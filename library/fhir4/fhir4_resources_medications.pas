unit fhir4_resources_medications;

{$I fhir4.inc}

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to
     endorse or promote products derived from this software without specific
     prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

}

{$I fhir.inc}

interface

// FHIR v4.0.0 generated 2019-01-21T22:41:56+11:00

uses
  SysUtils, Classes,
  fsl_base, fsl_utilities, fsl_stream,
  fhir_objects, fhir_utilities, 
  fhir4_base, fhir4_types, fhir4_resources_base;

Type
{$IFDEF FHIR_MEDICATION}
  TFhirMedicationIngredient = class;
  TFhirMedicationIngredientList = class;
  TFhirMedicationBatch = class;
  TFhirMedicationBatchList = class;
  TFhirMedication = class;
  TFhirMedicationList = class;
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
  TFhirMedicationKnowledgeRelatedMedicationKnowledge = class;
  TFhirMedicationKnowledgeRelatedMedicationKnowledgeList = class;
  TFhirMedicationKnowledgeMonograph = class;
  TFhirMedicationKnowledgeMonographList = class;
  TFhirMedicationKnowledgeIngredient = class;
  TFhirMedicationKnowledgeIngredientList = class;
  TFhirMedicationKnowledgeCost = class;
  TFhirMedicationKnowledgeCostList = class;
  TFhirMedicationKnowledgeMonitoringProgram = class;
  TFhirMedicationKnowledgeMonitoringProgramList = class;
  TFhirMedicationKnowledgeAdministrationGuidelines = class;
  TFhirMedicationKnowledgeAdministrationGuidelinesList = class;
  TFhirMedicationKnowledgeAdministrationGuidelinesDosage = class;
  TFhirMedicationKnowledgeAdministrationGuidelinesDosageList = class;
  TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics = class;
  TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList = class;
  TFhirMedicationKnowledgeMedicineClassification = class;
  TFhirMedicationKnowledgeMedicineClassificationList = class;
  TFhirMedicationKnowledgePackaging = class;
  TFhirMedicationKnowledgePackagingList = class;
  TFhirMedicationKnowledgeDrugCharacteristic = class;
  TFhirMedicationKnowledgeDrugCharacteristicList = class;
  TFhirMedicationKnowledgeRegulatory = class;
  TFhirMedicationKnowledgeRegulatoryList = class;
  TFhirMedicationKnowledgeRegulatorySubstitution = class;
  TFhirMedicationKnowledgeRegulatorySubstitutionList = class;
  TFhirMedicationKnowledgeRegulatorySchedule = class;
  TFhirMedicationKnowledgeRegulatoryScheduleList = class;
  TFhirMedicationKnowledgeRegulatoryMaxDispense = class;
  TFhirMedicationKnowledgeRegulatoryMaxDispenseList = class;
  TFhirMedicationKnowledgeKinetics = class;
  TFhirMedicationKnowledgeKineticsList = class;
  TFhirMedicationKnowledge = class;
  TFhirMedicationKnowledgeList = class;
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICINALPRODUCT}
  TFhirMedicinalProductName = class;
  TFhirMedicinalProductNameList = class;
  TFhirMedicinalProductNameNamePart = class;
  TFhirMedicinalProductNameNamePartList = class;
  TFhirMedicinalProductNameCountryLanguage = class;
  TFhirMedicinalProductNameCountryLanguageList = class;
  TFhirMedicinalProductManufacturingBusinessOperation = class;
  TFhirMedicinalProductManufacturingBusinessOperationList = class;
  TFhirMedicinalProductSpecialDesignation = class;
  TFhirMedicinalProductSpecialDesignationList = class;
  TFhirMedicinalProduct = class;
  TFhirMedicinalProductList = class;
{$ENDIF FHIR_MEDICINALPRODUCT}
{$IFDEF FHIR_MEDICINALPRODUCTAUTHORIZATION}
  TFhirMedicinalProductAuthorizationJurisdictionalAuthorization = class;
  TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList = class;
  TFhirMedicinalProductAuthorizationProcedure = class;
  TFhirMedicinalProductAuthorizationProcedureList = class;
  TFhirMedicinalProductAuthorization = class;
  TFhirMedicinalProductAuthorizationList = class;
{$ENDIF FHIR_MEDICINALPRODUCTAUTHORIZATION}
{$IFDEF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
  TFhirMedicinalProductContraindicationOtherTherapy = class;
  TFhirMedicinalProductContraindicationOtherTherapyList = class;
  TFhirMedicinalProductContraindication = class;
  TFhirMedicinalProductContraindicationList = class;
{$ENDIF FHIR_MEDICINALPRODUCTCONTRAINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINDICATION}
  TFhirMedicinalProductIndicationOtherTherapy = class;
  TFhirMedicinalProductIndicationOtherTherapyList = class;
  TFhirMedicinalProductIndication = class;
  TFhirMedicinalProductIndicationList = class;
{$ENDIF FHIR_MEDICINALPRODUCTINDICATION}
{$IFDEF FHIR_MEDICINALPRODUCTINGREDIENT}
  TFhirMedicinalProductIngredientSpecifiedSubstance = class;
  TFhirMedicinalProductIngredientSpecifiedSubstanceList = class;
  TFhirMedicinalProductIngredientSpecifiedSubstanceStrength = class;
  TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList = class;
  TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength = class;
  TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList = class;
  TFhirMedicinalProductIngredientSubstance = class;
  TFhirMedicinalProductIngredientSubstanceList = class;
  TFhirMedicinalProductIngredient = class;
  TFhirMedicinalProductIngredientList = class;
{$ENDIF FHIR_MEDICINALPRODUCTINGREDIENT}
{$IFDEF FHIR_MEDICINALPRODUCTINTERACTION}
  TFhirMedicinalProductInteractionInteractant = class;
  TFhirMedicinalProductInteractionInteractantList = class;
  TFhirMedicinalProductInteraction = class;
  TFhirMedicinalProductInteractionList = class;
{$ENDIF FHIR_MEDICINALPRODUCTINTERACTION}
{$IFDEF FHIR_MEDICINALPRODUCTMANUFACTURED}
  TFhirMedicinalProductManufactured = class;
  TFhirMedicinalProductManufacturedList = class;
{$ENDIF FHIR_MEDICINALPRODUCTMANUFACTURED}
{$IFDEF FHIR_MEDICINALPRODUCTPACKAGED}
  TFhirMedicinalProductPackagedBatchIdentifier = class;
  TFhirMedicinalProductPackagedBatchIdentifierList = class;
  TFhirMedicinalProductPackagedPackageItem = class;
  TFhirMedicinalProductPackagedPackageItemList = class;
  TFhirMedicinalProductPackaged = class;
  TFhirMedicinalProductPackagedList = class;
{$ENDIF FHIR_MEDICINALPRODUCTPACKAGED}
{$IFDEF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
  TFhirMedicinalProductPharmaceuticalCharacteristics = class;
  TFhirMedicinalProductPharmaceuticalCharacteristicsList = class;
  TFhirMedicinalProductPharmaceuticalRouteOfAdministration = class;
  TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList = class;
  TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies = class;
  TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList = class;
  TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod = class;
  TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList = class;
  TFhirMedicinalProductPharmaceutical = class;
  TFhirMedicinalProductPharmaceuticalList = class;
{$ENDIF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}
{$IFDEF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
  TFhirMedicinalProductUndesirableEffect = class;
  TFhirMedicinalProductUndesirableEffectList = class;
{$ENDIF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}
{$IFDEF FHIR_SUBSTANCE}
  TFhirSubstanceInstance = class;
  TFhirSubstanceInstanceList = class;
  TFhirSubstanceIngredient = class;
  TFhirSubstanceIngredientList = class;
  TFhirSubstance = class;
  TFhirSubstanceList = class;
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCENUCLEICACID}
  TFhirSubstanceNucleicAcidSubunit = class;
  TFhirSubstanceNucleicAcidSubunitList = class;
  TFhirSubstanceNucleicAcidSubunitLinkage = class;
  TFhirSubstanceNucleicAcidSubunitLinkageList = class;
  TFhirSubstanceNucleicAcidSubunitSugar = class;
  TFhirSubstanceNucleicAcidSubunitSugarList = class;
  TFhirSubstanceNucleicAcid = class;
  TFhirSubstanceNucleicAcidList = class;
{$ENDIF FHIR_SUBSTANCENUCLEICACID}
{$IFDEF FHIR_SUBSTANCEPOLYMER}
  TFhirSubstancePolymerMonomerSet = class;
  TFhirSubstancePolymerMonomerSetList = class;
  TFhirSubstancePolymerMonomerSetStartingMaterial = class;
  TFhirSubstancePolymerMonomerSetStartingMaterialList = class;
  TFhirSubstancePolymerRepeat = class;
  TFhirSubstancePolymerRepeatList = class;
  TFhirSubstancePolymerRepeatRepeatUnit = class;
  TFhirSubstancePolymerRepeatRepeatUnitList = class;
  TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation = class;
  TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList = class;
  TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation = class;
  TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList = class;
  TFhirSubstancePolymer = class;
  TFhirSubstancePolymerList = class;
{$ENDIF FHIR_SUBSTANCEPOLYMER}
{$IFDEF FHIR_SUBSTANCEPROTEIN}
  TFhirSubstanceProteinSubunit = class;
  TFhirSubstanceProteinSubunitList = class;
  TFhirSubstanceProtein = class;
  TFhirSubstanceProteinList = class;
{$ENDIF FHIR_SUBSTANCEPROTEIN}
{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}
  TFhirSubstanceReferenceInformationGene = class;
  TFhirSubstanceReferenceInformationGeneList = class;
  TFhirSubstanceReferenceInformationGeneElement = class;
  TFhirSubstanceReferenceInformationGeneElementList = class;
  TFhirSubstanceReferenceInformationClassification = class;
  TFhirSubstanceReferenceInformationClassificationList = class;
  TFhirSubstanceReferenceInformationTarget = class;
  TFhirSubstanceReferenceInformationTargetList = class;
  TFhirSubstanceReferenceInformation = class;
  TFhirSubstanceReferenceInformationList = class;
{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}
{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}
  TFhirSubstanceSourceMaterialFractionDescription = class;
  TFhirSubstanceSourceMaterialFractionDescriptionList = class;
  TFhirSubstanceSourceMaterialOrganism = class;
  TFhirSubstanceSourceMaterialOrganismList = class;
  TFhirSubstanceSourceMaterialOrganismAuthor = class;
  TFhirSubstanceSourceMaterialOrganismAuthorList = class;
  TFhirSubstanceSourceMaterialOrganismHybrid = class;
  TFhirSubstanceSourceMaterialOrganismHybridList = class;
  TFhirSubstanceSourceMaterialOrganismOrganismGeneral = class;
  TFhirSubstanceSourceMaterialOrganismOrganismGeneralList = class;
  TFhirSubstanceSourceMaterialPartDescription = class;
  TFhirSubstanceSourceMaterialPartDescriptionList = class;
  TFhirSubstanceSourceMaterial = class;
  TFhirSubstanceSourceMaterialList = class;
{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}
{$IFDEF FHIR_SUBSTANCESPECIFICATION}
  TFhirSubstanceSpecificationMoiety = class;
  TFhirSubstanceSpecificationMoietyList = class;
  TFhirSubstanceSpecificationProperty = class;
  TFhirSubstanceSpecificationPropertyList = class;
  TFhirSubstanceSpecificationStructure = class;
  TFhirSubstanceSpecificationStructureList = class;
  TFhirSubstanceSpecificationStructureIsotope = class;
  TFhirSubstanceSpecificationStructureIsotopeList = class;
  TFhirSubstanceSpecificationStructureIsotopeMolecularWeight = class;
  TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList = class;
  TFhirSubstanceSpecificationStructureRepresentation = class;
  TFhirSubstanceSpecificationStructureRepresentationList = class;
  TFhirSubstanceSpecificationCode = class;
  TFhirSubstanceSpecificationCodeList = class;
  TFhirSubstanceSpecificationName = class;
  TFhirSubstanceSpecificationNameList = class;
  TFhirSubstanceSpecificationNameOfficial = class;
  TFhirSubstanceSpecificationNameOfficialList = class;
  TFhirSubstanceSpecificationRelationship = class;
  TFhirSubstanceSpecificationRelationshipList = class;
  TFhirSubstanceSpecification = class;
  TFhirSubstanceSpecificationList = class;
{$ENDIF FHIR_SUBSTANCESPECIFICATION}

{$IFDEF FHIR_MEDICATION}

  // Identifies a particular constituent of interest in the product.
  TFhirMedicationIngredient = class (TFhirBackboneElement)
  protected
    FItem : TFhirType;
    FIsActive : TFhirBoolean;
    FStrength : TFhirRatio;
    Procedure SetItem(value : TFhirType);
    Procedure SetIsActive(value : TFhirBoolean);
    Function GetIsActiveST : Boolean;
    Procedure SetIsActiveST(value : Boolean);
    Procedure SetStrength(value : TFhirRatio);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationIngredient; overload;
    function Clone : TFhirMedicationIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The actual ingredient - either a substance (simple ingredient) or another medication of a medication. (defined for API consistency)
    property item : TFhirType read FItem write SetItem;
    // The actual ingredient - either a substance (simple ingredient) or another medication of a medication.
    property itemElement : TFhirType read FItem write SetItem;

    // Typed access to Indication of whether this ingredient affects the therapeutic action of the drug.
    property isActive : Boolean read GetIsActiveST write SetIsActiveST;
    // Indication of whether this ingredient affects the therapeutic action of the drug.
    property isActiveElement : TFhirBoolean read FIsActive write SetIsActive;

    // Typed access to Specifies how many (or how much) of the items there are in this Medication.  For example, 250 mg per tablet.  This is expressed as a ratio where the numerator is 250mg and the denominator is 1 tablet. (defined for API consistency)
    property strength : TFhirRatio read FStrength write SetStrength;
    // Specifies how many (or how much) of the items there are in this Medication.  For example, 250 mg per tablet.  This is expressed as a ratio where the numerator is 250mg and the denominator is 1 tablet.
    property strengthElement : TFhirRatio read FStrength write SetStrength;

  end;

  TFhirMedicationIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationIngredientList;
    function GetCurrent : TFhirMedicationIngredient;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationIngredient read GetCurrent;
  end;

  TFhirMedicationIngredientList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationIngredient;
    procedure SetItemN(index : Integer; value : TFhirMedicationIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationIngredientList; Overload;
    function Clone : TFhirMedicationIngredientList; Overload;
    function GetEnumerator : TFhirMedicationIngredientListEnumerator;
    

    //  Add a FhirMedicationIngredient to the end of the list.
    function Append : TFhirMedicationIngredient;

    
    // Add an already existing FhirMedicationIngredient to the end of the list.
    procedure AddItem(value : TFhirMedicationIngredient); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationIngredient) : Integer;
    

    // Insert FhirMedicationIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationIngredient;
    

    // Insert an existing FhirMedicationIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationIngredient);
    
    // Get the iIndexth FhirMedicationIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationIngredient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationIngredient;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicationIngredients[index : Integer] : TFhirMedicationIngredient read GetItemN write SetItemN; default;
  End;

  // Information that only applies to packages (not products).
  TFhirMedicationBatch = class (TFhirBackboneElement)
  protected
    FLotNumber : TFhirString;
    FExpirationDate : TFhirDateTime;
    Procedure SetLotNumber(value : TFhirString);
    Function GetLotNumberST : String;
    Procedure SetLotNumberST(value : String);
    Procedure SetExpirationDate(value : TFhirDateTime);
    Function GetExpirationDateST : TFslDateTime;
    Procedure SetExpirationDateST(value : TFslDateTime);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationBatch; overload;
    function Clone : TFhirMedicationBatch; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The assigned lot number of a batch of the specified product.
    property lotNumber : String read GetLotNumberST write SetLotNumberST;
    // The assigned lot number of a batch of the specified product.
    property lotNumberElement : TFhirString read FLotNumber write SetLotNumber;

    // Typed access to When this specific batch of product will expire.
    property expirationDate : TFslDateTime read GetExpirationDateST write SetExpirationDateST;
    // When this specific batch of product will expire.
    property expirationDateElement : TFhirDateTime read FExpirationDate write SetExpirationDate;

  end;

  TFhirMedicationBatchListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationBatchList;
    function GetCurrent : TFhirMedicationBatch;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationBatchList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationBatch read GetCurrent;
  end;

  TFhirMedicationBatchList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationBatch;
    procedure SetItemN(index : Integer; value : TFhirMedicationBatch);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationBatchList; Overload;
    function Clone : TFhirMedicationBatchList; Overload;
    function GetEnumerator : TFhirMedicationBatchListEnumerator;
    

    //  Add a FhirMedicationBatch to the end of the list.
    function Append : TFhirMedicationBatch;

    
    // Add an already existing FhirMedicationBatch to the end of the list.
    procedure AddItem(value : TFhirMedicationBatch); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationBatch) : Integer;
    

    // Insert FhirMedicationBatch before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationBatch;
    

    // Insert an existing FhirMedicationBatch before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationBatch);
    
    // Get the iIndexth FhirMedicationBatch. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationBatch);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationBatch;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicationBatches[index : Integer] : TFhirMedicationBatch read GetItemN write SetItemN; default;
  End;

  // This resource is primarily used for the identification and definition of a medication for the purposes of prescribing, dispensing, and administering a medication as well as for making statements about medication use.
  TFhirMedication = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FCode : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FManufacturer : TFhirReference{TFhirOrganization};
    FForm : TFhirCodeableConcept;
    FAmount : TFhirRatio;
    FingredientList : TFhirMedicationIngredientList;
    FBatch : TFhirMedicationBatch;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirMedicationStatusEnum;
    Procedure SetStatusST(value : TFhirMedicationStatusEnum);
    Procedure SetManufacturer(value : TFhirReference{TFhirOrganization});
    Procedure SetForm(value : TFhirCodeableConcept);
    Procedure SetAmount(value : TFhirRatio);
    function GetIngredientList : TFhirMedicationIngredientList;
    function GetHasIngredientList : Boolean;
    Procedure SetBatch(value : TFhirMedicationBatch);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedication; overload;
    function Clone : TFhirMedication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Business identifier for this medication.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A code (or set of codes) that specify this medication, or a textual description if no code is available. Usage note: This could be a standard medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local formulary code, optionally with translations to other code systems. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code (or set of codes) that specify this medication, or a textual description if no code is available. Usage note: This could be a standard medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local formulary code, optionally with translations to other code systems.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // A code to indicate if the medication is in active use.
    property status : TFhirMedicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Describes the details of the manufacturer of the medication product.  This is not intended to represent the distributor of a medication product. (defined for API consistency)
    property manufacturer : TFhirReference{TFhirOrganization} read FManufacturer write SetManufacturer;
    // Describes the details of the manufacturer of the medication product.  This is not intended to represent the distributor of a medication product.
    property manufacturerElement : TFhirReference{TFhirOrganization} read FManufacturer write SetManufacturer;

    // Typed access to Describes the form of the item.  Powder; tablets; capsule. (defined for API consistency)
    property form : TFhirCodeableConcept read FForm write SetForm;
    // Describes the form of the item.  Powder; tablets; capsule.
    property formElement : TFhirCodeableConcept read FForm write SetForm;

    // Typed access to Specific amount of the drug in the packaged product.  For example, when specifying a product that has the same strength (For example, Insulin glargine 100 unit per mL solution for injection), this attribute provides additional clarification of the package amount (For example, 3 mL, 10mL, etc.). (defined for API consistency)
    property amount : TFhirRatio read FAmount write SetAmount;
    // Specific amount of the drug in the packaged product.  For example, when specifying a product that has the same strength (For example, Insulin glargine 100 unit per mL solution for injection), this attribute provides additional clarification of the package amount (For example, 3 mL, 10mL, etc.).
    property amountElement : TFhirRatio read FAmount write SetAmount;

    // Identifies a particular constituent of interest in the product.
    property ingredientList : TFhirMedicationIngredientList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // Typed access to Information that only applies to packages (not products). (defined for API consistency)
    property batch : TFhirMedicationBatch read FBatch write SetBatch;
    // Information that only applies to packages (not products).
    property batchElement : TFhirMedicationBatch read FBatch write SetBatch;

  end;

  TFhirMedicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationList;
    function GetCurrent : TFhirMedication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedication read GetCurrent;
  end;

  TFhirMedicationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedication;
    procedure SetItemN(index : Integer; value : TFhirMedication);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationList; Overload;
    function Clone : TFhirMedicationList; Overload;
    function GetEnumerator : TFhirMedicationListEnumerator;
    

    //  Add a FhirMedication to the end of the list.
    function Append : TFhirMedication;

    
    // Add an already existing FhirMedication to the end of the list.
    procedure AddItem(value : TFhirMedication); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedication) : Integer;
    

    // Insert FhirMedication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedication;
    

    // Insert an existing FhirMedication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedication);
    
    // Get the iIndexth FhirMedication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedication;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedications[index : Integer] : TFhirMedication read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATION}

{$IFDEF FHIR_MEDICATIONKNOWLEDGE}

  // Associated or related knowledge about a medication.
  TFhirMedicationKnowledgeRelatedMedicationKnowledge = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FreferenceList : TFhirReferenceList{TFhirMedicationKnowledge};
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetReferenceList : TFhirReferenceList{TFhirMedicationKnowledge};
    function GetHasReferenceList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeRelatedMedicationKnowledge; overload;
    function Clone : TFhirMedicationKnowledgeRelatedMedicationKnowledge; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The category of the associated medication knowledge reference. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of the associated medication knowledge reference.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Associated documentation about the associated medication knowledge.
    property referenceList : TFhirReferenceList{TFhirMedicationKnowledge} read GetReferenceList;
    property hasReferenceList : boolean read GetHasReferenceList;

  end;

  TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
    function GetCurrent : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeRelatedMedicationKnowledge read GetCurrent;
  end;

  TFhirMedicationKnowledgeRelatedMedicationKnowledgeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeRelatedMedicationKnowledge);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList; Overload;
    function Clone : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList; Overload;
    function GetEnumerator : TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator;
    

    //  Add a FhirMedicationKnowledgeRelatedMedicationKnowledge to the end of the list.
    function Append : TFhirMedicationKnowledgeRelatedMedicationKnowledge;

    
    // Add an already existing FhirMedicationKnowledgeRelatedMedicationKnowledge to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeRelatedMedicationKnowledge); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeRelatedMedicationKnowledge) : Integer;
    

    // Insert FhirMedicationKnowledgeRelatedMedicationKnowledge before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
    

    // Insert an existing FhirMedicationKnowledgeRelatedMedicationKnowledge before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeRelatedMedicationKnowledge);
    
    // Get the iIndexth FhirMedicationKnowledgeRelatedMedicationKnowledge. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeRelatedMedicationKnowledge);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicationKnowledgeRelatedMedicationKnowledges[index : Integer] : TFhirMedicationKnowledgeRelatedMedicationKnowledge read GetItemN write SetItemN; default;
  End;

  // Associated documentation about the medication.
  TFhirMedicationKnowledgeMonograph = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FSource : TFhirReference{TFhirDocumentReference};
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetSource(value : TFhirReference{TFhirDocumentReference});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeMonograph; overload;
    function Clone : TFhirMedicationKnowledgeMonograph; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The category of documentation about the medication. (e.g. professional monograph, patient education monograph). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of documentation about the medication. (e.g. professional monograph, patient education monograph).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Associated documentation about the medication. (defined for API consistency)
    property source : TFhirReference{TFhirDocumentReference} read FSource write SetSource;
    // Associated documentation about the medication.
    property sourceElement : TFhirReference{TFhirDocumentReference} read FSource write SetSource;

  end;

  TFhirMedicationKnowledgeMonographListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeMonographList;
    function GetCurrent : TFhirMedicationKnowledgeMonograph;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeMonographList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeMonograph read GetCurrent;
  end;

  TFhirMedicationKnowledgeMonographList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationKnowledgeMonograph;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeMonograph);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationKnowledgeMonographList; Overload;
    function Clone : TFhirMedicationKnowledgeMonographList; Overload;
    function GetEnumerator : TFhirMedicationKnowledgeMonographListEnumerator;
    

    //  Add a FhirMedicationKnowledgeMonograph to the end of the list.
    function Append : TFhirMedicationKnowledgeMonograph;

    
    // Add an already existing FhirMedicationKnowledgeMonograph to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeMonograph); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeMonograph) : Integer;
    

    // Insert FhirMedicationKnowledgeMonograph before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeMonograph;
    

    // Insert an existing FhirMedicationKnowledgeMonograph before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeMonograph);
    
    // Get the iIndexth FhirMedicationKnowledgeMonograph. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeMonograph);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeMonograph;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicationKnowledgeMonographs[index : Integer] : TFhirMedicationKnowledgeMonograph read GetItemN write SetItemN; default;
  End;

  // Identifies a particular constituent of interest in the product.
  TFhirMedicationKnowledgeIngredient = class (TFhirBackboneElement)
  protected
    FItem : TFhirType;
    FIsActive : TFhirBoolean;
    FStrength : TFhirRatio;
    Procedure SetItem(value : TFhirType);
    Procedure SetIsActive(value : TFhirBoolean);
    Function GetIsActiveST : Boolean;
    Procedure SetIsActiveST(value : Boolean);
    Procedure SetStrength(value : TFhirRatio);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeIngredient; overload;
    function Clone : TFhirMedicationKnowledgeIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The actual ingredient - either a substance (simple ingredient) or another medication. (defined for API consistency)
    property item : TFhirType read FItem write SetItem;
    // The actual ingredient - either a substance (simple ingredient) or another medication.
    property itemElement : TFhirType read FItem write SetItem;

    // Typed access to Indication of whether this ingredient affects the therapeutic action of the drug.
    property isActive : Boolean read GetIsActiveST write SetIsActiveST;
    // Indication of whether this ingredient affects the therapeutic action of the drug.
    property isActiveElement : TFhirBoolean read FIsActive write SetIsActive;

    // Typed access to Specifies how many (or how much) of the items there are in this Medication.  For example, 250 mg per tablet.  This is expressed as a ratio where the numerator is 250mg and the denominator is 1 tablet. (defined for API consistency)
    property strength : TFhirRatio read FStrength write SetStrength;
    // Specifies how many (or how much) of the items there are in this Medication.  For example, 250 mg per tablet.  This is expressed as a ratio where the numerator is 250mg and the denominator is 1 tablet.
    property strengthElement : TFhirRatio read FStrength write SetStrength;

  end;

  TFhirMedicationKnowledgeIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeIngredientList;
    function GetCurrent : TFhirMedicationKnowledgeIngredient;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeIngredient read GetCurrent;
  end;

  TFhirMedicationKnowledgeIngredientList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationKnowledgeIngredient;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationKnowledgeIngredientList; Overload;
    function Clone : TFhirMedicationKnowledgeIngredientList; Overload;
    function GetEnumerator : TFhirMedicationKnowledgeIngredientListEnumerator;
    

    //  Add a FhirMedicationKnowledgeIngredient to the end of the list.
    function Append : TFhirMedicationKnowledgeIngredient;

    
    // Add an already existing FhirMedicationKnowledgeIngredient to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeIngredient); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeIngredient) : Integer;
    

    // Insert FhirMedicationKnowledgeIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeIngredient;
    

    // Insert an existing FhirMedicationKnowledgeIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeIngredient);
    
    // Get the iIndexth FhirMedicationKnowledgeIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeIngredient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeIngredient;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicationKnowledgeIngredients[index : Integer] : TFhirMedicationKnowledgeIngredient read GetItemN write SetItemN; default;
  End;

  // The price of the medication.
  TFhirMedicationKnowledgeCost = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FSource : TFhirString;
    FCost : TFhirMoney;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetSource(value : TFhirString);
    Function GetSourceST : String;
    Procedure SetSourceST(value : String);
    Procedure SetCost(value : TFhirMoney);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeCost; overload;
    function Clone : TFhirMedicationKnowledgeCost; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The category of the cost information.  For example, manufacturers' cost, patient cost, claim reimbursement cost, actual acquisition cost. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of the cost information.  For example, manufacturers' cost, patient cost, claim reimbursement cost, actual acquisition cost.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The source or owner that assigns the price to the medication.
    property source : String read GetSourceST write SetSourceST;
    // The source or owner that assigns the price to the medication.
    property sourceElement : TFhirString read FSource write SetSource;

    // Typed access to The price of the medication. (defined for API consistency)
    property cost : TFhirMoney read FCost write SetCost;
    // The price of the medication.
    property costElement : TFhirMoney read FCost write SetCost;

  end;

  TFhirMedicationKnowledgeCostListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeCostList;
    function GetCurrent : TFhirMedicationKnowledgeCost;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeCostList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeCost read GetCurrent;
  end;

  TFhirMedicationKnowledgeCostList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationKnowledgeCost;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeCost);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationKnowledgeCostList; Overload;
    function Clone : TFhirMedicationKnowledgeCostList; Overload;
    function GetEnumerator : TFhirMedicationKnowledgeCostListEnumerator;
    

    //  Add a FhirMedicationKnowledgeCost to the end of the list.
    function Append : TFhirMedicationKnowledgeCost;

    
    // Add an already existing FhirMedicationKnowledgeCost to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeCost); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeCost) : Integer;
    

    // Insert FhirMedicationKnowledgeCost before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeCost;
    

    // Insert an existing FhirMedicationKnowledgeCost before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeCost);
    
    // Get the iIndexth FhirMedicationKnowledgeCost. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeCost);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeCost;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicationKnowledgeCosts[index : Integer] : TFhirMedicationKnowledgeCost read GetItemN write SetItemN; default;
  End;

  // The program under which the medication is reviewed.
  TFhirMedicationKnowledgeMonitoringProgram = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FName : TFhirString;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeMonitoringProgram; overload;
    function Clone : TFhirMedicationKnowledgeMonitoringProgram; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Type of program under which the medication is monitored. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of program under which the medication is monitored.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Name of the reviewing program.
    property name : String read GetNameST write SetNameST;
    // Name of the reviewing program.
    property nameElement : TFhirString read FName write SetName;

  end;

  TFhirMedicationKnowledgeMonitoringProgramListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeMonitoringProgramList;
    function GetCurrent : TFhirMedicationKnowledgeMonitoringProgram;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeMonitoringProgramList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeMonitoringProgram read GetCurrent;
  end;

  TFhirMedicationKnowledgeMonitoringProgramList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationKnowledgeMonitoringProgram;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeMonitoringProgram);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationKnowledgeMonitoringProgramList; Overload;
    function Clone : TFhirMedicationKnowledgeMonitoringProgramList; Overload;
    function GetEnumerator : TFhirMedicationKnowledgeMonitoringProgramListEnumerator;
    

    //  Add a FhirMedicationKnowledgeMonitoringProgram to the end of the list.
    function Append : TFhirMedicationKnowledgeMonitoringProgram;

    
    // Add an already existing FhirMedicationKnowledgeMonitoringProgram to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeMonitoringProgram); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeMonitoringProgram) : Integer;
    

    // Insert FhirMedicationKnowledgeMonitoringProgram before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeMonitoringProgram;
    

    // Insert an existing FhirMedicationKnowledgeMonitoringProgram before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeMonitoringProgram);
    
    // Get the iIndexth FhirMedicationKnowledgeMonitoringProgram. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeMonitoringProgram);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeMonitoringProgram;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicationKnowledgeMonitoringPrograms[index : Integer] : TFhirMedicationKnowledgeMonitoringProgram read GetItemN write SetItemN; default;
  End;

  // Guidelines for the administration of the medication.
  TFhirMedicationKnowledgeAdministrationGuidelines = class (TFhirBackboneElement)
  protected
    FdosageList : TFhirMedicationKnowledgeAdministrationGuidelinesDosageList;
    FIndication : TFhirType;
    FpatientCharacteristicsList : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList;
    function GetDosageList : TFhirMedicationKnowledgeAdministrationGuidelinesDosageList;
    function GetHasDosageList : Boolean;
    Procedure SetIndication(value : TFhirType);
    function GetPatientCharacteristicsList : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList;
    function GetHasPatientCharacteristicsList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeAdministrationGuidelines; overload;
    function Clone : TFhirMedicationKnowledgeAdministrationGuidelines; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Dosage for the medication for the specific guidelines.
    property dosageList : TFhirMedicationKnowledgeAdministrationGuidelinesDosageList read GetDosageList;
    property hasDosageList : boolean read GetHasDosageList;

    // Typed access to Indication for use that apply to the specific administration guidelines. (defined for API consistency)
    property indication : TFhirType read FIndication write SetIndication;
    // Indication for use that apply to the specific administration guidelines.
    property indicationElement : TFhirType read FIndication write SetIndication;

    // Characteristics of the patient that are relevant to the administration guidelines (for example, height, weight, gender, etc.).
    property patientCharacteristicsList : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList read GetPatientCharacteristicsList;
    property hasPatientCharacteristicsList : boolean read GetHasPatientCharacteristicsList;

  end;

  TFhirMedicationKnowledgeAdministrationGuidelinesListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeAdministrationGuidelinesList;
    function GetCurrent : TFhirMedicationKnowledgeAdministrationGuidelines;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeAdministrationGuidelinesList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeAdministrationGuidelines read GetCurrent;
  end;

  TFhirMedicationKnowledgeAdministrationGuidelinesList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelines;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelines);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationKnowledgeAdministrationGuidelinesList; Overload;
    function Clone : TFhirMedicationKnowledgeAdministrationGuidelinesList; Overload;
    function GetEnumerator : TFhirMedicationKnowledgeAdministrationGuidelinesListEnumerator;
    

    //  Add a FhirMedicationKnowledgeAdministrationGuidelines to the end of the list.
    function Append : TFhirMedicationKnowledgeAdministrationGuidelines;

    
    // Add an already existing FhirMedicationKnowledgeAdministrationGuidelines to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeAdministrationGuidelines); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeAdministrationGuidelines) : Integer;
    

    // Insert FhirMedicationKnowledgeAdministrationGuidelines before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelines;
    

    // Insert an existing FhirMedicationKnowledgeAdministrationGuidelines before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelines);
    
    // Get the iIndexth FhirMedicationKnowledgeAdministrationGuidelines. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelines);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelines;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicationKnowledgeAdministrationGuidelines[index : Integer] : TFhirMedicationKnowledgeAdministrationGuidelines read GetItemN write SetItemN; default;
  End;

  // Dosage for the medication for the specific guidelines.
  TFhirMedicationKnowledgeAdministrationGuidelinesDosage = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FdosageList : TFhirDosageList;
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetDosageList : TFhirDosageList;
    function GetHasDosageList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeAdministrationGuidelinesDosage; overload;
    function Clone : TFhirMedicationKnowledgeAdministrationGuidelinesDosage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The type of dosage (for example, prophylaxis, maintenance, therapeutic, etc.). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of dosage (for example, prophylaxis, maintenance, therapeutic, etc.).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Dosage for the medication for the specific guidelines.
    property dosageList : TFhirDosageList read GetDosageList;
    property hasDosageList : boolean read GetHasDosageList;

  end;

  TFhirMedicationKnowledgeAdministrationGuidelinesDosageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeAdministrationGuidelinesDosageList;
    function GetCurrent : TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeAdministrationGuidelinesDosageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeAdministrationGuidelinesDosage read GetCurrent;
  end;

  TFhirMedicationKnowledgeAdministrationGuidelinesDosageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationKnowledgeAdministrationGuidelinesDosageList; Overload;
    function Clone : TFhirMedicationKnowledgeAdministrationGuidelinesDosageList; Overload;
    function GetEnumerator : TFhirMedicationKnowledgeAdministrationGuidelinesDosageListEnumerator;
    

    //  Add a FhirMedicationKnowledgeAdministrationGuidelinesDosage to the end of the list.
    function Append : TFhirMedicationKnowledgeAdministrationGuidelinesDosage;

    
    // Add an already existing FhirMedicationKnowledgeAdministrationGuidelinesDosage to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeAdministrationGuidelinesDosage); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeAdministrationGuidelinesDosage) : Integer;
    

    // Insert FhirMedicationKnowledgeAdministrationGuidelinesDosage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
    

    // Insert an existing FhirMedicationKnowledgeAdministrationGuidelinesDosage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
    
    // Get the iIndexth FhirMedicationKnowledgeAdministrationGuidelinesDosage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicationKnowledgeAdministrationGuidelinesDosages[index : Integer] : TFhirMedicationKnowledgeAdministrationGuidelinesDosage read GetItemN write SetItemN; default;
  End;

  // Characteristics of the patient that are relevant to the administration guidelines (for example, height, weight, gender, etc.).
  TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics = class (TFhirBackboneElement)
  protected
    FCharacteristic : TFhirType;
    FvalueList : TFhirStringList;
    Procedure SetCharacteristic(value : TFhirType);
    function GetValueList : TFhirStringList;
    function GetHasValueList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics; overload;
    function Clone : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Specific characteristic that is relevant to the administration guideline (e.g. height, weight, gender). (defined for API consistency)
    property characteristic : TFhirType read FCharacteristic write SetCharacteristic;
    // Specific characteristic that is relevant to the administration guideline (e.g. height, weight, gender).
    property characteristicElement : TFhirType read FCharacteristic write SetCharacteristic;

    // The specific characteristic (e.g. height, weight, gender, etc.).
    property valueList : TFhirStringList read GetValueList;
    property hasValueList : boolean read GetHasValueList;

  end;

  TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList;
    function GetCurrent : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics read GetCurrent;
  end;

  TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList; Overload;
    function Clone : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList; Overload;
    function GetEnumerator : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsListEnumerator;
    

    //  Add a FhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics to the end of the list.
    function Append : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;

    
    // Add an already existing FhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics) : Integer;
    

    // Insert FhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
    

    // Insert an existing FhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
    
    // Get the iIndexth FhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics[index : Integer] : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics read GetItemN write SetItemN; default;
  End;

  // Categorization of the medication within a formulary or classification system.
  TFhirMedicationKnowledgeMedicineClassification = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FclassificationList : TFhirCodeableConceptList;
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetClassificationList : TFhirCodeableConceptList;
    function GetHasClassificationList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeMedicineClassification; overload;
    function Clone : TFhirMedicationKnowledgeMedicineClassification; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The type of category for the medication (for example, therapeutic classification, therapeutic sub-classification). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of category for the medication (for example, therapeutic classification, therapeutic sub-classification).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Specific category assigned to the medication (e.g. anti-infective, anti-hypertensive, antibiotic, etc.).
    property classificationList : TFhirCodeableConceptList read GetClassificationList;
    property hasClassificationList : boolean read GetHasClassificationList;

  end;

  TFhirMedicationKnowledgeMedicineClassificationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeMedicineClassificationList;
    function GetCurrent : TFhirMedicationKnowledgeMedicineClassification;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeMedicineClassificationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeMedicineClassification read GetCurrent;
  end;

  TFhirMedicationKnowledgeMedicineClassificationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationKnowledgeMedicineClassification;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeMedicineClassification);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationKnowledgeMedicineClassificationList; Overload;
    function Clone : TFhirMedicationKnowledgeMedicineClassificationList; Overload;
    function GetEnumerator : TFhirMedicationKnowledgeMedicineClassificationListEnumerator;
    

    //  Add a FhirMedicationKnowledgeMedicineClassification to the end of the list.
    function Append : TFhirMedicationKnowledgeMedicineClassification;

    
    // Add an already existing FhirMedicationKnowledgeMedicineClassification to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeMedicineClassification); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeMedicineClassification) : Integer;
    

    // Insert FhirMedicationKnowledgeMedicineClassification before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeMedicineClassification;
    

    // Insert an existing FhirMedicationKnowledgeMedicineClassification before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeMedicineClassification);
    
    // Get the iIndexth FhirMedicationKnowledgeMedicineClassification. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeMedicineClassification);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeMedicineClassification;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicationKnowledgeMedicineClassifications[index : Integer] : TFhirMedicationKnowledgeMedicineClassification read GetItemN write SetItemN; default;
  End;

  // Information that only applies to packages (not products).
  TFhirMedicationKnowledgePackaging = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgePackaging; overload;
    function Clone : TFhirMedicationKnowledgePackaging; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A code that defines the specific type of packaging that the medication can be found in (e.g. blister sleeve, tube, bottle). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code that defines the specific type of packaging that the medication can be found in (e.g. blister sleeve, tube, bottle).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The number of product units the package would contain if fully loaded. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of product units the package would contain if fully loaded.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

  end;

  TFhirMedicationKnowledgePackagingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgePackagingList;
    function GetCurrent : TFhirMedicationKnowledgePackaging;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgePackagingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgePackaging read GetCurrent;
  end;

  TFhirMedicationKnowledgePackagingList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationKnowledgePackaging;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgePackaging);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationKnowledgePackagingList; Overload;
    function Clone : TFhirMedicationKnowledgePackagingList; Overload;
    function GetEnumerator : TFhirMedicationKnowledgePackagingListEnumerator;
    

    //  Add a FhirMedicationKnowledgePackaging to the end of the list.
    function Append : TFhirMedicationKnowledgePackaging;

    
    // Add an already existing FhirMedicationKnowledgePackaging to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgePackaging); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgePackaging) : Integer;
    

    // Insert FhirMedicationKnowledgePackaging before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgePackaging;
    

    // Insert an existing FhirMedicationKnowledgePackaging before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgePackaging);
    
    // Get the iIndexth FhirMedicationKnowledgePackaging. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgePackaging);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgePackaging;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicationKnowledgePackagings[index : Integer] : TFhirMedicationKnowledgePackaging read GetItemN write SetItemN; default;
  End;

  // Specifies descriptive properties of the medicine, such as color, shape, imprints, etc.
  TFhirMedicationKnowledgeDrugCharacteristic = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirType;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeDrugCharacteristic; overload;
    function Clone : TFhirMedicationKnowledgeDrugCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A code specifying which characteristic of the medicine is being described (for example, colour, shape, imprint). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code specifying which characteristic of the medicine is being described (for example, colour, shape, imprint).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Description of the characteristic. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // Description of the characteristic.
    property valueElement : TFhirType read FValue write SetValue;

  end;

  TFhirMedicationKnowledgeDrugCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeDrugCharacteristicList;
    function GetCurrent : TFhirMedicationKnowledgeDrugCharacteristic;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeDrugCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeDrugCharacteristic read GetCurrent;
  end;

  TFhirMedicationKnowledgeDrugCharacteristicList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationKnowledgeDrugCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeDrugCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationKnowledgeDrugCharacteristicList; Overload;
    function Clone : TFhirMedicationKnowledgeDrugCharacteristicList; Overload;
    function GetEnumerator : TFhirMedicationKnowledgeDrugCharacteristicListEnumerator;
    

    //  Add a FhirMedicationKnowledgeDrugCharacteristic to the end of the list.
    function Append : TFhirMedicationKnowledgeDrugCharacteristic;

    
    // Add an already existing FhirMedicationKnowledgeDrugCharacteristic to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeDrugCharacteristic); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeDrugCharacteristic) : Integer;
    

    // Insert FhirMedicationKnowledgeDrugCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeDrugCharacteristic;
    

    // Insert an existing FhirMedicationKnowledgeDrugCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeDrugCharacteristic);
    
    // Get the iIndexth FhirMedicationKnowledgeDrugCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeDrugCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeDrugCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicationKnowledgeDrugCharacteristics[index : Integer] : TFhirMedicationKnowledgeDrugCharacteristic read GetItemN write SetItemN; default;
  End;

  // Regulatory information about a medication.
  TFhirMedicationKnowledgeRegulatory = class (TFhirBackboneElement)
  protected
    FRegulatoryAuthority : TFhirReference{TFhirOrganization};
    FsubstitutionList : TFhirMedicationKnowledgeRegulatorySubstitutionList;
    FscheduleList : TFhirMedicationKnowledgeRegulatoryScheduleList;
    FMaxDispense : TFhirMedicationKnowledgeRegulatoryMaxDispense;
    Procedure SetRegulatoryAuthority(value : TFhirReference{TFhirOrganization});
    function GetSubstitutionList : TFhirMedicationKnowledgeRegulatorySubstitutionList;
    function GetHasSubstitutionList : Boolean;
    function GetScheduleList : TFhirMedicationKnowledgeRegulatoryScheduleList;
    function GetHasScheduleList : Boolean;
    Procedure SetMaxDispense(value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeRegulatory; overload;
    function Clone : TFhirMedicationKnowledgeRegulatory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The authority that is specifying the regulations. (defined for API consistency)
    property regulatoryAuthority : TFhirReference{TFhirOrganization} read FRegulatoryAuthority write SetRegulatoryAuthority;
    // The authority that is specifying the regulations.
    property regulatoryAuthorityElement : TFhirReference{TFhirOrganization} read FRegulatoryAuthority write SetRegulatoryAuthority;

    // Specifies if changes are allowed when dispensing a medication from a regulatory perspective.
    property substitutionList : TFhirMedicationKnowledgeRegulatorySubstitutionList read GetSubstitutionList;
    property hasSubstitutionList : boolean read GetHasSubstitutionList;

    // Specifies the schedule of a medication in jurisdiction.
    property scheduleList : TFhirMedicationKnowledgeRegulatoryScheduleList read GetScheduleList;
    property hasScheduleList : boolean read GetHasScheduleList;

    // Typed access to The maximum number of units of the medication that can be dispensed in a period. (defined for API consistency)
    property maxDispense : TFhirMedicationKnowledgeRegulatoryMaxDispense read FMaxDispense write SetMaxDispense;
    // The maximum number of units of the medication that can be dispensed in a period.
    property maxDispenseElement : TFhirMedicationKnowledgeRegulatoryMaxDispense read FMaxDispense write SetMaxDispense;

  end;

  TFhirMedicationKnowledgeRegulatoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeRegulatoryList;
    function GetCurrent : TFhirMedicationKnowledgeRegulatory;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeRegulatoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeRegulatory read GetCurrent;
  end;

  TFhirMedicationKnowledgeRegulatoryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationKnowledgeRegulatory;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeRegulatory);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationKnowledgeRegulatoryList; Overload;
    function Clone : TFhirMedicationKnowledgeRegulatoryList; Overload;
    function GetEnumerator : TFhirMedicationKnowledgeRegulatoryListEnumerator;
    

    //  Add a FhirMedicationKnowledgeRegulatory to the end of the list.
    function Append : TFhirMedicationKnowledgeRegulatory;

    
    // Add an already existing FhirMedicationKnowledgeRegulatory to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeRegulatory); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeRegulatory) : Integer;
    

    // Insert FhirMedicationKnowledgeRegulatory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeRegulatory;
    

    // Insert an existing FhirMedicationKnowledgeRegulatory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeRegulatory);
    
    // Get the iIndexth FhirMedicationKnowledgeRegulatory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeRegulatory);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeRegulatory;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicationKnowledgeRegulatories[index : Integer] : TFhirMedicationKnowledgeRegulatory read GetItemN write SetItemN; default;
  End;

  // Specifies if changes are allowed when dispensing a medication from a regulatory perspective.
  TFhirMedicationKnowledgeRegulatorySubstitution = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAllowed : TFhirBoolean;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetAllowed(value : TFhirBoolean);
    Function GetAllowedST : Boolean;
    Procedure SetAllowedST(value : Boolean);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeRegulatorySubstitution; overload;
    function Clone : TFhirMedicationKnowledgeRegulatorySubstitution; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Specifies the type of substitution allowed. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Specifies the type of substitution allowed.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Specifies if regulation allows for changes in the medication when dispensing.
    property allowed : Boolean read GetAllowedST write SetAllowedST;
    // Specifies if regulation allows for changes in the medication when dispensing.
    property allowedElement : TFhirBoolean read FAllowed write SetAllowed;

  end;

  TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeRegulatorySubstitutionList;
    function GetCurrent : TFhirMedicationKnowledgeRegulatorySubstitution;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeRegulatorySubstitutionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeRegulatorySubstitution read GetCurrent;
  end;

  TFhirMedicationKnowledgeRegulatorySubstitutionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationKnowledgeRegulatorySubstitution;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeRegulatorySubstitution);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationKnowledgeRegulatorySubstitutionList; Overload;
    function Clone : TFhirMedicationKnowledgeRegulatorySubstitutionList; Overload;
    function GetEnumerator : TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator;
    

    //  Add a FhirMedicationKnowledgeRegulatorySubstitution to the end of the list.
    function Append : TFhirMedicationKnowledgeRegulatorySubstitution;

    
    // Add an already existing FhirMedicationKnowledgeRegulatorySubstitution to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeRegulatorySubstitution); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeRegulatorySubstitution) : Integer;
    

    // Insert FhirMedicationKnowledgeRegulatorySubstitution before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeRegulatorySubstitution;
    

    // Insert an existing FhirMedicationKnowledgeRegulatorySubstitution before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeRegulatorySubstitution);
    
    // Get the iIndexth FhirMedicationKnowledgeRegulatorySubstitution. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeRegulatorySubstitution);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeRegulatorySubstitution;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicationKnowledgeRegulatorySubstitutions[index : Integer] : TFhirMedicationKnowledgeRegulatorySubstitution read GetItemN write SetItemN; default;
  End;

  // Specifies the schedule of a medication in jurisdiction.
  TFhirMedicationKnowledgeRegulatorySchedule = class (TFhirBackboneElement)
  protected
    FSchedule : TFhirCodeableConcept;
    Procedure SetSchedule(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeRegulatorySchedule; overload;
    function Clone : TFhirMedicationKnowledgeRegulatorySchedule; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Specifies the specific drug schedule. (defined for API consistency)
    property schedule : TFhirCodeableConcept read FSchedule write SetSchedule;
    // Specifies the specific drug schedule.
    property scheduleElement : TFhirCodeableConcept read FSchedule write SetSchedule;

  end;

  TFhirMedicationKnowledgeRegulatoryScheduleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeRegulatoryScheduleList;
    function GetCurrent : TFhirMedicationKnowledgeRegulatorySchedule;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeRegulatoryScheduleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeRegulatorySchedule read GetCurrent;
  end;

  TFhirMedicationKnowledgeRegulatoryScheduleList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationKnowledgeRegulatorySchedule;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeRegulatorySchedule);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationKnowledgeRegulatoryScheduleList; Overload;
    function Clone : TFhirMedicationKnowledgeRegulatoryScheduleList; Overload;
    function GetEnumerator : TFhirMedicationKnowledgeRegulatoryScheduleListEnumerator;
    

    //  Add a FhirMedicationKnowledgeRegulatorySchedule to the end of the list.
    function Append : TFhirMedicationKnowledgeRegulatorySchedule;

    
    // Add an already existing FhirMedicationKnowledgeRegulatorySchedule to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeRegulatorySchedule); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeRegulatorySchedule) : Integer;
    

    // Insert FhirMedicationKnowledgeRegulatorySchedule before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeRegulatorySchedule;
    

    // Insert an existing FhirMedicationKnowledgeRegulatorySchedule before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeRegulatorySchedule);
    
    // Get the iIndexth FhirMedicationKnowledgeRegulatorySchedule. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeRegulatorySchedule);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeRegulatorySchedule;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicationKnowledgeRegulatorySchedules[index : Integer] : TFhirMedicationKnowledgeRegulatorySchedule read GetItemN write SetItemN; default;
  End;

  // The maximum number of units of the medication that can be dispensed in a period.
  TFhirMedicationKnowledgeRegulatoryMaxDispense = class (TFhirBackboneElement)
  protected
    FQuantity : TFhirQuantity;
    FPeriod : TFhirDuration;
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetPeriod(value : TFhirDuration);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeRegulatoryMaxDispense; overload;
    function Clone : TFhirMedicationKnowledgeRegulatoryMaxDispense; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The maximum number of units of the medication that can be dispensed. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The maximum number of units of the medication that can be dispensed.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The period that applies to the maximum number of units. (defined for API consistency)
    property period : TFhirDuration read FPeriod write SetPeriod;
    // The period that applies to the maximum number of units.
    property periodElement : TFhirDuration read FPeriod write SetPeriod;

  end;

  TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeRegulatoryMaxDispenseList;
    function GetCurrent : TFhirMedicationKnowledgeRegulatoryMaxDispense;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeRegulatoryMaxDispenseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeRegulatoryMaxDispense read GetCurrent;
  end;

  TFhirMedicationKnowledgeRegulatoryMaxDispenseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationKnowledgeRegulatoryMaxDispense;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationKnowledgeRegulatoryMaxDispenseList; Overload;
    function Clone : TFhirMedicationKnowledgeRegulatoryMaxDispenseList; Overload;
    function GetEnumerator : TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator;
    

    //  Add a FhirMedicationKnowledgeRegulatoryMaxDispense to the end of the list.
    function Append : TFhirMedicationKnowledgeRegulatoryMaxDispense;

    
    // Add an already existing FhirMedicationKnowledgeRegulatoryMaxDispense to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeRegulatoryMaxDispense); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeRegulatoryMaxDispense) : Integer;
    

    // Insert FhirMedicationKnowledgeRegulatoryMaxDispense before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeRegulatoryMaxDispense;
    

    // Insert an existing FhirMedicationKnowledgeRegulatoryMaxDispense before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
    
    // Get the iIndexth FhirMedicationKnowledgeRegulatoryMaxDispense. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeRegulatoryMaxDispense;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicationKnowledgeRegulatoryMaxDispenses[index : Integer] : TFhirMedicationKnowledgeRegulatoryMaxDispense read GetItemN write SetItemN; default;
  End;

  // The time course of drug absorption, distribution, metabolism and excretion of a medication from the body.
  TFhirMedicationKnowledgeKinetics = class (TFhirBackboneElement)
  protected
    FareaUnderCurveList : TFhirQuantityList;
    FlethalDose50List : TFhirQuantityList;
    FHalfLifePeriod : TFhirDuration;
    function GetAreaUnderCurveList : TFhirQuantityList;
    function GetHasAreaUnderCurveList : Boolean;
    function GetLethalDose50List : TFhirQuantityList;
    function GetHasLethalDose50List : Boolean;
    Procedure SetHalfLifePeriod(value : TFhirDuration);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeKinetics; overload;
    function Clone : TFhirMedicationKnowledgeKinetics; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The drug concentration measured at certain discrete points in time.
    property areaUnderCurveList : TFhirQuantityList read GetAreaUnderCurveList;
    property hasAreaUnderCurveList : boolean read GetHasAreaUnderCurveList;

    // The median lethal dose of a drug.
    property lethalDose50List : TFhirQuantityList read GetLethalDose50List;
    property hasLethalDose50List : boolean read GetHasLethalDose50List;

    // Typed access to The time required for any specified property (e.g., the concentration of a substance in the body) to decrease by half. (defined for API consistency)
    property halfLifePeriod : TFhirDuration read FHalfLifePeriod write SetHalfLifePeriod;
    // The time required for any specified property (e.g., the concentration of a substance in the body) to decrease by half.
    property halfLifePeriodElement : TFhirDuration read FHalfLifePeriod write SetHalfLifePeriod;

  end;

  TFhirMedicationKnowledgeKineticsListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeKineticsList;
    function GetCurrent : TFhirMedicationKnowledgeKinetics;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeKineticsList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeKinetics read GetCurrent;
  end;

  TFhirMedicationKnowledgeKineticsList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationKnowledgeKinetics;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeKinetics);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationKnowledgeKineticsList; Overload;
    function Clone : TFhirMedicationKnowledgeKineticsList; Overload;
    function GetEnumerator : TFhirMedicationKnowledgeKineticsListEnumerator;
    

    //  Add a FhirMedicationKnowledgeKinetics to the end of the list.
    function Append : TFhirMedicationKnowledgeKinetics;

    
    // Add an already existing FhirMedicationKnowledgeKinetics to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledgeKinetics); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeKinetics) : Integer;
    

    // Insert FhirMedicationKnowledgeKinetics before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeKinetics;
    

    // Insert an existing FhirMedicationKnowledgeKinetics before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeKinetics);
    
    // Get the iIndexth FhirMedicationKnowledgeKinetics. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeKinetics);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeKinetics;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicationKnowledgeKinetics[index : Integer] : TFhirMedicationKnowledgeKinetics read GetItemN write SetItemN; default;
  End;

  // Information about a medication that is used to support knowledge.
  TFhirMedicationKnowledge = class (TFhirDomainResource)
  protected
    FCode : TFhirCodeableConcept;
    FStatus : TFhirCode;
    FManufacturer : TFhirReference{TFhirOrganization};
    FDoseForm : TFhirCodeableConcept;
    FAmount : TFhirQuantity;
    FsynonymList : TFhirStringList;
    FrelatedMedicationKnowledgeList : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
    FassociatedMedicationList : TFhirReferenceList{TFhirMedication};
    FproductTypeList : TFhirCodeableConceptList;
    FmonographList : TFhirMedicationKnowledgeMonographList;
    FingredientList : TFhirMedicationKnowledgeIngredientList;
    FPreparationInstruction : TFhirMarkdown;
    FintendedRouteList : TFhirCodeableConceptList;
    FcostList : TFhirMedicationKnowledgeCostList;
    FmonitoringProgramList : TFhirMedicationKnowledgeMonitoringProgramList;
    FadministrationGuidelinesList : TFhirMedicationKnowledgeAdministrationGuidelinesList;
    FmedicineClassificationList : TFhirMedicationKnowledgeMedicineClassificationList;
    FPackaging : TFhirMedicationKnowledgePackaging;
    FdrugCharacteristicList : TFhirMedicationKnowledgeDrugCharacteristicList;
    FcontraindicationList : TFhirReferenceList{TFhirDetectedIssue};
    FregulatoryList : TFhirMedicationKnowledgeRegulatoryList;
    FkineticsList : TFhirMedicationKnowledgeKineticsList;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetStatus(value : TFhirCode);
    Function GetStatusST : String;
    Procedure SetStatusST(value : String);
    Procedure SetManufacturer(value : TFhirReference{TFhirOrganization});
    Procedure SetDoseForm(value : TFhirCodeableConcept);
    Procedure SetAmount(value : TFhirQuantity);
    function GetSynonymList : TFhirStringList;
    function GetHasSynonymList : Boolean;
    function GetRelatedMedicationKnowledgeList : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
    function GetHasRelatedMedicationKnowledgeList : Boolean;
    function GetAssociatedMedicationList : TFhirReferenceList{TFhirMedication};
    function GetHasAssociatedMedicationList : Boolean;
    function GetProductTypeList : TFhirCodeableConceptList;
    function GetHasProductTypeList : Boolean;
    function GetMonographList : TFhirMedicationKnowledgeMonographList;
    function GetHasMonographList : Boolean;
    function GetIngredientList : TFhirMedicationKnowledgeIngredientList;
    function GetHasIngredientList : Boolean;
    Procedure SetPreparationInstruction(value : TFhirMarkdown);
    Function GetPreparationInstructionST : String;
    Procedure SetPreparationInstructionST(value : String);
    function GetIntendedRouteList : TFhirCodeableConceptList;
    function GetHasIntendedRouteList : Boolean;
    function GetCostList : TFhirMedicationKnowledgeCostList;
    function GetHasCostList : Boolean;
    function GetMonitoringProgramList : TFhirMedicationKnowledgeMonitoringProgramList;
    function GetHasMonitoringProgramList : Boolean;
    function GetAdministrationGuidelinesList : TFhirMedicationKnowledgeAdministrationGuidelinesList;
    function GetHasAdministrationGuidelinesList : Boolean;
    function GetMedicineClassificationList : TFhirMedicationKnowledgeMedicineClassificationList;
    function GetHasMedicineClassificationList : Boolean;
    Procedure SetPackaging(value : TFhirMedicationKnowledgePackaging);
    function GetDrugCharacteristicList : TFhirMedicationKnowledgeDrugCharacteristicList;
    function GetHasDrugCharacteristicList : Boolean;
    function GetContraindicationList : TFhirReferenceList{TFhirDetectedIssue};
    function GetHasContraindicationList : Boolean;
    function GetRegulatoryList : TFhirMedicationKnowledgeRegulatoryList;
    function GetHasRegulatoryList : Boolean;
    function GetKineticsList : TFhirMedicationKnowledgeKineticsList;
    function GetHasKineticsList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledge; overload;
    function Clone : TFhirMedicationKnowledge; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A code that specifies this medication, or a textual description if no code is available. Usage note: This could be a standard medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local formulary code, optionally with translations to other code systems. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that specifies this medication, or a textual description if no code is available. Usage note: This could be a standard medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local formulary code, optionally with translations to other code systems.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to A code to indicate if the medication is in active use.  The status refers to the validity about the information of the medication and not to its medicinal properties.
    property status : String read GetStatusST write SetStatusST;
    // A code to indicate if the medication is in active use.  The status refers to the validity about the information of the medication and not to its medicinal properties.
    property statusElement : TFhirCode read FStatus write SetStatus;

    // Typed access to Describes the details of the manufacturer of the medication product.  This is not intended to represent the distributor of a medication product. (defined for API consistency)
    property manufacturer : TFhirReference{TFhirOrganization} read FManufacturer write SetManufacturer;
    // Describes the details of the manufacturer of the medication product.  This is not intended to represent the distributor of a medication product.
    property manufacturerElement : TFhirReference{TFhirOrganization} read FManufacturer write SetManufacturer;

    // Typed access to Describes the form of the item.  Powder; tablets; capsule. (defined for API consistency)
    property doseForm : TFhirCodeableConcept read FDoseForm write SetDoseForm;
    // Describes the form of the item.  Powder; tablets; capsule.
    property doseFormElement : TFhirCodeableConcept read FDoseForm write SetDoseForm;

    // Typed access to Specific amount of the drug in the packaged product.  For example, when specifying a product that has the same strength (For example, Insulin glargine 100 unit per mL solution for injection), this attribute provides additional clarification of the package amount (For example, 3 mL, 10mL, etc.). (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // Specific amount of the drug in the packaged product.  For example, when specifying a product that has the same strength (For example, Insulin glargine 100 unit per mL solution for injection), this attribute provides additional clarification of the package amount (For example, 3 mL, 10mL, etc.).
    property amountElement : TFhirQuantity read FAmount write SetAmount;

    // Additional names for a medication, for example, the name(s) given to a medication in different countries.  For example, acetaminophen and paracetamol or salbutamol and albuterol.
    property synonymList : TFhirStringList read GetSynonymList;
    property hasSynonymList : boolean read GetHasSynonymList;

    // Associated or related knowledge about a medication.
    property relatedMedicationKnowledgeList : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList read GetRelatedMedicationKnowledgeList;
    property hasRelatedMedicationKnowledgeList : boolean read GetHasRelatedMedicationKnowledgeList;

    // Associated or related medications.  For example, if the medication is a branded product (e.g. Crestor), this is the Therapeutic Moeity (e.g. Rosuvastatin) or if this is a generic medication (e.g. Rosuvastatin), this would link to a branded product (e.g. Crestor).
    property associatedMedicationList : TFhirReferenceList{TFhirMedication} read GetAssociatedMedicationList;
    property hasAssociatedMedicationList : boolean read GetHasAssociatedMedicationList;

    // Category of the medication or product (e.g. branded product, therapeutic moeity, generic product, innovator product, etc.).
    property productTypeList : TFhirCodeableConceptList read GetProductTypeList;
    property hasProductTypeList : boolean read GetHasProductTypeList;

    // Associated documentation about the medication.
    property monographList : TFhirMedicationKnowledgeMonographList read GetMonographList;
    property hasMonographList : boolean read GetHasMonographList;

    // Identifies a particular constituent of interest in the product.
    property ingredientList : TFhirMedicationKnowledgeIngredientList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // Typed access to The instructions for preparing the medication.
    property preparationInstruction : String read GetPreparationInstructionST write SetPreparationInstructionST;
    // The instructions for preparing the medication.
    property preparationInstructionElement : TFhirMarkdown read FPreparationInstruction write SetPreparationInstruction;

    // The intended or approved route of administration.
    property intendedRouteList : TFhirCodeableConceptList read GetIntendedRouteList;
    property hasIntendedRouteList : boolean read GetHasIntendedRouteList;

    // The price of the medication.
    property costList : TFhirMedicationKnowledgeCostList read GetCostList;
    property hasCostList : boolean read GetHasCostList;

    // The program under which the medication is reviewed.
    property monitoringProgramList : TFhirMedicationKnowledgeMonitoringProgramList read GetMonitoringProgramList;
    property hasMonitoringProgramList : boolean read GetHasMonitoringProgramList;

    // Guidelines for the administration of the medication.
    property administrationGuidelinesList : TFhirMedicationKnowledgeAdministrationGuidelinesList read GetAdministrationGuidelinesList;
    property hasAdministrationGuidelinesList : boolean read GetHasAdministrationGuidelinesList;

    // Categorization of the medication within a formulary or classification system.
    property medicineClassificationList : TFhirMedicationKnowledgeMedicineClassificationList read GetMedicineClassificationList;
    property hasMedicineClassificationList : boolean read GetHasMedicineClassificationList;

    // Typed access to Information that only applies to packages (not products). (defined for API consistency)
    property packaging : TFhirMedicationKnowledgePackaging read FPackaging write SetPackaging;
    // Information that only applies to packages (not products).
    property packagingElement : TFhirMedicationKnowledgePackaging read FPackaging write SetPackaging;

    // Specifies descriptive properties of the medicine, such as color, shape, imprints, etc.
    property drugCharacteristicList : TFhirMedicationKnowledgeDrugCharacteristicList read GetDrugCharacteristicList;
    property hasDrugCharacteristicList : boolean read GetHasDrugCharacteristicList;

    // Potential clinical issue with or between medication(s) (for example, drug-drug interaction, drug-disease contraindication, drug-allergy interaction, etc.).
    property contraindicationList : TFhirReferenceList{TFhirDetectedIssue} read GetContraindicationList;
    property hasContraindicationList : boolean read GetHasContraindicationList;

    // Regulatory information about a medication.
    property regulatoryList : TFhirMedicationKnowledgeRegulatoryList read GetRegulatoryList;
    property hasRegulatoryList : boolean read GetHasRegulatoryList;

    // The time course of drug absorption, distribution, metabolism and excretion of a medication from the body.
    property kineticsList : TFhirMedicationKnowledgeKineticsList read GetKineticsList;
    property hasKineticsList : boolean read GetHasKineticsList;

  end;

  TFhirMedicationKnowledgeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeList;
    function GetCurrent : TFhirMedicationKnowledge;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledge read GetCurrent;
  end;

  TFhirMedicationKnowledgeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationKnowledge;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledge);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationKnowledgeList; Overload;
    function Clone : TFhirMedicationKnowledgeList; Overload;
    function GetEnumerator : TFhirMedicationKnowledgeListEnumerator;
    

    //  Add a FhirMedicationKnowledge to the end of the list.
    function Append : TFhirMedicationKnowledge;

    
    // Add an already existing FhirMedicationKnowledge to the end of the list.
    procedure AddItem(value : TFhirMedicationKnowledge); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledge) : Integer;
    

    // Insert FhirMedicationKnowledge before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledge;
    

    // Insert an existing FhirMedicationKnowledge before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledge);
    
    // Get the iIndexth FhirMedicationKnowledge. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledge);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledge;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicationKnowledges[index : Integer] : TFhirMedicationKnowledge read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATIONKNOWLEDGE}

{$IFDEF FHIR_MEDICINALPRODUCT}

  // The product's name, including full name and possibly coded parts.
  TFhirMedicinalProductName = class (TFhirBackboneElement)
  protected
    FProductName : TFhirString;
    FnamePartList : TFhirMedicinalProductNameNamePartList;
    FcountryLanguageList : TFhirMedicinalProductNameCountryLanguageList;
    Procedure SetProductName(value : TFhirString);
    Function GetProductNameST : String;
    Procedure SetProductNameST(value : String);
    function GetNamePartList : TFhirMedicinalProductNameNamePartList;
    function GetHasNamePartList : Boolean;
    function GetCountryLanguageList : TFhirMedicinalProductNameCountryLanguageList;
    function GetHasCountryLanguageList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductName; overload;
    function Clone : TFhirMedicinalProductName; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The full product name.
    property productName : String read GetProductNameST write SetProductNameST;
    // The full product name.
    property productNameElement : TFhirString read FProductName write SetProductName;

    // Coding words or phrases of the name.
    property namePartList : TFhirMedicinalProductNameNamePartList read GetNamePartList;
    property hasNamePartList : boolean read GetHasNamePartList;

    // Country where the name applies.
    property countryLanguageList : TFhirMedicinalProductNameCountryLanguageList read GetCountryLanguageList;
    property hasCountryLanguageList : boolean read GetHasCountryLanguageList;

  end;

  TFhirMedicinalProductNameListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductNameList;
    function GetCurrent : TFhirMedicinalProductName;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductNameList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductName read GetCurrent;
  end;

  TFhirMedicinalProductNameList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductName;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductName);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductNameList; Overload;
    function Clone : TFhirMedicinalProductNameList; Overload;
    function GetEnumerator : TFhirMedicinalProductNameListEnumerator;
    

    //  Add a FhirMedicinalProductName to the end of the list.
    function Append : TFhirMedicinalProductName;

    
    // Add an already existing FhirMedicinalProductName to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductName); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductName) : Integer;
    

    // Insert FhirMedicinalProductName before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductName;
    

    // Insert an existing FhirMedicinalProductName before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductName);
    
    // Get the iIndexth FhirMedicinalProductName. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductName);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductName;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductNames[index : Integer] : TFhirMedicinalProductName read GetItemN write SetItemN; default;
  End;

  // Coding words or phrases of the name.
  TFhirMedicinalProductNameNamePart = class (TFhirBackboneElement)
  protected
    FPart : TFhirString;
    FType_ : TFhirCoding;
    Procedure SetPart(value : TFhirString);
    Function GetPartST : String;
    Procedure SetPartST(value : String);
    Procedure SetType_(value : TFhirCoding);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductNameNamePart; overload;
    function Clone : TFhirMedicinalProductNameNamePart; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A fragment of a product name.
    property part : String read GetPartST write SetPartST;
    // A fragment of a product name.
    property partElement : TFhirString read FPart write SetPart;

    // Typed access to Idenifying type for this part of the name (e.g. strength part). (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // Idenifying type for this part of the name (e.g. strength part).
    property type_Element : TFhirCoding read FType_ write SetType_;

  end;

  TFhirMedicinalProductNameNamePartListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductNameNamePartList;
    function GetCurrent : TFhirMedicinalProductNameNamePart;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductNameNamePartList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductNameNamePart read GetCurrent;
  end;

  TFhirMedicinalProductNameNamePartList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductNameNamePart;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductNameNamePart);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductNameNamePartList; Overload;
    function Clone : TFhirMedicinalProductNameNamePartList; Overload;
    function GetEnumerator : TFhirMedicinalProductNameNamePartListEnumerator;
    

    //  Add a FhirMedicinalProductNameNamePart to the end of the list.
    function Append : TFhirMedicinalProductNameNamePart;

    
    // Add an already existing FhirMedicinalProductNameNamePart to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductNameNamePart); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductNameNamePart) : Integer;
    

    // Insert FhirMedicinalProductNameNamePart before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductNameNamePart;
    

    // Insert an existing FhirMedicinalProductNameNamePart before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductNameNamePart);
    
    // Get the iIndexth FhirMedicinalProductNameNamePart. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductNameNamePart);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductNameNamePart;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductNameNameParts[index : Integer] : TFhirMedicinalProductNameNamePart read GetItemN write SetItemN; default;
  End;

  // Country where the name applies.
  TFhirMedicinalProductNameCountryLanguage = class (TFhirBackboneElement)
  protected
    FCountry : TFhirCodeableConcept;
    FJurisdiction : TFhirCodeableConcept;
    FLanguage : TFhirCodeableConcept;
    Procedure SetCountry(value : TFhirCodeableConcept);
    Procedure SetJurisdiction(value : TFhirCodeableConcept);
    Procedure SetLanguage(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductNameCountryLanguage; overload;
    function Clone : TFhirMedicinalProductNameCountryLanguage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Country code for where this name applies. (defined for API consistency)
    property country : TFhirCodeableConcept read FCountry write SetCountry;
    // Country code for where this name applies.
    property countryElement : TFhirCodeableConcept read FCountry write SetCountry;

    // Typed access to Jurisdiction code for where this name applies. (defined for API consistency)
    property jurisdiction : TFhirCodeableConcept read FJurisdiction write SetJurisdiction;
    // Jurisdiction code for where this name applies.
    property jurisdictionElement : TFhirCodeableConcept read FJurisdiction write SetJurisdiction;

    // Typed access to Language code for this name. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // Language code for this name.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

  end;

  TFhirMedicinalProductNameCountryLanguageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductNameCountryLanguageList;
    function GetCurrent : TFhirMedicinalProductNameCountryLanguage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductNameCountryLanguageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductNameCountryLanguage read GetCurrent;
  end;

  TFhirMedicinalProductNameCountryLanguageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductNameCountryLanguage;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductNameCountryLanguage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductNameCountryLanguageList; Overload;
    function Clone : TFhirMedicinalProductNameCountryLanguageList; Overload;
    function GetEnumerator : TFhirMedicinalProductNameCountryLanguageListEnumerator;
    

    //  Add a FhirMedicinalProductNameCountryLanguage to the end of the list.
    function Append : TFhirMedicinalProductNameCountryLanguage;

    
    // Add an already existing FhirMedicinalProductNameCountryLanguage to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductNameCountryLanguage); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductNameCountryLanguage) : Integer;
    

    // Insert FhirMedicinalProductNameCountryLanguage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductNameCountryLanguage;
    

    // Insert an existing FhirMedicinalProductNameCountryLanguage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductNameCountryLanguage);
    
    // Get the iIndexth FhirMedicinalProductNameCountryLanguage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductNameCountryLanguage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductNameCountryLanguage;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductNameCountryLanguages[index : Integer] : TFhirMedicinalProductNameCountryLanguage read GetItemN write SetItemN; default;
  End;

  // An operation applied to the product, for manufacturing or adminsitrative purpose.
  TFhirMedicinalProductManufacturingBusinessOperation = class (TFhirBackboneElement)
  protected
    FOperationType : TFhirCodeableConcept;
    FAuthorisationReferenceNumber : TFhirIdentifier;
    FEffectiveDate : TFhirDateTime;
    FConfidentialityIndicator : TFhirCodeableConcept;
    FmanufacturerList : TFhirReferenceList{TFhirOrganization};
    FRegulator : TFhirReference{TFhirOrganization};
    Procedure SetOperationType(value : TFhirCodeableConcept);
    Procedure SetAuthorisationReferenceNumber(value : TFhirIdentifier);
    Procedure SetEffectiveDate(value : TFhirDateTime);
    Function GetEffectiveDateST : TFslDateTime;
    Procedure SetEffectiveDateST(value : TFslDateTime);
    Procedure SetConfidentialityIndicator(value : TFhirCodeableConcept);
    function GetManufacturerList : TFhirReferenceList{TFhirOrganization};
    function GetHasManufacturerList : Boolean;
    Procedure SetRegulator(value : TFhirReference{TFhirOrganization});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductManufacturingBusinessOperation; overload;
    function Clone : TFhirMedicinalProductManufacturingBusinessOperation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The type of manufacturing operation. (defined for API consistency)
    property operationType : TFhirCodeableConcept read FOperationType write SetOperationType;
    // The type of manufacturing operation.
    property operationTypeElement : TFhirCodeableConcept read FOperationType write SetOperationType;

    // Typed access to Regulatory authorization reference number. (defined for API consistency)
    property authorisationReferenceNumber : TFhirIdentifier read FAuthorisationReferenceNumber write SetAuthorisationReferenceNumber;
    // Regulatory authorization reference number.
    property authorisationReferenceNumberElement : TFhirIdentifier read FAuthorisationReferenceNumber write SetAuthorisationReferenceNumber;

    // Typed access to Regulatory authorization date.
    property effectiveDate : TFslDateTime read GetEffectiveDateST write SetEffectiveDateST;
    // Regulatory authorization date.
    property effectiveDateElement : TFhirDateTime read FEffectiveDate write SetEffectiveDate;

    // Typed access to To indicate if this proces is commercially confidential. (defined for API consistency)
    property confidentialityIndicator : TFhirCodeableConcept read FConfidentialityIndicator write SetConfidentialityIndicator;
    // To indicate if this proces is commercially confidential.
    property confidentialityIndicatorElement : TFhirCodeableConcept read FConfidentialityIndicator write SetConfidentialityIndicator;

    // The manufacturer or establishment associated with the process.
    property manufacturerList : TFhirReferenceList{TFhirOrganization} read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // Typed access to A regulator which oversees the operation. (defined for API consistency)
    property regulator : TFhirReference{TFhirOrganization} read FRegulator write SetRegulator;
    // A regulator which oversees the operation.
    property regulatorElement : TFhirReference{TFhirOrganization} read FRegulator write SetRegulator;

  end;

  TFhirMedicinalProductManufacturingBusinessOperationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductManufacturingBusinessOperationList;
    function GetCurrent : TFhirMedicinalProductManufacturingBusinessOperation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductManufacturingBusinessOperationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductManufacturingBusinessOperation read GetCurrent;
  end;

  TFhirMedicinalProductManufacturingBusinessOperationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductManufacturingBusinessOperation;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductManufacturingBusinessOperation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductManufacturingBusinessOperationList; Overload;
    function Clone : TFhirMedicinalProductManufacturingBusinessOperationList; Overload;
    function GetEnumerator : TFhirMedicinalProductManufacturingBusinessOperationListEnumerator;
    

    //  Add a FhirMedicinalProductManufacturingBusinessOperation to the end of the list.
    function Append : TFhirMedicinalProductManufacturingBusinessOperation;

    
    // Add an already existing FhirMedicinalProductManufacturingBusinessOperation to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductManufacturingBusinessOperation); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductManufacturingBusinessOperation) : Integer;
    

    // Insert FhirMedicinalProductManufacturingBusinessOperation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductManufacturingBusinessOperation;
    

    // Insert an existing FhirMedicinalProductManufacturingBusinessOperation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductManufacturingBusinessOperation);
    
    // Get the iIndexth FhirMedicinalProductManufacturingBusinessOperation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductManufacturingBusinessOperation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductManufacturingBusinessOperation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductManufacturingBusinessOperations[index : Integer] : TFhirMedicinalProductManufacturingBusinessOperation read GetItemN write SetItemN; default;
  End;

  // Indicates if the medicinal product has an orphan designation for the treatment of a rare disease.
  TFhirMedicinalProductSpecialDesignation = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCodeableConcept;
    FIntendedUse : TFhirCodeableConcept;
    FIndication : TFhirType;
    FStatus : TFhirCodeableConcept;
    FDate : TFhirDateTime;
    FSpecies : TFhirCodeableConcept;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetIntendedUse(value : TFhirCodeableConcept);
    Procedure SetIndication(value : TFhirType);
    Procedure SetStatus(value : TFhirCodeableConcept);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetSpecies(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductSpecialDesignation; overload;
    function Clone : TFhirMedicinalProductSpecialDesignation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifier for the designation, or procedure number.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The type of special designation, e.g. orphan drug, minor use. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of special designation, e.g. orphan drug, minor use.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The intended use of the product, e.g. prevention, treatment. (defined for API consistency)
    property intendedUse : TFhirCodeableConcept read FIntendedUse write SetIntendedUse;
    // The intended use of the product, e.g. prevention, treatment.
    property intendedUseElement : TFhirCodeableConcept read FIntendedUse write SetIntendedUse;

    // Typed access to Condition for which the medicinal use applies. (defined for API consistency)
    property indication : TFhirType read FIndication write SetIndication;
    // Condition for which the medicinal use applies.
    property indicationElement : TFhirType read FIndication write SetIndication;

    // Typed access to For example granted, pending, expired or withdrawn. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // For example granted, pending, expired or withdrawn.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to Date when the designation was granted.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date when the designation was granted.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Animal species for which this applies. (defined for API consistency)
    property species : TFhirCodeableConcept read FSpecies write SetSpecies;
    // Animal species for which this applies.
    property speciesElement : TFhirCodeableConcept read FSpecies write SetSpecies;

  end;

  TFhirMedicinalProductSpecialDesignationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductSpecialDesignationList;
    function GetCurrent : TFhirMedicinalProductSpecialDesignation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductSpecialDesignationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductSpecialDesignation read GetCurrent;
  end;

  TFhirMedicinalProductSpecialDesignationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductSpecialDesignation;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductSpecialDesignation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductSpecialDesignationList; Overload;
    function Clone : TFhirMedicinalProductSpecialDesignationList; Overload;
    function GetEnumerator : TFhirMedicinalProductSpecialDesignationListEnumerator;
    

    //  Add a FhirMedicinalProductSpecialDesignation to the end of the list.
    function Append : TFhirMedicinalProductSpecialDesignation;

    
    // Add an already existing FhirMedicinalProductSpecialDesignation to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductSpecialDesignation); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductSpecialDesignation) : Integer;
    

    // Insert FhirMedicinalProductSpecialDesignation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductSpecialDesignation;
    

    // Insert an existing FhirMedicinalProductSpecialDesignation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductSpecialDesignation);
    
    // Get the iIndexth FhirMedicinalProductSpecialDesignation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductSpecialDesignation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductSpecialDesignation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductSpecialDesignations[index : Integer] : TFhirMedicinalProductSpecialDesignation read GetItemN write SetItemN; default;
  End;

  // Detailed definition of a medicinal product, typically for uses other than direct patient care (e.g. regulatory use).
  TFhirMedicinalProduct = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCodeableConcept;
    FDomain : TFhirCoding;
    FCombinedPharmaceuticalDoseForm : TFhirCodeableConcept;
    FLegalStatusOfSupply : TFhirCodeableConcept;
    FAdditionalMonitoringIndicator : TFhirCodeableConcept;
    FspecialMeasuresList : TFhirStringList;
    FPaediatricUseIndicator : TFhirCodeableConcept;
    FproductClassificationList : TFhirCodeableConceptList;
    FmarketingStatusList : TFhirMarketingStatusList;
    FpharmaceuticalProductList : TFhirReferenceList{TFhirMedicinalProductPharmaceutical};
    FpackagedMedicinalProductList : TFhirReferenceList{TFhirMedicinalProductPackaged};
    FattachedDocumentList : TFhirReferenceList{TFhirDocumentReference};
    FmasterFileList : TFhirReferenceList{TFhirDocumentReference};
    FcontactList : TFhirReferenceList{TFhirOrganization};
    FclinicalTrialList : TFhirReferenceList{TFhirResearchStudy};
    FnameList : TFhirMedicinalProductNameList;
    FcrossReferenceList : TFhirIdentifierList;
    FmanufacturingBusinessOperationList : TFhirMedicinalProductManufacturingBusinessOperationList;
    FspecialDesignationList : TFhirMedicinalProductSpecialDesignationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetDomain(value : TFhirCoding);
    Procedure SetCombinedPharmaceuticalDoseForm(value : TFhirCodeableConcept);
    Procedure SetLegalStatusOfSupply(value : TFhirCodeableConcept);
    Procedure SetAdditionalMonitoringIndicator(value : TFhirCodeableConcept);
    function GetSpecialMeasuresList : TFhirStringList;
    function GetHasSpecialMeasuresList : Boolean;
    Procedure SetPaediatricUseIndicator(value : TFhirCodeableConcept);
    function GetProductClassificationList : TFhirCodeableConceptList;
    function GetHasProductClassificationList : Boolean;
    function GetMarketingStatusList : TFhirMarketingStatusList;
    function GetHasMarketingStatusList : Boolean;
    function GetPharmaceuticalProductList : TFhirReferenceList{TFhirMedicinalProductPharmaceutical};
    function GetHasPharmaceuticalProductList : Boolean;
    function GetPackagedMedicinalProductList : TFhirReferenceList{TFhirMedicinalProductPackaged};
    function GetHasPackagedMedicinalProductList : Boolean;
    function GetAttachedDocumentList : TFhirReferenceList{TFhirDocumentReference};
    function GetHasAttachedDocumentList : Boolean;
    function GetMasterFileList : TFhirReferenceList{TFhirDocumentReference};
    function GetHasMasterFileList : Boolean;
    function GetContactList : TFhirReferenceList{TFhirOrganization};
    function GetHasContactList : Boolean;
    function GetClinicalTrialList : TFhirReferenceList{TFhirResearchStudy};
    function GetHasClinicalTrialList : Boolean;
    function GetNameList : TFhirMedicinalProductNameList;
    function GetHasNameList : Boolean;
    function GetCrossReferenceList : TFhirIdentifierList;
    function GetHasCrossReferenceList : Boolean;
    function GetManufacturingBusinessOperationList : TFhirMedicinalProductManufacturingBusinessOperationList;
    function GetHasManufacturingBusinessOperationList : Boolean;
    function GetSpecialDesignationList : TFhirMedicinalProductSpecialDesignationList;
    function GetHasSpecialDesignationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProduct; overload;
    function Clone : TFhirMedicinalProduct; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Business identifier for this product. Could be an MPID.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Regulatory type, e.g. Investigational or Authorized. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Regulatory type, e.g. Investigational or Authorized.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to If this medicine applies to human or veterinary uses. (defined for API consistency)
    property domain : TFhirCoding read FDomain write SetDomain;
    // If this medicine applies to human or veterinary uses.
    property domainElement : TFhirCoding read FDomain write SetDomain;

    // Typed access to The dose form for a single part product, or combined form of a multiple part product. (defined for API consistency)
    property combinedPharmaceuticalDoseForm : TFhirCodeableConcept read FCombinedPharmaceuticalDoseForm write SetCombinedPharmaceuticalDoseForm;
    // The dose form for a single part product, or combined form of a multiple part product.
    property combinedPharmaceuticalDoseFormElement : TFhirCodeableConcept read FCombinedPharmaceuticalDoseForm write SetCombinedPharmaceuticalDoseForm;

    // Typed access to The legal status of supply of the medicinal product as classified by the regulator. (defined for API consistency)
    property legalStatusOfSupply : TFhirCodeableConcept read FLegalStatusOfSupply write SetLegalStatusOfSupply;
    // The legal status of supply of the medicinal product as classified by the regulator.
    property legalStatusOfSupplyElement : TFhirCodeableConcept read FLegalStatusOfSupply write SetLegalStatusOfSupply;

    // Typed access to Whether the Medicinal Product is subject to additional monitoring for regulatory reasons. (defined for API consistency)
    property additionalMonitoringIndicator : TFhirCodeableConcept read FAdditionalMonitoringIndicator write SetAdditionalMonitoringIndicator;
    // Whether the Medicinal Product is subject to additional monitoring for regulatory reasons.
    property additionalMonitoringIndicatorElement : TFhirCodeableConcept read FAdditionalMonitoringIndicator write SetAdditionalMonitoringIndicator;

    // Whether the Medicinal Product is subject to special measures for regulatory reasons.
    property specialMeasuresList : TFhirStringList read GetSpecialMeasuresList;
    property hasSpecialMeasuresList : boolean read GetHasSpecialMeasuresList;

    // Typed access to If authorised for use in children. (defined for API consistency)
    property paediatricUseIndicator : TFhirCodeableConcept read FPaediatricUseIndicator write SetPaediatricUseIndicator;
    // If authorised for use in children.
    property paediatricUseIndicatorElement : TFhirCodeableConcept read FPaediatricUseIndicator write SetPaediatricUseIndicator;

    // Allows the product to be classified by various systems.
    property productClassificationList : TFhirCodeableConceptList read GetProductClassificationList;
    property hasProductClassificationList : boolean read GetHasProductClassificationList;

    // Marketing status of the medicinal product, in contrast to marketing authorizaton.
    property marketingStatusList : TFhirMarketingStatusList read GetMarketingStatusList;
    property hasMarketingStatusList : boolean read GetHasMarketingStatusList;

    // Pharmaceutical aspects of product.
    property pharmaceuticalProductList : TFhirReferenceList{TFhirMedicinalProductPharmaceutical} read GetPharmaceuticalProductList;
    property hasPharmaceuticalProductList : boolean read GetHasPharmaceuticalProductList;

    // Package representation for the product.
    property packagedMedicinalProductList : TFhirReferenceList{TFhirMedicinalProductPackaged} read GetPackagedMedicinalProductList;
    property hasPackagedMedicinalProductList : boolean read GetHasPackagedMedicinalProductList;

    // Supporting documentation, typically for regulatory submission.
    property attachedDocumentList : TFhirReferenceList{TFhirDocumentReference} read GetAttachedDocumentList;
    property hasAttachedDocumentList : boolean read GetHasAttachedDocumentList;

    // A master file for to the medicinal product (e.g. Pharmacovigilance System Master File).
    property masterFileList : TFhirReferenceList{TFhirDocumentReference} read GetMasterFileList;
    property hasMasterFileList : boolean read GetHasMasterFileList;

    // A product specific contact, person (in a role), or an organization.
    property contactList : TFhirReferenceList{TFhirOrganization} read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Clinical trials or studies that this product is involved in.
    property clinicalTrialList : TFhirReferenceList{TFhirResearchStudy} read GetClinicalTrialList;
    property hasClinicalTrialList : boolean read GetHasClinicalTrialList;

    // The product's name, including full name and possibly coded parts.
    property nameList : TFhirMedicinalProductNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // Reference to another product, e.g. for linking authorised to investigational product.
    property crossReferenceList : TFhirIdentifierList read GetCrossReferenceList;
    property hasCrossReferenceList : boolean read GetHasCrossReferenceList;

    // An operation applied to the product, for manufacturing or adminsitrative purpose.
    property manufacturingBusinessOperationList : TFhirMedicinalProductManufacturingBusinessOperationList read GetManufacturingBusinessOperationList;
    property hasManufacturingBusinessOperationList : boolean read GetHasManufacturingBusinessOperationList;

    // Indicates if the medicinal product has an orphan designation for the treatment of a rare disease.
    property specialDesignationList : TFhirMedicinalProductSpecialDesignationList read GetSpecialDesignationList;
    property hasSpecialDesignationList : boolean read GetHasSpecialDesignationList;

  end;

  TFhirMedicinalProductListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductList;
    function GetCurrent : TFhirMedicinalProduct;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProduct read GetCurrent;
  end;

  TFhirMedicinalProductList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProduct;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProduct);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductList; Overload;
    function Clone : TFhirMedicinalProductList; Overload;
    function GetEnumerator : TFhirMedicinalProductListEnumerator;
    

    //  Add a FhirMedicinalProduct to the end of the list.
    function Append : TFhirMedicinalProduct;

    
    // Add an already existing FhirMedicinalProduct to the end of the list.
    procedure AddItem(value : TFhirMedicinalProduct); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProduct) : Integer;
    

    // Insert FhirMedicinalProduct before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProduct;
    

    // Insert an existing FhirMedicinalProduct before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProduct);
    
    // Get the iIndexth FhirMedicinalProduct. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProduct);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProduct;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProducts[index : Integer] : TFhirMedicinalProduct read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICINALPRODUCT}

{$IFDEF FHIR_MEDICINALPRODUCTAUTHORIZATION}

  // Authorization in areas within a country.
  TFhirMedicinalProductAuthorizationJurisdictionalAuthorization = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FCountry : TFhirCodeableConcept;
    FjurisdictionList : TFhirCodeableConceptList;
    FLegalStatusOfSupply : TFhirCodeableConcept;
    FValidityPeriod : TFhirPeriod;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetCountry(value : TFhirCodeableConcept);
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    Procedure SetLegalStatusOfSupply(value : TFhirCodeableConcept);
    Procedure SetValidityPeriod(value : TFhirPeriod);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization; overload;
    function Clone : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The assigned number for the marketing authorization.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Country of authorization. (defined for API consistency)
    property country : TFhirCodeableConcept read FCountry write SetCountry;
    // Country of authorization.
    property countryElement : TFhirCodeableConcept read FCountry write SetCountry;

    // Jurisdiction within a country.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to The legal status of supply in a jurisdiction or region. (defined for API consistency)
    property legalStatusOfSupply : TFhirCodeableConcept read FLegalStatusOfSupply write SetLegalStatusOfSupply;
    // The legal status of supply in a jurisdiction or region.
    property legalStatusOfSupplyElement : TFhirCodeableConcept read FLegalStatusOfSupply write SetLegalStatusOfSupply;

    // Typed access to The start and expected end date of the authorization. (defined for API consistency)
    property validityPeriod : TFhirPeriod read FValidityPeriod write SetValidityPeriod;
    // The start and expected end date of the authorization.
    property validityPeriodElement : TFhirPeriod read FValidityPeriod write SetValidityPeriod;

  end;

  TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList;
    function GetCurrent : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization read GetCurrent;
  end;

  TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList; Overload;
    function Clone : TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList; Overload;
    function GetEnumerator : TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationListEnumerator;
    

    //  Add a FhirMedicinalProductAuthorizationJurisdictionalAuthorization to the end of the list.
    function Append : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization;

    
    // Add an already existing FhirMedicinalProductAuthorizationJurisdictionalAuthorization to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization) : Integer;
    

    // Insert FhirMedicinalProductAuthorizationJurisdictionalAuthorization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization;
    

    // Insert an existing FhirMedicinalProductAuthorizationJurisdictionalAuthorization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization);
    
    // Get the iIndexth FhirMedicinalProductAuthorizationJurisdictionalAuthorization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductAuthorizationJurisdictionalAuthorizations[index : Integer] : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization read GetItemN write SetItemN; default;
  End;

  // The regulatory procedure for granting or amending a marketing authorization.
  TFhirMedicinalProductAuthorizationProcedure = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FType_ : TFhirCodeableConcept;
    FDate : TFhirType;
    FapplicationList : TFhirMedicinalProductAuthorizationProcedureList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetDate(value : TFhirType);
    function GetApplicationList : TFhirMedicinalProductAuthorizationProcedureList;
    function GetHasApplicationList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductAuthorizationProcedure; overload;
    function Clone : TFhirMedicinalProductAuthorizationProcedure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Identifier for this procedure. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier for this procedure.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Type of procedure. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of procedure.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Date of procedure. (defined for API consistency)
    property date : TFhirType read FDate write SetDate;
    // Date of procedure.
    property dateElement : TFhirType read FDate write SetDate;

    // Applcations submitted to obtain a marketing authorization.
    property applicationList : TFhirMedicinalProductAuthorizationProcedureList read GetApplicationList;
    property hasApplicationList : boolean read GetHasApplicationList;

  end;

  TFhirMedicinalProductAuthorizationProcedureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductAuthorizationProcedureList;
    function GetCurrent : TFhirMedicinalProductAuthorizationProcedure;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductAuthorizationProcedureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductAuthorizationProcedure read GetCurrent;
  end;

  TFhirMedicinalProductAuthorizationProcedureList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductAuthorizationProcedure;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductAuthorizationProcedure);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductAuthorizationProcedureList; Overload;
    function Clone : TFhirMedicinalProductAuthorizationProcedureList; Overload;
    function GetEnumerator : TFhirMedicinalProductAuthorizationProcedureListEnumerator;
    

    //  Add a FhirMedicinalProductAuthorizationProcedure to the end of the list.
    function Append : TFhirMedicinalProductAuthorizationProcedure;

    
    // Add an already existing FhirMedicinalProductAuthorizationProcedure to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductAuthorizationProcedure); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductAuthorizationProcedure) : Integer;
    

    // Insert FhirMedicinalProductAuthorizationProcedure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductAuthorizationProcedure;
    

    // Insert an existing FhirMedicinalProductAuthorizationProcedure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductAuthorizationProcedure);
    
    // Get the iIndexth FhirMedicinalProductAuthorizationProcedure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductAuthorizationProcedure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductAuthorizationProcedure;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductAuthorizationProcedures[index : Integer] : TFhirMedicinalProductAuthorizationProcedure read GetItemN write SetItemN; default;
  End;

  // The regulatory authorization of a medicinal product.
  TFhirMedicinalProductAuthorization = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FSubject : TFhirReference{TFhirMedicinalProduct};
    FcountryList : TFhirCodeableConceptList;
    FjurisdictionList : TFhirCodeableConceptList;
    FStatus : TFhirCodeableConcept;
    FStatusDate : TFhirDateTime;
    FRestoreDate : TFhirDateTime;
    FValidityPeriod : TFhirPeriod;
    FDataExclusivityPeriod : TFhirPeriod;
    FDateOfFirstAuthorization : TFhirDateTime;
    FInternationalBirthDate : TFhirDateTime;
    FLegalBasis : TFhirCodeableConcept;
    FjurisdictionalAuthorizationList : TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList;
    FHolder : TFhirReference{TFhirOrganization};
    FRegulator : TFhirReference{TFhirOrganization};
    FProcedure_ : TFhirMedicinalProductAuthorizationProcedure;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetSubject(value : TFhirReference{TFhirMedicinalProduct});
    function GetCountryList : TFhirCodeableConceptList;
    function GetHasCountryList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    Procedure SetStatus(value : TFhirCodeableConcept);
    Procedure SetStatusDate(value : TFhirDateTime);
    Function GetStatusDateST : TFslDateTime;
    Procedure SetStatusDateST(value : TFslDateTime);
    Procedure SetRestoreDate(value : TFhirDateTime);
    Function GetRestoreDateST : TFslDateTime;
    Procedure SetRestoreDateST(value : TFslDateTime);
    Procedure SetValidityPeriod(value : TFhirPeriod);
    Procedure SetDataExclusivityPeriod(value : TFhirPeriod);
    Procedure SetDateOfFirstAuthorization(value : TFhirDateTime);
    Function GetDateOfFirstAuthorizationST : TFslDateTime;
    Procedure SetDateOfFirstAuthorizationST(value : TFslDateTime);
    Procedure SetInternationalBirthDate(value : TFhirDateTime);
    Function GetInternationalBirthDateST : TFslDateTime;
    Procedure SetInternationalBirthDateST(value : TFslDateTime);
    Procedure SetLegalBasis(value : TFhirCodeableConcept);
    function GetJurisdictionalAuthorizationList : TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList;
    function GetHasJurisdictionalAuthorizationList : Boolean;
    Procedure SetHolder(value : TFhirReference{TFhirOrganization});
    Procedure SetRegulator(value : TFhirReference{TFhirOrganization});
    Procedure SetProcedure_(value : TFhirMedicinalProductAuthorizationProcedure);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductAuthorization; overload;
    function Clone : TFhirMedicinalProductAuthorization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Business identifier for the marketing authorization, as assigned by a regulator.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The medicinal product that is being authorized. (defined for API consistency)
    property subject : TFhirReference{TFhirMedicinalProduct} read FSubject write SetSubject;
    // The medicinal product that is being authorized.
    property subjectElement : TFhirReference{TFhirMedicinalProduct} read FSubject write SetSubject;

    // The country in which the marketing authorization has been granted.
    property countryList : TFhirCodeableConceptList read GetCountryList;
    property hasCountryList : boolean read GetHasCountryList;

    // Jurisdiction within a country.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to The status of the marketing authorization. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status of the marketing authorization.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to The date at which the given status has become applicable.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // The date at which the given status has become applicable.
    property statusDateElement : TFhirDateTime read FStatusDate write SetStatusDate;

    // Typed access to The date when a suspended the marketing or the marketing authorization of the product is anticipated to be restored.
    property restoreDate : TFslDateTime read GetRestoreDateST write SetRestoreDateST;
    // The date when a suspended the marketing or the marketing authorization of the product is anticipated to be restored.
    property restoreDateElement : TFhirDateTime read FRestoreDate write SetRestoreDate;

    // Typed access to The beginning of the time period in which the marketing authorization is in the specific status shall be specified A complete date consisting of day, month and year shall be specified using the ISO 8601 date format. (defined for API consistency)
    property validityPeriod : TFhirPeriod read FValidityPeriod write SetValidityPeriod;
    // The beginning of the time period in which the marketing authorization is in the specific status shall be specified A complete date consisting of day, month and year shall be specified using the ISO 8601 date format.
    property validityPeriodElement : TFhirPeriod read FValidityPeriod write SetValidityPeriod;

    // Typed access to A period of time after authorization before generic product applicatiosn can be submitted. (defined for API consistency)
    property dataExclusivityPeriod : TFhirPeriod read FDataExclusivityPeriod write SetDataExclusivityPeriod;
    // A period of time after authorization before generic product applicatiosn can be submitted.
    property dataExclusivityPeriodElement : TFhirPeriod read FDataExclusivityPeriod write SetDataExclusivityPeriod;

    // Typed access to The date when the first authorization was granted by a Medicines Regulatory Agency.
    property dateOfFirstAuthorization : TFslDateTime read GetDateOfFirstAuthorizationST write SetDateOfFirstAuthorizationST;
    // The date when the first authorization was granted by a Medicines Regulatory Agency.
    property dateOfFirstAuthorizationElement : TFhirDateTime read FDateOfFirstAuthorization write SetDateOfFirstAuthorization;

    // Typed access to Date of first marketing authorization for a company's new medicinal product in any country in the World.
    property internationalBirthDate : TFslDateTime read GetInternationalBirthDateST write SetInternationalBirthDateST;
    // Date of first marketing authorization for a company's new medicinal product in any country in the World.
    property internationalBirthDateElement : TFhirDateTime read FInternationalBirthDate write SetInternationalBirthDate;

    // Typed access to The legal framework against which this authorization is granted. (defined for API consistency)
    property legalBasis : TFhirCodeableConcept read FLegalBasis write SetLegalBasis;
    // The legal framework against which this authorization is granted.
    property legalBasisElement : TFhirCodeableConcept read FLegalBasis write SetLegalBasis;

    // Authorization in areas within a country.
    property jurisdictionalAuthorizationList : TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList read GetJurisdictionalAuthorizationList;
    property hasJurisdictionalAuthorizationList : boolean read GetHasJurisdictionalAuthorizationList;

    // Typed access to Marketing Authorization Holder. (defined for API consistency)
    property holder : TFhirReference{TFhirOrganization} read FHolder write SetHolder;
    // Marketing Authorization Holder.
    property holderElement : TFhirReference{TFhirOrganization} read FHolder write SetHolder;

    // Typed access to Medicines Regulatory Agency. (defined for API consistency)
    property regulator : TFhirReference{TFhirOrganization} read FRegulator write SetRegulator;
    // Medicines Regulatory Agency.
    property regulatorElement : TFhirReference{TFhirOrganization} read FRegulator write SetRegulator;

    // Typed access to The regulatory procedure for granting or amending a marketing authorization. (defined for API consistency)
    property procedure_ : TFhirMedicinalProductAuthorizationProcedure read FProcedure_ write SetProcedure_;
    // The regulatory procedure for granting or amending a marketing authorization.
    property procedure_Element : TFhirMedicinalProductAuthorizationProcedure read FProcedure_ write SetProcedure_;

  end;

  TFhirMedicinalProductAuthorizationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductAuthorizationList;
    function GetCurrent : TFhirMedicinalProductAuthorization;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductAuthorizationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductAuthorization read GetCurrent;
  end;

  TFhirMedicinalProductAuthorizationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductAuthorization;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductAuthorization);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductAuthorizationList; Overload;
    function Clone : TFhirMedicinalProductAuthorizationList; Overload;
    function GetEnumerator : TFhirMedicinalProductAuthorizationListEnumerator;
    

    //  Add a FhirMedicinalProductAuthorization to the end of the list.
    function Append : TFhirMedicinalProductAuthorization;

    
    // Add an already existing FhirMedicinalProductAuthorization to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductAuthorization); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductAuthorization) : Integer;
    

    // Insert FhirMedicinalProductAuthorization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductAuthorization;
    

    // Insert an existing FhirMedicinalProductAuthorization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductAuthorization);
    
    // Get the iIndexth FhirMedicinalProductAuthorization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductAuthorization);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductAuthorization;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductAuthorizations[index : Integer] : TFhirMedicinalProductAuthorization read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICINALPRODUCTAUTHORIZATION}

{$IFDEF FHIR_MEDICINALPRODUCTCONTRAINDICATION}

  // Information about the use of the medicinal product in relation to other therapies described as part of the indication.
  TFhirMedicinalProductContraindicationOtherTherapy = class (TFhirBackboneElement)
  protected
    FTherapyRelationshipType : TFhirCodeableConcept;
    FMedication : TFhirType;
    Procedure SetTherapyRelationshipType(value : TFhirCodeableConcept);
    Procedure SetMedication(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductContraindicationOtherTherapy; overload;
    function Clone : TFhirMedicinalProductContraindicationOtherTherapy; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The type of relationship between the medicinal product indication or contraindication and another therapy. (defined for API consistency)
    property therapyRelationshipType : TFhirCodeableConcept read FTherapyRelationshipType write SetTherapyRelationshipType;
    // The type of relationship between the medicinal product indication or contraindication and another therapy.
    property therapyRelationshipTypeElement : TFhirCodeableConcept read FTherapyRelationshipType write SetTherapyRelationshipType;

    // Typed access to Reference to a specific medication (active substance, medicinal product or class of products) as part of an indication or contraindication. (defined for API consistency)
    property medication : TFhirType read FMedication write SetMedication;
    // Reference to a specific medication (active substance, medicinal product or class of products) as part of an indication or contraindication.
    property medicationElement : TFhirType read FMedication write SetMedication;

  end;

  TFhirMedicinalProductContraindicationOtherTherapyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductContraindicationOtherTherapyList;
    function GetCurrent : TFhirMedicinalProductContraindicationOtherTherapy;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductContraindicationOtherTherapyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductContraindicationOtherTherapy read GetCurrent;
  end;

  TFhirMedicinalProductContraindicationOtherTherapyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductContraindicationOtherTherapy;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductContraindicationOtherTherapy);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductContraindicationOtherTherapyList; Overload;
    function Clone : TFhirMedicinalProductContraindicationOtherTherapyList; Overload;
    function GetEnumerator : TFhirMedicinalProductContraindicationOtherTherapyListEnumerator;
    

    //  Add a FhirMedicinalProductContraindicationOtherTherapy to the end of the list.
    function Append : TFhirMedicinalProductContraindicationOtherTherapy;

    
    // Add an already existing FhirMedicinalProductContraindicationOtherTherapy to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductContraindicationOtherTherapy); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductContraindicationOtherTherapy) : Integer;
    

    // Insert FhirMedicinalProductContraindicationOtherTherapy before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductContraindicationOtherTherapy;
    

    // Insert an existing FhirMedicinalProductContraindicationOtherTherapy before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductContraindicationOtherTherapy);
    
    // Get the iIndexth FhirMedicinalProductContraindicationOtherTherapy. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductContraindicationOtherTherapy);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductContraindicationOtherTherapy;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductContraindicationOtherTherapies[index : Integer] : TFhirMedicinalProductContraindicationOtherTherapy read GetItemN write SetItemN; default;
  End;

  // The clinical particulars - indications, contraindications etc. of a medicinal product, including for regulatory purposes.
  TFhirMedicinalProductContraindication = class (TFhirDomainResource)
  protected
    FsubjectList : TFhirReferenceList{TFhirMedicinalProduct};
    FDisease : TFhirCodeableConcept;
    FDiseaseStatus : TFhirCodeableConcept;
    FcomorbidityList : TFhirCodeableConceptList;
    FtherapeuticIndicationList : TFhirReferenceList{TFhirMedicinalProductIndication};
    FotherTherapyList : TFhirMedicinalProductContraindicationOtherTherapyList;
    FpopulationList : TFhirPopulationList;
    function GetSubjectList : TFhirReferenceList{TFhirMedicinalProduct};
    function GetHasSubjectList : Boolean;
    Procedure SetDisease(value : TFhirCodeableConcept);
    Procedure SetDiseaseStatus(value : TFhirCodeableConcept);
    function GetComorbidityList : TFhirCodeableConceptList;
    function GetHasComorbidityList : Boolean;
    function GetTherapeuticIndicationList : TFhirReferenceList{TFhirMedicinalProductIndication};
    function GetHasTherapeuticIndicationList : Boolean;
    function GetOtherTherapyList : TFhirMedicinalProductContraindicationOtherTherapyList;
    function GetHasOtherTherapyList : Boolean;
    function GetPopulationList : TFhirPopulationList;
    function GetHasPopulationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductContraindication; overload;
    function Clone : TFhirMedicinalProductContraindication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The medication for which this is an indication.
    property subjectList : TFhirReferenceList{TFhirMedicinalProduct} read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // Typed access to The disease, symptom or procedure for the contraindication. (defined for API consistency)
    property disease : TFhirCodeableConcept read FDisease write SetDisease;
    // The disease, symptom or procedure for the contraindication.
    property diseaseElement : TFhirCodeableConcept read FDisease write SetDisease;

    // Typed access to The status of the disease or symptom for the contraindication. (defined for API consistency)
    property diseaseStatus : TFhirCodeableConcept read FDiseaseStatus write SetDiseaseStatus;
    // The status of the disease or symptom for the contraindication.
    property diseaseStatusElement : TFhirCodeableConcept read FDiseaseStatus write SetDiseaseStatus;

    // A comorbidity (concurrent condition) or coinfection.
    property comorbidityList : TFhirCodeableConceptList read GetComorbidityList;
    property hasComorbidityList : boolean read GetHasComorbidityList;

    // Information about the use of the medicinal product in relation to other therapies as part of the indication.
    property therapeuticIndicationList : TFhirReferenceList{TFhirMedicinalProductIndication} read GetTherapeuticIndicationList;
    property hasTherapeuticIndicationList : boolean read GetHasTherapeuticIndicationList;

    // Information about the use of the medicinal product in relation to other therapies described as part of the indication.
    property otherTherapyList : TFhirMedicinalProductContraindicationOtherTherapyList read GetOtherTherapyList;
    property hasOtherTherapyList : boolean read GetHasOtherTherapyList;

    // The population group to which this applies.
    property populationList : TFhirPopulationList read GetPopulationList;
    property hasPopulationList : boolean read GetHasPopulationList;

  end;

  TFhirMedicinalProductContraindicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductContraindicationList;
    function GetCurrent : TFhirMedicinalProductContraindication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductContraindicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductContraindication read GetCurrent;
  end;

  TFhirMedicinalProductContraindicationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductContraindication;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductContraindication);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductContraindicationList; Overload;
    function Clone : TFhirMedicinalProductContraindicationList; Overload;
    function GetEnumerator : TFhirMedicinalProductContraindicationListEnumerator;
    

    //  Add a FhirMedicinalProductContraindication to the end of the list.
    function Append : TFhirMedicinalProductContraindication;

    
    // Add an already existing FhirMedicinalProductContraindication to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductContraindication); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductContraindication) : Integer;
    

    // Insert FhirMedicinalProductContraindication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductContraindication;
    

    // Insert an existing FhirMedicinalProductContraindication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductContraindication);
    
    // Get the iIndexth FhirMedicinalProductContraindication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductContraindication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductContraindication;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductContraindications[index : Integer] : TFhirMedicinalProductContraindication read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICINALPRODUCTCONTRAINDICATION}

{$IFDEF FHIR_MEDICINALPRODUCTINDICATION}

  // Information about the use of the medicinal product in relation to other therapies described as part of the indication.
  TFhirMedicinalProductIndicationOtherTherapy = class (TFhirBackboneElement)
  protected
    FTherapyRelationshipType : TFhirCodeableConcept;
    FMedication : TFhirType;
    Procedure SetTherapyRelationshipType(value : TFhirCodeableConcept);
    Procedure SetMedication(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductIndicationOtherTherapy; overload;
    function Clone : TFhirMedicinalProductIndicationOtherTherapy; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The type of relationship between the medicinal product indication or contraindication and another therapy. (defined for API consistency)
    property therapyRelationshipType : TFhirCodeableConcept read FTherapyRelationshipType write SetTherapyRelationshipType;
    // The type of relationship between the medicinal product indication or contraindication and another therapy.
    property therapyRelationshipTypeElement : TFhirCodeableConcept read FTherapyRelationshipType write SetTherapyRelationshipType;

    // Typed access to Reference to a specific medication (active substance, medicinal product or class of products) as part of an indication or contraindication. (defined for API consistency)
    property medication : TFhirType read FMedication write SetMedication;
    // Reference to a specific medication (active substance, medicinal product or class of products) as part of an indication or contraindication.
    property medicationElement : TFhirType read FMedication write SetMedication;

  end;

  TFhirMedicinalProductIndicationOtherTherapyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductIndicationOtherTherapyList;
    function GetCurrent : TFhirMedicinalProductIndicationOtherTherapy;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductIndicationOtherTherapyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductIndicationOtherTherapy read GetCurrent;
  end;

  TFhirMedicinalProductIndicationOtherTherapyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductIndicationOtherTherapy;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductIndicationOtherTherapy);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductIndicationOtherTherapyList; Overload;
    function Clone : TFhirMedicinalProductIndicationOtherTherapyList; Overload;
    function GetEnumerator : TFhirMedicinalProductIndicationOtherTherapyListEnumerator;
    

    //  Add a FhirMedicinalProductIndicationOtherTherapy to the end of the list.
    function Append : TFhirMedicinalProductIndicationOtherTherapy;

    
    // Add an already existing FhirMedicinalProductIndicationOtherTherapy to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductIndicationOtherTherapy); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductIndicationOtherTherapy) : Integer;
    

    // Insert FhirMedicinalProductIndicationOtherTherapy before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductIndicationOtherTherapy;
    

    // Insert an existing FhirMedicinalProductIndicationOtherTherapy before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductIndicationOtherTherapy);
    
    // Get the iIndexth FhirMedicinalProductIndicationOtherTherapy. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductIndicationOtherTherapy);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductIndicationOtherTherapy;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductIndicationOtherTherapies[index : Integer] : TFhirMedicinalProductIndicationOtherTherapy read GetItemN write SetItemN; default;
  End;

  // Indication for the Medicinal Product.
  TFhirMedicinalProductIndication = class (TFhirDomainResource)
  protected
    FsubjectList : TFhirReferenceList{TFhirMedicinalProduct};
    FDiseaseSymptomProcedure : TFhirCodeableConcept;
    FDiseaseStatus : TFhirCodeableConcept;
    FcomorbidityList : TFhirCodeableConceptList;
    FIntendedEffect : TFhirCodeableConcept;
    FDuration : TFhirQuantity;
    FotherTherapyList : TFhirMedicinalProductIndicationOtherTherapyList;
    FundesirableEffectList : TFhirReferenceList{TFhirMedicinalProductUndesirableEffect};
    FpopulationList : TFhirPopulationList;
    function GetSubjectList : TFhirReferenceList{TFhirMedicinalProduct};
    function GetHasSubjectList : Boolean;
    Procedure SetDiseaseSymptomProcedure(value : TFhirCodeableConcept);
    Procedure SetDiseaseStatus(value : TFhirCodeableConcept);
    function GetComorbidityList : TFhirCodeableConceptList;
    function GetHasComorbidityList : Boolean;
    Procedure SetIntendedEffect(value : TFhirCodeableConcept);
    Procedure SetDuration(value : TFhirQuantity);
    function GetOtherTherapyList : TFhirMedicinalProductIndicationOtherTherapyList;
    function GetHasOtherTherapyList : Boolean;
    function GetUndesirableEffectList : TFhirReferenceList{TFhirMedicinalProductUndesirableEffect};
    function GetHasUndesirableEffectList : Boolean;
    function GetPopulationList : TFhirPopulationList;
    function GetHasPopulationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductIndication; overload;
    function Clone : TFhirMedicinalProductIndication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The medication for which this is an indication.
    property subjectList : TFhirReferenceList{TFhirMedicinalProduct} read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // Typed access to The disease, symptom or procedure that is the indication for treatment. (defined for API consistency)
    property diseaseSymptomProcedure : TFhirCodeableConcept read FDiseaseSymptomProcedure write SetDiseaseSymptomProcedure;
    // The disease, symptom or procedure that is the indication for treatment.
    property diseaseSymptomProcedureElement : TFhirCodeableConcept read FDiseaseSymptomProcedure write SetDiseaseSymptomProcedure;

    // Typed access to The status of the disease or symptom for which the indication applies. (defined for API consistency)
    property diseaseStatus : TFhirCodeableConcept read FDiseaseStatus write SetDiseaseStatus;
    // The status of the disease or symptom for which the indication applies.
    property diseaseStatusElement : TFhirCodeableConcept read FDiseaseStatus write SetDiseaseStatus;

    // Comorbidity (concurrent condition) or co-infection as part of the indication.
    property comorbidityList : TFhirCodeableConceptList read GetComorbidityList;
    property hasComorbidityList : boolean read GetHasComorbidityList;

    // Typed access to The intended effect, aim or strategy to be achieved by the indication. (defined for API consistency)
    property intendedEffect : TFhirCodeableConcept read FIntendedEffect write SetIntendedEffect;
    // The intended effect, aim or strategy to be achieved by the indication.
    property intendedEffectElement : TFhirCodeableConcept read FIntendedEffect write SetIntendedEffect;

    // Typed access to Timing or duration information as part of the indication. (defined for API consistency)
    property duration : TFhirQuantity read FDuration write SetDuration;
    // Timing or duration information as part of the indication.
    property durationElement : TFhirQuantity read FDuration write SetDuration;

    // Information about the use of the medicinal product in relation to other therapies described as part of the indication.
    property otherTherapyList : TFhirMedicinalProductIndicationOtherTherapyList read GetOtherTherapyList;
    property hasOtherTherapyList : boolean read GetHasOtherTherapyList;

    // Describe the undesirable effects of the medicinal product.
    property undesirableEffectList : TFhirReferenceList{TFhirMedicinalProductUndesirableEffect} read GetUndesirableEffectList;
    property hasUndesirableEffectList : boolean read GetHasUndesirableEffectList;

    // The population group to which this applies.
    property populationList : TFhirPopulationList read GetPopulationList;
    property hasPopulationList : boolean read GetHasPopulationList;

  end;

  TFhirMedicinalProductIndicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductIndicationList;
    function GetCurrent : TFhirMedicinalProductIndication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductIndicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductIndication read GetCurrent;
  end;

  TFhirMedicinalProductIndicationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductIndication;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductIndication);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductIndicationList; Overload;
    function Clone : TFhirMedicinalProductIndicationList; Overload;
    function GetEnumerator : TFhirMedicinalProductIndicationListEnumerator;
    

    //  Add a FhirMedicinalProductIndication to the end of the list.
    function Append : TFhirMedicinalProductIndication;

    
    // Add an already existing FhirMedicinalProductIndication to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductIndication); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductIndication) : Integer;
    

    // Insert FhirMedicinalProductIndication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductIndication;
    

    // Insert an existing FhirMedicinalProductIndication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductIndication);
    
    // Get the iIndexth FhirMedicinalProductIndication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductIndication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductIndication;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductIndications[index : Integer] : TFhirMedicinalProductIndication read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICINALPRODUCTINDICATION}

{$IFDEF FHIR_MEDICINALPRODUCTINGREDIENT}

  // A specified substance that comprises this ingredient.
  TFhirMedicinalProductIngredientSpecifiedSubstance = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FGroup : TFhirCodeableConcept;
    FConfidentiality : TFhirCodeableConcept;
    FstrengthList : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetGroup(value : TFhirCodeableConcept);
    Procedure SetConfidentiality(value : TFhirCodeableConcept);
    function GetStrengthList : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList;
    function GetHasStrengthList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductIngredientSpecifiedSubstance; overload;
    function Clone : TFhirMedicinalProductIngredientSpecifiedSubstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The specified substance. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The specified substance.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The group of specified substance, e.g. group 1 to 4. (defined for API consistency)
    property group : TFhirCodeableConcept read FGroup write SetGroup;
    // The group of specified substance, e.g. group 1 to 4.
    property groupElement : TFhirCodeableConcept read FGroup write SetGroup;

    // Typed access to Confidentiality level of the specified substance as the ingredient. (defined for API consistency)
    property confidentiality : TFhirCodeableConcept read FConfidentiality write SetConfidentiality;
    // Confidentiality level of the specified substance as the ingredient.
    property confidentialityElement : TFhirCodeableConcept read FConfidentiality write SetConfidentiality;

    // Quantity of the substance or specified substance present in the manufactured item or pharmaceutical product.
    property strengthList : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList read GetStrengthList;
    property hasStrengthList : boolean read GetHasStrengthList;

  end;

  TFhirMedicinalProductIngredientSpecifiedSubstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductIngredientSpecifiedSubstanceList;
    function GetCurrent : TFhirMedicinalProductIngredientSpecifiedSubstance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductIngredientSpecifiedSubstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductIngredientSpecifiedSubstance read GetCurrent;
  end;

  TFhirMedicinalProductIngredientSpecifiedSubstanceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductIngredientSpecifiedSubstance;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductIngredientSpecifiedSubstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductIngredientSpecifiedSubstanceList; Overload;
    function Clone : TFhirMedicinalProductIngredientSpecifiedSubstanceList; Overload;
    function GetEnumerator : TFhirMedicinalProductIngredientSpecifiedSubstanceListEnumerator;
    

    //  Add a FhirMedicinalProductIngredientSpecifiedSubstance to the end of the list.
    function Append : TFhirMedicinalProductIngredientSpecifiedSubstance;

    
    // Add an already existing FhirMedicinalProductIngredientSpecifiedSubstance to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductIngredientSpecifiedSubstance); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductIngredientSpecifiedSubstance) : Integer;
    

    // Insert FhirMedicinalProductIngredientSpecifiedSubstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductIngredientSpecifiedSubstance;
    

    // Insert an existing FhirMedicinalProductIngredientSpecifiedSubstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductIngredientSpecifiedSubstance);
    
    // Get the iIndexth FhirMedicinalProductIngredientSpecifiedSubstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductIngredientSpecifiedSubstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductIngredientSpecifiedSubstance;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductIngredientSpecifiedSubstances[index : Integer] : TFhirMedicinalProductIngredientSpecifiedSubstance read GetItemN write SetItemN; default;
  End;

  // Quantity of the substance or specified substance present in the manufactured item or pharmaceutical product.
  TFhirMedicinalProductIngredientSpecifiedSubstanceStrength = class (TFhirBackboneElement)
  protected
    FPresentation : TFhirRatio;
    FPresentationLowLimit : TFhirRatio;
    FConcentration : TFhirRatio;
    FConcentrationLowLimit : TFhirRatio;
    FMeasurementPoint : TFhirString;
    FcountryList : TFhirCodeableConceptList;
    FreferenceStrengthList : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList;
    Procedure SetPresentation(value : TFhirRatio);
    Procedure SetPresentationLowLimit(value : TFhirRatio);
    Procedure SetConcentration(value : TFhirRatio);
    Procedure SetConcentrationLowLimit(value : TFhirRatio);
    Procedure SetMeasurementPoint(value : TFhirString);
    Function GetMeasurementPointST : String;
    Procedure SetMeasurementPointST(value : String);
    function GetCountryList : TFhirCodeableConceptList;
    function GetHasCountryList : Boolean;
    function GetReferenceStrengthList : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList;
    function GetHasReferenceStrengthList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength; overload;
    function Clone : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. (defined for API consistency)
    property presentation : TFhirRatio read FPresentation write SetPresentation;
    // The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item.
    property presentationElement : TFhirRatio read FPresentation write SetPresentation;

    // Typed access to A lower limit for the quantity of substance in the unit of presentation. For use when there is a range of strengths, this is the lower limit, with the presentation attribute becoming the upper limit. (defined for API consistency)
    property presentationLowLimit : TFhirRatio read FPresentationLowLimit write SetPresentationLowLimit;
    // A lower limit for the quantity of substance in the unit of presentation. For use when there is a range of strengths, this is the lower limit, with the presentation attribute becoming the upper limit.
    property presentationLowLimitElement : TFhirRatio read FPresentationLowLimit write SetPresentationLowLimit;

    // Typed access to The strength per unitary volume (or mass). (defined for API consistency)
    property concentration : TFhirRatio read FConcentration write SetConcentration;
    // The strength per unitary volume (or mass).
    property concentrationElement : TFhirRatio read FConcentration write SetConcentration;

    // Typed access to A lower limit for the strength per unitary volume (or mass), for when there is a range. The concentration attribute then becomes the upper limit. (defined for API consistency)
    property concentrationLowLimit : TFhirRatio read FConcentrationLowLimit write SetConcentrationLowLimit;
    // A lower limit for the strength per unitary volume (or mass), for when there is a range. The concentration attribute then becomes the upper limit.
    property concentrationLowLimitElement : TFhirRatio read FConcentrationLowLimit write SetConcentrationLowLimit;

    // Typed access to For when strength is measured at a particular point or distance.
    property measurementPoint : String read GetMeasurementPointST write SetMeasurementPointST;
    // For when strength is measured at a particular point or distance.
    property measurementPointElement : TFhirString read FMeasurementPoint write SetMeasurementPoint;

    // The country or countries for which the strength range applies.
    property countryList : TFhirCodeableConceptList read GetCountryList;
    property hasCountryList : boolean read GetHasCountryList;

    // Strength expressed in terms of a reference substance.
    property referenceStrengthList : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList read GetReferenceStrengthList;
    property hasReferenceStrengthList : boolean read GetHasReferenceStrengthList;

  end;

  TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList;
    function GetCurrent : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength read GetCurrent;
  end;

  TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList; Overload;
    function Clone : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList; Overload;
    function GetEnumerator : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthListEnumerator;
    

    //  Add a FhirMedicinalProductIngredientSpecifiedSubstanceStrength to the end of the list.
    function Append : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength;

    
    // Add an already existing FhirMedicinalProductIngredientSpecifiedSubstanceStrength to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength) : Integer;
    

    // Insert FhirMedicinalProductIngredientSpecifiedSubstanceStrength before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength;
    

    // Insert an existing FhirMedicinalProductIngredientSpecifiedSubstanceStrength before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength);
    
    // Get the iIndexth FhirMedicinalProductIngredientSpecifiedSubstanceStrength. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductIngredientSpecifiedSubstanceStrengths[index : Integer] : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength read GetItemN write SetItemN; default;
  End;

  // Strength expressed in terms of a reference substance.
  TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength = class (TFhirBackboneElement)
  protected
    FSubstance : TFhirCodeableConcept;
    FStrength : TFhirRatio;
    FStrengthLowLimit : TFhirRatio;
    FMeasurementPoint : TFhirString;
    FcountryList : TFhirCodeableConceptList;
    Procedure SetSubstance(value : TFhirCodeableConcept);
    Procedure SetStrength(value : TFhirRatio);
    Procedure SetStrengthLowLimit(value : TFhirRatio);
    Procedure SetMeasurementPoint(value : TFhirString);
    Function GetMeasurementPointST : String;
    Procedure SetMeasurementPointST(value : String);
    function GetCountryList : TFhirCodeableConceptList;
    function GetHasCountryList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength; overload;
    function Clone : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Relevant reference substance. (defined for API consistency)
    property substance : TFhirCodeableConcept read FSubstance write SetSubstance;
    // Relevant reference substance.
    property substanceElement : TFhirCodeableConcept read FSubstance write SetSubstance;

    // Typed access to Strength expressed in terms of a reference substance. (defined for API consistency)
    property strength : TFhirRatio read FStrength write SetStrength;
    // Strength expressed in terms of a reference substance.
    property strengthElement : TFhirRatio read FStrength write SetStrength;

    // Typed access to Strength expressed in terms of a reference substance. (defined for API consistency)
    property strengthLowLimit : TFhirRatio read FStrengthLowLimit write SetStrengthLowLimit;
    // Strength expressed in terms of a reference substance.
    property strengthLowLimitElement : TFhirRatio read FStrengthLowLimit write SetStrengthLowLimit;

    // Typed access to For when strength is measured at a particular point or distance.
    property measurementPoint : String read GetMeasurementPointST write SetMeasurementPointST;
    // For when strength is measured at a particular point or distance.
    property measurementPointElement : TFhirString read FMeasurementPoint write SetMeasurementPoint;

    // The country or countries for which the strength range applies.
    property countryList : TFhirCodeableConceptList read GetCountryList;
    property hasCountryList : boolean read GetHasCountryList;

  end;

  TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList;
    function GetCurrent : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength read GetCurrent;
  end;

  TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList; Overload;
    function Clone : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList; Overload;
    function GetEnumerator : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthListEnumerator;
    

    //  Add a FhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength to the end of the list.
    function Append : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength;

    
    // Add an already existing FhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength) : Integer;
    

    // Insert FhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength;
    

    // Insert an existing FhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength);
    
    // Get the iIndexth FhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengths[index : Integer] : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength read GetItemN write SetItemN; default;
  End;

  // The ingredient substance.
  TFhirMedicinalProductIngredientSubstance = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FstrengthList : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList;
    Procedure SetCode(value : TFhirCodeableConcept);
    function GetStrengthList : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList;
    function GetHasStrengthList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductIngredientSubstance; overload;
    function Clone : TFhirMedicinalProductIngredientSubstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The ingredient substance. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The ingredient substance.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Quantity of the substance or specified substance present in the manufactured item or pharmaceutical product.
    property strengthList : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList read GetStrengthList;
    property hasStrengthList : boolean read GetHasStrengthList;

  end;

  TFhirMedicinalProductIngredientSubstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductIngredientSubstanceList;
    function GetCurrent : TFhirMedicinalProductIngredientSubstance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductIngredientSubstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductIngredientSubstance read GetCurrent;
  end;

  TFhirMedicinalProductIngredientSubstanceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductIngredientSubstance;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductIngredientSubstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductIngredientSubstanceList; Overload;
    function Clone : TFhirMedicinalProductIngredientSubstanceList; Overload;
    function GetEnumerator : TFhirMedicinalProductIngredientSubstanceListEnumerator;
    

    //  Add a FhirMedicinalProductIngredientSubstance to the end of the list.
    function Append : TFhirMedicinalProductIngredientSubstance;

    
    // Add an already existing FhirMedicinalProductIngredientSubstance to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductIngredientSubstance); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductIngredientSubstance) : Integer;
    

    // Insert FhirMedicinalProductIngredientSubstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductIngredientSubstance;
    

    // Insert an existing FhirMedicinalProductIngredientSubstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductIngredientSubstance);
    
    // Get the iIndexth FhirMedicinalProductIngredientSubstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductIngredientSubstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductIngredientSubstance;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductIngredientSubstances[index : Integer] : TFhirMedicinalProductIngredientSubstance read GetItemN write SetItemN; default;
  End;

  // An ingredient of a manufactured item or pharmaceutical product.
  TFhirMedicinalProductIngredient = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FRole : TFhirCodeableConcept;
    FAllergenicIndicator : TFhirBoolean;
    FmanufacturerList : TFhirReferenceList{TFhirOrganization};
    FspecifiedSubstanceList : TFhirMedicinalProductIngredientSpecifiedSubstanceList;
    FSubstance : TFhirMedicinalProductIngredientSubstance;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetRole(value : TFhirCodeableConcept);
    Procedure SetAllergenicIndicator(value : TFhirBoolean);
    Function GetAllergenicIndicatorST : Boolean;
    Procedure SetAllergenicIndicatorST(value : Boolean);
    function GetManufacturerList : TFhirReferenceList{TFhirOrganization};
    function GetHasManufacturerList : Boolean;
    function GetSpecifiedSubstanceList : TFhirMedicinalProductIngredientSpecifiedSubstanceList;
    function GetHasSpecifiedSubstanceList : Boolean;
    Procedure SetSubstance(value : TFhirMedicinalProductIngredientSubstance);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductIngredient; overload;
    function Clone : TFhirMedicinalProductIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The identifier(s) of this Ingredient that are assigned by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // The identifier(s) of this Ingredient that are assigned by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Ingredient role e.g. Active ingredient, excipient. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Ingredient role e.g. Active ingredient, excipient.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to If the ingredient is a known or suspected allergen.
    property allergenicIndicator : Boolean read GetAllergenicIndicatorST write SetAllergenicIndicatorST;
    // If the ingredient is a known or suspected allergen.
    property allergenicIndicatorElement : TFhirBoolean read FAllergenicIndicator write SetAllergenicIndicator;

    // Manufacturer of this Ingredient.
    property manufacturerList : TFhirReferenceList{TFhirOrganization} read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // A specified substance that comprises this ingredient.
    property specifiedSubstanceList : TFhirMedicinalProductIngredientSpecifiedSubstanceList read GetSpecifiedSubstanceList;
    property hasSpecifiedSubstanceList : boolean read GetHasSpecifiedSubstanceList;

    // Typed access to The ingredient substance. (defined for API consistency)
    property substance : TFhirMedicinalProductIngredientSubstance read FSubstance write SetSubstance;
    // The ingredient substance.
    property substanceElement : TFhirMedicinalProductIngredientSubstance read FSubstance write SetSubstance;

  end;

  TFhirMedicinalProductIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductIngredientList;
    function GetCurrent : TFhirMedicinalProductIngredient;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductIngredient read GetCurrent;
  end;

  TFhirMedicinalProductIngredientList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductIngredient;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductIngredientList; Overload;
    function Clone : TFhirMedicinalProductIngredientList; Overload;
    function GetEnumerator : TFhirMedicinalProductIngredientListEnumerator;
    

    //  Add a FhirMedicinalProductIngredient to the end of the list.
    function Append : TFhirMedicinalProductIngredient;

    
    // Add an already existing FhirMedicinalProductIngredient to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductIngredient); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductIngredient) : Integer;
    

    // Insert FhirMedicinalProductIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductIngredient;
    

    // Insert an existing FhirMedicinalProductIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductIngredient);
    
    // Get the iIndexth FhirMedicinalProductIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductIngredient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductIngredient;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductIngredients[index : Integer] : TFhirMedicinalProductIngredient read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICINALPRODUCTINGREDIENT}

{$IFDEF FHIR_MEDICINALPRODUCTINTERACTION}

  // The specific medication, food or laboratory test that interacts.
  TFhirMedicinalProductInteractionInteractant = class (TFhirBackboneElement)
  protected
    FItem : TFhirType;
    Procedure SetItem(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductInteractionInteractant; overload;
    function Clone : TFhirMedicinalProductInteractionInteractant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The specific medication, food or laboratory test that interacts. (defined for API consistency)
    property item : TFhirType read FItem write SetItem;
    // The specific medication, food or laboratory test that interacts.
    property itemElement : TFhirType read FItem write SetItem;

  end;

  TFhirMedicinalProductInteractionInteractantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductInteractionInteractantList;
    function GetCurrent : TFhirMedicinalProductInteractionInteractant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductInteractionInteractantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductInteractionInteractant read GetCurrent;
  end;

  TFhirMedicinalProductInteractionInteractantList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductInteractionInteractant;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductInteractionInteractant);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductInteractionInteractantList; Overload;
    function Clone : TFhirMedicinalProductInteractionInteractantList; Overload;
    function GetEnumerator : TFhirMedicinalProductInteractionInteractantListEnumerator;
    

    //  Add a FhirMedicinalProductInteractionInteractant to the end of the list.
    function Append : TFhirMedicinalProductInteractionInteractant;

    
    // Add an already existing FhirMedicinalProductInteractionInteractant to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductInteractionInteractant); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductInteractionInteractant) : Integer;
    

    // Insert FhirMedicinalProductInteractionInteractant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductInteractionInteractant;
    

    // Insert an existing FhirMedicinalProductInteractionInteractant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductInteractionInteractant);
    
    // Get the iIndexth FhirMedicinalProductInteractionInteractant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductInteractionInteractant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductInteractionInteractant;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductInteractionInteractants[index : Integer] : TFhirMedicinalProductInteractionInteractant read GetItemN write SetItemN; default;
  End;

  // The interactions of the medicinal product with other medicinal products, or other forms of interactions.
  TFhirMedicinalProductInteraction = class (TFhirDomainResource)
  protected
    FsubjectList : TFhirReferenceList{TFhirMedicinalProduct};
    FDescription : TFhirString;
    FinteractantList : TFhirMedicinalProductInteractionInteractantList;
    FType_ : TFhirCodeableConcept;
    FEffect : TFhirCodeableConcept;
    FIncidence : TFhirCodeableConcept;
    FManagement : TFhirCodeableConcept;
    function GetSubjectList : TFhirReferenceList{TFhirMedicinalProduct};
    function GetHasSubjectList : Boolean;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetInteractantList : TFhirMedicinalProductInteractionInteractantList;
    function GetHasInteractantList : Boolean;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetEffect(value : TFhirCodeableConcept);
    Procedure SetIncidence(value : TFhirCodeableConcept);
    Procedure SetManagement(value : TFhirCodeableConcept);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductInteraction; overload;
    function Clone : TFhirMedicinalProductInteraction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The medication for which this is a described interaction.
    property subjectList : TFhirReferenceList{TFhirMedicinalProduct} read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // Typed access to The interaction described.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The interaction described.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The specific medication, food or laboratory test that interacts.
    property interactantList : TFhirMedicinalProductInteractionInteractantList read GetInteractantList;
    property hasInteractantList : boolean read GetHasInteractantList;

    // Typed access to The type of the interaction e.g. drug-drug interaction, drug-food interaction, drug-lab test interaction. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of the interaction e.g. drug-drug interaction, drug-food interaction, drug-lab test interaction.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The effect of the interaction, for example "reduced gastric absorption of primary medication". (defined for API consistency)
    property effect : TFhirCodeableConcept read FEffect write SetEffect;
    // The effect of the interaction, for example "reduced gastric absorption of primary medication".
    property effectElement : TFhirCodeableConcept read FEffect write SetEffect;

    // Typed access to The incidence of the interaction, e.g. theoretical, observed. (defined for API consistency)
    property incidence : TFhirCodeableConcept read FIncidence write SetIncidence;
    // The incidence of the interaction, e.g. theoretical, observed.
    property incidenceElement : TFhirCodeableConcept read FIncidence write SetIncidence;

    // Typed access to Actions for managing the interaction. (defined for API consistency)
    property management : TFhirCodeableConcept read FManagement write SetManagement;
    // Actions for managing the interaction.
    property managementElement : TFhirCodeableConcept read FManagement write SetManagement;

  end;

  TFhirMedicinalProductInteractionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductInteractionList;
    function GetCurrent : TFhirMedicinalProductInteraction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductInteractionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductInteraction read GetCurrent;
  end;

  TFhirMedicinalProductInteractionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductInteraction;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductInteraction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductInteractionList; Overload;
    function Clone : TFhirMedicinalProductInteractionList; Overload;
    function GetEnumerator : TFhirMedicinalProductInteractionListEnumerator;
    

    //  Add a FhirMedicinalProductInteraction to the end of the list.
    function Append : TFhirMedicinalProductInteraction;

    
    // Add an already existing FhirMedicinalProductInteraction to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductInteraction); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductInteraction) : Integer;
    

    // Insert FhirMedicinalProductInteraction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductInteraction;
    

    // Insert an existing FhirMedicinalProductInteraction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductInteraction);
    
    // Get the iIndexth FhirMedicinalProductInteraction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductInteraction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductInteraction;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductInteractions[index : Integer] : TFhirMedicinalProductInteraction read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICINALPRODUCTINTERACTION}

{$IFDEF FHIR_MEDICINALPRODUCTMANUFACTURED}

  // The manufactured item as contained in the packaged medicinal product.
  TFhirMedicinalProductManufactured = class (TFhirDomainResource)
  protected
    FManufacturedDoseForm : TFhirCodeableConcept;
    FUnitOfPresentation : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FmanufacturerList : TFhirReferenceList{TFhirOrganization};
    FingredientList : TFhirReferenceList{TFhirMedicinalProductIngredient};
    FPhysicalCharacteristics : TFhirProdCharacteristic;
    FotherCharacteristicsList : TFhirCodeableConceptList;
    Procedure SetManufacturedDoseForm(value : TFhirCodeableConcept);
    Procedure SetUnitOfPresentation(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    function GetManufacturerList : TFhirReferenceList{TFhirOrganization};
    function GetHasManufacturerList : Boolean;
    function GetIngredientList : TFhirReferenceList{TFhirMedicinalProductIngredient};
    function GetHasIngredientList : Boolean;
    Procedure SetPhysicalCharacteristics(value : TFhirProdCharacteristic);
    function GetOtherCharacteristicsList : TFhirCodeableConceptList;
    function GetHasOtherCharacteristicsList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductManufactured; overload;
    function Clone : TFhirMedicinalProductManufactured; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Dose form as manufactured and before any transformation into the pharmaceutical product. (defined for API consistency)
    property manufacturedDoseForm : TFhirCodeableConcept read FManufacturedDoseForm write SetManufacturedDoseForm;
    // Dose form as manufactured and before any transformation into the pharmaceutical product.
    property manufacturedDoseFormElement : TFhirCodeableConcept read FManufacturedDoseForm write SetManufacturedDoseForm;

    // Typed access to The ?real world? units in which the quantity of the manufactured item is described. (defined for API consistency)
    property unitOfPresentation : TFhirCodeableConcept read FUnitOfPresentation write SetUnitOfPresentation;
    // The ?real world? units in which the quantity of the manufactured item is described.
    property unitOfPresentationElement : TFhirCodeableConcept read FUnitOfPresentation write SetUnitOfPresentation;

    // Typed access to The quantity or "count number" of the manufactured item. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The quantity or "count number" of the manufactured item.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Manufacturer of the item (Note that this should be named "manufacturer" but it currently causes technical issues).
    property manufacturerList : TFhirReferenceList{TFhirOrganization} read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // Ingredient.
    property ingredientList : TFhirReferenceList{TFhirMedicinalProductIngredient} read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // Typed access to Dimensions, color etc. (defined for API consistency)
    property physicalCharacteristics : TFhirProdCharacteristic read FPhysicalCharacteristics write SetPhysicalCharacteristics;
    // Dimensions, color etc.
    property physicalCharacteristicsElement : TFhirProdCharacteristic read FPhysicalCharacteristics write SetPhysicalCharacteristics;

    // Other codeable characteristics.
    property otherCharacteristicsList : TFhirCodeableConceptList read GetOtherCharacteristicsList;
    property hasOtherCharacteristicsList : boolean read GetHasOtherCharacteristicsList;

  end;

  TFhirMedicinalProductManufacturedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductManufacturedList;
    function GetCurrent : TFhirMedicinalProductManufactured;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductManufacturedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductManufactured read GetCurrent;
  end;

  TFhirMedicinalProductManufacturedList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductManufactured;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductManufactured);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductManufacturedList; Overload;
    function Clone : TFhirMedicinalProductManufacturedList; Overload;
    function GetEnumerator : TFhirMedicinalProductManufacturedListEnumerator;
    

    //  Add a FhirMedicinalProductManufactured to the end of the list.
    function Append : TFhirMedicinalProductManufactured;

    
    // Add an already existing FhirMedicinalProductManufactured to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductManufactured); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductManufactured) : Integer;
    

    // Insert FhirMedicinalProductManufactured before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductManufactured;
    

    // Insert an existing FhirMedicinalProductManufactured before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductManufactured);
    
    // Get the iIndexth FhirMedicinalProductManufactured. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductManufactured);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductManufactured;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductManufactureds[index : Integer] : TFhirMedicinalProductManufactured read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICINALPRODUCTMANUFACTURED}

{$IFDEF FHIR_MEDICINALPRODUCTPACKAGED}

  // Batch numbering.
  TFhirMedicinalProductPackagedBatchIdentifier = class (TFhirBackboneElement)
  protected
    FOuterPackaging : TFhirIdentifier;
    FImmediatePackaging : TFhirIdentifier;
    Procedure SetOuterPackaging(value : TFhirIdentifier);
    Procedure SetImmediatePackaging(value : TFhirIdentifier);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductPackagedBatchIdentifier; overload;
    function Clone : TFhirMedicinalProductPackagedBatchIdentifier; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number appearing on the outer packaging of a specific batch. (defined for API consistency)
    property outerPackaging : TFhirIdentifier read FOuterPackaging write SetOuterPackaging;
    // A number appearing on the outer packaging of a specific batch.
    property outerPackagingElement : TFhirIdentifier read FOuterPackaging write SetOuterPackaging;

    // Typed access to A number appearing on the immediate packaging (and not the outer packaging). (defined for API consistency)
    property immediatePackaging : TFhirIdentifier read FImmediatePackaging write SetImmediatePackaging;
    // A number appearing on the immediate packaging (and not the outer packaging).
    property immediatePackagingElement : TFhirIdentifier read FImmediatePackaging write SetImmediatePackaging;

  end;

  TFhirMedicinalProductPackagedBatchIdentifierListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductPackagedBatchIdentifierList;
    function GetCurrent : TFhirMedicinalProductPackagedBatchIdentifier;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductPackagedBatchIdentifierList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductPackagedBatchIdentifier read GetCurrent;
  end;

  TFhirMedicinalProductPackagedBatchIdentifierList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductPackagedBatchIdentifier;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductPackagedBatchIdentifier);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductPackagedBatchIdentifierList; Overload;
    function Clone : TFhirMedicinalProductPackagedBatchIdentifierList; Overload;
    function GetEnumerator : TFhirMedicinalProductPackagedBatchIdentifierListEnumerator;
    

    //  Add a FhirMedicinalProductPackagedBatchIdentifier to the end of the list.
    function Append : TFhirMedicinalProductPackagedBatchIdentifier;

    
    // Add an already existing FhirMedicinalProductPackagedBatchIdentifier to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductPackagedBatchIdentifier); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductPackagedBatchIdentifier) : Integer;
    

    // Insert FhirMedicinalProductPackagedBatchIdentifier before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductPackagedBatchIdentifier;
    

    // Insert an existing FhirMedicinalProductPackagedBatchIdentifier before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductPackagedBatchIdentifier);
    
    // Get the iIndexth FhirMedicinalProductPackagedBatchIdentifier. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductPackagedBatchIdentifier);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductPackagedBatchIdentifier;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductPackagedBatchIdentifiers[index : Integer] : TFhirMedicinalProductPackagedBatchIdentifier read GetItemN write SetItemN; default;
  End;

  // A packaging item, as a contained for medicine, possibly with other packaging items within.
  TFhirMedicinalProductPackagedPackageItem = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FmaterialList : TFhirCodeableConceptList;
    FalternateMaterialList : TFhirCodeableConceptList;
    FdeviceList : TFhirReferenceList{TFhirDeviceDefinition};
    FmanufacturedItemList : TFhirReferenceList{TFhirMedicinalProductManufactured};
    FpackageItemList : TFhirMedicinalProductPackagedPackageItemList;
    FPhysicalCharacteristics : TFhirProdCharacteristic;
    FotherCharacteristicsList : TFhirCodeableConceptList;
    FshelfLifeStorageList : TFhirProductShelfLifeList;
    FmanufacturerList : TFhirReferenceList{TFhirOrganization};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    function GetMaterialList : TFhirCodeableConceptList;
    function GetHasMaterialList : Boolean;
    function GetAlternateMaterialList : TFhirCodeableConceptList;
    function GetHasAlternateMaterialList : Boolean;
    function GetDeviceList : TFhirReferenceList{TFhirDeviceDefinition};
    function GetHasDeviceList : Boolean;
    function GetManufacturedItemList : TFhirReferenceList{TFhirMedicinalProductManufactured};
    function GetHasManufacturedItemList : Boolean;
    function GetPackageItemList : TFhirMedicinalProductPackagedPackageItemList;
    function GetHasPackageItemList : Boolean;
    Procedure SetPhysicalCharacteristics(value : TFhirProdCharacteristic);
    function GetOtherCharacteristicsList : TFhirCodeableConceptList;
    function GetHasOtherCharacteristicsList : Boolean;
    function GetShelfLifeStorageList : TFhirProductShelfLifeList;
    function GetHasShelfLifeStorageList : Boolean;
    function GetManufacturerList : TFhirReferenceList{TFhirOrganization};
    function GetHasManufacturerList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductPackagedPackageItem; overload;
    function Clone : TFhirMedicinalProductPackagedPackageItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Including possibly Data Carrier Identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The physical type of the container of the medicine. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The physical type of the container of the medicine.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The quantity of this package in the medicinal product, at the current level of packaging. The outermost is always 1. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The quantity of this package in the medicinal product, at the current level of packaging. The outermost is always 1.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Material type of the package item.
    property materialList : TFhirCodeableConceptList read GetMaterialList;
    property hasMaterialList : boolean read GetHasMaterialList;

    // A possible alternate material for the packaging.
    property alternateMaterialList : TFhirCodeableConceptList read GetAlternateMaterialList;
    property hasAlternateMaterialList : boolean read GetHasAlternateMaterialList;

    // A device accompanying a medicinal product.
    property deviceList : TFhirReferenceList{TFhirDeviceDefinition} read GetDeviceList;
    property hasDeviceList : boolean read GetHasDeviceList;

    // The manufactured item as contained in the packaged medicinal product.
    property manufacturedItemList : TFhirReferenceList{TFhirMedicinalProductManufactured} read GetManufacturedItemList;
    property hasManufacturedItemList : boolean read GetHasManufacturedItemList;

    // Allows containers within containers.
    property packageItemList : TFhirMedicinalProductPackagedPackageItemList read GetPackageItemList;
    property hasPackageItemList : boolean read GetHasPackageItemList;

    // Typed access to Dimensions, color etc. (defined for API consistency)
    property physicalCharacteristics : TFhirProdCharacteristic read FPhysicalCharacteristics write SetPhysicalCharacteristics;
    // Dimensions, color etc.
    property physicalCharacteristicsElement : TFhirProdCharacteristic read FPhysicalCharacteristics write SetPhysicalCharacteristics;

    // Other codeable characteristics.
    property otherCharacteristicsList : TFhirCodeableConceptList read GetOtherCharacteristicsList;
    property hasOtherCharacteristicsList : boolean read GetHasOtherCharacteristicsList;

    // Shelf Life and storage information.
    property shelfLifeStorageList : TFhirProductShelfLifeList read GetShelfLifeStorageList;
    property hasShelfLifeStorageList : boolean read GetHasShelfLifeStorageList;

    // Manufacturer of this Package Item.
    property manufacturerList : TFhirReferenceList{TFhirOrganization} read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

  end;

  TFhirMedicinalProductPackagedPackageItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductPackagedPackageItemList;
    function GetCurrent : TFhirMedicinalProductPackagedPackageItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductPackagedPackageItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductPackagedPackageItem read GetCurrent;
  end;

  TFhirMedicinalProductPackagedPackageItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductPackagedPackageItem;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductPackagedPackageItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductPackagedPackageItemList; Overload;
    function Clone : TFhirMedicinalProductPackagedPackageItemList; Overload;
    function GetEnumerator : TFhirMedicinalProductPackagedPackageItemListEnumerator;
    

    //  Add a FhirMedicinalProductPackagedPackageItem to the end of the list.
    function Append : TFhirMedicinalProductPackagedPackageItem;

    
    // Add an already existing FhirMedicinalProductPackagedPackageItem to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductPackagedPackageItem); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductPackagedPackageItem) : Integer;
    

    // Insert FhirMedicinalProductPackagedPackageItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductPackagedPackageItem;
    

    // Insert an existing FhirMedicinalProductPackagedPackageItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductPackagedPackageItem);
    
    // Get the iIndexth FhirMedicinalProductPackagedPackageItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductPackagedPackageItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductPackagedPackageItem;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductPackagedPackageItems[index : Integer] : TFhirMedicinalProductPackagedPackageItem read GetItemN write SetItemN; default;
  End;

  // A medicinal product in a container or package.
  TFhirMedicinalProductPackaged = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FsubjectList : TFhirReferenceList{TFhirMedicinalProduct};
    FDescription : TFhirString;
    FLegalStatusOfSupply : TFhirCodeableConcept;
    FmarketingStatusList : TFhirMarketingStatusList;
    FMarketingAuthorization : TFhirReference{TFhirMedicinalProductAuthorization};
    FmanufacturerList : TFhirReferenceList{TFhirOrganization};
    FbatchIdentifierList : TFhirMedicinalProductPackagedBatchIdentifierList;
    FpackageItemList : TFhirMedicinalProductPackagedPackageItemList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetSubjectList : TFhirReferenceList{TFhirMedicinalProduct};
    function GetHasSubjectList : Boolean;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetLegalStatusOfSupply(value : TFhirCodeableConcept);
    function GetMarketingStatusList : TFhirMarketingStatusList;
    function GetHasMarketingStatusList : Boolean;
    Procedure SetMarketingAuthorization(value : TFhirReference{TFhirMedicinalProductAuthorization});
    function GetManufacturerList : TFhirReferenceList{TFhirOrganization};
    function GetHasManufacturerList : Boolean;
    function GetBatchIdentifierList : TFhirMedicinalProductPackagedBatchIdentifierList;
    function GetHasBatchIdentifierList : Boolean;
    function GetPackageItemList : TFhirMedicinalProductPackagedPackageItemList;
    function GetHasPackageItemList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductPackaged; overload;
    function Clone : TFhirMedicinalProductPackaged; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Unique identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The product with this is a pack for.
    property subjectList : TFhirReferenceList{TFhirMedicinalProduct} read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // Typed access to Textual description.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Textual description.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The legal status of supply of the medicinal product as classified by the regulator. (defined for API consistency)
    property legalStatusOfSupply : TFhirCodeableConcept read FLegalStatusOfSupply write SetLegalStatusOfSupply;
    // The legal status of supply of the medicinal product as classified by the regulator.
    property legalStatusOfSupplyElement : TFhirCodeableConcept read FLegalStatusOfSupply write SetLegalStatusOfSupply;

    // Marketing information.
    property marketingStatusList : TFhirMarketingStatusList read GetMarketingStatusList;
    property hasMarketingStatusList : boolean read GetHasMarketingStatusList;

    // Typed access to Manufacturer of this Package Item. (defined for API consistency)
    property marketingAuthorization : TFhirReference{TFhirMedicinalProductAuthorization} read FMarketingAuthorization write SetMarketingAuthorization;
    // Manufacturer of this Package Item.
    property marketingAuthorizationElement : TFhirReference{TFhirMedicinalProductAuthorization} read FMarketingAuthorization write SetMarketingAuthorization;

    // Manufacturer of this Package Item.
    property manufacturerList : TFhirReferenceList{TFhirOrganization} read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // Batch numbering.
    property batchIdentifierList : TFhirMedicinalProductPackagedBatchIdentifierList read GetBatchIdentifierList;
    property hasBatchIdentifierList : boolean read GetHasBatchIdentifierList;

    // A packaging item, as a contained for medicine, possibly with other packaging items within.
    property packageItemList : TFhirMedicinalProductPackagedPackageItemList read GetPackageItemList;
    property hasPackageItemList : boolean read GetHasPackageItemList;

  end;

  TFhirMedicinalProductPackagedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductPackagedList;
    function GetCurrent : TFhirMedicinalProductPackaged;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductPackagedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductPackaged read GetCurrent;
  end;

  TFhirMedicinalProductPackagedList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductPackaged;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductPackaged);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductPackagedList; Overload;
    function Clone : TFhirMedicinalProductPackagedList; Overload;
    function GetEnumerator : TFhirMedicinalProductPackagedListEnumerator;
    

    //  Add a FhirMedicinalProductPackaged to the end of the list.
    function Append : TFhirMedicinalProductPackaged;

    
    // Add an already existing FhirMedicinalProductPackaged to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductPackaged); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductPackaged) : Integer;
    

    // Insert FhirMedicinalProductPackaged before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductPackaged;
    

    // Insert an existing FhirMedicinalProductPackaged before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductPackaged);
    
    // Get the iIndexth FhirMedicinalProductPackaged. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductPackaged);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductPackaged;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductPackageds[index : Integer] : TFhirMedicinalProductPackaged read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICINALPRODUCTPACKAGED}

{$IFDEF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}

  // Characteristics e.g. a products onset of action.
  TFhirMedicinalProductPharmaceuticalCharacteristics = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FStatus : TFhirCodeableConcept;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetStatus(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductPharmaceuticalCharacteristics; overload;
    function Clone : TFhirMedicinalProductPharmaceuticalCharacteristics; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A coded characteristic. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A coded characteristic.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The status of characteristic e.g. assigned or pending. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status of characteristic e.g. assigned or pending.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

  end;

  TFhirMedicinalProductPharmaceuticalCharacteristicsListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductPharmaceuticalCharacteristicsList;
    function GetCurrent : TFhirMedicinalProductPharmaceuticalCharacteristics;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductPharmaceuticalCharacteristicsList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductPharmaceuticalCharacteristics read GetCurrent;
  end;

  TFhirMedicinalProductPharmaceuticalCharacteristicsList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductPharmaceuticalCharacteristics;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductPharmaceuticalCharacteristics);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductPharmaceuticalCharacteristicsList; Overload;
    function Clone : TFhirMedicinalProductPharmaceuticalCharacteristicsList; Overload;
    function GetEnumerator : TFhirMedicinalProductPharmaceuticalCharacteristicsListEnumerator;
    

    //  Add a FhirMedicinalProductPharmaceuticalCharacteristics to the end of the list.
    function Append : TFhirMedicinalProductPharmaceuticalCharacteristics;

    
    // Add an already existing FhirMedicinalProductPharmaceuticalCharacteristics to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductPharmaceuticalCharacteristics); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductPharmaceuticalCharacteristics) : Integer;
    

    // Insert FhirMedicinalProductPharmaceuticalCharacteristics before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductPharmaceuticalCharacteristics;
    

    // Insert an existing FhirMedicinalProductPharmaceuticalCharacteristics before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductPharmaceuticalCharacteristics);
    
    // Get the iIndexth FhirMedicinalProductPharmaceuticalCharacteristics. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductPharmaceuticalCharacteristics);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductPharmaceuticalCharacteristics;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductPharmaceuticalCharacteristics[index : Integer] : TFhirMedicinalProductPharmaceuticalCharacteristics read GetItemN write SetItemN; default;
  End;

  // The path by which the pharmaceutical product is taken into or makes contact with the body.
  TFhirMedicinalProductPharmaceuticalRouteOfAdministration = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FFirstDose : TFhirQuantity;
    FMaxSingleDose : TFhirQuantity;
    FMaxDosePerDay : TFhirQuantity;
    FMaxDosePerTreatmentPeriod : TFhirRatio;
    FMaxTreatmentPeriod : TFhirDuration;
    FtargetSpeciesList : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetFirstDose(value : TFhirQuantity);
    Procedure SetMaxSingleDose(value : TFhirQuantity);
    Procedure SetMaxDosePerDay(value : TFhirQuantity);
    Procedure SetMaxDosePerTreatmentPeriod(value : TFhirRatio);
    Procedure SetMaxTreatmentPeriod(value : TFhirDuration);
    function GetTargetSpeciesList : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList;
    function GetHasTargetSpeciesList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductPharmaceuticalRouteOfAdministration; overload;
    function Clone : TFhirMedicinalProductPharmaceuticalRouteOfAdministration; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Coded expression for the route. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Coded expression for the route.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The first dose (dose quantity) administered in humans can be specified, for a product under investigation, using a numerical value and its unit of measurement. (defined for API consistency)
    property firstDose : TFhirQuantity read FFirstDose write SetFirstDose;
    // The first dose (dose quantity) administered in humans can be specified, for a product under investigation, using a numerical value and its unit of measurement.
    property firstDoseElement : TFhirQuantity read FFirstDose write SetFirstDose;

    // Typed access to The maximum single dose that can be administered as per the protocol of a clinical trial can be specified using a numerical value and its unit of measurement. (defined for API consistency)
    property maxSingleDose : TFhirQuantity read FMaxSingleDose write SetMaxSingleDose;
    // The maximum single dose that can be administered as per the protocol of a clinical trial can be specified using a numerical value and its unit of measurement.
    property maxSingleDoseElement : TFhirQuantity read FMaxSingleDose write SetMaxSingleDose;

    // Typed access to The maximum dose per day (maximum dose quantity to be administered in any one 24-h period) that can be administered as per the protocol referenced in the clinical trial authorisation. (defined for API consistency)
    property maxDosePerDay : TFhirQuantity read FMaxDosePerDay write SetMaxDosePerDay;
    // The maximum dose per day (maximum dose quantity to be administered in any one 24-h period) that can be administered as per the protocol referenced in the clinical trial authorisation.
    property maxDosePerDayElement : TFhirQuantity read FMaxDosePerDay write SetMaxDosePerDay;

    // Typed access to The maximum dose per treatment period that can be administered as per the protocol referenced in the clinical trial authorisation. (defined for API consistency)
    property maxDosePerTreatmentPeriod : TFhirRatio read FMaxDosePerTreatmentPeriod write SetMaxDosePerTreatmentPeriod;
    // The maximum dose per treatment period that can be administered as per the protocol referenced in the clinical trial authorisation.
    property maxDosePerTreatmentPeriodElement : TFhirRatio read FMaxDosePerTreatmentPeriod write SetMaxDosePerTreatmentPeriod;

    // Typed access to The maximum treatment period during which an Investigational Medicinal Product can be administered as per the protocol referenced in the clinical trial authorisation. (defined for API consistency)
    property maxTreatmentPeriod : TFhirDuration read FMaxTreatmentPeriod write SetMaxTreatmentPeriod;
    // The maximum treatment period during which an Investigational Medicinal Product can be administered as per the protocol referenced in the clinical trial authorisation.
    property maxTreatmentPeriodElement : TFhirDuration read FMaxTreatmentPeriod write SetMaxTreatmentPeriod;

    // A species for which this route applies.
    property targetSpeciesList : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList read GetTargetSpeciesList;
    property hasTargetSpeciesList : boolean read GetHasTargetSpeciesList;

  end;

  TFhirMedicinalProductPharmaceuticalRouteOfAdministrationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList;
    function GetCurrent : TFhirMedicinalProductPharmaceuticalRouteOfAdministration;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductPharmaceuticalRouteOfAdministration read GetCurrent;
  end;

  TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductPharmaceuticalRouteOfAdministration;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductPharmaceuticalRouteOfAdministration);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList; Overload;
    function Clone : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList; Overload;
    function GetEnumerator : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationListEnumerator;
    

    //  Add a FhirMedicinalProductPharmaceuticalRouteOfAdministration to the end of the list.
    function Append : TFhirMedicinalProductPharmaceuticalRouteOfAdministration;

    
    // Add an already existing FhirMedicinalProductPharmaceuticalRouteOfAdministration to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductPharmaceuticalRouteOfAdministration); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductPharmaceuticalRouteOfAdministration) : Integer;
    

    // Insert FhirMedicinalProductPharmaceuticalRouteOfAdministration before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductPharmaceuticalRouteOfAdministration;
    

    // Insert an existing FhirMedicinalProductPharmaceuticalRouteOfAdministration before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductPharmaceuticalRouteOfAdministration);
    
    // Get the iIndexth FhirMedicinalProductPharmaceuticalRouteOfAdministration. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductPharmaceuticalRouteOfAdministration);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductPharmaceuticalRouteOfAdministration;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductPharmaceuticalRouteOfAdministrations[index : Integer] : TFhirMedicinalProductPharmaceuticalRouteOfAdministration read GetItemN write SetItemN; default;
  End;

  // A species for which this route applies.
  TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FwithdrawalPeriodList : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
    Procedure SetCode(value : TFhirCodeableConcept);
    function GetWithdrawalPeriodList : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
    function GetHasWithdrawalPeriodList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies; overload;
    function Clone : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Coded expression for the species. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Coded expression for the species.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // A species specific time during which consumption of animal product is not appropriate.
    property withdrawalPeriodList : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList read GetWithdrawalPeriodList;
    property hasWithdrawalPeriodList : boolean read GetHasWithdrawalPeriodList;

  end;

  TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList;
    function GetCurrent : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies read GetCurrent;
  end;

  TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList; Overload;
    function Clone : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList; Overload;
    function GetEnumerator : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesListEnumerator;
    

    //  Add a FhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies to the end of the list.
    function Append : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies;

    
    // Add an already existing FhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies) : Integer;
    

    // Insert FhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies;
    

    // Insert an existing FhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies);
    
    // Get the iIndexth FhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies[index : Integer] : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies read GetItemN write SetItemN; default;
  End;

  // A species specific time during which consumption of animal product is not appropriate.
  TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod = class (TFhirBackboneElement)
  protected
    FTissue : TFhirCodeableConcept;
    FValue : TFhirQuantity;
    FSupportingInformation : TFhirString;
    Procedure SetTissue(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirQuantity);
    Procedure SetSupportingInformation(value : TFhirString);
    Function GetSupportingInformationST : String;
    Procedure SetSupportingInformationST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod; overload;
    function Clone : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Coded expression for the type of tissue for which the withdrawal period applues, e.g. meat, milk. (defined for API consistency)
    property tissue : TFhirCodeableConcept read FTissue write SetTissue;
    // Coded expression for the type of tissue for which the withdrawal period applues, e.g. meat, milk.
    property tissueElement : TFhirCodeableConcept read FTissue write SetTissue;

    // Typed access to A value for the time. (defined for API consistency)
    property value : TFhirQuantity read FValue write SetValue;
    // A value for the time.
    property valueElement : TFhirQuantity read FValue write SetValue;

    // Typed access to Extra information about the withdrawal period.
    property supportingInformation : String read GetSupportingInformationST write SetSupportingInformationST;
    // Extra information about the withdrawal period.
    property supportingInformationElement : TFhirString read FSupportingInformation write SetSupportingInformation;

  end;

  TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
    function GetCurrent : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod read GetCurrent;
  end;

  TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList; Overload;
    function Clone : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList; Overload;
    function GetEnumerator : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator;
    

    //  Add a FhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod to the end of the list.
    function Append : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod;

    
    // Add an already existing FhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod) : Integer;
    

    // Insert FhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
    

    // Insert an existing FhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
    
    // Get the iIndexth FhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriods[index : Integer] : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod read GetItemN write SetItemN; default;
  End;

  // A pharmaceutical product described in terms of its composition and dose form.
  TFhirMedicinalProductPharmaceutical = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FAdministrableDoseForm : TFhirCodeableConcept;
    FUnitOfPresentation : TFhirCodeableConcept;
    FingredientList : TFhirReferenceList{TFhirMedicinalProductIngredient};
    FdeviceList : TFhirReferenceList{TFhirDeviceDefinition};
    FcharacteristicsList : TFhirMedicinalProductPharmaceuticalCharacteristicsList;
    FrouteOfAdministrationList : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetAdministrableDoseForm(value : TFhirCodeableConcept);
    Procedure SetUnitOfPresentation(value : TFhirCodeableConcept);
    function GetIngredientList : TFhirReferenceList{TFhirMedicinalProductIngredient};
    function GetHasIngredientList : Boolean;
    function GetDeviceList : TFhirReferenceList{TFhirDeviceDefinition};
    function GetHasDeviceList : Boolean;
    function GetCharacteristicsList : TFhirMedicinalProductPharmaceuticalCharacteristicsList;
    function GetHasCharacteristicsList : Boolean;
    function GetRouteOfAdministrationList : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList;
    function GetHasRouteOfAdministrationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductPharmaceutical; overload;
    function Clone : TFhirMedicinalProductPharmaceutical; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // An identifier for the pharmaceutical medicinal product.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The administrable dose form, after necessary reconstitution. (defined for API consistency)
    property administrableDoseForm : TFhirCodeableConcept read FAdministrableDoseForm write SetAdministrableDoseForm;
    // The administrable dose form, after necessary reconstitution.
    property administrableDoseFormElement : TFhirCodeableConcept read FAdministrableDoseForm write SetAdministrableDoseForm;

    // Typed access to Todo. (defined for API consistency)
    property unitOfPresentation : TFhirCodeableConcept read FUnitOfPresentation write SetUnitOfPresentation;
    // Todo.
    property unitOfPresentationElement : TFhirCodeableConcept read FUnitOfPresentation write SetUnitOfPresentation;

    // Ingredient.
    property ingredientList : TFhirReferenceList{TFhirMedicinalProductIngredient} read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // Accompanying device.
    property deviceList : TFhirReferenceList{TFhirDeviceDefinition} read GetDeviceList;
    property hasDeviceList : boolean read GetHasDeviceList;

    // Characteristics e.g. a products onset of action.
    property characteristicsList : TFhirMedicinalProductPharmaceuticalCharacteristicsList read GetCharacteristicsList;
    property hasCharacteristicsList : boolean read GetHasCharacteristicsList;

    // The path by which the pharmaceutical product is taken into or makes contact with the body.
    property routeOfAdministrationList : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList read GetRouteOfAdministrationList;
    property hasRouteOfAdministrationList : boolean read GetHasRouteOfAdministrationList;

  end;

  TFhirMedicinalProductPharmaceuticalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductPharmaceuticalList;
    function GetCurrent : TFhirMedicinalProductPharmaceutical;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductPharmaceuticalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductPharmaceutical read GetCurrent;
  end;

  TFhirMedicinalProductPharmaceuticalList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductPharmaceutical;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductPharmaceutical);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductPharmaceuticalList; Overload;
    function Clone : TFhirMedicinalProductPharmaceuticalList; Overload;
    function GetEnumerator : TFhirMedicinalProductPharmaceuticalListEnumerator;
    

    //  Add a FhirMedicinalProductPharmaceutical to the end of the list.
    function Append : TFhirMedicinalProductPharmaceutical;

    
    // Add an already existing FhirMedicinalProductPharmaceutical to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductPharmaceutical); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductPharmaceutical) : Integer;
    

    // Insert FhirMedicinalProductPharmaceutical before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductPharmaceutical;
    

    // Insert an existing FhirMedicinalProductPharmaceutical before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductPharmaceutical);
    
    // Get the iIndexth FhirMedicinalProductPharmaceutical. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductPharmaceutical);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductPharmaceutical;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductPharmaceuticals[index : Integer] : TFhirMedicinalProductPharmaceutical read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}

{$IFDEF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}

  // Describe the undesirable effects of the medicinal product.
  TFhirMedicinalProductUndesirableEffect = class (TFhirDomainResource)
  protected
    FsubjectList : TFhirReferenceList{TFhirMedicinalProduct};
    FSymptomConditionEffect : TFhirCodeableConcept;
    FClassification : TFhirCodeableConcept;
    FFrequencyOfOccurrence : TFhirCodeableConcept;
    FpopulationList : TFhirPopulationList;
    function GetSubjectList : TFhirReferenceList{TFhirMedicinalProduct};
    function GetHasSubjectList : Boolean;
    Procedure SetSymptomConditionEffect(value : TFhirCodeableConcept);
    Procedure SetClassification(value : TFhirCodeableConcept);
    Procedure SetFrequencyOfOccurrence(value : TFhirCodeableConcept);
    function GetPopulationList : TFhirPopulationList;
    function GetHasPopulationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductUndesirableEffect; overload;
    function Clone : TFhirMedicinalProductUndesirableEffect; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The medication for which this is an indication.
    property subjectList : TFhirReferenceList{TFhirMedicinalProduct} read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // Typed access to The symptom, condition or undesirable effect. (defined for API consistency)
    property symptomConditionEffect : TFhirCodeableConcept read FSymptomConditionEffect write SetSymptomConditionEffect;
    // The symptom, condition or undesirable effect.
    property symptomConditionEffectElement : TFhirCodeableConcept read FSymptomConditionEffect write SetSymptomConditionEffect;

    // Typed access to Classification of the effect. (defined for API consistency)
    property classification : TFhirCodeableConcept read FClassification write SetClassification;
    // Classification of the effect.
    property classificationElement : TFhirCodeableConcept read FClassification write SetClassification;

    // Typed access to The frequency of occurrence of the effect. (defined for API consistency)
    property frequencyOfOccurrence : TFhirCodeableConcept read FFrequencyOfOccurrence write SetFrequencyOfOccurrence;
    // The frequency of occurrence of the effect.
    property frequencyOfOccurrenceElement : TFhirCodeableConcept read FFrequencyOfOccurrence write SetFrequencyOfOccurrence;

    // The population group to which this applies.
    property populationList : TFhirPopulationList read GetPopulationList;
    property hasPopulationList : boolean read GetHasPopulationList;

  end;

  TFhirMedicinalProductUndesirableEffectListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductUndesirableEffectList;
    function GetCurrent : TFhirMedicinalProductUndesirableEffect;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductUndesirableEffectList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductUndesirableEffect read GetCurrent;
  end;

  TFhirMedicinalProductUndesirableEffectList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicinalProductUndesirableEffect;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductUndesirableEffect);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicinalProductUndesirableEffectList; Overload;
    function Clone : TFhirMedicinalProductUndesirableEffectList; Overload;
    function GetEnumerator : TFhirMedicinalProductUndesirableEffectListEnumerator;
    

    //  Add a FhirMedicinalProductUndesirableEffect to the end of the list.
    function Append : TFhirMedicinalProductUndesirableEffect;

    
    // Add an already existing FhirMedicinalProductUndesirableEffect to the end of the list.
    procedure AddItem(value : TFhirMedicinalProductUndesirableEffect); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductUndesirableEffect) : Integer;
    

    // Insert FhirMedicinalProductUndesirableEffect before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductUndesirableEffect;
    

    // Insert an existing FhirMedicinalProductUndesirableEffect before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductUndesirableEffect);
    
    // Get the iIndexth FhirMedicinalProductUndesirableEffect. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductUndesirableEffect);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductUndesirableEffect;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMedicinalProductUndesirableEffects[index : Integer] : TFhirMedicinalProductUndesirableEffect read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}

{$IFDEF FHIR_SUBSTANCE}

  // Substance may be used to describe a kind of substance, or a specific package/container of the substance: an instance.
  TFhirSubstanceInstance = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FExpiry : TFhirDateTime;
    FQuantity : TFhirQuantity;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetExpiry(value : TFhirDateTime);
    Function GetExpiryST : TFslDateTime;
    Procedure SetExpiryST(value : TFslDateTime);
    Procedure SetQuantity(value : TFhirQuantity);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceInstance; overload;
    function Clone : TFhirSubstanceInstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Identifier associated with the package/container (usually a label affixed directly). (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier associated with the package/container (usually a label affixed directly).
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to When the substance is no longer valid to use. For some substances, a single arbitrary date is used for expiry.
    property expiry : TFslDateTime read GetExpiryST write SetExpiryST;
    // When the substance is no longer valid to use. For some substances, a single arbitrary date is used for expiry.
    property expiryElement : TFhirDateTime read FExpiry write SetExpiry;

    // Typed access to The amount of the substance. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount of the substance.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

  end;

  TFhirSubstanceInstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceInstanceList;
    function GetCurrent : TFhirSubstanceInstance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceInstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceInstance read GetCurrent;
  end;

  TFhirSubstanceInstanceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceInstance;
    procedure SetItemN(index : Integer; value : TFhirSubstanceInstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceInstanceList; Overload;
    function Clone : TFhirSubstanceInstanceList; Overload;
    function GetEnumerator : TFhirSubstanceInstanceListEnumerator;
    

    //  Add a FhirSubstanceInstance to the end of the list.
    function Append : TFhirSubstanceInstance;

    
    // Add an already existing FhirSubstanceInstance to the end of the list.
    procedure AddItem(value : TFhirSubstanceInstance); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceInstance) : Integer;
    

    // Insert FhirSubstanceInstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceInstance;
    

    // Insert an existing FhirSubstanceInstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceInstance);
    
    // Get the iIndexth FhirSubstanceInstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceInstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceInstance;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceInstances[index : Integer] : TFhirSubstanceInstance read GetItemN write SetItemN; default;
  End;

  // A substance can be composed of other substances.
  TFhirSubstanceIngredient = class (TFhirBackboneElement)
  protected
    FQuantity : TFhirRatio;
    FSubstance : TFhirType;
    Procedure SetQuantity(value : TFhirRatio);
    Procedure SetSubstance(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceIngredient; overload;
    function Clone : TFhirSubstanceIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The amount of the ingredient in the substance - a concentration ratio. (defined for API consistency)
    property quantity : TFhirRatio read FQuantity write SetQuantity;
    // The amount of the ingredient in the substance - a concentration ratio.
    property quantityElement : TFhirRatio read FQuantity write SetQuantity;

    // Typed access to Another substance that is a component of this substance. (defined for API consistency)
    property substance : TFhirType read FSubstance write SetSubstance;
    // Another substance that is a component of this substance.
    property substanceElement : TFhirType read FSubstance write SetSubstance;

  end;

  TFhirSubstanceIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceIngredientList;
    function GetCurrent : TFhirSubstanceIngredient;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceIngredient read GetCurrent;
  end;

  TFhirSubstanceIngredientList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceIngredient;
    procedure SetItemN(index : Integer; value : TFhirSubstanceIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceIngredientList; Overload;
    function Clone : TFhirSubstanceIngredientList; Overload;
    function GetEnumerator : TFhirSubstanceIngredientListEnumerator;
    

    //  Add a FhirSubstanceIngredient to the end of the list.
    function Append : TFhirSubstanceIngredient;

    
    // Add an already existing FhirSubstanceIngredient to the end of the list.
    procedure AddItem(value : TFhirSubstanceIngredient); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceIngredient) : Integer;
    

    // Insert FhirSubstanceIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceIngredient;
    

    // Insert an existing FhirSubstanceIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceIngredient);
    
    // Get the iIndexth FhirSubstanceIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceIngredient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceIngredient;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceIngredients[index : Integer] : TFhirSubstanceIngredient read GetItemN write SetItemN; default;
  End;

  // A homogeneous material with a definite composition.
  TFhirSubstance = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FCode : TFhirCodeableConcept;
    FDescription : TFhirString;
    FinstanceList : TFhirSubstanceInstanceList;
    FingredientList : TFhirSubstanceIngredientList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirSubstanceStatusEnum;
    Procedure SetStatusST(value : TFhirSubstanceStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetInstanceList : TFhirSubstanceInstanceList;
    function GetHasInstanceList : Boolean;
    function GetIngredientList : TFhirSubstanceIngredientList;
    function GetHasIngredientList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstance; overload;
    function Clone : TFhirSubstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Unique identifier for the substance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A code to indicate if the substance is actively used.
    property status : TFhirSubstanceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // A code that classifies the general type of substance.  This is used  for searching, sorting and display purposes.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to A code (or set of codes) that identify this substance. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code (or set of codes) that identify this substance.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to A description of the substance - its appearance, handling requirements, and other usage notes.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of the substance - its appearance, handling requirements, and other usage notes.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Substance may be used to describe a kind of substance, or a specific package/container of the substance: an instance.
    property instanceList : TFhirSubstanceInstanceList read GetInstanceList;
    property hasInstanceList : boolean read GetHasInstanceList;

    // A substance can be composed of other substances.
    property ingredientList : TFhirSubstanceIngredientList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

  end;

  TFhirSubstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceList;
    function GetCurrent : TFhirSubstance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstance read GetCurrent;
  end;

  TFhirSubstanceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstance;
    procedure SetItemN(index : Integer; value : TFhirSubstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceList; Overload;
    function Clone : TFhirSubstanceList; Overload;
    function GetEnumerator : TFhirSubstanceListEnumerator;
    

    //  Add a FhirSubstance to the end of the list.
    function Append : TFhirSubstance;

    
    // Add an already existing FhirSubstance to the end of the list.
    procedure AddItem(value : TFhirSubstance); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstance) : Integer;
    

    // Insert FhirSubstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstance;
    

    // Insert an existing FhirSubstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstance);
    
    // Get the iIndexth FhirSubstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstance;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstances[index : Integer] : TFhirSubstance read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCE}

{$IFDEF FHIR_SUBSTANCENUCLEICACID}

  // Subunits are listed in order of decreasing length; sequences of the same length will be ordered by molecular weight; subunits that have identical sequences will be repeated multiple times.
  TFhirSubstanceNucleicAcidSubunit = class (TFhirBackboneElement)
  protected
    FSubunit : TFhirInteger;
    FSequence : TFhirString;
    FLength : TFhirInteger;
    FSequenceAttachment : TFhirAttachment;
    FFivePrime : TFhirCodeableConcept;
    FThreePrime : TFhirCodeableConcept;
    FlinkageList : TFhirSubstanceNucleicAcidSubunitLinkageList;
    FsugarList : TFhirSubstanceNucleicAcidSubunitSugarList;
    Procedure SetSubunit(value : TFhirInteger);
    Function GetSubunitST : String;
    Procedure SetSubunitST(value : String);
    Procedure SetSequence(value : TFhirString);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetLength(value : TFhirInteger);
    Function GetLengthST : String;
    Procedure SetLengthST(value : String);
    Procedure SetSequenceAttachment(value : TFhirAttachment);
    Procedure SetFivePrime(value : TFhirCodeableConcept);
    Procedure SetThreePrime(value : TFhirCodeableConcept);
    function GetLinkageList : TFhirSubstanceNucleicAcidSubunitLinkageList;
    function GetHasLinkageList : Boolean;
    function GetSugarList : TFhirSubstanceNucleicAcidSubunitSugarList;
    function GetHasSugarList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceNucleicAcidSubunit; overload;
    function Clone : TFhirSubstanceNucleicAcidSubunit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Index of linear sequences of nucleic acids in order of decreasing length. Sequences of the same length will be ordered by molecular weight. Subunits that have identical sequences will be repeated and have sequential subscripts.
    property subunit : String read GetSubunitST write SetSubunitST;
    // Index of linear sequences of nucleic acids in order of decreasing length. Sequences of the same length will be ordered by molecular weight. Subunits that have identical sequences will be repeated and have sequential subscripts.
    property subunitElement : TFhirInteger read FSubunit write SetSubunit;

    // Typed access to Actual nucleotide sequence notation from 5' to 3' end using standard single letter codes. In addition to the base sequence, sugar and type of phosphate or non-phosphate linkage should also be captured.
    property sequence : String read GetSequenceST write SetSequenceST;
    // Actual nucleotide sequence notation from 5' to 3' end using standard single letter codes. In addition to the base sequence, sugar and type of phosphate or non-phosphate linkage should also be captured.
    property sequenceElement : TFhirString read FSequence write SetSequence;

    // Typed access to The length of the sequence shall be captured.
    property length : String read GetLengthST write SetLengthST;
    // The length of the sequence shall be captured.
    property lengthElement : TFhirInteger read FLength write SetLength;

    // Typed access to (TBC). (defined for API consistency)
    property sequenceAttachment : TFhirAttachment read FSequenceAttachment write SetSequenceAttachment;
    // (TBC).
    property sequenceAttachmentElement : TFhirAttachment read FSequenceAttachment write SetSequenceAttachment;

    // Typed access to The nucleotide present at the 5? terminal shall be specified based on a controlled vocabulary. Since the sequence is represented from the 5' to the 3' end, the 5? prime nucleotide is the letter at the first position in the sequence. A separate representation would be redundant. (defined for API consistency)
    property fivePrime : TFhirCodeableConcept read FFivePrime write SetFivePrime;
    // The nucleotide present at the 5? terminal shall be specified based on a controlled vocabulary. Since the sequence is represented from the 5' to the 3' end, the 5? prime nucleotide is the letter at the first position in the sequence. A separate representation would be redundant.
    property fivePrimeElement : TFhirCodeableConcept read FFivePrime write SetFivePrime;

    // Typed access to The nucleotide present at the 3? terminal shall be specified based on a controlled vocabulary. Since the sequence is represented from the 5' to the 3' end, the 5? prime nucleotide is the letter at the last position in the sequence. A separate representation would be redundant. (defined for API consistency)
    property threePrime : TFhirCodeableConcept read FThreePrime write SetThreePrime;
    // The nucleotide present at the 3? terminal shall be specified based on a controlled vocabulary. Since the sequence is represented from the 5' to the 3' end, the 5? prime nucleotide is the letter at the last position in the sequence. A separate representation would be redundant.
    property threePrimeElement : TFhirCodeableConcept read FThreePrime write SetThreePrime;

    // The linkages between sugar residues will also be captured.
    property linkageList : TFhirSubstanceNucleicAcidSubunitLinkageList read GetLinkageList;
    property hasLinkageList : boolean read GetHasLinkageList;

    // 5.3.6.8.1 Sugar ID (Mandatory).
    property sugarList : TFhirSubstanceNucleicAcidSubunitSugarList read GetSugarList;
    property hasSugarList : boolean read GetHasSugarList;

  end;

  TFhirSubstanceNucleicAcidSubunitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceNucleicAcidSubunitList;
    function GetCurrent : TFhirSubstanceNucleicAcidSubunit;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceNucleicAcidSubunitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceNucleicAcidSubunit read GetCurrent;
  end;

  TFhirSubstanceNucleicAcidSubunitList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceNucleicAcidSubunit;
    procedure SetItemN(index : Integer; value : TFhirSubstanceNucleicAcidSubunit);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceNucleicAcidSubunitList; Overload;
    function Clone : TFhirSubstanceNucleicAcidSubunitList; Overload;
    function GetEnumerator : TFhirSubstanceNucleicAcidSubunitListEnumerator;
    

    //  Add a FhirSubstanceNucleicAcidSubunit to the end of the list.
    function Append : TFhirSubstanceNucleicAcidSubunit;

    
    // Add an already existing FhirSubstanceNucleicAcidSubunit to the end of the list.
    procedure AddItem(value : TFhirSubstanceNucleicAcidSubunit); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceNucleicAcidSubunit) : Integer;
    

    // Insert FhirSubstanceNucleicAcidSubunit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceNucleicAcidSubunit;
    

    // Insert an existing FhirSubstanceNucleicAcidSubunit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceNucleicAcidSubunit);
    
    // Get the iIndexth FhirSubstanceNucleicAcidSubunit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceNucleicAcidSubunit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceNucleicAcidSubunit;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceNucleicAcidSubunits[index : Integer] : TFhirSubstanceNucleicAcidSubunit read GetItemN write SetItemN; default;
  End;

  // The linkages between sugar residues will also be captured.
  TFhirSubstanceNucleicAcidSubunitLinkage = class (TFhirBackboneElement)
  protected
    FConnectivity : TFhirString;
    FIdentifier : TFhirIdentifier;
    FName : TFhirString;
    FResidueSite : TFhirString;
    Procedure SetConnectivity(value : TFhirString);
    Function GetConnectivityST : String;
    Procedure SetConnectivityST(value : String);
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetResidueSite(value : TFhirString);
    Function GetResidueSiteST : String;
    Procedure SetResidueSiteST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceNucleicAcidSubunitLinkage; overload;
    function Clone : TFhirSubstanceNucleicAcidSubunitLinkage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The entity that links the sugar residues together should also be captured for nearly all naturally occurring nucleic acid the linkage is a phosphate group. For many synthetic oligonucleotides phosphorothioate linkages are often seen. Linkage connectivity is assumed to be 3?-5?. If the linkage is either 3?-3? or 5?-5? this should be specified.
    property connectivity : String read GetConnectivityST write SetConnectivityST;
    // The entity that links the sugar residues together should also be captured for nearly all naturally occurring nucleic acid the linkage is a phosphate group. For many synthetic oligonucleotides phosphorothioate linkages are often seen. Linkage connectivity is assumed to be 3?-5?. If the linkage is either 3?-3? or 5?-5? this should be specified.
    property connectivityElement : TFhirString read FConnectivity write SetConnectivity;

    // Typed access to Each linkage will be registered as a fragment and have an ID. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Each linkage will be registered as a fragment and have an ID.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Each linkage will be registered as a fragment and have at least one name. A single name shall be assigned to each linkage.
    property name : String read GetNameST write SetNameST;
    // Each linkage will be registered as a fragment and have at least one name. A single name shall be assigned to each linkage.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Residues shall be captured as described in 5.3.6.8.3.
    property residueSite : String read GetResidueSiteST write SetResidueSiteST;
    // Residues shall be captured as described in 5.3.6.8.3.
    property residueSiteElement : TFhirString read FResidueSite write SetResidueSite;

  end;

  TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceNucleicAcidSubunitLinkageList;
    function GetCurrent : TFhirSubstanceNucleicAcidSubunitLinkage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceNucleicAcidSubunitLinkageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceNucleicAcidSubunitLinkage read GetCurrent;
  end;

  TFhirSubstanceNucleicAcidSubunitLinkageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceNucleicAcidSubunitLinkage;
    procedure SetItemN(index : Integer; value : TFhirSubstanceNucleicAcidSubunitLinkage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceNucleicAcidSubunitLinkageList; Overload;
    function Clone : TFhirSubstanceNucleicAcidSubunitLinkageList; Overload;
    function GetEnumerator : TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator;
    

    //  Add a FhirSubstanceNucleicAcidSubunitLinkage to the end of the list.
    function Append : TFhirSubstanceNucleicAcidSubunitLinkage;

    
    // Add an already existing FhirSubstanceNucleicAcidSubunitLinkage to the end of the list.
    procedure AddItem(value : TFhirSubstanceNucleicAcidSubunitLinkage); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceNucleicAcidSubunitLinkage) : Integer;
    

    // Insert FhirSubstanceNucleicAcidSubunitLinkage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceNucleicAcidSubunitLinkage;
    

    // Insert an existing FhirSubstanceNucleicAcidSubunitLinkage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceNucleicAcidSubunitLinkage);
    
    // Get the iIndexth FhirSubstanceNucleicAcidSubunitLinkage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceNucleicAcidSubunitLinkage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceNucleicAcidSubunitLinkage;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceNucleicAcidSubunitLinkages[index : Integer] : TFhirSubstanceNucleicAcidSubunitLinkage read GetItemN write SetItemN; default;
  End;

  // 5.3.6.8.1 Sugar ID (Mandatory).
  TFhirSubstanceNucleicAcidSubunitSugar = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FName : TFhirString;
    FResidueSite : TFhirString;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetResidueSite(value : TFhirString);
    Function GetResidueSiteST : String;
    Procedure SetResidueSiteST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceNucleicAcidSubunitSugar; overload;
    function Clone : TFhirSubstanceNucleicAcidSubunitSugar; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The Substance ID of the sugar or sugar-like component that make up the nucleotide. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // The Substance ID of the sugar or sugar-like component that make up the nucleotide.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The name of the sugar or sugar-like component that make up the nucleotide.
    property name : String read GetNameST write SetNameST;
    // The name of the sugar or sugar-like component that make up the nucleotide.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The residues that contain a given sugar will be captured. The order of given residues will be captured in the 5?-3?direction consistent with the base sequences listed above.
    property residueSite : String read GetResidueSiteST write SetResidueSiteST;
    // The residues that contain a given sugar will be captured. The order of given residues will be captured in the 5?-3?direction consistent with the base sequences listed above.
    property residueSiteElement : TFhirString read FResidueSite write SetResidueSite;

  end;

  TFhirSubstanceNucleicAcidSubunitSugarListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceNucleicAcidSubunitSugarList;
    function GetCurrent : TFhirSubstanceNucleicAcidSubunitSugar;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceNucleicAcidSubunitSugarList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceNucleicAcidSubunitSugar read GetCurrent;
  end;

  TFhirSubstanceNucleicAcidSubunitSugarList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceNucleicAcidSubunitSugar;
    procedure SetItemN(index : Integer; value : TFhirSubstanceNucleicAcidSubunitSugar);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceNucleicAcidSubunitSugarList; Overload;
    function Clone : TFhirSubstanceNucleicAcidSubunitSugarList; Overload;
    function GetEnumerator : TFhirSubstanceNucleicAcidSubunitSugarListEnumerator;
    

    //  Add a FhirSubstanceNucleicAcidSubunitSugar to the end of the list.
    function Append : TFhirSubstanceNucleicAcidSubunitSugar;

    
    // Add an already existing FhirSubstanceNucleicAcidSubunitSugar to the end of the list.
    procedure AddItem(value : TFhirSubstanceNucleicAcidSubunitSugar); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceNucleicAcidSubunitSugar) : Integer;
    

    // Insert FhirSubstanceNucleicAcidSubunitSugar before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceNucleicAcidSubunitSugar;
    

    // Insert an existing FhirSubstanceNucleicAcidSubunitSugar before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceNucleicAcidSubunitSugar);
    
    // Get the iIndexth FhirSubstanceNucleicAcidSubunitSugar. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceNucleicAcidSubunitSugar);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceNucleicAcidSubunitSugar;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceNucleicAcidSubunitSugars[index : Integer] : TFhirSubstanceNucleicAcidSubunitSugar read GetItemN write SetItemN; default;
  End;

  // Nucleic acids are defined by three distinct elements: the base, sugar and linkage. Individual substance/moiety IDs will be created for each of these elements. The nucleotide sequence will be always entered in the 5?-3? direction.
  TFhirSubstanceNucleicAcid = class (TFhirDomainResource)
  protected
    FSequenceType : TFhirCodeableConcept;
    FNumberOfSubunits : TFhirInteger;
    FAreaOfHybridisation : TFhirString;
    FOligoNucleotideType : TFhirCodeableConcept;
    FsubunitList : TFhirSubstanceNucleicAcidSubunitList;
    Procedure SetSequenceType(value : TFhirCodeableConcept);
    Procedure SetNumberOfSubunits(value : TFhirInteger);
    Function GetNumberOfSubunitsST : String;
    Procedure SetNumberOfSubunitsST(value : String);
    Procedure SetAreaOfHybridisation(value : TFhirString);
    Function GetAreaOfHybridisationST : String;
    Procedure SetAreaOfHybridisationST(value : String);
    Procedure SetOligoNucleotideType(value : TFhirCodeableConcept);
    function GetSubunitList : TFhirSubstanceNucleicAcidSubunitList;
    function GetHasSubunitList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceNucleicAcid; overload;
    function Clone : TFhirSubstanceNucleicAcid; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The type of the sequence shall be specified based on a controlled vocabulary. (defined for API consistency)
    property sequenceType : TFhirCodeableConcept read FSequenceType write SetSequenceType;
    // The type of the sequence shall be specified based on a controlled vocabulary.
    property sequenceTypeElement : TFhirCodeableConcept read FSequenceType write SetSequenceType;

    // Typed access to The number of linear sequences of nucleotides linked through phosphodiester bonds shall be described. Subunits would be strands of nucleic acids that are tightly associated typically through Watson-Crick base pairing. NOTE: If not specified in the reference source, the assumption is that there is 1 subunit.
    property numberOfSubunits : String read GetNumberOfSubunitsST write SetNumberOfSubunitsST;
    // The number of linear sequences of nucleotides linked through phosphodiester bonds shall be described. Subunits would be strands of nucleic acids that are tightly associated typically through Watson-Crick base pairing. NOTE: If not specified in the reference source, the assumption is that there is 1 subunit.
    property numberOfSubunitsElement : TFhirInteger read FNumberOfSubunits write SetNumberOfSubunits;

    // Typed access to The area of hybridisation shall be described if applicable for double stranded RNA or DNA. The number associated with the subunit followed by the number associated to the residue shall be specified in increasing order. The underscore ?? shall be used as separator as follows: ?Subunitnumber Residue?.
    property areaOfHybridisation : String read GetAreaOfHybridisationST write SetAreaOfHybridisationST;
    // The area of hybridisation shall be described if applicable for double stranded RNA or DNA. The number associated with the subunit followed by the number associated to the residue shall be specified in increasing order. The underscore ?? shall be used as separator as follows: ?Subunitnumber Residue?.
    property areaOfHybridisationElement : TFhirString read FAreaOfHybridisation write SetAreaOfHybridisation;

    // Typed access to (TBC). (defined for API consistency)
    property oligoNucleotideType : TFhirCodeableConcept read FOligoNucleotideType write SetOligoNucleotideType;
    // (TBC).
    property oligoNucleotideTypeElement : TFhirCodeableConcept read FOligoNucleotideType write SetOligoNucleotideType;

    // Subunits are listed in order of decreasing length; sequences of the same length will be ordered by molecular weight; subunits that have identical sequences will be repeated multiple times.
    property subunitList : TFhirSubstanceNucleicAcidSubunitList read GetSubunitList;
    property hasSubunitList : boolean read GetHasSubunitList;

  end;

  TFhirSubstanceNucleicAcidListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceNucleicAcidList;
    function GetCurrent : TFhirSubstanceNucleicAcid;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceNucleicAcidList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceNucleicAcid read GetCurrent;
  end;

  TFhirSubstanceNucleicAcidList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceNucleicAcid;
    procedure SetItemN(index : Integer; value : TFhirSubstanceNucleicAcid);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceNucleicAcidList; Overload;
    function Clone : TFhirSubstanceNucleicAcidList; Overload;
    function GetEnumerator : TFhirSubstanceNucleicAcidListEnumerator;
    

    //  Add a FhirSubstanceNucleicAcid to the end of the list.
    function Append : TFhirSubstanceNucleicAcid;

    
    // Add an already existing FhirSubstanceNucleicAcid to the end of the list.
    procedure AddItem(value : TFhirSubstanceNucleicAcid); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceNucleicAcid) : Integer;
    

    // Insert FhirSubstanceNucleicAcid before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceNucleicAcid;
    

    // Insert an existing FhirSubstanceNucleicAcid before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceNucleicAcid);
    
    // Get the iIndexth FhirSubstanceNucleicAcid. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceNucleicAcid);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceNucleicAcid;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceNucleicAcids[index : Integer] : TFhirSubstanceNucleicAcid read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCENUCLEICACID}

{$IFDEF FHIR_SUBSTANCEPOLYMER}

  // Todo.
  TFhirSubstancePolymerMonomerSet = class (TFhirBackboneElement)
  protected
    FRatioType : TFhirCodeableConcept;
    FstartingMaterialList : TFhirSubstancePolymerMonomerSetStartingMaterialList;
    Procedure SetRatioType(value : TFhirCodeableConcept);
    function GetStartingMaterialList : TFhirSubstancePolymerMonomerSetStartingMaterialList;
    function GetHasStartingMaterialList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymerMonomerSet; overload;
    function Clone : TFhirSubstancePolymerMonomerSet; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Todo. (defined for API consistency)
    property ratioType : TFhirCodeableConcept read FRatioType write SetRatioType;
    // Todo.
    property ratioTypeElement : TFhirCodeableConcept read FRatioType write SetRatioType;

    // Todo.
    property startingMaterialList : TFhirSubstancePolymerMonomerSetStartingMaterialList read GetStartingMaterialList;
    property hasStartingMaterialList : boolean read GetHasStartingMaterialList;

  end;

  TFhirSubstancePolymerMonomerSetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerMonomerSetList;
    function GetCurrent : TFhirSubstancePolymerMonomerSet;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerMonomerSetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymerMonomerSet read GetCurrent;
  end;

  TFhirSubstancePolymerMonomerSetList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstancePolymerMonomerSet;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymerMonomerSet);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstancePolymerMonomerSetList; Overload;
    function Clone : TFhirSubstancePolymerMonomerSetList; Overload;
    function GetEnumerator : TFhirSubstancePolymerMonomerSetListEnumerator;
    

    //  Add a FhirSubstancePolymerMonomerSet to the end of the list.
    function Append : TFhirSubstancePolymerMonomerSet;

    
    // Add an already existing FhirSubstancePolymerMonomerSet to the end of the list.
    procedure AddItem(value : TFhirSubstancePolymerMonomerSet); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymerMonomerSet) : Integer;
    

    // Insert FhirSubstancePolymerMonomerSet before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymerMonomerSet;
    

    // Insert an existing FhirSubstancePolymerMonomerSet before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymerMonomerSet);
    
    // Get the iIndexth FhirSubstancePolymerMonomerSet. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymerMonomerSet);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymerMonomerSet;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstancePolymerMonomerSets[index : Integer] : TFhirSubstancePolymerMonomerSet read GetItemN write SetItemN; default;
  End;

  // Todo.
  TFhirSubstancePolymerMonomerSetStartingMaterial = class (TFhirBackboneElement)
  protected
    FMaterial : TFhirCodeableConcept;
    FType_ : TFhirCodeableConcept;
    FIsDefining : TFhirBoolean;
    FAmount : TFhirSubstanceAmount;
    Procedure SetMaterial(value : TFhirCodeableConcept);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetIsDefining(value : TFhirBoolean);
    Function GetIsDefiningST : Boolean;
    Procedure SetIsDefiningST(value : Boolean);
    Procedure SetAmount(value : TFhirSubstanceAmount);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymerMonomerSetStartingMaterial; overload;
    function Clone : TFhirSubstancePolymerMonomerSetStartingMaterial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Todo. (defined for API consistency)
    property material : TFhirCodeableConcept read FMaterial write SetMaterial;
    // Todo.
    property materialElement : TFhirCodeableConcept read FMaterial write SetMaterial;

    // Typed access to Todo. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Todo.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Todo.
    property isDefining : Boolean read GetIsDefiningST write SetIsDefiningST;
    // Todo.
    property isDefiningElement : TFhirBoolean read FIsDefining write SetIsDefining;

    // Typed access to Todo. (defined for API consistency)
    property amount : TFhirSubstanceAmount read FAmount write SetAmount;
    // Todo.
    property amountElement : TFhirSubstanceAmount read FAmount write SetAmount;

  end;

  TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerMonomerSetStartingMaterialList;
    function GetCurrent : TFhirSubstancePolymerMonomerSetStartingMaterial;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerMonomerSetStartingMaterialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymerMonomerSetStartingMaterial read GetCurrent;
  end;

  TFhirSubstancePolymerMonomerSetStartingMaterialList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstancePolymerMonomerSetStartingMaterial;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymerMonomerSetStartingMaterial);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstancePolymerMonomerSetStartingMaterialList; Overload;
    function Clone : TFhirSubstancePolymerMonomerSetStartingMaterialList; Overload;
    function GetEnumerator : TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator;
    

    //  Add a FhirSubstancePolymerMonomerSetStartingMaterial to the end of the list.
    function Append : TFhirSubstancePolymerMonomerSetStartingMaterial;

    
    // Add an already existing FhirSubstancePolymerMonomerSetStartingMaterial to the end of the list.
    procedure AddItem(value : TFhirSubstancePolymerMonomerSetStartingMaterial); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymerMonomerSetStartingMaterial) : Integer;
    

    // Insert FhirSubstancePolymerMonomerSetStartingMaterial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymerMonomerSetStartingMaterial;
    

    // Insert an existing FhirSubstancePolymerMonomerSetStartingMaterial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymerMonomerSetStartingMaterial);
    
    // Get the iIndexth FhirSubstancePolymerMonomerSetStartingMaterial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymerMonomerSetStartingMaterial);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymerMonomerSetStartingMaterial;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstancePolymerMonomerSetStartingMaterials[index : Integer] : TFhirSubstancePolymerMonomerSetStartingMaterial read GetItemN write SetItemN; default;
  End;

  // Todo.
  TFhirSubstancePolymerRepeat = class (TFhirBackboneElement)
  protected
    FNumberOfUnits : TFhirInteger;
    FAverageMolecularFormula : TFhirString;
    FRepeatUnitAmountType : TFhirCodeableConcept;
    FrepeatUnitList : TFhirSubstancePolymerRepeatRepeatUnitList;
    Procedure SetNumberOfUnits(value : TFhirInteger);
    Function GetNumberOfUnitsST : String;
    Procedure SetNumberOfUnitsST(value : String);
    Procedure SetAverageMolecularFormula(value : TFhirString);
    Function GetAverageMolecularFormulaST : String;
    Procedure SetAverageMolecularFormulaST(value : String);
    Procedure SetRepeatUnitAmountType(value : TFhirCodeableConcept);
    function GetRepeatUnitList : TFhirSubstancePolymerRepeatRepeatUnitList;
    function GetHasRepeatUnitList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymerRepeat; overload;
    function Clone : TFhirSubstancePolymerRepeat; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Todo.
    property numberOfUnits : String read GetNumberOfUnitsST write SetNumberOfUnitsST;
    // Todo.
    property numberOfUnitsElement : TFhirInteger read FNumberOfUnits write SetNumberOfUnits;

    // Typed access to Todo.
    property averageMolecularFormula : String read GetAverageMolecularFormulaST write SetAverageMolecularFormulaST;
    // Todo.
    property averageMolecularFormulaElement : TFhirString read FAverageMolecularFormula write SetAverageMolecularFormula;

    // Typed access to Todo. (defined for API consistency)
    property repeatUnitAmountType : TFhirCodeableConcept read FRepeatUnitAmountType write SetRepeatUnitAmountType;
    // Todo.
    property repeatUnitAmountTypeElement : TFhirCodeableConcept read FRepeatUnitAmountType write SetRepeatUnitAmountType;

    // Todo.
    property repeatUnitList : TFhirSubstancePolymerRepeatRepeatUnitList read GetRepeatUnitList;
    property hasRepeatUnitList : boolean read GetHasRepeatUnitList;

  end;

  TFhirSubstancePolymerRepeatListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerRepeatList;
    function GetCurrent : TFhirSubstancePolymerRepeat;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerRepeatList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymerRepeat read GetCurrent;
  end;

  TFhirSubstancePolymerRepeatList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstancePolymerRepeat;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymerRepeat);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstancePolymerRepeatList; Overload;
    function Clone : TFhirSubstancePolymerRepeatList; Overload;
    function GetEnumerator : TFhirSubstancePolymerRepeatListEnumerator;
    

    //  Add a FhirSubstancePolymerRepeat to the end of the list.
    function Append : TFhirSubstancePolymerRepeat;

    
    // Add an already existing FhirSubstancePolymerRepeat to the end of the list.
    procedure AddItem(value : TFhirSubstancePolymerRepeat); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymerRepeat) : Integer;
    

    // Insert FhirSubstancePolymerRepeat before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymerRepeat;
    

    // Insert an existing FhirSubstancePolymerRepeat before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymerRepeat);
    
    // Get the iIndexth FhirSubstancePolymerRepeat. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymerRepeat);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymerRepeat;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstancePolymerRepeats[index : Integer] : TFhirSubstancePolymerRepeat read GetItemN write SetItemN; default;
  End;

  // Todo.
  TFhirSubstancePolymerRepeatRepeatUnit = class (TFhirBackboneElement)
  protected
    FOrientationOfPolymerisation : TFhirCodeableConcept;
    FRepeatUnit : TFhirString;
    FAmount : TFhirSubstanceAmount;
    FdegreeOfPolymerisationList : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList;
    FstructuralRepresentationList : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList;
    Procedure SetOrientationOfPolymerisation(value : TFhirCodeableConcept);
    Procedure SetRepeatUnit(value : TFhirString);
    Function GetRepeatUnitST : String;
    Procedure SetRepeatUnitST(value : String);
    Procedure SetAmount(value : TFhirSubstanceAmount);
    function GetDegreeOfPolymerisationList : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList;
    function GetHasDegreeOfPolymerisationList : Boolean;
    function GetStructuralRepresentationList : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList;
    function GetHasStructuralRepresentationList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymerRepeatRepeatUnit; overload;
    function Clone : TFhirSubstancePolymerRepeatRepeatUnit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Todo. (defined for API consistency)
    property orientationOfPolymerisation : TFhirCodeableConcept read FOrientationOfPolymerisation write SetOrientationOfPolymerisation;
    // Todo.
    property orientationOfPolymerisationElement : TFhirCodeableConcept read FOrientationOfPolymerisation write SetOrientationOfPolymerisation;

    // Typed access to Todo.
    property repeatUnit : String read GetRepeatUnitST write SetRepeatUnitST;
    // Todo.
    property repeatUnitElement : TFhirString read FRepeatUnit write SetRepeatUnit;

    // Typed access to Todo. (defined for API consistency)
    property amount : TFhirSubstanceAmount read FAmount write SetAmount;
    // Todo.
    property amountElement : TFhirSubstanceAmount read FAmount write SetAmount;

    // Todo.
    property degreeOfPolymerisationList : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList read GetDegreeOfPolymerisationList;
    property hasDegreeOfPolymerisationList : boolean read GetHasDegreeOfPolymerisationList;

    // Todo.
    property structuralRepresentationList : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList read GetStructuralRepresentationList;
    property hasStructuralRepresentationList : boolean read GetHasStructuralRepresentationList;

  end;

  TFhirSubstancePolymerRepeatRepeatUnitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerRepeatRepeatUnitList;
    function GetCurrent : TFhirSubstancePolymerRepeatRepeatUnit;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerRepeatRepeatUnitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymerRepeatRepeatUnit read GetCurrent;
  end;

  TFhirSubstancePolymerRepeatRepeatUnitList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnit;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnit);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstancePolymerRepeatRepeatUnitList; Overload;
    function Clone : TFhirSubstancePolymerRepeatRepeatUnitList; Overload;
    function GetEnumerator : TFhirSubstancePolymerRepeatRepeatUnitListEnumerator;
    

    //  Add a FhirSubstancePolymerRepeatRepeatUnit to the end of the list.
    function Append : TFhirSubstancePolymerRepeatRepeatUnit;

    
    // Add an already existing FhirSubstancePolymerRepeatRepeatUnit to the end of the list.
    procedure AddItem(value : TFhirSubstancePolymerRepeatRepeatUnit); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymerRepeatRepeatUnit) : Integer;
    

    // Insert FhirSubstancePolymerRepeatRepeatUnit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnit;
    

    // Insert an existing FhirSubstancePolymerRepeatRepeatUnit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnit);
    
    // Get the iIndexth FhirSubstancePolymerRepeatRepeatUnit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnit;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstancePolymerRepeatRepeatUnits[index : Integer] : TFhirSubstancePolymerRepeatRepeatUnit read GetItemN write SetItemN; default;
  End;

  // Todo.
  TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation = class (TFhirBackboneElement)
  protected
    FDegree : TFhirCodeableConcept;
    FAmount : TFhirSubstanceAmount;
    Procedure SetDegree(value : TFhirCodeableConcept);
    Procedure SetAmount(value : TFhirSubstanceAmount);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation; overload;
    function Clone : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Todo. (defined for API consistency)
    property degree : TFhirCodeableConcept read FDegree write SetDegree;
    // Todo.
    property degreeElement : TFhirCodeableConcept read FDegree write SetDegree;

    // Typed access to Todo. (defined for API consistency)
    property amount : TFhirSubstanceAmount read FAmount write SetAmount;
    // Todo.
    property amountElement : TFhirSubstanceAmount read FAmount write SetAmount;

  end;

  TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList;
    function GetCurrent : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation read GetCurrent;
  end;

  TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList; Overload;
    function Clone : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList; Overload;
    function GetEnumerator : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator;
    

    //  Add a FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation to the end of the list.
    function Append : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;

    
    // Add an already existing FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation to the end of the list.
    procedure AddItem(value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation) : Integer;
    

    // Insert FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
    

    // Insert an existing FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
    
    // Get the iIndexth FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisations[index : Integer] : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation read GetItemN write SetItemN; default;
  End;

  // Todo.
  TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FRepresentation : TFhirString;
    FAttachment : TFhirAttachment;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetRepresentation(value : TFhirString);
    Function GetRepresentationST : String;
    Procedure SetRepresentationST(value : String);
    Procedure SetAttachment(value : TFhirAttachment);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation; overload;
    function Clone : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Todo. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Todo.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Todo.
    property representation : String read GetRepresentationST write SetRepresentationST;
    // Todo.
    property representationElement : TFhirString read FRepresentation write SetRepresentation;

    // Typed access to Todo. (defined for API consistency)
    property attachment : TFhirAttachment read FAttachment write SetAttachment;
    // Todo.
    property attachmentElement : TFhirAttachment read FAttachment write SetAttachment;

  end;

  TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList;
    function GetCurrent : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation read GetCurrent;
  end;

  TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList; Overload;
    function Clone : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList; Overload;
    function GetEnumerator : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator;
    

    //  Add a FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation to the end of the list.
    function Append : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;

    
    // Add an already existing FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation to the end of the list.
    procedure AddItem(value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation) : Integer;
    

    // Insert FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
    

    // Insert an existing FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
    
    // Get the iIndexth FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentations[index : Integer] : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation read GetItemN write SetItemN; default;
  End;

  // Todo.
  TFhirSubstancePolymer = class (TFhirDomainResource)
  protected
    FClass_ : TFhirCodeableConcept;
    FGeometry : TFhirCodeableConcept;
    FcopolymerConnectivityList : TFhirCodeableConceptList;
    FmodificationList : TFhirStringList;
    FmonomerSetList : TFhirSubstancePolymerMonomerSetList;
    Frepeat_List : TFhirSubstancePolymerRepeatList;
    Procedure SetClass_(value : TFhirCodeableConcept);
    Procedure SetGeometry(value : TFhirCodeableConcept);
    function GetCopolymerConnectivityList : TFhirCodeableConceptList;
    function GetHasCopolymerConnectivityList : Boolean;
    function GetModificationList : TFhirStringList;
    function GetHasModificationList : Boolean;
    function GetMonomerSetList : TFhirSubstancePolymerMonomerSetList;
    function GetHasMonomerSetList : Boolean;
    function GetRepeat_List : TFhirSubstancePolymerRepeatList;
    function GetHasRepeat_List : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstancePolymer; overload;
    function Clone : TFhirSubstancePolymer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Todo. (defined for API consistency)
    property class_ : TFhirCodeableConcept read FClass_ write SetClass_;
    // Todo.
    property class_Element : TFhirCodeableConcept read FClass_ write SetClass_;

    // Typed access to Todo. (defined for API consistency)
    property geometry : TFhirCodeableConcept read FGeometry write SetGeometry;
    // Todo.
    property geometryElement : TFhirCodeableConcept read FGeometry write SetGeometry;

    // Todo.
    property copolymerConnectivityList : TFhirCodeableConceptList read GetCopolymerConnectivityList;
    property hasCopolymerConnectivityList : boolean read GetHasCopolymerConnectivityList;

    // Todo.
    property modificationList : TFhirStringList read GetModificationList;
    property hasModificationList : boolean read GetHasModificationList;

    // Todo.
    property monomerSetList : TFhirSubstancePolymerMonomerSetList read GetMonomerSetList;
    property hasMonomerSetList : boolean read GetHasMonomerSetList;

    // Todo.
    property repeat_List : TFhirSubstancePolymerRepeatList read GetRepeat_List;
    property hasRepeat_List : boolean read GetHasRepeat_List;

  end;

  TFhirSubstancePolymerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstancePolymerList;
    function GetCurrent : TFhirSubstancePolymer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstancePolymerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstancePolymer read GetCurrent;
  end;

  TFhirSubstancePolymerList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstancePolymer;
    procedure SetItemN(index : Integer; value : TFhirSubstancePolymer);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstancePolymerList; Overload;
    function Clone : TFhirSubstancePolymerList; Overload;
    function GetEnumerator : TFhirSubstancePolymerListEnumerator;
    

    //  Add a FhirSubstancePolymer to the end of the list.
    function Append : TFhirSubstancePolymer;

    
    // Add an already existing FhirSubstancePolymer to the end of the list.
    procedure AddItem(value : TFhirSubstancePolymer); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstancePolymer) : Integer;
    

    // Insert FhirSubstancePolymer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstancePolymer;
    

    // Insert an existing FhirSubstancePolymer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstancePolymer);
    
    // Get the iIndexth FhirSubstancePolymer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstancePolymer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstancePolymer;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstancePolymers[index : Integer] : TFhirSubstancePolymer read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCEPOLYMER}

{$IFDEF FHIR_SUBSTANCEPROTEIN}

  // This subclause refers to the description of each subunit constituting the SubstanceProtein. A subunit is a linear sequence of amino acids linked through peptide bonds. The Subunit information shall be provided when the finished SubstanceProtein is a complex of multiple sequences; subunits are not used to delineate domains within a single sequence. Subunits are listed in order of decreasing length; sequences of the same length will be ordered by decreasing molecular weight; subunits that have identical sequences will be repeated multiple times.
  TFhirSubstanceProteinSubunit = class (TFhirBackboneElement)
  protected
    FSubunit : TFhirInteger;
    FSequence : TFhirString;
    FLength : TFhirInteger;
    FSequenceAttachment : TFhirAttachment;
    FNTerminalModificationId : TFhirIdentifier;
    FNTerminalModification : TFhirString;
    FCTerminalModificationId : TFhirIdentifier;
    FCTerminalModification : TFhirString;
    Procedure SetSubunit(value : TFhirInteger);
    Function GetSubunitST : String;
    Procedure SetSubunitST(value : String);
    Procedure SetSequence(value : TFhirString);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetLength(value : TFhirInteger);
    Function GetLengthST : String;
    Procedure SetLengthST(value : String);
    Procedure SetSequenceAttachment(value : TFhirAttachment);
    Procedure SetNTerminalModificationId(value : TFhirIdentifier);
    Procedure SetNTerminalModification(value : TFhirString);
    Function GetNTerminalModificationST : String;
    Procedure SetNTerminalModificationST(value : String);
    Procedure SetCTerminalModificationId(value : TFhirIdentifier);
    Procedure SetCTerminalModification(value : TFhirString);
    Function GetCTerminalModificationST : String;
    Procedure SetCTerminalModificationST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceProteinSubunit; overload;
    function Clone : TFhirSubstanceProteinSubunit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Index of primary sequences of amino acids linked through peptide bonds in order of decreasing length. Sequences of the same length will be ordered by molecular weight. Subunits that have identical sequences will be repeated and have sequential subscripts.
    property subunit : String read GetSubunitST write SetSubunitST;
    // Index of primary sequences of amino acids linked through peptide bonds in order of decreasing length. Sequences of the same length will be ordered by molecular weight. Subunits that have identical sequences will be repeated and have sequential subscripts.
    property subunitElement : TFhirInteger read FSubunit write SetSubunit;

    // Typed access to The sequence information shall be provided enumerating the amino acids from N- to C-terminal end using standard single-letter amino acid codes. Uppercase shall be used for L-amino acids and lowercase for D-amino acids. Transcribed SubstanceProteins will always be described using the translated sequence; for synthetic peptide containing amino acids that are not represented with a single letter code an X should be used within the sequence. The modified amino acids will be distinguished by their position in the sequence.
    property sequence : String read GetSequenceST write SetSequenceST;
    // The sequence information shall be provided enumerating the amino acids from N- to C-terminal end using standard single-letter amino acid codes. Uppercase shall be used for L-amino acids and lowercase for D-amino acids. Transcribed SubstanceProteins will always be described using the translated sequence; for synthetic peptide containing amino acids that are not represented with a single letter code an X should be used within the sequence. The modified amino acids will be distinguished by their position in the sequence.
    property sequenceElement : TFhirString read FSequence write SetSequence;

    // Typed access to Length of linear sequences of amino acids contained in the subunit.
    property length : String read GetLengthST write SetLengthST;
    // Length of linear sequences of amino acids contained in the subunit.
    property lengthElement : TFhirInteger read FLength write SetLength;

    // Typed access to The sequence information shall be provided enumerating the amino acids from N- to C-terminal end using standard single-letter amino acid codes. Uppercase shall be used for L-amino acids and lowercase for D-amino acids. Transcribed SubstanceProteins will always be described using the translated sequence; for synthetic peptide containing amino acids that are not represented with a single letter code an X should be used within the sequence. The modified amino acids will be distinguished by their position in the sequence. (defined for API consistency)
    property sequenceAttachment : TFhirAttachment read FSequenceAttachment write SetSequenceAttachment;
    // The sequence information shall be provided enumerating the amino acids from N- to C-terminal end using standard single-letter amino acid codes. Uppercase shall be used for L-amino acids and lowercase for D-amino acids. Transcribed SubstanceProteins will always be described using the translated sequence; for synthetic peptide containing amino acids that are not represented with a single letter code an X should be used within the sequence. The modified amino acids will be distinguished by their position in the sequence.
    property sequenceAttachmentElement : TFhirAttachment read FSequenceAttachment write SetSequenceAttachment;

    // Typed access to Unique identifier for molecular fragment modification based on the ISO 11238 Substance ID. (defined for API consistency)
    property nTerminalModificationId : TFhirIdentifier read FNTerminalModificationId write SetNTerminalModificationId;
    // Unique identifier for molecular fragment modification based on the ISO 11238 Substance ID.
    property nTerminalModificationIdElement : TFhirIdentifier read FNTerminalModificationId write SetNTerminalModificationId;

    // Typed access to The name of the fragment modified at the N-terminal of the SubstanceProtein shall be specified.
    property nTerminalModification : String read GetNTerminalModificationST write SetNTerminalModificationST;
    // The name of the fragment modified at the N-terminal of the SubstanceProtein shall be specified.
    property nTerminalModificationElement : TFhirString read FNTerminalModification write SetNTerminalModification;

    // Typed access to Unique identifier for molecular fragment modification based on the ISO 11238 Substance ID. (defined for API consistency)
    property cTerminalModificationId : TFhirIdentifier read FCTerminalModificationId write SetCTerminalModificationId;
    // Unique identifier for molecular fragment modification based on the ISO 11238 Substance ID.
    property cTerminalModificationIdElement : TFhirIdentifier read FCTerminalModificationId write SetCTerminalModificationId;

    // Typed access to The modification at the C-terminal shall be specified.
    property cTerminalModification : String read GetCTerminalModificationST write SetCTerminalModificationST;
    // The modification at the C-terminal shall be specified.
    property cTerminalModificationElement : TFhirString read FCTerminalModification write SetCTerminalModification;

  end;

  TFhirSubstanceProteinSubunitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceProteinSubunitList;
    function GetCurrent : TFhirSubstanceProteinSubunit;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceProteinSubunitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceProteinSubunit read GetCurrent;
  end;

  TFhirSubstanceProteinSubunitList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceProteinSubunit;
    procedure SetItemN(index : Integer; value : TFhirSubstanceProteinSubunit);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceProteinSubunitList; Overload;
    function Clone : TFhirSubstanceProteinSubunitList; Overload;
    function GetEnumerator : TFhirSubstanceProteinSubunitListEnumerator;
    

    //  Add a FhirSubstanceProteinSubunit to the end of the list.
    function Append : TFhirSubstanceProteinSubunit;

    
    // Add an already existing FhirSubstanceProteinSubunit to the end of the list.
    procedure AddItem(value : TFhirSubstanceProteinSubunit); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceProteinSubunit) : Integer;
    

    // Insert FhirSubstanceProteinSubunit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceProteinSubunit;
    

    // Insert an existing FhirSubstanceProteinSubunit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceProteinSubunit);
    
    // Get the iIndexth FhirSubstanceProteinSubunit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceProteinSubunit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceProteinSubunit;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceProteinSubunits[index : Integer] : TFhirSubstanceProteinSubunit read GetItemN write SetItemN; default;
  End;

  // A SubstanceProtein is defined as a single unit of a linear amino acid sequence, or a combination of subunits that are either covalently linked or have a defined invariant stoichiometric relationship. This includes all synthetic, recombinant and purified SubstanceProteins of defined sequence, whether the use is therapeutic or prophylactic. This set of elements will be used to describe albumins, coagulation factors, cytokines, growth factors, peptide/SubstanceProtein hormones, enzymes, toxins, toxoids, recombinant vaccines, and immunomodulators.
  TFhirSubstanceProtein = class (TFhirDomainResource)
  protected
    FSequenceType : TFhirCodeableConcept;
    FNumberOfSubunits : TFhirInteger;
    FdisulfideLinkageList : TFhirStringList;
    FsubunitList : TFhirSubstanceProteinSubunitList;
    Procedure SetSequenceType(value : TFhirCodeableConcept);
    Procedure SetNumberOfSubunits(value : TFhirInteger);
    Function GetNumberOfSubunitsST : String;
    Procedure SetNumberOfSubunitsST(value : String);
    function GetDisulfideLinkageList : TFhirStringList;
    function GetHasDisulfideLinkageList : Boolean;
    function GetSubunitList : TFhirSubstanceProteinSubunitList;
    function GetHasSubunitList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceProtein; overload;
    function Clone : TFhirSubstanceProtein; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The SubstanceProtein descriptive elements will only be used when a complete or partial amino acid sequence is available or derivable from a nucleic acid sequence. (defined for API consistency)
    property sequenceType : TFhirCodeableConcept read FSequenceType write SetSequenceType;
    // The SubstanceProtein descriptive elements will only be used when a complete or partial amino acid sequence is available or derivable from a nucleic acid sequence.
    property sequenceTypeElement : TFhirCodeableConcept read FSequenceType write SetSequenceType;

    // Typed access to Number of linear sequences of amino acids linked through peptide bonds. The number of subunits constituting the SubstanceProtein shall be described. It is possible that the number of subunits can be variable.
    property numberOfSubunits : String read GetNumberOfSubunitsST write SetNumberOfSubunitsST;
    // Number of linear sequences of amino acids linked through peptide bonds. The number of subunits constituting the SubstanceProtein shall be described. It is possible that the number of subunits can be variable.
    property numberOfSubunitsElement : TFhirInteger read FNumberOfSubunits write SetNumberOfSubunits;

    // The disulphide bond between two cysteine residues either on the same subunit or on two different subunits shall be described. The position of the disulfide bonds in the SubstanceProtein shall be listed in increasing order of subunit number and position within subunit followed by the abbreviation of the amino acids involved. The disulfide linkage positions shall actually contain the amino acid Cysteine at the respective positions.
    property disulfideLinkageList : TFhirStringList read GetDisulfideLinkageList;
    property hasDisulfideLinkageList : boolean read GetHasDisulfideLinkageList;

    // This subclause refers to the description of each subunit constituting the SubstanceProtein. A subunit is a linear sequence of amino acids linked through peptide bonds. The Subunit information shall be provided when the finished SubstanceProtein is a complex of multiple sequences; subunits are not used to delineate domains within a single sequence. Subunits are listed in order of decreasing length; sequences of the same length will be ordered by decreasing molecular weight; subunits that have identical sequences will be repeated multiple times.
    property subunitList : TFhirSubstanceProteinSubunitList read GetSubunitList;
    property hasSubunitList : boolean read GetHasSubunitList;

  end;

  TFhirSubstanceProteinListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceProteinList;
    function GetCurrent : TFhirSubstanceProtein;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceProteinList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceProtein read GetCurrent;
  end;

  TFhirSubstanceProteinList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceProtein;
    procedure SetItemN(index : Integer; value : TFhirSubstanceProtein);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceProteinList; Overload;
    function Clone : TFhirSubstanceProteinList; Overload;
    function GetEnumerator : TFhirSubstanceProteinListEnumerator;
    

    //  Add a FhirSubstanceProtein to the end of the list.
    function Append : TFhirSubstanceProtein;

    
    // Add an already existing FhirSubstanceProtein to the end of the list.
    procedure AddItem(value : TFhirSubstanceProtein); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceProtein) : Integer;
    

    // Insert FhirSubstanceProtein before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceProtein;
    

    // Insert an existing FhirSubstanceProtein before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceProtein);
    
    // Get the iIndexth FhirSubstanceProtein. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceProtein);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceProtein;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceProteins[index : Integer] : TFhirSubstanceProtein read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCEPROTEIN}

{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}

  // Todo.
  TFhirSubstanceReferenceInformationGene = class (TFhirBackboneElement)
  protected
    FGeneSequenceOrigin : TFhirCodeableConcept;
    FGene : TFhirCodeableConcept;
    FsourceList : TFhirReferenceList{TFhirDocumentReference};
    Procedure SetGeneSequenceOrigin(value : TFhirCodeableConcept);
    Procedure SetGene(value : TFhirCodeableConcept);
    function GetSourceList : TFhirReferenceList{TFhirDocumentReference};
    function GetHasSourceList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceReferenceInformationGene; overload;
    function Clone : TFhirSubstanceReferenceInformationGene; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Todo. (defined for API consistency)
    property geneSequenceOrigin : TFhirCodeableConcept read FGeneSequenceOrigin write SetGeneSequenceOrigin;
    // Todo.
    property geneSequenceOriginElement : TFhirCodeableConcept read FGeneSequenceOrigin write SetGeneSequenceOrigin;

    // Typed access to Todo. (defined for API consistency)
    property gene : TFhirCodeableConcept read FGene write SetGene;
    // Todo.
    property geneElement : TFhirCodeableConcept read FGene write SetGene;

    // Todo.
    property sourceList : TFhirReferenceList{TFhirDocumentReference} read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceReferenceInformationGeneListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceReferenceInformationGeneList;
    function GetCurrent : TFhirSubstanceReferenceInformationGene;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceReferenceInformationGeneList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceReferenceInformationGene read GetCurrent;
  end;

  TFhirSubstanceReferenceInformationGeneList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceReferenceInformationGene;
    procedure SetItemN(index : Integer; value : TFhirSubstanceReferenceInformationGene);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceReferenceInformationGeneList; Overload;
    function Clone : TFhirSubstanceReferenceInformationGeneList; Overload;
    function GetEnumerator : TFhirSubstanceReferenceInformationGeneListEnumerator;
    

    //  Add a FhirSubstanceReferenceInformationGene to the end of the list.
    function Append : TFhirSubstanceReferenceInformationGene;

    
    // Add an already existing FhirSubstanceReferenceInformationGene to the end of the list.
    procedure AddItem(value : TFhirSubstanceReferenceInformationGene); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceReferenceInformationGene) : Integer;
    

    // Insert FhirSubstanceReferenceInformationGene before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceReferenceInformationGene;
    

    // Insert an existing FhirSubstanceReferenceInformationGene before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceReferenceInformationGene);
    
    // Get the iIndexth FhirSubstanceReferenceInformationGene. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceReferenceInformationGene);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceReferenceInformationGene;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceReferenceInformationGenes[index : Integer] : TFhirSubstanceReferenceInformationGene read GetItemN write SetItemN; default;
  End;

  // Todo.
  TFhirSubstanceReferenceInformationGeneElement = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FElement : TFhirIdentifier;
    FsourceList : TFhirReferenceList{TFhirDocumentReference};
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetElement(value : TFhirIdentifier);
    function GetSourceList : TFhirReferenceList{TFhirDocumentReference};
    function GetHasSourceList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceReferenceInformationGeneElement; overload;
    function Clone : TFhirSubstanceReferenceInformationGeneElement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Todo. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Todo.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Todo. (defined for API consistency)
    property element : TFhirIdentifier read FElement write SetElement;
    // Todo.
    property elementElement : TFhirIdentifier read FElement write SetElement;

    // Todo.
    property sourceList : TFhirReferenceList{TFhirDocumentReference} read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceReferenceInformationGeneElementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceReferenceInformationGeneElementList;
    function GetCurrent : TFhirSubstanceReferenceInformationGeneElement;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceReferenceInformationGeneElementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceReferenceInformationGeneElement read GetCurrent;
  end;

  TFhirSubstanceReferenceInformationGeneElementList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceReferenceInformationGeneElement;
    procedure SetItemN(index : Integer; value : TFhirSubstanceReferenceInformationGeneElement);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceReferenceInformationGeneElementList; Overload;
    function Clone : TFhirSubstanceReferenceInformationGeneElementList; Overload;
    function GetEnumerator : TFhirSubstanceReferenceInformationGeneElementListEnumerator;
    

    //  Add a FhirSubstanceReferenceInformationGeneElement to the end of the list.
    function Append : TFhirSubstanceReferenceInformationGeneElement;

    
    // Add an already existing FhirSubstanceReferenceInformationGeneElement to the end of the list.
    procedure AddItem(value : TFhirSubstanceReferenceInformationGeneElement); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceReferenceInformationGeneElement) : Integer;
    

    // Insert FhirSubstanceReferenceInformationGeneElement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceReferenceInformationGeneElement;
    

    // Insert an existing FhirSubstanceReferenceInformationGeneElement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceReferenceInformationGeneElement);
    
    // Get the iIndexth FhirSubstanceReferenceInformationGeneElement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceReferenceInformationGeneElement);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceReferenceInformationGeneElement;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceReferenceInformationGeneElements[index : Integer] : TFhirSubstanceReferenceInformationGeneElement read GetItemN write SetItemN; default;
  End;

  // Todo.
  TFhirSubstanceReferenceInformationClassification = class (TFhirBackboneElement)
  protected
    FDomain : TFhirCodeableConcept;
    FClassification : TFhirCodeableConcept;
    FsubtypeList : TFhirCodeableConceptList;
    FsourceList : TFhirReferenceList{TFhirDocumentReference};
    Procedure SetDomain(value : TFhirCodeableConcept);
    Procedure SetClassification(value : TFhirCodeableConcept);
    function GetSubtypeList : TFhirCodeableConceptList;
    function GetHasSubtypeList : Boolean;
    function GetSourceList : TFhirReferenceList{TFhirDocumentReference};
    function GetHasSourceList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceReferenceInformationClassification; overload;
    function Clone : TFhirSubstanceReferenceInformationClassification; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Todo. (defined for API consistency)
    property domain : TFhirCodeableConcept read FDomain write SetDomain;
    // Todo.
    property domainElement : TFhirCodeableConcept read FDomain write SetDomain;

    // Typed access to Todo. (defined for API consistency)
    property classification : TFhirCodeableConcept read FClassification write SetClassification;
    // Todo.
    property classificationElement : TFhirCodeableConcept read FClassification write SetClassification;

    // Todo.
    property subtypeList : TFhirCodeableConceptList read GetSubtypeList;
    property hasSubtypeList : boolean read GetHasSubtypeList;

    // Todo.
    property sourceList : TFhirReferenceList{TFhirDocumentReference} read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceReferenceInformationClassificationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceReferenceInformationClassificationList;
    function GetCurrent : TFhirSubstanceReferenceInformationClassification;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceReferenceInformationClassificationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceReferenceInformationClassification read GetCurrent;
  end;

  TFhirSubstanceReferenceInformationClassificationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceReferenceInformationClassification;
    procedure SetItemN(index : Integer; value : TFhirSubstanceReferenceInformationClassification);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceReferenceInformationClassificationList; Overload;
    function Clone : TFhirSubstanceReferenceInformationClassificationList; Overload;
    function GetEnumerator : TFhirSubstanceReferenceInformationClassificationListEnumerator;
    

    //  Add a FhirSubstanceReferenceInformationClassification to the end of the list.
    function Append : TFhirSubstanceReferenceInformationClassification;

    
    // Add an already existing FhirSubstanceReferenceInformationClassification to the end of the list.
    procedure AddItem(value : TFhirSubstanceReferenceInformationClassification); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceReferenceInformationClassification) : Integer;
    

    // Insert FhirSubstanceReferenceInformationClassification before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceReferenceInformationClassification;
    

    // Insert an existing FhirSubstanceReferenceInformationClassification before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceReferenceInformationClassification);
    
    // Get the iIndexth FhirSubstanceReferenceInformationClassification. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceReferenceInformationClassification);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceReferenceInformationClassification;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceReferenceInformationClassifications[index : Integer] : TFhirSubstanceReferenceInformationClassification read GetItemN write SetItemN; default;
  End;

  // Todo.
  TFhirSubstanceReferenceInformationTarget = class (TFhirBackboneElement)
  protected
    FTarget : TFhirIdentifier;
    FType_ : TFhirCodeableConcept;
    FInteraction : TFhirCodeableConcept;
    FOrganism : TFhirCodeableConcept;
    FOrganismType : TFhirCodeableConcept;
    FAmount : TFhirType;
    FAmountType : TFhirCodeableConcept;
    FsourceList : TFhirReferenceList{TFhirDocumentReference};
    Procedure SetTarget(value : TFhirIdentifier);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetInteraction(value : TFhirCodeableConcept);
    Procedure SetOrganism(value : TFhirCodeableConcept);
    Procedure SetOrganismType(value : TFhirCodeableConcept);
    Procedure SetAmount(value : TFhirType);
    Procedure SetAmountType(value : TFhirCodeableConcept);
    function GetSourceList : TFhirReferenceList{TFhirDocumentReference};
    function GetHasSourceList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceReferenceInformationTarget; overload;
    function Clone : TFhirSubstanceReferenceInformationTarget; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Todo. (defined for API consistency)
    property target : TFhirIdentifier read FTarget write SetTarget;
    // Todo.
    property targetElement : TFhirIdentifier read FTarget write SetTarget;

    // Typed access to Todo. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Todo.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Todo. (defined for API consistency)
    property interaction : TFhirCodeableConcept read FInteraction write SetInteraction;
    // Todo.
    property interactionElement : TFhirCodeableConcept read FInteraction write SetInteraction;

    // Typed access to Todo. (defined for API consistency)
    property organism : TFhirCodeableConcept read FOrganism write SetOrganism;
    // Todo.
    property organismElement : TFhirCodeableConcept read FOrganism write SetOrganism;

    // Typed access to Todo. (defined for API consistency)
    property organismType : TFhirCodeableConcept read FOrganismType write SetOrganismType;
    // Todo.
    property organismTypeElement : TFhirCodeableConcept read FOrganismType write SetOrganismType;

    // Typed access to Todo. (defined for API consistency)
    property amount : TFhirType read FAmount write SetAmount;
    // Todo.
    property amountElement : TFhirType read FAmount write SetAmount;

    // Typed access to Todo. (defined for API consistency)
    property amountType : TFhirCodeableConcept read FAmountType write SetAmountType;
    // Todo.
    property amountTypeElement : TFhirCodeableConcept read FAmountType write SetAmountType;

    // Todo.
    property sourceList : TFhirReferenceList{TFhirDocumentReference} read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceReferenceInformationTargetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceReferenceInformationTargetList;
    function GetCurrent : TFhirSubstanceReferenceInformationTarget;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceReferenceInformationTargetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceReferenceInformationTarget read GetCurrent;
  end;

  TFhirSubstanceReferenceInformationTargetList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceReferenceInformationTarget;
    procedure SetItemN(index : Integer; value : TFhirSubstanceReferenceInformationTarget);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceReferenceInformationTargetList; Overload;
    function Clone : TFhirSubstanceReferenceInformationTargetList; Overload;
    function GetEnumerator : TFhirSubstanceReferenceInformationTargetListEnumerator;
    

    //  Add a FhirSubstanceReferenceInformationTarget to the end of the list.
    function Append : TFhirSubstanceReferenceInformationTarget;

    
    // Add an already existing FhirSubstanceReferenceInformationTarget to the end of the list.
    procedure AddItem(value : TFhirSubstanceReferenceInformationTarget); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceReferenceInformationTarget) : Integer;
    

    // Insert FhirSubstanceReferenceInformationTarget before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceReferenceInformationTarget;
    

    // Insert an existing FhirSubstanceReferenceInformationTarget before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceReferenceInformationTarget);
    
    // Get the iIndexth FhirSubstanceReferenceInformationTarget. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceReferenceInformationTarget);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceReferenceInformationTarget;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceReferenceInformationTargets[index : Integer] : TFhirSubstanceReferenceInformationTarget read GetItemN write SetItemN; default;
  End;

  // Todo.
  TFhirSubstanceReferenceInformation = class (TFhirDomainResource)
  protected
    FComment : TFhirString;
    FgeneList : TFhirSubstanceReferenceInformationGeneList;
    FgeneElementList : TFhirSubstanceReferenceInformationGeneElementList;
    FclassificationList : TFhirSubstanceReferenceInformationClassificationList;
    FtargetList : TFhirSubstanceReferenceInformationTargetList;
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);
    function GetGeneList : TFhirSubstanceReferenceInformationGeneList;
    function GetHasGeneList : Boolean;
    function GetGeneElementList : TFhirSubstanceReferenceInformationGeneElementList;
    function GetHasGeneElementList : Boolean;
    function GetClassificationList : TFhirSubstanceReferenceInformationClassificationList;
    function GetHasClassificationList : Boolean;
    function GetTargetList : TFhirSubstanceReferenceInformationTargetList;
    function GetHasTargetList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceReferenceInformation; overload;
    function Clone : TFhirSubstanceReferenceInformation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Todo.
    property comment : String read GetCommentST write SetCommentST;
    // Todo.
    property commentElement : TFhirString read FComment write SetComment;

    // Todo.
    property geneList : TFhirSubstanceReferenceInformationGeneList read GetGeneList;
    property hasGeneList : boolean read GetHasGeneList;

    // Todo.
    property geneElementList : TFhirSubstanceReferenceInformationGeneElementList read GetGeneElementList;
    property hasGeneElementList : boolean read GetHasGeneElementList;

    // Todo.
    property classificationList : TFhirSubstanceReferenceInformationClassificationList read GetClassificationList;
    property hasClassificationList : boolean read GetHasClassificationList;

    // Todo.
    property targetList : TFhirSubstanceReferenceInformationTargetList read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

  end;

  TFhirSubstanceReferenceInformationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceReferenceInformationList;
    function GetCurrent : TFhirSubstanceReferenceInformation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceReferenceInformationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceReferenceInformation read GetCurrent;
  end;

  TFhirSubstanceReferenceInformationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceReferenceInformation;
    procedure SetItemN(index : Integer; value : TFhirSubstanceReferenceInformation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceReferenceInformationList; Overload;
    function Clone : TFhirSubstanceReferenceInformationList; Overload;
    function GetEnumerator : TFhirSubstanceReferenceInformationListEnumerator;
    

    //  Add a FhirSubstanceReferenceInformation to the end of the list.
    function Append : TFhirSubstanceReferenceInformation;

    
    // Add an already existing FhirSubstanceReferenceInformation to the end of the list.
    procedure AddItem(value : TFhirSubstanceReferenceInformation); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceReferenceInformation) : Integer;
    

    // Insert FhirSubstanceReferenceInformation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceReferenceInformation;
    

    // Insert an existing FhirSubstanceReferenceInformation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceReferenceInformation);
    
    // Get the iIndexth FhirSubstanceReferenceInformation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceReferenceInformation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceReferenceInformation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceReferenceInformations[index : Integer] : TFhirSubstanceReferenceInformation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}

{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}

  // Many complex materials are fractions of parts of plants, animals, or minerals. Fraction elements are often necessary to define both Substances and Specified Group 1 Substances. For substances derived from Plants, fraction information will be captured at the Substance information level ( . Oils, Juices and Exudates). Additional information for Extracts, such as extraction solvent composition, will be captured at the Specified Substance Group 1 information level. For plasma-derived products fraction information will be captured at the Substance and the Specified Substance Group 1 levels.
  TFhirSubstanceSourceMaterialFractionDescription = class (TFhirBackboneElement)
  protected
    FFraction : TFhirString;
    FMaterialType : TFhirCodeableConcept;
    Procedure SetFraction(value : TFhirString);
    Function GetFractionST : String;
    Procedure SetFractionST(value : String);
    Procedure SetMaterialType(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterialFractionDescription; overload;
    function Clone : TFhirSubstanceSourceMaterialFractionDescription; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to This element is capturing information about the fraction of a plant part, or human plasma for fractionation.
    property fraction : String read GetFractionST write SetFractionST;
    // This element is capturing information about the fraction of a plant part, or human plasma for fractionation.
    property fractionElement : TFhirString read FFraction write SetFraction;

    // Typed access to The specific type of the material constituting the component. For Herbal preparations the particulars of the extracts (liquid/dry) is described in Specified Substance Group 1. (defined for API consistency)
    property materialType : TFhirCodeableConcept read FMaterialType write SetMaterialType;
    // The specific type of the material constituting the component. For Herbal preparations the particulars of the extracts (liquid/dry) is described in Specified Substance Group 1.
    property materialTypeElement : TFhirCodeableConcept read FMaterialType write SetMaterialType;

  end;

  TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialFractionDescriptionList;
    function GetCurrent : TFhirSubstanceSourceMaterialFractionDescription;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialFractionDescriptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterialFractionDescription read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialFractionDescriptionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterialFractionDescription;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterialFractionDescription);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceSourceMaterialFractionDescriptionList; Overload;
    function Clone : TFhirSubstanceSourceMaterialFractionDescriptionList; Overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator;
    

    //  Add a FhirSubstanceSourceMaterialFractionDescription to the end of the list.
    function Append : TFhirSubstanceSourceMaterialFractionDescription;

    
    // Add an already existing FhirSubstanceSourceMaterialFractionDescription to the end of the list.
    procedure AddItem(value : TFhirSubstanceSourceMaterialFractionDescription); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterialFractionDescription) : Integer;
    

    // Insert FhirSubstanceSourceMaterialFractionDescription before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterialFractionDescription;
    

    // Insert an existing FhirSubstanceSourceMaterialFractionDescription before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterialFractionDescription);
    
    // Get the iIndexth FhirSubstanceSourceMaterialFractionDescription. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterialFractionDescription);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterialFractionDescription;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceSourceMaterialFractionDescriptions[index : Integer] : TFhirSubstanceSourceMaterialFractionDescription read GetItemN write SetItemN; default;
  End;

  // This subclause describes the organism which the substance is derived from. For vaccines, the parent organism shall be specified based on these subclause elements. As an example, full taxonomy will be described for the Substance Name: ., Leaf.
  TFhirSubstanceSourceMaterialOrganism = class (TFhirBackboneElement)
  protected
    FFamily : TFhirCodeableConcept;
    FGenus : TFhirCodeableConcept;
    FSpecies : TFhirCodeableConcept;
    FIntraspecificType : TFhirCodeableConcept;
    FIntraspecificDescription : TFhirString;
    FauthorList : TFhirSubstanceSourceMaterialOrganismAuthorList;
    FHybrid : TFhirSubstanceSourceMaterialOrganismHybrid;
    FOrganismGeneral : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
    Procedure SetFamily(value : TFhirCodeableConcept);
    Procedure SetGenus(value : TFhirCodeableConcept);
    Procedure SetSpecies(value : TFhirCodeableConcept);
    Procedure SetIntraspecificType(value : TFhirCodeableConcept);
    Procedure SetIntraspecificDescription(value : TFhirString);
    Function GetIntraspecificDescriptionST : String;
    Procedure SetIntraspecificDescriptionST(value : String);
    function GetAuthorList : TFhirSubstanceSourceMaterialOrganismAuthorList;
    function GetHasAuthorList : Boolean;
    Procedure SetHybrid(value : TFhirSubstanceSourceMaterialOrganismHybrid);
    Procedure SetOrganismGeneral(value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterialOrganism; overload;
    function Clone : TFhirSubstanceSourceMaterialOrganism; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The family of an organism shall be specified. (defined for API consistency)
    property family : TFhirCodeableConcept read FFamily write SetFamily;
    // The family of an organism shall be specified.
    property familyElement : TFhirCodeableConcept read FFamily write SetFamily;

    // Typed access to The genus of an organism shall be specified; refers to the Latin epithet of the genus element of the plant/animal scientific name; it is present in names for genera, species and infraspecies. (defined for API consistency)
    property genus : TFhirCodeableConcept read FGenus write SetGenus;
    // The genus of an organism shall be specified; refers to the Latin epithet of the genus element of the plant/animal scientific name; it is present in names for genera, species and infraspecies.
    property genusElement : TFhirCodeableConcept read FGenus write SetGenus;

    // Typed access to The species of an organism shall be specified; refers to the Latin epithet of the species of the plant/animal; it is present in names for species and infraspecies. (defined for API consistency)
    property species : TFhirCodeableConcept read FSpecies write SetSpecies;
    // The species of an organism shall be specified; refers to the Latin epithet of the species of the plant/animal; it is present in names for species and infraspecies.
    property speciesElement : TFhirCodeableConcept read FSpecies write SetSpecies;

    // Typed access to The Intraspecific type of an organism shall be specified. (defined for API consistency)
    property intraspecificType : TFhirCodeableConcept read FIntraspecificType write SetIntraspecificType;
    // The Intraspecific type of an organism shall be specified.
    property intraspecificTypeElement : TFhirCodeableConcept read FIntraspecificType write SetIntraspecificType;

    // Typed access to The intraspecific description of an organism shall be specified based on a controlled vocabulary. For Influenza Vaccine, the intraspecific description shall contain the syntax of the antigen in line with the WHO convention.
    property intraspecificDescription : String read GetIntraspecificDescriptionST write SetIntraspecificDescriptionST;
    // The intraspecific description of an organism shall be specified based on a controlled vocabulary. For Influenza Vaccine, the intraspecific description shall contain the syntax of the antigen in line with the WHO convention.
    property intraspecificDescriptionElement : TFhirString read FIntraspecificDescription write SetIntraspecificDescription;

    // 4.9.13.6.1 Author type (Conditional).
    property authorList : TFhirSubstanceSourceMaterialOrganismAuthorList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // Typed access to 4.9.13.8.1 Hybrid species maternal organism ID (Optional). (defined for API consistency)
    property hybrid : TFhirSubstanceSourceMaterialOrganismHybrid read FHybrid write SetHybrid;
    // 4.9.13.8.1 Hybrid species maternal organism ID (Optional).
    property hybridElement : TFhirSubstanceSourceMaterialOrganismHybrid read FHybrid write SetHybrid;

    // Typed access to 4.9.13.7.1 Kingdom (Conditional). (defined for API consistency)
    property organismGeneral : TFhirSubstanceSourceMaterialOrganismOrganismGeneral read FOrganismGeneral write SetOrganismGeneral;
    // 4.9.13.7.1 Kingdom (Conditional).
    property organismGeneralElement : TFhirSubstanceSourceMaterialOrganismOrganismGeneral read FOrganismGeneral write SetOrganismGeneral;

  end;

  TFhirSubstanceSourceMaterialOrganismListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialOrganismList;
    function GetCurrent : TFhirSubstanceSourceMaterialOrganism;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialOrganismList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterialOrganism read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialOrganismList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterialOrganism;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterialOrganism);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceSourceMaterialOrganismList; Overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismList; Overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialOrganismListEnumerator;
    

    //  Add a FhirSubstanceSourceMaterialOrganism to the end of the list.
    function Append : TFhirSubstanceSourceMaterialOrganism;

    
    // Add an already existing FhirSubstanceSourceMaterialOrganism to the end of the list.
    procedure AddItem(value : TFhirSubstanceSourceMaterialOrganism); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterialOrganism) : Integer;
    

    // Insert FhirSubstanceSourceMaterialOrganism before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterialOrganism;
    

    // Insert an existing FhirSubstanceSourceMaterialOrganism before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterialOrganism);
    
    // Get the iIndexth FhirSubstanceSourceMaterialOrganism. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterialOrganism);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterialOrganism;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceSourceMaterialOrganisms[index : Integer] : TFhirSubstanceSourceMaterialOrganism read GetItemN write SetItemN; default;
  End;

  // 4.9.13.6.1 Author type (Conditional).
  TFhirSubstanceSourceMaterialOrganismAuthor = class (TFhirBackboneElement)
  protected
    FAuthorType : TFhirCodeableConcept;
    FAuthorDescription : TFhirString;
    Procedure SetAuthorType(value : TFhirCodeableConcept);
    Procedure SetAuthorDescription(value : TFhirString);
    Function GetAuthorDescriptionST : String;
    Procedure SetAuthorDescriptionST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterialOrganismAuthor; overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismAuthor; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The type of author of an organism species shall be specified. The parenthetical author of an organism species refers to the first author who {$IFNDEF FPC}Published{$ENDIF} the plant/animal name (of any rank). The primary author of an organism species refers to the first author(s), who validly {$IFNDEF FPC}Published{$ENDIF} the plant/animal name. (defined for API consistency)
    property authorType : TFhirCodeableConcept read FAuthorType write SetAuthorType;
    // The type of author of an organism species shall be specified. The parenthetical author of an organism species refers to the first author who {$IFNDEF FPC}Published{$ENDIF} the plant/animal name (of any rank). The primary author of an organism species refers to the first author(s), who validly {$IFNDEF FPC}Published{$ENDIF} the plant/animal name.
    property authorTypeElement : TFhirCodeableConcept read FAuthorType write SetAuthorType;

    // Typed access to The author of an organism species shall be specified. The author year of an organism shall also be specified when applicable; refers to the year in which the first author(s) {$IFNDEF FPC}Published{$ENDIF} the infraspecific plant/animal name (of any rank).
    property authorDescription : String read GetAuthorDescriptionST write SetAuthorDescriptionST;
    // The author of an organism species shall be specified. The author year of an organism shall also be specified when applicable; refers to the year in which the first author(s) {$IFNDEF FPC}Published{$ENDIF} the infraspecific plant/animal name (of any rank).
    property authorDescriptionElement : TFhirString read FAuthorDescription write SetAuthorDescription;

  end;

  TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialOrganismAuthorList;
    function GetCurrent : TFhirSubstanceSourceMaterialOrganismAuthor;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialOrganismAuthorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterialOrganismAuthor read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialOrganismAuthorList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterialOrganismAuthor;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterialOrganismAuthor);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceSourceMaterialOrganismAuthorList; Overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismAuthorList; Overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator;
    

    //  Add a FhirSubstanceSourceMaterialOrganismAuthor to the end of the list.
    function Append : TFhirSubstanceSourceMaterialOrganismAuthor;

    
    // Add an already existing FhirSubstanceSourceMaterialOrganismAuthor to the end of the list.
    procedure AddItem(value : TFhirSubstanceSourceMaterialOrganismAuthor); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterialOrganismAuthor) : Integer;
    

    // Insert FhirSubstanceSourceMaterialOrganismAuthor before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterialOrganismAuthor;
    

    // Insert an existing FhirSubstanceSourceMaterialOrganismAuthor before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterialOrganismAuthor);
    
    // Get the iIndexth FhirSubstanceSourceMaterialOrganismAuthor. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterialOrganismAuthor);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterialOrganismAuthor;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceSourceMaterialOrganismAuthors[index : Integer] : TFhirSubstanceSourceMaterialOrganismAuthor read GetItemN write SetItemN; default;
  End;

  // 4.9.13.8.1 Hybrid species maternal organism ID (Optional).
  TFhirSubstanceSourceMaterialOrganismHybrid = class (TFhirBackboneElement)
  protected
    FMaternalOrganismId : TFhirString;
    FMaternalOrganismName : TFhirString;
    FPaternalOrganismId : TFhirString;
    FPaternalOrganismName : TFhirString;
    FHybridType : TFhirCodeableConcept;
    Procedure SetMaternalOrganismId(value : TFhirString);
    Function GetMaternalOrganismIdST : String;
    Procedure SetMaternalOrganismIdST(value : String);
    Procedure SetMaternalOrganismName(value : TFhirString);
    Function GetMaternalOrganismNameST : String;
    Procedure SetMaternalOrganismNameST(value : String);
    Procedure SetPaternalOrganismId(value : TFhirString);
    Function GetPaternalOrganismIdST : String;
    Procedure SetPaternalOrganismIdST(value : String);
    Procedure SetPaternalOrganismName(value : TFhirString);
    Function GetPaternalOrganismNameST : String;
    Procedure SetPaternalOrganismNameST(value : String);
    Procedure SetHybridType(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterialOrganismHybrid; overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismHybrid; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The identifier of the maternal species constituting the hybrid organism shall be specified based on a controlled vocabulary. For plants, the parents aren?t always known, and it is unlikely that it will be known which is maternal and which is paternal.
    property maternalOrganismId : String read GetMaternalOrganismIdST write SetMaternalOrganismIdST;
    // The identifier of the maternal species constituting the hybrid organism shall be specified based on a controlled vocabulary. For plants, the parents aren?t always known, and it is unlikely that it will be known which is maternal and which is paternal.
    property maternalOrganismIdElement : TFhirString read FMaternalOrganismId write SetMaternalOrganismId;

    // Typed access to The name of the maternal species constituting the hybrid organism shall be specified. For plants, the parents aren?t always known, and it is unlikely that it will be known which is maternal and which is paternal.
    property maternalOrganismName : String read GetMaternalOrganismNameST write SetMaternalOrganismNameST;
    // The name of the maternal species constituting the hybrid organism shall be specified. For plants, the parents aren?t always known, and it is unlikely that it will be known which is maternal and which is paternal.
    property maternalOrganismNameElement : TFhirString read FMaternalOrganismName write SetMaternalOrganismName;

    // Typed access to The identifier of the paternal species constituting the hybrid organism shall be specified based on a controlled vocabulary.
    property paternalOrganismId : String read GetPaternalOrganismIdST write SetPaternalOrganismIdST;
    // The identifier of the paternal species constituting the hybrid organism shall be specified based on a controlled vocabulary.
    property paternalOrganismIdElement : TFhirString read FPaternalOrganismId write SetPaternalOrganismId;

    // Typed access to The name of the paternal species constituting the hybrid organism shall be specified.
    property paternalOrganismName : String read GetPaternalOrganismNameST write SetPaternalOrganismNameST;
    // The name of the paternal species constituting the hybrid organism shall be specified.
    property paternalOrganismNameElement : TFhirString read FPaternalOrganismName write SetPaternalOrganismName;

    // Typed access to The hybrid type of an organism shall be specified. (defined for API consistency)
    property hybridType : TFhirCodeableConcept read FHybridType write SetHybridType;
    // The hybrid type of an organism shall be specified.
    property hybridTypeElement : TFhirCodeableConcept read FHybridType write SetHybridType;

  end;

  TFhirSubstanceSourceMaterialOrganismHybridListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialOrganismHybridList;
    function GetCurrent : TFhirSubstanceSourceMaterialOrganismHybrid;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialOrganismHybridList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterialOrganismHybrid read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialOrganismHybridList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterialOrganismHybrid;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterialOrganismHybrid);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceSourceMaterialOrganismHybridList; Overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismHybridList; Overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialOrganismHybridListEnumerator;
    

    //  Add a FhirSubstanceSourceMaterialOrganismHybrid to the end of the list.
    function Append : TFhirSubstanceSourceMaterialOrganismHybrid;

    
    // Add an already existing FhirSubstanceSourceMaterialOrganismHybrid to the end of the list.
    procedure AddItem(value : TFhirSubstanceSourceMaterialOrganismHybrid); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterialOrganismHybrid) : Integer;
    

    // Insert FhirSubstanceSourceMaterialOrganismHybrid before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterialOrganismHybrid;
    

    // Insert an existing FhirSubstanceSourceMaterialOrganismHybrid before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterialOrganismHybrid);
    
    // Get the iIndexth FhirSubstanceSourceMaterialOrganismHybrid. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterialOrganismHybrid);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterialOrganismHybrid;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceSourceMaterialOrganismHybrids[index : Integer] : TFhirSubstanceSourceMaterialOrganismHybrid read GetItemN write SetItemN; default;
  End;

  // 4.9.13.7.1 Kingdom (Conditional).
  TFhirSubstanceSourceMaterialOrganismOrganismGeneral = class (TFhirBackboneElement)
  protected
    FKingdom : TFhirCodeableConcept;
    FPhylum : TFhirCodeableConcept;
    FClass_ : TFhirCodeableConcept;
    FOrder : TFhirCodeableConcept;
    Procedure SetKingdom(value : TFhirCodeableConcept);
    Procedure SetPhylum(value : TFhirCodeableConcept);
    Procedure SetClass_(value : TFhirCodeableConcept);
    Procedure SetOrder(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterialOrganismOrganismGeneral; overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismOrganismGeneral; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The kingdom of an organism shall be specified. (defined for API consistency)
    property kingdom : TFhirCodeableConcept read FKingdom write SetKingdom;
    // The kingdom of an organism shall be specified.
    property kingdomElement : TFhirCodeableConcept read FKingdom write SetKingdom;

    // Typed access to The phylum of an organism shall be specified. (defined for API consistency)
    property phylum : TFhirCodeableConcept read FPhylum write SetPhylum;
    // The phylum of an organism shall be specified.
    property phylumElement : TFhirCodeableConcept read FPhylum write SetPhylum;

    // Typed access to The class of an organism shall be specified. (defined for API consistency)
    property class_ : TFhirCodeableConcept read FClass_ write SetClass_;
    // The class of an organism shall be specified.
    property class_Element : TFhirCodeableConcept read FClass_ write SetClass_;

    // Typed access to The order of an organism shall be specified,. (defined for API consistency)
    property order : TFhirCodeableConcept read FOrder write SetOrder;
    // The order of an organism shall be specified,.
    property orderElement : TFhirCodeableConcept read FOrder write SetOrder;

  end;

  TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialOrganismOrganismGeneralList;
    function GetCurrent : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialOrganismOrganismGeneralList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterialOrganismOrganismGeneral read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialOrganismOrganismGeneralList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceSourceMaterialOrganismOrganismGeneralList; Overload;
    function Clone : TFhirSubstanceSourceMaterialOrganismOrganismGeneralList; Overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator;
    

    //  Add a FhirSubstanceSourceMaterialOrganismOrganismGeneral to the end of the list.
    function Append : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;

    
    // Add an already existing FhirSubstanceSourceMaterialOrganismOrganismGeneral to the end of the list.
    procedure AddItem(value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral) : Integer;
    

    // Insert FhirSubstanceSourceMaterialOrganismOrganismGeneral before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
    

    // Insert an existing FhirSubstanceSourceMaterialOrganismOrganismGeneral before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
    
    // Get the iIndexth FhirSubstanceSourceMaterialOrganismOrganismGeneral. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceSourceMaterialOrganismOrganismGenerals[index : Integer] : TFhirSubstanceSourceMaterialOrganismOrganismGeneral read GetItemN write SetItemN; default;
  End;

  // To do.
  TFhirSubstanceSourceMaterialPartDescription = class (TFhirBackboneElement)
  protected
    FPart : TFhirCodeableConcept;
    FPartLocation : TFhirCodeableConcept;
    Procedure SetPart(value : TFhirCodeableConcept);
    Procedure SetPartLocation(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterialPartDescription; overload;
    function Clone : TFhirSubstanceSourceMaterialPartDescription; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Entity of anatomical origin of source material within an organism. (defined for API consistency)
    property part : TFhirCodeableConcept read FPart write SetPart;
    // Entity of anatomical origin of source material within an organism.
    property partElement : TFhirCodeableConcept read FPart write SetPart;

    // Typed access to The detailed anatomic location when the part can be extracted from different anatomical locations of the organism. Multiple alternative locations may apply. (defined for API consistency)
    property partLocation : TFhirCodeableConcept read FPartLocation write SetPartLocation;
    // The detailed anatomic location when the part can be extracted from different anatomical locations of the organism. Multiple alternative locations may apply.
    property partLocationElement : TFhirCodeableConcept read FPartLocation write SetPartLocation;

  end;

  TFhirSubstanceSourceMaterialPartDescriptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialPartDescriptionList;
    function GetCurrent : TFhirSubstanceSourceMaterialPartDescription;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialPartDescriptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterialPartDescription read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialPartDescriptionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterialPartDescription;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterialPartDescription);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceSourceMaterialPartDescriptionList; Overload;
    function Clone : TFhirSubstanceSourceMaterialPartDescriptionList; Overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialPartDescriptionListEnumerator;
    

    //  Add a FhirSubstanceSourceMaterialPartDescription to the end of the list.
    function Append : TFhirSubstanceSourceMaterialPartDescription;

    
    // Add an already existing FhirSubstanceSourceMaterialPartDescription to the end of the list.
    procedure AddItem(value : TFhirSubstanceSourceMaterialPartDescription); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterialPartDescription) : Integer;
    

    // Insert FhirSubstanceSourceMaterialPartDescription before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterialPartDescription;
    

    // Insert an existing FhirSubstanceSourceMaterialPartDescription before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterialPartDescription);
    
    // Get the iIndexth FhirSubstanceSourceMaterialPartDescription. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterialPartDescription);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterialPartDescription;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceSourceMaterialPartDescriptions[index : Integer] : TFhirSubstanceSourceMaterialPartDescription read GetItemN write SetItemN; default;
  End;

  // Source material shall capture information on the taxonomic and anatomical origins as well as the fraction of a material that can result in or can be modified to form a substance. This set of data elements shall be used to define polymer substances isolated from biological matrices. Taxonomic and anatomical origins shall be described using a controlled vocabulary as required. This information is captured for naturally derived polymers ( . starch) and structurally diverse substances. For Organisms belonging to the Kingdom Plantae the Substance level defines the fresh material of a single species or infraspecies, the Herbal Drug and the Herbal preparation. For Herbal preparations, the fraction information will be captured at the Substance information level and additional information for herbal extracts will be captured at the Specified Substance Group 1 information level. See for further explanation the Substance Class: Structurally Diverse and the herbal annex.
  TFhirSubstanceSourceMaterial = class (TFhirDomainResource)
  protected
    FSourceMaterialClass : TFhirCodeableConcept;
    FSourceMaterialType : TFhirCodeableConcept;
    FSourceMaterialState : TFhirCodeableConcept;
    FOrganismId : TFhirIdentifier;
    FOrganismName : TFhirString;
    FparentSubstanceIdList : TFhirIdentifierList;
    FparentSubstanceNameList : TFhirStringList;
    FcountryOfOriginList : TFhirCodeableConceptList;
    FgeographicalLocationList : TFhirStringList;
    FDevelopmentStage : TFhirCodeableConcept;
    FfractionDescriptionList : TFhirSubstanceSourceMaterialFractionDescriptionList;
    FOrganism : TFhirSubstanceSourceMaterialOrganism;
    FpartDescriptionList : TFhirSubstanceSourceMaterialPartDescriptionList;
    Procedure SetSourceMaterialClass(value : TFhirCodeableConcept);
    Procedure SetSourceMaterialType(value : TFhirCodeableConcept);
    Procedure SetSourceMaterialState(value : TFhirCodeableConcept);
    Procedure SetOrganismId(value : TFhirIdentifier);
    Procedure SetOrganismName(value : TFhirString);
    Function GetOrganismNameST : String;
    Procedure SetOrganismNameST(value : String);
    function GetParentSubstanceIdList : TFhirIdentifierList;
    function GetHasParentSubstanceIdList : Boolean;
    function GetParentSubstanceNameList : TFhirStringList;
    function GetHasParentSubstanceNameList : Boolean;
    function GetCountryOfOriginList : TFhirCodeableConceptList;
    function GetHasCountryOfOriginList : Boolean;
    function GetGeographicalLocationList : TFhirStringList;
    function GetHasGeographicalLocationList : Boolean;
    Procedure SetDevelopmentStage(value : TFhirCodeableConcept);
    function GetFractionDescriptionList : TFhirSubstanceSourceMaterialFractionDescriptionList;
    function GetHasFractionDescriptionList : Boolean;
    Procedure SetOrganism(value : TFhirSubstanceSourceMaterialOrganism);
    function GetPartDescriptionList : TFhirSubstanceSourceMaterialPartDescriptionList;
    function GetHasPartDescriptionList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSourceMaterial; overload;
    function Clone : TFhirSubstanceSourceMaterial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to General high level classification of the source material specific to the origin of the material. (defined for API consistency)
    property sourceMaterialClass : TFhirCodeableConcept read FSourceMaterialClass write SetSourceMaterialClass;
    // General high level classification of the source material specific to the origin of the material.
    property sourceMaterialClassElement : TFhirCodeableConcept read FSourceMaterialClass write SetSourceMaterialClass;

    // Typed access to The type of the source material shall be specified based on a controlled vocabulary. For vaccines, this subclause refers to the class of infectious agent. (defined for API consistency)
    property sourceMaterialType : TFhirCodeableConcept read FSourceMaterialType write SetSourceMaterialType;
    // The type of the source material shall be specified based on a controlled vocabulary. For vaccines, this subclause refers to the class of infectious agent.
    property sourceMaterialTypeElement : TFhirCodeableConcept read FSourceMaterialType write SetSourceMaterialType;

    // Typed access to The state of the source material when extracted. (defined for API consistency)
    property sourceMaterialState : TFhirCodeableConcept read FSourceMaterialState write SetSourceMaterialState;
    // The state of the source material when extracted.
    property sourceMaterialStateElement : TFhirCodeableConcept read FSourceMaterialState write SetSourceMaterialState;

    // Typed access to The unique identifier associated with the source material parent organism shall be specified. (defined for API consistency)
    property organismId : TFhirIdentifier read FOrganismId write SetOrganismId;
    // The unique identifier associated with the source material parent organism shall be specified.
    property organismIdElement : TFhirIdentifier read FOrganismId write SetOrganismId;

    // Typed access to The organism accepted Scientific name shall be provided based on the organism taxonomy.
    property organismName : String read GetOrganismNameST write SetOrganismNameST;
    // The organism accepted Scientific name shall be provided based on the organism taxonomy.
    property organismNameElement : TFhirString read FOrganismName write SetOrganismName;

    // The parent of the herbal drug Ginkgo biloba, Leaf is the substance ID of the substance (fresh) of Ginkgo biloba L. or Ginkgo biloba L. (Whole plant).
    property parentSubstanceIdList : TFhirIdentifierList read GetParentSubstanceIdList;
    property hasParentSubstanceIdList : boolean read GetHasParentSubstanceIdList;

    // The parent substance of the Herbal Drug, or Herbal preparation.
    property parentSubstanceNameList : TFhirStringList read GetParentSubstanceNameList;
    property hasParentSubstanceNameList : boolean read GetHasParentSubstanceNameList;

    // The country where the plant material is harvested or the countries where the plasma is sourced from as laid down in accordance with the Plasma Master File. For ?Plasma-derived substances? the attribute country of origin provides information about the countries used for the manufacturing of the Cryopoor plama or Crioprecipitate.
    property countryOfOriginList : TFhirCodeableConceptList read GetCountryOfOriginList;
    property hasCountryOfOriginList : boolean read GetHasCountryOfOriginList;

    // The place/region where the plant is harvested or the places/regions where the animal source material has its habitat.
    property geographicalLocationList : TFhirStringList read GetGeographicalLocationList;
    property hasGeographicalLocationList : boolean read GetHasGeographicalLocationList;

    // Typed access to Stage of life for animals, plants, insects and microorganisms. This information shall be provided only when the substance is significantly different in these stages (e.g. foetal bovine serum). (defined for API consistency)
    property developmentStage : TFhirCodeableConcept read FDevelopmentStage write SetDevelopmentStage;
    // Stage of life for animals, plants, insects and microorganisms. This information shall be provided only when the substance is significantly different in these stages (e.g. foetal bovine serum).
    property developmentStageElement : TFhirCodeableConcept read FDevelopmentStage write SetDevelopmentStage;

    // Many complex materials are fractions of parts of plants, animals, or minerals. Fraction elements are often necessary to define both Substances and Specified Group 1 Substances. For substances derived from Plants, fraction information will be captured at the Substance information level ( . Oils, Juices and Exudates). Additional information for Extracts, such as extraction solvent composition, will be captured at the Specified Substance Group 1 information level. For plasma-derived products fraction information will be captured at the Substance and the Specified Substance Group 1 levels.
    property fractionDescriptionList : TFhirSubstanceSourceMaterialFractionDescriptionList read GetFractionDescriptionList;
    property hasFractionDescriptionList : boolean read GetHasFractionDescriptionList;

    // Typed access to This subclause describes the organism which the substance is derived from. For vaccines, the parent organism shall be specified based on these subclause elements. As an example, full taxonomy will be described for the Substance Name: ., Leaf. (defined for API consistency)
    property organism : TFhirSubstanceSourceMaterialOrganism read FOrganism write SetOrganism;
    // This subclause describes the organism which the substance is derived from. For vaccines, the parent organism shall be specified based on these subclause elements. As an example, full taxonomy will be described for the Substance Name: ., Leaf.
    property organismElement : TFhirSubstanceSourceMaterialOrganism read FOrganism write SetOrganism;

    // To do.
    property partDescriptionList : TFhirSubstanceSourceMaterialPartDescriptionList read GetPartDescriptionList;
    property hasPartDescriptionList : boolean read GetHasPartDescriptionList;

  end;

  TFhirSubstanceSourceMaterialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSourceMaterialList;
    function GetCurrent : TFhirSubstanceSourceMaterial;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSourceMaterialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSourceMaterial read GetCurrent;
  end;

  TFhirSubstanceSourceMaterialList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceSourceMaterial;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSourceMaterial);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceSourceMaterialList; Overload;
    function Clone : TFhirSubstanceSourceMaterialList; Overload;
    function GetEnumerator : TFhirSubstanceSourceMaterialListEnumerator;
    

    //  Add a FhirSubstanceSourceMaterial to the end of the list.
    function Append : TFhirSubstanceSourceMaterial;

    
    // Add an already existing FhirSubstanceSourceMaterial to the end of the list.
    procedure AddItem(value : TFhirSubstanceSourceMaterial); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSourceMaterial) : Integer;
    

    // Insert FhirSubstanceSourceMaterial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSourceMaterial;
    

    // Insert an existing FhirSubstanceSourceMaterial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSourceMaterial);
    
    // Get the iIndexth FhirSubstanceSourceMaterial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSourceMaterial);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSourceMaterial;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceSourceMaterials[index : Integer] : TFhirSubstanceSourceMaterial read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}

{$IFDEF FHIR_SUBSTANCESPECIFICATION}

  // Moiety, for structural modifications.
  TFhirSubstanceSpecificationMoiety = class (TFhirBackboneElement)
  protected
    FRole : TFhirCodeableConcept;
    FIdentifier : TFhirIdentifier;
    FName : TFhirString;
    FStereochemistry : TFhirCodeableConcept;
    FOpticalActivity : TFhirCodeableConcept;
    FMolecularFormula : TFhirString;
    FAmount : TFhirType;
    Procedure SetRole(value : TFhirCodeableConcept);
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetStereochemistry(value : TFhirCodeableConcept);
    Procedure SetOpticalActivity(value : TFhirCodeableConcept);
    Procedure SetMolecularFormula(value : TFhirString);
    Function GetMolecularFormulaST : String;
    Procedure SetMolecularFormulaST(value : String);
    Procedure SetAmount(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSpecificationMoiety; overload;
    function Clone : TFhirSubstanceSpecificationMoiety; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Role that the moiety is playing. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Role that the moiety is playing.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to Identifier by which this moiety substance is known. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier by which this moiety substance is known.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Textual name for this moiety substance.
    property name : String read GetNameST write SetNameST;
    // Textual name for this moiety substance.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Stereochemistry type. (defined for API consistency)
    property stereochemistry : TFhirCodeableConcept read FStereochemistry write SetStereochemistry;
    // Stereochemistry type.
    property stereochemistryElement : TFhirCodeableConcept read FStereochemistry write SetStereochemistry;

    // Typed access to Optical activity type. (defined for API consistency)
    property opticalActivity : TFhirCodeableConcept read FOpticalActivity write SetOpticalActivity;
    // Optical activity type.
    property opticalActivityElement : TFhirCodeableConcept read FOpticalActivity write SetOpticalActivity;

    // Typed access to Molecular formula.
    property molecularFormula : String read GetMolecularFormulaST write SetMolecularFormulaST;
    // Molecular formula.
    property molecularFormulaElement : TFhirString read FMolecularFormula write SetMolecularFormula;

    // Typed access to Quantitative value for this moiety. (defined for API consistency)
    property amount : TFhirType read FAmount write SetAmount;
    // Quantitative value for this moiety.
    property amountElement : TFhirType read FAmount write SetAmount;

  end;

  TFhirSubstanceSpecificationMoietyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSpecificationMoietyList;
    function GetCurrent : TFhirSubstanceSpecificationMoiety;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSpecificationMoietyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSpecificationMoiety read GetCurrent;
  end;

  TFhirSubstanceSpecificationMoietyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceSpecificationMoiety;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSpecificationMoiety);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceSpecificationMoietyList; Overload;
    function Clone : TFhirSubstanceSpecificationMoietyList; Overload;
    function GetEnumerator : TFhirSubstanceSpecificationMoietyListEnumerator;
    

    //  Add a FhirSubstanceSpecificationMoiety to the end of the list.
    function Append : TFhirSubstanceSpecificationMoiety;

    
    // Add an already existing FhirSubstanceSpecificationMoiety to the end of the list.
    procedure AddItem(value : TFhirSubstanceSpecificationMoiety); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSpecificationMoiety) : Integer;
    

    // Insert FhirSubstanceSpecificationMoiety before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSpecificationMoiety;
    

    // Insert an existing FhirSubstanceSpecificationMoiety before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSpecificationMoiety);
    
    // Get the iIndexth FhirSubstanceSpecificationMoiety. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSpecificationMoiety);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSpecificationMoiety;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceSpecificationMoieties[index : Integer] : TFhirSubstanceSpecificationMoiety read GetItemN write SetItemN; default;
  End;

  // General specifications for this substance, including how it is related to other substances.
  TFhirSubstanceSpecificationProperty = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FParameters : TFhirString;
    FDefiningSubstance : TFhirType;
    FAmount : TFhirType;
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetParameters(value : TFhirString);
    Function GetParametersST : String;
    Procedure SetParametersST(value : String);
    Procedure SetDefiningSubstance(value : TFhirType);
    Procedure SetAmount(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSpecificationProperty; overload;
    function Clone : TFhirSubstanceSpecificationProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A category for this property, e.g. Physical, Chemical, Enzymatic. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A category for this property, e.g. Physical, Chemical, Enzymatic.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Property type e.g. viscosity, pH, isoelectric point. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Property type e.g. viscosity, pH, isoelectric point.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Parameters that were used in the measurement of a property (e.g. for viscosity: measured at 20C with a pH of 7.1).
    property parameters : String read GetParametersST write SetParametersST;
    // Parameters that were used in the measurement of a property (e.g. for viscosity: measured at 20C with a pH of 7.1).
    property parametersElement : TFhirString read FParameters write SetParameters;

    // Typed access to A substance upon which a defining property depends (e.g. for solubility: in water, in alcohol). (defined for API consistency)
    property definingSubstance : TFhirType read FDefiningSubstance write SetDefiningSubstance;
    // A substance upon which a defining property depends (e.g. for solubility: in water, in alcohol).
    property definingSubstanceElement : TFhirType read FDefiningSubstance write SetDefiningSubstance;

    // Typed access to Quantitative value for this property. (defined for API consistency)
    property amount : TFhirType read FAmount write SetAmount;
    // Quantitative value for this property.
    property amountElement : TFhirType read FAmount write SetAmount;

  end;

  TFhirSubstanceSpecificationPropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSpecificationPropertyList;
    function GetCurrent : TFhirSubstanceSpecificationProperty;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSpecificationPropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSpecificationProperty read GetCurrent;
  end;

  TFhirSubstanceSpecificationPropertyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceSpecificationProperty;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSpecificationProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceSpecificationPropertyList; Overload;
    function Clone : TFhirSubstanceSpecificationPropertyList; Overload;
    function GetEnumerator : TFhirSubstanceSpecificationPropertyListEnumerator;
    

    //  Add a FhirSubstanceSpecificationProperty to the end of the list.
    function Append : TFhirSubstanceSpecificationProperty;

    
    // Add an already existing FhirSubstanceSpecificationProperty to the end of the list.
    procedure AddItem(value : TFhirSubstanceSpecificationProperty); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSpecificationProperty) : Integer;
    

    // Insert FhirSubstanceSpecificationProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSpecificationProperty;
    

    // Insert an existing FhirSubstanceSpecificationProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSpecificationProperty);
    
    // Get the iIndexth FhirSubstanceSpecificationProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSpecificationProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSpecificationProperty;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceSpecificationProperties[index : Integer] : TFhirSubstanceSpecificationProperty read GetItemN write SetItemN; default;
  End;

  // Structural information.
  TFhirSubstanceSpecificationStructure = class (TFhirBackboneElement)
  protected
    FStereochemistry : TFhirCodeableConcept;
    FOpticalActivity : TFhirCodeableConcept;
    FMolecularFormula : TFhirString;
    FMolecularFormulaByMoiety : TFhirString;
    FisotopeList : TFhirSubstanceSpecificationStructureIsotopeList;
    FMolecularWeight : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight;
    FsourceList : TFhirReferenceList{TFhirDocumentReference};
    FrepresentationList : TFhirSubstanceSpecificationStructureRepresentationList;
    Procedure SetStereochemistry(value : TFhirCodeableConcept);
    Procedure SetOpticalActivity(value : TFhirCodeableConcept);
    Procedure SetMolecularFormula(value : TFhirString);
    Function GetMolecularFormulaST : String;
    Procedure SetMolecularFormulaST(value : String);
    Procedure SetMolecularFormulaByMoiety(value : TFhirString);
    Function GetMolecularFormulaByMoietyST : String;
    Procedure SetMolecularFormulaByMoietyST(value : String);
    function GetIsotopeList : TFhirSubstanceSpecificationStructureIsotopeList;
    function GetHasIsotopeList : Boolean;
    Procedure SetMolecularWeight(value : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight);
    function GetSourceList : TFhirReferenceList{TFhirDocumentReference};
    function GetHasSourceList : Boolean;
    function GetRepresentationList : TFhirSubstanceSpecificationStructureRepresentationList;
    function GetHasRepresentationList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSpecificationStructure; overload;
    function Clone : TFhirSubstanceSpecificationStructure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Stereochemistry type. (defined for API consistency)
    property stereochemistry : TFhirCodeableConcept read FStereochemistry write SetStereochemistry;
    // Stereochemistry type.
    property stereochemistryElement : TFhirCodeableConcept read FStereochemistry write SetStereochemistry;

    // Typed access to Optical activity type. (defined for API consistency)
    property opticalActivity : TFhirCodeableConcept read FOpticalActivity write SetOpticalActivity;
    // Optical activity type.
    property opticalActivityElement : TFhirCodeableConcept read FOpticalActivity write SetOpticalActivity;

    // Typed access to Molecular formula.
    property molecularFormula : String read GetMolecularFormulaST write SetMolecularFormulaST;
    // Molecular formula.
    property molecularFormulaElement : TFhirString read FMolecularFormula write SetMolecularFormula;

    // Typed access to Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.
    property molecularFormulaByMoiety : String read GetMolecularFormulaByMoietyST write SetMolecularFormulaByMoietyST;
    // Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.
    property molecularFormulaByMoietyElement : TFhirString read FMolecularFormulaByMoiety write SetMolecularFormulaByMoiety;

    // Applicable for single substances that contain a radionuclide or a non-natural isotopic ratio.
    property isotopeList : TFhirSubstanceSpecificationStructureIsotopeList read GetIsotopeList;
    property hasIsotopeList : boolean read GetHasIsotopeList;

    // Typed access to The molecular weight or weight range (for proteins, polymers or nucleic acids). (defined for API consistency)
    property molecularWeight : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight read FMolecularWeight write SetMolecularWeight;
    // The molecular weight or weight range (for proteins, polymers or nucleic acids).
    property molecularWeightElement : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight read FMolecularWeight write SetMolecularWeight;

    // Supporting literature.
    property sourceList : TFhirReferenceList{TFhirDocumentReference} read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

    // Molecular structural representation.
    property representationList : TFhirSubstanceSpecificationStructureRepresentationList read GetRepresentationList;
    property hasRepresentationList : boolean read GetHasRepresentationList;

  end;

  TFhirSubstanceSpecificationStructureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSpecificationStructureList;
    function GetCurrent : TFhirSubstanceSpecificationStructure;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSpecificationStructureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSpecificationStructure read GetCurrent;
  end;

  TFhirSubstanceSpecificationStructureList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceSpecificationStructure;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSpecificationStructure);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceSpecificationStructureList; Overload;
    function Clone : TFhirSubstanceSpecificationStructureList; Overload;
    function GetEnumerator : TFhirSubstanceSpecificationStructureListEnumerator;
    

    //  Add a FhirSubstanceSpecificationStructure to the end of the list.
    function Append : TFhirSubstanceSpecificationStructure;

    
    // Add an already existing FhirSubstanceSpecificationStructure to the end of the list.
    procedure AddItem(value : TFhirSubstanceSpecificationStructure); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSpecificationStructure) : Integer;
    

    // Insert FhirSubstanceSpecificationStructure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSpecificationStructure;
    

    // Insert an existing FhirSubstanceSpecificationStructure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSpecificationStructure);
    
    // Get the iIndexth FhirSubstanceSpecificationStructure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSpecificationStructure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSpecificationStructure;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceSpecificationStructures[index : Integer] : TFhirSubstanceSpecificationStructure read GetItemN write SetItemN; default;
  End;

  // Applicable for single substances that contain a radionuclide or a non-natural isotopic ratio.
  TFhirSubstanceSpecificationStructureIsotope = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FName : TFhirCodeableConcept;
    FSubstitution : TFhirCodeableConcept;
    FHalfLife : TFhirQuantity;
    FMolecularWeight : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetName(value : TFhirCodeableConcept);
    Procedure SetSubstitution(value : TFhirCodeableConcept);
    Procedure SetHalfLife(value : TFhirQuantity);
    Procedure SetMolecularWeight(value : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSpecificationStructureIsotope; overload;
    function Clone : TFhirSubstanceSpecificationStructureIsotope; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Substance identifier for each non-natural or radioisotope. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Substance identifier for each non-natural or radioisotope.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Substance name for each non-natural or radioisotope. (defined for API consistency)
    property name : TFhirCodeableConcept read FName write SetName;
    // Substance name for each non-natural or radioisotope.
    property nameElement : TFhirCodeableConcept read FName write SetName;

    // Typed access to The type of isotopic substitution present in a single substance. (defined for API consistency)
    property substitution : TFhirCodeableConcept read FSubstitution write SetSubstitution;
    // The type of isotopic substitution present in a single substance.
    property substitutionElement : TFhirCodeableConcept read FSubstitution write SetSubstitution;

    // Typed access to Half life - for a non-natural nuclide. (defined for API consistency)
    property halfLife : TFhirQuantity read FHalfLife write SetHalfLife;
    // Half life - for a non-natural nuclide.
    property halfLifeElement : TFhirQuantity read FHalfLife write SetHalfLife;

    // Typed access to The molecular weight or weight range (for proteins, polymers or nucleic acids). (defined for API consistency)
    property molecularWeight : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight read FMolecularWeight write SetMolecularWeight;
    // The molecular weight or weight range (for proteins, polymers or nucleic acids).
    property molecularWeightElement : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight read FMolecularWeight write SetMolecularWeight;

  end;

  TFhirSubstanceSpecificationStructureIsotopeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSpecificationStructureIsotopeList;
    function GetCurrent : TFhirSubstanceSpecificationStructureIsotope;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSpecificationStructureIsotopeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSpecificationStructureIsotope read GetCurrent;
  end;

  TFhirSubstanceSpecificationStructureIsotopeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceSpecificationStructureIsotope;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSpecificationStructureIsotope);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceSpecificationStructureIsotopeList; Overload;
    function Clone : TFhirSubstanceSpecificationStructureIsotopeList; Overload;
    function GetEnumerator : TFhirSubstanceSpecificationStructureIsotopeListEnumerator;
    

    //  Add a FhirSubstanceSpecificationStructureIsotope to the end of the list.
    function Append : TFhirSubstanceSpecificationStructureIsotope;

    
    // Add an already existing FhirSubstanceSpecificationStructureIsotope to the end of the list.
    procedure AddItem(value : TFhirSubstanceSpecificationStructureIsotope); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSpecificationStructureIsotope) : Integer;
    

    // Insert FhirSubstanceSpecificationStructureIsotope before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSpecificationStructureIsotope;
    

    // Insert an existing FhirSubstanceSpecificationStructureIsotope before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSpecificationStructureIsotope);
    
    // Get the iIndexth FhirSubstanceSpecificationStructureIsotope. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSpecificationStructureIsotope);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSpecificationStructureIsotope;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceSpecificationStructureIsotopes[index : Integer] : TFhirSubstanceSpecificationStructureIsotope read GetItemN write SetItemN; default;
  End;

  // The molecular weight or weight range (for proteins, polymers or nucleic acids).
  TFhirSubstanceSpecificationStructureIsotopeMolecularWeight = class (TFhirBackboneElement)
  protected
    FMethod : TFhirCodeableConcept;
    FType_ : TFhirCodeableConcept;
    FAmount : TFhirQuantity;
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetAmount(value : TFhirQuantity);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight; overload;
    function Clone : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The method by which the molecular weight was determined. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // The method by which the molecular weight was determined.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to Type of molecular weight such as exact, average (also known as. number average), weight average. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of molecular weight such as exact, average (also known as. number average), weight average.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

  end;

  TFhirSubstanceSpecificationStructureIsotopeMolecularWeightListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList;
    function GetCurrent : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight read GetCurrent;
  end;

  TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList; Overload;
    function Clone : TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList; Overload;
    function GetEnumerator : TFhirSubstanceSpecificationStructureIsotopeMolecularWeightListEnumerator;
    

    //  Add a FhirSubstanceSpecificationStructureIsotopeMolecularWeight to the end of the list.
    function Append : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight;

    
    // Add an already existing FhirSubstanceSpecificationStructureIsotopeMolecularWeight to the end of the list.
    procedure AddItem(value : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight) : Integer;
    

    // Insert FhirSubstanceSpecificationStructureIsotopeMolecularWeight before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight;
    

    // Insert an existing FhirSubstanceSpecificationStructureIsotopeMolecularWeight before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight);
    
    // Get the iIndexth FhirSubstanceSpecificationStructureIsotopeMolecularWeight. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceSpecificationStructureIsotopeMolecularWeights[index : Integer] : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight read GetItemN write SetItemN; default;
  End;

  // Molecular structural representation.
  TFhirSubstanceSpecificationStructureRepresentation = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FRepresentation : TFhirString;
    FAttachment : TFhirAttachment;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetRepresentation(value : TFhirString);
    Function GetRepresentationST : String;
    Procedure SetRepresentationST(value : String);
    Procedure SetAttachment(value : TFhirAttachment);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSpecificationStructureRepresentation; overload;
    function Clone : TFhirSubstanceSpecificationStructureRepresentation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The type of structure (e.g. Full, Partial, Representative). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of structure (e.g. Full, Partial, Representative).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The structural representation as text string in a format e.g. InChI, SMILES, MOLFILE, CDX.
    property representation : String read GetRepresentationST write SetRepresentationST;
    // The structural representation as text string in a format e.g. InChI, SMILES, MOLFILE, CDX.
    property representationElement : TFhirString read FRepresentation write SetRepresentation;

    // Typed access to An attached file with the structural representation. (defined for API consistency)
    property attachment : TFhirAttachment read FAttachment write SetAttachment;
    // An attached file with the structural representation.
    property attachmentElement : TFhirAttachment read FAttachment write SetAttachment;

  end;

  TFhirSubstanceSpecificationStructureRepresentationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSpecificationStructureRepresentationList;
    function GetCurrent : TFhirSubstanceSpecificationStructureRepresentation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSpecificationStructureRepresentationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSpecificationStructureRepresentation read GetCurrent;
  end;

  TFhirSubstanceSpecificationStructureRepresentationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceSpecificationStructureRepresentation;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSpecificationStructureRepresentation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceSpecificationStructureRepresentationList; Overload;
    function Clone : TFhirSubstanceSpecificationStructureRepresentationList; Overload;
    function GetEnumerator : TFhirSubstanceSpecificationStructureRepresentationListEnumerator;
    

    //  Add a FhirSubstanceSpecificationStructureRepresentation to the end of the list.
    function Append : TFhirSubstanceSpecificationStructureRepresentation;

    
    // Add an already existing FhirSubstanceSpecificationStructureRepresentation to the end of the list.
    procedure AddItem(value : TFhirSubstanceSpecificationStructureRepresentation); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSpecificationStructureRepresentation) : Integer;
    

    // Insert FhirSubstanceSpecificationStructureRepresentation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSpecificationStructureRepresentation;
    

    // Insert an existing FhirSubstanceSpecificationStructureRepresentation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSpecificationStructureRepresentation);
    
    // Get the iIndexth FhirSubstanceSpecificationStructureRepresentation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSpecificationStructureRepresentation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSpecificationStructureRepresentation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceSpecificationStructureRepresentations[index : Integer] : TFhirSubstanceSpecificationStructureRepresentation read GetItemN write SetItemN; default;
  End;

  // Codes associated with the substance.
  TFhirSubstanceSpecificationCode = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FStatus : TFhirCodeableConcept;
    FStatusDate : TFhirDateTime;
    FComment : TFhirString;
    FsourceList : TFhirReferenceList{TFhirDocumentReference};
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetStatus(value : TFhirCodeableConcept);
    Procedure SetStatusDate(value : TFhirDateTime);
    Function GetStatusDateST : TFslDateTime;
    Procedure SetStatusDateST(value : TFslDateTime);
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);
    function GetSourceList : TFhirReferenceList{TFhirDocumentReference};
    function GetHasSourceList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSpecificationCode; overload;
    function Clone : TFhirSubstanceSpecificationCode; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The specific code. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The specific code.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Status of the code assignment. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // Status of the code assignment.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to The date at which the code status is changed as part of the terminology maintenance.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // The date at which the code status is changed as part of the terminology maintenance.
    property statusDateElement : TFhirDateTime read FStatusDate write SetStatusDate;

    // Typed access to Any comment can be provided in this field, if necessary.
    property comment : String read GetCommentST write SetCommentST;
    // Any comment can be provided in this field, if necessary.
    property commentElement : TFhirString read FComment write SetComment;

    // Supporting literature.
    property sourceList : TFhirReferenceList{TFhirDocumentReference} read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceSpecificationCodeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSpecificationCodeList;
    function GetCurrent : TFhirSubstanceSpecificationCode;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSpecificationCodeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSpecificationCode read GetCurrent;
  end;

  TFhirSubstanceSpecificationCodeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceSpecificationCode;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSpecificationCode);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceSpecificationCodeList; Overload;
    function Clone : TFhirSubstanceSpecificationCodeList; Overload;
    function GetEnumerator : TFhirSubstanceSpecificationCodeListEnumerator;
    

    //  Add a FhirSubstanceSpecificationCode to the end of the list.
    function Append : TFhirSubstanceSpecificationCode;

    
    // Add an already existing FhirSubstanceSpecificationCode to the end of the list.
    procedure AddItem(value : TFhirSubstanceSpecificationCode); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSpecificationCode) : Integer;
    

    // Insert FhirSubstanceSpecificationCode before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSpecificationCode;
    

    // Insert an existing FhirSubstanceSpecificationCode before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSpecificationCode);
    
    // Get the iIndexth FhirSubstanceSpecificationCode. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSpecificationCode);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSpecificationCode;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceSpecificationCodes[index : Integer] : TFhirSubstanceSpecificationCode read GetItemN write SetItemN; default;
  End;

  // Names applicable to this substance.
  TFhirSubstanceSpecificationName = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FType_ : TFhirCodeableConcept;
    FStatus : TFhirCodeableConcept;
    FPreferred : TFhirBoolean;
    FlanguageList : TFhirCodeableConceptList;
    FdomainList : TFhirCodeableConceptList;
    FjurisdictionList : TFhirCodeableConceptList;
    FsynonymList : TFhirSubstanceSpecificationNameList;
    FtranslationList : TFhirSubstanceSpecificationNameList;
    FofficialList : TFhirSubstanceSpecificationNameOfficialList;
    FsourceList : TFhirReferenceList{TFhirDocumentReference};
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetStatus(value : TFhirCodeableConcept);
    Procedure SetPreferred(value : TFhirBoolean);
    Function GetPreferredST : Boolean;
    Procedure SetPreferredST(value : Boolean);
    function GetLanguageList : TFhirCodeableConceptList;
    function GetHasLanguageList : Boolean;
    function GetDomainList : TFhirCodeableConceptList;
    function GetHasDomainList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    function GetSynonymList : TFhirSubstanceSpecificationNameList;
    function GetHasSynonymList : Boolean;
    function GetTranslationList : TFhirSubstanceSpecificationNameList;
    function GetHasTranslationList : Boolean;
    function GetOfficialList : TFhirSubstanceSpecificationNameOfficialList;
    function GetHasOfficialList : Boolean;
    function GetSourceList : TFhirReferenceList{TFhirDocumentReference};
    function GetHasSourceList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSpecificationName; overload;
    function Clone : TFhirSubstanceSpecificationName; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The actual name.
    property name : String read GetNameST write SetNameST;
    // The actual name.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Name type. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Name type.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The status of the name. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status of the name.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to If this is the preferred name for this substance.
    property preferred : Boolean read GetPreferredST write SetPreferredST;
    // If this is the preferred name for this substance.
    property preferredElement : TFhirBoolean read FPreferred write SetPreferred;

    // Language of the name.
    property languageList : TFhirCodeableConceptList read GetLanguageList;
    property hasLanguageList : boolean read GetHasLanguageList;

    // The use context of this name for example if there is a different name a drug active ingredient as opposed to a food colour additive.
    property domainList : TFhirCodeableConceptList read GetDomainList;
    property hasDomainList : boolean read GetHasDomainList;

    // The jurisdiction where this name applies.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // A synonym of this name.
    property synonymList : TFhirSubstanceSpecificationNameList read GetSynonymList;
    property hasSynonymList : boolean read GetHasSynonymList;

    // A translation for this name.
    property translationList : TFhirSubstanceSpecificationNameList read GetTranslationList;
    property hasTranslationList : boolean read GetHasTranslationList;

    // Details of the official nature of this name.
    property officialList : TFhirSubstanceSpecificationNameOfficialList read GetOfficialList;
    property hasOfficialList : boolean read GetHasOfficialList;

    // Supporting literature.
    property sourceList : TFhirReferenceList{TFhirDocumentReference} read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceSpecificationNameListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSpecificationNameList;
    function GetCurrent : TFhirSubstanceSpecificationName;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSpecificationNameList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSpecificationName read GetCurrent;
  end;

  TFhirSubstanceSpecificationNameList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceSpecificationName;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSpecificationName);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceSpecificationNameList; Overload;
    function Clone : TFhirSubstanceSpecificationNameList; Overload;
    function GetEnumerator : TFhirSubstanceSpecificationNameListEnumerator;
    

    //  Add a FhirSubstanceSpecificationName to the end of the list.
    function Append : TFhirSubstanceSpecificationName;

    
    // Add an already existing FhirSubstanceSpecificationName to the end of the list.
    procedure AddItem(value : TFhirSubstanceSpecificationName); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSpecificationName) : Integer;
    

    // Insert FhirSubstanceSpecificationName before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSpecificationName;
    

    // Insert an existing FhirSubstanceSpecificationName before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSpecificationName);
    
    // Get the iIndexth FhirSubstanceSpecificationName. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSpecificationName);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSpecificationName;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceSpecificationNames[index : Integer] : TFhirSubstanceSpecificationName read GetItemN write SetItemN; default;
  End;

  // Details of the official nature of this name.
  TFhirSubstanceSpecificationNameOfficial = class (TFhirBackboneElement)
  protected
    FAuthority : TFhirCodeableConcept;
    FStatus : TFhirCodeableConcept;
    FDate : TFhirDateTime;
    Procedure SetAuthority(value : TFhirCodeableConcept);
    Procedure SetStatus(value : TFhirCodeableConcept);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSpecificationNameOfficial; overload;
    function Clone : TFhirSubstanceSpecificationNameOfficial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Which authority uses this official name. (defined for API consistency)
    property authority : TFhirCodeableConcept read FAuthority write SetAuthority;
    // Which authority uses this official name.
    property authorityElement : TFhirCodeableConcept read FAuthority write SetAuthority;

    // Typed access to The status of the official name. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status of the official name.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to Date of official name change.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date of official name change.
    property dateElement : TFhirDateTime read FDate write SetDate;

  end;

  TFhirSubstanceSpecificationNameOfficialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSpecificationNameOfficialList;
    function GetCurrent : TFhirSubstanceSpecificationNameOfficial;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSpecificationNameOfficialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSpecificationNameOfficial read GetCurrent;
  end;

  TFhirSubstanceSpecificationNameOfficialList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceSpecificationNameOfficial;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSpecificationNameOfficial);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceSpecificationNameOfficialList; Overload;
    function Clone : TFhirSubstanceSpecificationNameOfficialList; Overload;
    function GetEnumerator : TFhirSubstanceSpecificationNameOfficialListEnumerator;
    

    //  Add a FhirSubstanceSpecificationNameOfficial to the end of the list.
    function Append : TFhirSubstanceSpecificationNameOfficial;

    
    // Add an already existing FhirSubstanceSpecificationNameOfficial to the end of the list.
    procedure AddItem(value : TFhirSubstanceSpecificationNameOfficial); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSpecificationNameOfficial) : Integer;
    

    // Insert FhirSubstanceSpecificationNameOfficial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSpecificationNameOfficial;
    

    // Insert an existing FhirSubstanceSpecificationNameOfficial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSpecificationNameOfficial);
    
    // Get the iIndexth FhirSubstanceSpecificationNameOfficial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSpecificationNameOfficial);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSpecificationNameOfficial;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceSpecificationNameOfficials[index : Integer] : TFhirSubstanceSpecificationNameOfficial read GetItemN write SetItemN; default;
  End;

  // A link between this substance and another, with details of the relationship.
  TFhirSubstanceSpecificationRelationship = class (TFhirBackboneElement)
  protected
    FSubstance : TFhirType;
    FRelationship : TFhirCodeableConcept;
    FIsDefining : TFhirBoolean;
    FAmount : TFhirType;
    FAmountRatioLowLimit : TFhirRatio;
    FAmountType : TFhirCodeableConcept;
    FsourceList : TFhirReferenceList{TFhirDocumentReference};
    Procedure SetSubstance(value : TFhirType);
    Procedure SetRelationship(value : TFhirCodeableConcept);
    Procedure SetIsDefining(value : TFhirBoolean);
    Function GetIsDefiningST : Boolean;
    Procedure SetIsDefiningST(value : Boolean);
    Procedure SetAmount(value : TFhirType);
    Procedure SetAmountRatioLowLimit(value : TFhirRatio);
    Procedure SetAmountType(value : TFhirCodeableConcept);
    function GetSourceList : TFhirReferenceList{TFhirDocumentReference};
    function GetHasSourceList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSpecificationRelationship; overload;
    function Clone : TFhirSubstanceSpecificationRelationship; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A pointer to another substance, as a resource or just a representational code. (defined for API consistency)
    property substance : TFhirType read FSubstance write SetSubstance;
    // A pointer to another substance, as a resource or just a representational code.
    property substanceElement : TFhirType read FSubstance write SetSubstance;

    // Typed access to For example "salt to parent", "active moiety", "starting material". (defined for API consistency)
    property relationship : TFhirCodeableConcept read FRelationship write SetRelationship;
    // For example "salt to parent", "active moiety", "starting material".
    property relationshipElement : TFhirCodeableConcept read FRelationship write SetRelationship;

    // Typed access to For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.
    property isDefining : Boolean read GetIsDefiningST write SetIsDefiningST;
    // For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.
    property isDefiningElement : TFhirBoolean read FIsDefining write SetIsDefining;

    // Typed access to A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other. (defined for API consistency)
    property amount : TFhirType read FAmount write SetAmount;
    // A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
    property amountElement : TFhirType read FAmount write SetAmount;

    // Typed access to For use when the numeric. (defined for API consistency)
    property amountRatioLowLimit : TFhirRatio read FAmountRatioLowLimit write SetAmountRatioLowLimit;
    // For use when the numeric.
    property amountRatioLowLimitElement : TFhirRatio read FAmountRatioLowLimit write SetAmountRatioLowLimit;

    // Typed access to An operator for the amount, for example "average", "approximately", "less than". (defined for API consistency)
    property amountType : TFhirCodeableConcept read FAmountType write SetAmountType;
    // An operator for the amount, for example "average", "approximately", "less than".
    property amountTypeElement : TFhirCodeableConcept read FAmountType write SetAmountType;

    // Supporting literature.
    property sourceList : TFhirReferenceList{TFhirDocumentReference} read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceSpecificationRelationshipListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSpecificationRelationshipList;
    function GetCurrent : TFhirSubstanceSpecificationRelationship;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSpecificationRelationshipList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSpecificationRelationship read GetCurrent;
  end;

  TFhirSubstanceSpecificationRelationshipList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceSpecificationRelationship;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSpecificationRelationship);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceSpecificationRelationshipList; Overload;
    function Clone : TFhirSubstanceSpecificationRelationshipList; Overload;
    function GetEnumerator : TFhirSubstanceSpecificationRelationshipListEnumerator;
    

    //  Add a FhirSubstanceSpecificationRelationship to the end of the list.
    function Append : TFhirSubstanceSpecificationRelationship;

    
    // Add an already existing FhirSubstanceSpecificationRelationship to the end of the list.
    procedure AddItem(value : TFhirSubstanceSpecificationRelationship); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSpecificationRelationship) : Integer;
    

    // Insert FhirSubstanceSpecificationRelationship before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSpecificationRelationship;
    

    // Insert an existing FhirSubstanceSpecificationRelationship before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSpecificationRelationship);
    
    // Get the iIndexth FhirSubstanceSpecificationRelationship. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSpecificationRelationship);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSpecificationRelationship;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceSpecificationRelationships[index : Integer] : TFhirSubstanceSpecificationRelationship read GetItemN write SetItemN; default;
  End;

  // The detailed description of a substance, typically at a level beyond what is used for prescribing.
  TFhirSubstanceSpecification = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FType_ : TFhirCodeableConcept;
    FStatus : TFhirCodeableConcept;
    FDomain : TFhirCodeableConcept;
    FDescription : TFhirString;
    FsourceList : TFhirReferenceList{TFhirDocumentReference};
    FComment : TFhirString;
    FmoietyList : TFhirSubstanceSpecificationMoietyList;
    Fproperty_List : TFhirSubstanceSpecificationPropertyList;
    FReferenceInformation : TFhirReference{TFhirSubstanceReferenceInformation};
    FStructure : TFhirSubstanceSpecificationStructure;
    FcodeList : TFhirSubstanceSpecificationCodeList;
    FnameList : TFhirSubstanceSpecificationNameList;
    FmolecularWeightList : TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList;
    FrelationshipList : TFhirSubstanceSpecificationRelationshipList;
    FNucleicAcid : TFhirReference{TFhirSubstanceNucleicAcid};
    FPolymer : TFhirReference{TFhirSubstancePolymer};
    FProtein : TFhirReference{TFhirSubstanceProtein};
    FSourceMaterial : TFhirReference{TFhirSubstanceSourceMaterial};
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetStatus(value : TFhirCodeableConcept);
    Procedure SetDomain(value : TFhirCodeableConcept);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetSourceList : TFhirReferenceList{TFhirDocumentReference};
    function GetHasSourceList : Boolean;
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);
    function GetMoietyList : TFhirSubstanceSpecificationMoietyList;
    function GetHasMoietyList : Boolean;
    function GetProperty_List : TFhirSubstanceSpecificationPropertyList;
    function GetHasProperty_List : Boolean;
    Procedure SetReferenceInformation(value : TFhirReference{TFhirSubstanceReferenceInformation});
    Procedure SetStructure(value : TFhirSubstanceSpecificationStructure);
    function GetCodeList : TFhirSubstanceSpecificationCodeList;
    function GetHasCodeList : Boolean;
    function GetNameList : TFhirSubstanceSpecificationNameList;
    function GetHasNameList : Boolean;
    function GetMolecularWeightList : TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList;
    function GetHasMolecularWeightList : Boolean;
    function GetRelationshipList : TFhirSubstanceSpecificationRelationshipList;
    function GetHasRelationshipList : Boolean;
    Procedure SetNucleicAcid(value : TFhirReference{TFhirSubstanceNucleicAcid});
    Procedure SetPolymer(value : TFhirReference{TFhirSubstancePolymer});
    Procedure SetProtein(value : TFhirReference{TFhirSubstanceProtein});
    Procedure SetSourceMaterial(value : TFhirReference{TFhirSubstanceSourceMaterial});
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceSpecification; overload;
    function Clone : TFhirSubstanceSpecification; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Identifier by which this substance is known. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier by which this substance is known.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to High level categorization, e.g. polymer or nucleic acid. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // High level categorization, e.g. polymer or nucleic acid.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Status of substance within the catalogue e.g. approved. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // Status of substance within the catalogue e.g. approved.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to If the substance applies to only human or veterinary use. (defined for API consistency)
    property domain : TFhirCodeableConcept read FDomain write SetDomain;
    // If the substance applies to only human or veterinary use.
    property domainElement : TFhirCodeableConcept read FDomain write SetDomain;

    // Typed access to Textual description of the substance.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Textual description of the substance.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Supporting literature.
    property sourceList : TFhirReferenceList{TFhirDocumentReference} read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

    // Typed access to Textual comment about this record of a substance.
    property comment : String read GetCommentST write SetCommentST;
    // Textual comment about this record of a substance.
    property commentElement : TFhirString read FComment write SetComment;

    // Moiety, for structural modifications.
    property moietyList : TFhirSubstanceSpecificationMoietyList read GetMoietyList;
    property hasMoietyList : boolean read GetHasMoietyList;

    // General specifications for this substance, including how it is related to other substances.
    property property_List : TFhirSubstanceSpecificationPropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // Typed access to General information detailing this substance. (defined for API consistency)
    property referenceInformation : TFhirReference{TFhirSubstanceReferenceInformation} read FReferenceInformation write SetReferenceInformation;
    // General information detailing this substance.
    property referenceInformationElement : TFhirReference{TFhirSubstanceReferenceInformation} read FReferenceInformation write SetReferenceInformation;

    // Typed access to Structural information. (defined for API consistency)
    property structure : TFhirSubstanceSpecificationStructure read FStructure write SetStructure;
    // Structural information.
    property structureElement : TFhirSubstanceSpecificationStructure read FStructure write SetStructure;

    // Codes associated with the substance.
    property codeList : TFhirSubstanceSpecificationCodeList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Names applicable to this substance.
    property nameList : TFhirSubstanceSpecificationNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // The molecular weight or weight range (for proteins, polymers or nucleic acids).
    property molecularWeightList : TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList read GetMolecularWeightList;
    property hasMolecularWeightList : boolean read GetHasMolecularWeightList;

    // A link between this substance and another, with details of the relationship.
    property relationshipList : TFhirSubstanceSpecificationRelationshipList read GetRelationshipList;
    property hasRelationshipList : boolean read GetHasRelationshipList;

    // Typed access to Data items specific to nucleic acids. (defined for API consistency)
    property nucleicAcid : TFhirReference{TFhirSubstanceNucleicAcid} read FNucleicAcid write SetNucleicAcid;
    // Data items specific to nucleic acids.
    property nucleicAcidElement : TFhirReference{TFhirSubstanceNucleicAcid} read FNucleicAcid write SetNucleicAcid;

    // Typed access to Data items specific to polymers. (defined for API consistency)
    property polymer : TFhirReference{TFhirSubstancePolymer} read FPolymer write SetPolymer;
    // Data items specific to polymers.
    property polymerElement : TFhirReference{TFhirSubstancePolymer} read FPolymer write SetPolymer;

    // Typed access to Data items specific to proteins. (defined for API consistency)
    property protein : TFhirReference{TFhirSubstanceProtein} read FProtein write SetProtein;
    // Data items specific to proteins.
    property proteinElement : TFhirReference{TFhirSubstanceProtein} read FProtein write SetProtein;

    // Typed access to Material or taxonomic/anatomical source for the substance. (defined for API consistency)
    property sourceMaterial : TFhirReference{TFhirSubstanceSourceMaterial} read FSourceMaterial write SetSourceMaterial;
    // Material or taxonomic/anatomical source for the substance.
    property sourceMaterialElement : TFhirReference{TFhirSubstanceSourceMaterial} read FSourceMaterial write SetSourceMaterial;

  end;

  TFhirSubstanceSpecificationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceSpecificationList;
    function GetCurrent : TFhirSubstanceSpecification;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceSpecificationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceSpecification read GetCurrent;
  end;

  TFhirSubstanceSpecificationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceSpecification;
    procedure SetItemN(index : Integer; value : TFhirSubstanceSpecification);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceSpecificationList; Overload;
    function Clone : TFhirSubstanceSpecificationList; Overload;
    function GetEnumerator : TFhirSubstanceSpecificationListEnumerator;
    

    //  Add a FhirSubstanceSpecification to the end of the list.
    function Append : TFhirSubstanceSpecification;

    
    // Add an already existing FhirSubstanceSpecification to the end of the list.
    procedure AddItem(value : TFhirSubstanceSpecification); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceSpecification) : Integer;
    

    // Insert FhirSubstanceSpecification before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceSpecification;
    

    // Insert an existing FhirSubstanceSpecification before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceSpecification);
    
    // Get the iIndexth FhirSubstanceSpecification. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceSpecification);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceSpecification;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceSpecifications[index : Integer] : TFhirSubstanceSpecification read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCESPECIFICATION}

implementation

uses
  fhir4_utilities;

{$IFDEF FHIR_MEDICATION}

{ TFhirMedicationIngredient }

constructor TFhirMedicationIngredient.Create;
begin
  inherited;
end;

destructor TFhirMedicationIngredient.Destroy;
begin
  FItem.free;
  FIsActive.free;
  FStrength.free;
  inherited;
end;

procedure TFhirMedicationIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirMedicationIngredient(oSource).item.Clone;
  isActiveElement := TFhirMedicationIngredient(oSource).isActiveElement.Clone;
  strength := TFhirMedicationIngredient(oSource).strength.Clone;
end;

procedure TFhirMedicationIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item[x]') or (child_name = 'item') Then
     list.add(self.link, 'item[x]', FItem.Link);
  if (child_name = 'isActive') Then
     list.add(self.link, 'isActive', FIsActive.Link);
  if (child_name = 'strength') Then
     list.add(self.link, 'strength', FStrength.Link);
end;

procedure TFhirMedicationIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item[x]', 'CodeableConcept|Reference(Substance)', false, TFhirType, FItem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'isActive', 'boolean', false, TFhirBoolean, FIsActive.Link));{2}
  oList.add(TFHIRProperty.create(self, 'strength', 'Ratio', false, TFhirRatio, FStrength.Link));{2}
end;

function TFhirMedicationIngredient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then
  begin
    Item := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'isActive') then
  begin
    IsActiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'strength') then
  begin
    Strength := propValue as TFhirRatio{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationIngredient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Item'){4x}
  else if (propName = 'isActive') then result := TFhirBoolean.create() {5b}
  else if (propName = 'strength') then result := TFhirRatio.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'isActive') then result := 'boolean'
  else if (propName = 'strength') then result := 'Ratio'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationIngredient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := nil{4x}
  else if (propName = 'isActive') then IsActiveElement := nil
  else if (propName = 'strength') then StrengthElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := new as TFhirType{4x}
  else if (propName = 'isActive') then IsActiveElement := asBoolean(new){5b}
  else if (propName = 'strength') then StrengthElement := new as TFhirRatio{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationIngredient.fhirType : string;
begin
  result := 'ingredient';
end;

function TFhirMedicationIngredient.Link : TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient(inherited Link);
end;

function TFhirMedicationIngredient.Clone : TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient(inherited Clone);
end;

function TFhirMedicationIngredient.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationIngredient)) then
    result := false
  else
  begin
    o := TFhirMedicationIngredient(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(isActiveElement, o.isActiveElement, true) and 
      compareDeep(strengthElement, o.strengthElement, true);
  end;
end;

function TFhirMedicationIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FIsActive) and isEmptyProp(FStrength);
end;

procedure TFhirMedicationIngredient.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item[x]');
  fields.add('isActive');
  fields.add('strength');
end;

{ TFhirMedicationIngredient }

Procedure TFhirMedicationIngredient.SetItem(value : TFhirType);
begin
  FItem.free;
  FItem := value;
end;

Procedure TFhirMedicationIngredient.SetIsActive(value : TFhirBoolean);
begin
  FIsActive.free;
  FIsActive := value;
end;

Function TFhirMedicationIngredient.GetIsActiveST : Boolean;
begin
  if FIsActive = nil then
    result := false
  else
    result := FIsActive.value;
end;

Procedure TFhirMedicationIngredient.SetIsActiveST(value : Boolean);
begin
  if FIsActive = nil then
    FIsActive := TFhirBoolean.create;
  FIsActive.value := value
end;

Procedure TFhirMedicationIngredient.SetStrength(value : TFhirRatio);
begin
  FStrength.free;
  FStrength := value;
end;

function TFhirMedicationIngredient.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItem.sizeInBytes);
  inc(result, FIsActive.sizeInBytes);
  inc(result, FStrength.sizeInBytes);
end;

{ TFhirMedicationIngredientListEnumerator }

Constructor TFhirMedicationIngredientListEnumerator.Create(list : TFhirMedicationIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationIngredientListEnumerator.GetCurrent : TFhirMedicationIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationIngredientListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationIngredientList }
procedure TFhirMedicationIngredientList.AddItem(value: TFhirMedicationIngredient);
begin
  assert(value.ClassName = 'TFhirMedicationIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationIngredient');
  add(value);
end;

function TFhirMedicationIngredientList.Append: TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationIngredientList.GetEnumerator : TFhirMedicationIngredientListEnumerator;
begin
  result := TFhirMedicationIngredientListEnumerator.Create(self.link);
end;

function TFhirMedicationIngredientList.Clone: TFhirMedicationIngredientList;
begin
  result := TFhirMedicationIngredientList(inherited Clone);
end;

function TFhirMedicationIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationIngredientList.GetItemN(index: Integer): TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationIngredient;
end;
function TFhirMedicationIngredientList.IndexOf(value: TFhirMedicationIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationIngredientList.Insert(index: Integer): TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationIngredientList.InsertItem(index: Integer; value: TFhirMedicationIngredient);
begin
  assert(value is TFhirMedicationIngredient);
  Inherited Insert(index, value);
end;

function TFhirMedicationIngredientList.Item(index: Integer): TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationIngredientList.Link: TFhirMedicationIngredientList;
begin
  result := TFhirMedicationIngredientList(inherited Link);
end;

procedure TFhirMedicationIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationIngredientList.SetItemByIndex(index: Integer; value: TFhirMedicationIngredient);
begin
  assert(value is TFhirMedicationIngredient);
  FhirMedicationIngredients[index] := value;
end;

procedure TFhirMedicationIngredientList.SetItemN(index: Integer; value: TFhirMedicationIngredient);
begin
  assert(value is TFhirMedicationIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationBatch }

constructor TFhirMedicationBatch.Create;
begin
  inherited;
end;

destructor TFhirMedicationBatch.Destroy;
begin
  FLotNumber.free;
  FExpirationDate.free;
  inherited;
end;

procedure TFhirMedicationBatch.Assign(oSource : TFslObject);
begin
  inherited;
  lotNumberElement := TFhirMedicationBatch(oSource).lotNumberElement.Clone;
  expirationDateElement := TFhirMedicationBatch(oSource).expirationDateElement.Clone;
end;

procedure TFhirMedicationBatch.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'lotNumber') Then
     list.add(self.link, 'lotNumber', FLotNumber.Link);
  if (child_name = 'expirationDate') Then
     list.add(self.link, 'expirationDate', FExpirationDate.Link);
end;

procedure TFhirMedicationBatch.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'lotNumber', 'string', false, TFhirString, FLotNumber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expirationDate', 'dateTime', false, TFhirDateTime, FExpirationDate.Link));{2}
end;

function TFhirMedicationBatch.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'lotNumber') then
  begin
    LotNumberElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'expirationDate') then
  begin
    ExpirationDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationBatch.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationBatch.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'lotNumber') then result := TFhirString.create() {5b}
  else if (propName = 'expirationDate') then result := TFhirDateTime.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationBatch.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'lotNumber') then result := 'string'
  else if (propName = 'expirationDate') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationBatch.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'lotNumber') then LotNumberElement := nil
  else if (propName = 'expirationDate') then ExpirationDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationBatch.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'lotNumber') then LotNumberElement := asString(new){5b}
  else if (propName = 'expirationDate') then ExpirationDateElement := asDateTime(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationBatch.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationBatch.fhirType : string;
begin
  result := 'batch';
end;

function TFhirMedicationBatch.Link : TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch(inherited Link);
end;

function TFhirMedicationBatch.Clone : TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch(inherited Clone);
end;

function TFhirMedicationBatch.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationBatch;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationBatch)) then
    result := false
  else
  begin
    o := TFhirMedicationBatch(other);
    result := compareDeep(lotNumberElement, o.lotNumberElement, true) and compareDeep(expirationDateElement, o.expirationDateElement, true);
  end;
end;

function TFhirMedicationBatch.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLotNumber) and isEmptyProp(FExpirationDate);
end;

procedure TFhirMedicationBatch.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('lotNumber');
  fields.add('expirationDate');
end;

{ TFhirMedicationBatch }

Procedure TFhirMedicationBatch.SetLotNumber(value : TFhirString);
begin
  FLotNumber.free;
  FLotNumber := value;
end;

Function TFhirMedicationBatch.GetLotNumberST : String;
begin
  if FLotNumber = nil then
    result := ''
  else
    result := FLotNumber.value;
end;

Procedure TFhirMedicationBatch.SetLotNumberST(value : String);
begin
  if value <> '' then
  begin
    if FLotNumber = nil then
      FLotNumber := TFhirString.create;
    FLotNumber.value := value
  end
  else if FLotNumber <> nil then
    FLotNumber.value := '';
end;

Procedure TFhirMedicationBatch.SetExpirationDate(value : TFhirDateTime);
begin
  FExpirationDate.free;
  FExpirationDate := value;
end;

Function TFhirMedicationBatch.GetExpirationDateST : TFslDateTime;
begin
  if FExpirationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpirationDate.value;
end;

Procedure TFhirMedicationBatch.SetExpirationDateST(value : TFslDateTime);
begin
  if FExpirationDate = nil then
    FExpirationDate := TFhirDateTime.create;
  FExpirationDate.value := value
end;

function TFhirMedicationBatch.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLotNumber.sizeInBytes);
  inc(result, FExpirationDate.sizeInBytes);
end;

{ TFhirMedicationBatchListEnumerator }

Constructor TFhirMedicationBatchListEnumerator.Create(list : TFhirMedicationBatchList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationBatchListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationBatchListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationBatchListEnumerator.GetCurrent : TFhirMedicationBatch;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationBatchListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationBatchList }
procedure TFhirMedicationBatchList.AddItem(value: TFhirMedicationBatch);
begin
  assert(value.ClassName = 'TFhirMedicationBatch', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationBatch');
  add(value);
end;

function TFhirMedicationBatchList.Append: TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationBatchList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationBatchList.GetEnumerator : TFhirMedicationBatchListEnumerator;
begin
  result := TFhirMedicationBatchListEnumerator.Create(self.link);
end;

function TFhirMedicationBatchList.Clone: TFhirMedicationBatchList;
begin
  result := TFhirMedicationBatchList(inherited Clone);
end;

function TFhirMedicationBatchList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationBatchList.GetItemN(index: Integer): TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch(ObjectByIndex[index]);
end;

function TFhirMedicationBatchList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationBatch;
end;
function TFhirMedicationBatchList.IndexOf(value: TFhirMedicationBatch): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationBatchList.Insert(index: Integer): TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationBatchList.InsertItem(index: Integer; value: TFhirMedicationBatch);
begin
  assert(value is TFhirMedicationBatch);
  Inherited Insert(index, value);
end;

function TFhirMedicationBatchList.Item(index: Integer): TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch(ObjectByIndex[index]);
end;

function TFhirMedicationBatchList.Link: TFhirMedicationBatchList;
begin
  result := TFhirMedicationBatchList(inherited Link);
end;

procedure TFhirMedicationBatchList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationBatchList.SetItemByIndex(index: Integer; value: TFhirMedicationBatch);
begin
  assert(value is TFhirMedicationBatch);
  FhirMedicationBatches[index] := value;
end;

procedure TFhirMedicationBatchList.SetItemN(index: Integer; value: TFhirMedicationBatch);
begin
  assert(value is TFhirMedicationBatch);
  ObjectByIndex[index] := value;
end;

{ TFhirMedication }

constructor TFhirMedication.Create;
begin
  inherited;
end;

destructor TFhirMedication.Destroy;
begin
  FIdentifierList.Free;
  FCode.free;
  FStatus.free;
  FManufacturer.free;
  FForm.free;
  FAmount.free;
  FIngredientList.Free;
  FBatch.free;
  inherited;
end;

function TFhirMedication.GetResourceType : TFhirResourceType;
begin
  result := frtMedication;
end;

procedure TFhirMedication.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedication(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedication(oSource).FIdentifierList);
  end;
  code := TFhirMedication(oSource).code.Clone;
  FStatus := TFhirMedication(oSource).FStatus.Link;
  manufacturer := TFhirMedication(oSource).manufacturer.Clone;
  form := TFhirMedication(oSource).form.Clone;
  amount := TFhirMedication(oSource).amount.Clone;
  if (TFhirMedication(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirMedicationIngredientList.Create;
    FIngredientList.Assign(TFhirMedication(oSource).FIngredientList);
  end;
  batch := TFhirMedication(oSource).batch.Clone;
end;

procedure TFhirMedication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer', FManufacturer.Link);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'batch') Then
     list.add(self.link, 'batch', FBatch.Link);
end;

procedure TFhirMedication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FManufacturer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'form', 'CodeableConcept', false, TFhirCodeableConcept, FForm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Ratio', false, TFhirRatio, FAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ingredient', '', true, TFhirMedicationIngredient, FIngredientList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'batch', '', false, TFhirMedicationBatch, FBatch.Link));{2}
end;

function TFhirMedication.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationStatusEnum, CODES_TFhirMedicationStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'manufacturer') then
  begin
    Manufacturer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirRatio{4b};
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirMedicationIngredient){2a};
    result := propValue;
  end
  else if (propName = 'batch') then
  begin
    Batch := propValue as TFhirMedicationBatch{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirMedicationIngredient){2a}
  else inherited;
end;

function TFhirMedication.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'manufacturer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'form') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'amount') then result := TFhirRatio.create(){4b}
  else if (propName = 'ingredient') then result := IngredientList.new(){2}
  else if (propName = 'batch') then result := TFhirMedicationBatch.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'form') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Ratio'
  else if (propName = 'ingredient') then result := ''
  else if (propName = 'batch') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedication.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'manufacturer') then ManufacturerElement := nil
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value) {2}
  else if (propName = 'batch') then BatchElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationStatusEnum, CODES_TFhirMedicationStatusEnum, new){4}
  else if (propName = 'manufacturer') then ManufacturerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'form') then FormElement := new as TFhirCodeableConcept{4}
  else if (propName = 'amount') then AmountElement := new as TFhirRatio{4}
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new) {2}
  else if (propName = 'batch') then BatchElement := new as TFhirMedicationBatch{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedication.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'ingredient') then IngredientList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedication.fhirType : string;
begin
  result := 'Medication';
end;

function TFhirMedication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCode) and isEmptyProp(FStatus) and isEmptyProp(FManufacturer) and isEmptyProp(FForm) and isEmptyProp(FAmount) and isEmptyProp(FingredientList) and isEmptyProp(FBatch);
end;

function TFhirMedication.equals(other : TObject) : boolean; 
var
  o : TFhirMedication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedication)) then
    result := false
  else
  begin
    o := TFhirMedication(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(manufacturerElement, o.manufacturerElement, true) and 
      compareDeep(formElement, o.formElement, true) and compareDeep(amountElement, o.amountElement, true) and 
      compareDeep(ingredientList, o.ingredientList, true) and compareDeep(batchElement, o.batchElement, true);
  end;
end;

function TFhirMedication.Link : TFhirMedication;
begin
  result := TFhirMedication(inherited Link);
end;

function TFhirMedication.Clone : TFhirMedication;
begin
  result := TFhirMedication(inherited Clone);
end;

procedure TFhirMedication.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('status');
  fields.add('manufacturer');
  fields.add('form');
  fields.add('amount');
  fields.add('ingredient');
  fields.add('batch');
end;

{ TFhirMedication }

Function TFhirMedication.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirMedication.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirMedication.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirMedication.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirMedication.GetStatusST : TFhirMedicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationStatusEnum(0)
  else
    result := TFhirMedicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationStatusEnum, FStatus.value));
end;

Procedure TFhirMedication.SetStatusST(value : TFhirMedicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationStatusEnum[value], CODES_TFhirMedicationStatusEnum[value]);
end;

Procedure TFhirMedication.SetManufacturer(value : TFhirReference{TFhirOrganization});
begin
  FManufacturer.free;
  FManufacturer := value;
end;

Procedure TFhirMedication.SetForm(value : TFhirCodeableConcept);
begin
  FForm.free;
  FForm := value;
end;

Procedure TFhirMedication.SetAmount(value : TFhirRatio);
begin
  FAmount.free;
  FAmount := value;
end;

Function TFhirMedication.GetIngredientList : TFhirMedicationIngredientList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirMedicationIngredientList.Create;
  result := FIngredientList;
end;

Function TFhirMedication.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

Procedure TFhirMedication.SetBatch(value : TFhirMedicationBatch);
begin
  FBatch.free;
  FBatch := value;
end;

function TFhirMedication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FManufacturer.sizeInBytes);
  inc(result, FForm.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FingredientList.sizeInBytes);
  inc(result, FBatch.sizeInBytes);
end;

{ TFhirMedicationListEnumerator }

Constructor TFhirMedicationListEnumerator.Create(list : TFhirMedicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationListEnumerator.GetCurrent : TFhirMedication;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationList }
procedure TFhirMedicationList.AddItem(value: TFhirMedication);
begin
  assert(value.ClassName = 'TFhirMedication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedication');
  add(value);
end;

function TFhirMedicationList.Append: TFhirMedication;
begin
  result := TFhirMedication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationList.GetEnumerator : TFhirMedicationListEnumerator;
begin
  result := TFhirMedicationListEnumerator.Create(self.link);
end;

function TFhirMedicationList.Clone: TFhirMedicationList;
begin
  result := TFhirMedicationList(inherited Clone);
end;

function TFhirMedicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationList.GetItemN(index: Integer): TFhirMedication;
begin
  result := TFhirMedication(ObjectByIndex[index]);
end;

function TFhirMedicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedication;
end;
function TFhirMedicationList.IndexOf(value: TFhirMedication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationList.Insert(index: Integer): TFhirMedication;
begin
  result := TFhirMedication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationList.InsertItem(index: Integer; value: TFhirMedication);
begin
  assert(value is TFhirMedication);
  Inherited Insert(index, value);
end;

function TFhirMedicationList.Item(index: Integer): TFhirMedication;
begin
  result := TFhirMedication(ObjectByIndex[index]);
end;

function TFhirMedicationList.Link: TFhirMedicationList;
begin
  result := TFhirMedicationList(inherited Link);
end;

procedure TFhirMedicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationList.SetItemByIndex(index: Integer; value: TFhirMedication);
begin
  assert(value is TFhirMedication);
  FhirMedications[index] := value;
end;

procedure TFhirMedicationList.SetItemN(index: Integer; value: TFhirMedication);
begin
  assert(value is TFhirMedication);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATION}

{$IFDEF FHIR_MEDICATIONKNOWLEDGE}

{ TFhirMedicationKnowledgeRelatedMedicationKnowledge }

constructor TFhirMedicationKnowledgeRelatedMedicationKnowledge.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeRelatedMedicationKnowledge.Destroy;
begin
  FType_.free;
  FReferenceList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeRelatedMedicationKnowledge(oSource).type_.Clone;
  if (TFhirMedicationKnowledgeRelatedMedicationKnowledge(oSource).FReferenceList = nil) then
  begin
    FReferenceList.free;
    FReferenceList := nil;
  end
  else
  begin
    if FReferenceList = nil then
      FReferenceList := TFhirReferenceList{TFhirMedicationKnowledge}.Create;
    FReferenceList.Assign(TFhirMedicationKnowledgeRelatedMedicationKnowledge(oSource).FReferenceList);
  end;
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'reference') Then
    list.addAll(self, 'reference', FReferenceList);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference(MedicationKnowledge)', true, TFhirReference{TFhirMedicationKnowledge}, FReferenceList.Link)){3};
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    ReferenceList.add(propValue as TFhirReference{TFhirMedicationKnowledge}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reference') then ReferenceList.insertItem(index, propValue as TFhirReference{TFhirMedicationKnowledge}){2a}
  else inherited;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reference') then result := ReferenceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'reference') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'reference') then deletePropertyValue('reference', ReferenceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'reference') then replacePropertyValue('reference', ReferenceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reference') then ReferenceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.fhirType : string;
begin
  result := 'relatedMedicationKnowledge';
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.Link : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge(inherited Link);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.Clone : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge(inherited Clone);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeRelatedMedicationKnowledge)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeRelatedMedicationKnowledge(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(referenceList, o.referenceList, true);
  end;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FreferenceList);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('reference');
end;

{ TFhirMedicationKnowledgeRelatedMedicationKnowledge }

Procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirMedicationKnowledgeRelatedMedicationKnowledge.GetReferenceList : TFhirReferenceList{TFhirMedicationKnowledge};
begin
  if FReferenceList = nil then
    FReferenceList := TFhirReferenceList{TFhirMedicationKnowledge}.Create;
  result := FReferenceList;
end;

Function TFhirMedicationKnowledgeRelatedMedicationKnowledge.GetHasReferenceList : boolean;
begin
  result := (FReferenceList <> nil) and (FReferenceList.count > 0);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FreferenceList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator }

Constructor TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.Create(list : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.GetCurrent : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeRelatedMedicationKnowledgeList }
procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.AddItem(value: TFhirMedicationKnowledgeRelatedMedicationKnowledge);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeRelatedMedicationKnowledge', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeRelatedMedicationKnowledge');
  add(value);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Append: TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.GetEnumerator : TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Clone: TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledgeList(inherited Clone);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.GetItemN(index: Integer): TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge;
end;
function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.IndexOf(value: TFhirMedicationKnowledgeRelatedMedicationKnowledge): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Insert(index: Integer): TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeRelatedMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledgeRelatedMedicationKnowledge);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Item(index: Integer): TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Link: TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledgeList(inherited Link);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeRelatedMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledgeRelatedMedicationKnowledge);
  FhirMedicationKnowledgeRelatedMedicationKnowledges[index] := value;
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeRelatedMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledgeRelatedMedicationKnowledge);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeMonograph }

constructor TFhirMedicationKnowledgeMonograph.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeMonograph.Destroy;
begin
  FType_.free;
  FSource.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeMonograph.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeMonograph(oSource).type_.Clone;
  source := TFhirMedicationKnowledgeMonograph(oSource).source.Clone;
end;

procedure TFhirMedicationKnowledgeMonograph.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
end;

procedure TFhirMedicationKnowledgeMonograph.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference(DocumentReference)', false, TFhirReference{TFhirDocumentReference}, FSource.Link));{2}
end;

function TFhirMedicationKnowledgeMonograph.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference{TFhirDocumentReference}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeMonograph.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeMonograph.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'source') then result := TFhirReference{TFhirDocumentReference}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeMonograph.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeMonograph.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'source') then SourceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeMonograph.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'source') then SourceElement := new as TFhirReference{TFhirDocumentReference}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeMonograph.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeMonograph.fhirType : string;
begin
  result := 'monograph';
end;

function TFhirMedicationKnowledgeMonograph.Link : TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph(inherited Link);
end;

function TFhirMedicationKnowledgeMonograph.Clone : TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph(inherited Clone);
end;

function TFhirMedicationKnowledgeMonograph.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeMonograph;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeMonograph)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeMonograph(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(sourceElement, o.sourceElement, true);
  end;
end;

function TFhirMedicationKnowledgeMonograph.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FSource);
end;

procedure TFhirMedicationKnowledgeMonograph.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('source');
end;

{ TFhirMedicationKnowledgeMonograph }

Procedure TFhirMedicationKnowledgeMonograph.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirMedicationKnowledgeMonograph.SetSource(value : TFhirReference{TFhirDocumentReference});
begin
  FSource.free;
  FSource := value;
end;

function TFhirMedicationKnowledgeMonograph.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FSource.sizeInBytes);
end;

{ TFhirMedicationKnowledgeMonographListEnumerator }

Constructor TFhirMedicationKnowledgeMonographListEnumerator.Create(list : TFhirMedicationKnowledgeMonographList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeMonographListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeMonographListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeMonographListEnumerator.GetCurrent : TFhirMedicationKnowledgeMonograph;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeMonographListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeMonographList }
procedure TFhirMedicationKnowledgeMonographList.AddItem(value: TFhirMedicationKnowledgeMonograph);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeMonograph', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeMonograph');
  add(value);
end;

function TFhirMedicationKnowledgeMonographList.Append: TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMonographList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeMonographList.GetEnumerator : TFhirMedicationKnowledgeMonographListEnumerator;
begin
  result := TFhirMedicationKnowledgeMonographListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeMonographList.Clone: TFhirMedicationKnowledgeMonographList;
begin
  result := TFhirMedicationKnowledgeMonographList(inherited Clone);
end;

function TFhirMedicationKnowledgeMonographList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeMonographList.GetItemN(index: Integer): TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMonographList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeMonograph;
end;
function TFhirMedicationKnowledgeMonographList.IndexOf(value: TFhirMedicationKnowledgeMonograph): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeMonographList.Insert(index: Integer): TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMonographList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeMonograph);
begin
  assert(value is TFhirMedicationKnowledgeMonograph);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeMonographList.Item(index: Integer): TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMonographList.Link: TFhirMedicationKnowledgeMonographList;
begin
  result := TFhirMedicationKnowledgeMonographList(inherited Link);
end;

procedure TFhirMedicationKnowledgeMonographList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeMonographList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeMonograph);
begin
  assert(value is TFhirMedicationKnowledgeMonograph);
  FhirMedicationKnowledgeMonographs[index] := value;
end;

procedure TFhirMedicationKnowledgeMonographList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeMonograph);
begin
  assert(value is TFhirMedicationKnowledgeMonograph);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeIngredient }

constructor TFhirMedicationKnowledgeIngredient.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeIngredient.Destroy;
begin
  FItem.free;
  FIsActive.free;
  FStrength.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirMedicationKnowledgeIngredient(oSource).item.Clone;
  isActiveElement := TFhirMedicationKnowledgeIngredient(oSource).isActiveElement.Clone;
  strength := TFhirMedicationKnowledgeIngredient(oSource).strength.Clone;
end;

procedure TFhirMedicationKnowledgeIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item[x]') or (child_name = 'item') Then
     list.add(self.link, 'item[x]', FItem.Link);
  if (child_name = 'isActive') Then
     list.add(self.link, 'isActive', FIsActive.Link);
  if (child_name = 'strength') Then
     list.add(self.link, 'strength', FStrength.Link);
end;

procedure TFhirMedicationKnowledgeIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item[x]', 'CodeableConcept|Reference(Substance)', false, TFhirType, FItem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'isActive', 'boolean', false, TFhirBoolean, FIsActive.Link));{2}
  oList.add(TFHIRProperty.create(self, 'strength', 'Ratio', false, TFhirRatio, FStrength.Link));{2}
end;

function TFhirMedicationKnowledgeIngredient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then
  begin
    Item := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'isActive') then
  begin
    IsActiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'strength') then
  begin
    Strength := propValue as TFhirRatio{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeIngredient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Item'){4x}
  else if (propName = 'isActive') then result := TFhirBoolean.create() {5b}
  else if (propName = 'strength') then result := TFhirRatio.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'isActive') then result := 'boolean'
  else if (propName = 'strength') then result := 'Ratio'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeIngredient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := nil{4x}
  else if (propName = 'isActive') then IsActiveElement := nil
  else if (propName = 'strength') then StrengthElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := new as TFhirType{4x}
  else if (propName = 'isActive') then IsActiveElement := asBoolean(new){5b}
  else if (propName = 'strength') then StrengthElement := new as TFhirRatio{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeIngredient.fhirType : string;
begin
  result := 'ingredient';
end;

function TFhirMedicationKnowledgeIngredient.Link : TFhirMedicationKnowledgeIngredient;
begin
  result := TFhirMedicationKnowledgeIngredient(inherited Link);
end;

function TFhirMedicationKnowledgeIngredient.Clone : TFhirMedicationKnowledgeIngredient;
begin
  result := TFhirMedicationKnowledgeIngredient(inherited Clone);
end;

function TFhirMedicationKnowledgeIngredient.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeIngredient)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeIngredient(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(isActiveElement, o.isActiveElement, true) and 
      compareDeep(strengthElement, o.strengthElement, true);
  end;
end;

function TFhirMedicationKnowledgeIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FIsActive) and isEmptyProp(FStrength);
end;

procedure TFhirMedicationKnowledgeIngredient.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item[x]');
  fields.add('isActive');
  fields.add('strength');
end;

{ TFhirMedicationKnowledgeIngredient }

Procedure TFhirMedicationKnowledgeIngredient.SetItem(value : TFhirType);
begin
  FItem.free;
  FItem := value;
end;

Procedure TFhirMedicationKnowledgeIngredient.SetIsActive(value : TFhirBoolean);
begin
  FIsActive.free;
  FIsActive := value;
end;

Function TFhirMedicationKnowledgeIngredient.GetIsActiveST : Boolean;
begin
  if FIsActive = nil then
    result := false
  else
    result := FIsActive.value;
end;

Procedure TFhirMedicationKnowledgeIngredient.SetIsActiveST(value : Boolean);
begin
  if FIsActive = nil then
    FIsActive := TFhirBoolean.create;
  FIsActive.value := value
end;

Procedure TFhirMedicationKnowledgeIngredient.SetStrength(value : TFhirRatio);
begin
  FStrength.free;
  FStrength := value;
end;

function TFhirMedicationKnowledgeIngredient.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItem.sizeInBytes);
  inc(result, FIsActive.sizeInBytes);
  inc(result, FStrength.sizeInBytes);
end;

{ TFhirMedicationKnowledgeIngredientListEnumerator }

Constructor TFhirMedicationKnowledgeIngredientListEnumerator.Create(list : TFhirMedicationKnowledgeIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeIngredientListEnumerator.GetCurrent : TFhirMedicationKnowledgeIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeIngredientListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeIngredientList }
procedure TFhirMedicationKnowledgeIngredientList.AddItem(value: TFhirMedicationKnowledgeIngredient);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeIngredient');
  add(value);
end;

function TFhirMedicationKnowledgeIngredientList.Append: TFhirMedicationKnowledgeIngredient;
begin
  result := TFhirMedicationKnowledgeIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeIngredientList.GetEnumerator : TFhirMedicationKnowledgeIngredientListEnumerator;
begin
  result := TFhirMedicationKnowledgeIngredientListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeIngredientList.Clone: TFhirMedicationKnowledgeIngredientList;
begin
  result := TFhirMedicationKnowledgeIngredientList(inherited Clone);
end;

function TFhirMedicationKnowledgeIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeIngredientList.GetItemN(index: Integer): TFhirMedicationKnowledgeIngredient;
begin
  result := TFhirMedicationKnowledgeIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeIngredient;
end;
function TFhirMedicationKnowledgeIngredientList.IndexOf(value: TFhirMedicationKnowledgeIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeIngredientList.Insert(index: Integer): TFhirMedicationKnowledgeIngredient;
begin
  result := TFhirMedicationKnowledgeIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeIngredientList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeIngredient);
begin
  assert(value is TFhirMedicationKnowledgeIngredient);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeIngredientList.Item(index: Integer): TFhirMedicationKnowledgeIngredient;
begin
  result := TFhirMedicationKnowledgeIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeIngredientList.Link: TFhirMedicationKnowledgeIngredientList;
begin
  result := TFhirMedicationKnowledgeIngredientList(inherited Link);
end;

procedure TFhirMedicationKnowledgeIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeIngredientList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeIngredient);
begin
  assert(value is TFhirMedicationKnowledgeIngredient);
  FhirMedicationKnowledgeIngredients[index] := value;
end;

procedure TFhirMedicationKnowledgeIngredientList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeIngredient);
begin
  assert(value is TFhirMedicationKnowledgeIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeCost }

constructor TFhirMedicationKnowledgeCost.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeCost.Destroy;
begin
  FType_.free;
  FSource.free;
  FCost.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeCost.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeCost(oSource).type_.Clone;
  sourceElement := TFhirMedicationKnowledgeCost(oSource).sourceElement.Clone;
  cost := TFhirMedicationKnowledgeCost(oSource).cost.Clone;
end;

procedure TFhirMedicationKnowledgeCost.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'cost') Then
     list.add(self.link, 'cost', FCost.Link);
end;

procedure TFhirMedicationKnowledgeCost.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'string', false, TFhirString, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'cost', 'Money', false, TFhirMoney, FCost.Link));{2}
end;

function TFhirMedicationKnowledgeCost.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'cost') then
  begin
    Cost := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeCost.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeCost.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'source') then result := TFhirString.create() {5b}
  else if (propName = 'cost') then result := TFhirMoney.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeCost.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'string'
  else if (propName = 'cost') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeCost.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'cost') then CostElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeCost.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'source') then SourceElement := asString(new){5b}
  else if (propName = 'cost') then CostElement := new as TFhirMoney{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeCost.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeCost.fhirType : string;
begin
  result := 'cost';
end;

function TFhirMedicationKnowledgeCost.Link : TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost(inherited Link);
end;

function TFhirMedicationKnowledgeCost.Clone : TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost(inherited Clone);
end;

function TFhirMedicationKnowledgeCost.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeCost;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeCost)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeCost(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(costElement, o.costElement, true);
  end;
end;

function TFhirMedicationKnowledgeCost.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FSource) and isEmptyProp(FCost);
end;

procedure TFhirMedicationKnowledgeCost.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('source');
  fields.add('cost');
end;

{ TFhirMedicationKnowledgeCost }

Procedure TFhirMedicationKnowledgeCost.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirMedicationKnowledgeCost.SetSource(value : TFhirString);
begin
  FSource.free;
  FSource := value;
end;

Function TFhirMedicationKnowledgeCost.GetSourceST : String;
begin
  if FSource = nil then
    result := ''
  else
    result := FSource.value;
end;

Procedure TFhirMedicationKnowledgeCost.SetSourceST(value : String);
begin
  if value <> '' then
  begin
    if FSource = nil then
      FSource := TFhirString.create;
    FSource.value := value
  end
  else if FSource <> nil then
    FSource.value := '';
end;

Procedure TFhirMedicationKnowledgeCost.SetCost(value : TFhirMoney);
begin
  FCost.free;
  FCost := value;
end;

function TFhirMedicationKnowledgeCost.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FCost.sizeInBytes);
end;

{ TFhirMedicationKnowledgeCostListEnumerator }

Constructor TFhirMedicationKnowledgeCostListEnumerator.Create(list : TFhirMedicationKnowledgeCostList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeCostListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeCostListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeCostListEnumerator.GetCurrent : TFhirMedicationKnowledgeCost;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeCostListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeCostList }
procedure TFhirMedicationKnowledgeCostList.AddItem(value: TFhirMedicationKnowledgeCost);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeCost', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeCost');
  add(value);
end;

function TFhirMedicationKnowledgeCostList.Append: TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeCostList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeCostList.GetEnumerator : TFhirMedicationKnowledgeCostListEnumerator;
begin
  result := TFhirMedicationKnowledgeCostListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeCostList.Clone: TFhirMedicationKnowledgeCostList;
begin
  result := TFhirMedicationKnowledgeCostList(inherited Clone);
end;

function TFhirMedicationKnowledgeCostList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeCostList.GetItemN(index: Integer): TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeCostList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeCost;
end;
function TFhirMedicationKnowledgeCostList.IndexOf(value: TFhirMedicationKnowledgeCost): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeCostList.Insert(index: Integer): TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeCostList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeCost);
begin
  assert(value is TFhirMedicationKnowledgeCost);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeCostList.Item(index: Integer): TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeCostList.Link: TFhirMedicationKnowledgeCostList;
begin
  result := TFhirMedicationKnowledgeCostList(inherited Link);
end;

procedure TFhirMedicationKnowledgeCostList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeCostList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeCost);
begin
  assert(value is TFhirMedicationKnowledgeCost);
  FhirMedicationKnowledgeCosts[index] := value;
end;

procedure TFhirMedicationKnowledgeCostList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeCost);
begin
  assert(value is TFhirMedicationKnowledgeCost);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeMonitoringProgram }

constructor TFhirMedicationKnowledgeMonitoringProgram.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeMonitoringProgram.Destroy;
begin
  FType_.free;
  FName.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeMonitoringProgram(oSource).type_.Clone;
  nameElement := TFhirMedicationKnowledgeMonitoringProgram(oSource).nameElement.Clone;
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
end;

function TFhirMedicationKnowledgeMonitoringProgram.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeMonitoringProgram.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeMonitoringProgram.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'name') then NameElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeMonitoringProgram.fhirType : string;
begin
  result := 'monitoringProgram';
end;

function TFhirMedicationKnowledgeMonitoringProgram.Link : TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram(inherited Link);
end;

function TFhirMedicationKnowledgeMonitoringProgram.Clone : TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram(inherited Clone);
end;

function TFhirMedicationKnowledgeMonitoringProgram.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeMonitoringProgram;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeMonitoringProgram)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeMonitoringProgram(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(nameElement, o.nameElement, true);
  end;
end;

function TFhirMedicationKnowledgeMonitoringProgram.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FName);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('name');
end;

{ TFhirMedicationKnowledgeMonitoringProgram }

Procedure TFhirMedicationKnowledgeMonitoringProgram.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirMedicationKnowledgeMonitoringProgram.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirMedicationKnowledgeMonitoringProgram.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirMedicationKnowledgeMonitoringProgram.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

function TFhirMedicationKnowledgeMonitoringProgram.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FName.sizeInBytes);
end;

{ TFhirMedicationKnowledgeMonitoringProgramListEnumerator }

Constructor TFhirMedicationKnowledgeMonitoringProgramListEnumerator.Create(list : TFhirMedicationKnowledgeMonitoringProgramList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeMonitoringProgramListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeMonitoringProgramListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeMonitoringProgramListEnumerator.GetCurrent : TFhirMedicationKnowledgeMonitoringProgram;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeMonitoringProgramListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeMonitoringProgramList }
procedure TFhirMedicationKnowledgeMonitoringProgramList.AddItem(value: TFhirMedicationKnowledgeMonitoringProgram);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeMonitoringProgram', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeMonitoringProgram');
  add(value);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Append: TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMonitoringProgramList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeMonitoringProgramList.GetEnumerator : TFhirMedicationKnowledgeMonitoringProgramListEnumerator;
begin
  result := TFhirMedicationKnowledgeMonitoringProgramListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Clone: TFhirMedicationKnowledgeMonitoringProgramList;
begin
  result := TFhirMedicationKnowledgeMonitoringProgramList(inherited Clone);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeMonitoringProgramList.GetItemN(index: Integer): TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram;
end;
function TFhirMedicationKnowledgeMonitoringProgramList.IndexOf(value: TFhirMedicationKnowledgeMonitoringProgram): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Insert(index: Integer): TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMonitoringProgramList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeMonitoringProgram);
begin
  assert(value is TFhirMedicationKnowledgeMonitoringProgram);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Item(index: Integer): TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Link: TFhirMedicationKnowledgeMonitoringProgramList;
begin
  result := TFhirMedicationKnowledgeMonitoringProgramList(inherited Link);
end;

procedure TFhirMedicationKnowledgeMonitoringProgramList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeMonitoringProgramList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeMonitoringProgram);
begin
  assert(value is TFhirMedicationKnowledgeMonitoringProgram);
  FhirMedicationKnowledgeMonitoringPrograms[index] := value;
end;

procedure TFhirMedicationKnowledgeMonitoringProgramList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeMonitoringProgram);
begin
  assert(value is TFhirMedicationKnowledgeMonitoringProgram);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeAdministrationGuidelines }

constructor TFhirMedicationKnowledgeAdministrationGuidelines.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeAdministrationGuidelines.Destroy;
begin
  FDosageList.Free;
  FIndication.free;
  FPatientCharacteristicsList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelines.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationKnowledgeAdministrationGuidelines(oSource).FDosageList = nil) then
  begin
    FDosageList.free;
    FDosageList := nil;
  end
  else
  begin
    if FDosageList = nil then
      FDosageList := TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.Create;
    FDosageList.Assign(TFhirMedicationKnowledgeAdministrationGuidelines(oSource).FDosageList);
  end;
  indication := TFhirMedicationKnowledgeAdministrationGuidelines(oSource).indication.Clone;
  if (TFhirMedicationKnowledgeAdministrationGuidelines(oSource).FPatientCharacteristicsList = nil) then
  begin
    FPatientCharacteristicsList.free;
    FPatientCharacteristicsList := nil;
  end
  else
  begin
    if FPatientCharacteristicsList = nil then
      FPatientCharacteristicsList := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.Create;
    FPatientCharacteristicsList.Assign(TFhirMedicationKnowledgeAdministrationGuidelines(oSource).FPatientCharacteristicsList);
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelines.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'dosage') Then
    list.addAll(self, 'dosage', FDosageList);
  if (child_name = 'indication[x]') or (child_name = 'indication') Then
     list.add(self.link, 'indication[x]', FIndication.Link);
  if (child_name = 'patientCharacteristics') Then
    list.addAll(self, 'patientCharacteristics', FPatientCharacteristicsList);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelines.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'dosage', '', true, TFhirMedicationKnowledgeAdministrationGuidelinesDosage, FDosageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'indication[x]', 'CodeableConcept|Reference(ObservationDefinition)', false, TFhirType, FIndication.Link));{2}
  oList.add(TFHIRProperty.create(self, 'patientCharacteristics', '', true, TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics, FPatientCharacteristicsList.Link)){3};
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'dosage') then
  begin
    DosageList.add(propValue as TFhirMedicationKnowledgeAdministrationGuidelinesDosage){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'indication', ['CodeableConcept', 'Reference'])) then
  begin
    Indication := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'patientCharacteristics') then
  begin
    PatientCharacteristicsList.add(propValue as TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelines.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'dosage') then DosageList.insertItem(index, propValue as TFhirMedicationKnowledgeAdministrationGuidelinesDosage){2a}
  else if (propName = 'patientCharacteristics') then PatientCharacteristicsList.insertItem(index, propValue as TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics){2a}
  else inherited;
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'dosage') then result := DosageList.new(){2}
  else if (isMatchingName(propName, 'indication', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Indication'){4x}
  else if (propName = 'patientCharacteristics') then result := PatientCharacteristicsList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'dosage') then result := ''
  else if (propName = 'indication[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'patientCharacteristics') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelines.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'dosage') then deletePropertyValue('dosage', DosageList, value) {2}
  else if (isMatchingName(propName, 'indication', ['CodeableConcept', 'Reference'])) then IndicationElement := nil{4x}
  else if (propName = 'patientCharacteristics') then deletePropertyValue('patientCharacteristics', PatientCharacteristicsList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelines.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'dosage') then replacePropertyValue('dosage', DosageList, existing, new) {2}
  else if (isMatchingName(propName, 'indication', ['CodeableConcept', 'Reference'])) then IndicationElement := new as TFhirType{4x}
  else if (propName = 'patientCharacteristics') then replacePropertyValue('patientCharacteristics', PatientCharacteristicsList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelines.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'dosage') then DosageList.move(source, destination){2a}
  else if (propName = 'patientCharacteristics') then PatientCharacteristicsList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.fhirType : string;
begin
  result := 'administrationGuidelines';
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.Link : TFhirMedicationKnowledgeAdministrationGuidelines;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelines(inherited Link);
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.Clone : TFhirMedicationKnowledgeAdministrationGuidelines;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelines(inherited Clone);
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeAdministrationGuidelines;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeAdministrationGuidelines)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeAdministrationGuidelines(other);
    result := compareDeep(dosageList, o.dosageList, true) and compareDeep(indicationElement, o.indicationElement, true) and 
      compareDeep(patientCharacteristicsList, o.patientCharacteristicsList, true);
  end;
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FdosageList) and isEmptyProp(FIndication) and isEmptyProp(FpatientCharacteristicsList);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelines.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('dosage');
  fields.add('indication[x]');
  fields.add('patientCharacteristics');
end;

{ TFhirMedicationKnowledgeAdministrationGuidelines }

Function TFhirMedicationKnowledgeAdministrationGuidelines.GetDosageList : TFhirMedicationKnowledgeAdministrationGuidelinesDosageList;
begin
  if FDosageList = nil then
    FDosageList := TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.Create;
  result := FDosageList;
end;

Function TFhirMedicationKnowledgeAdministrationGuidelines.GetHasDosageList : boolean;
begin
  result := (FDosageList <> nil) and (FDosageList.count > 0);
end;

Procedure TFhirMedicationKnowledgeAdministrationGuidelines.SetIndication(value : TFhirType);
begin
  FIndication.free;
  FIndication := value;
end;

Function TFhirMedicationKnowledgeAdministrationGuidelines.GetPatientCharacteristicsList : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList;
begin
  if FPatientCharacteristicsList = nil then
    FPatientCharacteristicsList := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.Create;
  result := FPatientCharacteristicsList;
end;

Function TFhirMedicationKnowledgeAdministrationGuidelines.GetHasPatientCharacteristicsList : boolean;
begin
  result := (FPatientCharacteristicsList <> nil) and (FPatientCharacteristicsList.count > 0);
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FdosageList.sizeInBytes);
  inc(result, FIndication.sizeInBytes);
  inc(result, FpatientCharacteristicsList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinesListEnumerator }

Constructor TFhirMedicationKnowledgeAdministrationGuidelinesListEnumerator.Create(list : TFhirMedicationKnowledgeAdministrationGuidelinesList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeAdministrationGuidelinesListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesListEnumerator.GetCurrent : TFhirMedicationKnowledgeAdministrationGuidelines;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinesList }
procedure TFhirMedicationKnowledgeAdministrationGuidelinesList.AddItem(value: TFhirMedicationKnowledgeAdministrationGuidelines);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeAdministrationGuidelines', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeAdministrationGuidelines');
  add(value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesList.Append: TFhirMedicationKnowledgeAdministrationGuidelines;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelines.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesList.GetEnumerator : TFhirMedicationKnowledgeAdministrationGuidelinesListEnumerator;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesList.Clone: TFhirMedicationKnowledgeAdministrationGuidelinesList;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesList(inherited Clone);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesList.GetItemN(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelines;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelines(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelines;
end;
function TFhirMedicationKnowledgeAdministrationGuidelinesList.IndexOf(value: TFhirMedicationKnowledgeAdministrationGuidelines): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesList.Insert(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelines;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelines.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelines);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelines);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesList.Item(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelines;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelines(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesList.Link: TFhirMedicationKnowledgeAdministrationGuidelinesList;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesList(inherited Link);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelines);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelines);
  FhirMedicationKnowledgeAdministrationGuidelines[index] := value;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelines);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelines);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinesDosage }

constructor TFhirMedicationKnowledgeAdministrationGuidelinesDosage.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeAdministrationGuidelinesDosage.Destroy;
begin
  FType_.free;
  FDosageList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosage.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeAdministrationGuidelinesDosage(oSource).type_.Clone;
  if (TFhirMedicationKnowledgeAdministrationGuidelinesDosage(oSource).FDosageList = nil) then
  begin
    FDosageList.free;
    FDosageList := nil;
  end
  else
  begin
    if FDosageList = nil then
      FDosageList := TFhirDosageList.Create;
    FDosageList.Assign(TFhirMedicationKnowledgeAdministrationGuidelinesDosage(oSource).FDosageList);
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'dosage') Then
    list.addAll(self, 'dosage', FDosageList);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dosage', 'Dosage', true, TFhirDosage, FDosageList.Link)){3};
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'dosage') then
  begin
    DosageList.add(propValue as TFhirDosage){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'dosage') then DosageList.insertItem(index, propValue as TFhirDosage){2a}
  else inherited;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'dosage') then result := DosageList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'dosage') then result := 'Dosage'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'dosage') then deletePropertyValue('dosage', DosageList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'dosage') then replacePropertyValue('dosage', DosageList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'dosage') then DosageList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.fhirType : string;
begin
  result := 'dosage';
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.Link : TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosage(inherited Link);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.Clone : TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosage(inherited Clone);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeAdministrationGuidelinesDosage)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeAdministrationGuidelinesDosage(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(dosageList, o.dosageList, true);
  end;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FdosageList);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('dosage');
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinesDosage }

Procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosage.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.GetDosageList : TFhirDosageList;
begin
  if FDosageList = nil then
    FDosageList := TFhirDosageList.Create;
  result := FDosageList;
end;

Function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.GetHasDosageList : boolean;
begin
  result := (FDosageList <> nil) and (FDosageList.count > 0);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FdosageList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinesDosageListEnumerator }

Constructor TFhirMedicationKnowledgeAdministrationGuidelinesDosageListEnumerator.Create(list : TFhirMedicationKnowledgeAdministrationGuidelinesDosageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeAdministrationGuidelinesDosageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageListEnumerator.GetCurrent : TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinesDosageList }
procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.AddItem(value: TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeAdministrationGuidelinesDosage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeAdministrationGuidelinesDosage');
  add(value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.Append: TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.GetEnumerator : TFhirMedicationKnowledgeAdministrationGuidelinesDosageListEnumerator;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosageListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.Clone: TFhirMedicationKnowledgeAdministrationGuidelinesDosageList;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosageList(inherited Clone);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.GetItemN(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosage(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
end;
function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.IndexOf(value: TFhirMedicationKnowledgeAdministrationGuidelinesDosage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.Insert(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.Item(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosage(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.Link: TFhirMedicationKnowledgeAdministrationGuidelinesDosageList;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosageList(inherited Link);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
  FhirMedicationKnowledgeAdministrationGuidelinesDosages[index] := value;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics }

constructor TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.Destroy;
begin
  FCharacteristic.free;
  FValueList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.Assign(oSource : TFslObject);
begin
  inherited;
  characteristic := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(oSource).characteristic.Clone;
  if (TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(oSource).FValueList = nil) then
  begin
    FValueList.free;
    FValueList := nil;
  end
  else
  begin
    if FValueList = nil then
      FValueList := TFhirStringList.Create;
    FValueList.Assign(TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(oSource).FValueList);
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'characteristic[x]') or (child_name = 'characteristic') Then
     list.add(self.link, 'characteristic[x]', FCharacteristic.Link);
  if (child_name = 'value') Then
    list.addAll(self, 'value', FValueList);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'characteristic[x]', 'CodeableConcept|Quantity', false, TFhirType, FCharacteristic.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'string', true, TFhirString, FValueList.Link)){3};
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'characteristic', ['CodeableConcept', 'Quantity'])) then
  begin
    Characteristic := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'value') then ValueList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'characteristic', ['CodeableConcept', 'Quantity'])) then raise EFHIRException.create('Cannot make property Characteristic'){4x}
  else if (propName = 'value') then result := ValueList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'characteristic[x]') then result := 'CodeableConcept|Quantity'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'characteristic', ['CodeableConcept', 'Quantity'])) then CharacteristicElement := nil{4x}
  else if (propName = 'value') then deletePropertyValue('value', ValueList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'characteristic', ['CodeableConcept', 'Quantity'])) then CharacteristicElement := new as TFhirType{4x}
  else if (propName = 'value') then replacePropertyValue('value', ValueList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'value') then ValueList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.fhirType : string;
begin
  result := 'patientCharacteristics';
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.Link : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(inherited Link);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.Clone : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(inherited Clone);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(other);
    result := compareDeep(characteristicElement, o.characteristicElement, true) and 
      compareDeep(valueList, o.valueList, true);
  end;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCharacteristic) and isEmptyProp(FvalueList);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('characteristic[x]');
  fields.add('value');
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics }

Procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.SetCharacteristic(value : TFhirType);
begin
  FCharacteristic.free;
  FCharacteristic := value;
end;

Function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.GetValueList : TFhirStringList;
begin
  if FValueList = nil then
    FValueList := TFhirStringList.Create;
  result := FValueList;
end;

Function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.GetHasValueList : boolean;
begin
  result := (FValueList <> nil) and (FValueList.count > 0);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCharacteristic.sizeInBytes);
  inc(result, FvalueList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsListEnumerator }

Constructor TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsListEnumerator.Create(list : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsListEnumerator.GetCurrent : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList }
procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.AddItem(value: TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics');
  add(value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.Append: TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.GetEnumerator : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsListEnumerator;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.Clone: TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList(inherited Clone);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.GetItemN(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
end;
function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.IndexOf(value: TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.Insert(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.Item(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.Link: TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList(inherited Link);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
  FhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics[index] := value;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeMedicineClassification }

constructor TFhirMedicationKnowledgeMedicineClassification.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeMedicineClassification.Destroy;
begin
  FType_.free;
  FClassificationList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeMedicineClassification.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeMedicineClassification(oSource).type_.Clone;
  if (TFhirMedicationKnowledgeMedicineClassification(oSource).FClassificationList = nil) then
  begin
    FClassificationList.free;
    FClassificationList := nil;
  end
  else
  begin
    if FClassificationList = nil then
      FClassificationList := TFhirCodeableConceptList.Create;
    FClassificationList.Assign(TFhirMedicationKnowledgeMedicineClassification(oSource).FClassificationList);
  end;
end;

procedure TFhirMedicationKnowledgeMedicineClassification.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'classification') Then
    list.addAll(self, 'classification', FClassificationList);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'classification', 'CodeableConcept', true, TFhirCodeableConcept, FClassificationList.Link)){3};
end;

function TFhirMedicationKnowledgeMedicineClassification.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'classification') then
  begin
    ClassificationList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'classification') then ClassificationList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirMedicationKnowledgeMedicineClassification.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'classification') then result := ClassificationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeMedicineClassification.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'classification') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'classification') then deletePropertyValue('classification', ClassificationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'classification') then replacePropertyValue('classification', ClassificationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'classification') then ClassificationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeMedicineClassification.fhirType : string;
begin
  result := 'medicineClassification';
end;

function TFhirMedicationKnowledgeMedicineClassification.Link : TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification(inherited Link);
end;

function TFhirMedicationKnowledgeMedicineClassification.Clone : TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification(inherited Clone);
end;

function TFhirMedicationKnowledgeMedicineClassification.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeMedicineClassification;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeMedicineClassification)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeMedicineClassification(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(classificationList, o.classificationList, true);
  end;
end;

function TFhirMedicationKnowledgeMedicineClassification.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FclassificationList);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('classification');
end;

{ TFhirMedicationKnowledgeMedicineClassification }

Procedure TFhirMedicationKnowledgeMedicineClassification.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirMedicationKnowledgeMedicineClassification.GetClassificationList : TFhirCodeableConceptList;
begin
  if FClassificationList = nil then
    FClassificationList := TFhirCodeableConceptList.Create;
  result := FClassificationList;
end;

Function TFhirMedicationKnowledgeMedicineClassification.GetHasClassificationList : boolean;
begin
  result := (FClassificationList <> nil) and (FClassificationList.count > 0);
end;

function TFhirMedicationKnowledgeMedicineClassification.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FclassificationList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeMedicineClassificationListEnumerator }

Constructor TFhirMedicationKnowledgeMedicineClassificationListEnumerator.Create(list : TFhirMedicationKnowledgeMedicineClassificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeMedicineClassificationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeMedicineClassificationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeMedicineClassificationListEnumerator.GetCurrent : TFhirMedicationKnowledgeMedicineClassification;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeMedicineClassificationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeMedicineClassificationList }
procedure TFhirMedicationKnowledgeMedicineClassificationList.AddItem(value: TFhirMedicationKnowledgeMedicineClassification);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeMedicineClassification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeMedicineClassification');
  add(value);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Append: TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMedicineClassificationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeMedicineClassificationList.GetEnumerator : TFhirMedicationKnowledgeMedicineClassificationListEnumerator;
begin
  result := TFhirMedicationKnowledgeMedicineClassificationListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Clone: TFhirMedicationKnowledgeMedicineClassificationList;
begin
  result := TFhirMedicationKnowledgeMedicineClassificationList(inherited Clone);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeMedicineClassificationList.GetItemN(index: Integer): TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeMedicineClassification;
end;
function TFhirMedicationKnowledgeMedicineClassificationList.IndexOf(value: TFhirMedicationKnowledgeMedicineClassification): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Insert(index: Integer): TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMedicineClassificationList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeMedicineClassification);
begin
  assert(value is TFhirMedicationKnowledgeMedicineClassification);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Item(index: Integer): TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Link: TFhirMedicationKnowledgeMedicineClassificationList;
begin
  result := TFhirMedicationKnowledgeMedicineClassificationList(inherited Link);
end;

procedure TFhirMedicationKnowledgeMedicineClassificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeMedicineClassificationList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeMedicineClassification);
begin
  assert(value is TFhirMedicationKnowledgeMedicineClassification);
  FhirMedicationKnowledgeMedicineClassifications[index] := value;
end;

procedure TFhirMedicationKnowledgeMedicineClassificationList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeMedicineClassification);
begin
  assert(value is TFhirMedicationKnowledgeMedicineClassification);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgePackaging }

constructor TFhirMedicationKnowledgePackaging.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgePackaging.Destroy;
begin
  FType_.free;
  FQuantity.free;
  inherited;
end;

procedure TFhirMedicationKnowledgePackaging.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgePackaging(oSource).type_.Clone;
  quantity := TFhirMedicationKnowledgePackaging(oSource).quantity.Clone;
end;

procedure TFhirMedicationKnowledgePackaging.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
end;

procedure TFhirMedicationKnowledgePackaging.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
end;

function TFhirMedicationKnowledgePackaging.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgePackaging.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgePackaging.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgePackaging.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgePackaging.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgePackaging.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgePackaging.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgePackaging.fhirType : string;
begin
  result := 'packaging';
end;

function TFhirMedicationKnowledgePackaging.Link : TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging(inherited Link);
end;

function TFhirMedicationKnowledgePackaging.Clone : TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging(inherited Clone);
end;

function TFhirMedicationKnowledgePackaging.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgePackaging;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgePackaging)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgePackaging(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(quantityElement, o.quantityElement, true);
  end;
end;

function TFhirMedicationKnowledgePackaging.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FQuantity);
end;

procedure TFhirMedicationKnowledgePackaging.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('quantity');
end;

{ TFhirMedicationKnowledgePackaging }

Procedure TFhirMedicationKnowledgePackaging.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirMedicationKnowledgePackaging.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

function TFhirMedicationKnowledgePackaging.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
end;

{ TFhirMedicationKnowledgePackagingListEnumerator }

Constructor TFhirMedicationKnowledgePackagingListEnumerator.Create(list : TFhirMedicationKnowledgePackagingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgePackagingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgePackagingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgePackagingListEnumerator.GetCurrent : TFhirMedicationKnowledgePackaging;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgePackagingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgePackagingList }
procedure TFhirMedicationKnowledgePackagingList.AddItem(value: TFhirMedicationKnowledgePackaging);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgePackaging', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgePackaging');
  add(value);
end;

function TFhirMedicationKnowledgePackagingList.Append: TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgePackagingList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgePackagingList.GetEnumerator : TFhirMedicationKnowledgePackagingListEnumerator;
begin
  result := TFhirMedicationKnowledgePackagingListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgePackagingList.Clone: TFhirMedicationKnowledgePackagingList;
begin
  result := TFhirMedicationKnowledgePackagingList(inherited Clone);
end;

function TFhirMedicationKnowledgePackagingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgePackagingList.GetItemN(index: Integer): TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgePackagingList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgePackaging;
end;
function TFhirMedicationKnowledgePackagingList.IndexOf(value: TFhirMedicationKnowledgePackaging): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgePackagingList.Insert(index: Integer): TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgePackagingList.InsertItem(index: Integer; value: TFhirMedicationKnowledgePackaging);
begin
  assert(value is TFhirMedicationKnowledgePackaging);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgePackagingList.Item(index: Integer): TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgePackagingList.Link: TFhirMedicationKnowledgePackagingList;
begin
  result := TFhirMedicationKnowledgePackagingList(inherited Link);
end;

procedure TFhirMedicationKnowledgePackagingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgePackagingList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgePackaging);
begin
  assert(value is TFhirMedicationKnowledgePackaging);
  FhirMedicationKnowledgePackagings[index] := value;
end;

procedure TFhirMedicationKnowledgePackagingList.SetItemN(index: Integer; value: TFhirMedicationKnowledgePackaging);
begin
  assert(value is TFhirMedicationKnowledgePackaging);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeDrugCharacteristic }

constructor TFhirMedicationKnowledgeDrugCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeDrugCharacteristic.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeDrugCharacteristic(oSource).type_.Clone;
  value := TFhirMedicationKnowledgeDrugCharacteristic(oSource).value.Clone;
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|string|Quantity|base64Binary', false, TFhirType, FValue.Link));{2}
end;

function TFhirMedicationKnowledgeDrugCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeDrugCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeDrugCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|string|Quantity|base64Binary'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary'])) then ValueElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary'])) then ValueElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeDrugCharacteristic.fhirType : string;
begin
  result := 'drugCharacteristic';
end;

function TFhirMedicationKnowledgeDrugCharacteristic.Link : TFhirMedicationKnowledgeDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic(inherited Link);
end;

function TFhirMedicationKnowledgeDrugCharacteristic.Clone : TFhirMedicationKnowledgeDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic(inherited Clone);
end;

function TFhirMedicationKnowledgeDrugCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeDrugCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeDrugCharacteristic)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeDrugCharacteristic(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirMedicationKnowledgeDrugCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

{ TFhirMedicationKnowledgeDrugCharacteristic }

Procedure TFhirMedicationKnowledgeDrugCharacteristic.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirMedicationKnowledgeDrugCharacteristic.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

function TFhirMedicationKnowledgeDrugCharacteristic.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirMedicationKnowledgeDrugCharacteristicListEnumerator }

Constructor TFhirMedicationKnowledgeDrugCharacteristicListEnumerator.Create(list : TFhirMedicationKnowledgeDrugCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeDrugCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeDrugCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeDrugCharacteristicListEnumerator.GetCurrent : TFhirMedicationKnowledgeDrugCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeDrugCharacteristicListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeDrugCharacteristicList }
procedure TFhirMedicationKnowledgeDrugCharacteristicList.AddItem(value: TFhirMedicationKnowledgeDrugCharacteristic);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeDrugCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeDrugCharacteristic');
  add(value);
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.Append: TFhirMedicationKnowledgeDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeDrugCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.GetEnumerator : TFhirMedicationKnowledgeDrugCharacteristicListEnumerator;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristicListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.Clone: TFhirMedicationKnowledgeDrugCharacteristicList;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristicList(inherited Clone);
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.GetItemN(index: Integer): TFhirMedicationKnowledgeDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic;
end;
function TFhirMedicationKnowledgeDrugCharacteristicList.IndexOf(value: TFhirMedicationKnowledgeDrugCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.Insert(index: Integer): TFhirMedicationKnowledgeDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeDrugCharacteristicList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeDrugCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeDrugCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.Item(index: Integer): TFhirMedicationKnowledgeDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.Link: TFhirMedicationKnowledgeDrugCharacteristicList;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristicList(inherited Link);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristicList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeDrugCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeDrugCharacteristic);
  FhirMedicationKnowledgeDrugCharacteristics[index] := value;
end;

procedure TFhirMedicationKnowledgeDrugCharacteristicList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeDrugCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeDrugCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeRegulatory }

constructor TFhirMedicationKnowledgeRegulatory.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeRegulatory.Destroy;
begin
  FRegulatoryAuthority.free;
  FSubstitutionList.Free;
  FScheduleList.Free;
  FMaxDispense.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeRegulatory.Assign(oSource : TFslObject);
begin
  inherited;
  regulatoryAuthority := TFhirMedicationKnowledgeRegulatory(oSource).regulatoryAuthority.Clone;
  if (TFhirMedicationKnowledgeRegulatory(oSource).FSubstitutionList = nil) then
  begin
    FSubstitutionList.free;
    FSubstitutionList := nil;
  end
  else
  begin
    if FSubstitutionList = nil then
      FSubstitutionList := TFhirMedicationKnowledgeRegulatorySubstitutionList.Create;
    FSubstitutionList.Assign(TFhirMedicationKnowledgeRegulatory(oSource).FSubstitutionList);
  end;
  if (TFhirMedicationKnowledgeRegulatory(oSource).FScheduleList = nil) then
  begin
    FScheduleList.free;
    FScheduleList := nil;
  end
  else
  begin
    if FScheduleList = nil then
      FScheduleList := TFhirMedicationKnowledgeRegulatoryScheduleList.Create;
    FScheduleList.Assign(TFhirMedicationKnowledgeRegulatory(oSource).FScheduleList);
  end;
  maxDispense := TFhirMedicationKnowledgeRegulatory(oSource).maxDispense.Clone;
end;

procedure TFhirMedicationKnowledgeRegulatory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'regulatoryAuthority') Then
     list.add(self.link, 'regulatoryAuthority', FRegulatoryAuthority.Link);
  if (child_name = 'substitution') Then
    list.addAll(self, 'substitution', FSubstitutionList);
  if (child_name = 'schedule') Then
    list.addAll(self, 'schedule', FScheduleList);
  if (child_name = 'maxDispense') Then
     list.add(self.link, 'maxDispense', FMaxDispense.Link);
end;

procedure TFhirMedicationKnowledgeRegulatory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'regulatoryAuthority', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FRegulatoryAuthority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'substitution', '', true, TFhirMedicationKnowledgeRegulatorySubstitution, FSubstitutionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'schedule', '', true, TFhirMedicationKnowledgeRegulatorySchedule, FScheduleList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'maxDispense', '', false, TFhirMedicationKnowledgeRegulatoryMaxDispense, FMaxDispense.Link));{2}
end;

function TFhirMedicationKnowledgeRegulatory.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'regulatoryAuthority') then
  begin
    RegulatoryAuthority := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'substitution') then
  begin
    SubstitutionList.add(propValue as TFhirMedicationKnowledgeRegulatorySubstitution){2a};
    result := propValue;
  end
  else if (propName = 'schedule') then
  begin
    ScheduleList.add(propValue as TFhirMedicationKnowledgeRegulatorySchedule){2a};
    result := propValue;
  end
  else if (propName = 'maxDispense') then
  begin
    MaxDispense := propValue as TFhirMedicationKnowledgeRegulatoryMaxDispense{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeRegulatory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'substitution') then SubstitutionList.insertItem(index, propValue as TFhirMedicationKnowledgeRegulatorySubstitution){2a}
  else if (propName = 'schedule') then ScheduleList.insertItem(index, propValue as TFhirMedicationKnowledgeRegulatorySchedule){2a}
  else inherited;
end;

function TFhirMedicationKnowledgeRegulatory.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'regulatoryAuthority') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'substitution') then result := SubstitutionList.new(){2}
  else if (propName = 'schedule') then result := ScheduleList.new(){2}
  else if (propName = 'maxDispense') then result := TFhirMedicationKnowledgeRegulatoryMaxDispense.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeRegulatory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'regulatoryAuthority') then result := 'Reference'
  else if (propName = 'substitution') then result := ''
  else if (propName = 'schedule') then result := ''
  else if (propName = 'maxDispense') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeRegulatory.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'regulatoryAuthority') then RegulatoryAuthorityElement := nil
  else if (propName = 'substitution') then deletePropertyValue('substitution', SubstitutionList, value) {2}
  else if (propName = 'schedule') then deletePropertyValue('schedule', ScheduleList, value) {2}
  else if (propName = 'maxDispense') then MaxDispenseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeRegulatory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'regulatoryAuthority') then RegulatoryAuthorityElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'substitution') then replacePropertyValue('substitution', SubstitutionList, existing, new) {2}
  else if (propName = 'schedule') then replacePropertyValue('schedule', ScheduleList, existing, new) {2}
  else if (propName = 'maxDispense') then MaxDispenseElement := new as TFhirMedicationKnowledgeRegulatoryMaxDispense{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeRegulatory.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'substitution') then SubstitutionList.move(source, destination){2a}
  else if (propName = 'schedule') then ScheduleList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeRegulatory.fhirType : string;
begin
  result := 'regulatory';
end;

function TFhirMedicationKnowledgeRegulatory.Link : TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory(inherited Link);
end;

function TFhirMedicationKnowledgeRegulatory.Clone : TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatory.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeRegulatory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeRegulatory)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeRegulatory(other);
    result := compareDeep(regulatoryAuthorityElement, o.regulatoryAuthorityElement, true) and 
      compareDeep(substitutionList, o.substitutionList, true) and compareDeep(scheduleList, o.scheduleList, true) and 
      compareDeep(maxDispenseElement, o.maxDispenseElement, true);
  end;
end;

function TFhirMedicationKnowledgeRegulatory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRegulatoryAuthority) and isEmptyProp(FsubstitutionList) and isEmptyProp(FscheduleList) and isEmptyProp(FMaxDispense);
end;

procedure TFhirMedicationKnowledgeRegulatory.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('regulatoryAuthority');
  fields.add('substitution');
  fields.add('schedule');
  fields.add('maxDispense');
end;

{ TFhirMedicationKnowledgeRegulatory }

Procedure TFhirMedicationKnowledgeRegulatory.SetRegulatoryAuthority(value : TFhirReference{TFhirOrganization});
begin
  FRegulatoryAuthority.free;
  FRegulatoryAuthority := value;
end;

Function TFhirMedicationKnowledgeRegulatory.GetSubstitutionList : TFhirMedicationKnowledgeRegulatorySubstitutionList;
begin
  if FSubstitutionList = nil then
    FSubstitutionList := TFhirMedicationKnowledgeRegulatorySubstitutionList.Create;
  result := FSubstitutionList;
end;

Function TFhirMedicationKnowledgeRegulatory.GetHasSubstitutionList : boolean;
begin
  result := (FSubstitutionList <> nil) and (FSubstitutionList.count > 0);
end;

Function TFhirMedicationKnowledgeRegulatory.GetScheduleList : TFhirMedicationKnowledgeRegulatoryScheduleList;
begin
  if FScheduleList = nil then
    FScheduleList := TFhirMedicationKnowledgeRegulatoryScheduleList.Create;
  result := FScheduleList;
end;

Function TFhirMedicationKnowledgeRegulatory.GetHasScheduleList : boolean;
begin
  result := (FScheduleList <> nil) and (FScheduleList.count > 0);
end;

Procedure TFhirMedicationKnowledgeRegulatory.SetMaxDispense(value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
  FMaxDispense.free;
  FMaxDispense := value;
end;

function TFhirMedicationKnowledgeRegulatory.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRegulatoryAuthority.sizeInBytes);
  inc(result, FsubstitutionList.sizeInBytes);
  inc(result, FscheduleList.sizeInBytes);
  inc(result, FMaxDispense.sizeInBytes);
end;

{ TFhirMedicationKnowledgeRegulatoryListEnumerator }

Constructor TFhirMedicationKnowledgeRegulatoryListEnumerator.Create(list : TFhirMedicationKnowledgeRegulatoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeRegulatoryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeRegulatoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeRegulatoryListEnumerator.GetCurrent : TFhirMedicationKnowledgeRegulatory;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeRegulatoryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeRegulatoryList }
procedure TFhirMedicationKnowledgeRegulatoryList.AddItem(value: TFhirMedicationKnowledgeRegulatory);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeRegulatory', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeRegulatory');
  add(value);
end;

function TFhirMedicationKnowledgeRegulatoryList.Append: TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatoryList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeRegulatoryList.GetEnumerator : TFhirMedicationKnowledgeRegulatoryListEnumerator;
begin
  result := TFhirMedicationKnowledgeRegulatoryListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeRegulatoryList.Clone: TFhirMedicationKnowledgeRegulatoryList;
begin
  result := TFhirMedicationKnowledgeRegulatoryList(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeRegulatoryList.GetItemN(index: Integer): TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeRegulatory;
end;
function TFhirMedicationKnowledgeRegulatoryList.IndexOf(value: TFhirMedicationKnowledgeRegulatory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeRegulatoryList.Insert(index: Integer): TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatoryList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeRegulatory);
begin
  assert(value is TFhirMedicationKnowledgeRegulatory);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeRegulatoryList.Item(index: Integer): TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatoryList.Link: TFhirMedicationKnowledgeRegulatoryList;
begin
  result := TFhirMedicationKnowledgeRegulatoryList(inherited Link);
end;

procedure TFhirMedicationKnowledgeRegulatoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeRegulatoryList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeRegulatory);
begin
  assert(value is TFhirMedicationKnowledgeRegulatory);
  FhirMedicationKnowledgeRegulatories[index] := value;
end;

procedure TFhirMedicationKnowledgeRegulatoryList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeRegulatory);
begin
  assert(value is TFhirMedicationKnowledgeRegulatory);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeRegulatorySubstitution }

constructor TFhirMedicationKnowledgeRegulatorySubstitution.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeRegulatorySubstitution.Destroy;
begin
  FType_.free;
  FAllowed.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeRegulatorySubstitution(oSource).type_.Clone;
  allowedElement := TFhirMedicationKnowledgeRegulatorySubstitution(oSource).allowedElement.Clone;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'allowed') Then
     list.add(self.link, 'allowed', FAllowed.Link);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'allowed', 'boolean', false, TFhirBoolean, FAllowed.Link));{2}
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'allowed') then
  begin
    AllowedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'allowed') then result := TFhirBoolean.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'allowed') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'allowed') then AllowedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'allowed') then AllowedElement := asBoolean(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.fhirType : string;
begin
  result := 'substitution';
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.Link : TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution(inherited Link);
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.Clone : TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeRegulatorySubstitution)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeRegulatorySubstitution(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(allowedElement, o.allowedElement, true);
  end;
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAllowed);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('allowed');
end;

{ TFhirMedicationKnowledgeRegulatorySubstitution }

Procedure TFhirMedicationKnowledgeRegulatorySubstitution.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirMedicationKnowledgeRegulatorySubstitution.SetAllowed(value : TFhirBoolean);
begin
  FAllowed.free;
  FAllowed := value;
end;

Function TFhirMedicationKnowledgeRegulatorySubstitution.GetAllowedST : Boolean;
begin
  if FAllowed = nil then
    result := false
  else
    result := FAllowed.value;
end;

Procedure TFhirMedicationKnowledgeRegulatorySubstitution.SetAllowedST(value : Boolean);
begin
  if FAllowed = nil then
    FAllowed := TFhirBoolean.create;
  FAllowed.value := value
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FAllowed.sizeInBytes);
end;

{ TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator }

Constructor TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.Create(list : TFhirMedicationKnowledgeRegulatorySubstitutionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.GetCurrent : TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeRegulatorySubstitutionList }
procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.AddItem(value: TFhirMedicationKnowledgeRegulatorySubstitution);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeRegulatorySubstitution', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeRegulatorySubstitution');
  add(value);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Append: TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.GetEnumerator : TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Clone: TFhirMedicationKnowledgeRegulatorySubstitutionList;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitutionList(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.GetItemN(index: Integer): TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution;
end;
function TFhirMedicationKnowledgeRegulatorySubstitutionList.IndexOf(value: TFhirMedicationKnowledgeRegulatorySubstitution): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Insert(index: Integer): TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeRegulatorySubstitution);
begin
  assert(value is TFhirMedicationKnowledgeRegulatorySubstitution);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Item(index: Integer): TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Link: TFhirMedicationKnowledgeRegulatorySubstitutionList;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitutionList(inherited Link);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeRegulatorySubstitution);
begin
  assert(value is TFhirMedicationKnowledgeRegulatorySubstitution);
  FhirMedicationKnowledgeRegulatorySubstitutions[index] := value;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeRegulatorySubstitution);
begin
  assert(value is TFhirMedicationKnowledgeRegulatorySubstitution);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeRegulatorySchedule }

constructor TFhirMedicationKnowledgeRegulatorySchedule.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeRegulatorySchedule.Destroy;
begin
  FSchedule.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeRegulatorySchedule.Assign(oSource : TFslObject);
begin
  inherited;
  schedule := TFhirMedicationKnowledgeRegulatorySchedule(oSource).schedule.Clone;
end;

procedure TFhirMedicationKnowledgeRegulatorySchedule.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'schedule') Then
     list.add(self.link, 'schedule', FSchedule.Link);
end;

procedure TFhirMedicationKnowledgeRegulatorySchedule.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'schedule', 'CodeableConcept', false, TFhirCodeableConcept, FSchedule.Link));{2}
end;

function TFhirMedicationKnowledgeRegulatorySchedule.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'schedule') then
  begin
    Schedule := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeRegulatorySchedule.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeRegulatorySchedule.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'schedule') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeRegulatorySchedule.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'schedule') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeRegulatorySchedule.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'schedule') then ScheduleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeRegulatorySchedule.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'schedule') then ScheduleElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeRegulatorySchedule.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeRegulatorySchedule.fhirType : string;
begin
  result := 'schedule';
end;

function TFhirMedicationKnowledgeRegulatorySchedule.Link : TFhirMedicationKnowledgeRegulatorySchedule;
begin
  result := TFhirMedicationKnowledgeRegulatorySchedule(inherited Link);
end;

function TFhirMedicationKnowledgeRegulatorySchedule.Clone : TFhirMedicationKnowledgeRegulatorySchedule;
begin
  result := TFhirMedicationKnowledgeRegulatorySchedule(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatorySchedule.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeRegulatorySchedule;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeRegulatorySchedule)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeRegulatorySchedule(other);
    result := compareDeep(scheduleElement, o.scheduleElement, true);
  end;
end;

function TFhirMedicationKnowledgeRegulatorySchedule.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSchedule);
end;

procedure TFhirMedicationKnowledgeRegulatorySchedule.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('schedule');
end;

{ TFhirMedicationKnowledgeRegulatorySchedule }

Procedure TFhirMedicationKnowledgeRegulatorySchedule.SetSchedule(value : TFhirCodeableConcept);
begin
  FSchedule.free;
  FSchedule := value;
end;

function TFhirMedicationKnowledgeRegulatorySchedule.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSchedule.sizeInBytes);
end;

{ TFhirMedicationKnowledgeRegulatoryScheduleListEnumerator }

Constructor TFhirMedicationKnowledgeRegulatoryScheduleListEnumerator.Create(list : TFhirMedicationKnowledgeRegulatoryScheduleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeRegulatoryScheduleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeRegulatoryScheduleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeRegulatoryScheduleListEnumerator.GetCurrent : TFhirMedicationKnowledgeRegulatorySchedule;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeRegulatoryScheduleListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeRegulatoryScheduleList }
procedure TFhirMedicationKnowledgeRegulatoryScheduleList.AddItem(value: TFhirMedicationKnowledgeRegulatorySchedule);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeRegulatorySchedule', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeRegulatorySchedule');
  add(value);
end;

function TFhirMedicationKnowledgeRegulatoryScheduleList.Append: TFhirMedicationKnowledgeRegulatorySchedule;
begin
  result := TFhirMedicationKnowledgeRegulatorySchedule.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatoryScheduleList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeRegulatoryScheduleList.GetEnumerator : TFhirMedicationKnowledgeRegulatoryScheduleListEnumerator;
begin
  result := TFhirMedicationKnowledgeRegulatoryScheduleListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeRegulatoryScheduleList.Clone: TFhirMedicationKnowledgeRegulatoryScheduleList;
begin
  result := TFhirMedicationKnowledgeRegulatoryScheduleList(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatoryScheduleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeRegulatoryScheduleList.GetItemN(index: Integer): TFhirMedicationKnowledgeRegulatorySchedule;
begin
  result := TFhirMedicationKnowledgeRegulatorySchedule(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatoryScheduleList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeRegulatorySchedule;
end;
function TFhirMedicationKnowledgeRegulatoryScheduleList.IndexOf(value: TFhirMedicationKnowledgeRegulatorySchedule): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeRegulatoryScheduleList.Insert(index: Integer): TFhirMedicationKnowledgeRegulatorySchedule;
begin
  result := TFhirMedicationKnowledgeRegulatorySchedule.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatoryScheduleList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeRegulatorySchedule);
begin
  assert(value is TFhirMedicationKnowledgeRegulatorySchedule);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeRegulatoryScheduleList.Item(index: Integer): TFhirMedicationKnowledgeRegulatorySchedule;
begin
  result := TFhirMedicationKnowledgeRegulatorySchedule(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatoryScheduleList.Link: TFhirMedicationKnowledgeRegulatoryScheduleList;
begin
  result := TFhirMedicationKnowledgeRegulatoryScheduleList(inherited Link);
end;

procedure TFhirMedicationKnowledgeRegulatoryScheduleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeRegulatoryScheduleList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeRegulatorySchedule);
begin
  assert(value is TFhirMedicationKnowledgeRegulatorySchedule);
  FhirMedicationKnowledgeRegulatorySchedules[index] := value;
end;

procedure TFhirMedicationKnowledgeRegulatoryScheduleList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeRegulatorySchedule);
begin
  assert(value is TFhirMedicationKnowledgeRegulatorySchedule);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeRegulatoryMaxDispense }

constructor TFhirMedicationKnowledgeRegulatoryMaxDispense.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeRegulatoryMaxDispense.Destroy;
begin
  FQuantity.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.Assign(oSource : TFslObject);
begin
  inherited;
  quantity := TFhirMedicationKnowledgeRegulatoryMaxDispense(oSource).quantity.Clone;
  period := TFhirMedicationKnowledgeRegulatoryMaxDispense(oSource).period.Clone;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Duration', false, TFhirDuration, FPeriod.Link));{2}
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirDuration{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'period') then result := TFhirDuration.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'period') then result := 'Duration'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'period') then PeriodElement := new as TFhirDuration{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.fhirType : string;
begin
  result := 'maxDispense';
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.Link : TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense(inherited Link);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.Clone : TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeRegulatoryMaxDispense)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeRegulatoryMaxDispense(other);
    result := compareDeep(quantityElement, o.quantityElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FQuantity) and isEmptyProp(FPeriod);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('quantity');
  fields.add('period');
end;

{ TFhirMedicationKnowledgeRegulatoryMaxDispense }

Procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.SetPeriod(value : TFhirDuration);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FQuantity.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator }

Constructor TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.Create(list : TFhirMedicationKnowledgeRegulatoryMaxDispenseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.GetCurrent : TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeRegulatoryMaxDispenseList }
procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.AddItem(value: TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeRegulatoryMaxDispense', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeRegulatoryMaxDispense');
  add(value);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Append: TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.GetEnumerator : TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Clone: TFhirMedicationKnowledgeRegulatoryMaxDispenseList;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispenseList(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.GetItemN(index: Integer): TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense;
end;
function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.IndexOf(value: TFhirMedicationKnowledgeRegulatoryMaxDispense): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Insert(index: Integer): TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
  assert(value is TFhirMedicationKnowledgeRegulatoryMaxDispense);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Item(index: Integer): TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Link: TFhirMedicationKnowledgeRegulatoryMaxDispenseList;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispenseList(inherited Link);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
  assert(value is TFhirMedicationKnowledgeRegulatoryMaxDispense);
  FhirMedicationKnowledgeRegulatoryMaxDispenses[index] := value;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
  assert(value is TFhirMedicationKnowledgeRegulatoryMaxDispense);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeKinetics }

constructor TFhirMedicationKnowledgeKinetics.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeKinetics.Destroy;
begin
  FAreaUnderCurveList.Free;
  FLethalDose50List.Free;
  FHalfLifePeriod.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeKinetics.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationKnowledgeKinetics(oSource).FAreaUnderCurveList = nil) then
  begin
    FAreaUnderCurveList.free;
    FAreaUnderCurveList := nil;
  end
  else
  begin
    if FAreaUnderCurveList = nil then
      FAreaUnderCurveList := TFhirQuantityList.Create;
    FAreaUnderCurveList.Assign(TFhirMedicationKnowledgeKinetics(oSource).FAreaUnderCurveList);
  end;
  if (TFhirMedicationKnowledgeKinetics(oSource).FLethalDose50List = nil) then
  begin
    FLethalDose50List.free;
    FLethalDose50List := nil;
  end
  else
  begin
    if FLethalDose50List = nil then
      FLethalDose50List := TFhirQuantityList.Create;
    FLethalDose50List.Assign(TFhirMedicationKnowledgeKinetics(oSource).FLethalDose50List);
  end;
  halfLifePeriod := TFhirMedicationKnowledgeKinetics(oSource).halfLifePeriod.Clone;
end;

procedure TFhirMedicationKnowledgeKinetics.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'areaUnderCurve') Then
    list.addAll(self, 'areaUnderCurve', FAreaUnderCurveList);
  if (child_name = 'lethalDose50') Then
    list.addAll(self, 'lethalDose50', FLethalDose50List);
  if (child_name = 'halfLifePeriod') Then
     list.add(self.link, 'halfLifePeriod', FHalfLifePeriod.Link);
end;

procedure TFhirMedicationKnowledgeKinetics.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'areaUnderCurve', 'Quantity', true, TFhirQuantity, FAreaUnderCurveList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'lethalDose50', 'Quantity', true, TFhirQuantity, FLethalDose50List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'halfLifePeriod', 'Duration', false, TFhirDuration, FHalfLifePeriod.Link));{2}
end;

function TFhirMedicationKnowledgeKinetics.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'areaUnderCurve') then
  begin
    AreaUnderCurveList.add(propValue as TFhirQuantity){2a};
    result := propValue;
  end
  else if (propName = 'lethalDose50') then
  begin
    LethalDose50List.add(propValue as TFhirQuantity){2a};
    result := propValue;
  end
  else if (propName = 'halfLifePeriod') then
  begin
    HalfLifePeriod := propValue as TFhirDuration{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeKinetics.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'areaUnderCurve') then AreaUnderCurveList.insertItem(index, propValue as TFhirQuantity){2a}
  else if (propName = 'lethalDose50') then LethalDose50List.insertItem(index, propValue as TFhirQuantity){2a}
  else inherited;
end;

function TFhirMedicationKnowledgeKinetics.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'areaUnderCurve') then result := AreaUnderCurveList.new(){2}
  else if (propName = 'lethalDose50') then result := LethalDose50List.new(){2}
  else if (propName = 'halfLifePeriod') then result := TFhirDuration.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeKinetics.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'areaUnderCurve') then result := 'Quantity'
  else if (propName = 'lethalDose50') then result := 'Quantity'
  else if (propName = 'halfLifePeriod') then result := 'Duration'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeKinetics.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'areaUnderCurve') then deletePropertyValue('areaUnderCurve', AreaUnderCurveList, value) {2}
  else if (propName = 'lethalDose50') then deletePropertyValue('lethalDose50', LethalDose50List, value) {2}
  else if (propName = 'halfLifePeriod') then HalfLifePeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeKinetics.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'areaUnderCurve') then replacePropertyValue('areaUnderCurve', AreaUnderCurveList, existing, new) {2}
  else if (propName = 'lethalDose50') then replacePropertyValue('lethalDose50', LethalDose50List, existing, new) {2}
  else if (propName = 'halfLifePeriod') then HalfLifePeriodElement := new as TFhirDuration{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeKinetics.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'areaUnderCurve') then AreaUnderCurveList.move(source, destination){2a}
  else if (propName = 'lethalDose50') then LethalDose50List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeKinetics.fhirType : string;
begin
  result := 'kinetics';
end;

function TFhirMedicationKnowledgeKinetics.Link : TFhirMedicationKnowledgeKinetics;
begin
  result := TFhirMedicationKnowledgeKinetics(inherited Link);
end;

function TFhirMedicationKnowledgeKinetics.Clone : TFhirMedicationKnowledgeKinetics;
begin
  result := TFhirMedicationKnowledgeKinetics(inherited Clone);
end;

function TFhirMedicationKnowledgeKinetics.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeKinetics;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeKinetics)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeKinetics(other);
    result := compareDeep(areaUnderCurveList, o.areaUnderCurveList, true) and compareDeep(lethalDose50List, o.lethalDose50List, true) and 
      compareDeep(halfLifePeriodElement, o.halfLifePeriodElement, true);
  end;
end;

function TFhirMedicationKnowledgeKinetics.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FareaUnderCurveList) and isEmptyProp(FlethalDose50List) and isEmptyProp(FHalfLifePeriod);
end;

procedure TFhirMedicationKnowledgeKinetics.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('areaUnderCurve');
  fields.add('lethalDose50');
  fields.add('halfLifePeriod');
end;

{ TFhirMedicationKnowledgeKinetics }

Function TFhirMedicationKnowledgeKinetics.GetAreaUnderCurveList : TFhirQuantityList;
begin
  if FAreaUnderCurveList = nil then
    FAreaUnderCurveList := TFhirQuantityList.Create;
  result := FAreaUnderCurveList;
end;

Function TFhirMedicationKnowledgeKinetics.GetHasAreaUnderCurveList : boolean;
begin
  result := (FAreaUnderCurveList <> nil) and (FAreaUnderCurveList.count > 0);
end;

Function TFhirMedicationKnowledgeKinetics.GetLethalDose50List : TFhirQuantityList;
begin
  if FLethalDose50List = nil then
    FLethalDose50List := TFhirQuantityList.Create;
  result := FLethalDose50List;
end;

Function TFhirMedicationKnowledgeKinetics.GetHasLethalDose50List : boolean;
begin
  result := (FLethalDose50List <> nil) and (FLethalDose50List.count > 0);
end;

Procedure TFhirMedicationKnowledgeKinetics.SetHalfLifePeriod(value : TFhirDuration);
begin
  FHalfLifePeriod.free;
  FHalfLifePeriod := value;
end;

function TFhirMedicationKnowledgeKinetics.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FareaUnderCurveList.sizeInBytes);
  inc(result, FlethalDose50List.sizeInBytes);
  inc(result, FHalfLifePeriod.sizeInBytes);
end;

{ TFhirMedicationKnowledgeKineticsListEnumerator }

Constructor TFhirMedicationKnowledgeKineticsListEnumerator.Create(list : TFhirMedicationKnowledgeKineticsList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeKineticsListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeKineticsListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeKineticsListEnumerator.GetCurrent : TFhirMedicationKnowledgeKinetics;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeKineticsListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeKineticsList }
procedure TFhirMedicationKnowledgeKineticsList.AddItem(value: TFhirMedicationKnowledgeKinetics);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeKinetics', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeKinetics');
  add(value);
end;

function TFhirMedicationKnowledgeKineticsList.Append: TFhirMedicationKnowledgeKinetics;
begin
  result := TFhirMedicationKnowledgeKinetics.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeKineticsList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeKineticsList.GetEnumerator : TFhirMedicationKnowledgeKineticsListEnumerator;
begin
  result := TFhirMedicationKnowledgeKineticsListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeKineticsList.Clone: TFhirMedicationKnowledgeKineticsList;
begin
  result := TFhirMedicationKnowledgeKineticsList(inherited Clone);
end;

function TFhirMedicationKnowledgeKineticsList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeKineticsList.GetItemN(index: Integer): TFhirMedicationKnowledgeKinetics;
begin
  result := TFhirMedicationKnowledgeKinetics(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeKineticsList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeKinetics;
end;
function TFhirMedicationKnowledgeKineticsList.IndexOf(value: TFhirMedicationKnowledgeKinetics): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeKineticsList.Insert(index: Integer): TFhirMedicationKnowledgeKinetics;
begin
  result := TFhirMedicationKnowledgeKinetics.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeKineticsList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeKinetics);
begin
  assert(value is TFhirMedicationKnowledgeKinetics);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeKineticsList.Item(index: Integer): TFhirMedicationKnowledgeKinetics;
begin
  result := TFhirMedicationKnowledgeKinetics(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeKineticsList.Link: TFhirMedicationKnowledgeKineticsList;
begin
  result := TFhirMedicationKnowledgeKineticsList(inherited Link);
end;

procedure TFhirMedicationKnowledgeKineticsList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeKineticsList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeKinetics);
begin
  assert(value is TFhirMedicationKnowledgeKinetics);
  FhirMedicationKnowledgeKinetics[index] := value;
end;

procedure TFhirMedicationKnowledgeKineticsList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeKinetics);
begin
  assert(value is TFhirMedicationKnowledgeKinetics);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledge }

constructor TFhirMedicationKnowledge.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledge.Destroy;
begin
  FCode.free;
  FStatus.free;
  FManufacturer.free;
  FDoseForm.free;
  FAmount.free;
  FSynonymList.Free;
  FRelatedMedicationKnowledgeList.Free;
  FAssociatedMedicationList.Free;
  FProductTypeList.Free;
  FMonographList.Free;
  FIngredientList.Free;
  FPreparationInstruction.free;
  FIntendedRouteList.Free;
  FCostList.Free;
  FMonitoringProgramList.Free;
  FAdministrationGuidelinesList.Free;
  FMedicineClassificationList.Free;
  FPackaging.free;
  FDrugCharacteristicList.Free;
  FContraindicationList.Free;
  FRegulatoryList.Free;
  FKineticsList.Free;
  inherited;
end;

function TFhirMedicationKnowledge.GetResourceType : TFhirResourceType;
begin
  result := frtMedicationKnowledge;
end;

procedure TFhirMedicationKnowledge.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMedicationKnowledge(oSource).code.Clone;
  statusElement := TFhirMedicationKnowledge(oSource).statusElement.Clone;
  manufacturer := TFhirMedicationKnowledge(oSource).manufacturer.Clone;
  doseForm := TFhirMedicationKnowledge(oSource).doseForm.Clone;
  amount := TFhirMedicationKnowledge(oSource).amount.Clone;
  if (TFhirMedicationKnowledge(oSource).FSynonymList = nil) then
  begin
    FSynonymList.free;
    FSynonymList := nil;
  end
  else
  begin
    if FSynonymList = nil then
      FSynonymList := TFhirStringList.Create;
    FSynonymList.Assign(TFhirMedicationKnowledge(oSource).FSynonymList);
  end;
  if (TFhirMedicationKnowledge(oSource).FRelatedMedicationKnowledgeList = nil) then
  begin
    FRelatedMedicationKnowledgeList.free;
    FRelatedMedicationKnowledgeList := nil;
  end
  else
  begin
    if FRelatedMedicationKnowledgeList = nil then
      FRelatedMedicationKnowledgeList := TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Create;
    FRelatedMedicationKnowledgeList.Assign(TFhirMedicationKnowledge(oSource).FRelatedMedicationKnowledgeList);
  end;
  if (TFhirMedicationKnowledge(oSource).FAssociatedMedicationList = nil) then
  begin
    FAssociatedMedicationList.free;
    FAssociatedMedicationList := nil;
  end
  else
  begin
    if FAssociatedMedicationList = nil then
      FAssociatedMedicationList := TFhirReferenceList{TFhirMedication}.Create;
    FAssociatedMedicationList.Assign(TFhirMedicationKnowledge(oSource).FAssociatedMedicationList);
  end;
  if (TFhirMedicationKnowledge(oSource).FProductTypeList = nil) then
  begin
    FProductTypeList.free;
    FProductTypeList := nil;
  end
  else
  begin
    if FProductTypeList = nil then
      FProductTypeList := TFhirCodeableConceptList.Create;
    FProductTypeList.Assign(TFhirMedicationKnowledge(oSource).FProductTypeList);
  end;
  if (TFhirMedicationKnowledge(oSource).FMonographList = nil) then
  begin
    FMonographList.free;
    FMonographList := nil;
  end
  else
  begin
    if FMonographList = nil then
      FMonographList := TFhirMedicationKnowledgeMonographList.Create;
    FMonographList.Assign(TFhirMedicationKnowledge(oSource).FMonographList);
  end;
  if (TFhirMedicationKnowledge(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirMedicationKnowledgeIngredientList.Create;
    FIngredientList.Assign(TFhirMedicationKnowledge(oSource).FIngredientList);
  end;
  preparationInstructionElement := TFhirMedicationKnowledge(oSource).preparationInstructionElement.Clone;
  if (TFhirMedicationKnowledge(oSource).FIntendedRouteList = nil) then
  begin
    FIntendedRouteList.free;
    FIntendedRouteList := nil;
  end
  else
  begin
    if FIntendedRouteList = nil then
      FIntendedRouteList := TFhirCodeableConceptList.Create;
    FIntendedRouteList.Assign(TFhirMedicationKnowledge(oSource).FIntendedRouteList);
  end;
  if (TFhirMedicationKnowledge(oSource).FCostList = nil) then
  begin
    FCostList.free;
    FCostList := nil;
  end
  else
  begin
    if FCostList = nil then
      FCostList := TFhirMedicationKnowledgeCostList.Create;
    FCostList.Assign(TFhirMedicationKnowledge(oSource).FCostList);
  end;
  if (TFhirMedicationKnowledge(oSource).FMonitoringProgramList = nil) then
  begin
    FMonitoringProgramList.free;
    FMonitoringProgramList := nil;
  end
  else
  begin
    if FMonitoringProgramList = nil then
      FMonitoringProgramList := TFhirMedicationKnowledgeMonitoringProgramList.Create;
    FMonitoringProgramList.Assign(TFhirMedicationKnowledge(oSource).FMonitoringProgramList);
  end;
  if (TFhirMedicationKnowledge(oSource).FAdministrationGuidelinesList = nil) then
  begin
    FAdministrationGuidelinesList.free;
    FAdministrationGuidelinesList := nil;
  end
  else
  begin
    if FAdministrationGuidelinesList = nil then
      FAdministrationGuidelinesList := TFhirMedicationKnowledgeAdministrationGuidelinesList.Create;
    FAdministrationGuidelinesList.Assign(TFhirMedicationKnowledge(oSource).FAdministrationGuidelinesList);
  end;
  if (TFhirMedicationKnowledge(oSource).FMedicineClassificationList = nil) then
  begin
    FMedicineClassificationList.free;
    FMedicineClassificationList := nil;
  end
  else
  begin
    if FMedicineClassificationList = nil then
      FMedicineClassificationList := TFhirMedicationKnowledgeMedicineClassificationList.Create;
    FMedicineClassificationList.Assign(TFhirMedicationKnowledge(oSource).FMedicineClassificationList);
  end;
  packaging := TFhirMedicationKnowledge(oSource).packaging.Clone;
  if (TFhirMedicationKnowledge(oSource).FDrugCharacteristicList = nil) then
  begin
    FDrugCharacteristicList.free;
    FDrugCharacteristicList := nil;
  end
  else
  begin
    if FDrugCharacteristicList = nil then
      FDrugCharacteristicList := TFhirMedicationKnowledgeDrugCharacteristicList.Create;
    FDrugCharacteristicList.Assign(TFhirMedicationKnowledge(oSource).FDrugCharacteristicList);
  end;
  if (TFhirMedicationKnowledge(oSource).FContraindicationList = nil) then
  begin
    FContraindicationList.free;
    FContraindicationList := nil;
  end
  else
  begin
    if FContraindicationList = nil then
      FContraindicationList := TFhirReferenceList{TFhirDetectedIssue}.Create;
    FContraindicationList.Assign(TFhirMedicationKnowledge(oSource).FContraindicationList);
  end;
  if (TFhirMedicationKnowledge(oSource).FRegulatoryList = nil) then
  begin
    FRegulatoryList.free;
    FRegulatoryList := nil;
  end
  else
  begin
    if FRegulatoryList = nil then
      FRegulatoryList := TFhirMedicationKnowledgeRegulatoryList.Create;
    FRegulatoryList.Assign(TFhirMedicationKnowledge(oSource).FRegulatoryList);
  end;
  if (TFhirMedicationKnowledge(oSource).FKineticsList = nil) then
  begin
    FKineticsList.free;
    FKineticsList := nil;
  end
  else
  begin
    if FKineticsList = nil then
      FKineticsList := TFhirMedicationKnowledgeKineticsList.Create;
    FKineticsList.Assign(TFhirMedicationKnowledge(oSource).FKineticsList);
  end;
end;

procedure TFhirMedicationKnowledge.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer', FManufacturer.Link);
  if (child_name = 'doseForm') Then
     list.add(self.link, 'doseForm', FDoseForm.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'synonym') Then
    list.addAll(self, 'synonym', FSynonymList);
  if (child_name = 'relatedMedicationKnowledge') Then
    list.addAll(self, 'relatedMedicationKnowledge', FRelatedMedicationKnowledgeList);
  if (child_name = 'associatedMedication') Then
    list.addAll(self, 'associatedMedication', FAssociatedMedicationList);
  if (child_name = 'productType') Then
    list.addAll(self, 'productType', FProductTypeList);
  if (child_name = 'monograph') Then
    list.addAll(self, 'monograph', FMonographList);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'preparationInstruction') Then
     list.add(self.link, 'preparationInstruction', FPreparationInstruction.Link);
  if (child_name = 'intendedRoute') Then
    list.addAll(self, 'intendedRoute', FIntendedRouteList);
  if (child_name = 'cost') Then
    list.addAll(self, 'cost', FCostList);
  if (child_name = 'monitoringProgram') Then
    list.addAll(self, 'monitoringProgram', FMonitoringProgramList);
  if (child_name = 'administrationGuidelines') Then
    list.addAll(self, 'administrationGuidelines', FAdministrationGuidelinesList);
  if (child_name = 'medicineClassification') Then
    list.addAll(self, 'medicineClassification', FMedicineClassificationList);
  if (child_name = 'packaging') Then
     list.add(self.link, 'packaging', FPackaging.Link);
  if (child_name = 'drugCharacteristic') Then
    list.addAll(self, 'drugCharacteristic', FDrugCharacteristicList);
  if (child_name = 'contraindication') Then
    list.addAll(self, 'contraindication', FContraindicationList);
  if (child_name = 'regulatory') Then
    list.addAll(self, 'regulatory', FRegulatoryList);
  if (child_name = 'kinetics') Then
    list.addAll(self, 'kinetics', FKineticsList);
end;

procedure TFhirMedicationKnowledge.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirCode, FStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FManufacturer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseForm', 'CodeableConcept', false, TFhirCodeableConcept, FDoseForm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'synonym', 'string', true, TFhirString, FSynonymList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relatedMedicationKnowledge', '', true, TFhirMedicationKnowledgeRelatedMedicationKnowledge, FRelatedMedicationKnowledgeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'associatedMedication', 'Reference(Medication)', true, TFhirReference{TFhirMedication}, FAssociatedMedicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'productType', 'CodeableConcept', true, TFhirCodeableConcept, FProductTypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'monograph', '', true, TFhirMedicationKnowledgeMonograph, FMonographList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'ingredient', '', true, TFhirMedicationKnowledgeIngredient, FIngredientList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'preparationInstruction', 'markdown', false, TFhirMarkdown, FPreparationInstruction.Link));{2}
  oList.add(TFHIRProperty.create(self, 'intendedRoute', 'CodeableConcept', true, TFhirCodeableConcept, FIntendedRouteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'cost', '', true, TFhirMedicationKnowledgeCost, FCostList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'monitoringProgram', '', true, TFhirMedicationKnowledgeMonitoringProgram, FMonitoringProgramList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'administrationGuidelines', '', true, TFhirMedicationKnowledgeAdministrationGuidelines, FAdministrationGuidelinesList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'medicineClassification', '', true, TFhirMedicationKnowledgeMedicineClassification, FMedicineClassificationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'packaging', '', false, TFhirMedicationKnowledgePackaging, FPackaging.Link));{2}
  oList.add(TFHIRProperty.create(self, 'drugCharacteristic', '', true, TFhirMedicationKnowledgeDrugCharacteristic, FDrugCharacteristicList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'contraindication', 'Reference(DetectedIssue)', true, TFhirReference{TFhirDetectedIssue}, FContraindicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'regulatory', '', true, TFhirMedicationKnowledgeRegulatory, FRegulatoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'kinetics', '', true, TFhirMedicationKnowledgeKinetics, FKineticsList.Link)){3};
end;

function TFhirMedicationKnowledge.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    Manufacturer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'doseForm') then
  begin
    DoseForm := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'synonym') then
  begin
    SynonymList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'relatedMedicationKnowledge') then
  begin
    RelatedMedicationKnowledgeList.add(propValue as TFhirMedicationKnowledgeRelatedMedicationKnowledge){2a};
    result := propValue;
  end
  else if (propName = 'associatedMedication') then
  begin
    AssociatedMedicationList.add(propValue as TFhirReference{TFhirMedication}){2a};
    result := propValue;
  end
  else if (propName = 'productType') then
  begin
    ProductTypeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'monograph') then
  begin
    MonographList.add(propValue as TFhirMedicationKnowledgeMonograph){2a};
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirMedicationKnowledgeIngredient){2a};
    result := propValue;
  end
  else if (propName = 'preparationInstruction') then
  begin
    PreparationInstructionElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'intendedRoute') then
  begin
    IntendedRouteList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'cost') then
  begin
    CostList.add(propValue as TFhirMedicationKnowledgeCost){2a};
    result := propValue;
  end
  else if (propName = 'monitoringProgram') then
  begin
    MonitoringProgramList.add(propValue as TFhirMedicationKnowledgeMonitoringProgram){2a};
    result := propValue;
  end
  else if (propName = 'administrationGuidelines') then
  begin
    AdministrationGuidelinesList.add(propValue as TFhirMedicationKnowledgeAdministrationGuidelines){2a};
    result := propValue;
  end
  else if (propName = 'medicineClassification') then
  begin
    MedicineClassificationList.add(propValue as TFhirMedicationKnowledgeMedicineClassification){2a};
    result := propValue;
  end
  else if (propName = 'packaging') then
  begin
    Packaging := propValue as TFhirMedicationKnowledgePackaging{4b};
    result := propValue;
  end
  else if (propName = 'drugCharacteristic') then
  begin
    DrugCharacteristicList.add(propValue as TFhirMedicationKnowledgeDrugCharacteristic){2a};
    result := propValue;
  end
  else if (propName = 'contraindication') then
  begin
    ContraindicationList.add(propValue as TFhirReference{TFhirDetectedIssue}){2a};
    result := propValue;
  end
  else if (propName = 'regulatory') then
  begin
    RegulatoryList.add(propValue as TFhirMedicationKnowledgeRegulatory){2a};
    result := propValue;
  end
  else if (propName = 'kinetics') then
  begin
    KineticsList.add(propValue as TFhirMedicationKnowledgeKinetics){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedicationKnowledge.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'synonym') then SynonymList.insertItem(index, asString(propValue)){2}
  else if (propName = 'relatedMedicationKnowledge') then RelatedMedicationKnowledgeList.insertItem(index, propValue as TFhirMedicationKnowledgeRelatedMedicationKnowledge){2a}
  else if (propName = 'associatedMedication') then AssociatedMedicationList.insertItem(index, propValue as TFhirReference{TFhirMedication}){2a}
  else if (propName = 'productType') then ProductTypeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'monograph') then MonographList.insertItem(index, propValue as TFhirMedicationKnowledgeMonograph){2a}
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirMedicationKnowledgeIngredient){2a}
  else if (propName = 'intendedRoute') then IntendedRouteList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'cost') then CostList.insertItem(index, propValue as TFhirMedicationKnowledgeCost){2a}
  else if (propName = 'monitoringProgram') then MonitoringProgramList.insertItem(index, propValue as TFhirMedicationKnowledgeMonitoringProgram){2a}
  else if (propName = 'administrationGuidelines') then AdministrationGuidelinesList.insertItem(index, propValue as TFhirMedicationKnowledgeAdministrationGuidelines){2a}
  else if (propName = 'medicineClassification') then MedicineClassificationList.insertItem(index, propValue as TFhirMedicationKnowledgeMedicineClassification){2a}
  else if (propName = 'drugCharacteristic') then DrugCharacteristicList.insertItem(index, propValue as TFhirMedicationKnowledgeDrugCharacteristic){2a}
  else if (propName = 'contraindication') then ContraindicationList.insertItem(index, propValue as TFhirReference{TFhirDetectedIssue}){2a}
  else if (propName = 'regulatory') then RegulatoryList.insertItem(index, propValue as TFhirMedicationKnowledgeRegulatory){2a}
  else if (propName = 'kinetics') then KineticsList.insertItem(index, propValue as TFhirMedicationKnowledgeKinetics){2a}
  else inherited;
end;

function TFhirMedicationKnowledge.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'status') then result := TFhirCode.create() {5b}
  else if (propName = 'manufacturer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'doseForm') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'amount') then result := TFhirQuantity.create(){4b}
  else if (propName = 'synonym') then result := SynonymList.new(){2}
  else if (propName = 'relatedMedicationKnowledge') then result := RelatedMedicationKnowledgeList.new(){2}
  else if (propName = 'associatedMedication') then result := AssociatedMedicationList.new(){2}
  else if (propName = 'productType') then result := ProductTypeList.new(){2}
  else if (propName = 'monograph') then result := MonographList.new(){2}
  else if (propName = 'ingredient') then result := IngredientList.new(){2}
  else if (propName = 'preparationInstruction') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'intendedRoute') then result := IntendedRouteList.new(){2}
  else if (propName = 'cost') then result := CostList.new(){2}
  else if (propName = 'monitoringProgram') then result := MonitoringProgramList.new(){2}
  else if (propName = 'administrationGuidelines') then result := AdministrationGuidelinesList.new(){2}
  else if (propName = 'medicineClassification') then result := MedicineClassificationList.new(){2}
  else if (propName = 'packaging') then result := TFhirMedicationKnowledgePackaging.create(){4b}
  else if (propName = 'drugCharacteristic') then result := DrugCharacteristicList.new(){2}
  else if (propName = 'contraindication') then result := ContraindicationList.new(){2}
  else if (propName = 'regulatory') then result := RegulatoryList.new(){2}
  else if (propName = 'kinetics') then result := KineticsList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledge.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'doseForm') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Quantity'
  else if (propName = 'synonym') then result := 'string'
  else if (propName = 'relatedMedicationKnowledge') then result := ''
  else if (propName = 'associatedMedication') then result := 'Reference'
  else if (propName = 'productType') then result := 'CodeableConcept'
  else if (propName = 'monograph') then result := ''
  else if (propName = 'ingredient') then result := ''
  else if (propName = 'preparationInstruction') then result := 'markdown'
  else if (propName = 'intendedRoute') then result := 'CodeableConcept'
  else if (propName = 'cost') then result := ''
  else if (propName = 'monitoringProgram') then result := ''
  else if (propName = 'administrationGuidelines') then result := ''
  else if (propName = 'medicineClassification') then result := ''
  else if (propName = 'packaging') then result := ''
  else if (propName = 'drugCharacteristic') then result := ''
  else if (propName = 'contraindication') then result := 'Reference'
  else if (propName = 'regulatory') then result := ''
  else if (propName = 'kinetics') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledge.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'manufacturer') then ManufacturerElement := nil
  else if (propName = 'doseForm') then DoseFormElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'synonym') then deletePropertyValue('synonym', SynonymList, value) {2}
  else if (propName = 'relatedMedicationKnowledge') then deletePropertyValue('relatedMedicationKnowledge', RelatedMedicationKnowledgeList, value) {2}
  else if (propName = 'associatedMedication') then deletePropertyValue('associatedMedication', AssociatedMedicationList, value) {2}
  else if (propName = 'productType') then deletePropertyValue('productType', ProductTypeList, value) {2}
  else if (propName = 'monograph') then deletePropertyValue('monograph', MonographList, value) {2}
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value) {2}
  else if (propName = 'preparationInstruction') then PreparationInstructionElement := nil
  else if (propName = 'intendedRoute') then deletePropertyValue('intendedRoute', IntendedRouteList, value) {2}
  else if (propName = 'cost') then deletePropertyValue('cost', CostList, value) {2}
  else if (propName = 'monitoringProgram') then deletePropertyValue('monitoringProgram', MonitoringProgramList, value) {2}
  else if (propName = 'administrationGuidelines') then deletePropertyValue('administrationGuidelines', AdministrationGuidelinesList, value) {2}
  else if (propName = 'medicineClassification') then deletePropertyValue('medicineClassification', MedicineClassificationList, value) {2}
  else if (propName = 'packaging') then PackagingElement := nil
  else if (propName = 'drugCharacteristic') then deletePropertyValue('drugCharacteristic', DrugCharacteristicList, value) {2}
  else if (propName = 'contraindication') then deletePropertyValue('contraindication', ContraindicationList, value) {2}
  else if (propName = 'regulatory') then deletePropertyValue('regulatory', RegulatoryList, value) {2}
  else if (propName = 'kinetics') then deletePropertyValue('kinetics', KineticsList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledge.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'status') then StatusElement := asCode(new){5b}
  else if (propName = 'manufacturer') then ManufacturerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'doseForm') then DoseFormElement := new as TFhirCodeableConcept{4}
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity{4}
  else if (propName = 'synonym') then replacePropertyValue('synonym', SynonymList, existing, new) {2}
  else if (propName = 'relatedMedicationKnowledge') then replacePropertyValue('relatedMedicationKnowledge', RelatedMedicationKnowledgeList, existing, new) {2}
  else if (propName = 'associatedMedication') then replacePropertyValue('associatedMedication', AssociatedMedicationList, existing, new) {2}
  else if (propName = 'productType') then replacePropertyValue('productType', ProductTypeList, existing, new) {2}
  else if (propName = 'monograph') then replacePropertyValue('monograph', MonographList, existing, new) {2}
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new) {2}
  else if (propName = 'preparationInstruction') then PreparationInstructionElement := asMarkdown(new){5b}
  else if (propName = 'intendedRoute') then replacePropertyValue('intendedRoute', IntendedRouteList, existing, new) {2}
  else if (propName = 'cost') then replacePropertyValue('cost', CostList, existing, new) {2}
  else if (propName = 'monitoringProgram') then replacePropertyValue('monitoringProgram', MonitoringProgramList, existing, new) {2}
  else if (propName = 'administrationGuidelines') then replacePropertyValue('administrationGuidelines', AdministrationGuidelinesList, existing, new) {2}
  else if (propName = 'medicineClassification') then replacePropertyValue('medicineClassification', MedicineClassificationList, existing, new) {2}
  else if (propName = 'packaging') then PackagingElement := new as TFhirMedicationKnowledgePackaging{4}
  else if (propName = 'drugCharacteristic') then replacePropertyValue('drugCharacteristic', DrugCharacteristicList, existing, new) {2}
  else if (propName = 'contraindication') then replacePropertyValue('contraindication', ContraindicationList, existing, new) {2}
  else if (propName = 'regulatory') then replacePropertyValue('regulatory', RegulatoryList, existing, new) {2}
  else if (propName = 'kinetics') then replacePropertyValue('kinetics', KineticsList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledge.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'synonym') then SynonymList.move(source, destination){2}
  else if (propName = 'relatedMedicationKnowledge') then RelatedMedicationKnowledgeList.move(source, destination){2a}
  else if (propName = 'associatedMedication') then AssociatedMedicationList.move(source, destination){2a}
  else if (propName = 'productType') then ProductTypeList.move(source, destination){2a}
  else if (propName = 'monograph') then MonographList.move(source, destination){2a}
  else if (propName = 'ingredient') then IngredientList.move(source, destination){2a}
  else if (propName = 'intendedRoute') then IntendedRouteList.move(source, destination){2a}
  else if (propName = 'cost') then CostList.move(source, destination){2a}
  else if (propName = 'monitoringProgram') then MonitoringProgramList.move(source, destination){2a}
  else if (propName = 'administrationGuidelines') then AdministrationGuidelinesList.move(source, destination){2a}
  else if (propName = 'medicineClassification') then MedicineClassificationList.move(source, destination){2a}
  else if (propName = 'drugCharacteristic') then DrugCharacteristicList.move(source, destination){2a}
  else if (propName = 'contraindication') then ContraindicationList.move(source, destination){2a}
  else if (propName = 'regulatory') then RegulatoryList.move(source, destination){2a}
  else if (propName = 'kinetics') then KineticsList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledge.fhirType : string;
begin
  result := 'MedicationKnowledge';
end;

function TFhirMedicationKnowledge.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FStatus) and isEmptyProp(FManufacturer) and isEmptyProp(FDoseForm) and isEmptyProp(FAmount) and isEmptyProp(FsynonymList) and isEmptyProp(FrelatedMedicationKnowledgeList) and isEmptyProp(FassociatedMedicationList) and isEmptyProp(FproductTypeList) and isEmptyProp(FmonographList) and isEmptyProp(FingredientList) and isEmptyProp(FPreparationInstruction) and isEmptyProp(FintendedRouteList) and isEmptyProp(FcostList) and isEmptyProp(FmonitoringProgramList) and isEmptyProp(FadministrationGuidelinesList) and isEmptyProp(FmedicineClassificationList) and isEmptyProp(FPackaging) and isEmptyProp(FdrugCharacteristicList) and isEmptyProp(FcontraindicationList) and isEmptyProp(FregulatoryList) and isEmptyProp(FkineticsList);
end;

function TFhirMedicationKnowledge.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledge;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledge)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledge(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(manufacturerElement, o.manufacturerElement, true) and compareDeep(doseFormElement, o.doseFormElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(synonymList, o.synonymList, true) and 
      compareDeep(relatedMedicationKnowledgeList, o.relatedMedicationKnowledgeList, true) and 
      compareDeep(associatedMedicationList, o.associatedMedicationList, true) and compareDeep(productTypeList, o.productTypeList, true) and 
      compareDeep(monographList, o.monographList, true) and compareDeep(ingredientList, o.ingredientList, true) and 
      compareDeep(preparationInstructionElement, o.preparationInstructionElement, true) and 
      compareDeep(intendedRouteList, o.intendedRouteList, true) and compareDeep(costList, o.costList, true) and 
      compareDeep(monitoringProgramList, o.monitoringProgramList, true) and compareDeep(administrationGuidelinesList, o.administrationGuidelinesList, true) and 
      compareDeep(medicineClassificationList, o.medicineClassificationList, true) and 
      compareDeep(packagingElement, o.packagingElement, true) and compareDeep(drugCharacteristicList, o.drugCharacteristicList, true) and 
      compareDeep(contraindicationList, o.contraindicationList, true) and compareDeep(regulatoryList, o.regulatoryList, true) and 
      compareDeep(kineticsList, o.kineticsList, true);
  end;
end;

function TFhirMedicationKnowledge.Link : TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge(inherited Link);
end;

function TFhirMedicationKnowledge.Clone : TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge(inherited Clone);
end;

procedure TFhirMedicationKnowledge.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('code');
  fields.add('status');
  fields.add('manufacturer');
  fields.add('doseForm');
  fields.add('amount');
  fields.add('synonym');
  fields.add('relatedMedicationKnowledge');
  fields.add('associatedMedication');
  fields.add('productType');
  fields.add('monograph');
  fields.add('ingredient');
  fields.add('preparationInstruction');
  fields.add('intendedRoute');
  fields.add('cost');
  fields.add('monitoringProgram');
  fields.add('administrationGuidelines');
  fields.add('medicineClassification');
  fields.add('packaging');
  fields.add('drugCharacteristic');
  fields.add('contraindication');
  fields.add('regulatory');
  fields.add('kinetics');
end;

{ TFhirMedicationKnowledge }

Procedure TFhirMedicationKnowledge.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirMedicationKnowledge.SetStatus(value : TFhirCode);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirMedicationKnowledge.GetStatusST : String;
begin
  if FStatus = nil then
    result := ''
  else
    result := FStatus.value;
end;

Procedure TFhirMedicationKnowledge.SetStatusST(value : String);
begin
  if value <> '' then
  begin
    if FStatus = nil then
      FStatus := TFhirCode.create;
    FStatus.value := value
  end
  else if FStatus <> nil then
    FStatus.value := '';
end;

Procedure TFhirMedicationKnowledge.SetManufacturer(value : TFhirReference{TFhirOrganization});
begin
  FManufacturer.free;
  FManufacturer := value;
end;

Procedure TFhirMedicationKnowledge.SetDoseForm(value : TFhirCodeableConcept);
begin
  FDoseForm.free;
  FDoseForm := value;
end;

Procedure TFhirMedicationKnowledge.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;

Function TFhirMedicationKnowledge.GetSynonymList : TFhirStringList;
begin
  if FSynonymList = nil then
    FSynonymList := TFhirStringList.Create;
  result := FSynonymList;
end;

Function TFhirMedicationKnowledge.GetHasSynonymList : boolean;
begin
  result := (FSynonymList <> nil) and (FSynonymList.count > 0);
end;

Function TFhirMedicationKnowledge.GetRelatedMedicationKnowledgeList : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
begin
  if FRelatedMedicationKnowledgeList = nil then
    FRelatedMedicationKnowledgeList := TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Create;
  result := FRelatedMedicationKnowledgeList;
end;

Function TFhirMedicationKnowledge.GetHasRelatedMedicationKnowledgeList : boolean;
begin
  result := (FRelatedMedicationKnowledgeList <> nil) and (FRelatedMedicationKnowledgeList.count > 0);
end;

Function TFhirMedicationKnowledge.GetAssociatedMedicationList : TFhirReferenceList{TFhirMedication};
begin
  if FAssociatedMedicationList = nil then
    FAssociatedMedicationList := TFhirReferenceList{TFhirMedication}.Create;
  result := FAssociatedMedicationList;
end;

Function TFhirMedicationKnowledge.GetHasAssociatedMedicationList : boolean;
begin
  result := (FAssociatedMedicationList <> nil) and (FAssociatedMedicationList.count > 0);
end;

Function TFhirMedicationKnowledge.GetProductTypeList : TFhirCodeableConceptList;
begin
  if FProductTypeList = nil then
    FProductTypeList := TFhirCodeableConceptList.Create;
  result := FProductTypeList;
end;

Function TFhirMedicationKnowledge.GetHasProductTypeList : boolean;
begin
  result := (FProductTypeList <> nil) and (FProductTypeList.count > 0);
end;

Function TFhirMedicationKnowledge.GetMonographList : TFhirMedicationKnowledgeMonographList;
begin
  if FMonographList = nil then
    FMonographList := TFhirMedicationKnowledgeMonographList.Create;
  result := FMonographList;
end;

Function TFhirMedicationKnowledge.GetHasMonographList : boolean;
begin
  result := (FMonographList <> nil) and (FMonographList.count > 0);
end;

Function TFhirMedicationKnowledge.GetIngredientList : TFhirMedicationKnowledgeIngredientList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirMedicationKnowledgeIngredientList.Create;
  result := FIngredientList;
end;

Function TFhirMedicationKnowledge.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

Procedure TFhirMedicationKnowledge.SetPreparationInstruction(value : TFhirMarkdown);
begin
  FPreparationInstruction.free;
  FPreparationInstruction := value;
end;

Function TFhirMedicationKnowledge.GetPreparationInstructionST : String;
begin
  if FPreparationInstruction = nil then
    result := ''
  else
    result := FPreparationInstruction.value;
end;

Procedure TFhirMedicationKnowledge.SetPreparationInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FPreparationInstruction = nil then
      FPreparationInstruction := TFhirMarkdown.create;
    FPreparationInstruction.value := value
  end
  else if FPreparationInstruction <> nil then
    FPreparationInstruction.value := '';
end;

Function TFhirMedicationKnowledge.GetIntendedRouteList : TFhirCodeableConceptList;
begin
  if FIntendedRouteList = nil then
    FIntendedRouteList := TFhirCodeableConceptList.Create;
  result := FIntendedRouteList;
end;

Function TFhirMedicationKnowledge.GetHasIntendedRouteList : boolean;
begin
  result := (FIntendedRouteList <> nil) and (FIntendedRouteList.count > 0);
end;

Function TFhirMedicationKnowledge.GetCostList : TFhirMedicationKnowledgeCostList;
begin
  if FCostList = nil then
    FCostList := TFhirMedicationKnowledgeCostList.Create;
  result := FCostList;
end;

Function TFhirMedicationKnowledge.GetHasCostList : boolean;
begin
  result := (FCostList <> nil) and (FCostList.count > 0);
end;

Function TFhirMedicationKnowledge.GetMonitoringProgramList : TFhirMedicationKnowledgeMonitoringProgramList;
begin
  if FMonitoringProgramList = nil then
    FMonitoringProgramList := TFhirMedicationKnowledgeMonitoringProgramList.Create;
  result := FMonitoringProgramList;
end;

Function TFhirMedicationKnowledge.GetHasMonitoringProgramList : boolean;
begin
  result := (FMonitoringProgramList <> nil) and (FMonitoringProgramList.count > 0);
end;

Function TFhirMedicationKnowledge.GetAdministrationGuidelinesList : TFhirMedicationKnowledgeAdministrationGuidelinesList;
begin
  if FAdministrationGuidelinesList = nil then
    FAdministrationGuidelinesList := TFhirMedicationKnowledgeAdministrationGuidelinesList.Create;
  result := FAdministrationGuidelinesList;
end;

Function TFhirMedicationKnowledge.GetHasAdministrationGuidelinesList : boolean;
begin
  result := (FAdministrationGuidelinesList <> nil) and (FAdministrationGuidelinesList.count > 0);
end;

Function TFhirMedicationKnowledge.GetMedicineClassificationList : TFhirMedicationKnowledgeMedicineClassificationList;
begin
  if FMedicineClassificationList = nil then
    FMedicineClassificationList := TFhirMedicationKnowledgeMedicineClassificationList.Create;
  result := FMedicineClassificationList;
end;

Function TFhirMedicationKnowledge.GetHasMedicineClassificationList : boolean;
begin
  result := (FMedicineClassificationList <> nil) and (FMedicineClassificationList.count > 0);
end;

Procedure TFhirMedicationKnowledge.SetPackaging(value : TFhirMedicationKnowledgePackaging);
begin
  FPackaging.free;
  FPackaging := value;
end;

Function TFhirMedicationKnowledge.GetDrugCharacteristicList : TFhirMedicationKnowledgeDrugCharacteristicList;
begin
  if FDrugCharacteristicList = nil then
    FDrugCharacteristicList := TFhirMedicationKnowledgeDrugCharacteristicList.Create;
  result := FDrugCharacteristicList;
end;

Function TFhirMedicationKnowledge.GetHasDrugCharacteristicList : boolean;
begin
  result := (FDrugCharacteristicList <> nil) and (FDrugCharacteristicList.count > 0);
end;

Function TFhirMedicationKnowledge.GetContraindicationList : TFhirReferenceList{TFhirDetectedIssue};
begin
  if FContraindicationList = nil then
    FContraindicationList := TFhirReferenceList{TFhirDetectedIssue}.Create;
  result := FContraindicationList;
end;

Function TFhirMedicationKnowledge.GetHasContraindicationList : boolean;
begin
  result := (FContraindicationList <> nil) and (FContraindicationList.count > 0);
end;

Function TFhirMedicationKnowledge.GetRegulatoryList : TFhirMedicationKnowledgeRegulatoryList;
begin
  if FRegulatoryList = nil then
    FRegulatoryList := TFhirMedicationKnowledgeRegulatoryList.Create;
  result := FRegulatoryList;
end;

Function TFhirMedicationKnowledge.GetHasRegulatoryList : boolean;
begin
  result := (FRegulatoryList <> nil) and (FRegulatoryList.count > 0);
end;

Function TFhirMedicationKnowledge.GetKineticsList : TFhirMedicationKnowledgeKineticsList;
begin
  if FKineticsList = nil then
    FKineticsList := TFhirMedicationKnowledgeKineticsList.Create;
  result := FKineticsList;
end;

Function TFhirMedicationKnowledge.GetHasKineticsList : boolean;
begin
  result := (FKineticsList <> nil) and (FKineticsList.count > 0);
end;

function TFhirMedicationKnowledge.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FManufacturer.sizeInBytes);
  inc(result, FDoseForm.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FsynonymList.sizeInBytes);
  inc(result, FrelatedMedicationKnowledgeList.sizeInBytes);
  inc(result, FassociatedMedicationList.sizeInBytes);
  inc(result, FproductTypeList.sizeInBytes);
  inc(result, FmonographList.sizeInBytes);
  inc(result, FingredientList.sizeInBytes);
  inc(result, FPreparationInstruction.sizeInBytes);
  inc(result, FintendedRouteList.sizeInBytes);
  inc(result, FcostList.sizeInBytes);
  inc(result, FmonitoringProgramList.sizeInBytes);
  inc(result, FadministrationGuidelinesList.sizeInBytes);
  inc(result, FmedicineClassificationList.sizeInBytes);
  inc(result, FPackaging.sizeInBytes);
  inc(result, FdrugCharacteristicList.sizeInBytes);
  inc(result, FcontraindicationList.sizeInBytes);
  inc(result, FregulatoryList.sizeInBytes);
  inc(result, FkineticsList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeListEnumerator }

Constructor TFhirMedicationKnowledgeListEnumerator.Create(list : TFhirMedicationKnowledgeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeListEnumerator.GetCurrent : TFhirMedicationKnowledge;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationKnowledgeList }
procedure TFhirMedicationKnowledgeList.AddItem(value: TFhirMedicationKnowledge);
begin
  assert(value.ClassName = 'TFhirMedicationKnowledge', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledge');
  add(value);
end;

function TFhirMedicationKnowledgeList.Append: TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeList.GetEnumerator : TFhirMedicationKnowledgeListEnumerator;
begin
  result := TFhirMedicationKnowledgeListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeList.Clone: TFhirMedicationKnowledgeList;
begin
  result := TFhirMedicationKnowledgeList(inherited Clone);
end;

function TFhirMedicationKnowledgeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeList.GetItemN(index: Integer): TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledge;
end;
function TFhirMedicationKnowledgeList.IndexOf(value: TFhirMedicationKnowledge): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeList.Insert(index: Integer): TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeList.InsertItem(index: Integer; value: TFhirMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledge);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeList.Item(index: Integer): TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeList.Link: TFhirMedicationKnowledgeList;
begin
  result := TFhirMedicationKnowledgeList(inherited Link);
end;

procedure TFhirMedicationKnowledgeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledge);
  FhirMedicationKnowledges[index] := value;
end;

procedure TFhirMedicationKnowledgeList.SetItemN(index: Integer; value: TFhirMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledge);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATIONKNOWLEDGE}

{$IFDEF FHIR_MEDICINALPRODUCT}

{ TFhirMedicinalProductName }

constructor TFhirMedicinalProductName.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductName.Destroy;
begin
  FProductName.free;
  FNamePartList.Free;
  FCountryLanguageList.Free;
  inherited;
end;

procedure TFhirMedicinalProductName.Assign(oSource : TFslObject);
begin
  inherited;
  productNameElement := TFhirMedicinalProductName(oSource).productNameElement.Clone;
  if (TFhirMedicinalProductName(oSource).FNamePartList = nil) then
  begin
    FNamePartList.free;
    FNamePartList := nil;
  end
  else
  begin
    if FNamePartList = nil then
      FNamePartList := TFhirMedicinalProductNameNamePartList.Create;
    FNamePartList.Assign(TFhirMedicinalProductName(oSource).FNamePartList);
  end;
  if (TFhirMedicinalProductName(oSource).FCountryLanguageList = nil) then
  begin
    FCountryLanguageList.free;
    FCountryLanguageList := nil;
  end
  else
  begin
    if FCountryLanguageList = nil then
      FCountryLanguageList := TFhirMedicinalProductNameCountryLanguageList.Create;
    FCountryLanguageList.Assign(TFhirMedicinalProductName(oSource).FCountryLanguageList);
  end;
end;

procedure TFhirMedicinalProductName.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'productName') Then
     list.add(self.link, 'productName', FProductName.Link);
  if (child_name = 'namePart') Then
    list.addAll(self, 'namePart', FNamePartList);
  if (child_name = 'countryLanguage') Then
    list.addAll(self, 'countryLanguage', FCountryLanguageList);
end;

procedure TFhirMedicinalProductName.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'productName', 'string', false, TFhirString, FProductName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'namePart', '', true, TFhirMedicinalProductNameNamePart, FNamePartList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'countryLanguage', '', true, TFhirMedicinalProductNameCountryLanguage, FCountryLanguageList.Link)){3};
end;

function TFhirMedicinalProductName.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'productName') then
  begin
    ProductNameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'namePart') then
  begin
    NamePartList.add(propValue as TFhirMedicinalProductNameNamePart){2a};
    result := propValue;
  end
  else if (propName = 'countryLanguage') then
  begin
    CountryLanguageList.add(propValue as TFhirMedicinalProductNameCountryLanguage){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductName.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'namePart') then NamePartList.insertItem(index, propValue as TFhirMedicinalProductNameNamePart){2a}
  else if (propName = 'countryLanguage') then CountryLanguageList.insertItem(index, propValue as TFhirMedicinalProductNameCountryLanguage){2a}
  else inherited;
end;

function TFhirMedicinalProductName.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'productName') then result := TFhirString.create() {5b}
  else if (propName = 'namePart') then result := NamePartList.new(){2}
  else if (propName = 'countryLanguage') then result := CountryLanguageList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductName.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'productName') then result := 'string'
  else if (propName = 'namePart') then result := ''
  else if (propName = 'countryLanguage') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductName.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'productName') then ProductNameElement := nil
  else if (propName = 'namePart') then deletePropertyValue('namePart', NamePartList, value) {2}
  else if (propName = 'countryLanguage') then deletePropertyValue('countryLanguage', CountryLanguageList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductName.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'productName') then ProductNameElement := asString(new){5b}
  else if (propName = 'namePart') then replacePropertyValue('namePart', NamePartList, existing, new) {2}
  else if (propName = 'countryLanguage') then replacePropertyValue('countryLanguage', CountryLanguageList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductName.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'namePart') then NamePartList.move(source, destination){2a}
  else if (propName = 'countryLanguage') then CountryLanguageList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductName.fhirType : string;
begin
  result := 'name';
end;

function TFhirMedicinalProductName.Link : TFhirMedicinalProductName;
begin
  result := TFhirMedicinalProductName(inherited Link);
end;

function TFhirMedicinalProductName.Clone : TFhirMedicinalProductName;
begin
  result := TFhirMedicinalProductName(inherited Clone);
end;

function TFhirMedicinalProductName.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductName;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductName)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductName(other);
    result := compareDeep(productNameElement, o.productNameElement, true) and compareDeep(namePartList, o.namePartList, true) and 
      compareDeep(countryLanguageList, o.countryLanguageList, true);
  end;
end;

function TFhirMedicinalProductName.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProductName) and isEmptyProp(FnamePartList) and isEmptyProp(FcountryLanguageList);
end;

procedure TFhirMedicinalProductName.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('productName');
  fields.add('namePart');
  fields.add('countryLanguage');
end;

{ TFhirMedicinalProductName }

Procedure TFhirMedicinalProductName.SetProductName(value : TFhirString);
begin
  FProductName.free;
  FProductName := value;
end;

Function TFhirMedicinalProductName.GetProductNameST : String;
begin
  if FProductName = nil then
    result := ''
  else
    result := FProductName.value;
end;

Procedure TFhirMedicinalProductName.SetProductNameST(value : String);
begin
  if value <> '' then
  begin
    if FProductName = nil then
      FProductName := TFhirString.create;
    FProductName.value := value
  end
  else if FProductName <> nil then
    FProductName.value := '';
end;

Function TFhirMedicinalProductName.GetNamePartList : TFhirMedicinalProductNameNamePartList;
begin
  if FNamePartList = nil then
    FNamePartList := TFhirMedicinalProductNameNamePartList.Create;
  result := FNamePartList;
end;

Function TFhirMedicinalProductName.GetHasNamePartList : boolean;
begin
  result := (FNamePartList <> nil) and (FNamePartList.count > 0);
end;

Function TFhirMedicinalProductName.GetCountryLanguageList : TFhirMedicinalProductNameCountryLanguageList;
begin
  if FCountryLanguageList = nil then
    FCountryLanguageList := TFhirMedicinalProductNameCountryLanguageList.Create;
  result := FCountryLanguageList;
end;

Function TFhirMedicinalProductName.GetHasCountryLanguageList : boolean;
begin
  result := (FCountryLanguageList <> nil) and (FCountryLanguageList.count > 0);
end;

function TFhirMedicinalProductName.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FProductName.sizeInBytes);
  inc(result, FnamePartList.sizeInBytes);
  inc(result, FcountryLanguageList.sizeInBytes);
end;

{ TFhirMedicinalProductNameListEnumerator }

Constructor TFhirMedicinalProductNameListEnumerator.Create(list : TFhirMedicinalProductNameList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductNameListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductNameListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductNameListEnumerator.GetCurrent : TFhirMedicinalProductName;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductNameListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductNameList }
procedure TFhirMedicinalProductNameList.AddItem(value: TFhirMedicinalProductName);
begin
  assert(value.ClassName = 'TFhirMedicinalProductName', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductName');
  add(value);
end;

function TFhirMedicinalProductNameList.Append: TFhirMedicinalProductName;
begin
  result := TFhirMedicinalProductName.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductNameList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductNameList.GetEnumerator : TFhirMedicinalProductNameListEnumerator;
begin
  result := TFhirMedicinalProductNameListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductNameList.Clone: TFhirMedicinalProductNameList;
begin
  result := TFhirMedicinalProductNameList(inherited Clone);
end;

function TFhirMedicinalProductNameList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductNameList.GetItemN(index: Integer): TFhirMedicinalProductName;
begin
  result := TFhirMedicinalProductName(ObjectByIndex[index]);
end;

function TFhirMedicinalProductNameList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductName;
end;
function TFhirMedicinalProductNameList.IndexOf(value: TFhirMedicinalProductName): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductNameList.Insert(index: Integer): TFhirMedicinalProductName;
begin
  result := TFhirMedicinalProductName.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductNameList.InsertItem(index: Integer; value: TFhirMedicinalProductName);
begin
  assert(value is TFhirMedicinalProductName);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductNameList.Item(index: Integer): TFhirMedicinalProductName;
begin
  result := TFhirMedicinalProductName(ObjectByIndex[index]);
end;

function TFhirMedicinalProductNameList.Link: TFhirMedicinalProductNameList;
begin
  result := TFhirMedicinalProductNameList(inherited Link);
end;

procedure TFhirMedicinalProductNameList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductNameList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductName);
begin
  assert(value is TFhirMedicinalProductName);
  FhirMedicinalProductNames[index] := value;
end;

procedure TFhirMedicinalProductNameList.SetItemN(index: Integer; value: TFhirMedicinalProductName);
begin
  assert(value is TFhirMedicinalProductName);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductNameNamePart }

constructor TFhirMedicinalProductNameNamePart.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductNameNamePart.Destroy;
begin
  FPart.free;
  FType_.free;
  inherited;
end;

procedure TFhirMedicinalProductNameNamePart.Assign(oSource : TFslObject);
begin
  inherited;
  partElement := TFhirMedicinalProductNameNamePart(oSource).partElement.Clone;
  type_ := TFhirMedicinalProductNameNamePart(oSource).type_.Clone;
end;

procedure TFhirMedicinalProductNameNamePart.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'part') Then
     list.add(self.link, 'part', FPart.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirMedicinalProductNameNamePart.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'part', 'string', false, TFhirString, FPart.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
end;

function TFhirMedicinalProductNameNamePart.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'part') then
  begin
    PartElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductNameNamePart.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductNameNamePart.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'part') then result := TFhirString.create() {5b}
  else if (propName = 'type') then result := TFhirCoding.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductNameNamePart.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'part') then result := 'string'
  else if (propName = 'type') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductNameNamePart.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'part') then PartElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductNameNamePart.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'part') then PartElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductNameNamePart.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductNameNamePart.fhirType : string;
begin
  result := 'namePart';
end;

function TFhirMedicinalProductNameNamePart.Link : TFhirMedicinalProductNameNamePart;
begin
  result := TFhirMedicinalProductNameNamePart(inherited Link);
end;

function TFhirMedicinalProductNameNamePart.Clone : TFhirMedicinalProductNameNamePart;
begin
  result := TFhirMedicinalProductNameNamePart(inherited Clone);
end;

function TFhirMedicinalProductNameNamePart.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductNameNamePart;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductNameNamePart)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductNameNamePart(other);
    result := compareDeep(partElement, o.partElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirMedicinalProductNameNamePart.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPart) and isEmptyProp(FType_);
end;

procedure TFhirMedicinalProductNameNamePart.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('part');
  fields.add('type');
end;

{ TFhirMedicinalProductNameNamePart }

Procedure TFhirMedicinalProductNameNamePart.SetPart(value : TFhirString);
begin
  FPart.free;
  FPart := value;
end;

Function TFhirMedicinalProductNameNamePart.GetPartST : String;
begin
  if FPart = nil then
    result := ''
  else
    result := FPart.value;
end;

Procedure TFhirMedicinalProductNameNamePart.SetPartST(value : String);
begin
  if value <> '' then
  begin
    if FPart = nil then
      FPart := TFhirString.create;
    FPart.value := value
  end
  else if FPart <> nil then
    FPart.value := '';
end;

Procedure TFhirMedicinalProductNameNamePart.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirMedicinalProductNameNamePart.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPart.sizeInBytes);
  inc(result, FType_.sizeInBytes);
end;

{ TFhirMedicinalProductNameNamePartListEnumerator }

Constructor TFhirMedicinalProductNameNamePartListEnumerator.Create(list : TFhirMedicinalProductNameNamePartList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductNameNamePartListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductNameNamePartListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductNameNamePartListEnumerator.GetCurrent : TFhirMedicinalProductNameNamePart;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductNameNamePartListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductNameNamePartList }
procedure TFhirMedicinalProductNameNamePartList.AddItem(value: TFhirMedicinalProductNameNamePart);
begin
  assert(value.ClassName = 'TFhirMedicinalProductNameNamePart', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductNameNamePart');
  add(value);
end;

function TFhirMedicinalProductNameNamePartList.Append: TFhirMedicinalProductNameNamePart;
begin
  result := TFhirMedicinalProductNameNamePart.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductNameNamePartList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductNameNamePartList.GetEnumerator : TFhirMedicinalProductNameNamePartListEnumerator;
begin
  result := TFhirMedicinalProductNameNamePartListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductNameNamePartList.Clone: TFhirMedicinalProductNameNamePartList;
begin
  result := TFhirMedicinalProductNameNamePartList(inherited Clone);
end;

function TFhirMedicinalProductNameNamePartList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductNameNamePartList.GetItemN(index: Integer): TFhirMedicinalProductNameNamePart;
begin
  result := TFhirMedicinalProductNameNamePart(ObjectByIndex[index]);
end;

function TFhirMedicinalProductNameNamePartList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductNameNamePart;
end;
function TFhirMedicinalProductNameNamePartList.IndexOf(value: TFhirMedicinalProductNameNamePart): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductNameNamePartList.Insert(index: Integer): TFhirMedicinalProductNameNamePart;
begin
  result := TFhirMedicinalProductNameNamePart.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductNameNamePartList.InsertItem(index: Integer; value: TFhirMedicinalProductNameNamePart);
begin
  assert(value is TFhirMedicinalProductNameNamePart);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductNameNamePartList.Item(index: Integer): TFhirMedicinalProductNameNamePart;
begin
  result := TFhirMedicinalProductNameNamePart(ObjectByIndex[index]);
end;

function TFhirMedicinalProductNameNamePartList.Link: TFhirMedicinalProductNameNamePartList;
begin
  result := TFhirMedicinalProductNameNamePartList(inherited Link);
end;

procedure TFhirMedicinalProductNameNamePartList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductNameNamePartList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductNameNamePart);
begin
  assert(value is TFhirMedicinalProductNameNamePart);
  FhirMedicinalProductNameNameParts[index] := value;
end;

procedure TFhirMedicinalProductNameNamePartList.SetItemN(index: Integer; value: TFhirMedicinalProductNameNamePart);
begin
  assert(value is TFhirMedicinalProductNameNamePart);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductNameCountryLanguage }

constructor TFhirMedicinalProductNameCountryLanguage.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductNameCountryLanguage.Destroy;
begin
  FCountry.free;
  FJurisdiction.free;
  FLanguage.free;
  inherited;
end;

procedure TFhirMedicinalProductNameCountryLanguage.Assign(oSource : TFslObject);
begin
  inherited;
  country := TFhirMedicinalProductNameCountryLanguage(oSource).country.Clone;
  jurisdiction := TFhirMedicinalProductNameCountryLanguage(oSource).jurisdiction.Clone;
  language := TFhirMedicinalProductNameCountryLanguage(oSource).language.Clone;
end;

procedure TFhirMedicinalProductNameCountryLanguage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'country') Then
     list.add(self.link, 'country', FCountry.Link);
  if (child_name = 'jurisdiction') Then
     list.add(self.link, 'jurisdiction', FJurisdiction.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
end;

procedure TFhirMedicinalProductNameCountryLanguage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'country', 'CodeableConcept', false, TFhirCodeableConcept, FCountry.Link));{2}
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', false, TFhirCodeableConcept, FJurisdiction.Link));{2}
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link));{2}
end;

function TFhirMedicinalProductNameCountryLanguage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'country') then
  begin
    Country := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    Jurisdiction := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductNameCountryLanguage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductNameCountryLanguage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'country') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'jurisdiction') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'language') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductNameCountryLanguage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'country') then result := 'CodeableConcept'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'language') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductNameCountryLanguage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'country') then CountryElement := nil
  else if (propName = 'jurisdiction') then JurisdictionElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductNameCountryLanguage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'country') then CountryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'jurisdiction') then JurisdictionElement := new as TFhirCodeableConcept{4}
  else if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductNameCountryLanguage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductNameCountryLanguage.fhirType : string;
begin
  result := 'countryLanguage';
end;

function TFhirMedicinalProductNameCountryLanguage.Link : TFhirMedicinalProductNameCountryLanguage;
begin
  result := TFhirMedicinalProductNameCountryLanguage(inherited Link);
end;

function TFhirMedicinalProductNameCountryLanguage.Clone : TFhirMedicinalProductNameCountryLanguage;
begin
  result := TFhirMedicinalProductNameCountryLanguage(inherited Clone);
end;

function TFhirMedicinalProductNameCountryLanguage.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductNameCountryLanguage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductNameCountryLanguage)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductNameCountryLanguage(other);
    result := compareDeep(countryElement, o.countryElement, true) and compareDeep(jurisdictionElement, o.jurisdictionElement, true) and 
      compareDeep(languageElement, o.languageElement, true);
  end;
end;

function TFhirMedicinalProductNameCountryLanguage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCountry) and isEmptyProp(FJurisdiction) and isEmptyProp(FLanguage);
end;

procedure TFhirMedicinalProductNameCountryLanguage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('country');
  fields.add('jurisdiction');
  fields.add('language');
end;

{ TFhirMedicinalProductNameCountryLanguage }

Procedure TFhirMedicinalProductNameCountryLanguage.SetCountry(value : TFhirCodeableConcept);
begin
  FCountry.free;
  FCountry := value;
end;

Procedure TFhirMedicinalProductNameCountryLanguage.SetJurisdiction(value : TFhirCodeableConcept);
begin
  FJurisdiction.free;
  FJurisdiction := value;
end;

Procedure TFhirMedicinalProductNameCountryLanguage.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value;
end;

function TFhirMedicinalProductNameCountryLanguage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCountry.sizeInBytes);
  inc(result, FJurisdiction.sizeInBytes);
  inc(result, FLanguage.sizeInBytes);
end;

{ TFhirMedicinalProductNameCountryLanguageListEnumerator }

Constructor TFhirMedicinalProductNameCountryLanguageListEnumerator.Create(list : TFhirMedicinalProductNameCountryLanguageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductNameCountryLanguageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductNameCountryLanguageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductNameCountryLanguageListEnumerator.GetCurrent : TFhirMedicinalProductNameCountryLanguage;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductNameCountryLanguageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductNameCountryLanguageList }
procedure TFhirMedicinalProductNameCountryLanguageList.AddItem(value: TFhirMedicinalProductNameCountryLanguage);
begin
  assert(value.ClassName = 'TFhirMedicinalProductNameCountryLanguage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductNameCountryLanguage');
  add(value);
end;

function TFhirMedicinalProductNameCountryLanguageList.Append: TFhirMedicinalProductNameCountryLanguage;
begin
  result := TFhirMedicinalProductNameCountryLanguage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductNameCountryLanguageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductNameCountryLanguageList.GetEnumerator : TFhirMedicinalProductNameCountryLanguageListEnumerator;
begin
  result := TFhirMedicinalProductNameCountryLanguageListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductNameCountryLanguageList.Clone: TFhirMedicinalProductNameCountryLanguageList;
begin
  result := TFhirMedicinalProductNameCountryLanguageList(inherited Clone);
end;

function TFhirMedicinalProductNameCountryLanguageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductNameCountryLanguageList.GetItemN(index: Integer): TFhirMedicinalProductNameCountryLanguage;
begin
  result := TFhirMedicinalProductNameCountryLanguage(ObjectByIndex[index]);
end;

function TFhirMedicinalProductNameCountryLanguageList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductNameCountryLanguage;
end;
function TFhirMedicinalProductNameCountryLanguageList.IndexOf(value: TFhirMedicinalProductNameCountryLanguage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductNameCountryLanguageList.Insert(index: Integer): TFhirMedicinalProductNameCountryLanguage;
begin
  result := TFhirMedicinalProductNameCountryLanguage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductNameCountryLanguageList.InsertItem(index: Integer; value: TFhirMedicinalProductNameCountryLanguage);
begin
  assert(value is TFhirMedicinalProductNameCountryLanguage);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductNameCountryLanguageList.Item(index: Integer): TFhirMedicinalProductNameCountryLanguage;
begin
  result := TFhirMedicinalProductNameCountryLanguage(ObjectByIndex[index]);
end;

function TFhirMedicinalProductNameCountryLanguageList.Link: TFhirMedicinalProductNameCountryLanguageList;
begin
  result := TFhirMedicinalProductNameCountryLanguageList(inherited Link);
end;

procedure TFhirMedicinalProductNameCountryLanguageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductNameCountryLanguageList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductNameCountryLanguage);
begin
  assert(value is TFhirMedicinalProductNameCountryLanguage);
  FhirMedicinalProductNameCountryLanguages[index] := value;
end;

procedure TFhirMedicinalProductNameCountryLanguageList.SetItemN(index: Integer; value: TFhirMedicinalProductNameCountryLanguage);
begin
  assert(value is TFhirMedicinalProductNameCountryLanguage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductManufacturingBusinessOperation }

constructor TFhirMedicinalProductManufacturingBusinessOperation.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductManufacturingBusinessOperation.Destroy;
begin
  FOperationType.free;
  FAuthorisationReferenceNumber.free;
  FEffectiveDate.free;
  FConfidentialityIndicator.free;
  FManufacturerList.Free;
  FRegulator.free;
  inherited;
end;

procedure TFhirMedicinalProductManufacturingBusinessOperation.Assign(oSource : TFslObject);
begin
  inherited;
  operationType := TFhirMedicinalProductManufacturingBusinessOperation(oSource).operationType.Clone;
  authorisationReferenceNumber := TFhirMedicinalProductManufacturingBusinessOperation(oSource).authorisationReferenceNumber.Clone;
  effectiveDateElement := TFhirMedicinalProductManufacturingBusinessOperation(oSource).effectiveDateElement.Clone;
  confidentialityIndicator := TFhirMedicinalProductManufacturingBusinessOperation(oSource).confidentialityIndicator.Clone;
  if (TFhirMedicinalProductManufacturingBusinessOperation(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList{TFhirOrganization}.Create;
    FManufacturerList.Assign(TFhirMedicinalProductManufacturingBusinessOperation(oSource).FManufacturerList);
  end;
  regulator := TFhirMedicinalProductManufacturingBusinessOperation(oSource).regulator.Clone;
end;

procedure TFhirMedicinalProductManufacturingBusinessOperation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operationType') Then
     list.add(self.link, 'operationType', FOperationType.Link);
  if (child_name = 'authorisationReferenceNumber') Then
     list.add(self.link, 'authorisationReferenceNumber', FAuthorisationReferenceNumber.Link);
  if (child_name = 'effectiveDate') Then
     list.add(self.link, 'effectiveDate', FEffectiveDate.Link);
  if (child_name = 'confidentialityIndicator') Then
     list.add(self.link, 'confidentialityIndicator', FConfidentialityIndicator.Link);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'regulator') Then
     list.add(self.link, 'regulator', FRegulator.Link);
end;

procedure TFhirMedicinalProductManufacturingBusinessOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operationType', 'CodeableConcept', false, TFhirCodeableConcept, FOperationType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authorisationReferenceNumber', 'Identifier', false, TFhirIdentifier, FAuthorisationReferenceNumber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effectiveDate', 'dateTime', false, TFhirDateTime, FEffectiveDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'confidentialityIndicator', 'CodeableConcept', false, TFhirCodeableConcept, FConfidentialityIndicator.Link));{2}
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FManufacturerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'regulator', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FRegulator.Link));{2}
end;

function TFhirMedicinalProductManufacturingBusinessOperation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operationType') then
  begin
    OperationType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'authorisationReferenceNumber') then
  begin
    AuthorisationReferenceNumber := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'effectiveDate') then
  begin
    EffectiveDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'confidentialityIndicator') then
  begin
    ConfidentialityIndicator := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else if (propName = 'regulator') then
  begin
    Regulator := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductManufacturingBusinessOperation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else inherited;
end;

function TFhirMedicinalProductManufacturingBusinessOperation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operationType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'authorisationReferenceNumber') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'effectiveDate') then result := TFhirDateTime.create() {5b}
  else if (propName = 'confidentialityIndicator') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'manufacturer') then result := ManufacturerList.new(){2}
  else if (propName = 'regulator') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductManufacturingBusinessOperation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operationType') then result := 'CodeableConcept'
  else if (propName = 'authorisationReferenceNumber') then result := 'Identifier'
  else if (propName = 'effectiveDate') then result := 'dateTime'
  else if (propName = 'confidentialityIndicator') then result := 'CodeableConcept'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'regulator') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductManufacturingBusinessOperation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operationType') then OperationTypeElement := nil
  else if (propName = 'authorisationReferenceNumber') then AuthorisationReferenceNumberElement := nil
  else if (propName = 'effectiveDate') then EffectiveDateElement := nil
  else if (propName = 'confidentialityIndicator') then ConfidentialityIndicatorElement := nil
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value) {2}
  else if (propName = 'regulator') then RegulatorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductManufacturingBusinessOperation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operationType') then OperationTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'authorisationReferenceNumber') then AuthorisationReferenceNumberElement := new as TFhirIdentifier{4}
  else if (propName = 'effectiveDate') then EffectiveDateElement := asDateTime(new){5b}
  else if (propName = 'confidentialityIndicator') then ConfidentialityIndicatorElement := new as TFhirCodeableConcept{4}
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new) {2}
  else if (propName = 'regulator') then RegulatorElement := new as TFhirReference{TFhirOrganization}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductManufacturingBusinessOperation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'manufacturer') then ManufacturerList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductManufacturingBusinessOperation.fhirType : string;
begin
  result := 'manufacturingBusinessOperation';
end;

function TFhirMedicinalProductManufacturingBusinessOperation.Link : TFhirMedicinalProductManufacturingBusinessOperation;
begin
  result := TFhirMedicinalProductManufacturingBusinessOperation(inherited Link);
end;

function TFhirMedicinalProductManufacturingBusinessOperation.Clone : TFhirMedicinalProductManufacturingBusinessOperation;
begin
  result := TFhirMedicinalProductManufacturingBusinessOperation(inherited Clone);
end;

function TFhirMedicinalProductManufacturingBusinessOperation.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductManufacturingBusinessOperation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductManufacturingBusinessOperation)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductManufacturingBusinessOperation(other);
    result := compareDeep(operationTypeElement, o.operationTypeElement, true) and 
      compareDeep(authorisationReferenceNumberElement, o.authorisationReferenceNumberElement, true) and 
      compareDeep(effectiveDateElement, o.effectiveDateElement, true) and compareDeep(confidentialityIndicatorElement, o.confidentialityIndicatorElement, true) and 
      compareDeep(manufacturerList, o.manufacturerList, true) and compareDeep(regulatorElement, o.regulatorElement, true);
  end;
end;

function TFhirMedicinalProductManufacturingBusinessOperation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperationType) and isEmptyProp(FAuthorisationReferenceNumber) and isEmptyProp(FEffectiveDate) and isEmptyProp(FConfidentialityIndicator) and isEmptyProp(FmanufacturerList) and isEmptyProp(FRegulator);
end;

procedure TFhirMedicinalProductManufacturingBusinessOperation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('operationType');
  fields.add('authorisationReferenceNumber');
  fields.add('effectiveDate');
  fields.add('confidentialityIndicator');
  fields.add('manufacturer');
  fields.add('regulator');
end;

{ TFhirMedicinalProductManufacturingBusinessOperation }

Procedure TFhirMedicinalProductManufacturingBusinessOperation.SetOperationType(value : TFhirCodeableConcept);
begin
  FOperationType.free;
  FOperationType := value;
end;

Procedure TFhirMedicinalProductManufacturingBusinessOperation.SetAuthorisationReferenceNumber(value : TFhirIdentifier);
begin
  FAuthorisationReferenceNumber.free;
  FAuthorisationReferenceNumber := value;
end;

Procedure TFhirMedicinalProductManufacturingBusinessOperation.SetEffectiveDate(value : TFhirDateTime);
begin
  FEffectiveDate.free;
  FEffectiveDate := value;
end;

Function TFhirMedicinalProductManufacturingBusinessOperation.GetEffectiveDateST : TFslDateTime;
begin
  if FEffectiveDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FEffectiveDate.value;
end;

Procedure TFhirMedicinalProductManufacturingBusinessOperation.SetEffectiveDateST(value : TFslDateTime);
begin
  if FEffectiveDate = nil then
    FEffectiveDate := TFhirDateTime.create;
  FEffectiveDate.value := value
end;

Procedure TFhirMedicinalProductManufacturingBusinessOperation.SetConfidentialityIndicator(value : TFhirCodeableConcept);
begin
  FConfidentialityIndicator.free;
  FConfidentialityIndicator := value;
end;

Function TFhirMedicinalProductManufacturingBusinessOperation.GetManufacturerList : TFhirReferenceList{TFhirOrganization};
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FManufacturerList;
end;

Function TFhirMedicinalProductManufacturingBusinessOperation.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

Procedure TFhirMedicinalProductManufacturingBusinessOperation.SetRegulator(value : TFhirReference{TFhirOrganization});
begin
  FRegulator.free;
  FRegulator := value;
end;

function TFhirMedicinalProductManufacturingBusinessOperation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOperationType.sizeInBytes);
  inc(result, FAuthorisationReferenceNumber.sizeInBytes);
  inc(result, FEffectiveDate.sizeInBytes);
  inc(result, FConfidentialityIndicator.sizeInBytes);
  inc(result, FmanufacturerList.sizeInBytes);
  inc(result, FRegulator.sizeInBytes);
end;

{ TFhirMedicinalProductManufacturingBusinessOperationListEnumerator }

Constructor TFhirMedicinalProductManufacturingBusinessOperationListEnumerator.Create(list : TFhirMedicinalProductManufacturingBusinessOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductManufacturingBusinessOperationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductManufacturingBusinessOperationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductManufacturingBusinessOperationListEnumerator.GetCurrent : TFhirMedicinalProductManufacturingBusinessOperation;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductManufacturingBusinessOperationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductManufacturingBusinessOperationList }
procedure TFhirMedicinalProductManufacturingBusinessOperationList.AddItem(value: TFhirMedicinalProductManufacturingBusinessOperation);
begin
  assert(value.ClassName = 'TFhirMedicinalProductManufacturingBusinessOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductManufacturingBusinessOperation');
  add(value);
end;

function TFhirMedicinalProductManufacturingBusinessOperationList.Append: TFhirMedicinalProductManufacturingBusinessOperation;
begin
  result := TFhirMedicinalProductManufacturingBusinessOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductManufacturingBusinessOperationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductManufacturingBusinessOperationList.GetEnumerator : TFhirMedicinalProductManufacturingBusinessOperationListEnumerator;
begin
  result := TFhirMedicinalProductManufacturingBusinessOperationListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductManufacturingBusinessOperationList.Clone: TFhirMedicinalProductManufacturingBusinessOperationList;
begin
  result := TFhirMedicinalProductManufacturingBusinessOperationList(inherited Clone);
end;

function TFhirMedicinalProductManufacturingBusinessOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductManufacturingBusinessOperationList.GetItemN(index: Integer): TFhirMedicinalProductManufacturingBusinessOperation;
begin
  result := TFhirMedicinalProductManufacturingBusinessOperation(ObjectByIndex[index]);
end;

function TFhirMedicinalProductManufacturingBusinessOperationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductManufacturingBusinessOperation;
end;
function TFhirMedicinalProductManufacturingBusinessOperationList.IndexOf(value: TFhirMedicinalProductManufacturingBusinessOperation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductManufacturingBusinessOperationList.Insert(index: Integer): TFhirMedicinalProductManufacturingBusinessOperation;
begin
  result := TFhirMedicinalProductManufacturingBusinessOperation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductManufacturingBusinessOperationList.InsertItem(index: Integer; value: TFhirMedicinalProductManufacturingBusinessOperation);
begin
  assert(value is TFhirMedicinalProductManufacturingBusinessOperation);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductManufacturingBusinessOperationList.Item(index: Integer): TFhirMedicinalProductManufacturingBusinessOperation;
begin
  result := TFhirMedicinalProductManufacturingBusinessOperation(ObjectByIndex[index]);
end;

function TFhirMedicinalProductManufacturingBusinessOperationList.Link: TFhirMedicinalProductManufacturingBusinessOperationList;
begin
  result := TFhirMedicinalProductManufacturingBusinessOperationList(inherited Link);
end;

procedure TFhirMedicinalProductManufacturingBusinessOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductManufacturingBusinessOperationList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductManufacturingBusinessOperation);
begin
  assert(value is TFhirMedicinalProductManufacturingBusinessOperation);
  FhirMedicinalProductManufacturingBusinessOperations[index] := value;
end;

procedure TFhirMedicinalProductManufacturingBusinessOperationList.SetItemN(index: Integer; value: TFhirMedicinalProductManufacturingBusinessOperation);
begin
  assert(value is TFhirMedicinalProductManufacturingBusinessOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductSpecialDesignation }

constructor TFhirMedicinalProductSpecialDesignation.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductSpecialDesignation.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FIntendedUse.free;
  FIndication.free;
  FStatus.free;
  FDate.free;
  FSpecies.free;
  inherited;
end;

procedure TFhirMedicinalProductSpecialDesignation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicinalProductSpecialDesignation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicinalProductSpecialDesignation(oSource).FIdentifierList);
  end;
  type_ := TFhirMedicinalProductSpecialDesignation(oSource).type_.Clone;
  intendedUse := TFhirMedicinalProductSpecialDesignation(oSource).intendedUse.Clone;
  indication := TFhirMedicinalProductSpecialDesignation(oSource).indication.Clone;
  status := TFhirMedicinalProductSpecialDesignation(oSource).status.Clone;
  dateElement := TFhirMedicinalProductSpecialDesignation(oSource).dateElement.Clone;
  species := TFhirMedicinalProductSpecialDesignation(oSource).species.Clone;
end;

procedure TFhirMedicinalProductSpecialDesignation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'intendedUse') Then
     list.add(self.link, 'intendedUse', FIntendedUse.Link);
  if (child_name = 'indication[x]') or (child_name = 'indication') Then
     list.add(self.link, 'indication[x]', FIndication.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'species') Then
     list.add(self.link, 'species', FSpecies.Link);
end;

procedure TFhirMedicinalProductSpecialDesignation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'intendedUse', 'CodeableConcept', false, TFhirCodeableConcept, FIntendedUse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'indication[x]', 'CodeableConcept|Reference(MedicinalProductIndication)', false, TFhirType, FIndication.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'species', 'CodeableConcept', false, TFhirCodeableConcept, FSpecies.Link));{2}
end;

function TFhirMedicinalProductSpecialDesignation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'intendedUse') then
  begin
    IntendedUse := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'indication', ['CodeableConcept', 'Reference'])) then
  begin
    Indication := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'species') then
  begin
    Species := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductSpecialDesignation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirMedicinalProductSpecialDesignation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'intendedUse') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'indication', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Indication'){4x}
  else if (propName = 'status') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'species') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductSpecialDesignation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'intendedUse') then result := 'CodeableConcept'
  else if (propName = 'indication[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'species') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductSpecialDesignation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'intendedUse') then IntendedUseElement := nil
  else if (isMatchingName(propName, 'indication', ['CodeableConcept', 'Reference'])) then IndicationElement := nil{4x}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'species') then SpeciesElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductSpecialDesignation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'intendedUse') then IntendedUseElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'indication', ['CodeableConcept', 'Reference'])) then IndicationElement := new as TFhirType{4x}
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept{4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'species') then SpeciesElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductSpecialDesignation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductSpecialDesignation.fhirType : string;
begin
  result := 'specialDesignation';
end;

function TFhirMedicinalProductSpecialDesignation.Link : TFhirMedicinalProductSpecialDesignation;
begin
  result := TFhirMedicinalProductSpecialDesignation(inherited Link);
end;

function TFhirMedicinalProductSpecialDesignation.Clone : TFhirMedicinalProductSpecialDesignation;
begin
  result := TFhirMedicinalProductSpecialDesignation(inherited Clone);
end;

function TFhirMedicinalProductSpecialDesignation.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductSpecialDesignation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductSpecialDesignation)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductSpecialDesignation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(intendedUseElement, o.intendedUseElement, true) and compareDeep(indicationElement, o.indicationElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(speciesElement, o.speciesElement, true);
  end;
end;

function TFhirMedicinalProductSpecialDesignation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FIntendedUse) and isEmptyProp(FIndication) and isEmptyProp(FStatus) and isEmptyProp(FDate) and isEmptyProp(FSpecies);
end;

procedure TFhirMedicinalProductSpecialDesignation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('intendedUse');
  fields.add('indication[x]');
  fields.add('status');
  fields.add('date');
  fields.add('species');
end;

{ TFhirMedicinalProductSpecialDesignation }

Function TFhirMedicinalProductSpecialDesignation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirMedicinalProductSpecialDesignation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirMedicinalProductSpecialDesignation.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirMedicinalProductSpecialDesignation.SetIntendedUse(value : TFhirCodeableConcept);
begin
  FIntendedUse.free;
  FIntendedUse := value;
end;

Procedure TFhirMedicinalProductSpecialDesignation.SetIndication(value : TFhirType);
begin
  FIndication.free;
  FIndication := value;
end;

Procedure TFhirMedicinalProductSpecialDesignation.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

Procedure TFhirMedicinalProductSpecialDesignation.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirMedicinalProductSpecialDesignation.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirMedicinalProductSpecialDesignation.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirMedicinalProductSpecialDesignation.SetSpecies(value : TFhirCodeableConcept);
begin
  FSpecies.free;
  FSpecies := value;
end;

function TFhirMedicinalProductSpecialDesignation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FIntendedUse.sizeInBytes);
  inc(result, FIndication.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FSpecies.sizeInBytes);
end;

{ TFhirMedicinalProductSpecialDesignationListEnumerator }

Constructor TFhirMedicinalProductSpecialDesignationListEnumerator.Create(list : TFhirMedicinalProductSpecialDesignationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductSpecialDesignationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductSpecialDesignationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductSpecialDesignationListEnumerator.GetCurrent : TFhirMedicinalProductSpecialDesignation;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductSpecialDesignationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductSpecialDesignationList }
procedure TFhirMedicinalProductSpecialDesignationList.AddItem(value: TFhirMedicinalProductSpecialDesignation);
begin
  assert(value.ClassName = 'TFhirMedicinalProductSpecialDesignation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductSpecialDesignation');
  add(value);
end;

function TFhirMedicinalProductSpecialDesignationList.Append: TFhirMedicinalProductSpecialDesignation;
begin
  result := TFhirMedicinalProductSpecialDesignation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductSpecialDesignationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductSpecialDesignationList.GetEnumerator : TFhirMedicinalProductSpecialDesignationListEnumerator;
begin
  result := TFhirMedicinalProductSpecialDesignationListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductSpecialDesignationList.Clone: TFhirMedicinalProductSpecialDesignationList;
begin
  result := TFhirMedicinalProductSpecialDesignationList(inherited Clone);
end;

function TFhirMedicinalProductSpecialDesignationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductSpecialDesignationList.GetItemN(index: Integer): TFhirMedicinalProductSpecialDesignation;
begin
  result := TFhirMedicinalProductSpecialDesignation(ObjectByIndex[index]);
end;

function TFhirMedicinalProductSpecialDesignationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductSpecialDesignation;
end;
function TFhirMedicinalProductSpecialDesignationList.IndexOf(value: TFhirMedicinalProductSpecialDesignation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductSpecialDesignationList.Insert(index: Integer): TFhirMedicinalProductSpecialDesignation;
begin
  result := TFhirMedicinalProductSpecialDesignation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductSpecialDesignationList.InsertItem(index: Integer; value: TFhirMedicinalProductSpecialDesignation);
begin
  assert(value is TFhirMedicinalProductSpecialDesignation);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductSpecialDesignationList.Item(index: Integer): TFhirMedicinalProductSpecialDesignation;
begin
  result := TFhirMedicinalProductSpecialDesignation(ObjectByIndex[index]);
end;

function TFhirMedicinalProductSpecialDesignationList.Link: TFhirMedicinalProductSpecialDesignationList;
begin
  result := TFhirMedicinalProductSpecialDesignationList(inherited Link);
end;

procedure TFhirMedicinalProductSpecialDesignationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductSpecialDesignationList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductSpecialDesignation);
begin
  assert(value is TFhirMedicinalProductSpecialDesignation);
  FhirMedicinalProductSpecialDesignations[index] := value;
end;

procedure TFhirMedicinalProductSpecialDesignationList.SetItemN(index: Integer; value: TFhirMedicinalProductSpecialDesignation);
begin
  assert(value is TFhirMedicinalProductSpecialDesignation);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProduct }

constructor TFhirMedicinalProduct.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProduct.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FDomain.free;
  FCombinedPharmaceuticalDoseForm.free;
  FLegalStatusOfSupply.free;
  FAdditionalMonitoringIndicator.free;
  FSpecialMeasuresList.Free;
  FPaediatricUseIndicator.free;
  FProductClassificationList.Free;
  FMarketingStatusList.Free;
  FPharmaceuticalProductList.Free;
  FPackagedMedicinalProductList.Free;
  FAttachedDocumentList.Free;
  FMasterFileList.Free;
  FContactList.Free;
  FClinicalTrialList.Free;
  FNameList.Free;
  FCrossReferenceList.Free;
  FManufacturingBusinessOperationList.Free;
  FSpecialDesignationList.Free;
  inherited;
end;

function TFhirMedicinalProduct.GetResourceType : TFhirResourceType;
begin
  result := frtMedicinalProduct;
end;

procedure TFhirMedicinalProduct.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicinalProduct(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicinalProduct(oSource).FIdentifierList);
  end;
  type_ := TFhirMedicinalProduct(oSource).type_.Clone;
  domain := TFhirMedicinalProduct(oSource).domain.Clone;
  combinedPharmaceuticalDoseForm := TFhirMedicinalProduct(oSource).combinedPharmaceuticalDoseForm.Clone;
  legalStatusOfSupply := TFhirMedicinalProduct(oSource).legalStatusOfSupply.Clone;
  additionalMonitoringIndicator := TFhirMedicinalProduct(oSource).additionalMonitoringIndicator.Clone;
  if (TFhirMedicinalProduct(oSource).FSpecialMeasuresList = nil) then
  begin
    FSpecialMeasuresList.free;
    FSpecialMeasuresList := nil;
  end
  else
  begin
    if FSpecialMeasuresList = nil then
      FSpecialMeasuresList := TFhirStringList.Create;
    FSpecialMeasuresList.Assign(TFhirMedicinalProduct(oSource).FSpecialMeasuresList);
  end;
  paediatricUseIndicator := TFhirMedicinalProduct(oSource).paediatricUseIndicator.Clone;
  if (TFhirMedicinalProduct(oSource).FProductClassificationList = nil) then
  begin
    FProductClassificationList.free;
    FProductClassificationList := nil;
  end
  else
  begin
    if FProductClassificationList = nil then
      FProductClassificationList := TFhirCodeableConceptList.Create;
    FProductClassificationList.Assign(TFhirMedicinalProduct(oSource).FProductClassificationList);
  end;
  if (TFhirMedicinalProduct(oSource).FMarketingStatusList = nil) then
  begin
    FMarketingStatusList.free;
    FMarketingStatusList := nil;
  end
  else
  begin
    if FMarketingStatusList = nil then
      FMarketingStatusList := TFhirMarketingStatusList.Create;
    FMarketingStatusList.Assign(TFhirMedicinalProduct(oSource).FMarketingStatusList);
  end;
  if (TFhirMedicinalProduct(oSource).FPharmaceuticalProductList = nil) then
  begin
    FPharmaceuticalProductList.free;
    FPharmaceuticalProductList := nil;
  end
  else
  begin
    if FPharmaceuticalProductList = nil then
      FPharmaceuticalProductList := TFhirReferenceList{TFhirMedicinalProductPharmaceutical}.Create;
    FPharmaceuticalProductList.Assign(TFhirMedicinalProduct(oSource).FPharmaceuticalProductList);
  end;
  if (TFhirMedicinalProduct(oSource).FPackagedMedicinalProductList = nil) then
  begin
    FPackagedMedicinalProductList.free;
    FPackagedMedicinalProductList := nil;
  end
  else
  begin
    if FPackagedMedicinalProductList = nil then
      FPackagedMedicinalProductList := TFhirReferenceList{TFhirMedicinalProductPackaged}.Create;
    FPackagedMedicinalProductList.Assign(TFhirMedicinalProduct(oSource).FPackagedMedicinalProductList);
  end;
  if (TFhirMedicinalProduct(oSource).FAttachedDocumentList = nil) then
  begin
    FAttachedDocumentList.free;
    FAttachedDocumentList := nil;
  end
  else
  begin
    if FAttachedDocumentList = nil then
      FAttachedDocumentList := TFhirReferenceList{TFhirDocumentReference}.Create;
    FAttachedDocumentList.Assign(TFhirMedicinalProduct(oSource).FAttachedDocumentList);
  end;
  if (TFhirMedicinalProduct(oSource).FMasterFileList = nil) then
  begin
    FMasterFileList.free;
    FMasterFileList := nil;
  end
  else
  begin
    if FMasterFileList = nil then
      FMasterFileList := TFhirReferenceList{TFhirDocumentReference}.Create;
    FMasterFileList.Assign(TFhirMedicinalProduct(oSource).FMasterFileList);
  end;
  if (TFhirMedicinalProduct(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirReferenceList{TFhirOrganization}.Create;
    FContactList.Assign(TFhirMedicinalProduct(oSource).FContactList);
  end;
  if (TFhirMedicinalProduct(oSource).FClinicalTrialList = nil) then
  begin
    FClinicalTrialList.free;
    FClinicalTrialList := nil;
  end
  else
  begin
    if FClinicalTrialList = nil then
      FClinicalTrialList := TFhirReferenceList{TFhirResearchStudy}.Create;
    FClinicalTrialList.Assign(TFhirMedicinalProduct(oSource).FClinicalTrialList);
  end;
  if (TFhirMedicinalProduct(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirMedicinalProductNameList.Create;
    FNameList.Assign(TFhirMedicinalProduct(oSource).FNameList);
  end;
  if (TFhirMedicinalProduct(oSource).FCrossReferenceList = nil) then
  begin
    FCrossReferenceList.free;
    FCrossReferenceList := nil;
  end
  else
  begin
    if FCrossReferenceList = nil then
      FCrossReferenceList := TFhirIdentifierList.Create;
    FCrossReferenceList.Assign(TFhirMedicinalProduct(oSource).FCrossReferenceList);
  end;
  if (TFhirMedicinalProduct(oSource).FManufacturingBusinessOperationList = nil) then
  begin
    FManufacturingBusinessOperationList.free;
    FManufacturingBusinessOperationList := nil;
  end
  else
  begin
    if FManufacturingBusinessOperationList = nil then
      FManufacturingBusinessOperationList := TFhirMedicinalProductManufacturingBusinessOperationList.Create;
    FManufacturingBusinessOperationList.Assign(TFhirMedicinalProduct(oSource).FManufacturingBusinessOperationList);
  end;
  if (TFhirMedicinalProduct(oSource).FSpecialDesignationList = nil) then
  begin
    FSpecialDesignationList.free;
    FSpecialDesignationList := nil;
  end
  else
  begin
    if FSpecialDesignationList = nil then
      FSpecialDesignationList := TFhirMedicinalProductSpecialDesignationList.Create;
    FSpecialDesignationList.Assign(TFhirMedicinalProduct(oSource).FSpecialDesignationList);
  end;
end;

procedure TFhirMedicinalProduct.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'domain') Then
     list.add(self.link, 'domain', FDomain.Link);
  if (child_name = 'combinedPharmaceuticalDoseForm') Then
     list.add(self.link, 'combinedPharmaceuticalDoseForm', FCombinedPharmaceuticalDoseForm.Link);
  if (child_name = 'legalStatusOfSupply') Then
     list.add(self.link, 'legalStatusOfSupply', FLegalStatusOfSupply.Link);
  if (child_name = 'additionalMonitoringIndicator') Then
     list.add(self.link, 'additionalMonitoringIndicator', FAdditionalMonitoringIndicator.Link);
  if (child_name = 'specialMeasures') Then
    list.addAll(self, 'specialMeasures', FSpecialMeasuresList);
  if (child_name = 'paediatricUseIndicator') Then
     list.add(self.link, 'paediatricUseIndicator', FPaediatricUseIndicator.Link);
  if (child_name = 'productClassification') Then
    list.addAll(self, 'productClassification', FProductClassificationList);
  if (child_name = 'marketingStatus') Then
    list.addAll(self, 'marketingStatus', FMarketingStatusList);
  if (child_name = 'pharmaceuticalProduct') Then
    list.addAll(self, 'pharmaceuticalProduct', FPharmaceuticalProductList);
  if (child_name = 'packagedMedicinalProduct') Then
    list.addAll(self, 'packagedMedicinalProduct', FPackagedMedicinalProductList);
  if (child_name = 'attachedDocument') Then
    list.addAll(self, 'attachedDocument', FAttachedDocumentList);
  if (child_name = 'masterFile') Then
    list.addAll(self, 'masterFile', FMasterFileList);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'clinicalTrial') Then
    list.addAll(self, 'clinicalTrial', FClinicalTrialList);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'crossReference') Then
    list.addAll(self, 'crossReference', FCrossReferenceList);
  if (child_name = 'manufacturingBusinessOperation') Then
    list.addAll(self, 'manufacturingBusinessOperation', FManufacturingBusinessOperationList);
  if (child_name = 'specialDesignation') Then
    list.addAll(self, 'specialDesignation', FSpecialDesignationList);
end;

procedure TFhirMedicinalProduct.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'domain', 'Coding', false, TFhirCoding, FDomain.Link));{2}
  oList.add(TFHIRProperty.create(self, 'combinedPharmaceuticalDoseForm', 'CodeableConcept', false, TFhirCodeableConcept, FCombinedPharmaceuticalDoseForm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'legalStatusOfSupply', 'CodeableConcept', false, TFhirCodeableConcept, FLegalStatusOfSupply.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additionalMonitoringIndicator', 'CodeableConcept', false, TFhirCodeableConcept, FAdditionalMonitoringIndicator.Link));{2}
  oList.add(TFHIRProperty.create(self, 'specialMeasures', 'string', true, TFhirString, FSpecialMeasuresList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'paediatricUseIndicator', 'CodeableConcept', false, TFhirCodeableConcept, FPaediatricUseIndicator.Link));{2}
  oList.add(TFHIRProperty.create(self, 'productClassification', 'CodeableConcept', true, TFhirCodeableConcept, FProductClassificationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'marketingStatus', 'MarketingStatus', true, TFhirMarketingStatus, FMarketingStatusList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'pharmaceuticalProduct', 'Reference(MedicinalProductPharmaceutical)', true, TFhirReference{TFhirMedicinalProductPharmaceutical}, FPharmaceuticalProductList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'packagedMedicinalProduct', 'Reference(MedicinalProductPackaged)', true, TFhirReference{TFhirMedicinalProductPackaged}, FPackagedMedicinalProductList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'attachedDocument', 'Reference(DocumentReference)', true, TFhirReference{TFhirDocumentReference}, FAttachedDocumentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'masterFile', 'Reference(DocumentReference)', true, TFhirReference{TFhirDocumentReference}, FMasterFileList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'contact', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FContactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'clinicalTrial', 'Reference(ResearchStudy)', true, TFhirReference{TFhirResearchStudy}, FClinicalTrialList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'name', '', true, TFhirMedicinalProductName, FNameList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'crossReference', 'Identifier', true, TFhirIdentifier, FCrossReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'manufacturingBusinessOperation', '', true, TFhirMedicinalProductManufacturingBusinessOperation, FManufacturingBusinessOperationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'specialDesignation', '', true, TFhirMedicinalProductSpecialDesignation, FSpecialDesignationList.Link)){3};
end;

function TFhirMedicinalProduct.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'domain') then
  begin
    Domain := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'combinedPharmaceuticalDoseForm') then
  begin
    CombinedPharmaceuticalDoseForm := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'legalStatusOfSupply') then
  begin
    LegalStatusOfSupply := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'additionalMonitoringIndicator') then
  begin
    AdditionalMonitoringIndicator := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'specialMeasures') then
  begin
    SpecialMeasuresList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'paediatricUseIndicator') then
  begin
    PaediatricUseIndicator := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'productClassification') then
  begin
    ProductClassificationList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'marketingStatus') then
  begin
    MarketingStatusList.add(propValue as TFhirMarketingStatus){2a};
    result := propValue;
  end
  else if (propName = 'pharmaceuticalProduct') then
  begin
    PharmaceuticalProductList.add(propValue as TFhirReference{TFhirMedicinalProductPharmaceutical}){2a};
    result := propValue;
  end
  else if (propName = 'packagedMedicinalProduct') then
  begin
    PackagedMedicinalProductList.add(propValue as TFhirReference{TFhirMedicinalProductPackaged}){2a};
    result := propValue;
  end
  else if (propName = 'attachedDocument') then
  begin
    AttachedDocumentList.add(propValue as TFhirReference{TFhirDocumentReference}){2a};
    result := propValue;
  end
  else if (propName = 'masterFile') then
  begin
    MasterFileList.add(propValue as TFhirReference{TFhirDocumentReference}){2a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else if (propName = 'clinicalTrial') then
  begin
    ClinicalTrialList.add(propValue as TFhirReference{TFhirResearchStudy}){2a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirMedicinalProductName){2a};
    result := propValue;
  end
  else if (propName = 'crossReference') then
  begin
    CrossReferenceList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'manufacturingBusinessOperation') then
  begin
    ManufacturingBusinessOperationList.add(propValue as TFhirMedicinalProductManufacturingBusinessOperation){2a};
    result := propValue;
  end
  else if (propName = 'specialDesignation') then
  begin
    SpecialDesignationList.add(propValue as TFhirMedicinalProductSpecialDesignation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedicinalProduct.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'specialMeasures') then SpecialMeasuresList.insertItem(index, asString(propValue)){2}
  else if (propName = 'productClassification') then ProductClassificationList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'marketingStatus') then MarketingStatusList.insertItem(index, propValue as TFhirMarketingStatus){2a}
  else if (propName = 'pharmaceuticalProduct') then PharmaceuticalProductList.insertItem(index, propValue as TFhirReference{TFhirMedicinalProductPharmaceutical}){2a}
  else if (propName = 'packagedMedicinalProduct') then PackagedMedicinalProductList.insertItem(index, propValue as TFhirReference{TFhirMedicinalProductPackaged}){2a}
  else if (propName = 'attachedDocument') then AttachedDocumentList.insertItem(index, propValue as TFhirReference{TFhirDocumentReference}){2a}
  else if (propName = 'masterFile') then MasterFileList.insertItem(index, propValue as TFhirReference{TFhirDocumentReference}){2a}
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else if (propName = 'clinicalTrial') then ClinicalTrialList.insertItem(index, propValue as TFhirReference{TFhirResearchStudy}){2a}
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirMedicinalProductName){2a}
  else if (propName = 'crossReference') then CrossReferenceList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'manufacturingBusinessOperation') then ManufacturingBusinessOperationList.insertItem(index, propValue as TFhirMedicinalProductManufacturingBusinessOperation){2a}
  else if (propName = 'specialDesignation') then SpecialDesignationList.insertItem(index, propValue as TFhirMedicinalProductSpecialDesignation){2a}
  else inherited;
end;

function TFhirMedicinalProduct.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'domain') then result := TFhirCoding.create(){4b}
  else if (propName = 'combinedPharmaceuticalDoseForm') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'legalStatusOfSupply') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'additionalMonitoringIndicator') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'specialMeasures') then result := SpecialMeasuresList.new(){2}
  else if (propName = 'paediatricUseIndicator') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'productClassification') then result := ProductClassificationList.new(){2}
  else if (propName = 'marketingStatus') then result := MarketingStatusList.new(){2}
  else if (propName = 'pharmaceuticalProduct') then result := PharmaceuticalProductList.new(){2}
  else if (propName = 'packagedMedicinalProduct') then result := PackagedMedicinalProductList.new(){2}
  else if (propName = 'attachedDocument') then result := AttachedDocumentList.new(){2}
  else if (propName = 'masterFile') then result := MasterFileList.new(){2}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'clinicalTrial') then result := ClinicalTrialList.new(){2}
  else if (propName = 'name') then result := NameList.new(){2}
  else if (propName = 'crossReference') then result := CrossReferenceList.new(){2}
  else if (propName = 'manufacturingBusinessOperation') then result := ManufacturingBusinessOperationList.new(){2}
  else if (propName = 'specialDesignation') then result := SpecialDesignationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProduct.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'domain') then result := 'Coding'
  else if (propName = 'combinedPharmaceuticalDoseForm') then result := 'CodeableConcept'
  else if (propName = 'legalStatusOfSupply') then result := 'CodeableConcept'
  else if (propName = 'additionalMonitoringIndicator') then result := 'CodeableConcept'
  else if (propName = 'specialMeasures') then result := 'string'
  else if (propName = 'paediatricUseIndicator') then result := 'CodeableConcept'
  else if (propName = 'productClassification') then result := 'CodeableConcept'
  else if (propName = 'marketingStatus') then result := 'MarketingStatus'
  else if (propName = 'pharmaceuticalProduct') then result := 'Reference'
  else if (propName = 'packagedMedicinalProduct') then result := 'Reference'
  else if (propName = 'attachedDocument') then result := 'Reference'
  else if (propName = 'masterFile') then result := 'Reference'
  else if (propName = 'contact') then result := 'Reference'
  else if (propName = 'clinicalTrial') then result := 'Reference'
  else if (propName = 'name') then result := ''
  else if (propName = 'crossReference') then result := 'Identifier'
  else if (propName = 'manufacturingBusinessOperation') then result := ''
  else if (propName = 'specialDesignation') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProduct.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'domain') then DomainElement := nil
  else if (propName = 'combinedPharmaceuticalDoseForm') then CombinedPharmaceuticalDoseFormElement := nil
  else if (propName = 'legalStatusOfSupply') then LegalStatusOfSupplyElement := nil
  else if (propName = 'additionalMonitoringIndicator') then AdditionalMonitoringIndicatorElement := nil
  else if (propName = 'specialMeasures') then deletePropertyValue('specialMeasures', SpecialMeasuresList, value) {2}
  else if (propName = 'paediatricUseIndicator') then PaediatricUseIndicatorElement := nil
  else if (propName = 'productClassification') then deletePropertyValue('productClassification', ProductClassificationList, value) {2}
  else if (propName = 'marketingStatus') then deletePropertyValue('marketingStatus', MarketingStatusList, value) {2}
  else if (propName = 'pharmaceuticalProduct') then deletePropertyValue('pharmaceuticalProduct', PharmaceuticalProductList, value) {2}
  else if (propName = 'packagedMedicinalProduct') then deletePropertyValue('packagedMedicinalProduct', PackagedMedicinalProductList, value) {2}
  else if (propName = 'attachedDocument') then deletePropertyValue('attachedDocument', AttachedDocumentList, value) {2}
  else if (propName = 'masterFile') then deletePropertyValue('masterFile', MasterFileList, value) {2}
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'clinicalTrial') then deletePropertyValue('clinicalTrial', ClinicalTrialList, value) {2}
  else if (propName = 'name') then deletePropertyValue('name', NameList, value) {2}
  else if (propName = 'crossReference') then deletePropertyValue('crossReference', CrossReferenceList, value) {2}
  else if (propName = 'manufacturingBusinessOperation') then deletePropertyValue('manufacturingBusinessOperation', ManufacturingBusinessOperationList, value) {2}
  else if (propName = 'specialDesignation') then deletePropertyValue('specialDesignation', SpecialDesignationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProduct.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'domain') then DomainElement := new as TFhirCoding{4}
  else if (propName = 'combinedPharmaceuticalDoseForm') then CombinedPharmaceuticalDoseFormElement := new as TFhirCodeableConcept{4}
  else if (propName = 'legalStatusOfSupply') then LegalStatusOfSupplyElement := new as TFhirCodeableConcept{4}
  else if (propName = 'additionalMonitoringIndicator') then AdditionalMonitoringIndicatorElement := new as TFhirCodeableConcept{4}
  else if (propName = 'specialMeasures') then replacePropertyValue('specialMeasures', SpecialMeasuresList, existing, new) {2}
  else if (propName = 'paediatricUseIndicator') then PaediatricUseIndicatorElement := new as TFhirCodeableConcept{4}
  else if (propName = 'productClassification') then replacePropertyValue('productClassification', ProductClassificationList, existing, new) {2}
  else if (propName = 'marketingStatus') then replacePropertyValue('marketingStatus', MarketingStatusList, existing, new) {2}
  else if (propName = 'pharmaceuticalProduct') then replacePropertyValue('pharmaceuticalProduct', PharmaceuticalProductList, existing, new) {2}
  else if (propName = 'packagedMedicinalProduct') then replacePropertyValue('packagedMedicinalProduct', PackagedMedicinalProductList, existing, new) {2}
  else if (propName = 'attachedDocument') then replacePropertyValue('attachedDocument', AttachedDocumentList, existing, new) {2}
  else if (propName = 'masterFile') then replacePropertyValue('masterFile', MasterFileList, existing, new) {2}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'clinicalTrial') then replacePropertyValue('clinicalTrial', ClinicalTrialList, existing, new) {2}
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new) {2}
  else if (propName = 'crossReference') then replacePropertyValue('crossReference', CrossReferenceList, existing, new) {2}
  else if (propName = 'manufacturingBusinessOperation') then replacePropertyValue('manufacturingBusinessOperation', ManufacturingBusinessOperationList, existing, new) {2}
  else if (propName = 'specialDesignation') then replacePropertyValue('specialDesignation', SpecialDesignationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProduct.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'specialMeasures') then SpecialMeasuresList.move(source, destination){2}
  else if (propName = 'productClassification') then ProductClassificationList.move(source, destination){2a}
  else if (propName = 'marketingStatus') then MarketingStatusList.move(source, destination){2a}
  else if (propName = 'pharmaceuticalProduct') then PharmaceuticalProductList.move(source, destination){2a}
  else if (propName = 'packagedMedicinalProduct') then PackagedMedicinalProductList.move(source, destination){2a}
  else if (propName = 'attachedDocument') then AttachedDocumentList.move(source, destination){2a}
  else if (propName = 'masterFile') then MasterFileList.move(source, destination){2a}
  else if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'clinicalTrial') then ClinicalTrialList.move(source, destination){2a}
  else if (propName = 'name') then NameList.move(source, destination){2a}
  else if (propName = 'crossReference') then CrossReferenceList.move(source, destination){2a}
  else if (propName = 'manufacturingBusinessOperation') then ManufacturingBusinessOperationList.move(source, destination){2a}
  else if (propName = 'specialDesignation') then SpecialDesignationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProduct.fhirType : string;
begin
  result := 'MedicinalProduct';
end;

function TFhirMedicinalProduct.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FDomain) and isEmptyProp(FCombinedPharmaceuticalDoseForm) and isEmptyProp(FLegalStatusOfSupply) and isEmptyProp(FAdditionalMonitoringIndicator) and isEmptyProp(FspecialMeasuresList) and isEmptyProp(FPaediatricUseIndicator) and isEmptyProp(FproductClassificationList) and isEmptyProp(FmarketingStatusList) and isEmptyProp(FpharmaceuticalProductList) and isEmptyProp(FpackagedMedicinalProductList) and isEmptyProp(FattachedDocumentList) and isEmptyProp(FmasterFileList) and isEmptyProp(FcontactList) and isEmptyProp(FclinicalTrialList) and isEmptyProp(FnameList) and isEmptyProp(FcrossReferenceList) and isEmptyProp(FmanufacturingBusinessOperationList) and isEmptyProp(FspecialDesignationList);
end;

function TFhirMedicinalProduct.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProduct;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProduct)) then
    result := false
  else
  begin
    o := TFhirMedicinalProduct(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(domainElement, o.domainElement, true) and compareDeep(combinedPharmaceuticalDoseFormElement, o.combinedPharmaceuticalDoseFormElement, true) and 
      compareDeep(legalStatusOfSupplyElement, o.legalStatusOfSupplyElement, true) and 
      compareDeep(additionalMonitoringIndicatorElement, o.additionalMonitoringIndicatorElement, true) and 
      compareDeep(specialMeasuresList, o.specialMeasuresList, true) and compareDeep(paediatricUseIndicatorElement, o.paediatricUseIndicatorElement, true) and 
      compareDeep(productClassificationList, o.productClassificationList, true) and 
      compareDeep(marketingStatusList, o.marketingStatusList, true) and compareDeep(pharmaceuticalProductList, o.pharmaceuticalProductList, true) and 
      compareDeep(packagedMedicinalProductList, o.packagedMedicinalProductList, true) and 
      compareDeep(attachedDocumentList, o.attachedDocumentList, true) and compareDeep(masterFileList, o.masterFileList, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(clinicalTrialList, o.clinicalTrialList, true) and 
      compareDeep(nameList, o.nameList, true) and compareDeep(crossReferenceList, o.crossReferenceList, true) and 
      compareDeep(manufacturingBusinessOperationList, o.manufacturingBusinessOperationList, true) and 
      compareDeep(specialDesignationList, o.specialDesignationList, true);
  end;
end;

function TFhirMedicinalProduct.Link : TFhirMedicinalProduct;
begin
  result := TFhirMedicinalProduct(inherited Link);
end;

function TFhirMedicinalProduct.Clone : TFhirMedicinalProduct;
begin
  result := TFhirMedicinalProduct(inherited Clone);
end;

procedure TFhirMedicinalProduct.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('domain');
  fields.add('combinedPharmaceuticalDoseForm');
  fields.add('legalStatusOfSupply');
  fields.add('additionalMonitoringIndicator');
  fields.add('specialMeasures');
  fields.add('paediatricUseIndicator');
  fields.add('productClassification');
  fields.add('marketingStatus');
  fields.add('pharmaceuticalProduct');
  fields.add('packagedMedicinalProduct');
  fields.add('attachedDocument');
  fields.add('masterFile');
  fields.add('contact');
  fields.add('clinicalTrial');
  fields.add('name');
  fields.add('crossReference');
  fields.add('manufacturingBusinessOperation');
  fields.add('specialDesignation');
end;

{ TFhirMedicinalProduct }

Function TFhirMedicinalProduct.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirMedicinalProduct.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirMedicinalProduct.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirMedicinalProduct.SetDomain(value : TFhirCoding);
begin
  FDomain.free;
  FDomain := value;
end;

Procedure TFhirMedicinalProduct.SetCombinedPharmaceuticalDoseForm(value : TFhirCodeableConcept);
begin
  FCombinedPharmaceuticalDoseForm.free;
  FCombinedPharmaceuticalDoseForm := value;
end;

Procedure TFhirMedicinalProduct.SetLegalStatusOfSupply(value : TFhirCodeableConcept);
begin
  FLegalStatusOfSupply.free;
  FLegalStatusOfSupply := value;
end;

Procedure TFhirMedicinalProduct.SetAdditionalMonitoringIndicator(value : TFhirCodeableConcept);
begin
  FAdditionalMonitoringIndicator.free;
  FAdditionalMonitoringIndicator := value;
end;

Function TFhirMedicinalProduct.GetSpecialMeasuresList : TFhirStringList;
begin
  if FSpecialMeasuresList = nil then
    FSpecialMeasuresList := TFhirStringList.Create;
  result := FSpecialMeasuresList;
end;

Function TFhirMedicinalProduct.GetHasSpecialMeasuresList : boolean;
begin
  result := (FSpecialMeasuresList <> nil) and (FSpecialMeasuresList.count > 0);
end;

Procedure TFhirMedicinalProduct.SetPaediatricUseIndicator(value : TFhirCodeableConcept);
begin
  FPaediatricUseIndicator.free;
  FPaediatricUseIndicator := value;
end;

Function TFhirMedicinalProduct.GetProductClassificationList : TFhirCodeableConceptList;
begin
  if FProductClassificationList = nil then
    FProductClassificationList := TFhirCodeableConceptList.Create;
  result := FProductClassificationList;
end;

Function TFhirMedicinalProduct.GetHasProductClassificationList : boolean;
begin
  result := (FProductClassificationList <> nil) and (FProductClassificationList.count > 0);
end;

Function TFhirMedicinalProduct.GetMarketingStatusList : TFhirMarketingStatusList;
begin
  if FMarketingStatusList = nil then
    FMarketingStatusList := TFhirMarketingStatusList.Create;
  result := FMarketingStatusList;
end;

Function TFhirMedicinalProduct.GetHasMarketingStatusList : boolean;
begin
  result := (FMarketingStatusList <> nil) and (FMarketingStatusList.count > 0);
end;

Function TFhirMedicinalProduct.GetPharmaceuticalProductList : TFhirReferenceList{TFhirMedicinalProductPharmaceutical};
begin
  if FPharmaceuticalProductList = nil then
    FPharmaceuticalProductList := TFhirReferenceList{TFhirMedicinalProductPharmaceutical}.Create;
  result := FPharmaceuticalProductList;
end;

Function TFhirMedicinalProduct.GetHasPharmaceuticalProductList : boolean;
begin
  result := (FPharmaceuticalProductList <> nil) and (FPharmaceuticalProductList.count > 0);
end;

Function TFhirMedicinalProduct.GetPackagedMedicinalProductList : TFhirReferenceList{TFhirMedicinalProductPackaged};
begin
  if FPackagedMedicinalProductList = nil then
    FPackagedMedicinalProductList := TFhirReferenceList{TFhirMedicinalProductPackaged}.Create;
  result := FPackagedMedicinalProductList;
end;

Function TFhirMedicinalProduct.GetHasPackagedMedicinalProductList : boolean;
begin
  result := (FPackagedMedicinalProductList <> nil) and (FPackagedMedicinalProductList.count > 0);
end;

Function TFhirMedicinalProduct.GetAttachedDocumentList : TFhirReferenceList{TFhirDocumentReference};
begin
  if FAttachedDocumentList = nil then
    FAttachedDocumentList := TFhirReferenceList{TFhirDocumentReference}.Create;
  result := FAttachedDocumentList;
end;

Function TFhirMedicinalProduct.GetHasAttachedDocumentList : boolean;
begin
  result := (FAttachedDocumentList <> nil) and (FAttachedDocumentList.count > 0);
end;

Function TFhirMedicinalProduct.GetMasterFileList : TFhirReferenceList{TFhirDocumentReference};
begin
  if FMasterFileList = nil then
    FMasterFileList := TFhirReferenceList{TFhirDocumentReference}.Create;
  result := FMasterFileList;
end;

Function TFhirMedicinalProduct.GetHasMasterFileList : boolean;
begin
  result := (FMasterFileList <> nil) and (FMasterFileList.count > 0);
end;

Function TFhirMedicinalProduct.GetContactList : TFhirReferenceList{TFhirOrganization};
begin
  if FContactList = nil then
    FContactList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FContactList;
end;

Function TFhirMedicinalProduct.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Function TFhirMedicinalProduct.GetClinicalTrialList : TFhirReferenceList{TFhirResearchStudy};
begin
  if FClinicalTrialList = nil then
    FClinicalTrialList := TFhirReferenceList{TFhirResearchStudy}.Create;
  result := FClinicalTrialList;
end;

Function TFhirMedicinalProduct.GetHasClinicalTrialList : boolean;
begin
  result := (FClinicalTrialList <> nil) and (FClinicalTrialList.count > 0);
end;

Function TFhirMedicinalProduct.GetNameList : TFhirMedicinalProductNameList;
begin
  if FNameList = nil then
    FNameList := TFhirMedicinalProductNameList.Create;
  result := FNameList;
end;

Function TFhirMedicinalProduct.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

Function TFhirMedicinalProduct.GetCrossReferenceList : TFhirIdentifierList;
begin
  if FCrossReferenceList = nil then
    FCrossReferenceList := TFhirIdentifierList.Create;
  result := FCrossReferenceList;
end;

Function TFhirMedicinalProduct.GetHasCrossReferenceList : boolean;
begin
  result := (FCrossReferenceList <> nil) and (FCrossReferenceList.count > 0);
end;

Function TFhirMedicinalProduct.GetManufacturingBusinessOperationList : TFhirMedicinalProductManufacturingBusinessOperationList;
begin
  if FManufacturingBusinessOperationList = nil then
    FManufacturingBusinessOperationList := TFhirMedicinalProductManufacturingBusinessOperationList.Create;
  result := FManufacturingBusinessOperationList;
end;

Function TFhirMedicinalProduct.GetHasManufacturingBusinessOperationList : boolean;
begin
  result := (FManufacturingBusinessOperationList <> nil) and (FManufacturingBusinessOperationList.count > 0);
end;

Function TFhirMedicinalProduct.GetSpecialDesignationList : TFhirMedicinalProductSpecialDesignationList;
begin
  if FSpecialDesignationList = nil then
    FSpecialDesignationList := TFhirMedicinalProductSpecialDesignationList.Create;
  result := FSpecialDesignationList;
end;

Function TFhirMedicinalProduct.GetHasSpecialDesignationList : boolean;
begin
  result := (FSpecialDesignationList <> nil) and (FSpecialDesignationList.count > 0);
end;

function TFhirMedicinalProduct.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FDomain.sizeInBytes);
  inc(result, FCombinedPharmaceuticalDoseForm.sizeInBytes);
  inc(result, FLegalStatusOfSupply.sizeInBytes);
  inc(result, FAdditionalMonitoringIndicator.sizeInBytes);
  inc(result, FspecialMeasuresList.sizeInBytes);
  inc(result, FPaediatricUseIndicator.sizeInBytes);
  inc(result, FproductClassificationList.sizeInBytes);
  inc(result, FmarketingStatusList.sizeInBytes);
  inc(result, FpharmaceuticalProductList.sizeInBytes);
  inc(result, FpackagedMedicinalProductList.sizeInBytes);
  inc(result, FattachedDocumentList.sizeInBytes);
  inc(result, FmasterFileList.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FclinicalTrialList.sizeInBytes);
  inc(result, FnameList.sizeInBytes);
  inc(result, FcrossReferenceList.sizeInBytes);
  inc(result, FmanufacturingBusinessOperationList.sizeInBytes);
  inc(result, FspecialDesignationList.sizeInBytes);
end;

{ TFhirMedicinalProductListEnumerator }

Constructor TFhirMedicinalProductListEnumerator.Create(list : TFhirMedicinalProductList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductListEnumerator.GetCurrent : TFhirMedicinalProduct;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductList }
procedure TFhirMedicinalProductList.AddItem(value: TFhirMedicinalProduct);
begin
  assert(value.ClassName = 'TFhirMedicinalProduct', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProduct');
  add(value);
end;

function TFhirMedicinalProductList.Append: TFhirMedicinalProduct;
begin
  result := TFhirMedicinalProduct.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductList.GetEnumerator : TFhirMedicinalProductListEnumerator;
begin
  result := TFhirMedicinalProductListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductList.Clone: TFhirMedicinalProductList;
begin
  result := TFhirMedicinalProductList(inherited Clone);
end;

function TFhirMedicinalProductList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductList.GetItemN(index: Integer): TFhirMedicinalProduct;
begin
  result := TFhirMedicinalProduct(ObjectByIndex[index]);
end;

function TFhirMedicinalProductList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProduct;
end;
function TFhirMedicinalProductList.IndexOf(value: TFhirMedicinalProduct): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductList.Insert(index: Integer): TFhirMedicinalProduct;
begin
  result := TFhirMedicinalProduct.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductList.InsertItem(index: Integer; value: TFhirMedicinalProduct);
begin
  assert(value is TFhirMedicinalProduct);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductList.Item(index: Integer): TFhirMedicinalProduct;
begin
  result := TFhirMedicinalProduct(ObjectByIndex[index]);
end;

function TFhirMedicinalProductList.Link: TFhirMedicinalProductList;
begin
  result := TFhirMedicinalProductList(inherited Link);
end;

procedure TFhirMedicinalProductList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductList.SetItemByIndex(index: Integer; value: TFhirMedicinalProduct);
begin
  assert(value is TFhirMedicinalProduct);
  FhirMedicinalProducts[index] := value;
end;

procedure TFhirMedicinalProductList.SetItemN(index: Integer; value: TFhirMedicinalProduct);
begin
  assert(value is TFhirMedicinalProduct);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICINALPRODUCT}

{$IFDEF FHIR_MEDICINALPRODUCTAUTHORIZATION}

{ TFhirMedicinalProductAuthorizationJurisdictionalAuthorization }

constructor TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.Destroy;
begin
  FIdentifierList.Free;
  FCountry.free;
  FJurisdictionList.Free;
  FLegalStatusOfSupply.free;
  FValidityPeriod.free;
  inherited;
end;

procedure TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicinalProductAuthorizationJurisdictionalAuthorization(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicinalProductAuthorizationJurisdictionalAuthorization(oSource).FIdentifierList);
  end;
  country := TFhirMedicinalProductAuthorizationJurisdictionalAuthorization(oSource).country.Clone;
  if (TFhirMedicinalProductAuthorizationJurisdictionalAuthorization(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirMedicinalProductAuthorizationJurisdictionalAuthorization(oSource).FJurisdictionList);
  end;
  legalStatusOfSupply := TFhirMedicinalProductAuthorizationJurisdictionalAuthorization(oSource).legalStatusOfSupply.Clone;
  validityPeriod := TFhirMedicinalProductAuthorizationJurisdictionalAuthorization(oSource).validityPeriod.Clone;
end;

procedure TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'country') Then
     list.add(self.link, 'country', FCountry.Link);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'legalStatusOfSupply') Then
     list.add(self.link, 'legalStatusOfSupply', FLegalStatusOfSupply.Link);
  if (child_name = 'validityPeriod') Then
     list.add(self.link, 'validityPeriod', FValidityPeriod.Link);
end;

procedure TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'country', 'CodeableConcept', false, TFhirCodeableConcept, FCountry.Link));{2}
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'legalStatusOfSupply', 'CodeableConcept', false, TFhirCodeableConcept, FLegalStatusOfSupply.Link));{2}
  oList.add(TFHIRProperty.create(self, 'validityPeriod', 'Period', false, TFhirPeriod, FValidityPeriod.Link));{2}
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'country') then
  begin
    Country := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'legalStatusOfSupply') then
  begin
    LegalStatusOfSupply := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'validityPeriod') then
  begin
    ValidityPeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'country') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'jurisdiction') then result := JurisdictionList.new(){2}
  else if (propName = 'legalStatusOfSupply') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'validityPeriod') then result := TFhirPeriod.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'country') then result := 'CodeableConcept'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'legalStatusOfSupply') then result := 'CodeableConcept'
  else if (propName = 'validityPeriod') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'country') then CountryElement := nil
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value) {2}
  else if (propName = 'legalStatusOfSupply') then LegalStatusOfSupplyElement := nil
  else if (propName = 'validityPeriod') then ValidityPeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'country') then CountryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new) {2}
  else if (propName = 'legalStatusOfSupply') then LegalStatusOfSupplyElement := new as TFhirCodeableConcept{4}
  else if (propName = 'validityPeriod') then ValidityPeriodElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.fhirType : string;
begin
  result := 'jurisdictionalAuthorization';
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.Link : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization;
begin
  result := TFhirMedicinalProductAuthorizationJurisdictionalAuthorization(inherited Link);
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.Clone : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization;
begin
  result := TFhirMedicinalProductAuthorizationJurisdictionalAuthorization(inherited Clone);
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductAuthorizationJurisdictionalAuthorization)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductAuthorizationJurisdictionalAuthorization(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(countryElement, o.countryElement, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(legalStatusOfSupplyElement, o.legalStatusOfSupplyElement, true) and 
      compareDeep(validityPeriodElement, o.validityPeriodElement, true);
  end;
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCountry) and isEmptyProp(FjurisdictionList) and isEmptyProp(FLegalStatusOfSupply) and isEmptyProp(FValidityPeriod);
end;

procedure TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('country');
  fields.add('jurisdiction');
  fields.add('legalStatusOfSupply');
  fields.add('validityPeriod');
end;

{ TFhirMedicinalProductAuthorizationJurisdictionalAuthorization }

Function TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.SetCountry(value : TFhirCodeableConcept);
begin
  FCountry.free;
  FCountry := value;
end;

Function TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

Function TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

Procedure TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.SetLegalStatusOfSupply(value : TFhirCodeableConcept);
begin
  FLegalStatusOfSupply.free;
  FLegalStatusOfSupply := value;
end;

Procedure TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.SetValidityPeriod(value : TFhirPeriod);
begin
  FValidityPeriod.free;
  FValidityPeriod := value;
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FCountry.sizeInBytes);
  inc(result, FjurisdictionList.sizeInBytes);
  inc(result, FLegalStatusOfSupply.sizeInBytes);
  inc(result, FValidityPeriod.sizeInBytes);
end;

{ TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationListEnumerator }

Constructor TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationListEnumerator.Create(list : TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationListEnumerator.GetCurrent : TFhirMedicinalProductAuthorizationJurisdictionalAuthorization;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList }
procedure TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList.AddItem(value: TFhirMedicinalProductAuthorizationJurisdictionalAuthorization);
begin
  assert(value.ClassName = 'TFhirMedicinalProductAuthorizationJurisdictionalAuthorization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductAuthorizationJurisdictionalAuthorization');
  add(value);
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList.Append: TFhirMedicinalProductAuthorizationJurisdictionalAuthorization;
begin
  result := TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList.GetEnumerator : TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationListEnumerator;
begin
  result := TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList.Clone: TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList;
begin
  result := TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList(inherited Clone);
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList.GetItemN(index: Integer): TFhirMedicinalProductAuthorizationJurisdictionalAuthorization;
begin
  result := TFhirMedicinalProductAuthorizationJurisdictionalAuthorization(ObjectByIndex[index]);
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductAuthorizationJurisdictionalAuthorization;
end;
function TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList.IndexOf(value: TFhirMedicinalProductAuthorizationJurisdictionalAuthorization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList.Insert(index: Integer): TFhirMedicinalProductAuthorizationJurisdictionalAuthorization;
begin
  result := TFhirMedicinalProductAuthorizationJurisdictionalAuthorization.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList.InsertItem(index: Integer; value: TFhirMedicinalProductAuthorizationJurisdictionalAuthorization);
begin
  assert(value is TFhirMedicinalProductAuthorizationJurisdictionalAuthorization);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList.Item(index: Integer): TFhirMedicinalProductAuthorizationJurisdictionalAuthorization;
begin
  result := TFhirMedicinalProductAuthorizationJurisdictionalAuthorization(ObjectByIndex[index]);
end;

function TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList.Link: TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList;
begin
  result := TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList(inherited Link);
end;

procedure TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductAuthorizationJurisdictionalAuthorization);
begin
  assert(value is TFhirMedicinalProductAuthorizationJurisdictionalAuthorization);
  FhirMedicinalProductAuthorizationJurisdictionalAuthorizations[index] := value;
end;

procedure TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList.SetItemN(index: Integer; value: TFhirMedicinalProductAuthorizationJurisdictionalAuthorization);
begin
  assert(value is TFhirMedicinalProductAuthorizationJurisdictionalAuthorization);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductAuthorizationProcedure }

constructor TFhirMedicinalProductAuthorizationProcedure.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductAuthorizationProcedure.Destroy;
begin
  FIdentifier.free;
  FType_.free;
  FDate.free;
  FApplicationList.Free;
  inherited;
end;

procedure TFhirMedicinalProductAuthorizationProcedure.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirMedicinalProductAuthorizationProcedure(oSource).identifier.Clone;
  type_ := TFhirMedicinalProductAuthorizationProcedure(oSource).type_.Clone;
  date := TFhirMedicinalProductAuthorizationProcedure(oSource).date.Clone;
  if (TFhirMedicinalProductAuthorizationProcedure(oSource).FApplicationList = nil) then
  begin
    FApplicationList.free;
    FApplicationList := nil;
  end
  else
  begin
    if FApplicationList = nil then
      FApplicationList := TFhirMedicinalProductAuthorizationProcedureList.Create;
    FApplicationList.Assign(TFhirMedicinalProductAuthorizationProcedure(oSource).FApplicationList);
  end;
end;

procedure TFhirMedicinalProductAuthorizationProcedure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'date[x]') or (child_name = 'date') Then
     list.add(self.link, 'date[x]', FDate.Link);
  if (child_name = 'application') Then
    list.addAll(self, 'application', FApplicationList);
end;

procedure TFhirMedicinalProductAuthorizationProcedure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date[x]', 'Period|dateTime', false, TFhirType, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'application', '@MedicinalProductAuthorization.procedure', true, TFhirMedicinalProductAuthorizationProcedure, FApplicationList.Link)){3};
end;

function TFhirMedicinalProductAuthorizationProcedure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'date', ['Period', 'DateTime'])) then
  begin
    Date := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'application') then
  begin
    ApplicationList.add(propValue as TFhirMedicinalProductAuthorizationProcedure){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductAuthorizationProcedure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'application') then ApplicationList.insertItem(index, propValue as TFhirMedicinalProductAuthorizationProcedure){2a}
  else inherited;
end;

function TFhirMedicinalProductAuthorizationProcedure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'date', ['Period', 'DateTime'])) then raise EFHIRException.create('Cannot make property Date'){4x}
  else if (propName = 'application') then result := ApplicationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductAuthorizationProcedure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'date[x]') then result := 'Period|dateTime'
  else if (propName = 'application') then result := '@MedicinalProductAuthorization.procedure'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductAuthorizationProcedure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'date', ['Period', 'DateTime'])) then DateElement := nil{4x}
  else if (propName = 'application') then deletePropertyValue('application', ApplicationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductAuthorizationProcedure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'date', ['Period', 'DateTime'])) then DateElement := new as TFhirType{4x}
  else if (propName = 'application') then replacePropertyValue('application', ApplicationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductAuthorizationProcedure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'application') then ApplicationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductAuthorizationProcedure.fhirType : string;
begin
  result := 'procedure';
end;

function TFhirMedicinalProductAuthorizationProcedure.Link : TFhirMedicinalProductAuthorizationProcedure;
begin
  result := TFhirMedicinalProductAuthorizationProcedure(inherited Link);
end;

function TFhirMedicinalProductAuthorizationProcedure.Clone : TFhirMedicinalProductAuthorizationProcedure;
begin
  result := TFhirMedicinalProductAuthorizationProcedure(inherited Clone);
end;

function TFhirMedicinalProductAuthorizationProcedure.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductAuthorizationProcedure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductAuthorizationProcedure)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductAuthorizationProcedure(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(applicationList, o.applicationList, true);
  end;
end;

function TFhirMedicinalProductAuthorizationProcedure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FType_) and isEmptyProp(FDate) and isEmptyProp(FapplicationList);
end;

procedure TFhirMedicinalProductAuthorizationProcedure.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('date[x]');
  fields.add('application');
end;

{ TFhirMedicinalProductAuthorizationProcedure }

Procedure TFhirMedicinalProductAuthorizationProcedure.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirMedicinalProductAuthorizationProcedure.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirMedicinalProductAuthorizationProcedure.SetDate(value : TFhirType);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirMedicinalProductAuthorizationProcedure.GetApplicationList : TFhirMedicinalProductAuthorizationProcedureList;
begin
  if FApplicationList = nil then
    FApplicationList := TFhirMedicinalProductAuthorizationProcedureList.Create;
  result := FApplicationList;
end;

Function TFhirMedicinalProductAuthorizationProcedure.GetHasApplicationList : boolean;
begin
  result := (FApplicationList <> nil) and (FApplicationList.count > 0);
end;

function TFhirMedicinalProductAuthorizationProcedure.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FapplicationList.sizeInBytes);
end;

{ TFhirMedicinalProductAuthorizationProcedureListEnumerator }

Constructor TFhirMedicinalProductAuthorizationProcedureListEnumerator.Create(list : TFhirMedicinalProductAuthorizationProcedureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductAuthorizationProcedureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductAuthorizationProcedureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductAuthorizationProcedureListEnumerator.GetCurrent : TFhirMedicinalProductAuthorizationProcedure;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductAuthorizationProcedureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductAuthorizationProcedureList }
procedure TFhirMedicinalProductAuthorizationProcedureList.AddItem(value: TFhirMedicinalProductAuthorizationProcedure);
begin
  assert(value.ClassName = 'TFhirMedicinalProductAuthorizationProcedure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductAuthorizationProcedure');
  add(value);
end;

function TFhirMedicinalProductAuthorizationProcedureList.Append: TFhirMedicinalProductAuthorizationProcedure;
begin
  result := TFhirMedicinalProductAuthorizationProcedure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductAuthorizationProcedureList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductAuthorizationProcedureList.GetEnumerator : TFhirMedicinalProductAuthorizationProcedureListEnumerator;
begin
  result := TFhirMedicinalProductAuthorizationProcedureListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductAuthorizationProcedureList.Clone: TFhirMedicinalProductAuthorizationProcedureList;
begin
  result := TFhirMedicinalProductAuthorizationProcedureList(inherited Clone);
end;

function TFhirMedicinalProductAuthorizationProcedureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductAuthorizationProcedureList.GetItemN(index: Integer): TFhirMedicinalProductAuthorizationProcedure;
begin
  result := TFhirMedicinalProductAuthorizationProcedure(ObjectByIndex[index]);
end;

function TFhirMedicinalProductAuthorizationProcedureList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductAuthorizationProcedure;
end;
function TFhirMedicinalProductAuthorizationProcedureList.IndexOf(value: TFhirMedicinalProductAuthorizationProcedure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductAuthorizationProcedureList.Insert(index: Integer): TFhirMedicinalProductAuthorizationProcedure;
begin
  result := TFhirMedicinalProductAuthorizationProcedure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductAuthorizationProcedureList.InsertItem(index: Integer; value: TFhirMedicinalProductAuthorizationProcedure);
begin
  assert(value is TFhirMedicinalProductAuthorizationProcedure);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductAuthorizationProcedureList.Item(index: Integer): TFhirMedicinalProductAuthorizationProcedure;
begin
  result := TFhirMedicinalProductAuthorizationProcedure(ObjectByIndex[index]);
end;

function TFhirMedicinalProductAuthorizationProcedureList.Link: TFhirMedicinalProductAuthorizationProcedureList;
begin
  result := TFhirMedicinalProductAuthorizationProcedureList(inherited Link);
end;

procedure TFhirMedicinalProductAuthorizationProcedureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductAuthorizationProcedureList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductAuthorizationProcedure);
begin
  assert(value is TFhirMedicinalProductAuthorizationProcedure);
  FhirMedicinalProductAuthorizationProcedures[index] := value;
end;

procedure TFhirMedicinalProductAuthorizationProcedureList.SetItemN(index: Integer; value: TFhirMedicinalProductAuthorizationProcedure);
begin
  assert(value is TFhirMedicinalProductAuthorizationProcedure);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductAuthorization }

constructor TFhirMedicinalProductAuthorization.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductAuthorization.Destroy;
begin
  FIdentifierList.Free;
  FSubject.free;
  FCountryList.Free;
  FJurisdictionList.Free;
  FStatus.free;
  FStatusDate.free;
  FRestoreDate.free;
  FValidityPeriod.free;
  FDataExclusivityPeriod.free;
  FDateOfFirstAuthorization.free;
  FInternationalBirthDate.free;
  FLegalBasis.free;
  FJurisdictionalAuthorizationList.Free;
  FHolder.free;
  FRegulator.free;
  FProcedure_.free;
  inherited;
end;

function TFhirMedicinalProductAuthorization.GetResourceType : TFhirResourceType;
begin
  result := frtMedicinalProductAuthorization;
end;

procedure TFhirMedicinalProductAuthorization.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicinalProductAuthorization(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicinalProductAuthorization(oSource).FIdentifierList);
  end;
  subject := TFhirMedicinalProductAuthorization(oSource).subject.Clone;
  if (TFhirMedicinalProductAuthorization(oSource).FCountryList = nil) then
  begin
    FCountryList.free;
    FCountryList := nil;
  end
  else
  begin
    if FCountryList = nil then
      FCountryList := TFhirCodeableConceptList.Create;
    FCountryList.Assign(TFhirMedicinalProductAuthorization(oSource).FCountryList);
  end;
  if (TFhirMedicinalProductAuthorization(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirMedicinalProductAuthorization(oSource).FJurisdictionList);
  end;
  status := TFhirMedicinalProductAuthorization(oSource).status.Clone;
  statusDateElement := TFhirMedicinalProductAuthorization(oSource).statusDateElement.Clone;
  restoreDateElement := TFhirMedicinalProductAuthorization(oSource).restoreDateElement.Clone;
  validityPeriod := TFhirMedicinalProductAuthorization(oSource).validityPeriod.Clone;
  dataExclusivityPeriod := TFhirMedicinalProductAuthorization(oSource).dataExclusivityPeriod.Clone;
  dateOfFirstAuthorizationElement := TFhirMedicinalProductAuthorization(oSource).dateOfFirstAuthorizationElement.Clone;
  internationalBirthDateElement := TFhirMedicinalProductAuthorization(oSource).internationalBirthDateElement.Clone;
  legalBasis := TFhirMedicinalProductAuthorization(oSource).legalBasis.Clone;
  if (TFhirMedicinalProductAuthorization(oSource).FJurisdictionalAuthorizationList = nil) then
  begin
    FJurisdictionalAuthorizationList.free;
    FJurisdictionalAuthorizationList := nil;
  end
  else
  begin
    if FJurisdictionalAuthorizationList = nil then
      FJurisdictionalAuthorizationList := TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList.Create;
    FJurisdictionalAuthorizationList.Assign(TFhirMedicinalProductAuthorization(oSource).FJurisdictionalAuthorizationList);
  end;
  holder := TFhirMedicinalProductAuthorization(oSource).holder.Clone;
  regulator := TFhirMedicinalProductAuthorization(oSource).regulator.Clone;
  procedure_ := TFhirMedicinalProductAuthorization(oSource).procedure_.Clone;
end;

procedure TFhirMedicinalProductAuthorization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'country') Then
    list.addAll(self, 'country', FCountryList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'restoreDate') Then
     list.add(self.link, 'restoreDate', FRestoreDate.Link);
  if (child_name = 'validityPeriod') Then
     list.add(self.link, 'validityPeriod', FValidityPeriod.Link);
  if (child_name = 'dataExclusivityPeriod') Then
     list.add(self.link, 'dataExclusivityPeriod', FDataExclusivityPeriod.Link);
  if (child_name = 'dateOfFirstAuthorization') Then
     list.add(self.link, 'dateOfFirstAuthorization', FDateOfFirstAuthorization.Link);
  if (child_name = 'internationalBirthDate') Then
     list.add(self.link, 'internationalBirthDate', FInternationalBirthDate.Link);
  if (child_name = 'legalBasis') Then
     list.add(self.link, 'legalBasis', FLegalBasis.Link);
  if (child_name = 'jurisdictionalAuthorization') Then
    list.addAll(self, 'jurisdictionalAuthorization', FJurisdictionalAuthorizationList);
  if (child_name = 'holder') Then
     list.add(self.link, 'holder', FHolder.Link);
  if (child_name = 'regulator') Then
     list.add(self.link, 'regulator', FRegulator.Link);
  if (child_name = 'procedure') Then
     list.add(self.link, 'procedure', FProcedure_.Link);
end;

procedure TFhirMedicinalProductAuthorization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(MedicinalProduct)', false, TFhirReference{TFhirMedicinalProduct}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'country', 'CodeableConcept', true, TFhirCodeableConcept, FCountryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'statusDate', 'dateTime', false, TFhirDateTime, FStatusDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'restoreDate', 'dateTime', false, TFhirDateTime, FRestoreDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'validityPeriod', 'Period', false, TFhirPeriod, FValidityPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dataExclusivityPeriod', 'Period', false, TFhirPeriod, FDataExclusivityPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateOfFirstAuthorization', 'dateTime', false, TFhirDateTime, FDateOfFirstAuthorization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'internationalBirthDate', 'dateTime', false, TFhirDateTime, FInternationalBirthDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'legalBasis', 'CodeableConcept', false, TFhirCodeableConcept, FLegalBasis.Link));{2}
  oList.add(TFHIRProperty.create(self, 'jurisdictionalAuthorization', '', true, TFhirMedicinalProductAuthorizationJurisdictionalAuthorization, FJurisdictionalAuthorizationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'holder', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FHolder.Link));{2}
  oList.add(TFHIRProperty.create(self, 'regulator', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FRegulator.Link));{2}
  oList.add(TFHIRProperty.create(self, 'procedure', '', false, TFhirMedicinalProductAuthorizationProcedure, FProcedure_.Link));{2}
end;

function TFhirMedicinalProductAuthorization.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirMedicinalProduct}{4b};
    result := propValue;
  end
  else if (propName = 'country') then
  begin
    CountryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'restoreDate') then
  begin
    RestoreDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'validityPeriod') then
  begin
    ValidityPeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'dataExclusivityPeriod') then
  begin
    DataExclusivityPeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'dateOfFirstAuthorization') then
  begin
    DateOfFirstAuthorizationElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'internationalBirthDate') then
  begin
    InternationalBirthDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'legalBasis') then
  begin
    LegalBasis := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'jurisdictionalAuthorization') then
  begin
    JurisdictionalAuthorizationList.add(propValue as TFhirMedicinalProductAuthorizationJurisdictionalAuthorization){2a};
    result := propValue;
  end
  else if (propName = 'holder') then
  begin
    Holder := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'regulator') then
  begin
    Regulator := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'procedure') then
  begin
    Procedure_ := propValue as TFhirMedicinalProductAuthorizationProcedure{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedicinalProductAuthorization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'country') then CountryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'jurisdictionalAuthorization') then JurisdictionalAuthorizationList.insertItem(index, propValue as TFhirMedicinalProductAuthorizationJurisdictionalAuthorization){2a}
  else inherited;
end;

function TFhirMedicinalProductAuthorization.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'subject') then result := TFhirReference{TFhirMedicinalProduct}.create(){4b}
  else if (propName = 'country') then result := CountryList.new(){2}
  else if (propName = 'jurisdiction') then result := JurisdictionList.new(){2}
  else if (propName = 'status') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'statusDate') then result := TFhirDateTime.create() {5b}
  else if (propName = 'restoreDate') then result := TFhirDateTime.create() {5b}
  else if (propName = 'validityPeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'dataExclusivityPeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'dateOfFirstAuthorization') then result := TFhirDateTime.create() {5b}
  else if (propName = 'internationalBirthDate') then result := TFhirDateTime.create() {5b}
  else if (propName = 'legalBasis') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'jurisdictionalAuthorization') then result := JurisdictionalAuthorizationList.new(){2}
  else if (propName = 'holder') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'regulator') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'procedure') then result := TFhirMedicinalProductAuthorizationProcedure.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductAuthorization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'country') then result := 'CodeableConcept'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'statusDate') then result := 'dateTime'
  else if (propName = 'restoreDate') then result := 'dateTime'
  else if (propName = 'validityPeriod') then result := 'Period'
  else if (propName = 'dataExclusivityPeriod') then result := 'Period'
  else if (propName = 'dateOfFirstAuthorization') then result := 'dateTime'
  else if (propName = 'internationalBirthDate') then result := 'dateTime'
  else if (propName = 'legalBasis') then result := 'CodeableConcept'
  else if (propName = 'jurisdictionalAuthorization') then result := ''
  else if (propName = 'holder') then result := 'Reference'
  else if (propName = 'regulator') then result := 'Reference'
  else if (propName = 'procedure') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductAuthorization.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'country') then deletePropertyValue('country', CountryList, value) {2}
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'restoreDate') then RestoreDateElement := nil
  else if (propName = 'validityPeriod') then ValidityPeriodElement := nil
  else if (propName = 'dataExclusivityPeriod') then DataExclusivityPeriodElement := nil
  else if (propName = 'dateOfFirstAuthorization') then DateOfFirstAuthorizationElement := nil
  else if (propName = 'internationalBirthDate') then InternationalBirthDateElement := nil
  else if (propName = 'legalBasis') then LegalBasisElement := nil
  else if (propName = 'jurisdictionalAuthorization') then deletePropertyValue('jurisdictionalAuthorization', JurisdictionalAuthorizationList, value) {2}
  else if (propName = 'holder') then HolderElement := nil
  else if (propName = 'regulator') then RegulatorElement := nil
  else if (propName = 'procedure') then Procedure_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductAuthorization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirMedicinalProduct}{4}
  else if (propName = 'country') then replacePropertyValue('country', CountryList, existing, new) {2}
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new) {2}
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept{4}
  else if (propName = 'statusDate') then StatusDateElement := asDateTime(new){5b}
  else if (propName = 'restoreDate') then RestoreDateElement := asDateTime(new){5b}
  else if (propName = 'validityPeriod') then ValidityPeriodElement := new as TFhirPeriod{4}
  else if (propName = 'dataExclusivityPeriod') then DataExclusivityPeriodElement := new as TFhirPeriod{4}
  else if (propName = 'dateOfFirstAuthorization') then DateOfFirstAuthorizationElement := asDateTime(new){5b}
  else if (propName = 'internationalBirthDate') then InternationalBirthDateElement := asDateTime(new){5b}
  else if (propName = 'legalBasis') then LegalBasisElement := new as TFhirCodeableConcept{4}
  else if (propName = 'jurisdictionalAuthorization') then replacePropertyValue('jurisdictionalAuthorization', JurisdictionalAuthorizationList, existing, new) {2}
  else if (propName = 'holder') then HolderElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'regulator') then RegulatorElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'procedure') then Procedure_Element := new as TFhirMedicinalProductAuthorizationProcedure{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductAuthorization.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'country') then CountryList.move(source, destination){2a}
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination){2a}
  else if (propName = 'jurisdictionalAuthorization') then JurisdictionalAuthorizationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductAuthorization.fhirType : string;
begin
  result := 'MedicinalProductAuthorization';
end;

function TFhirMedicinalProductAuthorization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FSubject) and isEmptyProp(FcountryList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FStatus) and isEmptyProp(FStatusDate) and isEmptyProp(FRestoreDate) and isEmptyProp(FValidityPeriod) and isEmptyProp(FDataExclusivityPeriod) and isEmptyProp(FDateOfFirstAuthorization) and isEmptyProp(FInternationalBirthDate) and isEmptyProp(FLegalBasis) and isEmptyProp(FjurisdictionalAuthorizationList) and isEmptyProp(FHolder) and isEmptyProp(FRegulator) and isEmptyProp(FProcedure_);
end;

function TFhirMedicinalProductAuthorization.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductAuthorization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductAuthorization)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductAuthorization(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(countryList, o.countryList, true) and compareDeep(jurisdictionList, o.jurisdictionList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(statusDateElement, o.statusDateElement, true) and 
      compareDeep(restoreDateElement, o.restoreDateElement, true) and compareDeep(validityPeriodElement, o.validityPeriodElement, true) and 
      compareDeep(dataExclusivityPeriodElement, o.dataExclusivityPeriodElement, true) and 
      compareDeep(dateOfFirstAuthorizationElement, o.dateOfFirstAuthorizationElement, true) and 
      compareDeep(internationalBirthDateElement, o.internationalBirthDateElement, true) and 
      compareDeep(legalBasisElement, o.legalBasisElement, true) and compareDeep(jurisdictionalAuthorizationList, o.jurisdictionalAuthorizationList, true) and 
      compareDeep(holderElement, o.holderElement, true) and compareDeep(regulatorElement, o.regulatorElement, true) and 
      compareDeep(procedure_Element, o.procedure_Element, true);
  end;
end;

function TFhirMedicinalProductAuthorization.Link : TFhirMedicinalProductAuthorization;
begin
  result := TFhirMedicinalProductAuthorization(inherited Link);
end;

function TFhirMedicinalProductAuthorization.Clone : TFhirMedicinalProductAuthorization;
begin
  result := TFhirMedicinalProductAuthorization(inherited Clone);
end;

procedure TFhirMedicinalProductAuthorization.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('subject');
  fields.add('country');
  fields.add('jurisdiction');
  fields.add('status');
  fields.add('statusDate');
  fields.add('restoreDate');
  fields.add('validityPeriod');
  fields.add('dataExclusivityPeriod');
  fields.add('dateOfFirstAuthorization');
  fields.add('internationalBirthDate');
  fields.add('legalBasis');
  fields.add('jurisdictionalAuthorization');
  fields.add('holder');
  fields.add('regulator');
  fields.add('procedure');
end;

{ TFhirMedicinalProductAuthorization }

Function TFhirMedicinalProductAuthorization.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirMedicinalProductAuthorization.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirMedicinalProductAuthorization.SetSubject(value : TFhirReference{TFhirMedicinalProduct});
begin
  FSubject.free;
  FSubject := value;
end;

Function TFhirMedicinalProductAuthorization.GetCountryList : TFhirCodeableConceptList;
begin
  if FCountryList = nil then
    FCountryList := TFhirCodeableConceptList.Create;
  result := FCountryList;
end;

Function TFhirMedicinalProductAuthorization.GetHasCountryList : boolean;
begin
  result := (FCountryList <> nil) and (FCountryList.count > 0);
end;

Function TFhirMedicinalProductAuthorization.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

Function TFhirMedicinalProductAuthorization.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

Procedure TFhirMedicinalProductAuthorization.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

Procedure TFhirMedicinalProductAuthorization.SetStatusDate(value : TFhirDateTime);
begin
  FStatusDate.free;
  FStatusDate := value;
end;

Function TFhirMedicinalProductAuthorization.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

Procedure TFhirMedicinalProductAuthorization.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDateTime.create;
  FStatusDate.value := value
end;

Procedure TFhirMedicinalProductAuthorization.SetRestoreDate(value : TFhirDateTime);
begin
  FRestoreDate.free;
  FRestoreDate := value;
end;

Function TFhirMedicinalProductAuthorization.GetRestoreDateST : TFslDateTime;
begin
  if FRestoreDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FRestoreDate.value;
end;

Procedure TFhirMedicinalProductAuthorization.SetRestoreDateST(value : TFslDateTime);
begin
  if FRestoreDate = nil then
    FRestoreDate := TFhirDateTime.create;
  FRestoreDate.value := value
end;

Procedure TFhirMedicinalProductAuthorization.SetValidityPeriod(value : TFhirPeriod);
begin
  FValidityPeriod.free;
  FValidityPeriod := value;
end;

Procedure TFhirMedicinalProductAuthorization.SetDataExclusivityPeriod(value : TFhirPeriod);
begin
  FDataExclusivityPeriod.free;
  FDataExclusivityPeriod := value;
end;

Procedure TFhirMedicinalProductAuthorization.SetDateOfFirstAuthorization(value : TFhirDateTime);
begin
  FDateOfFirstAuthorization.free;
  FDateOfFirstAuthorization := value;
end;

Function TFhirMedicinalProductAuthorization.GetDateOfFirstAuthorizationST : TFslDateTime;
begin
  if FDateOfFirstAuthorization = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateOfFirstAuthorization.value;
end;

Procedure TFhirMedicinalProductAuthorization.SetDateOfFirstAuthorizationST(value : TFslDateTime);
begin
  if FDateOfFirstAuthorization = nil then
    FDateOfFirstAuthorization := TFhirDateTime.create;
  FDateOfFirstAuthorization.value := value
end;

Procedure TFhirMedicinalProductAuthorization.SetInternationalBirthDate(value : TFhirDateTime);
begin
  FInternationalBirthDate.free;
  FInternationalBirthDate := value;
end;

Function TFhirMedicinalProductAuthorization.GetInternationalBirthDateST : TFslDateTime;
begin
  if FInternationalBirthDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FInternationalBirthDate.value;
end;

Procedure TFhirMedicinalProductAuthorization.SetInternationalBirthDateST(value : TFslDateTime);
begin
  if FInternationalBirthDate = nil then
    FInternationalBirthDate := TFhirDateTime.create;
  FInternationalBirthDate.value := value
end;

Procedure TFhirMedicinalProductAuthorization.SetLegalBasis(value : TFhirCodeableConcept);
begin
  FLegalBasis.free;
  FLegalBasis := value;
end;

Function TFhirMedicinalProductAuthorization.GetJurisdictionalAuthorizationList : TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList;
begin
  if FJurisdictionalAuthorizationList = nil then
    FJurisdictionalAuthorizationList := TFhirMedicinalProductAuthorizationJurisdictionalAuthorizationList.Create;
  result := FJurisdictionalAuthorizationList;
end;

Function TFhirMedicinalProductAuthorization.GetHasJurisdictionalAuthorizationList : boolean;
begin
  result := (FJurisdictionalAuthorizationList <> nil) and (FJurisdictionalAuthorizationList.count > 0);
end;

Procedure TFhirMedicinalProductAuthorization.SetHolder(value : TFhirReference{TFhirOrganization});
begin
  FHolder.free;
  FHolder := value;
end;

Procedure TFhirMedicinalProductAuthorization.SetRegulator(value : TFhirReference{TFhirOrganization});
begin
  FRegulator.free;
  FRegulator := value;
end;

Procedure TFhirMedicinalProductAuthorization.SetProcedure_(value : TFhirMedicinalProductAuthorizationProcedure);
begin
  FProcedure_.free;
  FProcedure_ := value;
end;

function TFhirMedicinalProductAuthorization.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FcountryList.sizeInBytes);
  inc(result, FjurisdictionList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStatusDate.sizeInBytes);
  inc(result, FRestoreDate.sizeInBytes);
  inc(result, FValidityPeriod.sizeInBytes);
  inc(result, FDataExclusivityPeriod.sizeInBytes);
  inc(result, FDateOfFirstAuthorization.sizeInBytes);
  inc(result, FInternationalBirthDate.sizeInBytes);
  inc(result, FLegalBasis.sizeInBytes);
  inc(result, FjurisdictionalAuthorizationList.sizeInBytes);
  inc(result, FHolder.sizeInBytes);
  inc(result, FRegulator.sizeInBytes);
  inc(result, FProcedure_.sizeInBytes);
end;

{ TFhirMedicinalProductAuthorizationListEnumerator }

Constructor TFhirMedicinalProductAuthorizationListEnumerator.Create(list : TFhirMedicinalProductAuthorizationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductAuthorizationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductAuthorizationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductAuthorizationListEnumerator.GetCurrent : TFhirMedicinalProductAuthorization;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductAuthorizationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductAuthorizationList }
procedure TFhirMedicinalProductAuthorizationList.AddItem(value: TFhirMedicinalProductAuthorization);
begin
  assert(value.ClassName = 'TFhirMedicinalProductAuthorization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductAuthorization');
  add(value);
end;

function TFhirMedicinalProductAuthorizationList.Append: TFhirMedicinalProductAuthorization;
begin
  result := TFhirMedicinalProductAuthorization.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductAuthorizationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductAuthorizationList.GetEnumerator : TFhirMedicinalProductAuthorizationListEnumerator;
begin
  result := TFhirMedicinalProductAuthorizationListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductAuthorizationList.Clone: TFhirMedicinalProductAuthorizationList;
begin
  result := TFhirMedicinalProductAuthorizationList(inherited Clone);
end;

function TFhirMedicinalProductAuthorizationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductAuthorizationList.GetItemN(index: Integer): TFhirMedicinalProductAuthorization;
begin
  result := TFhirMedicinalProductAuthorization(ObjectByIndex[index]);
end;

function TFhirMedicinalProductAuthorizationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductAuthorization;
end;
function TFhirMedicinalProductAuthorizationList.IndexOf(value: TFhirMedicinalProductAuthorization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductAuthorizationList.Insert(index: Integer): TFhirMedicinalProductAuthorization;
begin
  result := TFhirMedicinalProductAuthorization.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductAuthorizationList.InsertItem(index: Integer; value: TFhirMedicinalProductAuthorization);
begin
  assert(value is TFhirMedicinalProductAuthorization);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductAuthorizationList.Item(index: Integer): TFhirMedicinalProductAuthorization;
begin
  result := TFhirMedicinalProductAuthorization(ObjectByIndex[index]);
end;

function TFhirMedicinalProductAuthorizationList.Link: TFhirMedicinalProductAuthorizationList;
begin
  result := TFhirMedicinalProductAuthorizationList(inherited Link);
end;

procedure TFhirMedicinalProductAuthorizationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductAuthorizationList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductAuthorization);
begin
  assert(value is TFhirMedicinalProductAuthorization);
  FhirMedicinalProductAuthorizations[index] := value;
end;

procedure TFhirMedicinalProductAuthorizationList.SetItemN(index: Integer; value: TFhirMedicinalProductAuthorization);
begin
  assert(value is TFhirMedicinalProductAuthorization);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICINALPRODUCTAUTHORIZATION}

{$IFDEF FHIR_MEDICINALPRODUCTCONTRAINDICATION}

{ TFhirMedicinalProductContraindicationOtherTherapy }

constructor TFhirMedicinalProductContraindicationOtherTherapy.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductContraindicationOtherTherapy.Destroy;
begin
  FTherapyRelationshipType.free;
  FMedication.free;
  inherited;
end;

procedure TFhirMedicinalProductContraindicationOtherTherapy.Assign(oSource : TFslObject);
begin
  inherited;
  therapyRelationshipType := TFhirMedicinalProductContraindicationOtherTherapy(oSource).therapyRelationshipType.Clone;
  medication := TFhirMedicinalProductContraindicationOtherTherapy(oSource).medication.Clone;
end;

procedure TFhirMedicinalProductContraindicationOtherTherapy.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'therapyRelationshipType') Then
     list.add(self.link, 'therapyRelationshipType', FTherapyRelationshipType.Link);
  if (child_name = 'medication[x]') or (child_name = 'medication') Then
     list.add(self.link, 'medication[x]', FMedication.Link);
end;

procedure TFhirMedicinalProductContraindicationOtherTherapy.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'therapyRelationshipType', 'CodeableConcept', false, TFhirCodeableConcept, FTherapyRelationshipType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'medication[x]', 'CodeableConcept|Reference(MedicinalProduct)', false, TFhirType, FMedication.Link));{2}
end;

function TFhirMedicinalProductContraindicationOtherTherapy.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'therapyRelationshipType') then
  begin
    TherapyRelationshipType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then
  begin
    Medication := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductContraindicationOtherTherapy.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductContraindicationOtherTherapy.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'therapyRelationshipType') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Medication'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductContraindicationOtherTherapy.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'therapyRelationshipType') then result := 'CodeableConcept'
  else if (propName = 'medication[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductContraindicationOtherTherapy.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'therapyRelationshipType') then TherapyRelationshipTypeElement := nil
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductContraindicationOtherTherapy.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'therapyRelationshipType') then TherapyRelationshipTypeElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductContraindicationOtherTherapy.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductContraindicationOtherTherapy.fhirType : string;
begin
  result := 'otherTherapy';
end;

function TFhirMedicinalProductContraindicationOtherTherapy.Link : TFhirMedicinalProductContraindicationOtherTherapy;
begin
  result := TFhirMedicinalProductContraindicationOtherTherapy(inherited Link);
end;

function TFhirMedicinalProductContraindicationOtherTherapy.Clone : TFhirMedicinalProductContraindicationOtherTherapy;
begin
  result := TFhirMedicinalProductContraindicationOtherTherapy(inherited Clone);
end;

function TFhirMedicinalProductContraindicationOtherTherapy.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductContraindicationOtherTherapy;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductContraindicationOtherTherapy)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductContraindicationOtherTherapy(other);
    result := compareDeep(therapyRelationshipTypeElement, o.therapyRelationshipTypeElement, true) and 
      compareDeep(medicationElement, o.medicationElement, true);
  end;
end;

function TFhirMedicinalProductContraindicationOtherTherapy.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTherapyRelationshipType) and isEmptyProp(FMedication);
end;

procedure TFhirMedicinalProductContraindicationOtherTherapy.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('therapyRelationshipType');
  fields.add('medication[x]');
end;

{ TFhirMedicinalProductContraindicationOtherTherapy }

Procedure TFhirMedicinalProductContraindicationOtherTherapy.SetTherapyRelationshipType(value : TFhirCodeableConcept);
begin
  FTherapyRelationshipType.free;
  FTherapyRelationshipType := value;
end;

Procedure TFhirMedicinalProductContraindicationOtherTherapy.SetMedication(value : TFhirType);
begin
  FMedication.free;
  FMedication := value;
end;

function TFhirMedicinalProductContraindicationOtherTherapy.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FTherapyRelationshipType.sizeInBytes);
  inc(result, FMedication.sizeInBytes);
end;

{ TFhirMedicinalProductContraindicationOtherTherapyListEnumerator }

Constructor TFhirMedicinalProductContraindicationOtherTherapyListEnumerator.Create(list : TFhirMedicinalProductContraindicationOtherTherapyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductContraindicationOtherTherapyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductContraindicationOtherTherapyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductContraindicationOtherTherapyListEnumerator.GetCurrent : TFhirMedicinalProductContraindicationOtherTherapy;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductContraindicationOtherTherapyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductContraindicationOtherTherapyList }
procedure TFhirMedicinalProductContraindicationOtherTherapyList.AddItem(value: TFhirMedicinalProductContraindicationOtherTherapy);
begin
  assert(value.ClassName = 'TFhirMedicinalProductContraindicationOtherTherapy', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductContraindicationOtherTherapy');
  add(value);
end;

function TFhirMedicinalProductContraindicationOtherTherapyList.Append: TFhirMedicinalProductContraindicationOtherTherapy;
begin
  result := TFhirMedicinalProductContraindicationOtherTherapy.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductContraindicationOtherTherapyList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductContraindicationOtherTherapyList.GetEnumerator : TFhirMedicinalProductContraindicationOtherTherapyListEnumerator;
begin
  result := TFhirMedicinalProductContraindicationOtherTherapyListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductContraindicationOtherTherapyList.Clone: TFhirMedicinalProductContraindicationOtherTherapyList;
begin
  result := TFhirMedicinalProductContraindicationOtherTherapyList(inherited Clone);
end;

function TFhirMedicinalProductContraindicationOtherTherapyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductContraindicationOtherTherapyList.GetItemN(index: Integer): TFhirMedicinalProductContraindicationOtherTherapy;
begin
  result := TFhirMedicinalProductContraindicationOtherTherapy(ObjectByIndex[index]);
end;

function TFhirMedicinalProductContraindicationOtherTherapyList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductContraindicationOtherTherapy;
end;
function TFhirMedicinalProductContraindicationOtherTherapyList.IndexOf(value: TFhirMedicinalProductContraindicationOtherTherapy): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductContraindicationOtherTherapyList.Insert(index: Integer): TFhirMedicinalProductContraindicationOtherTherapy;
begin
  result := TFhirMedicinalProductContraindicationOtherTherapy.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductContraindicationOtherTherapyList.InsertItem(index: Integer; value: TFhirMedicinalProductContraindicationOtherTherapy);
begin
  assert(value is TFhirMedicinalProductContraindicationOtherTherapy);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductContraindicationOtherTherapyList.Item(index: Integer): TFhirMedicinalProductContraindicationOtherTherapy;
begin
  result := TFhirMedicinalProductContraindicationOtherTherapy(ObjectByIndex[index]);
end;

function TFhirMedicinalProductContraindicationOtherTherapyList.Link: TFhirMedicinalProductContraindicationOtherTherapyList;
begin
  result := TFhirMedicinalProductContraindicationOtherTherapyList(inherited Link);
end;

procedure TFhirMedicinalProductContraindicationOtherTherapyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductContraindicationOtherTherapyList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductContraindicationOtherTherapy);
begin
  assert(value is TFhirMedicinalProductContraindicationOtherTherapy);
  FhirMedicinalProductContraindicationOtherTherapies[index] := value;
end;

procedure TFhirMedicinalProductContraindicationOtherTherapyList.SetItemN(index: Integer; value: TFhirMedicinalProductContraindicationOtherTherapy);
begin
  assert(value is TFhirMedicinalProductContraindicationOtherTherapy);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductContraindication }

constructor TFhirMedicinalProductContraindication.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductContraindication.Destroy;
begin
  FSubjectList.Free;
  FDisease.free;
  FDiseaseStatus.free;
  FComorbidityList.Free;
  FTherapeuticIndicationList.Free;
  FOtherTherapyList.Free;
  FPopulationList.Free;
  inherited;
end;

function TFhirMedicinalProductContraindication.GetResourceType : TFhirResourceType;
begin
  result := frtMedicinalProductContraindication;
end;

procedure TFhirMedicinalProductContraindication.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicinalProductContraindication(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirReferenceList{TFhirMedicinalProduct}.Create;
    FSubjectList.Assign(TFhirMedicinalProductContraindication(oSource).FSubjectList);
  end;
  disease := TFhirMedicinalProductContraindication(oSource).disease.Clone;
  diseaseStatus := TFhirMedicinalProductContraindication(oSource).diseaseStatus.Clone;
  if (TFhirMedicinalProductContraindication(oSource).FComorbidityList = nil) then
  begin
    FComorbidityList.free;
    FComorbidityList := nil;
  end
  else
  begin
    if FComorbidityList = nil then
      FComorbidityList := TFhirCodeableConceptList.Create;
    FComorbidityList.Assign(TFhirMedicinalProductContraindication(oSource).FComorbidityList);
  end;
  if (TFhirMedicinalProductContraindication(oSource).FTherapeuticIndicationList = nil) then
  begin
    FTherapeuticIndicationList.free;
    FTherapeuticIndicationList := nil;
  end
  else
  begin
    if FTherapeuticIndicationList = nil then
      FTherapeuticIndicationList := TFhirReferenceList{TFhirMedicinalProductIndication}.Create;
    FTherapeuticIndicationList.Assign(TFhirMedicinalProductContraindication(oSource).FTherapeuticIndicationList);
  end;
  if (TFhirMedicinalProductContraindication(oSource).FOtherTherapyList = nil) then
  begin
    FOtherTherapyList.free;
    FOtherTherapyList := nil;
  end
  else
  begin
    if FOtherTherapyList = nil then
      FOtherTherapyList := TFhirMedicinalProductContraindicationOtherTherapyList.Create;
    FOtherTherapyList.Assign(TFhirMedicinalProductContraindication(oSource).FOtherTherapyList);
  end;
  if (TFhirMedicinalProductContraindication(oSource).FPopulationList = nil) then
  begin
    FPopulationList.free;
    FPopulationList := nil;
  end
  else
  begin
    if FPopulationList = nil then
      FPopulationList := TFhirPopulationList.Create;
    FPopulationList.Assign(TFhirMedicinalProductContraindication(oSource).FPopulationList);
  end;
end;

procedure TFhirMedicinalProductContraindication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'disease') Then
     list.add(self.link, 'disease', FDisease.Link);
  if (child_name = 'diseaseStatus') Then
     list.add(self.link, 'diseaseStatus', FDiseaseStatus.Link);
  if (child_name = 'comorbidity') Then
    list.addAll(self, 'comorbidity', FComorbidityList);
  if (child_name = 'therapeuticIndication') Then
    list.addAll(self, 'therapeuticIndication', FTherapeuticIndicationList);
  if (child_name = 'otherTherapy') Then
    list.addAll(self, 'otherTherapy', FOtherTherapyList);
  if (child_name = 'population') Then
    list.addAll(self, 'population', FPopulationList);
end;

procedure TFhirMedicinalProductContraindication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(MedicinalProduct)', true, TFhirReference{TFhirMedicinalProduct}, FSubjectList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'disease', 'CodeableConcept', false, TFhirCodeableConcept, FDisease.Link));{2}
  oList.add(TFHIRProperty.create(self, 'diseaseStatus', 'CodeableConcept', false, TFhirCodeableConcept, FDiseaseStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comorbidity', 'CodeableConcept', true, TFhirCodeableConcept, FComorbidityList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'therapeuticIndication', 'Reference(MedicinalProductIndication)', true, TFhirReference{TFhirMedicinalProductIndication}, FTherapeuticIndicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'otherTherapy', '', true, TFhirMedicinalProductContraindicationOtherTherapy, FOtherTherapyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'population', 'Population', true, TFhirPopulation, FPopulationList.Link)){3};
end;

function TFhirMedicinalProductContraindication.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirReference{TFhirMedicinalProduct}){2a};
    result := propValue;
  end
  else if (propName = 'disease') then
  begin
    Disease := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'diseaseStatus') then
  begin
    DiseaseStatus := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'comorbidity') then
  begin
    ComorbidityList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'therapeuticIndication') then
  begin
    TherapeuticIndicationList.add(propValue as TFhirReference{TFhirMedicinalProductIndication}){2a};
    result := propValue;
  end
  else if (propName = 'otherTherapy') then
  begin
    OtherTherapyList.add(propValue as TFhirMedicinalProductContraindicationOtherTherapy){2a};
    result := propValue;
  end
  else if (propName = 'population') then
  begin
    PopulationList.add(propValue as TFhirPopulation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedicinalProductContraindication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirReference{TFhirMedicinalProduct}){2a}
  else if (propName = 'comorbidity') then ComorbidityList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'therapeuticIndication') then TherapeuticIndicationList.insertItem(index, propValue as TFhirReference{TFhirMedicinalProductIndication}){2a}
  else if (propName = 'otherTherapy') then OtherTherapyList.insertItem(index, propValue as TFhirMedicinalProductContraindicationOtherTherapy){2a}
  else if (propName = 'population') then PopulationList.insertItem(index, propValue as TFhirPopulation){2a}
  else inherited;
end;

function TFhirMedicinalProductContraindication.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'subject') then result := SubjectList.new(){2}
  else if (propName = 'disease') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'diseaseStatus') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'comorbidity') then result := ComorbidityList.new(){2}
  else if (propName = 'therapeuticIndication') then result := TherapeuticIndicationList.new(){2}
  else if (propName = 'otherTherapy') then result := OtherTherapyList.new(){2}
  else if (propName = 'population') then result := PopulationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductContraindication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'subject') then result := 'Reference'
  else if (propName = 'disease') then result := 'CodeableConcept'
  else if (propName = 'diseaseStatus') then result := 'CodeableConcept'
  else if (propName = 'comorbidity') then result := 'CodeableConcept'
  else if (propName = 'therapeuticIndication') then result := 'Reference'
  else if (propName = 'otherTherapy') then result := ''
  else if (propName = 'population') then result := 'Population'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductContraindication.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value) {2}
  else if (propName = 'disease') then DiseaseElement := nil
  else if (propName = 'diseaseStatus') then DiseaseStatusElement := nil
  else if (propName = 'comorbidity') then deletePropertyValue('comorbidity', ComorbidityList, value) {2}
  else if (propName = 'therapeuticIndication') then deletePropertyValue('therapeuticIndication', TherapeuticIndicationList, value) {2}
  else if (propName = 'otherTherapy') then deletePropertyValue('otherTherapy', OtherTherapyList, value) {2}
  else if (propName = 'population') then deletePropertyValue('population', PopulationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductContraindication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new) {2}
  else if (propName = 'disease') then DiseaseElement := new as TFhirCodeableConcept{4}
  else if (propName = 'diseaseStatus') then DiseaseStatusElement := new as TFhirCodeableConcept{4}
  else if (propName = 'comorbidity') then replacePropertyValue('comorbidity', ComorbidityList, existing, new) {2}
  else if (propName = 'therapeuticIndication') then replacePropertyValue('therapeuticIndication', TherapeuticIndicationList, existing, new) {2}
  else if (propName = 'otherTherapy') then replacePropertyValue('otherTherapy', OtherTherapyList, existing, new) {2}
  else if (propName = 'population') then replacePropertyValue('population', PopulationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductContraindication.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'subject') then SubjectList.move(source, destination){2a}
  else if (propName = 'comorbidity') then ComorbidityList.move(source, destination){2a}
  else if (propName = 'therapeuticIndication') then TherapeuticIndicationList.move(source, destination){2a}
  else if (propName = 'otherTherapy') then OtherTherapyList.move(source, destination){2a}
  else if (propName = 'population') then PopulationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductContraindication.fhirType : string;
begin
  result := 'MedicinalProductContraindication';
end;

function TFhirMedicinalProductContraindication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FsubjectList) and isEmptyProp(FDisease) and isEmptyProp(FDiseaseStatus) and isEmptyProp(FcomorbidityList) and isEmptyProp(FtherapeuticIndicationList) and isEmptyProp(FotherTherapyList) and isEmptyProp(FpopulationList);
end;

function TFhirMedicinalProductContraindication.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductContraindication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductContraindication)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductContraindication(other);
    result := compareDeep(subjectList, o.subjectList, true) and compareDeep(diseaseElement, o.diseaseElement, true) and 
      compareDeep(diseaseStatusElement, o.diseaseStatusElement, true) and compareDeep(comorbidityList, o.comorbidityList, true) and 
      compareDeep(therapeuticIndicationList, o.therapeuticIndicationList, true) and 
      compareDeep(otherTherapyList, o.otherTherapyList, true) and compareDeep(populationList, o.populationList, true);
  end;
end;

function TFhirMedicinalProductContraindication.Link : TFhirMedicinalProductContraindication;
begin
  result := TFhirMedicinalProductContraindication(inherited Link);
end;

function TFhirMedicinalProductContraindication.Clone : TFhirMedicinalProductContraindication;
begin
  result := TFhirMedicinalProductContraindication(inherited Clone);
end;

procedure TFhirMedicinalProductContraindication.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('subject');
  fields.add('disease');
  fields.add('diseaseStatus');
  fields.add('comorbidity');
  fields.add('therapeuticIndication');
  fields.add('otherTherapy');
  fields.add('population');
end;

{ TFhirMedicinalProductContraindication }

Function TFhirMedicinalProductContraindication.GetSubjectList : TFhirReferenceList{TFhirMedicinalProduct};
begin
  if FSubjectList = nil then
    FSubjectList := TFhirReferenceList{TFhirMedicinalProduct}.Create;
  result := FSubjectList;
end;

Function TFhirMedicinalProductContraindication.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

Procedure TFhirMedicinalProductContraindication.SetDisease(value : TFhirCodeableConcept);
begin
  FDisease.free;
  FDisease := value;
end;

Procedure TFhirMedicinalProductContraindication.SetDiseaseStatus(value : TFhirCodeableConcept);
begin
  FDiseaseStatus.free;
  FDiseaseStatus := value;
end;

Function TFhirMedicinalProductContraindication.GetComorbidityList : TFhirCodeableConceptList;
begin
  if FComorbidityList = nil then
    FComorbidityList := TFhirCodeableConceptList.Create;
  result := FComorbidityList;
end;

Function TFhirMedicinalProductContraindication.GetHasComorbidityList : boolean;
begin
  result := (FComorbidityList <> nil) and (FComorbidityList.count > 0);
end;

Function TFhirMedicinalProductContraindication.GetTherapeuticIndicationList : TFhirReferenceList{TFhirMedicinalProductIndication};
begin
  if FTherapeuticIndicationList = nil then
    FTherapeuticIndicationList := TFhirReferenceList{TFhirMedicinalProductIndication}.Create;
  result := FTherapeuticIndicationList;
end;

Function TFhirMedicinalProductContraindication.GetHasTherapeuticIndicationList : boolean;
begin
  result := (FTherapeuticIndicationList <> nil) and (FTherapeuticIndicationList.count > 0);
end;

Function TFhirMedicinalProductContraindication.GetOtherTherapyList : TFhirMedicinalProductContraindicationOtherTherapyList;
begin
  if FOtherTherapyList = nil then
    FOtherTherapyList := TFhirMedicinalProductContraindicationOtherTherapyList.Create;
  result := FOtherTherapyList;
end;

Function TFhirMedicinalProductContraindication.GetHasOtherTherapyList : boolean;
begin
  result := (FOtherTherapyList <> nil) and (FOtherTherapyList.count > 0);
end;

Function TFhirMedicinalProductContraindication.GetPopulationList : TFhirPopulationList;
begin
  if FPopulationList = nil then
    FPopulationList := TFhirPopulationList.Create;
  result := FPopulationList;
end;

Function TFhirMedicinalProductContraindication.GetHasPopulationList : boolean;
begin
  result := (FPopulationList <> nil) and (FPopulationList.count > 0);
end;

function TFhirMedicinalProductContraindication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FsubjectList.sizeInBytes);
  inc(result, FDisease.sizeInBytes);
  inc(result, FDiseaseStatus.sizeInBytes);
  inc(result, FcomorbidityList.sizeInBytes);
  inc(result, FtherapeuticIndicationList.sizeInBytes);
  inc(result, FotherTherapyList.sizeInBytes);
  inc(result, FpopulationList.sizeInBytes);
end;

{ TFhirMedicinalProductContraindicationListEnumerator }

Constructor TFhirMedicinalProductContraindicationListEnumerator.Create(list : TFhirMedicinalProductContraindicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductContraindicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductContraindicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductContraindicationListEnumerator.GetCurrent : TFhirMedicinalProductContraindication;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductContraindicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductContraindicationList }
procedure TFhirMedicinalProductContraindicationList.AddItem(value: TFhirMedicinalProductContraindication);
begin
  assert(value.ClassName = 'TFhirMedicinalProductContraindication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductContraindication');
  add(value);
end;

function TFhirMedicinalProductContraindicationList.Append: TFhirMedicinalProductContraindication;
begin
  result := TFhirMedicinalProductContraindication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductContraindicationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductContraindicationList.GetEnumerator : TFhirMedicinalProductContraindicationListEnumerator;
begin
  result := TFhirMedicinalProductContraindicationListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductContraindicationList.Clone: TFhirMedicinalProductContraindicationList;
begin
  result := TFhirMedicinalProductContraindicationList(inherited Clone);
end;

function TFhirMedicinalProductContraindicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductContraindicationList.GetItemN(index: Integer): TFhirMedicinalProductContraindication;
begin
  result := TFhirMedicinalProductContraindication(ObjectByIndex[index]);
end;

function TFhirMedicinalProductContraindicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductContraindication;
end;
function TFhirMedicinalProductContraindicationList.IndexOf(value: TFhirMedicinalProductContraindication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductContraindicationList.Insert(index: Integer): TFhirMedicinalProductContraindication;
begin
  result := TFhirMedicinalProductContraindication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductContraindicationList.InsertItem(index: Integer; value: TFhirMedicinalProductContraindication);
begin
  assert(value is TFhirMedicinalProductContraindication);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductContraindicationList.Item(index: Integer): TFhirMedicinalProductContraindication;
begin
  result := TFhirMedicinalProductContraindication(ObjectByIndex[index]);
end;

function TFhirMedicinalProductContraindicationList.Link: TFhirMedicinalProductContraindicationList;
begin
  result := TFhirMedicinalProductContraindicationList(inherited Link);
end;

procedure TFhirMedicinalProductContraindicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductContraindicationList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductContraindication);
begin
  assert(value is TFhirMedicinalProductContraindication);
  FhirMedicinalProductContraindications[index] := value;
end;

procedure TFhirMedicinalProductContraindicationList.SetItemN(index: Integer; value: TFhirMedicinalProductContraindication);
begin
  assert(value is TFhirMedicinalProductContraindication);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICINALPRODUCTCONTRAINDICATION}

{$IFDEF FHIR_MEDICINALPRODUCTINDICATION}

{ TFhirMedicinalProductIndicationOtherTherapy }

constructor TFhirMedicinalProductIndicationOtherTherapy.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductIndicationOtherTherapy.Destroy;
begin
  FTherapyRelationshipType.free;
  FMedication.free;
  inherited;
end;

procedure TFhirMedicinalProductIndicationOtherTherapy.Assign(oSource : TFslObject);
begin
  inherited;
  therapyRelationshipType := TFhirMedicinalProductIndicationOtherTherapy(oSource).therapyRelationshipType.Clone;
  medication := TFhirMedicinalProductIndicationOtherTherapy(oSource).medication.Clone;
end;

procedure TFhirMedicinalProductIndicationOtherTherapy.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'therapyRelationshipType') Then
     list.add(self.link, 'therapyRelationshipType', FTherapyRelationshipType.Link);
  if (child_name = 'medication[x]') or (child_name = 'medication') Then
     list.add(self.link, 'medication[x]', FMedication.Link);
end;

procedure TFhirMedicinalProductIndicationOtherTherapy.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'therapyRelationshipType', 'CodeableConcept', false, TFhirCodeableConcept, FTherapyRelationshipType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'medication[x]', 'CodeableConcept|Reference(MedicinalProduct)', false, TFhirType, FMedication.Link));{2}
end;

function TFhirMedicinalProductIndicationOtherTherapy.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'therapyRelationshipType') then
  begin
    TherapyRelationshipType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then
  begin
    Medication := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductIndicationOtherTherapy.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductIndicationOtherTherapy.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'therapyRelationshipType') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Medication'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductIndicationOtherTherapy.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'therapyRelationshipType') then result := 'CodeableConcept'
  else if (propName = 'medication[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductIndicationOtherTherapy.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'therapyRelationshipType') then TherapyRelationshipTypeElement := nil
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductIndicationOtherTherapy.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'therapyRelationshipType') then TherapyRelationshipTypeElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductIndicationOtherTherapy.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductIndicationOtherTherapy.fhirType : string;
begin
  result := 'otherTherapy';
end;

function TFhirMedicinalProductIndicationOtherTherapy.Link : TFhirMedicinalProductIndicationOtherTherapy;
begin
  result := TFhirMedicinalProductIndicationOtherTherapy(inherited Link);
end;

function TFhirMedicinalProductIndicationOtherTherapy.Clone : TFhirMedicinalProductIndicationOtherTherapy;
begin
  result := TFhirMedicinalProductIndicationOtherTherapy(inherited Clone);
end;

function TFhirMedicinalProductIndicationOtherTherapy.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductIndicationOtherTherapy;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductIndicationOtherTherapy)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductIndicationOtherTherapy(other);
    result := compareDeep(therapyRelationshipTypeElement, o.therapyRelationshipTypeElement, true) and 
      compareDeep(medicationElement, o.medicationElement, true);
  end;
end;

function TFhirMedicinalProductIndicationOtherTherapy.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTherapyRelationshipType) and isEmptyProp(FMedication);
end;

procedure TFhirMedicinalProductIndicationOtherTherapy.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('therapyRelationshipType');
  fields.add('medication[x]');
end;

{ TFhirMedicinalProductIndicationOtherTherapy }

Procedure TFhirMedicinalProductIndicationOtherTherapy.SetTherapyRelationshipType(value : TFhirCodeableConcept);
begin
  FTherapyRelationshipType.free;
  FTherapyRelationshipType := value;
end;

Procedure TFhirMedicinalProductIndicationOtherTherapy.SetMedication(value : TFhirType);
begin
  FMedication.free;
  FMedication := value;
end;

function TFhirMedicinalProductIndicationOtherTherapy.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FTherapyRelationshipType.sizeInBytes);
  inc(result, FMedication.sizeInBytes);
end;

{ TFhirMedicinalProductIndicationOtherTherapyListEnumerator }

Constructor TFhirMedicinalProductIndicationOtherTherapyListEnumerator.Create(list : TFhirMedicinalProductIndicationOtherTherapyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductIndicationOtherTherapyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductIndicationOtherTherapyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductIndicationOtherTherapyListEnumerator.GetCurrent : TFhirMedicinalProductIndicationOtherTherapy;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductIndicationOtherTherapyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductIndicationOtherTherapyList }
procedure TFhirMedicinalProductIndicationOtherTherapyList.AddItem(value: TFhirMedicinalProductIndicationOtherTherapy);
begin
  assert(value.ClassName = 'TFhirMedicinalProductIndicationOtherTherapy', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductIndicationOtherTherapy');
  add(value);
end;

function TFhirMedicinalProductIndicationOtherTherapyList.Append: TFhirMedicinalProductIndicationOtherTherapy;
begin
  result := TFhirMedicinalProductIndicationOtherTherapy.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductIndicationOtherTherapyList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductIndicationOtherTherapyList.GetEnumerator : TFhirMedicinalProductIndicationOtherTherapyListEnumerator;
begin
  result := TFhirMedicinalProductIndicationOtherTherapyListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductIndicationOtherTherapyList.Clone: TFhirMedicinalProductIndicationOtherTherapyList;
begin
  result := TFhirMedicinalProductIndicationOtherTherapyList(inherited Clone);
end;

function TFhirMedicinalProductIndicationOtherTherapyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductIndicationOtherTherapyList.GetItemN(index: Integer): TFhirMedicinalProductIndicationOtherTherapy;
begin
  result := TFhirMedicinalProductIndicationOtherTherapy(ObjectByIndex[index]);
end;

function TFhirMedicinalProductIndicationOtherTherapyList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductIndicationOtherTherapy;
end;
function TFhirMedicinalProductIndicationOtherTherapyList.IndexOf(value: TFhirMedicinalProductIndicationOtherTherapy): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductIndicationOtherTherapyList.Insert(index: Integer): TFhirMedicinalProductIndicationOtherTherapy;
begin
  result := TFhirMedicinalProductIndicationOtherTherapy.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductIndicationOtherTherapyList.InsertItem(index: Integer; value: TFhirMedicinalProductIndicationOtherTherapy);
begin
  assert(value is TFhirMedicinalProductIndicationOtherTherapy);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductIndicationOtherTherapyList.Item(index: Integer): TFhirMedicinalProductIndicationOtherTherapy;
begin
  result := TFhirMedicinalProductIndicationOtherTherapy(ObjectByIndex[index]);
end;

function TFhirMedicinalProductIndicationOtherTherapyList.Link: TFhirMedicinalProductIndicationOtherTherapyList;
begin
  result := TFhirMedicinalProductIndicationOtherTherapyList(inherited Link);
end;

procedure TFhirMedicinalProductIndicationOtherTherapyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductIndicationOtherTherapyList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductIndicationOtherTherapy);
begin
  assert(value is TFhirMedicinalProductIndicationOtherTherapy);
  FhirMedicinalProductIndicationOtherTherapies[index] := value;
end;

procedure TFhirMedicinalProductIndicationOtherTherapyList.SetItemN(index: Integer; value: TFhirMedicinalProductIndicationOtherTherapy);
begin
  assert(value is TFhirMedicinalProductIndicationOtherTherapy);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductIndication }

constructor TFhirMedicinalProductIndication.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductIndication.Destroy;
begin
  FSubjectList.Free;
  FDiseaseSymptomProcedure.free;
  FDiseaseStatus.free;
  FComorbidityList.Free;
  FIntendedEffect.free;
  FDuration.free;
  FOtherTherapyList.Free;
  FUndesirableEffectList.Free;
  FPopulationList.Free;
  inherited;
end;

function TFhirMedicinalProductIndication.GetResourceType : TFhirResourceType;
begin
  result := frtMedicinalProductIndication;
end;

procedure TFhirMedicinalProductIndication.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicinalProductIndication(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirReferenceList{TFhirMedicinalProduct}.Create;
    FSubjectList.Assign(TFhirMedicinalProductIndication(oSource).FSubjectList);
  end;
  diseaseSymptomProcedure := TFhirMedicinalProductIndication(oSource).diseaseSymptomProcedure.Clone;
  diseaseStatus := TFhirMedicinalProductIndication(oSource).diseaseStatus.Clone;
  if (TFhirMedicinalProductIndication(oSource).FComorbidityList = nil) then
  begin
    FComorbidityList.free;
    FComorbidityList := nil;
  end
  else
  begin
    if FComorbidityList = nil then
      FComorbidityList := TFhirCodeableConceptList.Create;
    FComorbidityList.Assign(TFhirMedicinalProductIndication(oSource).FComorbidityList);
  end;
  intendedEffect := TFhirMedicinalProductIndication(oSource).intendedEffect.Clone;
  duration := TFhirMedicinalProductIndication(oSource).duration.Clone;
  if (TFhirMedicinalProductIndication(oSource).FOtherTherapyList = nil) then
  begin
    FOtherTherapyList.free;
    FOtherTherapyList := nil;
  end
  else
  begin
    if FOtherTherapyList = nil then
      FOtherTherapyList := TFhirMedicinalProductIndicationOtherTherapyList.Create;
    FOtherTherapyList.Assign(TFhirMedicinalProductIndication(oSource).FOtherTherapyList);
  end;
  if (TFhirMedicinalProductIndication(oSource).FUndesirableEffectList = nil) then
  begin
    FUndesirableEffectList.free;
    FUndesirableEffectList := nil;
  end
  else
  begin
    if FUndesirableEffectList = nil then
      FUndesirableEffectList := TFhirReferenceList{TFhirMedicinalProductUndesirableEffect}.Create;
    FUndesirableEffectList.Assign(TFhirMedicinalProductIndication(oSource).FUndesirableEffectList);
  end;
  if (TFhirMedicinalProductIndication(oSource).FPopulationList = nil) then
  begin
    FPopulationList.free;
    FPopulationList := nil;
  end
  else
  begin
    if FPopulationList = nil then
      FPopulationList := TFhirPopulationList.Create;
    FPopulationList.Assign(TFhirMedicinalProductIndication(oSource).FPopulationList);
  end;
end;

procedure TFhirMedicinalProductIndication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'diseaseSymptomProcedure') Then
     list.add(self.link, 'diseaseSymptomProcedure', FDiseaseSymptomProcedure.Link);
  if (child_name = 'diseaseStatus') Then
     list.add(self.link, 'diseaseStatus', FDiseaseStatus.Link);
  if (child_name = 'comorbidity') Then
    list.addAll(self, 'comorbidity', FComorbidityList);
  if (child_name = 'intendedEffect') Then
     list.add(self.link, 'intendedEffect', FIntendedEffect.Link);
  if (child_name = 'duration') Then
     list.add(self.link, 'duration', FDuration.Link);
  if (child_name = 'otherTherapy') Then
    list.addAll(self, 'otherTherapy', FOtherTherapyList);
  if (child_name = 'undesirableEffect') Then
    list.addAll(self, 'undesirableEffect', FUndesirableEffectList);
  if (child_name = 'population') Then
    list.addAll(self, 'population', FPopulationList);
end;

procedure TFhirMedicinalProductIndication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(MedicinalProduct)', true, TFhirReference{TFhirMedicinalProduct}, FSubjectList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'diseaseSymptomProcedure', 'CodeableConcept', false, TFhirCodeableConcept, FDiseaseSymptomProcedure.Link));{2}
  oList.add(TFHIRProperty.create(self, 'diseaseStatus', 'CodeableConcept', false, TFhirCodeableConcept, FDiseaseStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comorbidity', 'CodeableConcept', true, TFhirCodeableConcept, FComorbidityList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'intendedEffect', 'CodeableConcept', false, TFhirCodeableConcept, FIntendedEffect.Link));{2}
  oList.add(TFHIRProperty.create(self, 'duration', 'Quantity', false, TFhirQuantity, FDuration.Link));{2}
  oList.add(TFHIRProperty.create(self, 'otherTherapy', '', true, TFhirMedicinalProductIndicationOtherTherapy, FOtherTherapyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'undesirableEffect', 'Reference(MedicinalProductUndesirableEffect)', true, TFhirReference{TFhirMedicinalProductUndesirableEffect}, FUndesirableEffectList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'population', 'Population', true, TFhirPopulation, FPopulationList.Link)){3};
end;

function TFhirMedicinalProductIndication.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirReference{TFhirMedicinalProduct}){2a};
    result := propValue;
  end
  else if (propName = 'diseaseSymptomProcedure') then
  begin
    DiseaseSymptomProcedure := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'diseaseStatus') then
  begin
    DiseaseStatus := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'comorbidity') then
  begin
    ComorbidityList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'intendedEffect') then
  begin
    IntendedEffect := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'duration') then
  begin
    Duration := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'otherTherapy') then
  begin
    OtherTherapyList.add(propValue as TFhirMedicinalProductIndicationOtherTherapy){2a};
    result := propValue;
  end
  else if (propName = 'undesirableEffect') then
  begin
    UndesirableEffectList.add(propValue as TFhirReference{TFhirMedicinalProductUndesirableEffect}){2a};
    result := propValue;
  end
  else if (propName = 'population') then
  begin
    PopulationList.add(propValue as TFhirPopulation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedicinalProductIndication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirReference{TFhirMedicinalProduct}){2a}
  else if (propName = 'comorbidity') then ComorbidityList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'otherTherapy') then OtherTherapyList.insertItem(index, propValue as TFhirMedicinalProductIndicationOtherTherapy){2a}
  else if (propName = 'undesirableEffect') then UndesirableEffectList.insertItem(index, propValue as TFhirReference{TFhirMedicinalProductUndesirableEffect}){2a}
  else if (propName = 'population') then PopulationList.insertItem(index, propValue as TFhirPopulation){2a}
  else inherited;
end;

function TFhirMedicinalProductIndication.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'subject') then result := SubjectList.new(){2}
  else if (propName = 'diseaseSymptomProcedure') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'diseaseStatus') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'comorbidity') then result := ComorbidityList.new(){2}
  else if (propName = 'intendedEffect') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'duration') then result := TFhirQuantity.create(){4b}
  else if (propName = 'otherTherapy') then result := OtherTherapyList.new(){2}
  else if (propName = 'undesirableEffect') then result := UndesirableEffectList.new(){2}
  else if (propName = 'population') then result := PopulationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductIndication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'subject') then result := 'Reference'
  else if (propName = 'diseaseSymptomProcedure') then result := 'CodeableConcept'
  else if (propName = 'diseaseStatus') then result := 'CodeableConcept'
  else if (propName = 'comorbidity') then result := 'CodeableConcept'
  else if (propName = 'intendedEffect') then result := 'CodeableConcept'
  else if (propName = 'duration') then result := 'Quantity'
  else if (propName = 'otherTherapy') then result := ''
  else if (propName = 'undesirableEffect') then result := 'Reference'
  else if (propName = 'population') then result := 'Population'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductIndication.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value) {2}
  else if (propName = 'diseaseSymptomProcedure') then DiseaseSymptomProcedureElement := nil
  else if (propName = 'diseaseStatus') then DiseaseStatusElement := nil
  else if (propName = 'comorbidity') then deletePropertyValue('comorbidity', ComorbidityList, value) {2}
  else if (propName = 'intendedEffect') then IntendedEffectElement := nil
  else if (propName = 'duration') then DurationElement := nil
  else if (propName = 'otherTherapy') then deletePropertyValue('otherTherapy', OtherTherapyList, value) {2}
  else if (propName = 'undesirableEffect') then deletePropertyValue('undesirableEffect', UndesirableEffectList, value) {2}
  else if (propName = 'population') then deletePropertyValue('population', PopulationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductIndication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new) {2}
  else if (propName = 'diseaseSymptomProcedure') then DiseaseSymptomProcedureElement := new as TFhirCodeableConcept{4}
  else if (propName = 'diseaseStatus') then DiseaseStatusElement := new as TFhirCodeableConcept{4}
  else if (propName = 'comorbidity') then replacePropertyValue('comorbidity', ComorbidityList, existing, new) {2}
  else if (propName = 'intendedEffect') then IntendedEffectElement := new as TFhirCodeableConcept{4}
  else if (propName = 'duration') then DurationElement := new as TFhirQuantity{4}
  else if (propName = 'otherTherapy') then replacePropertyValue('otherTherapy', OtherTherapyList, existing, new) {2}
  else if (propName = 'undesirableEffect') then replacePropertyValue('undesirableEffect', UndesirableEffectList, existing, new) {2}
  else if (propName = 'population') then replacePropertyValue('population', PopulationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductIndication.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'subject') then SubjectList.move(source, destination){2a}
  else if (propName = 'comorbidity') then ComorbidityList.move(source, destination){2a}
  else if (propName = 'otherTherapy') then OtherTherapyList.move(source, destination){2a}
  else if (propName = 'undesirableEffect') then UndesirableEffectList.move(source, destination){2a}
  else if (propName = 'population') then PopulationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductIndication.fhirType : string;
begin
  result := 'MedicinalProductIndication';
end;

function TFhirMedicinalProductIndication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FsubjectList) and isEmptyProp(FDiseaseSymptomProcedure) and isEmptyProp(FDiseaseStatus) and isEmptyProp(FcomorbidityList) and isEmptyProp(FIntendedEffect) and isEmptyProp(FDuration) and isEmptyProp(FotherTherapyList) and isEmptyProp(FundesirableEffectList) and isEmptyProp(FpopulationList);
end;

function TFhirMedicinalProductIndication.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductIndication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductIndication)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductIndication(other);
    result := compareDeep(subjectList, o.subjectList, true) and compareDeep(diseaseSymptomProcedureElement, o.diseaseSymptomProcedureElement, true) and 
      compareDeep(diseaseStatusElement, o.diseaseStatusElement, true) and compareDeep(comorbidityList, o.comorbidityList, true) and 
      compareDeep(intendedEffectElement, o.intendedEffectElement, true) and compareDeep(durationElement, o.durationElement, true) and 
      compareDeep(otherTherapyList, o.otherTherapyList, true) and compareDeep(undesirableEffectList, o.undesirableEffectList, true) and 
      compareDeep(populationList, o.populationList, true);
  end;
end;

function TFhirMedicinalProductIndication.Link : TFhirMedicinalProductIndication;
begin
  result := TFhirMedicinalProductIndication(inherited Link);
end;

function TFhirMedicinalProductIndication.Clone : TFhirMedicinalProductIndication;
begin
  result := TFhirMedicinalProductIndication(inherited Clone);
end;

procedure TFhirMedicinalProductIndication.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('subject');
  fields.add('diseaseSymptomProcedure');
  fields.add('diseaseStatus');
  fields.add('comorbidity');
  fields.add('intendedEffect');
  fields.add('duration');
  fields.add('otherTherapy');
  fields.add('undesirableEffect');
  fields.add('population');
end;

{ TFhirMedicinalProductIndication }

Function TFhirMedicinalProductIndication.GetSubjectList : TFhirReferenceList{TFhirMedicinalProduct};
begin
  if FSubjectList = nil then
    FSubjectList := TFhirReferenceList{TFhirMedicinalProduct}.Create;
  result := FSubjectList;
end;

Function TFhirMedicinalProductIndication.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

Procedure TFhirMedicinalProductIndication.SetDiseaseSymptomProcedure(value : TFhirCodeableConcept);
begin
  FDiseaseSymptomProcedure.free;
  FDiseaseSymptomProcedure := value;
end;

Procedure TFhirMedicinalProductIndication.SetDiseaseStatus(value : TFhirCodeableConcept);
begin
  FDiseaseStatus.free;
  FDiseaseStatus := value;
end;

Function TFhirMedicinalProductIndication.GetComorbidityList : TFhirCodeableConceptList;
begin
  if FComorbidityList = nil then
    FComorbidityList := TFhirCodeableConceptList.Create;
  result := FComorbidityList;
end;

Function TFhirMedicinalProductIndication.GetHasComorbidityList : boolean;
begin
  result := (FComorbidityList <> nil) and (FComorbidityList.count > 0);
end;

Procedure TFhirMedicinalProductIndication.SetIntendedEffect(value : TFhirCodeableConcept);
begin
  FIntendedEffect.free;
  FIntendedEffect := value;
end;

Procedure TFhirMedicinalProductIndication.SetDuration(value : TFhirQuantity);
begin
  FDuration.free;
  FDuration := value;
end;

Function TFhirMedicinalProductIndication.GetOtherTherapyList : TFhirMedicinalProductIndicationOtherTherapyList;
begin
  if FOtherTherapyList = nil then
    FOtherTherapyList := TFhirMedicinalProductIndicationOtherTherapyList.Create;
  result := FOtherTherapyList;
end;

Function TFhirMedicinalProductIndication.GetHasOtherTherapyList : boolean;
begin
  result := (FOtherTherapyList <> nil) and (FOtherTherapyList.count > 0);
end;

Function TFhirMedicinalProductIndication.GetUndesirableEffectList : TFhirReferenceList{TFhirMedicinalProductUndesirableEffect};
begin
  if FUndesirableEffectList = nil then
    FUndesirableEffectList := TFhirReferenceList{TFhirMedicinalProductUndesirableEffect}.Create;
  result := FUndesirableEffectList;
end;

Function TFhirMedicinalProductIndication.GetHasUndesirableEffectList : boolean;
begin
  result := (FUndesirableEffectList <> nil) and (FUndesirableEffectList.count > 0);
end;

Function TFhirMedicinalProductIndication.GetPopulationList : TFhirPopulationList;
begin
  if FPopulationList = nil then
    FPopulationList := TFhirPopulationList.Create;
  result := FPopulationList;
end;

Function TFhirMedicinalProductIndication.GetHasPopulationList : boolean;
begin
  result := (FPopulationList <> nil) and (FPopulationList.count > 0);
end;

function TFhirMedicinalProductIndication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FsubjectList.sizeInBytes);
  inc(result, FDiseaseSymptomProcedure.sizeInBytes);
  inc(result, FDiseaseStatus.sizeInBytes);
  inc(result, FcomorbidityList.sizeInBytes);
  inc(result, FIntendedEffect.sizeInBytes);
  inc(result, FDuration.sizeInBytes);
  inc(result, FotherTherapyList.sizeInBytes);
  inc(result, FundesirableEffectList.sizeInBytes);
  inc(result, FpopulationList.sizeInBytes);
end;

{ TFhirMedicinalProductIndicationListEnumerator }

Constructor TFhirMedicinalProductIndicationListEnumerator.Create(list : TFhirMedicinalProductIndicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductIndicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductIndicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductIndicationListEnumerator.GetCurrent : TFhirMedicinalProductIndication;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductIndicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductIndicationList }
procedure TFhirMedicinalProductIndicationList.AddItem(value: TFhirMedicinalProductIndication);
begin
  assert(value.ClassName = 'TFhirMedicinalProductIndication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductIndication');
  add(value);
end;

function TFhirMedicinalProductIndicationList.Append: TFhirMedicinalProductIndication;
begin
  result := TFhirMedicinalProductIndication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductIndicationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductIndicationList.GetEnumerator : TFhirMedicinalProductIndicationListEnumerator;
begin
  result := TFhirMedicinalProductIndicationListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductIndicationList.Clone: TFhirMedicinalProductIndicationList;
begin
  result := TFhirMedicinalProductIndicationList(inherited Clone);
end;

function TFhirMedicinalProductIndicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductIndicationList.GetItemN(index: Integer): TFhirMedicinalProductIndication;
begin
  result := TFhirMedicinalProductIndication(ObjectByIndex[index]);
end;

function TFhirMedicinalProductIndicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductIndication;
end;
function TFhirMedicinalProductIndicationList.IndexOf(value: TFhirMedicinalProductIndication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductIndicationList.Insert(index: Integer): TFhirMedicinalProductIndication;
begin
  result := TFhirMedicinalProductIndication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductIndicationList.InsertItem(index: Integer; value: TFhirMedicinalProductIndication);
begin
  assert(value is TFhirMedicinalProductIndication);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductIndicationList.Item(index: Integer): TFhirMedicinalProductIndication;
begin
  result := TFhirMedicinalProductIndication(ObjectByIndex[index]);
end;

function TFhirMedicinalProductIndicationList.Link: TFhirMedicinalProductIndicationList;
begin
  result := TFhirMedicinalProductIndicationList(inherited Link);
end;

procedure TFhirMedicinalProductIndicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductIndicationList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductIndication);
begin
  assert(value is TFhirMedicinalProductIndication);
  FhirMedicinalProductIndications[index] := value;
end;

procedure TFhirMedicinalProductIndicationList.SetItemN(index: Integer; value: TFhirMedicinalProductIndication);
begin
  assert(value is TFhirMedicinalProductIndication);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICINALPRODUCTINDICATION}

{$IFDEF FHIR_MEDICINALPRODUCTINGREDIENT}

{ TFhirMedicinalProductIngredientSpecifiedSubstance }

constructor TFhirMedicinalProductIngredientSpecifiedSubstance.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductIngredientSpecifiedSubstance.Destroy;
begin
  FCode.free;
  FGroup.free;
  FConfidentiality.free;
  FStrengthList.Free;
  inherited;
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstance.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMedicinalProductIngredientSpecifiedSubstance(oSource).code.Clone;
  group := TFhirMedicinalProductIngredientSpecifiedSubstance(oSource).group.Clone;
  confidentiality := TFhirMedicinalProductIngredientSpecifiedSubstance(oSource).confidentiality.Clone;
  if (TFhirMedicinalProductIngredientSpecifiedSubstance(oSource).FStrengthList = nil) then
  begin
    FStrengthList.free;
    FStrengthList := nil;
  end
  else
  begin
    if FStrengthList = nil then
      FStrengthList := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList.Create;
    FStrengthList.Assign(TFhirMedicinalProductIngredientSpecifiedSubstance(oSource).FStrengthList);
  end;
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'group') Then
     list.add(self.link, 'group', FGroup.Link);
  if (child_name = 'confidentiality') Then
     list.add(self.link, 'confidentiality', FConfidentiality.Link);
  if (child_name = 'strength') Then
    list.addAll(self, 'strength', FStrengthList);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'group', 'CodeableConcept', false, TFhirCodeableConcept, FGroup.Link));{2}
  oList.add(TFHIRProperty.create(self, 'confidentiality', 'CodeableConcept', false, TFhirCodeableConcept, FConfidentiality.Link));{2}
  oList.add(TFHIRProperty.create(self, 'strength', '', true, TFhirMedicinalProductIngredientSpecifiedSubstanceStrength, FStrengthList.Link)){3};
end;

function TFhirMedicinalProductIngredientSpecifiedSubstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    Group := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'confidentiality') then
  begin
    Confidentiality := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'strength') then
  begin
    StrengthList.add(propValue as TFhirMedicinalProductIngredientSpecifiedSubstanceStrength){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'strength') then StrengthList.insertItem(index, propValue as TFhirMedicinalProductIngredientSpecifiedSubstanceStrength){2a}
  else inherited;
end;

function TFhirMedicinalProductIngredientSpecifiedSubstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'group') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'confidentiality') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'strength') then result := StrengthList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'group') then result := 'CodeableConcept'
  else if (propName = 'confidentiality') then result := 'CodeableConcept'
  else if (propName = 'strength') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'group') then GroupElement := nil
  else if (propName = 'confidentiality') then ConfidentialityElement := nil
  else if (propName = 'strength') then deletePropertyValue('strength', StrengthList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'group') then GroupElement := new as TFhirCodeableConcept{4}
  else if (propName = 'confidentiality') then ConfidentialityElement := new as TFhirCodeableConcept{4}
  else if (propName = 'strength') then replacePropertyValue('strength', StrengthList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'strength') then StrengthList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstance.fhirType : string;
begin
  result := 'specifiedSubstance';
end;

function TFhirMedicinalProductIngredientSpecifiedSubstance.Link : TFhirMedicinalProductIngredientSpecifiedSubstance;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstance(inherited Link);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstance.Clone : TFhirMedicinalProductIngredientSpecifiedSubstance;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstance(inherited Clone);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstance.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductIngredientSpecifiedSubstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductIngredientSpecifiedSubstance)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductIngredientSpecifiedSubstance(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(groupElement, o.groupElement, true) and 
      compareDeep(confidentialityElement, o.confidentialityElement, true) and compareDeep(strengthList, o.strengthList, true);
  end;
end;

function TFhirMedicinalProductIngredientSpecifiedSubstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FGroup) and isEmptyProp(FConfidentiality) and isEmptyProp(FstrengthList);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('group');
  fields.add('confidentiality');
  fields.add('strength');
end;

{ TFhirMedicinalProductIngredientSpecifiedSubstance }

Procedure TFhirMedicinalProductIngredientSpecifiedSubstance.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirMedicinalProductIngredientSpecifiedSubstance.SetGroup(value : TFhirCodeableConcept);
begin
  FGroup.free;
  FGroup := value;
end;

Procedure TFhirMedicinalProductIngredientSpecifiedSubstance.SetConfidentiality(value : TFhirCodeableConcept);
begin
  FConfidentiality.free;
  FConfidentiality := value;
end;

Function TFhirMedicinalProductIngredientSpecifiedSubstance.GetStrengthList : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList;
begin
  if FStrengthList = nil then
    FStrengthList := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList.Create;
  result := FStrengthList;
end;

Function TFhirMedicinalProductIngredientSpecifiedSubstance.GetHasStrengthList : boolean;
begin
  result := (FStrengthList <> nil) and (FStrengthList.count > 0);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FGroup.sizeInBytes);
  inc(result, FConfidentiality.sizeInBytes);
  inc(result, FstrengthList.sizeInBytes);
end;

{ TFhirMedicinalProductIngredientSpecifiedSubstanceListEnumerator }

Constructor TFhirMedicinalProductIngredientSpecifiedSubstanceListEnumerator.Create(list : TFhirMedicinalProductIngredientSpecifiedSubstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductIngredientSpecifiedSubstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceListEnumerator.GetCurrent : TFhirMedicinalProductIngredientSpecifiedSubstance;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductIngredientSpecifiedSubstanceList }
procedure TFhirMedicinalProductIngredientSpecifiedSubstanceList.AddItem(value: TFhirMedicinalProductIngredientSpecifiedSubstance);
begin
  assert(value.ClassName = 'TFhirMedicinalProductIngredientSpecifiedSubstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductIngredientSpecifiedSubstance');
  add(value);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceList.Append: TFhirMedicinalProductIngredientSpecifiedSubstance;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceList.GetEnumerator : TFhirMedicinalProductIngredientSpecifiedSubstanceListEnumerator;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceList.Clone: TFhirMedicinalProductIngredientSpecifiedSubstanceList;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceList(inherited Clone);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceList.GetItemN(index: Integer): TFhirMedicinalProductIngredientSpecifiedSubstance;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstance(ObjectByIndex[index]);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstance;
end;
function TFhirMedicinalProductIngredientSpecifiedSubstanceList.IndexOf(value: TFhirMedicinalProductIngredientSpecifiedSubstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceList.Insert(index: Integer): TFhirMedicinalProductIngredientSpecifiedSubstance;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceList.InsertItem(index: Integer; value: TFhirMedicinalProductIngredientSpecifiedSubstance);
begin
  assert(value is TFhirMedicinalProductIngredientSpecifiedSubstance);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceList.Item(index: Integer): TFhirMedicinalProductIngredientSpecifiedSubstance;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstance(ObjectByIndex[index]);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceList.Link: TFhirMedicinalProductIngredientSpecifiedSubstanceList;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceList(inherited Link);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductIngredientSpecifiedSubstance);
begin
  assert(value is TFhirMedicinalProductIngredientSpecifiedSubstance);
  FhirMedicinalProductIngredientSpecifiedSubstances[index] := value;
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceList.SetItemN(index: Integer; value: TFhirMedicinalProductIngredientSpecifiedSubstance);
begin
  assert(value is TFhirMedicinalProductIngredientSpecifiedSubstance);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductIngredientSpecifiedSubstanceStrength }

constructor TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.Destroy;
begin
  FPresentation.free;
  FPresentationLowLimit.free;
  FConcentration.free;
  FConcentrationLowLimit.free;
  FMeasurementPoint.free;
  FCountryList.Free;
  FReferenceStrengthList.Free;
  inherited;
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.Assign(oSource : TFslObject);
begin
  inherited;
  presentation := TFhirMedicinalProductIngredientSpecifiedSubstanceStrength(oSource).presentation.Clone;
  presentationLowLimit := TFhirMedicinalProductIngredientSpecifiedSubstanceStrength(oSource).presentationLowLimit.Clone;
  concentration := TFhirMedicinalProductIngredientSpecifiedSubstanceStrength(oSource).concentration.Clone;
  concentrationLowLimit := TFhirMedicinalProductIngredientSpecifiedSubstanceStrength(oSource).concentrationLowLimit.Clone;
  measurementPointElement := TFhirMedicinalProductIngredientSpecifiedSubstanceStrength(oSource).measurementPointElement.Clone;
  if (TFhirMedicinalProductIngredientSpecifiedSubstanceStrength(oSource).FCountryList = nil) then
  begin
    FCountryList.free;
    FCountryList := nil;
  end
  else
  begin
    if FCountryList = nil then
      FCountryList := TFhirCodeableConceptList.Create;
    FCountryList.Assign(TFhirMedicinalProductIngredientSpecifiedSubstanceStrength(oSource).FCountryList);
  end;
  if (TFhirMedicinalProductIngredientSpecifiedSubstanceStrength(oSource).FReferenceStrengthList = nil) then
  begin
    FReferenceStrengthList.free;
    FReferenceStrengthList := nil;
  end
  else
  begin
    if FReferenceStrengthList = nil then
      FReferenceStrengthList := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList.Create;
    FReferenceStrengthList.Assign(TFhirMedicinalProductIngredientSpecifiedSubstanceStrength(oSource).FReferenceStrengthList);
  end;
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'presentation') Then
     list.add(self.link, 'presentation', FPresentation.Link);
  if (child_name = 'presentationLowLimit') Then
     list.add(self.link, 'presentationLowLimit', FPresentationLowLimit.Link);
  if (child_name = 'concentration') Then
     list.add(self.link, 'concentration', FConcentration.Link);
  if (child_name = 'concentrationLowLimit') Then
     list.add(self.link, 'concentrationLowLimit', FConcentrationLowLimit.Link);
  if (child_name = 'measurementPoint') Then
     list.add(self.link, 'measurementPoint', FMeasurementPoint.Link);
  if (child_name = 'country') Then
    list.addAll(self, 'country', FCountryList);
  if (child_name = 'referenceStrength') Then
    list.addAll(self, 'referenceStrength', FReferenceStrengthList);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'presentation', 'Ratio', false, TFhirRatio, FPresentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'presentationLowLimit', 'Ratio', false, TFhirRatio, FPresentationLowLimit.Link));{2}
  oList.add(TFHIRProperty.create(self, 'concentration', 'Ratio', false, TFhirRatio, FConcentration.Link));{2}
  oList.add(TFHIRProperty.create(self, 'concentrationLowLimit', 'Ratio', false, TFhirRatio, FConcentrationLowLimit.Link));{2}
  oList.add(TFHIRProperty.create(self, 'measurementPoint', 'string', false, TFhirString, FMeasurementPoint.Link));{2}
  oList.add(TFHIRProperty.create(self, 'country', 'CodeableConcept', true, TFhirCodeableConcept, FCountryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'referenceStrength', '', true, TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength, FReferenceStrengthList.Link)){3};
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'presentation') then
  begin
    Presentation := propValue as TFhirRatio{4b};
    result := propValue;
  end
  else if (propName = 'presentationLowLimit') then
  begin
    PresentationLowLimit := propValue as TFhirRatio{4b};
    result := propValue;
  end
  else if (propName = 'concentration') then
  begin
    Concentration := propValue as TFhirRatio{4b};
    result := propValue;
  end
  else if (propName = 'concentrationLowLimit') then
  begin
    ConcentrationLowLimit := propValue as TFhirRatio{4b};
    result := propValue;
  end
  else if (propName = 'measurementPoint') then
  begin
    MeasurementPointElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'country') then
  begin
    CountryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'referenceStrength') then
  begin
    ReferenceStrengthList.add(propValue as TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'country') then CountryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'referenceStrength') then ReferenceStrengthList.insertItem(index, propValue as TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength){2a}
  else inherited;
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'presentation') then result := TFhirRatio.create(){4b}
  else if (propName = 'presentationLowLimit') then result := TFhirRatio.create(){4b}
  else if (propName = 'concentration') then result := TFhirRatio.create(){4b}
  else if (propName = 'concentrationLowLimit') then result := TFhirRatio.create(){4b}
  else if (propName = 'measurementPoint') then result := TFhirString.create() {5b}
  else if (propName = 'country') then result := CountryList.new(){2}
  else if (propName = 'referenceStrength') then result := ReferenceStrengthList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'presentation') then result := 'Ratio'
  else if (propName = 'presentationLowLimit') then result := 'Ratio'
  else if (propName = 'concentration') then result := 'Ratio'
  else if (propName = 'concentrationLowLimit') then result := 'Ratio'
  else if (propName = 'measurementPoint') then result := 'string'
  else if (propName = 'country') then result := 'CodeableConcept'
  else if (propName = 'referenceStrength') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'presentation') then PresentationElement := nil
  else if (propName = 'presentationLowLimit') then PresentationLowLimitElement := nil
  else if (propName = 'concentration') then ConcentrationElement := nil
  else if (propName = 'concentrationLowLimit') then ConcentrationLowLimitElement := nil
  else if (propName = 'measurementPoint') then MeasurementPointElement := nil
  else if (propName = 'country') then deletePropertyValue('country', CountryList, value) {2}
  else if (propName = 'referenceStrength') then deletePropertyValue('referenceStrength', ReferenceStrengthList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'presentation') then PresentationElement := new as TFhirRatio{4}
  else if (propName = 'presentationLowLimit') then PresentationLowLimitElement := new as TFhirRatio{4}
  else if (propName = 'concentration') then ConcentrationElement := new as TFhirRatio{4}
  else if (propName = 'concentrationLowLimit') then ConcentrationLowLimitElement := new as TFhirRatio{4}
  else if (propName = 'measurementPoint') then MeasurementPointElement := asString(new){5b}
  else if (propName = 'country') then replacePropertyValue('country', CountryList, existing, new) {2}
  else if (propName = 'referenceStrength') then replacePropertyValue('referenceStrength', ReferenceStrengthList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'country') then CountryList.move(source, destination){2a}
  else if (propName = 'referenceStrength') then ReferenceStrengthList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.fhirType : string;
begin
  result := 'strength';
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.Link : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrength(inherited Link);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.Clone : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrength(inherited Clone);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductIngredientSpecifiedSubstanceStrength)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductIngredientSpecifiedSubstanceStrength(other);
    result := compareDeep(presentationElement, o.presentationElement, true) and 
      compareDeep(presentationLowLimitElement, o.presentationLowLimitElement, true) and 
      compareDeep(concentrationElement, o.concentrationElement, true) and compareDeep(concentrationLowLimitElement, o.concentrationLowLimitElement, true) and 
      compareDeep(measurementPointElement, o.measurementPointElement, true) and compareDeep(countryList, o.countryList, true) and 
      compareDeep(referenceStrengthList, o.referenceStrengthList, true);
  end;
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPresentation) and isEmptyProp(FPresentationLowLimit) and isEmptyProp(FConcentration) and isEmptyProp(FConcentrationLowLimit) and isEmptyProp(FMeasurementPoint) and isEmptyProp(FcountryList) and isEmptyProp(FreferenceStrengthList);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('presentation');
  fields.add('presentationLowLimit');
  fields.add('concentration');
  fields.add('concentrationLowLimit');
  fields.add('measurementPoint');
  fields.add('country');
  fields.add('referenceStrength');
end;

{ TFhirMedicinalProductIngredientSpecifiedSubstanceStrength }

Procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.SetPresentation(value : TFhirRatio);
begin
  FPresentation.free;
  FPresentation := value;
end;

Procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.SetPresentationLowLimit(value : TFhirRatio);
begin
  FPresentationLowLimit.free;
  FPresentationLowLimit := value;
end;

Procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.SetConcentration(value : TFhirRatio);
begin
  FConcentration.free;
  FConcentration := value;
end;

Procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.SetConcentrationLowLimit(value : TFhirRatio);
begin
  FConcentrationLowLimit.free;
  FConcentrationLowLimit := value;
end;

Procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.SetMeasurementPoint(value : TFhirString);
begin
  FMeasurementPoint.free;
  FMeasurementPoint := value;
end;

Function TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.GetMeasurementPointST : String;
begin
  if FMeasurementPoint = nil then
    result := ''
  else
    result := FMeasurementPoint.value;
end;

Procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.SetMeasurementPointST(value : String);
begin
  if value <> '' then
  begin
    if FMeasurementPoint = nil then
      FMeasurementPoint := TFhirString.create;
    FMeasurementPoint.value := value
  end
  else if FMeasurementPoint <> nil then
    FMeasurementPoint.value := '';
end;

Function TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.GetCountryList : TFhirCodeableConceptList;
begin
  if FCountryList = nil then
    FCountryList := TFhirCodeableConceptList.Create;
  result := FCountryList;
end;

Function TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.GetHasCountryList : boolean;
begin
  result := (FCountryList <> nil) and (FCountryList.count > 0);
end;

Function TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.GetReferenceStrengthList : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList;
begin
  if FReferenceStrengthList = nil then
    FReferenceStrengthList := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList.Create;
  result := FReferenceStrengthList;
end;

Function TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.GetHasReferenceStrengthList : boolean;
begin
  result := (FReferenceStrengthList <> nil) and (FReferenceStrengthList.count > 0);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPresentation.sizeInBytes);
  inc(result, FPresentationLowLimit.sizeInBytes);
  inc(result, FConcentration.sizeInBytes);
  inc(result, FConcentrationLowLimit.sizeInBytes);
  inc(result, FMeasurementPoint.sizeInBytes);
  inc(result, FcountryList.sizeInBytes);
  inc(result, FreferenceStrengthList.sizeInBytes);
end;

{ TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthListEnumerator }

Constructor TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthListEnumerator.Create(list : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthListEnumerator.GetCurrent : TFhirMedicinalProductIngredientSpecifiedSubstanceStrength;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList }
procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList.AddItem(value: TFhirMedicinalProductIngredientSpecifiedSubstanceStrength);
begin
  assert(value.ClassName = 'TFhirMedicinalProductIngredientSpecifiedSubstanceStrength', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductIngredientSpecifiedSubstanceStrength');
  add(value);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList.Append: TFhirMedicinalProductIngredientSpecifiedSubstanceStrength;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList.GetEnumerator : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthListEnumerator;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList.Clone: TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList(inherited Clone);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList.GetItemN(index: Integer): TFhirMedicinalProductIngredientSpecifiedSubstanceStrength;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrength(ObjectByIndex[index]);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrength;
end;
function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList.IndexOf(value: TFhirMedicinalProductIngredientSpecifiedSubstanceStrength): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList.Insert(index: Integer): TFhirMedicinalProductIngredientSpecifiedSubstanceStrength;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrength.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList.InsertItem(index: Integer; value: TFhirMedicinalProductIngredientSpecifiedSubstanceStrength);
begin
  assert(value is TFhirMedicinalProductIngredientSpecifiedSubstanceStrength);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList.Item(index: Integer): TFhirMedicinalProductIngredientSpecifiedSubstanceStrength;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrength(ObjectByIndex[index]);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList.Link: TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList(inherited Link);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductIngredientSpecifiedSubstanceStrength);
begin
  assert(value is TFhirMedicinalProductIngredientSpecifiedSubstanceStrength);
  FhirMedicinalProductIngredientSpecifiedSubstanceStrengths[index] := value;
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList.SetItemN(index: Integer; value: TFhirMedicinalProductIngredientSpecifiedSubstanceStrength);
begin
  assert(value is TFhirMedicinalProductIngredientSpecifiedSubstanceStrength);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength }

constructor TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.Destroy;
begin
  FSubstance.free;
  FStrength.free;
  FStrengthLowLimit.free;
  FMeasurementPoint.free;
  FCountryList.Free;
  inherited;
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.Assign(oSource : TFslObject);
begin
  inherited;
  substance := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(oSource).substance.Clone;
  strength := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(oSource).strength.Clone;
  strengthLowLimit := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(oSource).strengthLowLimit.Clone;
  measurementPointElement := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(oSource).measurementPointElement.Clone;
  if (TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(oSource).FCountryList = nil) then
  begin
    FCountryList.free;
    FCountryList := nil;
  end
  else
  begin
    if FCountryList = nil then
      FCountryList := TFhirCodeableConceptList.Create;
    FCountryList.Assign(TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(oSource).FCountryList);
  end;
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'substance') Then
     list.add(self.link, 'substance', FSubstance.Link);
  if (child_name = 'strength') Then
     list.add(self.link, 'strength', FStrength.Link);
  if (child_name = 'strengthLowLimit') Then
     list.add(self.link, 'strengthLowLimit', FStrengthLowLimit.Link);
  if (child_name = 'measurementPoint') Then
     list.add(self.link, 'measurementPoint', FMeasurementPoint.Link);
  if (child_name = 'country') Then
    list.addAll(self, 'country', FCountryList);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'substance', 'CodeableConcept', false, TFhirCodeableConcept, FSubstance.Link));{2}
  oList.add(TFHIRProperty.create(self, 'strength', 'Ratio', false, TFhirRatio, FStrength.Link));{2}
  oList.add(TFHIRProperty.create(self, 'strengthLowLimit', 'Ratio', false, TFhirRatio, FStrengthLowLimit.Link));{2}
  oList.add(TFHIRProperty.create(self, 'measurementPoint', 'string', false, TFhirString, FMeasurementPoint.Link));{2}
  oList.add(TFHIRProperty.create(self, 'country', 'CodeableConcept', true, TFhirCodeableConcept, FCountryList.Link)){3};
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'substance') then
  begin
    Substance := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'strength') then
  begin
    Strength := propValue as TFhirRatio{4b};
    result := propValue;
  end
  else if (propName = 'strengthLowLimit') then
  begin
    StrengthLowLimit := propValue as TFhirRatio{4b};
    result := propValue;
  end
  else if (propName = 'measurementPoint') then
  begin
    MeasurementPointElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'country') then
  begin
    CountryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'country') then CountryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'substance') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'strength') then result := TFhirRatio.create(){4b}
  else if (propName = 'strengthLowLimit') then result := TFhirRatio.create(){4b}
  else if (propName = 'measurementPoint') then result := TFhirString.create() {5b}
  else if (propName = 'country') then result := CountryList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'substance') then result := 'CodeableConcept'
  else if (propName = 'strength') then result := 'Ratio'
  else if (propName = 'strengthLowLimit') then result := 'Ratio'
  else if (propName = 'measurementPoint') then result := 'string'
  else if (propName = 'country') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'substance') then SubstanceElement := nil
  else if (propName = 'strength') then StrengthElement := nil
  else if (propName = 'strengthLowLimit') then StrengthLowLimitElement := nil
  else if (propName = 'measurementPoint') then MeasurementPointElement := nil
  else if (propName = 'country') then deletePropertyValue('country', CountryList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'substance') then SubstanceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'strength') then StrengthElement := new as TFhirRatio{4}
  else if (propName = 'strengthLowLimit') then StrengthLowLimitElement := new as TFhirRatio{4}
  else if (propName = 'measurementPoint') then MeasurementPointElement := asString(new){5b}
  else if (propName = 'country') then replacePropertyValue('country', CountryList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'country') then CountryList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.fhirType : string;
begin
  result := 'referenceStrength';
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.Link : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(inherited Link);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.Clone : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(inherited Clone);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(other);
    result := compareDeep(substanceElement, o.substanceElement, true) and compareDeep(strengthElement, o.strengthElement, true) and 
      compareDeep(strengthLowLimitElement, o.strengthLowLimitElement, true) and compareDeep(measurementPointElement, o.measurementPointElement, true) and 
      compareDeep(countryList, o.countryList, true);
  end;
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubstance) and isEmptyProp(FStrength) and isEmptyProp(FStrengthLowLimit) and isEmptyProp(FMeasurementPoint) and isEmptyProp(FcountryList);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('substance');
  fields.add('strength');
  fields.add('strengthLowLimit');
  fields.add('measurementPoint');
  fields.add('country');
end;

{ TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength }

Procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.SetSubstance(value : TFhirCodeableConcept);
begin
  FSubstance.free;
  FSubstance := value;
end;

Procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.SetStrength(value : TFhirRatio);
begin
  FStrength.free;
  FStrength := value;
end;

Procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.SetStrengthLowLimit(value : TFhirRatio);
begin
  FStrengthLowLimit.free;
  FStrengthLowLimit := value;
end;

Procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.SetMeasurementPoint(value : TFhirString);
begin
  FMeasurementPoint.free;
  FMeasurementPoint := value;
end;

Function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.GetMeasurementPointST : String;
begin
  if FMeasurementPoint = nil then
    result := ''
  else
    result := FMeasurementPoint.value;
end;

Procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.SetMeasurementPointST(value : String);
begin
  if value <> '' then
  begin
    if FMeasurementPoint = nil then
      FMeasurementPoint := TFhirString.create;
    FMeasurementPoint.value := value
  end
  else if FMeasurementPoint <> nil then
    FMeasurementPoint.value := '';
end;

Function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.GetCountryList : TFhirCodeableConceptList;
begin
  if FCountryList = nil then
    FCountryList := TFhirCodeableConceptList.Create;
  result := FCountryList;
end;

Function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.GetHasCountryList : boolean;
begin
  result := (FCountryList <> nil) and (FCountryList.count > 0);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSubstance.sizeInBytes);
  inc(result, FStrength.sizeInBytes);
  inc(result, FStrengthLowLimit.sizeInBytes);
  inc(result, FMeasurementPoint.sizeInBytes);
  inc(result, FcountryList.sizeInBytes);
end;

{ TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthListEnumerator }

Constructor TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthListEnumerator.Create(list : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthListEnumerator.GetCurrent : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList }
procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList.AddItem(value: TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength);
begin
  assert(value.ClassName = 'TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength');
  add(value);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList.Append: TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList.GetEnumerator : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthListEnumerator;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList.Clone: TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList(inherited Clone);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList.GetItemN(index: Integer): TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(ObjectByIndex[index]);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength;
end;
function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList.IndexOf(value: TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList.Insert(index: Integer): TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList.InsertItem(index: Integer; value: TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength);
begin
  assert(value is TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList.Item(index: Integer): TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength(ObjectByIndex[index]);
end;

function TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList.Link: TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList;
begin
  result := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList(inherited Link);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength);
begin
  assert(value is TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength);
  FhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengths[index] := value;
end;

procedure TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrengthList.SetItemN(index: Integer; value: TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength);
begin
  assert(value is TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthReferenceStrength);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductIngredientSubstance }

constructor TFhirMedicinalProductIngredientSubstance.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductIngredientSubstance.Destroy;
begin
  FCode.free;
  FStrengthList.Free;
  inherited;
end;

procedure TFhirMedicinalProductIngredientSubstance.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMedicinalProductIngredientSubstance(oSource).code.Clone;
  if (TFhirMedicinalProductIngredientSubstance(oSource).FStrengthList = nil) then
  begin
    FStrengthList.free;
    FStrengthList := nil;
  end
  else
  begin
    if FStrengthList = nil then
      FStrengthList := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList.Create;
    FStrengthList.Assign(TFhirMedicinalProductIngredientSubstance(oSource).FStrengthList);
  end;
end;

procedure TFhirMedicinalProductIngredientSubstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'strength') Then
    list.addAll(self, 'strength', FStrengthList);
end;

procedure TFhirMedicinalProductIngredientSubstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'strength', '@MedicinalProductIngredient.specifiedSubstance.strength', true, TFhirMedicinalProductIngredientSpecifiedSubstanceStrength, FStrengthList.Link)){3};
end;

function TFhirMedicinalProductIngredientSubstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'strength') then
  begin
    StrengthList.add(propValue as TFhirMedicinalProductIngredientSpecifiedSubstanceStrength){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductIngredientSubstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'strength') then StrengthList.insertItem(index, propValue as TFhirMedicinalProductIngredientSpecifiedSubstanceStrength){2a}
  else inherited;
end;

function TFhirMedicinalProductIngredientSubstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'strength') then result := StrengthList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductIngredientSubstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'strength') then result := '@MedicinalProductIngredient.specifiedSubstance.strength'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductIngredientSubstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'strength') then deletePropertyValue('strength', StrengthList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductIngredientSubstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'strength') then replacePropertyValue('strength', StrengthList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductIngredientSubstance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'strength') then StrengthList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductIngredientSubstance.fhirType : string;
begin
  result := 'substance';
end;

function TFhirMedicinalProductIngredientSubstance.Link : TFhirMedicinalProductIngredientSubstance;
begin
  result := TFhirMedicinalProductIngredientSubstance(inherited Link);
end;

function TFhirMedicinalProductIngredientSubstance.Clone : TFhirMedicinalProductIngredientSubstance;
begin
  result := TFhirMedicinalProductIngredientSubstance(inherited Clone);
end;

function TFhirMedicinalProductIngredientSubstance.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductIngredientSubstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductIngredientSubstance)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductIngredientSubstance(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(strengthList, o.strengthList, true);
  end;
end;

function TFhirMedicinalProductIngredientSubstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FstrengthList);
end;

procedure TFhirMedicinalProductIngredientSubstance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('strength');
end;

{ TFhirMedicinalProductIngredientSubstance }

Procedure TFhirMedicinalProductIngredientSubstance.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirMedicinalProductIngredientSubstance.GetStrengthList : TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList;
begin
  if FStrengthList = nil then
    FStrengthList := TFhirMedicinalProductIngredientSpecifiedSubstanceStrengthList.Create;
  result := FStrengthList;
end;

Function TFhirMedicinalProductIngredientSubstance.GetHasStrengthList : boolean;
begin
  result := (FStrengthList <> nil) and (FStrengthList.count > 0);
end;

function TFhirMedicinalProductIngredientSubstance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FstrengthList.sizeInBytes);
end;

{ TFhirMedicinalProductIngredientSubstanceListEnumerator }

Constructor TFhirMedicinalProductIngredientSubstanceListEnumerator.Create(list : TFhirMedicinalProductIngredientSubstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductIngredientSubstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductIngredientSubstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductIngredientSubstanceListEnumerator.GetCurrent : TFhirMedicinalProductIngredientSubstance;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductIngredientSubstanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductIngredientSubstanceList }
procedure TFhirMedicinalProductIngredientSubstanceList.AddItem(value: TFhirMedicinalProductIngredientSubstance);
begin
  assert(value.ClassName = 'TFhirMedicinalProductIngredientSubstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductIngredientSubstance');
  add(value);
end;

function TFhirMedicinalProductIngredientSubstanceList.Append: TFhirMedicinalProductIngredientSubstance;
begin
  result := TFhirMedicinalProductIngredientSubstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductIngredientSubstanceList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductIngredientSubstanceList.GetEnumerator : TFhirMedicinalProductIngredientSubstanceListEnumerator;
begin
  result := TFhirMedicinalProductIngredientSubstanceListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductIngredientSubstanceList.Clone: TFhirMedicinalProductIngredientSubstanceList;
begin
  result := TFhirMedicinalProductIngredientSubstanceList(inherited Clone);
end;

function TFhirMedicinalProductIngredientSubstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductIngredientSubstanceList.GetItemN(index: Integer): TFhirMedicinalProductIngredientSubstance;
begin
  result := TFhirMedicinalProductIngredientSubstance(ObjectByIndex[index]);
end;

function TFhirMedicinalProductIngredientSubstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductIngredientSubstance;
end;
function TFhirMedicinalProductIngredientSubstanceList.IndexOf(value: TFhirMedicinalProductIngredientSubstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductIngredientSubstanceList.Insert(index: Integer): TFhirMedicinalProductIngredientSubstance;
begin
  result := TFhirMedicinalProductIngredientSubstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductIngredientSubstanceList.InsertItem(index: Integer; value: TFhirMedicinalProductIngredientSubstance);
begin
  assert(value is TFhirMedicinalProductIngredientSubstance);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductIngredientSubstanceList.Item(index: Integer): TFhirMedicinalProductIngredientSubstance;
begin
  result := TFhirMedicinalProductIngredientSubstance(ObjectByIndex[index]);
end;

function TFhirMedicinalProductIngredientSubstanceList.Link: TFhirMedicinalProductIngredientSubstanceList;
begin
  result := TFhirMedicinalProductIngredientSubstanceList(inherited Link);
end;

procedure TFhirMedicinalProductIngredientSubstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductIngredientSubstanceList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductIngredientSubstance);
begin
  assert(value is TFhirMedicinalProductIngredientSubstance);
  FhirMedicinalProductIngredientSubstances[index] := value;
end;

procedure TFhirMedicinalProductIngredientSubstanceList.SetItemN(index: Integer; value: TFhirMedicinalProductIngredientSubstance);
begin
  assert(value is TFhirMedicinalProductIngredientSubstance);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductIngredient }

constructor TFhirMedicinalProductIngredient.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductIngredient.Destroy;
begin
  FIdentifier.free;
  FRole.free;
  FAllergenicIndicator.free;
  FManufacturerList.Free;
  FSpecifiedSubstanceList.Free;
  FSubstance.free;
  inherited;
end;

function TFhirMedicinalProductIngredient.GetResourceType : TFhirResourceType;
begin
  result := frtMedicinalProductIngredient;
end;

procedure TFhirMedicinalProductIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirMedicinalProductIngredient(oSource).identifier.Clone;
  role := TFhirMedicinalProductIngredient(oSource).role.Clone;
  allergenicIndicatorElement := TFhirMedicinalProductIngredient(oSource).allergenicIndicatorElement.Clone;
  if (TFhirMedicinalProductIngredient(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList{TFhirOrganization}.Create;
    FManufacturerList.Assign(TFhirMedicinalProductIngredient(oSource).FManufacturerList);
  end;
  if (TFhirMedicinalProductIngredient(oSource).FSpecifiedSubstanceList = nil) then
  begin
    FSpecifiedSubstanceList.free;
    FSpecifiedSubstanceList := nil;
  end
  else
  begin
    if FSpecifiedSubstanceList = nil then
      FSpecifiedSubstanceList := TFhirMedicinalProductIngredientSpecifiedSubstanceList.Create;
    FSpecifiedSubstanceList.Assign(TFhirMedicinalProductIngredient(oSource).FSpecifiedSubstanceList);
  end;
  substance := TFhirMedicinalProductIngredient(oSource).substance.Clone;
end;

procedure TFhirMedicinalProductIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'allergenicIndicator') Then
     list.add(self.link, 'allergenicIndicator', FAllergenicIndicator.Link);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'specifiedSubstance') Then
    list.addAll(self, 'specifiedSubstance', FSpecifiedSubstanceList);
  if (child_name = 'substance') Then
     list.add(self.link, 'substance', FSubstance.Link);
end;

procedure TFhirMedicinalProductIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'allergenicIndicator', 'boolean', false, TFhirBoolean, FAllergenicIndicator.Link));{2}
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FManufacturerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'specifiedSubstance', '', true, TFhirMedicinalProductIngredientSpecifiedSubstance, FSpecifiedSubstanceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'substance', '', false, TFhirMedicinalProductIngredientSubstance, FSubstance.Link));{2}
end;

function TFhirMedicinalProductIngredient.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'allergenicIndicator') then
  begin
    AllergenicIndicatorElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else if (propName = 'specifiedSubstance') then
  begin
    SpecifiedSubstanceList.add(propValue as TFhirMedicinalProductIngredientSpecifiedSubstance){2a};
    result := propValue;
  end
  else if (propName = 'substance') then
  begin
    Substance := propValue as TFhirMedicinalProductIngredientSubstance{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedicinalProductIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else if (propName = 'specifiedSubstance') then SpecifiedSubstanceList.insertItem(index, propValue as TFhirMedicinalProductIngredientSpecifiedSubstance){2a}
  else inherited;
end;

function TFhirMedicinalProductIngredient.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'allergenicIndicator') then result := TFhirBoolean.create() {5b}
  else if (propName = 'manufacturer') then result := ManufacturerList.new(){2}
  else if (propName = 'specifiedSubstance') then result := SpecifiedSubstanceList.new(){2}
  else if (propName = 'substance') then result := TFhirMedicinalProductIngredientSubstance.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'allergenicIndicator') then result := 'boolean'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'specifiedSubstance') then result := ''
  else if (propName = 'substance') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductIngredient.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'allergenicIndicator') then AllergenicIndicatorElement := nil
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value) {2}
  else if (propName = 'specifiedSubstance') then deletePropertyValue('specifiedSubstance', SpecifiedSubstanceList, value) {2}
  else if (propName = 'substance') then SubstanceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else if (propName = 'allergenicIndicator') then AllergenicIndicatorElement := asBoolean(new){5b}
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new) {2}
  else if (propName = 'specifiedSubstance') then replacePropertyValue('specifiedSubstance', SpecifiedSubstanceList, existing, new) {2}
  else if (propName = 'substance') then SubstanceElement := new as TFhirMedicinalProductIngredientSubstance{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'manufacturer') then ManufacturerList.move(source, destination){2a}
  else if (propName = 'specifiedSubstance') then SpecifiedSubstanceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductIngredient.fhirType : string;
begin
  result := 'MedicinalProductIngredient';
end;

function TFhirMedicinalProductIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FRole) and isEmptyProp(FAllergenicIndicator) and isEmptyProp(FmanufacturerList) and isEmptyProp(FspecifiedSubstanceList) and isEmptyProp(FSubstance);
end;

function TFhirMedicinalProductIngredient.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductIngredient)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductIngredient(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(roleElement, o.roleElement, true) and 
      compareDeep(allergenicIndicatorElement, o.allergenicIndicatorElement, true) and 
      compareDeep(manufacturerList, o.manufacturerList, true) and compareDeep(specifiedSubstanceList, o.specifiedSubstanceList, true) and 
      compareDeep(substanceElement, o.substanceElement, true);
  end;
end;

function TFhirMedicinalProductIngredient.Link : TFhirMedicinalProductIngredient;
begin
  result := TFhirMedicinalProductIngredient(inherited Link);
end;

function TFhirMedicinalProductIngredient.Clone : TFhirMedicinalProductIngredient;
begin
  result := TFhirMedicinalProductIngredient(inherited Clone);
end;

procedure TFhirMedicinalProductIngredient.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('role');
  fields.add('allergenicIndicator');
  fields.add('manufacturer');
  fields.add('specifiedSubstance');
  fields.add('substance');
end;

{ TFhirMedicinalProductIngredient }

Procedure TFhirMedicinalProductIngredient.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirMedicinalProductIngredient.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirMedicinalProductIngredient.SetAllergenicIndicator(value : TFhirBoolean);
begin
  FAllergenicIndicator.free;
  FAllergenicIndicator := value;
end;

Function TFhirMedicinalProductIngredient.GetAllergenicIndicatorST : Boolean;
begin
  if FAllergenicIndicator = nil then
    result := false
  else
    result := FAllergenicIndicator.value;
end;

Procedure TFhirMedicinalProductIngredient.SetAllergenicIndicatorST(value : Boolean);
begin
  if FAllergenicIndicator = nil then
    FAllergenicIndicator := TFhirBoolean.create;
  FAllergenicIndicator.value := value
end;

Function TFhirMedicinalProductIngredient.GetManufacturerList : TFhirReferenceList{TFhirOrganization};
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FManufacturerList;
end;

Function TFhirMedicinalProductIngredient.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

Function TFhirMedicinalProductIngredient.GetSpecifiedSubstanceList : TFhirMedicinalProductIngredientSpecifiedSubstanceList;
begin
  if FSpecifiedSubstanceList = nil then
    FSpecifiedSubstanceList := TFhirMedicinalProductIngredientSpecifiedSubstanceList.Create;
  result := FSpecifiedSubstanceList;
end;

Function TFhirMedicinalProductIngredient.GetHasSpecifiedSubstanceList : boolean;
begin
  result := (FSpecifiedSubstanceList <> nil) and (FSpecifiedSubstanceList.count > 0);
end;

Procedure TFhirMedicinalProductIngredient.SetSubstance(value : TFhirMedicinalProductIngredientSubstance);
begin
  FSubstance.free;
  FSubstance := value;
end;

function TFhirMedicinalProductIngredient.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FRole.sizeInBytes);
  inc(result, FAllergenicIndicator.sizeInBytes);
  inc(result, FmanufacturerList.sizeInBytes);
  inc(result, FspecifiedSubstanceList.sizeInBytes);
  inc(result, FSubstance.sizeInBytes);
end;

{ TFhirMedicinalProductIngredientListEnumerator }

Constructor TFhirMedicinalProductIngredientListEnumerator.Create(list : TFhirMedicinalProductIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductIngredientListEnumerator.GetCurrent : TFhirMedicinalProductIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductIngredientListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductIngredientList }
procedure TFhirMedicinalProductIngredientList.AddItem(value: TFhirMedicinalProductIngredient);
begin
  assert(value.ClassName = 'TFhirMedicinalProductIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductIngredient');
  add(value);
end;

function TFhirMedicinalProductIngredientList.Append: TFhirMedicinalProductIngredient;
begin
  result := TFhirMedicinalProductIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductIngredientList.GetEnumerator : TFhirMedicinalProductIngredientListEnumerator;
begin
  result := TFhirMedicinalProductIngredientListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductIngredientList.Clone: TFhirMedicinalProductIngredientList;
begin
  result := TFhirMedicinalProductIngredientList(inherited Clone);
end;

function TFhirMedicinalProductIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductIngredientList.GetItemN(index: Integer): TFhirMedicinalProductIngredient;
begin
  result := TFhirMedicinalProductIngredient(ObjectByIndex[index]);
end;

function TFhirMedicinalProductIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductIngredient;
end;
function TFhirMedicinalProductIngredientList.IndexOf(value: TFhirMedicinalProductIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductIngredientList.Insert(index: Integer): TFhirMedicinalProductIngredient;
begin
  result := TFhirMedicinalProductIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductIngredientList.InsertItem(index: Integer; value: TFhirMedicinalProductIngredient);
begin
  assert(value is TFhirMedicinalProductIngredient);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductIngredientList.Item(index: Integer): TFhirMedicinalProductIngredient;
begin
  result := TFhirMedicinalProductIngredient(ObjectByIndex[index]);
end;

function TFhirMedicinalProductIngredientList.Link: TFhirMedicinalProductIngredientList;
begin
  result := TFhirMedicinalProductIngredientList(inherited Link);
end;

procedure TFhirMedicinalProductIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductIngredientList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductIngredient);
begin
  assert(value is TFhirMedicinalProductIngredient);
  FhirMedicinalProductIngredients[index] := value;
end;

procedure TFhirMedicinalProductIngredientList.SetItemN(index: Integer; value: TFhirMedicinalProductIngredient);
begin
  assert(value is TFhirMedicinalProductIngredient);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICINALPRODUCTINGREDIENT}

{$IFDEF FHIR_MEDICINALPRODUCTINTERACTION}

{ TFhirMedicinalProductInteractionInteractant }

constructor TFhirMedicinalProductInteractionInteractant.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductInteractionInteractant.Destroy;
begin
  FItem.free;
  inherited;
end;

procedure TFhirMedicinalProductInteractionInteractant.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirMedicinalProductInteractionInteractant(oSource).item.Clone;
end;

procedure TFhirMedicinalProductInteractionInteractant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item[x]') or (child_name = 'item') Then
     list.add(self.link, 'item[x]', FItem.Link);
end;

procedure TFhirMedicinalProductInteractionInteractant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item[x]', 'Reference(MedicinalProduct)|CodeableConcept', false, TFhirType, FItem.Link));{2}
end;

function TFhirMedicinalProductInteractionInteractant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then
  begin
    Item := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductInteractionInteractant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductInteractionInteractant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Item'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductInteractionInteractant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item[x]') then result := 'Reference|CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductInteractionInteractant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then ItemElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductInteractionInteractant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then ItemElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductInteractionInteractant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductInteractionInteractant.fhirType : string;
begin
  result := 'interactant';
end;

function TFhirMedicinalProductInteractionInteractant.Link : TFhirMedicinalProductInteractionInteractant;
begin
  result := TFhirMedicinalProductInteractionInteractant(inherited Link);
end;

function TFhirMedicinalProductInteractionInteractant.Clone : TFhirMedicinalProductInteractionInteractant;
begin
  result := TFhirMedicinalProductInteractionInteractant(inherited Clone);
end;

function TFhirMedicinalProductInteractionInteractant.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductInteractionInteractant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductInteractionInteractant)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductInteractionInteractant(other);
    result := compareDeep(itemElement, o.itemElement, true);
  end;
end;

function TFhirMedicinalProductInteractionInteractant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem);
end;

procedure TFhirMedicinalProductInteractionInteractant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item[x]');
end;

{ TFhirMedicinalProductInteractionInteractant }

Procedure TFhirMedicinalProductInteractionInteractant.SetItem(value : TFhirType);
begin
  FItem.free;
  FItem := value;
end;

function TFhirMedicinalProductInteractionInteractant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItem.sizeInBytes);
end;

{ TFhirMedicinalProductInteractionInteractantListEnumerator }

Constructor TFhirMedicinalProductInteractionInteractantListEnumerator.Create(list : TFhirMedicinalProductInteractionInteractantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductInteractionInteractantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductInteractionInteractantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductInteractionInteractantListEnumerator.GetCurrent : TFhirMedicinalProductInteractionInteractant;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductInteractionInteractantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductInteractionInteractantList }
procedure TFhirMedicinalProductInteractionInteractantList.AddItem(value: TFhirMedicinalProductInteractionInteractant);
begin
  assert(value.ClassName = 'TFhirMedicinalProductInteractionInteractant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductInteractionInteractant');
  add(value);
end;

function TFhirMedicinalProductInteractionInteractantList.Append: TFhirMedicinalProductInteractionInteractant;
begin
  result := TFhirMedicinalProductInteractionInteractant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductInteractionInteractantList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductInteractionInteractantList.GetEnumerator : TFhirMedicinalProductInteractionInteractantListEnumerator;
begin
  result := TFhirMedicinalProductInteractionInteractantListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductInteractionInteractantList.Clone: TFhirMedicinalProductInteractionInteractantList;
begin
  result := TFhirMedicinalProductInteractionInteractantList(inherited Clone);
end;

function TFhirMedicinalProductInteractionInteractantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductInteractionInteractantList.GetItemN(index: Integer): TFhirMedicinalProductInteractionInteractant;
begin
  result := TFhirMedicinalProductInteractionInteractant(ObjectByIndex[index]);
end;

function TFhirMedicinalProductInteractionInteractantList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductInteractionInteractant;
end;
function TFhirMedicinalProductInteractionInteractantList.IndexOf(value: TFhirMedicinalProductInteractionInteractant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductInteractionInteractantList.Insert(index: Integer): TFhirMedicinalProductInteractionInteractant;
begin
  result := TFhirMedicinalProductInteractionInteractant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductInteractionInteractantList.InsertItem(index: Integer; value: TFhirMedicinalProductInteractionInteractant);
begin
  assert(value is TFhirMedicinalProductInteractionInteractant);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductInteractionInteractantList.Item(index: Integer): TFhirMedicinalProductInteractionInteractant;
begin
  result := TFhirMedicinalProductInteractionInteractant(ObjectByIndex[index]);
end;

function TFhirMedicinalProductInteractionInteractantList.Link: TFhirMedicinalProductInteractionInteractantList;
begin
  result := TFhirMedicinalProductInteractionInteractantList(inherited Link);
end;

procedure TFhirMedicinalProductInteractionInteractantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductInteractionInteractantList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductInteractionInteractant);
begin
  assert(value is TFhirMedicinalProductInteractionInteractant);
  FhirMedicinalProductInteractionInteractants[index] := value;
end;

procedure TFhirMedicinalProductInteractionInteractantList.SetItemN(index: Integer; value: TFhirMedicinalProductInteractionInteractant);
begin
  assert(value is TFhirMedicinalProductInteractionInteractant);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductInteraction }

constructor TFhirMedicinalProductInteraction.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductInteraction.Destroy;
begin
  FSubjectList.Free;
  FDescription.free;
  FInteractantList.Free;
  FType_.free;
  FEffect.free;
  FIncidence.free;
  FManagement.free;
  inherited;
end;

function TFhirMedicinalProductInteraction.GetResourceType : TFhirResourceType;
begin
  result := frtMedicinalProductInteraction;
end;

procedure TFhirMedicinalProductInteraction.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicinalProductInteraction(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirReferenceList{TFhirMedicinalProduct}.Create;
    FSubjectList.Assign(TFhirMedicinalProductInteraction(oSource).FSubjectList);
  end;
  descriptionElement := TFhirMedicinalProductInteraction(oSource).descriptionElement.Clone;
  if (TFhirMedicinalProductInteraction(oSource).FInteractantList = nil) then
  begin
    FInteractantList.free;
    FInteractantList := nil;
  end
  else
  begin
    if FInteractantList = nil then
      FInteractantList := TFhirMedicinalProductInteractionInteractantList.Create;
    FInteractantList.Assign(TFhirMedicinalProductInteraction(oSource).FInteractantList);
  end;
  type_ := TFhirMedicinalProductInteraction(oSource).type_.Clone;
  effect := TFhirMedicinalProductInteraction(oSource).effect.Clone;
  incidence := TFhirMedicinalProductInteraction(oSource).incidence.Clone;
  management := TFhirMedicinalProductInteraction(oSource).management.Clone;
end;

procedure TFhirMedicinalProductInteraction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'interactant') Then
    list.addAll(self, 'interactant', FInteractantList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'effect') Then
     list.add(self.link, 'effect', FEffect.Link);
  if (child_name = 'incidence') Then
     list.add(self.link, 'incidence', FIncidence.Link);
  if (child_name = 'management') Then
     list.add(self.link, 'management', FManagement.Link);
end;

procedure TFhirMedicinalProductInteraction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(MedicinalProduct)', true, TFhirReference{TFhirMedicinalProduct}, FSubjectList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'interactant', '', true, TFhirMedicinalProductInteractionInteractant, FInteractantList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effect', 'CodeableConcept', false, TFhirCodeableConcept, FEffect.Link));{2}
  oList.add(TFHIRProperty.create(self, 'incidence', 'CodeableConcept', false, TFhirCodeableConcept, FIncidence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'management', 'CodeableConcept', false, TFhirCodeableConcept, FManagement.Link));{2}
end;

function TFhirMedicinalProductInteraction.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirReference{TFhirMedicinalProduct}){2a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'interactant') then
  begin
    InteractantList.add(propValue as TFhirMedicinalProductInteractionInteractant){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'effect') then
  begin
    Effect := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'incidence') then
  begin
    Incidence := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'management') then
  begin
    Management := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedicinalProductInteraction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirReference{TFhirMedicinalProduct}){2a}
  else if (propName = 'interactant') then InteractantList.insertItem(index, propValue as TFhirMedicinalProductInteractionInteractant){2a}
  else inherited;
end;

function TFhirMedicinalProductInteraction.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'subject') then result := SubjectList.new(){2}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'interactant') then result := InteractantList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'effect') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'incidence') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'management') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductInteraction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'subject') then result := 'Reference'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'interactant') then result := ''
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'effect') then result := 'CodeableConcept'
  else if (propName = 'incidence') then result := 'CodeableConcept'
  else if (propName = 'management') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductInteraction.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value) {2}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'interactant') then deletePropertyValue('interactant', InteractantList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'effect') then EffectElement := nil
  else if (propName = 'incidence') then IncidenceElement := nil
  else if (propName = 'management') then ManagementElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductInteraction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new) {2}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'interactant') then replacePropertyValue('interactant', InteractantList, existing, new) {2}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'effect') then EffectElement := new as TFhirCodeableConcept{4}
  else if (propName = 'incidence') then IncidenceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'management') then ManagementElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductInteraction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'subject') then SubjectList.move(source, destination){2a}
  else if (propName = 'interactant') then InteractantList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductInteraction.fhirType : string;
begin
  result := 'MedicinalProductInteraction';
end;

function TFhirMedicinalProductInteraction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FsubjectList) and isEmptyProp(FDescription) and isEmptyProp(FinteractantList) and isEmptyProp(FType_) and isEmptyProp(FEffect) and isEmptyProp(FIncidence) and isEmptyProp(FManagement);
end;

function TFhirMedicinalProductInteraction.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductInteraction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductInteraction)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductInteraction(other);
    result := compareDeep(subjectList, o.subjectList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(interactantList, o.interactantList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(effectElement, o.effectElement, true) and compareDeep(incidenceElement, o.incidenceElement, true) and 
      compareDeep(managementElement, o.managementElement, true);
  end;
end;

function TFhirMedicinalProductInteraction.Link : TFhirMedicinalProductInteraction;
begin
  result := TFhirMedicinalProductInteraction(inherited Link);
end;

function TFhirMedicinalProductInteraction.Clone : TFhirMedicinalProductInteraction;
begin
  result := TFhirMedicinalProductInteraction(inherited Clone);
end;

procedure TFhirMedicinalProductInteraction.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('subject');
  fields.add('description');
  fields.add('interactant');
  fields.add('type');
  fields.add('effect');
  fields.add('incidence');
  fields.add('management');
end;

{ TFhirMedicinalProductInteraction }

Function TFhirMedicinalProductInteraction.GetSubjectList : TFhirReferenceList{TFhirMedicinalProduct};
begin
  if FSubjectList = nil then
    FSubjectList := TFhirReferenceList{TFhirMedicinalProduct}.Create;
  result := FSubjectList;
end;

Function TFhirMedicinalProductInteraction.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

Procedure TFhirMedicinalProductInteraction.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirMedicinalProductInteraction.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirMedicinalProductInteraction.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirMedicinalProductInteraction.GetInteractantList : TFhirMedicinalProductInteractionInteractantList;
begin
  if FInteractantList = nil then
    FInteractantList := TFhirMedicinalProductInteractionInteractantList.Create;
  result := FInteractantList;
end;

Function TFhirMedicinalProductInteraction.GetHasInteractantList : boolean;
begin
  result := (FInteractantList <> nil) and (FInteractantList.count > 0);
end;

Procedure TFhirMedicinalProductInteraction.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirMedicinalProductInteraction.SetEffect(value : TFhirCodeableConcept);
begin
  FEffect.free;
  FEffect := value;
end;

Procedure TFhirMedicinalProductInteraction.SetIncidence(value : TFhirCodeableConcept);
begin
  FIncidence.free;
  FIncidence := value;
end;

Procedure TFhirMedicinalProductInteraction.SetManagement(value : TFhirCodeableConcept);
begin
  FManagement.free;
  FManagement := value;
end;

function TFhirMedicinalProductInteraction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FsubjectList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FinteractantList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FEffect.sizeInBytes);
  inc(result, FIncidence.sizeInBytes);
  inc(result, FManagement.sizeInBytes);
end;

{ TFhirMedicinalProductInteractionListEnumerator }

Constructor TFhirMedicinalProductInteractionListEnumerator.Create(list : TFhirMedicinalProductInteractionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductInteractionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductInteractionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductInteractionListEnumerator.GetCurrent : TFhirMedicinalProductInteraction;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductInteractionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductInteractionList }
procedure TFhirMedicinalProductInteractionList.AddItem(value: TFhirMedicinalProductInteraction);
begin
  assert(value.ClassName = 'TFhirMedicinalProductInteraction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductInteraction');
  add(value);
end;

function TFhirMedicinalProductInteractionList.Append: TFhirMedicinalProductInteraction;
begin
  result := TFhirMedicinalProductInteraction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductInteractionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductInteractionList.GetEnumerator : TFhirMedicinalProductInteractionListEnumerator;
begin
  result := TFhirMedicinalProductInteractionListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductInteractionList.Clone: TFhirMedicinalProductInteractionList;
begin
  result := TFhirMedicinalProductInteractionList(inherited Clone);
end;

function TFhirMedicinalProductInteractionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductInteractionList.GetItemN(index: Integer): TFhirMedicinalProductInteraction;
begin
  result := TFhirMedicinalProductInteraction(ObjectByIndex[index]);
end;

function TFhirMedicinalProductInteractionList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductInteraction;
end;
function TFhirMedicinalProductInteractionList.IndexOf(value: TFhirMedicinalProductInteraction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductInteractionList.Insert(index: Integer): TFhirMedicinalProductInteraction;
begin
  result := TFhirMedicinalProductInteraction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductInteractionList.InsertItem(index: Integer; value: TFhirMedicinalProductInteraction);
begin
  assert(value is TFhirMedicinalProductInteraction);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductInteractionList.Item(index: Integer): TFhirMedicinalProductInteraction;
begin
  result := TFhirMedicinalProductInteraction(ObjectByIndex[index]);
end;

function TFhirMedicinalProductInteractionList.Link: TFhirMedicinalProductInteractionList;
begin
  result := TFhirMedicinalProductInteractionList(inherited Link);
end;

procedure TFhirMedicinalProductInteractionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductInteractionList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductInteraction);
begin
  assert(value is TFhirMedicinalProductInteraction);
  FhirMedicinalProductInteractions[index] := value;
end;

procedure TFhirMedicinalProductInteractionList.SetItemN(index: Integer; value: TFhirMedicinalProductInteraction);
begin
  assert(value is TFhirMedicinalProductInteraction);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICINALPRODUCTINTERACTION}

{$IFDEF FHIR_MEDICINALPRODUCTMANUFACTURED}

{ TFhirMedicinalProductManufactured }

constructor TFhirMedicinalProductManufactured.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductManufactured.Destroy;
begin
  FManufacturedDoseForm.free;
  FUnitOfPresentation.free;
  FQuantity.free;
  FManufacturerList.Free;
  FIngredientList.Free;
  FPhysicalCharacteristics.free;
  FOtherCharacteristicsList.Free;
  inherited;
end;

function TFhirMedicinalProductManufactured.GetResourceType : TFhirResourceType;
begin
  result := frtMedicinalProductManufactured;
end;

procedure TFhirMedicinalProductManufactured.Assign(oSource : TFslObject);
begin
  inherited;
  manufacturedDoseForm := TFhirMedicinalProductManufactured(oSource).manufacturedDoseForm.Clone;
  unitOfPresentation := TFhirMedicinalProductManufactured(oSource).unitOfPresentation.Clone;
  quantity := TFhirMedicinalProductManufactured(oSource).quantity.Clone;
  if (TFhirMedicinalProductManufactured(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList{TFhirOrganization}.Create;
    FManufacturerList.Assign(TFhirMedicinalProductManufactured(oSource).FManufacturerList);
  end;
  if (TFhirMedicinalProductManufactured(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirReferenceList{TFhirMedicinalProductIngredient}.Create;
    FIngredientList.Assign(TFhirMedicinalProductManufactured(oSource).FIngredientList);
  end;
  physicalCharacteristics := TFhirMedicinalProductManufactured(oSource).physicalCharacteristics.Clone;
  if (TFhirMedicinalProductManufactured(oSource).FOtherCharacteristicsList = nil) then
  begin
    FOtherCharacteristicsList.free;
    FOtherCharacteristicsList := nil;
  end
  else
  begin
    if FOtherCharacteristicsList = nil then
      FOtherCharacteristicsList := TFhirCodeableConceptList.Create;
    FOtherCharacteristicsList.Assign(TFhirMedicinalProductManufactured(oSource).FOtherCharacteristicsList);
  end;
end;

procedure TFhirMedicinalProductManufactured.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'manufacturedDoseForm') Then
     list.add(self.link, 'manufacturedDoseForm', FManufacturedDoseForm.Link);
  if (child_name = 'unitOfPresentation') Then
     list.add(self.link, 'unitOfPresentation', FUnitOfPresentation.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'physicalCharacteristics') Then
     list.add(self.link, 'physicalCharacteristics', FPhysicalCharacteristics.Link);
  if (child_name = 'otherCharacteristics') Then
    list.addAll(self, 'otherCharacteristics', FOtherCharacteristicsList);
end;

procedure TFhirMedicinalProductManufactured.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'manufacturedDoseForm', 'CodeableConcept', false, TFhirCodeableConcept, FManufacturedDoseForm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitOfPresentation', 'CodeableConcept', false, TFhirCodeableConcept, FUnitOfPresentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FManufacturerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'ingredient', 'Reference(MedicinalProductIngredient)', true, TFhirReference{TFhirMedicinalProductIngredient}, FIngredientList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'physicalCharacteristics', 'ProdCharacteristic', false, TFhirProdCharacteristic, FPhysicalCharacteristics.Link));{2}
  oList.add(TFHIRProperty.create(self, 'otherCharacteristics', 'CodeableConcept', true, TFhirCodeableConcept, FOtherCharacteristicsList.Link)){3};
end;

function TFhirMedicinalProductManufactured.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'manufacturedDoseForm') then
  begin
    ManufacturedDoseForm := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'unitOfPresentation') then
  begin
    UnitOfPresentation := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirReference{TFhirMedicinalProductIngredient}){2a};
    result := propValue;
  end
  else if (propName = 'physicalCharacteristics') then
  begin
    PhysicalCharacteristics := propValue as TFhirProdCharacteristic{4b};
    result := propValue;
  end
  else if (propName = 'otherCharacteristics') then
  begin
    OtherCharacteristicsList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedicinalProductManufactured.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirReference{TFhirMedicinalProductIngredient}){2a}
  else if (propName = 'otherCharacteristics') then OtherCharacteristicsList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirMedicinalProductManufactured.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'manufacturedDoseForm') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'unitOfPresentation') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'manufacturer') then result := ManufacturerList.new(){2}
  else if (propName = 'ingredient') then result := IngredientList.new(){2}
  else if (propName = 'physicalCharacteristics') then result := TFhirProdCharacteristic.create(){4b}
  else if (propName = 'otherCharacteristics') then result := OtherCharacteristicsList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductManufactured.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'manufacturedDoseForm') then result := 'CodeableConcept'
  else if (propName = 'unitOfPresentation') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'ingredient') then result := 'Reference'
  else if (propName = 'physicalCharacteristics') then result := 'ProdCharacteristic'
  else if (propName = 'otherCharacteristics') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductManufactured.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'manufacturedDoseForm') then ManufacturedDoseFormElement := nil
  else if (propName = 'unitOfPresentation') then UnitOfPresentationElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value) {2}
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value) {2}
  else if (propName = 'physicalCharacteristics') then PhysicalCharacteristicsElement := nil
  else if (propName = 'otherCharacteristics') then deletePropertyValue('otherCharacteristics', OtherCharacteristicsList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductManufactured.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'manufacturedDoseForm') then ManufacturedDoseFormElement := new as TFhirCodeableConcept{4}
  else if (propName = 'unitOfPresentation') then UnitOfPresentationElement := new as TFhirCodeableConcept{4}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new) {2}
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new) {2}
  else if (propName = 'physicalCharacteristics') then PhysicalCharacteristicsElement := new as TFhirProdCharacteristic{4}
  else if (propName = 'otherCharacteristics') then replacePropertyValue('otherCharacteristics', OtherCharacteristicsList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductManufactured.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'manufacturer') then ManufacturerList.move(source, destination){2a}
  else if (propName = 'ingredient') then IngredientList.move(source, destination){2a}
  else if (propName = 'otherCharacteristics') then OtherCharacteristicsList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductManufactured.fhirType : string;
begin
  result := 'MedicinalProductManufactured';
end;

function TFhirMedicinalProductManufactured.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FManufacturedDoseForm) and isEmptyProp(FUnitOfPresentation) and isEmptyProp(FQuantity) and isEmptyProp(FmanufacturerList) and isEmptyProp(FingredientList) and isEmptyProp(FPhysicalCharacteristics) and isEmptyProp(FotherCharacteristicsList);
end;

function TFhirMedicinalProductManufactured.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductManufactured;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductManufactured)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductManufactured(other);
    result := compareDeep(manufacturedDoseFormElement, o.manufacturedDoseFormElement, true) and 
      compareDeep(unitOfPresentationElement, o.unitOfPresentationElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(manufacturerList, o.manufacturerList, true) and 
      compareDeep(ingredientList, o.ingredientList, true) and compareDeep(physicalCharacteristicsElement, o.physicalCharacteristicsElement, true) and 
      compareDeep(otherCharacteristicsList, o.otherCharacteristicsList, true);
  end;
end;

function TFhirMedicinalProductManufactured.Link : TFhirMedicinalProductManufactured;
begin
  result := TFhirMedicinalProductManufactured(inherited Link);
end;

function TFhirMedicinalProductManufactured.Clone : TFhirMedicinalProductManufactured;
begin
  result := TFhirMedicinalProductManufactured(inherited Clone);
end;

procedure TFhirMedicinalProductManufactured.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('manufacturedDoseForm');
  fields.add('unitOfPresentation');
  fields.add('quantity');
  fields.add('manufacturer');
  fields.add('ingredient');
  fields.add('physicalCharacteristics');
  fields.add('otherCharacteristics');
end;

{ TFhirMedicinalProductManufactured }

Procedure TFhirMedicinalProductManufactured.SetManufacturedDoseForm(value : TFhirCodeableConcept);
begin
  FManufacturedDoseForm.free;
  FManufacturedDoseForm := value;
end;

Procedure TFhirMedicinalProductManufactured.SetUnitOfPresentation(value : TFhirCodeableConcept);
begin
  FUnitOfPresentation.free;
  FUnitOfPresentation := value;
end;

Procedure TFhirMedicinalProductManufactured.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Function TFhirMedicinalProductManufactured.GetManufacturerList : TFhirReferenceList{TFhirOrganization};
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FManufacturerList;
end;

Function TFhirMedicinalProductManufactured.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

Function TFhirMedicinalProductManufactured.GetIngredientList : TFhirReferenceList{TFhirMedicinalProductIngredient};
begin
  if FIngredientList = nil then
    FIngredientList := TFhirReferenceList{TFhirMedicinalProductIngredient}.Create;
  result := FIngredientList;
end;

Function TFhirMedicinalProductManufactured.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

Procedure TFhirMedicinalProductManufactured.SetPhysicalCharacteristics(value : TFhirProdCharacteristic);
begin
  FPhysicalCharacteristics.free;
  FPhysicalCharacteristics := value;
end;

Function TFhirMedicinalProductManufactured.GetOtherCharacteristicsList : TFhirCodeableConceptList;
begin
  if FOtherCharacteristicsList = nil then
    FOtherCharacteristicsList := TFhirCodeableConceptList.Create;
  result := FOtherCharacteristicsList;
end;

Function TFhirMedicinalProductManufactured.GetHasOtherCharacteristicsList : boolean;
begin
  result := (FOtherCharacteristicsList <> nil) and (FOtherCharacteristicsList.count > 0);
end;

function TFhirMedicinalProductManufactured.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FManufacturedDoseForm.sizeInBytes);
  inc(result, FUnitOfPresentation.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FmanufacturerList.sizeInBytes);
  inc(result, FingredientList.sizeInBytes);
  inc(result, FPhysicalCharacteristics.sizeInBytes);
  inc(result, FotherCharacteristicsList.sizeInBytes);
end;

{ TFhirMedicinalProductManufacturedListEnumerator }

Constructor TFhirMedicinalProductManufacturedListEnumerator.Create(list : TFhirMedicinalProductManufacturedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductManufacturedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductManufacturedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductManufacturedListEnumerator.GetCurrent : TFhirMedicinalProductManufactured;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductManufacturedListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductManufacturedList }
procedure TFhirMedicinalProductManufacturedList.AddItem(value: TFhirMedicinalProductManufactured);
begin
  assert(value.ClassName = 'TFhirMedicinalProductManufactured', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductManufactured');
  add(value);
end;

function TFhirMedicinalProductManufacturedList.Append: TFhirMedicinalProductManufactured;
begin
  result := TFhirMedicinalProductManufactured.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductManufacturedList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductManufacturedList.GetEnumerator : TFhirMedicinalProductManufacturedListEnumerator;
begin
  result := TFhirMedicinalProductManufacturedListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductManufacturedList.Clone: TFhirMedicinalProductManufacturedList;
begin
  result := TFhirMedicinalProductManufacturedList(inherited Clone);
end;

function TFhirMedicinalProductManufacturedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductManufacturedList.GetItemN(index: Integer): TFhirMedicinalProductManufactured;
begin
  result := TFhirMedicinalProductManufactured(ObjectByIndex[index]);
end;

function TFhirMedicinalProductManufacturedList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductManufactured;
end;
function TFhirMedicinalProductManufacturedList.IndexOf(value: TFhirMedicinalProductManufactured): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductManufacturedList.Insert(index: Integer): TFhirMedicinalProductManufactured;
begin
  result := TFhirMedicinalProductManufactured.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductManufacturedList.InsertItem(index: Integer; value: TFhirMedicinalProductManufactured);
begin
  assert(value is TFhirMedicinalProductManufactured);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductManufacturedList.Item(index: Integer): TFhirMedicinalProductManufactured;
begin
  result := TFhirMedicinalProductManufactured(ObjectByIndex[index]);
end;

function TFhirMedicinalProductManufacturedList.Link: TFhirMedicinalProductManufacturedList;
begin
  result := TFhirMedicinalProductManufacturedList(inherited Link);
end;

procedure TFhirMedicinalProductManufacturedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductManufacturedList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductManufactured);
begin
  assert(value is TFhirMedicinalProductManufactured);
  FhirMedicinalProductManufactureds[index] := value;
end;

procedure TFhirMedicinalProductManufacturedList.SetItemN(index: Integer; value: TFhirMedicinalProductManufactured);
begin
  assert(value is TFhirMedicinalProductManufactured);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICINALPRODUCTMANUFACTURED}

{$IFDEF FHIR_MEDICINALPRODUCTPACKAGED}

{ TFhirMedicinalProductPackagedBatchIdentifier }

constructor TFhirMedicinalProductPackagedBatchIdentifier.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductPackagedBatchIdentifier.Destroy;
begin
  FOuterPackaging.free;
  FImmediatePackaging.free;
  inherited;
end;

procedure TFhirMedicinalProductPackagedBatchIdentifier.Assign(oSource : TFslObject);
begin
  inherited;
  outerPackaging := TFhirMedicinalProductPackagedBatchIdentifier(oSource).outerPackaging.Clone;
  immediatePackaging := TFhirMedicinalProductPackagedBatchIdentifier(oSource).immediatePackaging.Clone;
end;

procedure TFhirMedicinalProductPackagedBatchIdentifier.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'outerPackaging') Then
     list.add(self.link, 'outerPackaging', FOuterPackaging.Link);
  if (child_name = 'immediatePackaging') Then
     list.add(self.link, 'immediatePackaging', FImmediatePackaging.Link);
end;

procedure TFhirMedicinalProductPackagedBatchIdentifier.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'outerPackaging', 'Identifier', false, TFhirIdentifier, FOuterPackaging.Link));{2}
  oList.add(TFHIRProperty.create(self, 'immediatePackaging', 'Identifier', false, TFhirIdentifier, FImmediatePackaging.Link));{2}
end;

function TFhirMedicinalProductPackagedBatchIdentifier.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'outerPackaging') then
  begin
    OuterPackaging := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'immediatePackaging') then
  begin
    ImmediatePackaging := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductPackagedBatchIdentifier.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductPackagedBatchIdentifier.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'outerPackaging') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'immediatePackaging') then result := TFhirIdentifier.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductPackagedBatchIdentifier.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'outerPackaging') then result := 'Identifier'
  else if (propName = 'immediatePackaging') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductPackagedBatchIdentifier.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'outerPackaging') then OuterPackagingElement := nil
  else if (propName = 'immediatePackaging') then ImmediatePackagingElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductPackagedBatchIdentifier.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'outerPackaging') then OuterPackagingElement := new as TFhirIdentifier{4}
  else if (propName = 'immediatePackaging') then ImmediatePackagingElement := new as TFhirIdentifier{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductPackagedBatchIdentifier.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductPackagedBatchIdentifier.fhirType : string;
begin
  result := 'batchIdentifier';
end;

function TFhirMedicinalProductPackagedBatchIdentifier.Link : TFhirMedicinalProductPackagedBatchIdentifier;
begin
  result := TFhirMedicinalProductPackagedBatchIdentifier(inherited Link);
end;

function TFhirMedicinalProductPackagedBatchIdentifier.Clone : TFhirMedicinalProductPackagedBatchIdentifier;
begin
  result := TFhirMedicinalProductPackagedBatchIdentifier(inherited Clone);
end;

function TFhirMedicinalProductPackagedBatchIdentifier.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductPackagedBatchIdentifier;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductPackagedBatchIdentifier)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductPackagedBatchIdentifier(other);
    result := compareDeep(outerPackagingElement, o.outerPackagingElement, true) and 
      compareDeep(immediatePackagingElement, o.immediatePackagingElement, true);
  end;
end;

function TFhirMedicinalProductPackagedBatchIdentifier.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOuterPackaging) and isEmptyProp(FImmediatePackaging);
end;

procedure TFhirMedicinalProductPackagedBatchIdentifier.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('outerPackaging');
  fields.add('immediatePackaging');
end;

{ TFhirMedicinalProductPackagedBatchIdentifier }

Procedure TFhirMedicinalProductPackagedBatchIdentifier.SetOuterPackaging(value : TFhirIdentifier);
begin
  FOuterPackaging.free;
  FOuterPackaging := value;
end;

Procedure TFhirMedicinalProductPackagedBatchIdentifier.SetImmediatePackaging(value : TFhirIdentifier);
begin
  FImmediatePackaging.free;
  FImmediatePackaging := value;
end;

function TFhirMedicinalProductPackagedBatchIdentifier.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOuterPackaging.sizeInBytes);
  inc(result, FImmediatePackaging.sizeInBytes);
end;

{ TFhirMedicinalProductPackagedBatchIdentifierListEnumerator }

Constructor TFhirMedicinalProductPackagedBatchIdentifierListEnumerator.Create(list : TFhirMedicinalProductPackagedBatchIdentifierList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductPackagedBatchIdentifierListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductPackagedBatchIdentifierListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductPackagedBatchIdentifierListEnumerator.GetCurrent : TFhirMedicinalProductPackagedBatchIdentifier;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductPackagedBatchIdentifierListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductPackagedBatchIdentifierList }
procedure TFhirMedicinalProductPackagedBatchIdentifierList.AddItem(value: TFhirMedicinalProductPackagedBatchIdentifier);
begin
  assert(value.ClassName = 'TFhirMedicinalProductPackagedBatchIdentifier', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductPackagedBatchIdentifier');
  add(value);
end;

function TFhirMedicinalProductPackagedBatchIdentifierList.Append: TFhirMedicinalProductPackagedBatchIdentifier;
begin
  result := TFhirMedicinalProductPackagedBatchIdentifier.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductPackagedBatchIdentifierList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductPackagedBatchIdentifierList.GetEnumerator : TFhirMedicinalProductPackagedBatchIdentifierListEnumerator;
begin
  result := TFhirMedicinalProductPackagedBatchIdentifierListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductPackagedBatchIdentifierList.Clone: TFhirMedicinalProductPackagedBatchIdentifierList;
begin
  result := TFhirMedicinalProductPackagedBatchIdentifierList(inherited Clone);
end;

function TFhirMedicinalProductPackagedBatchIdentifierList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductPackagedBatchIdentifierList.GetItemN(index: Integer): TFhirMedicinalProductPackagedBatchIdentifier;
begin
  result := TFhirMedicinalProductPackagedBatchIdentifier(ObjectByIndex[index]);
end;

function TFhirMedicinalProductPackagedBatchIdentifierList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductPackagedBatchIdentifier;
end;
function TFhirMedicinalProductPackagedBatchIdentifierList.IndexOf(value: TFhirMedicinalProductPackagedBatchIdentifier): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductPackagedBatchIdentifierList.Insert(index: Integer): TFhirMedicinalProductPackagedBatchIdentifier;
begin
  result := TFhirMedicinalProductPackagedBatchIdentifier.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductPackagedBatchIdentifierList.InsertItem(index: Integer; value: TFhirMedicinalProductPackagedBatchIdentifier);
begin
  assert(value is TFhirMedicinalProductPackagedBatchIdentifier);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductPackagedBatchIdentifierList.Item(index: Integer): TFhirMedicinalProductPackagedBatchIdentifier;
begin
  result := TFhirMedicinalProductPackagedBatchIdentifier(ObjectByIndex[index]);
end;

function TFhirMedicinalProductPackagedBatchIdentifierList.Link: TFhirMedicinalProductPackagedBatchIdentifierList;
begin
  result := TFhirMedicinalProductPackagedBatchIdentifierList(inherited Link);
end;

procedure TFhirMedicinalProductPackagedBatchIdentifierList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductPackagedBatchIdentifierList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductPackagedBatchIdentifier);
begin
  assert(value is TFhirMedicinalProductPackagedBatchIdentifier);
  FhirMedicinalProductPackagedBatchIdentifiers[index] := value;
end;

procedure TFhirMedicinalProductPackagedBatchIdentifierList.SetItemN(index: Integer; value: TFhirMedicinalProductPackagedBatchIdentifier);
begin
  assert(value is TFhirMedicinalProductPackagedBatchIdentifier);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductPackagedPackageItem }

constructor TFhirMedicinalProductPackagedPackageItem.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductPackagedPackageItem.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FQuantity.free;
  FMaterialList.Free;
  FAlternateMaterialList.Free;
  FDeviceList.Free;
  FManufacturedItemList.Free;
  FPackageItemList.Free;
  FPhysicalCharacteristics.free;
  FOtherCharacteristicsList.Free;
  FShelfLifeStorageList.Free;
  FManufacturerList.Free;
  inherited;
end;

procedure TFhirMedicinalProductPackagedPackageItem.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicinalProductPackagedPackageItem(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicinalProductPackagedPackageItem(oSource).FIdentifierList);
  end;
  type_ := TFhirMedicinalProductPackagedPackageItem(oSource).type_.Clone;
  quantity := TFhirMedicinalProductPackagedPackageItem(oSource).quantity.Clone;
  if (TFhirMedicinalProductPackagedPackageItem(oSource).FMaterialList = nil) then
  begin
    FMaterialList.free;
    FMaterialList := nil;
  end
  else
  begin
    if FMaterialList = nil then
      FMaterialList := TFhirCodeableConceptList.Create;
    FMaterialList.Assign(TFhirMedicinalProductPackagedPackageItem(oSource).FMaterialList);
  end;
  if (TFhirMedicinalProductPackagedPackageItem(oSource).FAlternateMaterialList = nil) then
  begin
    FAlternateMaterialList.free;
    FAlternateMaterialList := nil;
  end
  else
  begin
    if FAlternateMaterialList = nil then
      FAlternateMaterialList := TFhirCodeableConceptList.Create;
    FAlternateMaterialList.Assign(TFhirMedicinalProductPackagedPackageItem(oSource).FAlternateMaterialList);
  end;
  if (TFhirMedicinalProductPackagedPackageItem(oSource).FDeviceList = nil) then
  begin
    FDeviceList.free;
    FDeviceList := nil;
  end
  else
  begin
    if FDeviceList = nil then
      FDeviceList := TFhirReferenceList{TFhirDeviceDefinition}.Create;
    FDeviceList.Assign(TFhirMedicinalProductPackagedPackageItem(oSource).FDeviceList);
  end;
  if (TFhirMedicinalProductPackagedPackageItem(oSource).FManufacturedItemList = nil) then
  begin
    FManufacturedItemList.free;
    FManufacturedItemList := nil;
  end
  else
  begin
    if FManufacturedItemList = nil then
      FManufacturedItemList := TFhirReferenceList{TFhirMedicinalProductManufactured}.Create;
    FManufacturedItemList.Assign(TFhirMedicinalProductPackagedPackageItem(oSource).FManufacturedItemList);
  end;
  if (TFhirMedicinalProductPackagedPackageItem(oSource).FPackageItemList = nil) then
  begin
    FPackageItemList.free;
    FPackageItemList := nil;
  end
  else
  begin
    if FPackageItemList = nil then
      FPackageItemList := TFhirMedicinalProductPackagedPackageItemList.Create;
    FPackageItemList.Assign(TFhirMedicinalProductPackagedPackageItem(oSource).FPackageItemList);
  end;
  physicalCharacteristics := TFhirMedicinalProductPackagedPackageItem(oSource).physicalCharacteristics.Clone;
  if (TFhirMedicinalProductPackagedPackageItem(oSource).FOtherCharacteristicsList = nil) then
  begin
    FOtherCharacteristicsList.free;
    FOtherCharacteristicsList := nil;
  end
  else
  begin
    if FOtherCharacteristicsList = nil then
      FOtherCharacteristicsList := TFhirCodeableConceptList.Create;
    FOtherCharacteristicsList.Assign(TFhirMedicinalProductPackagedPackageItem(oSource).FOtherCharacteristicsList);
  end;
  if (TFhirMedicinalProductPackagedPackageItem(oSource).FShelfLifeStorageList = nil) then
  begin
    FShelfLifeStorageList.free;
    FShelfLifeStorageList := nil;
  end
  else
  begin
    if FShelfLifeStorageList = nil then
      FShelfLifeStorageList := TFhirProductShelfLifeList.Create;
    FShelfLifeStorageList.Assign(TFhirMedicinalProductPackagedPackageItem(oSource).FShelfLifeStorageList);
  end;
  if (TFhirMedicinalProductPackagedPackageItem(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList{TFhirOrganization}.Create;
    FManufacturerList.Assign(TFhirMedicinalProductPackagedPackageItem(oSource).FManufacturerList);
  end;
end;

procedure TFhirMedicinalProductPackagedPackageItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'material') Then
    list.addAll(self, 'material', FMaterialList);
  if (child_name = 'alternateMaterial') Then
    list.addAll(self, 'alternateMaterial', FAlternateMaterialList);
  if (child_name = 'device') Then
    list.addAll(self, 'device', FDeviceList);
  if (child_name = 'manufacturedItem') Then
    list.addAll(self, 'manufacturedItem', FManufacturedItemList);
  if (child_name = 'packageItem') Then
    list.addAll(self, 'packageItem', FPackageItemList);
  if (child_name = 'physicalCharacteristics') Then
     list.add(self.link, 'physicalCharacteristics', FPhysicalCharacteristics.Link);
  if (child_name = 'otherCharacteristics') Then
    list.addAll(self, 'otherCharacteristics', FOtherCharacteristicsList);
  if (child_name = 'shelfLifeStorage') Then
    list.addAll(self, 'shelfLifeStorage', FShelfLifeStorageList);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
end;

procedure TFhirMedicinalProductPackagedPackageItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'material', 'CodeableConcept', true, TFhirCodeableConcept, FMaterialList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'alternateMaterial', 'CodeableConcept', true, TFhirCodeableConcept, FAlternateMaterialList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'device', 'Reference(DeviceDefinition)', true, TFhirReference{TFhirDeviceDefinition}, FDeviceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'manufacturedItem', 'Reference(MedicinalProductManufactured)', true, TFhirReference{TFhirMedicinalProductManufactured}, FManufacturedItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'packageItem', '@MedicinalProductPackaged.packageItem', true, TFhirMedicinalProductPackagedPackageItem, FPackageItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'physicalCharacteristics', 'ProdCharacteristic', false, TFhirProdCharacteristic, FPhysicalCharacteristics.Link));{2}
  oList.add(TFHIRProperty.create(self, 'otherCharacteristics', 'CodeableConcept', true, TFhirCodeableConcept, FOtherCharacteristicsList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'shelfLifeStorage', 'ProductShelfLife', true, TFhirProductShelfLife, FShelfLifeStorageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FManufacturerList.Link)){3};
end;

function TFhirMedicinalProductPackagedPackageItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'material') then
  begin
    MaterialList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'alternateMaterial') then
  begin
    AlternateMaterialList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    DeviceList.add(propValue as TFhirReference{TFhirDeviceDefinition}){2a};
    result := propValue;
  end
  else if (propName = 'manufacturedItem') then
  begin
    ManufacturedItemList.add(propValue as TFhirReference{TFhirMedicinalProductManufactured}){2a};
    result := propValue;
  end
  else if (propName = 'packageItem') then
  begin
    PackageItemList.add(propValue as TFhirMedicinalProductPackagedPackageItem){2a};
    result := propValue;
  end
  else if (propName = 'physicalCharacteristics') then
  begin
    PhysicalCharacteristics := propValue as TFhirProdCharacteristic{4b};
    result := propValue;
  end
  else if (propName = 'otherCharacteristics') then
  begin
    OtherCharacteristicsList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'shelfLifeStorage') then
  begin
    ShelfLifeStorageList.add(propValue as TFhirProductShelfLife){2a};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductPackagedPackageItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'material') then MaterialList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'alternateMaterial') then AlternateMaterialList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'device') then DeviceList.insertItem(index, propValue as TFhirReference{TFhirDeviceDefinition}){2a}
  else if (propName = 'manufacturedItem') then ManufacturedItemList.insertItem(index, propValue as TFhirReference{TFhirMedicinalProductManufactured}){2a}
  else if (propName = 'packageItem') then PackageItemList.insertItem(index, propValue as TFhirMedicinalProductPackagedPackageItem){2a}
  else if (propName = 'otherCharacteristics') then OtherCharacteristicsList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'shelfLifeStorage') then ShelfLifeStorageList.insertItem(index, propValue as TFhirProductShelfLife){2a}
  else if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else inherited;
end;

function TFhirMedicinalProductPackagedPackageItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'material') then result := MaterialList.new(){2}
  else if (propName = 'alternateMaterial') then result := AlternateMaterialList.new(){2}
  else if (propName = 'device') then result := DeviceList.new(){2}
  else if (propName = 'manufacturedItem') then result := ManufacturedItemList.new(){2}
  else if (propName = 'packageItem') then result := PackageItemList.new(){2}
  else if (propName = 'physicalCharacteristics') then result := TFhirProdCharacteristic.create(){4b}
  else if (propName = 'otherCharacteristics') then result := OtherCharacteristicsList.new(){2}
  else if (propName = 'shelfLifeStorage') then result := ShelfLifeStorageList.new(){2}
  else if (propName = 'manufacturer') then result := ManufacturerList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductPackagedPackageItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'material') then result := 'CodeableConcept'
  else if (propName = 'alternateMaterial') then result := 'CodeableConcept'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'manufacturedItem') then result := 'Reference'
  else if (propName = 'packageItem') then result := '@MedicinalProductPackaged.packageItem'
  else if (propName = 'physicalCharacteristics') then result := 'ProdCharacteristic'
  else if (propName = 'otherCharacteristics') then result := 'CodeableConcept'
  else if (propName = 'shelfLifeStorage') then result := 'ProductShelfLife'
  else if (propName = 'manufacturer') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductPackagedPackageItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'material') then deletePropertyValue('material', MaterialList, value) {2}
  else if (propName = 'alternateMaterial') then deletePropertyValue('alternateMaterial', AlternateMaterialList, value) {2}
  else if (propName = 'device') then deletePropertyValue('device', DeviceList, value) {2}
  else if (propName = 'manufacturedItem') then deletePropertyValue('manufacturedItem', ManufacturedItemList, value) {2}
  else if (propName = 'packageItem') then deletePropertyValue('packageItem', PackageItemList, value) {2}
  else if (propName = 'physicalCharacteristics') then PhysicalCharacteristicsElement := nil
  else if (propName = 'otherCharacteristics') then deletePropertyValue('otherCharacteristics', OtherCharacteristicsList, value) {2}
  else if (propName = 'shelfLifeStorage') then deletePropertyValue('shelfLifeStorage', ShelfLifeStorageList, value) {2}
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductPackagedPackageItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'material') then replacePropertyValue('material', MaterialList, existing, new) {2}
  else if (propName = 'alternateMaterial') then replacePropertyValue('alternateMaterial', AlternateMaterialList, existing, new) {2}
  else if (propName = 'device') then replacePropertyValue('device', DeviceList, existing, new) {2}
  else if (propName = 'manufacturedItem') then replacePropertyValue('manufacturedItem', ManufacturedItemList, existing, new) {2}
  else if (propName = 'packageItem') then replacePropertyValue('packageItem', PackageItemList, existing, new) {2}
  else if (propName = 'physicalCharacteristics') then PhysicalCharacteristicsElement := new as TFhirProdCharacteristic{4}
  else if (propName = 'otherCharacteristics') then replacePropertyValue('otherCharacteristics', OtherCharacteristicsList, existing, new) {2}
  else if (propName = 'shelfLifeStorage') then replacePropertyValue('shelfLifeStorage', ShelfLifeStorageList, existing, new) {2}
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductPackagedPackageItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'material') then MaterialList.move(source, destination){2a}
  else if (propName = 'alternateMaterial') then AlternateMaterialList.move(source, destination){2a}
  else if (propName = 'device') then DeviceList.move(source, destination){2a}
  else if (propName = 'manufacturedItem') then ManufacturedItemList.move(source, destination){2a}
  else if (propName = 'packageItem') then PackageItemList.move(source, destination){2a}
  else if (propName = 'otherCharacteristics') then OtherCharacteristicsList.move(source, destination){2a}
  else if (propName = 'shelfLifeStorage') then ShelfLifeStorageList.move(source, destination){2a}
  else if (propName = 'manufacturer') then ManufacturerList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductPackagedPackageItem.fhirType : string;
begin
  result := 'packageItem';
end;

function TFhirMedicinalProductPackagedPackageItem.Link : TFhirMedicinalProductPackagedPackageItem;
begin
  result := TFhirMedicinalProductPackagedPackageItem(inherited Link);
end;

function TFhirMedicinalProductPackagedPackageItem.Clone : TFhirMedicinalProductPackagedPackageItem;
begin
  result := TFhirMedicinalProductPackagedPackageItem(inherited Clone);
end;

function TFhirMedicinalProductPackagedPackageItem.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductPackagedPackageItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductPackagedPackageItem)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductPackagedPackageItem(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(materialList, o.materialList, true) and 
      compareDeep(alternateMaterialList, o.alternateMaterialList, true) and compareDeep(deviceList, o.deviceList, true) and 
      compareDeep(manufacturedItemList, o.manufacturedItemList, true) and compareDeep(packageItemList, o.packageItemList, true) and 
      compareDeep(physicalCharacteristicsElement, o.physicalCharacteristicsElement, true) and 
      compareDeep(otherCharacteristicsList, o.otherCharacteristicsList, true) and compareDeep(shelfLifeStorageList, o.shelfLifeStorageList, true) and 
      compareDeep(manufacturerList, o.manufacturerList, true);
  end;
end;

function TFhirMedicinalProductPackagedPackageItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FQuantity) and isEmptyProp(FmaterialList) and isEmptyProp(FalternateMaterialList) and isEmptyProp(FdeviceList) and isEmptyProp(FmanufacturedItemList) and isEmptyProp(FpackageItemList) and isEmptyProp(FPhysicalCharacteristics) and isEmptyProp(FotherCharacteristicsList) and isEmptyProp(FshelfLifeStorageList) and isEmptyProp(FmanufacturerList);
end;

procedure TFhirMedicinalProductPackagedPackageItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('quantity');
  fields.add('material');
  fields.add('alternateMaterial');
  fields.add('device');
  fields.add('manufacturedItem');
  fields.add('packageItem');
  fields.add('physicalCharacteristics');
  fields.add('otherCharacteristics');
  fields.add('shelfLifeStorage');
  fields.add('manufacturer');
end;

{ TFhirMedicinalProductPackagedPackageItem }

Function TFhirMedicinalProductPackagedPackageItem.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirMedicinalProductPackagedPackageItem.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirMedicinalProductPackagedPackageItem.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirMedicinalProductPackagedPackageItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Function TFhirMedicinalProductPackagedPackageItem.GetMaterialList : TFhirCodeableConceptList;
begin
  if FMaterialList = nil then
    FMaterialList := TFhirCodeableConceptList.Create;
  result := FMaterialList;
end;

Function TFhirMedicinalProductPackagedPackageItem.GetHasMaterialList : boolean;
begin
  result := (FMaterialList <> nil) and (FMaterialList.count > 0);
end;

Function TFhirMedicinalProductPackagedPackageItem.GetAlternateMaterialList : TFhirCodeableConceptList;
begin
  if FAlternateMaterialList = nil then
    FAlternateMaterialList := TFhirCodeableConceptList.Create;
  result := FAlternateMaterialList;
end;

Function TFhirMedicinalProductPackagedPackageItem.GetHasAlternateMaterialList : boolean;
begin
  result := (FAlternateMaterialList <> nil) and (FAlternateMaterialList.count > 0);
end;

Function TFhirMedicinalProductPackagedPackageItem.GetDeviceList : TFhirReferenceList{TFhirDeviceDefinition};
begin
  if FDeviceList = nil then
    FDeviceList := TFhirReferenceList{TFhirDeviceDefinition}.Create;
  result := FDeviceList;
end;

Function TFhirMedicinalProductPackagedPackageItem.GetHasDeviceList : boolean;
begin
  result := (FDeviceList <> nil) and (FDeviceList.count > 0);
end;

Function TFhirMedicinalProductPackagedPackageItem.GetManufacturedItemList : TFhirReferenceList{TFhirMedicinalProductManufactured};
begin
  if FManufacturedItemList = nil then
    FManufacturedItemList := TFhirReferenceList{TFhirMedicinalProductManufactured}.Create;
  result := FManufacturedItemList;
end;

Function TFhirMedicinalProductPackagedPackageItem.GetHasManufacturedItemList : boolean;
begin
  result := (FManufacturedItemList <> nil) and (FManufacturedItemList.count > 0);
end;

Function TFhirMedicinalProductPackagedPackageItem.GetPackageItemList : TFhirMedicinalProductPackagedPackageItemList;
begin
  if FPackageItemList = nil then
    FPackageItemList := TFhirMedicinalProductPackagedPackageItemList.Create;
  result := FPackageItemList;
end;

Function TFhirMedicinalProductPackagedPackageItem.GetHasPackageItemList : boolean;
begin
  result := (FPackageItemList <> nil) and (FPackageItemList.count > 0);
end;

Procedure TFhirMedicinalProductPackagedPackageItem.SetPhysicalCharacteristics(value : TFhirProdCharacteristic);
begin
  FPhysicalCharacteristics.free;
  FPhysicalCharacteristics := value;
end;

Function TFhirMedicinalProductPackagedPackageItem.GetOtherCharacteristicsList : TFhirCodeableConceptList;
begin
  if FOtherCharacteristicsList = nil then
    FOtherCharacteristicsList := TFhirCodeableConceptList.Create;
  result := FOtherCharacteristicsList;
end;

Function TFhirMedicinalProductPackagedPackageItem.GetHasOtherCharacteristicsList : boolean;
begin
  result := (FOtherCharacteristicsList <> nil) and (FOtherCharacteristicsList.count > 0);
end;

Function TFhirMedicinalProductPackagedPackageItem.GetShelfLifeStorageList : TFhirProductShelfLifeList;
begin
  if FShelfLifeStorageList = nil then
    FShelfLifeStorageList := TFhirProductShelfLifeList.Create;
  result := FShelfLifeStorageList;
end;

Function TFhirMedicinalProductPackagedPackageItem.GetHasShelfLifeStorageList : boolean;
begin
  result := (FShelfLifeStorageList <> nil) and (FShelfLifeStorageList.count > 0);
end;

Function TFhirMedicinalProductPackagedPackageItem.GetManufacturerList : TFhirReferenceList{TFhirOrganization};
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FManufacturerList;
end;

Function TFhirMedicinalProductPackagedPackageItem.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

function TFhirMedicinalProductPackagedPackageItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FmaterialList.sizeInBytes);
  inc(result, FalternateMaterialList.sizeInBytes);
  inc(result, FdeviceList.sizeInBytes);
  inc(result, FmanufacturedItemList.sizeInBytes);
  inc(result, FpackageItemList.sizeInBytes);
  inc(result, FPhysicalCharacteristics.sizeInBytes);
  inc(result, FotherCharacteristicsList.sizeInBytes);
  inc(result, FshelfLifeStorageList.sizeInBytes);
  inc(result, FmanufacturerList.sizeInBytes);
end;

{ TFhirMedicinalProductPackagedPackageItemListEnumerator }

Constructor TFhirMedicinalProductPackagedPackageItemListEnumerator.Create(list : TFhirMedicinalProductPackagedPackageItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductPackagedPackageItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductPackagedPackageItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductPackagedPackageItemListEnumerator.GetCurrent : TFhirMedicinalProductPackagedPackageItem;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductPackagedPackageItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductPackagedPackageItemList }
procedure TFhirMedicinalProductPackagedPackageItemList.AddItem(value: TFhirMedicinalProductPackagedPackageItem);
begin
  assert(value.ClassName = 'TFhirMedicinalProductPackagedPackageItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductPackagedPackageItem');
  add(value);
end;

function TFhirMedicinalProductPackagedPackageItemList.Append: TFhirMedicinalProductPackagedPackageItem;
begin
  result := TFhirMedicinalProductPackagedPackageItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductPackagedPackageItemList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductPackagedPackageItemList.GetEnumerator : TFhirMedicinalProductPackagedPackageItemListEnumerator;
begin
  result := TFhirMedicinalProductPackagedPackageItemListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductPackagedPackageItemList.Clone: TFhirMedicinalProductPackagedPackageItemList;
begin
  result := TFhirMedicinalProductPackagedPackageItemList(inherited Clone);
end;

function TFhirMedicinalProductPackagedPackageItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductPackagedPackageItemList.GetItemN(index: Integer): TFhirMedicinalProductPackagedPackageItem;
begin
  result := TFhirMedicinalProductPackagedPackageItem(ObjectByIndex[index]);
end;

function TFhirMedicinalProductPackagedPackageItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductPackagedPackageItem;
end;
function TFhirMedicinalProductPackagedPackageItemList.IndexOf(value: TFhirMedicinalProductPackagedPackageItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductPackagedPackageItemList.Insert(index: Integer): TFhirMedicinalProductPackagedPackageItem;
begin
  result := TFhirMedicinalProductPackagedPackageItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductPackagedPackageItemList.InsertItem(index: Integer; value: TFhirMedicinalProductPackagedPackageItem);
begin
  assert(value is TFhirMedicinalProductPackagedPackageItem);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductPackagedPackageItemList.Item(index: Integer): TFhirMedicinalProductPackagedPackageItem;
begin
  result := TFhirMedicinalProductPackagedPackageItem(ObjectByIndex[index]);
end;

function TFhirMedicinalProductPackagedPackageItemList.Link: TFhirMedicinalProductPackagedPackageItemList;
begin
  result := TFhirMedicinalProductPackagedPackageItemList(inherited Link);
end;

procedure TFhirMedicinalProductPackagedPackageItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductPackagedPackageItemList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductPackagedPackageItem);
begin
  assert(value is TFhirMedicinalProductPackagedPackageItem);
  FhirMedicinalProductPackagedPackageItems[index] := value;
end;

procedure TFhirMedicinalProductPackagedPackageItemList.SetItemN(index: Integer; value: TFhirMedicinalProductPackagedPackageItem);
begin
  assert(value is TFhirMedicinalProductPackagedPackageItem);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductPackaged }

constructor TFhirMedicinalProductPackaged.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductPackaged.Destroy;
begin
  FIdentifierList.Free;
  FSubjectList.Free;
  FDescription.free;
  FLegalStatusOfSupply.free;
  FMarketingStatusList.Free;
  FMarketingAuthorization.free;
  FManufacturerList.Free;
  FBatchIdentifierList.Free;
  FPackageItemList.Free;
  inherited;
end;

function TFhirMedicinalProductPackaged.GetResourceType : TFhirResourceType;
begin
  result := frtMedicinalProductPackaged;
end;

procedure TFhirMedicinalProductPackaged.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicinalProductPackaged(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicinalProductPackaged(oSource).FIdentifierList);
  end;
  if (TFhirMedicinalProductPackaged(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirReferenceList{TFhirMedicinalProduct}.Create;
    FSubjectList.Assign(TFhirMedicinalProductPackaged(oSource).FSubjectList);
  end;
  descriptionElement := TFhirMedicinalProductPackaged(oSource).descriptionElement.Clone;
  legalStatusOfSupply := TFhirMedicinalProductPackaged(oSource).legalStatusOfSupply.Clone;
  if (TFhirMedicinalProductPackaged(oSource).FMarketingStatusList = nil) then
  begin
    FMarketingStatusList.free;
    FMarketingStatusList := nil;
  end
  else
  begin
    if FMarketingStatusList = nil then
      FMarketingStatusList := TFhirMarketingStatusList.Create;
    FMarketingStatusList.Assign(TFhirMedicinalProductPackaged(oSource).FMarketingStatusList);
  end;
  marketingAuthorization := TFhirMedicinalProductPackaged(oSource).marketingAuthorization.Clone;
  if (TFhirMedicinalProductPackaged(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList{TFhirOrganization}.Create;
    FManufacturerList.Assign(TFhirMedicinalProductPackaged(oSource).FManufacturerList);
  end;
  if (TFhirMedicinalProductPackaged(oSource).FBatchIdentifierList = nil) then
  begin
    FBatchIdentifierList.free;
    FBatchIdentifierList := nil;
  end
  else
  begin
    if FBatchIdentifierList = nil then
      FBatchIdentifierList := TFhirMedicinalProductPackagedBatchIdentifierList.Create;
    FBatchIdentifierList.Assign(TFhirMedicinalProductPackaged(oSource).FBatchIdentifierList);
  end;
  if (TFhirMedicinalProductPackaged(oSource).FPackageItemList = nil) then
  begin
    FPackageItemList.free;
    FPackageItemList := nil;
  end
  else
  begin
    if FPackageItemList = nil then
      FPackageItemList := TFhirMedicinalProductPackagedPackageItemList.Create;
    FPackageItemList.Assign(TFhirMedicinalProductPackaged(oSource).FPackageItemList);
  end;
end;

procedure TFhirMedicinalProductPackaged.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'legalStatusOfSupply') Then
     list.add(self.link, 'legalStatusOfSupply', FLegalStatusOfSupply.Link);
  if (child_name = 'marketingStatus') Then
    list.addAll(self, 'marketingStatus', FMarketingStatusList);
  if (child_name = 'marketingAuthorization') Then
     list.add(self.link, 'marketingAuthorization', FMarketingAuthorization.Link);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'batchIdentifier') Then
    list.addAll(self, 'batchIdentifier', FBatchIdentifierList);
  if (child_name = 'packageItem') Then
    list.addAll(self, 'packageItem', FPackageItemList);
end;

procedure TFhirMedicinalProductPackaged.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(MedicinalProduct)', true, TFhirReference{TFhirMedicinalProduct}, FSubjectList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'legalStatusOfSupply', 'CodeableConcept', false, TFhirCodeableConcept, FLegalStatusOfSupply.Link));{2}
  oList.add(TFHIRProperty.create(self, 'marketingStatus', 'MarketingStatus', true, TFhirMarketingStatus, FMarketingStatusList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'marketingAuthorization', 'Reference(MedicinalProductAuthorization)', false, TFhirReference{TFhirMedicinalProductAuthorization}, FMarketingAuthorization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FManufacturerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'batchIdentifier', '', true, TFhirMedicinalProductPackagedBatchIdentifier, FBatchIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'packageItem', '', true, TFhirMedicinalProductPackagedPackageItem, FPackageItemList.Link)){3};
end;

function TFhirMedicinalProductPackaged.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirReference{TFhirMedicinalProduct}){2a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'legalStatusOfSupply') then
  begin
    LegalStatusOfSupply := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'marketingStatus') then
  begin
    MarketingStatusList.add(propValue as TFhirMarketingStatus){2a};
    result := propValue;
  end
  else if (propName = 'marketingAuthorization') then
  begin
    MarketingAuthorization := propValue as TFhirReference{TFhirMedicinalProductAuthorization}{4b};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else if (propName = 'batchIdentifier') then
  begin
    BatchIdentifierList.add(propValue as TFhirMedicinalProductPackagedBatchIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'packageItem') then
  begin
    PackageItemList.add(propValue as TFhirMedicinalProductPackagedPackageItem){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedicinalProductPackaged.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirReference{TFhirMedicinalProduct}){2a}
  else if (propName = 'marketingStatus') then MarketingStatusList.insertItem(index, propValue as TFhirMarketingStatus){2a}
  else if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else if (propName = 'batchIdentifier') then BatchIdentifierList.insertItem(index, propValue as TFhirMedicinalProductPackagedBatchIdentifier){2a}
  else if (propName = 'packageItem') then PackageItemList.insertItem(index, propValue as TFhirMedicinalProductPackagedPackageItem){2a}
  else inherited;
end;

function TFhirMedicinalProductPackaged.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'subject') then result := SubjectList.new(){2}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'legalStatusOfSupply') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'marketingStatus') then result := MarketingStatusList.new(){2}
  else if (propName = 'marketingAuthorization') then result := TFhirReference{TFhirMedicinalProductAuthorization}.create(){4b}
  else if (propName = 'manufacturer') then result := ManufacturerList.new(){2}
  else if (propName = 'batchIdentifier') then result := BatchIdentifierList.new(){2}
  else if (propName = 'packageItem') then result := PackageItemList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductPackaged.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'legalStatusOfSupply') then result := 'CodeableConcept'
  else if (propName = 'marketingStatus') then result := 'MarketingStatus'
  else if (propName = 'marketingAuthorization') then result := 'Reference'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'batchIdentifier') then result := ''
  else if (propName = 'packageItem') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductPackaged.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value) {2}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'legalStatusOfSupply') then LegalStatusOfSupplyElement := nil
  else if (propName = 'marketingStatus') then deletePropertyValue('marketingStatus', MarketingStatusList, value) {2}
  else if (propName = 'marketingAuthorization') then MarketingAuthorizationElement := nil
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value) {2}
  else if (propName = 'batchIdentifier') then deletePropertyValue('batchIdentifier', BatchIdentifierList, value) {2}
  else if (propName = 'packageItem') then deletePropertyValue('packageItem', PackageItemList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductPackaged.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new) {2}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'legalStatusOfSupply') then LegalStatusOfSupplyElement := new as TFhirCodeableConcept{4}
  else if (propName = 'marketingStatus') then replacePropertyValue('marketingStatus', MarketingStatusList, existing, new) {2}
  else if (propName = 'marketingAuthorization') then MarketingAuthorizationElement := new as TFhirReference{TFhirMedicinalProductAuthorization}{4}
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new) {2}
  else if (propName = 'batchIdentifier') then replacePropertyValue('batchIdentifier', BatchIdentifierList, existing, new) {2}
  else if (propName = 'packageItem') then replacePropertyValue('packageItem', PackageItemList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductPackaged.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'subject') then SubjectList.move(source, destination){2a}
  else if (propName = 'marketingStatus') then MarketingStatusList.move(source, destination){2a}
  else if (propName = 'manufacturer') then ManufacturerList.move(source, destination){2a}
  else if (propName = 'batchIdentifier') then BatchIdentifierList.move(source, destination){2a}
  else if (propName = 'packageItem') then PackageItemList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductPackaged.fhirType : string;
begin
  result := 'MedicinalProductPackaged';
end;

function TFhirMedicinalProductPackaged.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FsubjectList) and isEmptyProp(FDescription) and isEmptyProp(FLegalStatusOfSupply) and isEmptyProp(FmarketingStatusList) and isEmptyProp(FMarketingAuthorization) and isEmptyProp(FmanufacturerList) and isEmptyProp(FbatchIdentifierList) and isEmptyProp(FpackageItemList);
end;

function TFhirMedicinalProductPackaged.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductPackaged;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductPackaged)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductPackaged(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(subjectList, o.subjectList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(legalStatusOfSupplyElement, o.legalStatusOfSupplyElement, true) and 
      compareDeep(marketingStatusList, o.marketingStatusList, true) and compareDeep(marketingAuthorizationElement, o.marketingAuthorizationElement, true) and 
      compareDeep(manufacturerList, o.manufacturerList, true) and compareDeep(batchIdentifierList, o.batchIdentifierList, true) and 
      compareDeep(packageItemList, o.packageItemList, true);
  end;
end;

function TFhirMedicinalProductPackaged.Link : TFhirMedicinalProductPackaged;
begin
  result := TFhirMedicinalProductPackaged(inherited Link);
end;

function TFhirMedicinalProductPackaged.Clone : TFhirMedicinalProductPackaged;
begin
  result := TFhirMedicinalProductPackaged(inherited Clone);
end;

procedure TFhirMedicinalProductPackaged.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('subject');
  fields.add('description');
  fields.add('legalStatusOfSupply');
  fields.add('marketingStatus');
  fields.add('marketingAuthorization');
  fields.add('manufacturer');
  fields.add('batchIdentifier');
  fields.add('packageItem');
end;

{ TFhirMedicinalProductPackaged }

Function TFhirMedicinalProductPackaged.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirMedicinalProductPackaged.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirMedicinalProductPackaged.GetSubjectList : TFhirReferenceList{TFhirMedicinalProduct};
begin
  if FSubjectList = nil then
    FSubjectList := TFhirReferenceList{TFhirMedicinalProduct}.Create;
  result := FSubjectList;
end;

Function TFhirMedicinalProductPackaged.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

Procedure TFhirMedicinalProductPackaged.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirMedicinalProductPackaged.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirMedicinalProductPackaged.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirMedicinalProductPackaged.SetLegalStatusOfSupply(value : TFhirCodeableConcept);
begin
  FLegalStatusOfSupply.free;
  FLegalStatusOfSupply := value;
end;

Function TFhirMedicinalProductPackaged.GetMarketingStatusList : TFhirMarketingStatusList;
begin
  if FMarketingStatusList = nil then
    FMarketingStatusList := TFhirMarketingStatusList.Create;
  result := FMarketingStatusList;
end;

Function TFhirMedicinalProductPackaged.GetHasMarketingStatusList : boolean;
begin
  result := (FMarketingStatusList <> nil) and (FMarketingStatusList.count > 0);
end;

Procedure TFhirMedicinalProductPackaged.SetMarketingAuthorization(value : TFhirReference{TFhirMedicinalProductAuthorization});
begin
  FMarketingAuthorization.free;
  FMarketingAuthorization := value;
end;

Function TFhirMedicinalProductPackaged.GetManufacturerList : TFhirReferenceList{TFhirOrganization};
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FManufacturerList;
end;

Function TFhirMedicinalProductPackaged.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

Function TFhirMedicinalProductPackaged.GetBatchIdentifierList : TFhirMedicinalProductPackagedBatchIdentifierList;
begin
  if FBatchIdentifierList = nil then
    FBatchIdentifierList := TFhirMedicinalProductPackagedBatchIdentifierList.Create;
  result := FBatchIdentifierList;
end;

Function TFhirMedicinalProductPackaged.GetHasBatchIdentifierList : boolean;
begin
  result := (FBatchIdentifierList <> nil) and (FBatchIdentifierList.count > 0);
end;

Function TFhirMedicinalProductPackaged.GetPackageItemList : TFhirMedicinalProductPackagedPackageItemList;
begin
  if FPackageItemList = nil then
    FPackageItemList := TFhirMedicinalProductPackagedPackageItemList.Create;
  result := FPackageItemList;
end;

Function TFhirMedicinalProductPackaged.GetHasPackageItemList : boolean;
begin
  result := (FPackageItemList <> nil) and (FPackageItemList.count > 0);
end;

function TFhirMedicinalProductPackaged.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FsubjectList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FLegalStatusOfSupply.sizeInBytes);
  inc(result, FmarketingStatusList.sizeInBytes);
  inc(result, FMarketingAuthorization.sizeInBytes);
  inc(result, FmanufacturerList.sizeInBytes);
  inc(result, FbatchIdentifierList.sizeInBytes);
  inc(result, FpackageItemList.sizeInBytes);
end;

{ TFhirMedicinalProductPackagedListEnumerator }

Constructor TFhirMedicinalProductPackagedListEnumerator.Create(list : TFhirMedicinalProductPackagedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductPackagedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductPackagedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductPackagedListEnumerator.GetCurrent : TFhirMedicinalProductPackaged;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductPackagedListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductPackagedList }
procedure TFhirMedicinalProductPackagedList.AddItem(value: TFhirMedicinalProductPackaged);
begin
  assert(value.ClassName = 'TFhirMedicinalProductPackaged', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductPackaged');
  add(value);
end;

function TFhirMedicinalProductPackagedList.Append: TFhirMedicinalProductPackaged;
begin
  result := TFhirMedicinalProductPackaged.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductPackagedList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductPackagedList.GetEnumerator : TFhirMedicinalProductPackagedListEnumerator;
begin
  result := TFhirMedicinalProductPackagedListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductPackagedList.Clone: TFhirMedicinalProductPackagedList;
begin
  result := TFhirMedicinalProductPackagedList(inherited Clone);
end;

function TFhirMedicinalProductPackagedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductPackagedList.GetItemN(index: Integer): TFhirMedicinalProductPackaged;
begin
  result := TFhirMedicinalProductPackaged(ObjectByIndex[index]);
end;

function TFhirMedicinalProductPackagedList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductPackaged;
end;
function TFhirMedicinalProductPackagedList.IndexOf(value: TFhirMedicinalProductPackaged): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductPackagedList.Insert(index: Integer): TFhirMedicinalProductPackaged;
begin
  result := TFhirMedicinalProductPackaged.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductPackagedList.InsertItem(index: Integer; value: TFhirMedicinalProductPackaged);
begin
  assert(value is TFhirMedicinalProductPackaged);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductPackagedList.Item(index: Integer): TFhirMedicinalProductPackaged;
begin
  result := TFhirMedicinalProductPackaged(ObjectByIndex[index]);
end;

function TFhirMedicinalProductPackagedList.Link: TFhirMedicinalProductPackagedList;
begin
  result := TFhirMedicinalProductPackagedList(inherited Link);
end;

procedure TFhirMedicinalProductPackagedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductPackagedList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductPackaged);
begin
  assert(value is TFhirMedicinalProductPackaged);
  FhirMedicinalProductPackageds[index] := value;
end;

procedure TFhirMedicinalProductPackagedList.SetItemN(index: Integer; value: TFhirMedicinalProductPackaged);
begin
  assert(value is TFhirMedicinalProductPackaged);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICINALPRODUCTPACKAGED}

{$IFDEF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}

{ TFhirMedicinalProductPharmaceuticalCharacteristics }

constructor TFhirMedicinalProductPharmaceuticalCharacteristics.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductPharmaceuticalCharacteristics.Destroy;
begin
  FCode.free;
  FStatus.free;
  inherited;
end;

procedure TFhirMedicinalProductPharmaceuticalCharacteristics.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMedicinalProductPharmaceuticalCharacteristics(oSource).code.Clone;
  status := TFhirMedicinalProductPharmaceuticalCharacteristics(oSource).status.Clone;
end;

procedure TFhirMedicinalProductPharmaceuticalCharacteristics.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
end;

procedure TFhirMedicinalProductPharmaceuticalCharacteristics.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));{2}
end;

function TFhirMedicinalProductPharmaceuticalCharacteristics.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductPharmaceuticalCharacteristics.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductPharmaceuticalCharacteristics.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'status') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductPharmaceuticalCharacteristics.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductPharmaceuticalCharacteristics.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'status') then StatusElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductPharmaceuticalCharacteristics.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductPharmaceuticalCharacteristics.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductPharmaceuticalCharacteristics.fhirType : string;
begin
  result := 'characteristics';
end;

function TFhirMedicinalProductPharmaceuticalCharacteristics.Link : TFhirMedicinalProductPharmaceuticalCharacteristics;
begin
  result := TFhirMedicinalProductPharmaceuticalCharacteristics(inherited Link);
end;

function TFhirMedicinalProductPharmaceuticalCharacteristics.Clone : TFhirMedicinalProductPharmaceuticalCharacteristics;
begin
  result := TFhirMedicinalProductPharmaceuticalCharacteristics(inherited Clone);
end;

function TFhirMedicinalProductPharmaceuticalCharacteristics.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductPharmaceuticalCharacteristics;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductPharmaceuticalCharacteristics)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductPharmaceuticalCharacteristics(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(statusElement, o.statusElement, true);
  end;
end;

function TFhirMedicinalProductPharmaceuticalCharacteristics.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FStatus);
end;

procedure TFhirMedicinalProductPharmaceuticalCharacteristics.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('status');
end;

{ TFhirMedicinalProductPharmaceuticalCharacteristics }

Procedure TFhirMedicinalProductPharmaceuticalCharacteristics.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirMedicinalProductPharmaceuticalCharacteristics.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirMedicinalProductPharmaceuticalCharacteristics.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
end;

{ TFhirMedicinalProductPharmaceuticalCharacteristicsListEnumerator }

Constructor TFhirMedicinalProductPharmaceuticalCharacteristicsListEnumerator.Create(list : TFhirMedicinalProductPharmaceuticalCharacteristicsList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductPharmaceuticalCharacteristicsListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductPharmaceuticalCharacteristicsListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductPharmaceuticalCharacteristicsListEnumerator.GetCurrent : TFhirMedicinalProductPharmaceuticalCharacteristics;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductPharmaceuticalCharacteristicsListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductPharmaceuticalCharacteristicsList }
procedure TFhirMedicinalProductPharmaceuticalCharacteristicsList.AddItem(value: TFhirMedicinalProductPharmaceuticalCharacteristics);
begin
  assert(value.ClassName = 'TFhirMedicinalProductPharmaceuticalCharacteristics', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductPharmaceuticalCharacteristics');
  add(value);
end;

function TFhirMedicinalProductPharmaceuticalCharacteristicsList.Append: TFhirMedicinalProductPharmaceuticalCharacteristics;
begin
  result := TFhirMedicinalProductPharmaceuticalCharacteristics.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductPharmaceuticalCharacteristicsList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductPharmaceuticalCharacteristicsList.GetEnumerator : TFhirMedicinalProductPharmaceuticalCharacteristicsListEnumerator;
begin
  result := TFhirMedicinalProductPharmaceuticalCharacteristicsListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductPharmaceuticalCharacteristicsList.Clone: TFhirMedicinalProductPharmaceuticalCharacteristicsList;
begin
  result := TFhirMedicinalProductPharmaceuticalCharacteristicsList(inherited Clone);
end;

function TFhirMedicinalProductPharmaceuticalCharacteristicsList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductPharmaceuticalCharacteristicsList.GetItemN(index: Integer): TFhirMedicinalProductPharmaceuticalCharacteristics;
begin
  result := TFhirMedicinalProductPharmaceuticalCharacteristics(ObjectByIndex[index]);
end;

function TFhirMedicinalProductPharmaceuticalCharacteristicsList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductPharmaceuticalCharacteristics;
end;
function TFhirMedicinalProductPharmaceuticalCharacteristicsList.IndexOf(value: TFhirMedicinalProductPharmaceuticalCharacteristics): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductPharmaceuticalCharacteristicsList.Insert(index: Integer): TFhirMedicinalProductPharmaceuticalCharacteristics;
begin
  result := TFhirMedicinalProductPharmaceuticalCharacteristics.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductPharmaceuticalCharacteristicsList.InsertItem(index: Integer; value: TFhirMedicinalProductPharmaceuticalCharacteristics);
begin
  assert(value is TFhirMedicinalProductPharmaceuticalCharacteristics);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductPharmaceuticalCharacteristicsList.Item(index: Integer): TFhirMedicinalProductPharmaceuticalCharacteristics;
begin
  result := TFhirMedicinalProductPharmaceuticalCharacteristics(ObjectByIndex[index]);
end;

function TFhirMedicinalProductPharmaceuticalCharacteristicsList.Link: TFhirMedicinalProductPharmaceuticalCharacteristicsList;
begin
  result := TFhirMedicinalProductPharmaceuticalCharacteristicsList(inherited Link);
end;

procedure TFhirMedicinalProductPharmaceuticalCharacteristicsList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductPharmaceuticalCharacteristicsList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductPharmaceuticalCharacteristics);
begin
  assert(value is TFhirMedicinalProductPharmaceuticalCharacteristics);
  FhirMedicinalProductPharmaceuticalCharacteristics[index] := value;
end;

procedure TFhirMedicinalProductPharmaceuticalCharacteristicsList.SetItemN(index: Integer; value: TFhirMedicinalProductPharmaceuticalCharacteristics);
begin
  assert(value is TFhirMedicinalProductPharmaceuticalCharacteristics);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductPharmaceuticalRouteOfAdministration }

constructor TFhirMedicinalProductPharmaceuticalRouteOfAdministration.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductPharmaceuticalRouteOfAdministration.Destroy;
begin
  FCode.free;
  FFirstDose.free;
  FMaxSingleDose.free;
  FMaxDosePerDay.free;
  FMaxDosePerTreatmentPeriod.free;
  FMaxTreatmentPeriod.free;
  FTargetSpeciesList.Free;
  inherited;
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministration.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMedicinalProductPharmaceuticalRouteOfAdministration(oSource).code.Clone;
  firstDose := TFhirMedicinalProductPharmaceuticalRouteOfAdministration(oSource).firstDose.Clone;
  maxSingleDose := TFhirMedicinalProductPharmaceuticalRouteOfAdministration(oSource).maxSingleDose.Clone;
  maxDosePerDay := TFhirMedicinalProductPharmaceuticalRouteOfAdministration(oSource).maxDosePerDay.Clone;
  maxDosePerTreatmentPeriod := TFhirMedicinalProductPharmaceuticalRouteOfAdministration(oSource).maxDosePerTreatmentPeriod.Clone;
  maxTreatmentPeriod := TFhirMedicinalProductPharmaceuticalRouteOfAdministration(oSource).maxTreatmentPeriod.Clone;
  if (TFhirMedicinalProductPharmaceuticalRouteOfAdministration(oSource).FTargetSpeciesList = nil) then
  begin
    FTargetSpeciesList.free;
    FTargetSpeciesList := nil;
  end
  else
  begin
    if FTargetSpeciesList = nil then
      FTargetSpeciesList := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList.Create;
    FTargetSpeciesList.Assign(TFhirMedicinalProductPharmaceuticalRouteOfAdministration(oSource).FTargetSpeciesList);
  end;
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministration.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'firstDose') Then
     list.add(self.link, 'firstDose', FFirstDose.Link);
  if (child_name = 'maxSingleDose') Then
     list.add(self.link, 'maxSingleDose', FMaxSingleDose.Link);
  if (child_name = 'maxDosePerDay') Then
     list.add(self.link, 'maxDosePerDay', FMaxDosePerDay.Link);
  if (child_name = 'maxDosePerTreatmentPeriod') Then
     list.add(self.link, 'maxDosePerTreatmentPeriod', FMaxDosePerTreatmentPeriod.Link);
  if (child_name = 'maxTreatmentPeriod') Then
     list.add(self.link, 'maxTreatmentPeriod', FMaxTreatmentPeriod.Link);
  if (child_name = 'targetSpecies') Then
    list.addAll(self, 'targetSpecies', FTargetSpeciesList);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministration.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'firstDose', 'Quantity', false, TFhirQuantity, FFirstDose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxSingleDose', 'Quantity', false, TFhirQuantity, FMaxSingleDose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxDosePerDay', 'Quantity', false, TFhirQuantity, FMaxDosePerDay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxDosePerTreatmentPeriod', 'Ratio', false, TFhirRatio, FMaxDosePerTreatmentPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxTreatmentPeriod', 'Duration', false, TFhirDuration, FMaxTreatmentPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'targetSpecies', '', true, TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies, FTargetSpeciesList.Link)){3};
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministration.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'firstDose') then
  begin
    FirstDose := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'maxSingleDose') then
  begin
    MaxSingleDose := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'maxDosePerDay') then
  begin
    MaxDosePerDay := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'maxDosePerTreatmentPeriod') then
  begin
    MaxDosePerTreatmentPeriod := propValue as TFhirRatio{4b};
    result := propValue;
  end
  else if (propName = 'maxTreatmentPeriod') then
  begin
    MaxTreatmentPeriod := propValue as TFhirDuration{4b};
    result := propValue;
  end
  else if (propName = 'targetSpecies') then
  begin
    TargetSpeciesList.add(propValue as TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministration.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'targetSpecies') then TargetSpeciesList.insertItem(index, propValue as TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies){2a}
  else inherited;
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministration.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'firstDose') then result := TFhirQuantity.create(){4b}
  else if (propName = 'maxSingleDose') then result := TFhirQuantity.create(){4b}
  else if (propName = 'maxDosePerDay') then result := TFhirQuantity.create(){4b}
  else if (propName = 'maxDosePerTreatmentPeriod') then result := TFhirRatio.create(){4b}
  else if (propName = 'maxTreatmentPeriod') then result := TFhirDuration.create(){4b}
  else if (propName = 'targetSpecies') then result := TargetSpeciesList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministration.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'firstDose') then result := 'Quantity'
  else if (propName = 'maxSingleDose') then result := 'Quantity'
  else if (propName = 'maxDosePerDay') then result := 'Quantity'
  else if (propName = 'maxDosePerTreatmentPeriod') then result := 'Ratio'
  else if (propName = 'maxTreatmentPeriod') then result := 'Duration'
  else if (propName = 'targetSpecies') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministration.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'firstDose') then FirstDoseElement := nil
  else if (propName = 'maxSingleDose') then MaxSingleDoseElement := nil
  else if (propName = 'maxDosePerDay') then MaxDosePerDayElement := nil
  else if (propName = 'maxDosePerTreatmentPeriod') then MaxDosePerTreatmentPeriodElement := nil
  else if (propName = 'maxTreatmentPeriod') then MaxTreatmentPeriodElement := nil
  else if (propName = 'targetSpecies') then deletePropertyValue('targetSpecies', TargetSpeciesList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministration.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'firstDose') then FirstDoseElement := new as TFhirQuantity{4}
  else if (propName = 'maxSingleDose') then MaxSingleDoseElement := new as TFhirQuantity{4}
  else if (propName = 'maxDosePerDay') then MaxDosePerDayElement := new as TFhirQuantity{4}
  else if (propName = 'maxDosePerTreatmentPeriod') then MaxDosePerTreatmentPeriodElement := new as TFhirRatio{4}
  else if (propName = 'maxTreatmentPeriod') then MaxTreatmentPeriodElement := new as TFhirDuration{4}
  else if (propName = 'targetSpecies') then replacePropertyValue('targetSpecies', TargetSpeciesList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministration.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'targetSpecies') then TargetSpeciesList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministration.fhirType : string;
begin
  result := 'routeOfAdministration';
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministration.Link : TFhirMedicinalProductPharmaceuticalRouteOfAdministration;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministration(inherited Link);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministration.Clone : TFhirMedicinalProductPharmaceuticalRouteOfAdministration;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministration(inherited Clone);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministration.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductPharmaceuticalRouteOfAdministration;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductPharmaceuticalRouteOfAdministration)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductPharmaceuticalRouteOfAdministration(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(firstDoseElement, o.firstDoseElement, true) and 
      compareDeep(maxSingleDoseElement, o.maxSingleDoseElement, true) and compareDeep(maxDosePerDayElement, o.maxDosePerDayElement, true) and 
      compareDeep(maxDosePerTreatmentPeriodElement, o.maxDosePerTreatmentPeriodElement, true) and 
      compareDeep(maxTreatmentPeriodElement, o.maxTreatmentPeriodElement, true) and 
      compareDeep(targetSpeciesList, o.targetSpeciesList, true);
  end;
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministration.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FFirstDose) and isEmptyProp(FMaxSingleDose) and isEmptyProp(FMaxDosePerDay) and isEmptyProp(FMaxDosePerTreatmentPeriod) and isEmptyProp(FMaxTreatmentPeriod) and isEmptyProp(FtargetSpeciesList);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministration.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('firstDose');
  fields.add('maxSingleDose');
  fields.add('maxDosePerDay');
  fields.add('maxDosePerTreatmentPeriod');
  fields.add('maxTreatmentPeriod');
  fields.add('targetSpecies');
end;

{ TFhirMedicinalProductPharmaceuticalRouteOfAdministration }

Procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministration.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministration.SetFirstDose(value : TFhirQuantity);
begin
  FFirstDose.free;
  FFirstDose := value;
end;

Procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministration.SetMaxSingleDose(value : TFhirQuantity);
begin
  FMaxSingleDose.free;
  FMaxSingleDose := value;
end;

Procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministration.SetMaxDosePerDay(value : TFhirQuantity);
begin
  FMaxDosePerDay.free;
  FMaxDosePerDay := value;
end;

Procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministration.SetMaxDosePerTreatmentPeriod(value : TFhirRatio);
begin
  FMaxDosePerTreatmentPeriod.free;
  FMaxDosePerTreatmentPeriod := value;
end;

Procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministration.SetMaxTreatmentPeriod(value : TFhirDuration);
begin
  FMaxTreatmentPeriod.free;
  FMaxTreatmentPeriod := value;
end;

Function TFhirMedicinalProductPharmaceuticalRouteOfAdministration.GetTargetSpeciesList : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList;
begin
  if FTargetSpeciesList = nil then
    FTargetSpeciesList := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList.Create;
  result := FTargetSpeciesList;
end;

Function TFhirMedicinalProductPharmaceuticalRouteOfAdministration.GetHasTargetSpeciesList : boolean;
begin
  result := (FTargetSpeciesList <> nil) and (FTargetSpeciesList.count > 0);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministration.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FFirstDose.sizeInBytes);
  inc(result, FMaxSingleDose.sizeInBytes);
  inc(result, FMaxDosePerDay.sizeInBytes);
  inc(result, FMaxDosePerTreatmentPeriod.sizeInBytes);
  inc(result, FMaxTreatmentPeriod.sizeInBytes);
  inc(result, FtargetSpeciesList.sizeInBytes);
end;

{ TFhirMedicinalProductPharmaceuticalRouteOfAdministrationListEnumerator }

Constructor TFhirMedicinalProductPharmaceuticalRouteOfAdministrationListEnumerator.Create(list : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductPharmaceuticalRouteOfAdministrationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationListEnumerator.GetCurrent : TFhirMedicinalProductPharmaceuticalRouteOfAdministration;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList }
procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList.AddItem(value: TFhirMedicinalProductPharmaceuticalRouteOfAdministration);
begin
  assert(value.ClassName = 'TFhirMedicinalProductPharmaceuticalRouteOfAdministration', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductPharmaceuticalRouteOfAdministration');
  add(value);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList.Append: TFhirMedicinalProductPharmaceuticalRouteOfAdministration;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministration.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList.GetEnumerator : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationListEnumerator;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList.Clone: TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList(inherited Clone);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList.GetItemN(index: Integer): TFhirMedicinalProductPharmaceuticalRouteOfAdministration;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministration(ObjectByIndex[index]);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministration;
end;
function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList.IndexOf(value: TFhirMedicinalProductPharmaceuticalRouteOfAdministration): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList.Insert(index: Integer): TFhirMedicinalProductPharmaceuticalRouteOfAdministration;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministration.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList.InsertItem(index: Integer; value: TFhirMedicinalProductPharmaceuticalRouteOfAdministration);
begin
  assert(value is TFhirMedicinalProductPharmaceuticalRouteOfAdministration);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList.Item(index: Integer): TFhirMedicinalProductPharmaceuticalRouteOfAdministration;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministration(ObjectByIndex[index]);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList.Link: TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList(inherited Link);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductPharmaceuticalRouteOfAdministration);
begin
  assert(value is TFhirMedicinalProductPharmaceuticalRouteOfAdministration);
  FhirMedicinalProductPharmaceuticalRouteOfAdministrations[index] := value;
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList.SetItemN(index: Integer; value: TFhirMedicinalProductPharmaceuticalRouteOfAdministration);
begin
  assert(value is TFhirMedicinalProductPharmaceuticalRouteOfAdministration);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies }

constructor TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.Destroy;
begin
  FCode.free;
  FWithdrawalPeriodList.Free;
  inherited;
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(oSource).code.Clone;
  if (TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(oSource).FWithdrawalPeriodList = nil) then
  begin
    FWithdrawalPeriodList.free;
    FWithdrawalPeriodList := nil;
  end
  else
  begin
    if FWithdrawalPeriodList = nil then
      FWithdrawalPeriodList := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Create;
    FWithdrawalPeriodList.Assign(TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(oSource).FWithdrawalPeriodList);
  end;
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'withdrawalPeriod') Then
    list.addAll(self, 'withdrawalPeriod', FWithdrawalPeriodList);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'withdrawalPeriod', '', true, TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod, FWithdrawalPeriodList.Link)){3};
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'withdrawalPeriod') then
  begin
    WithdrawalPeriodList.add(propValue as TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'withdrawalPeriod') then WithdrawalPeriodList.insertItem(index, propValue as TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod){2a}
  else inherited;
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'withdrawalPeriod') then result := WithdrawalPeriodList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'withdrawalPeriod') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'withdrawalPeriod') then deletePropertyValue('withdrawalPeriod', WithdrawalPeriodList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'withdrawalPeriod') then replacePropertyValue('withdrawalPeriod', WithdrawalPeriodList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'withdrawalPeriod') then WithdrawalPeriodList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.fhirType : string;
begin
  result := 'targetSpecies';
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.Link : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(inherited Link);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.Clone : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(inherited Clone);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(withdrawalPeriodList, o.withdrawalPeriodList, true);
  end;
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FwithdrawalPeriodList);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('withdrawalPeriod');
end;

{ TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies }

Procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.GetWithdrawalPeriodList : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
begin
  if FWithdrawalPeriodList = nil then
    FWithdrawalPeriodList := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Create;
  result := FWithdrawalPeriodList;
end;

Function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.GetHasWithdrawalPeriodList : boolean;
begin
  result := (FWithdrawalPeriodList <> nil) and (FWithdrawalPeriodList.count > 0);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FwithdrawalPeriodList.sizeInBytes);
end;

{ TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesListEnumerator }

Constructor TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesListEnumerator.Create(list : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesListEnumerator.GetCurrent : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList }
procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList.AddItem(value: TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies);
begin
  assert(value.ClassName = 'TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies');
  add(value);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList.Append: TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList.GetEnumerator : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesListEnumerator;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList.Clone: TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList(inherited Clone);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList.GetItemN(index: Integer): TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(ObjectByIndex[index]);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies;
end;
function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList.IndexOf(value: TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList.Insert(index: Integer): TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList.InsertItem(index: Integer; value: TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies);
begin
  assert(value is TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList.Item(index: Integer): TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies(ObjectByIndex[index]);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList.Link: TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList(inherited Link);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies);
begin
  assert(value is TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies);
  FhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies[index] := value;
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesList.SetItemN(index: Integer; value: TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies);
begin
  assert(value is TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpecies);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod }

constructor TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Destroy;
begin
  FTissue.free;
  FValue.free;
  FSupportingInformation.free;
  inherited;
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Assign(oSource : TFslObject);
begin
  inherited;
  tissue := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(oSource).tissue.Clone;
  value := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(oSource).value.Clone;
  supportingInformationElement := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(oSource).supportingInformationElement.Clone;
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'tissue') Then
     list.add(self.link, 'tissue', FTissue.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'supportingInformation') Then
     list.add(self.link, 'supportingInformation', FSupportingInformation.Link);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'tissue', 'CodeableConcept', false, TFhirCodeableConcept, FTissue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'Quantity', false, TFhirQuantity, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'string', false, TFhirString, FSupportingInformation.Link));{2}
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'tissue') then
  begin
    Tissue := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    Value := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'tissue') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'value') then result := TFhirQuantity.create(){4b}
  else if (propName = 'supportingInformation') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'tissue') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'Quantity'
  else if (propName = 'supportingInformation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'tissue') then TissueElement := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'supportingInformation') then SupportingInformationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'tissue') then TissueElement := new as TFhirCodeableConcept{4}
  else if (propName = 'value') then ValueElement := new as TFhirQuantity{4}
  else if (propName = 'supportingInformation') then SupportingInformationElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.fhirType : string;
begin
  result := 'withdrawalPeriod';
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Link : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(inherited Link);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Clone : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(inherited Clone);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(other);
    result := compareDeep(tissueElement, o.tissueElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(supportingInformationElement, o.supportingInformationElement, true);
  end;
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTissue) and isEmptyProp(FValue) and isEmptyProp(FSupportingInformation);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('tissue');
  fields.add('value');
  fields.add('supportingInformation');
end;

{ TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod }

Procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.SetTissue(value : TFhirCodeableConcept);
begin
  FTissue.free;
  FTissue := value;
end;

Procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.SetValue(value : TFhirQuantity);
begin
  FValue.free;
  FValue := value;
end;

Procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.SetSupportingInformation(value : TFhirString);
begin
  FSupportingInformation.free;
  FSupportingInformation := value;
end;

Function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.GetSupportingInformationST : String;
begin
  if FSupportingInformation = nil then
    result := ''
  else
    result := FSupportingInformation.value;
end;

Procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.SetSupportingInformationST(value : String);
begin
  if value <> '' then
  begin
    if FSupportingInformation = nil then
      FSupportingInformation := TFhirString.create;
    FSupportingInformation.value := value
  end
  else if FSupportingInformation <> nil then
    FSupportingInformation.value := '';
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FTissue.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FSupportingInformation.sizeInBytes);
end;

{ TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator }

Constructor TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.Create(list : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.GetCurrent : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList }
procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.AddItem(value: TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
begin
  assert(value.ClassName = 'TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod');
  add(value);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Append: TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.GetEnumerator : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Clone: TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList(inherited Clone);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.GetItemN(index: Integer): TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(ObjectByIndex[index]);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
end;
function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.IndexOf(value: TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Insert(index: Integer): TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.InsertItem(index: Integer; value: TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
begin
  assert(value is TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Item(index: Integer): TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod(ObjectByIndex[index]);
end;

function TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Link: TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
begin
  result := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList(inherited Link);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
begin
  assert(value is TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
  FhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriods[index] := value;
end;

procedure TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.SetItemN(index: Integer; value: TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
begin
  assert(value is TFhirMedicinalProductPharmaceuticalRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductPharmaceutical }

constructor TFhirMedicinalProductPharmaceutical.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductPharmaceutical.Destroy;
begin
  FIdentifierList.Free;
  FAdministrableDoseForm.free;
  FUnitOfPresentation.free;
  FIngredientList.Free;
  FDeviceList.Free;
  FCharacteristicsList.Free;
  FRouteOfAdministrationList.Free;
  inherited;
end;

function TFhirMedicinalProductPharmaceutical.GetResourceType : TFhirResourceType;
begin
  result := frtMedicinalProductPharmaceutical;
end;

procedure TFhirMedicinalProductPharmaceutical.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicinalProductPharmaceutical(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicinalProductPharmaceutical(oSource).FIdentifierList);
  end;
  administrableDoseForm := TFhirMedicinalProductPharmaceutical(oSource).administrableDoseForm.Clone;
  unitOfPresentation := TFhirMedicinalProductPharmaceutical(oSource).unitOfPresentation.Clone;
  if (TFhirMedicinalProductPharmaceutical(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirReferenceList{TFhirMedicinalProductIngredient}.Create;
    FIngredientList.Assign(TFhirMedicinalProductPharmaceutical(oSource).FIngredientList);
  end;
  if (TFhirMedicinalProductPharmaceutical(oSource).FDeviceList = nil) then
  begin
    FDeviceList.free;
    FDeviceList := nil;
  end
  else
  begin
    if FDeviceList = nil then
      FDeviceList := TFhirReferenceList{TFhirDeviceDefinition}.Create;
    FDeviceList.Assign(TFhirMedicinalProductPharmaceutical(oSource).FDeviceList);
  end;
  if (TFhirMedicinalProductPharmaceutical(oSource).FCharacteristicsList = nil) then
  begin
    FCharacteristicsList.free;
    FCharacteristicsList := nil;
  end
  else
  begin
    if FCharacteristicsList = nil then
      FCharacteristicsList := TFhirMedicinalProductPharmaceuticalCharacteristicsList.Create;
    FCharacteristicsList.Assign(TFhirMedicinalProductPharmaceutical(oSource).FCharacteristicsList);
  end;
  if (TFhirMedicinalProductPharmaceutical(oSource).FRouteOfAdministrationList = nil) then
  begin
    FRouteOfAdministrationList.free;
    FRouteOfAdministrationList := nil;
  end
  else
  begin
    if FRouteOfAdministrationList = nil then
      FRouteOfAdministrationList := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList.Create;
    FRouteOfAdministrationList.Assign(TFhirMedicinalProductPharmaceutical(oSource).FRouteOfAdministrationList);
  end;
end;

procedure TFhirMedicinalProductPharmaceutical.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'administrableDoseForm') Then
     list.add(self.link, 'administrableDoseForm', FAdministrableDoseForm.Link);
  if (child_name = 'unitOfPresentation') Then
     list.add(self.link, 'unitOfPresentation', FUnitOfPresentation.Link);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'device') Then
    list.addAll(self, 'device', FDeviceList);
  if (child_name = 'characteristics') Then
    list.addAll(self, 'characteristics', FCharacteristicsList);
  if (child_name = 'routeOfAdministration') Then
    list.addAll(self, 'routeOfAdministration', FRouteOfAdministrationList);
end;

procedure TFhirMedicinalProductPharmaceutical.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'administrableDoseForm', 'CodeableConcept', false, TFhirCodeableConcept, FAdministrableDoseForm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitOfPresentation', 'CodeableConcept', false, TFhirCodeableConcept, FUnitOfPresentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ingredient', 'Reference(MedicinalProductIngredient)', true, TFhirReference{TFhirMedicinalProductIngredient}, FIngredientList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'device', 'Reference(DeviceDefinition)', true, TFhirReference{TFhirDeviceDefinition}, FDeviceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'characteristics', '', true, TFhirMedicinalProductPharmaceuticalCharacteristics, FCharacteristicsList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'routeOfAdministration', '', true, TFhirMedicinalProductPharmaceuticalRouteOfAdministration, FRouteOfAdministrationList.Link)){3};
end;

function TFhirMedicinalProductPharmaceutical.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'administrableDoseForm') then
  begin
    AdministrableDoseForm := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'unitOfPresentation') then
  begin
    UnitOfPresentation := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirReference{TFhirMedicinalProductIngredient}){2a};
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    DeviceList.add(propValue as TFhirReference{TFhirDeviceDefinition}){2a};
    result := propValue;
  end
  else if (propName = 'characteristics') then
  begin
    CharacteristicsList.add(propValue as TFhirMedicinalProductPharmaceuticalCharacteristics){2a};
    result := propValue;
  end
  else if (propName = 'routeOfAdministration') then
  begin
    RouteOfAdministrationList.add(propValue as TFhirMedicinalProductPharmaceuticalRouteOfAdministration){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedicinalProductPharmaceutical.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirReference{TFhirMedicinalProductIngredient}){2a}
  else if (propName = 'device') then DeviceList.insertItem(index, propValue as TFhirReference{TFhirDeviceDefinition}){2a}
  else if (propName = 'characteristics') then CharacteristicsList.insertItem(index, propValue as TFhirMedicinalProductPharmaceuticalCharacteristics){2a}
  else if (propName = 'routeOfAdministration') then RouteOfAdministrationList.insertItem(index, propValue as TFhirMedicinalProductPharmaceuticalRouteOfAdministration){2a}
  else inherited;
end;

function TFhirMedicinalProductPharmaceutical.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'administrableDoseForm') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'unitOfPresentation') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'ingredient') then result := IngredientList.new(){2}
  else if (propName = 'device') then result := DeviceList.new(){2}
  else if (propName = 'characteristics') then result := CharacteristicsList.new(){2}
  else if (propName = 'routeOfAdministration') then result := RouteOfAdministrationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductPharmaceutical.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'administrableDoseForm') then result := 'CodeableConcept'
  else if (propName = 'unitOfPresentation') then result := 'CodeableConcept'
  else if (propName = 'ingredient') then result := 'Reference'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'characteristics') then result := ''
  else if (propName = 'routeOfAdministration') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductPharmaceutical.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'administrableDoseForm') then AdministrableDoseFormElement := nil
  else if (propName = 'unitOfPresentation') then UnitOfPresentationElement := nil
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value) {2}
  else if (propName = 'device') then deletePropertyValue('device', DeviceList, value) {2}
  else if (propName = 'characteristics') then deletePropertyValue('characteristics', CharacteristicsList, value) {2}
  else if (propName = 'routeOfAdministration') then deletePropertyValue('routeOfAdministration', RouteOfAdministrationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductPharmaceutical.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'administrableDoseForm') then AdministrableDoseFormElement := new as TFhirCodeableConcept{4}
  else if (propName = 'unitOfPresentation') then UnitOfPresentationElement := new as TFhirCodeableConcept{4}
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new) {2}
  else if (propName = 'device') then replacePropertyValue('device', DeviceList, existing, new) {2}
  else if (propName = 'characteristics') then replacePropertyValue('characteristics', CharacteristicsList, existing, new) {2}
  else if (propName = 'routeOfAdministration') then replacePropertyValue('routeOfAdministration', RouteOfAdministrationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductPharmaceutical.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'ingredient') then IngredientList.move(source, destination){2a}
  else if (propName = 'device') then DeviceList.move(source, destination){2a}
  else if (propName = 'characteristics') then CharacteristicsList.move(source, destination){2a}
  else if (propName = 'routeOfAdministration') then RouteOfAdministrationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductPharmaceutical.fhirType : string;
begin
  result := 'MedicinalProductPharmaceutical';
end;

function TFhirMedicinalProductPharmaceutical.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FAdministrableDoseForm) and isEmptyProp(FUnitOfPresentation) and isEmptyProp(FingredientList) and isEmptyProp(FdeviceList) and isEmptyProp(FcharacteristicsList) and isEmptyProp(FrouteOfAdministrationList);
end;

function TFhirMedicinalProductPharmaceutical.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductPharmaceutical;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductPharmaceutical)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductPharmaceutical(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(administrableDoseFormElement, o.administrableDoseFormElement, true) and 
      compareDeep(unitOfPresentationElement, o.unitOfPresentationElement, true) and 
      compareDeep(ingredientList, o.ingredientList, true) and compareDeep(deviceList, o.deviceList, true) and 
      compareDeep(characteristicsList, o.characteristicsList, true) and compareDeep(routeOfAdministrationList, o.routeOfAdministrationList, true);
  end;
end;

function TFhirMedicinalProductPharmaceutical.Link : TFhirMedicinalProductPharmaceutical;
begin
  result := TFhirMedicinalProductPharmaceutical(inherited Link);
end;

function TFhirMedicinalProductPharmaceutical.Clone : TFhirMedicinalProductPharmaceutical;
begin
  result := TFhirMedicinalProductPharmaceutical(inherited Clone);
end;

procedure TFhirMedicinalProductPharmaceutical.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('administrableDoseForm');
  fields.add('unitOfPresentation');
  fields.add('ingredient');
  fields.add('device');
  fields.add('characteristics');
  fields.add('routeOfAdministration');
end;

{ TFhirMedicinalProductPharmaceutical }

Function TFhirMedicinalProductPharmaceutical.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirMedicinalProductPharmaceutical.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirMedicinalProductPharmaceutical.SetAdministrableDoseForm(value : TFhirCodeableConcept);
begin
  FAdministrableDoseForm.free;
  FAdministrableDoseForm := value;
end;

Procedure TFhirMedicinalProductPharmaceutical.SetUnitOfPresentation(value : TFhirCodeableConcept);
begin
  FUnitOfPresentation.free;
  FUnitOfPresentation := value;
end;

Function TFhirMedicinalProductPharmaceutical.GetIngredientList : TFhirReferenceList{TFhirMedicinalProductIngredient};
begin
  if FIngredientList = nil then
    FIngredientList := TFhirReferenceList{TFhirMedicinalProductIngredient}.Create;
  result := FIngredientList;
end;

Function TFhirMedicinalProductPharmaceutical.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

Function TFhirMedicinalProductPharmaceutical.GetDeviceList : TFhirReferenceList{TFhirDeviceDefinition};
begin
  if FDeviceList = nil then
    FDeviceList := TFhirReferenceList{TFhirDeviceDefinition}.Create;
  result := FDeviceList;
end;

Function TFhirMedicinalProductPharmaceutical.GetHasDeviceList : boolean;
begin
  result := (FDeviceList <> nil) and (FDeviceList.count > 0);
end;

Function TFhirMedicinalProductPharmaceutical.GetCharacteristicsList : TFhirMedicinalProductPharmaceuticalCharacteristicsList;
begin
  if FCharacteristicsList = nil then
    FCharacteristicsList := TFhirMedicinalProductPharmaceuticalCharacteristicsList.Create;
  result := FCharacteristicsList;
end;

Function TFhirMedicinalProductPharmaceutical.GetHasCharacteristicsList : boolean;
begin
  result := (FCharacteristicsList <> nil) and (FCharacteristicsList.count > 0);
end;

Function TFhirMedicinalProductPharmaceutical.GetRouteOfAdministrationList : TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList;
begin
  if FRouteOfAdministrationList = nil then
    FRouteOfAdministrationList := TFhirMedicinalProductPharmaceuticalRouteOfAdministrationList.Create;
  result := FRouteOfAdministrationList;
end;

Function TFhirMedicinalProductPharmaceutical.GetHasRouteOfAdministrationList : boolean;
begin
  result := (FRouteOfAdministrationList <> nil) and (FRouteOfAdministrationList.count > 0);
end;

function TFhirMedicinalProductPharmaceutical.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FAdministrableDoseForm.sizeInBytes);
  inc(result, FUnitOfPresentation.sizeInBytes);
  inc(result, FingredientList.sizeInBytes);
  inc(result, FdeviceList.sizeInBytes);
  inc(result, FcharacteristicsList.sizeInBytes);
  inc(result, FrouteOfAdministrationList.sizeInBytes);
end;

{ TFhirMedicinalProductPharmaceuticalListEnumerator }

Constructor TFhirMedicinalProductPharmaceuticalListEnumerator.Create(list : TFhirMedicinalProductPharmaceuticalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductPharmaceuticalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductPharmaceuticalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductPharmaceuticalListEnumerator.GetCurrent : TFhirMedicinalProductPharmaceutical;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductPharmaceuticalListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductPharmaceuticalList }
procedure TFhirMedicinalProductPharmaceuticalList.AddItem(value: TFhirMedicinalProductPharmaceutical);
begin
  assert(value.ClassName = 'TFhirMedicinalProductPharmaceutical', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductPharmaceutical');
  add(value);
end;

function TFhirMedicinalProductPharmaceuticalList.Append: TFhirMedicinalProductPharmaceutical;
begin
  result := TFhirMedicinalProductPharmaceutical.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductPharmaceuticalList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductPharmaceuticalList.GetEnumerator : TFhirMedicinalProductPharmaceuticalListEnumerator;
begin
  result := TFhirMedicinalProductPharmaceuticalListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductPharmaceuticalList.Clone: TFhirMedicinalProductPharmaceuticalList;
begin
  result := TFhirMedicinalProductPharmaceuticalList(inherited Clone);
end;

function TFhirMedicinalProductPharmaceuticalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductPharmaceuticalList.GetItemN(index: Integer): TFhirMedicinalProductPharmaceutical;
begin
  result := TFhirMedicinalProductPharmaceutical(ObjectByIndex[index]);
end;

function TFhirMedicinalProductPharmaceuticalList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductPharmaceutical;
end;
function TFhirMedicinalProductPharmaceuticalList.IndexOf(value: TFhirMedicinalProductPharmaceutical): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductPharmaceuticalList.Insert(index: Integer): TFhirMedicinalProductPharmaceutical;
begin
  result := TFhirMedicinalProductPharmaceutical.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductPharmaceuticalList.InsertItem(index: Integer; value: TFhirMedicinalProductPharmaceutical);
begin
  assert(value is TFhirMedicinalProductPharmaceutical);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductPharmaceuticalList.Item(index: Integer): TFhirMedicinalProductPharmaceutical;
begin
  result := TFhirMedicinalProductPharmaceutical(ObjectByIndex[index]);
end;

function TFhirMedicinalProductPharmaceuticalList.Link: TFhirMedicinalProductPharmaceuticalList;
begin
  result := TFhirMedicinalProductPharmaceuticalList(inherited Link);
end;

procedure TFhirMedicinalProductPharmaceuticalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductPharmaceuticalList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductPharmaceutical);
begin
  assert(value is TFhirMedicinalProductPharmaceutical);
  FhirMedicinalProductPharmaceuticals[index] := value;
end;

procedure TFhirMedicinalProductPharmaceuticalList.SetItemN(index: Integer; value: TFhirMedicinalProductPharmaceutical);
begin
  assert(value is TFhirMedicinalProductPharmaceutical);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICINALPRODUCTPHARMACEUTICAL}

{$IFDEF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}

{ TFhirMedicinalProductUndesirableEffect }

constructor TFhirMedicinalProductUndesirableEffect.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductUndesirableEffect.Destroy;
begin
  FSubjectList.Free;
  FSymptomConditionEffect.free;
  FClassification.free;
  FFrequencyOfOccurrence.free;
  FPopulationList.Free;
  inherited;
end;

function TFhirMedicinalProductUndesirableEffect.GetResourceType : TFhirResourceType;
begin
  result := frtMedicinalProductUndesirableEffect;
end;

procedure TFhirMedicinalProductUndesirableEffect.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicinalProductUndesirableEffect(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirReferenceList{TFhirMedicinalProduct}.Create;
    FSubjectList.Assign(TFhirMedicinalProductUndesirableEffect(oSource).FSubjectList);
  end;
  symptomConditionEffect := TFhirMedicinalProductUndesirableEffect(oSource).symptomConditionEffect.Clone;
  classification := TFhirMedicinalProductUndesirableEffect(oSource).classification.Clone;
  frequencyOfOccurrence := TFhirMedicinalProductUndesirableEffect(oSource).frequencyOfOccurrence.Clone;
  if (TFhirMedicinalProductUndesirableEffect(oSource).FPopulationList = nil) then
  begin
    FPopulationList.free;
    FPopulationList := nil;
  end
  else
  begin
    if FPopulationList = nil then
      FPopulationList := TFhirPopulationList.Create;
    FPopulationList.Assign(TFhirMedicinalProductUndesirableEffect(oSource).FPopulationList);
  end;
end;

procedure TFhirMedicinalProductUndesirableEffect.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'symptomConditionEffect') Then
     list.add(self.link, 'symptomConditionEffect', FSymptomConditionEffect.Link);
  if (child_name = 'classification') Then
     list.add(self.link, 'classification', FClassification.Link);
  if (child_name = 'frequencyOfOccurrence') Then
     list.add(self.link, 'frequencyOfOccurrence', FFrequencyOfOccurrence.Link);
  if (child_name = 'population') Then
    list.addAll(self, 'population', FPopulationList);
end;

procedure TFhirMedicinalProductUndesirableEffect.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(MedicinalProduct)', true, TFhirReference{TFhirMedicinalProduct}, FSubjectList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'symptomConditionEffect', 'CodeableConcept', false, TFhirCodeableConcept, FSymptomConditionEffect.Link));{2}
  oList.add(TFHIRProperty.create(self, 'classification', 'CodeableConcept', false, TFhirCodeableConcept, FClassification.Link));{2}
  oList.add(TFHIRProperty.create(self, 'frequencyOfOccurrence', 'CodeableConcept', false, TFhirCodeableConcept, FFrequencyOfOccurrence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'population', 'Population', true, TFhirPopulation, FPopulationList.Link)){3};
end;

function TFhirMedicinalProductUndesirableEffect.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirReference{TFhirMedicinalProduct}){2a};
    result := propValue;
  end
  else if (propName = 'symptomConditionEffect') then
  begin
    SymptomConditionEffect := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'classification') then
  begin
    Classification := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'frequencyOfOccurrence') then
  begin
    FrequencyOfOccurrence := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'population') then
  begin
    PopulationList.add(propValue as TFhirPopulation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedicinalProductUndesirableEffect.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirReference{TFhirMedicinalProduct}){2a}
  else if (propName = 'population') then PopulationList.insertItem(index, propValue as TFhirPopulation){2a}
  else inherited;
end;

function TFhirMedicinalProductUndesirableEffect.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'subject') then result := SubjectList.new(){2}
  else if (propName = 'symptomConditionEffect') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'classification') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'frequencyOfOccurrence') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'population') then result := PopulationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductUndesirableEffect.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'subject') then result := 'Reference'
  else if (propName = 'symptomConditionEffect') then result := 'CodeableConcept'
  else if (propName = 'classification') then result := 'CodeableConcept'
  else if (propName = 'frequencyOfOccurrence') then result := 'CodeableConcept'
  else if (propName = 'population') then result := 'Population'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductUndesirableEffect.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value) {2}
  else if (propName = 'symptomConditionEffect') then SymptomConditionEffectElement := nil
  else if (propName = 'classification') then ClassificationElement := nil
  else if (propName = 'frequencyOfOccurrence') then FrequencyOfOccurrenceElement := nil
  else if (propName = 'population') then deletePropertyValue('population', PopulationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductUndesirableEffect.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new) {2}
  else if (propName = 'symptomConditionEffect') then SymptomConditionEffectElement := new as TFhirCodeableConcept{4}
  else if (propName = 'classification') then ClassificationElement := new as TFhirCodeableConcept{4}
  else if (propName = 'frequencyOfOccurrence') then FrequencyOfOccurrenceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'population') then replacePropertyValue('population', PopulationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductUndesirableEffect.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'subject') then SubjectList.move(source, destination){2a}
  else if (propName = 'population') then PopulationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductUndesirableEffect.fhirType : string;
begin
  result := 'MedicinalProductUndesirableEffect';
end;

function TFhirMedicinalProductUndesirableEffect.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FsubjectList) and isEmptyProp(FSymptomConditionEffect) and isEmptyProp(FClassification) and isEmptyProp(FFrequencyOfOccurrence) and isEmptyProp(FpopulationList);
end;

function TFhirMedicinalProductUndesirableEffect.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductUndesirableEffect;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductUndesirableEffect)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductUndesirableEffect(other);
    result := compareDeep(subjectList, o.subjectList, true) and compareDeep(symptomConditionEffectElement, o.symptomConditionEffectElement, true) and 
      compareDeep(classificationElement, o.classificationElement, true) and compareDeep(frequencyOfOccurrenceElement, o.frequencyOfOccurrenceElement, true) and 
      compareDeep(populationList, o.populationList, true);
  end;
end;

function TFhirMedicinalProductUndesirableEffect.Link : TFhirMedicinalProductUndesirableEffect;
begin
  result := TFhirMedicinalProductUndesirableEffect(inherited Link);
end;

function TFhirMedicinalProductUndesirableEffect.Clone : TFhirMedicinalProductUndesirableEffect;
begin
  result := TFhirMedicinalProductUndesirableEffect(inherited Clone);
end;

procedure TFhirMedicinalProductUndesirableEffect.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('subject');
  fields.add('symptomConditionEffect');
  fields.add('classification');
  fields.add('frequencyOfOccurrence');
  fields.add('population');
end;

{ TFhirMedicinalProductUndesirableEffect }

Function TFhirMedicinalProductUndesirableEffect.GetSubjectList : TFhirReferenceList{TFhirMedicinalProduct};
begin
  if FSubjectList = nil then
    FSubjectList := TFhirReferenceList{TFhirMedicinalProduct}.Create;
  result := FSubjectList;
end;

Function TFhirMedicinalProductUndesirableEffect.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

Procedure TFhirMedicinalProductUndesirableEffect.SetSymptomConditionEffect(value : TFhirCodeableConcept);
begin
  FSymptomConditionEffect.free;
  FSymptomConditionEffect := value;
end;

Procedure TFhirMedicinalProductUndesirableEffect.SetClassification(value : TFhirCodeableConcept);
begin
  FClassification.free;
  FClassification := value;
end;

Procedure TFhirMedicinalProductUndesirableEffect.SetFrequencyOfOccurrence(value : TFhirCodeableConcept);
begin
  FFrequencyOfOccurrence.free;
  FFrequencyOfOccurrence := value;
end;

Function TFhirMedicinalProductUndesirableEffect.GetPopulationList : TFhirPopulationList;
begin
  if FPopulationList = nil then
    FPopulationList := TFhirPopulationList.Create;
  result := FPopulationList;
end;

Function TFhirMedicinalProductUndesirableEffect.GetHasPopulationList : boolean;
begin
  result := (FPopulationList <> nil) and (FPopulationList.count > 0);
end;

function TFhirMedicinalProductUndesirableEffect.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FsubjectList.sizeInBytes);
  inc(result, FSymptomConditionEffect.sizeInBytes);
  inc(result, FClassification.sizeInBytes);
  inc(result, FFrequencyOfOccurrence.sizeInBytes);
  inc(result, FpopulationList.sizeInBytes);
end;

{ TFhirMedicinalProductUndesirableEffectListEnumerator }

Constructor TFhirMedicinalProductUndesirableEffectListEnumerator.Create(list : TFhirMedicinalProductUndesirableEffectList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductUndesirableEffectListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductUndesirableEffectListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductUndesirableEffectListEnumerator.GetCurrent : TFhirMedicinalProductUndesirableEffect;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductUndesirableEffectListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicinalProductUndesirableEffectList }
procedure TFhirMedicinalProductUndesirableEffectList.AddItem(value: TFhirMedicinalProductUndesirableEffect);
begin
  assert(value.ClassName = 'TFhirMedicinalProductUndesirableEffect', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductUndesirableEffect');
  add(value);
end;

function TFhirMedicinalProductUndesirableEffectList.Append: TFhirMedicinalProductUndesirableEffect;
begin
  result := TFhirMedicinalProductUndesirableEffect.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductUndesirableEffectList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductUndesirableEffectList.GetEnumerator : TFhirMedicinalProductUndesirableEffectListEnumerator;
begin
  result := TFhirMedicinalProductUndesirableEffectListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductUndesirableEffectList.Clone: TFhirMedicinalProductUndesirableEffectList;
begin
  result := TFhirMedicinalProductUndesirableEffectList(inherited Clone);
end;

function TFhirMedicinalProductUndesirableEffectList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductUndesirableEffectList.GetItemN(index: Integer): TFhirMedicinalProductUndesirableEffect;
begin
  result := TFhirMedicinalProductUndesirableEffect(ObjectByIndex[index]);
end;

function TFhirMedicinalProductUndesirableEffectList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductUndesirableEffect;
end;
function TFhirMedicinalProductUndesirableEffectList.IndexOf(value: TFhirMedicinalProductUndesirableEffect): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductUndesirableEffectList.Insert(index: Integer): TFhirMedicinalProductUndesirableEffect;
begin
  result := TFhirMedicinalProductUndesirableEffect.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductUndesirableEffectList.InsertItem(index: Integer; value: TFhirMedicinalProductUndesirableEffect);
begin
  assert(value is TFhirMedicinalProductUndesirableEffect);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductUndesirableEffectList.Item(index: Integer): TFhirMedicinalProductUndesirableEffect;
begin
  result := TFhirMedicinalProductUndesirableEffect(ObjectByIndex[index]);
end;

function TFhirMedicinalProductUndesirableEffectList.Link: TFhirMedicinalProductUndesirableEffectList;
begin
  result := TFhirMedicinalProductUndesirableEffectList(inherited Link);
end;

procedure TFhirMedicinalProductUndesirableEffectList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductUndesirableEffectList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductUndesirableEffect);
begin
  assert(value is TFhirMedicinalProductUndesirableEffect);
  FhirMedicinalProductUndesirableEffects[index] := value;
end;

procedure TFhirMedicinalProductUndesirableEffectList.SetItemN(index: Integer; value: TFhirMedicinalProductUndesirableEffect);
begin
  assert(value is TFhirMedicinalProductUndesirableEffect);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICINALPRODUCTUNDESIRABLEEFFECT}

{$IFDEF FHIR_SUBSTANCE}

{ TFhirSubstanceInstance }

constructor TFhirSubstanceInstance.Create;
begin
  inherited;
end;

destructor TFhirSubstanceInstance.Destroy;
begin
  FIdentifier.free;
  FExpiry.free;
  FQuantity.free;
  inherited;
end;

procedure TFhirSubstanceInstance.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirSubstanceInstance(oSource).identifier.Clone;
  expiryElement := TFhirSubstanceInstance(oSource).expiryElement.Clone;
  quantity := TFhirSubstanceInstance(oSource).quantity.Clone;
end;

procedure TFhirSubstanceInstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'expiry') Then
     list.add(self.link, 'expiry', FExpiry.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
end;

procedure TFhirSubstanceInstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expiry', 'dateTime', false, TFhirDateTime, FExpiry.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
end;

function TFhirSubstanceInstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'expiry') then
  begin
    ExpiryElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceInstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceInstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'expiry') then result := TFhirDateTime.create() {5b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceInstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'expiry') then result := 'dateTime'
  else if (propName = 'quantity') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceInstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'expiry') then ExpiryElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceInstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'expiry') then ExpiryElement := asDateTime(new){5b}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceInstance.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceInstance.fhirType : string;
begin
  result := 'instance';
end;

function TFhirSubstanceInstance.Link : TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance(inherited Link);
end;

function TFhirSubstanceInstance.Clone : TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance(inherited Clone);
end;

function TFhirSubstanceInstance.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceInstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceInstance)) then
    result := false
  else
  begin
    o := TFhirSubstanceInstance(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(expiryElement, o.expiryElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true);
  end;
end;

function TFhirSubstanceInstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FExpiry) and isEmptyProp(FQuantity);
end;

procedure TFhirSubstanceInstance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('expiry');
  fields.add('quantity');
end;

{ TFhirSubstanceInstance }

Procedure TFhirSubstanceInstance.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirSubstanceInstance.SetExpiry(value : TFhirDateTime);
begin
  FExpiry.free;
  FExpiry := value;
end;

Function TFhirSubstanceInstance.GetExpiryST : TFslDateTime;
begin
  if FExpiry = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpiry.value;
end;

Procedure TFhirSubstanceInstance.SetExpiryST(value : TFslDateTime);
begin
  if FExpiry = nil then
    FExpiry := TFhirDateTime.create;
  FExpiry.value := value
end;

Procedure TFhirSubstanceInstance.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

function TFhirSubstanceInstance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FExpiry.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
end;

{ TFhirSubstanceInstanceListEnumerator }

Constructor TFhirSubstanceInstanceListEnumerator.Create(list : TFhirSubstanceInstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceInstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceInstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceInstanceListEnumerator.GetCurrent : TFhirSubstanceInstance;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceInstanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceInstanceList }
procedure TFhirSubstanceInstanceList.AddItem(value: TFhirSubstanceInstance);
begin
  assert(value.ClassName = 'TFhirSubstanceInstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceInstance');
  add(value);
end;

function TFhirSubstanceInstanceList.Append: TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceInstanceList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceInstanceList.GetEnumerator : TFhirSubstanceInstanceListEnumerator;
begin
  result := TFhirSubstanceInstanceListEnumerator.Create(self.link);
end;

function TFhirSubstanceInstanceList.Clone: TFhirSubstanceInstanceList;
begin
  result := TFhirSubstanceInstanceList(inherited Clone);
end;

function TFhirSubstanceInstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceInstanceList.GetItemN(index: Integer): TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance(ObjectByIndex[index]);
end;

function TFhirSubstanceInstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceInstance;
end;
function TFhirSubstanceInstanceList.IndexOf(value: TFhirSubstanceInstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceInstanceList.Insert(index: Integer): TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceInstanceList.InsertItem(index: Integer; value: TFhirSubstanceInstance);
begin
  assert(value is TFhirSubstanceInstance);
  Inherited Insert(index, value);
end;

function TFhirSubstanceInstanceList.Item(index: Integer): TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance(ObjectByIndex[index]);
end;

function TFhirSubstanceInstanceList.Link: TFhirSubstanceInstanceList;
begin
  result := TFhirSubstanceInstanceList(inherited Link);
end;

procedure TFhirSubstanceInstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceInstanceList.SetItemByIndex(index: Integer; value: TFhirSubstanceInstance);
begin
  assert(value is TFhirSubstanceInstance);
  FhirSubstanceInstances[index] := value;
end;

procedure TFhirSubstanceInstanceList.SetItemN(index: Integer; value: TFhirSubstanceInstance);
begin
  assert(value is TFhirSubstanceInstance);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceIngredient }

constructor TFhirSubstanceIngredient.Create;
begin
  inherited;
end;

destructor TFhirSubstanceIngredient.Destroy;
begin
  FQuantity.free;
  FSubstance.free;
  inherited;
end;

procedure TFhirSubstanceIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  quantity := TFhirSubstanceIngredient(oSource).quantity.Clone;
  substance := TFhirSubstanceIngredient(oSource).substance.Clone;
end;

procedure TFhirSubstanceIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'substance[x]') or (child_name = 'substance') Then
     list.add(self.link, 'substance[x]', FSubstance.Link);
end;

procedure TFhirSubstanceIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'quantity', 'Ratio', false, TFhirRatio, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'substance[x]', 'CodeableConcept|Reference(Substance)', false, TFhirType, FSubstance.Link));{2}
end;

function TFhirSubstanceIngredient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirRatio{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'substance', ['CodeableConcept', 'Reference'])) then
  begin
    Substance := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceIngredient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'quantity') then result := TFhirRatio.create(){4b}
  else if (isMatchingName(propName, 'substance', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Substance'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'quantity') then result := 'Ratio'
  else if (propName = 'substance[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceIngredient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := nil
  else if (isMatchingName(propName, 'substance', ['CodeableConcept', 'Reference'])) then SubstanceElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := new as TFhirRatio{4}
  else if (isMatchingName(propName, 'substance', ['CodeableConcept', 'Reference'])) then SubstanceElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceIngredient.fhirType : string;
begin
  result := 'ingredient';
end;

function TFhirSubstanceIngredient.Link : TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(inherited Link);
end;

function TFhirSubstanceIngredient.Clone : TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(inherited Clone);
end;

function TFhirSubstanceIngredient.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceIngredient)) then
    result := false
  else
  begin
    o := TFhirSubstanceIngredient(other);
    result := compareDeep(quantityElement, o.quantityElement, true) and compareDeep(substanceElement, o.substanceElement, true);
  end;
end;

function TFhirSubstanceIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FQuantity) and isEmptyProp(FSubstance);
end;

procedure TFhirSubstanceIngredient.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('quantity');
  fields.add('substance[x]');
end;

{ TFhirSubstanceIngredient }

Procedure TFhirSubstanceIngredient.SetQuantity(value : TFhirRatio);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirSubstanceIngredient.SetSubstance(value : TFhirType);
begin
  FSubstance.free;
  FSubstance := value;
end;

function TFhirSubstanceIngredient.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FQuantity.sizeInBytes);
  inc(result, FSubstance.sizeInBytes);
end;

{ TFhirSubstanceIngredientListEnumerator }

Constructor TFhirSubstanceIngredientListEnumerator.Create(list : TFhirSubstanceIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceIngredientListEnumerator.GetCurrent : TFhirSubstanceIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceIngredientListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceIngredientList }
procedure TFhirSubstanceIngredientList.AddItem(value: TFhirSubstanceIngredient);
begin
  assert(value.ClassName = 'TFhirSubstanceIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceIngredient');
  add(value);
end;

function TFhirSubstanceIngredientList.Append: TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceIngredientList.GetEnumerator : TFhirSubstanceIngredientListEnumerator;
begin
  result := TFhirSubstanceIngredientListEnumerator.Create(self.link);
end;

function TFhirSubstanceIngredientList.Clone: TFhirSubstanceIngredientList;
begin
  result := TFhirSubstanceIngredientList(inherited Clone);
end;

function TFhirSubstanceIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceIngredientList.GetItemN(index: Integer): TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(ObjectByIndex[index]);
end;

function TFhirSubstanceIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceIngredient;
end;
function TFhirSubstanceIngredientList.IndexOf(value: TFhirSubstanceIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceIngredientList.Insert(index: Integer): TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceIngredientList.InsertItem(index: Integer; value: TFhirSubstanceIngredient);
begin
  assert(value is TFhirSubstanceIngredient);
  Inherited Insert(index, value);
end;

function TFhirSubstanceIngredientList.Item(index: Integer): TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(ObjectByIndex[index]);
end;

function TFhirSubstanceIngredientList.Link: TFhirSubstanceIngredientList;
begin
  result := TFhirSubstanceIngredientList(inherited Link);
end;

procedure TFhirSubstanceIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceIngredientList.SetItemByIndex(index: Integer; value: TFhirSubstanceIngredient);
begin
  assert(value is TFhirSubstanceIngredient);
  FhirSubstanceIngredients[index] := value;
end;

procedure TFhirSubstanceIngredientList.SetItemN(index: Integer; value: TFhirSubstanceIngredient);
begin
  assert(value is TFhirSubstanceIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstance }

constructor TFhirSubstance.Create;
begin
  inherited;
end;

destructor TFhirSubstance.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCategoryList.Free;
  FCode.free;
  FDescription.free;
  FInstanceList.Free;
  FIngredientList.Free;
  inherited;
end;

function TFhirSubstance.GetResourceType : TFhirResourceType;
begin
  result := frtSubstance;
end;

procedure TFhirSubstance.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSubstance(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSubstance(oSource).FIdentifierList);
  end;
  FStatus := TFhirSubstance(oSource).FStatus.Link;
  if (TFhirSubstance(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirSubstance(oSource).FCategoryList);
  end;
  code := TFhirSubstance(oSource).code.Clone;
  descriptionElement := TFhirSubstance(oSource).descriptionElement.Clone;
  if (TFhirSubstance(oSource).FInstanceList = nil) then
  begin
    FInstanceList.free;
    FInstanceList := nil;
  end
  else
  begin
    if FInstanceList = nil then
      FInstanceList := TFhirSubstanceInstanceList.Create;
    FInstanceList.Assign(TFhirSubstance(oSource).FInstanceList);
  end;
  if (TFhirSubstance(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirSubstanceIngredientList.Create;
    FIngredientList.Assign(TFhirSubstance(oSource).FIngredientList);
  end;
end;

procedure TFhirSubstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'instance') Then
    list.addAll(self, 'instance', FInstanceList);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
end;

procedure TFhirSubstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'instance', '', true, TFhirSubstanceInstance, FInstanceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'ingredient', '', true, TFhirSubstanceIngredient, FIngredientList.Link)){3};
end;

function TFhirSubstance.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSubstanceStatusEnum, CODES_TFhirSubstanceStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'instance') then
  begin
    InstanceList.add(propValue as TFhirSubstanceInstance){2a};
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirSubstanceIngredient){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSubstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'instance') then InstanceList.insertItem(index, propValue as TFhirSubstanceInstance){2a}
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirSubstanceIngredient){2a}
  else inherited;
end;

function TFhirSubstance.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'category') then result := CategoryList.new(){2}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'instance') then result := InstanceList.new(){2}
  else if (propName = 'ingredient') then result := IngredientList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'instance') then result := ''
  else if (propName = 'ingredient') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstance.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {2}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'instance') then deletePropertyValue('instance', InstanceList, value) {2}
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSubstanceStatusEnum, CODES_TFhirSubstanceStatusEnum, new){4}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {2}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'instance') then replacePropertyValue('instance', InstanceList, existing, new) {2}
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'category') then CategoryList.move(source, destination){2a}
  else if (propName = 'instance') then InstanceList.move(source, destination){2a}
  else if (propName = 'ingredient') then IngredientList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstance.fhirType : string;
begin
  result := 'Substance';
end;

function TFhirSubstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FCode) and isEmptyProp(FDescription) and isEmptyProp(FinstanceList) and isEmptyProp(FingredientList);
end;

function TFhirSubstance.equals(other : TObject) : boolean; 
var
  o : TFhirSubstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstance)) then
    result := false
  else
  begin
    o := TFhirSubstance(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(instanceList, o.instanceList, true) and 
      compareDeep(ingredientList, o.ingredientList, true);
  end;
end;

function TFhirSubstance.Link : TFhirSubstance;
begin
  result := TFhirSubstance(inherited Link);
end;

function TFhirSubstance.Clone : TFhirSubstance;
begin
  result := TFhirSubstance(inherited Clone);
end;

procedure TFhirSubstance.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('category');
  fields.add('code');
  fields.add('description');
  fields.add('instance');
  fields.add('ingredient');
end;

{ TFhirSubstance }

Function TFhirSubstance.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirSubstance.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirSubstance.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirSubstance.GetStatusST : TFhirSubstanceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSubstanceStatusEnum(0)
  else
    result := TFhirSubstanceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSubstanceStatusEnum, FStatus.value));
end;

Procedure TFhirSubstance.SetStatusST(value : TFhirSubstanceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSubstanceStatusEnum[value], CODES_TFhirSubstanceStatusEnum[value]);
end;

Function TFhirSubstance.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

Function TFhirSubstance.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

Procedure TFhirSubstance.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirSubstance.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirSubstance.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirSubstance.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirSubstance.GetInstanceList : TFhirSubstanceInstanceList;
begin
  if FInstanceList = nil then
    FInstanceList := TFhirSubstanceInstanceList.Create;
  result := FInstanceList;
end;

Function TFhirSubstance.GetHasInstanceList : boolean;
begin
  result := (FInstanceList <> nil) and (FInstanceList.count > 0);
end;

Function TFhirSubstance.GetIngredientList : TFhirSubstanceIngredientList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirSubstanceIngredientList.Create;
  result := FIngredientList;
end;

Function TFhirSubstance.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

function TFhirSubstance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FinstanceList.sizeInBytes);
  inc(result, FingredientList.sizeInBytes);
end;

{ TFhirSubstanceListEnumerator }

Constructor TFhirSubstanceListEnumerator.Create(list : TFhirSubstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceListEnumerator.GetCurrent : TFhirSubstance;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceList }
procedure TFhirSubstanceList.AddItem(value: TFhirSubstance);
begin
  assert(value.ClassName = 'TFhirSubstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstance');
  add(value);
end;

function TFhirSubstanceList.Append: TFhirSubstance;
begin
  result := TFhirSubstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceList.GetEnumerator : TFhirSubstanceListEnumerator;
begin
  result := TFhirSubstanceListEnumerator.Create(self.link);
end;

function TFhirSubstanceList.Clone: TFhirSubstanceList;
begin
  result := TFhirSubstanceList(inherited Clone);
end;

function TFhirSubstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceList.GetItemN(index: Integer): TFhirSubstance;
begin
  result := TFhirSubstance(ObjectByIndex[index]);
end;

function TFhirSubstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstance;
end;
function TFhirSubstanceList.IndexOf(value: TFhirSubstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceList.Insert(index: Integer): TFhirSubstance;
begin
  result := TFhirSubstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceList.InsertItem(index: Integer; value: TFhirSubstance);
begin
  assert(value is TFhirSubstance);
  Inherited Insert(index, value);
end;

function TFhirSubstanceList.Item(index: Integer): TFhirSubstance;
begin
  result := TFhirSubstance(ObjectByIndex[index]);
end;

function TFhirSubstanceList.Link: TFhirSubstanceList;
begin
  result := TFhirSubstanceList(inherited Link);
end;

procedure TFhirSubstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceList.SetItemByIndex(index: Integer; value: TFhirSubstance);
begin
  assert(value is TFhirSubstance);
  FhirSubstances[index] := value;
end;

procedure TFhirSubstanceList.SetItemN(index: Integer; value: TFhirSubstance);
begin
  assert(value is TFhirSubstance);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCE}

{$IFDEF FHIR_SUBSTANCENUCLEICACID}

{ TFhirSubstanceNucleicAcidSubunit }

constructor TFhirSubstanceNucleicAcidSubunit.Create;
begin
  inherited;
end;

destructor TFhirSubstanceNucleicAcidSubunit.Destroy;
begin
  FSubunit.free;
  FSequence.free;
  FLength.free;
  FSequenceAttachment.free;
  FFivePrime.free;
  FThreePrime.free;
  FLinkageList.Free;
  FSugarList.Free;
  inherited;
end;

procedure TFhirSubstanceNucleicAcidSubunit.Assign(oSource : TFslObject);
begin
  inherited;
  subunitElement := TFhirSubstanceNucleicAcidSubunit(oSource).subunitElement.Clone;
  sequenceElement := TFhirSubstanceNucleicAcidSubunit(oSource).sequenceElement.Clone;
  lengthElement := TFhirSubstanceNucleicAcidSubunit(oSource).lengthElement.Clone;
  sequenceAttachment := TFhirSubstanceNucleicAcidSubunit(oSource).sequenceAttachment.Clone;
  fivePrime := TFhirSubstanceNucleicAcidSubunit(oSource).fivePrime.Clone;
  threePrime := TFhirSubstanceNucleicAcidSubunit(oSource).threePrime.Clone;
  if (TFhirSubstanceNucleicAcidSubunit(oSource).FLinkageList = nil) then
  begin
    FLinkageList.free;
    FLinkageList := nil;
  end
  else
  begin
    if FLinkageList = nil then
      FLinkageList := TFhirSubstanceNucleicAcidSubunitLinkageList.Create;
    FLinkageList.Assign(TFhirSubstanceNucleicAcidSubunit(oSource).FLinkageList);
  end;
  if (TFhirSubstanceNucleicAcidSubunit(oSource).FSugarList = nil) then
  begin
    FSugarList.free;
    FSugarList := nil;
  end
  else
  begin
    if FSugarList = nil then
      FSugarList := TFhirSubstanceNucleicAcidSubunitSugarList.Create;
    FSugarList.Assign(TFhirSubstanceNucleicAcidSubunit(oSource).FSugarList);
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'subunit') Then
     list.add(self.link, 'subunit', FSubunit.Link);
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'length') Then
     list.add(self.link, 'length', FLength.Link);
  if (child_name = 'sequenceAttachment') Then
     list.add(self.link, 'sequenceAttachment', FSequenceAttachment.Link);
  if (child_name = 'fivePrime') Then
     list.add(self.link, 'fivePrime', FFivePrime.Link);
  if (child_name = 'threePrime') Then
     list.add(self.link, 'threePrime', FThreePrime.Link);
  if (child_name = 'linkage') Then
    list.addAll(self, 'linkage', FLinkageList);
  if (child_name = 'sugar') Then
    list.addAll(self, 'sugar', FSugarList);
end;

procedure TFhirSubstanceNucleicAcidSubunit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'subunit', 'integer', false, TFhirInteger, FSubunit.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sequence', 'string', false, TFhirString, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'length', 'integer', false, TFhirInteger, FLength.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sequenceAttachment', 'Attachment', false, TFhirAttachment, FSequenceAttachment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'fivePrime', 'CodeableConcept', false, TFhirCodeableConcept, FFivePrime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'threePrime', 'CodeableConcept', false, TFhirCodeableConcept, FThreePrime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'linkage', '', true, TFhirSubstanceNucleicAcidSubunitLinkage, FLinkageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'sugar', '', true, TFhirSubstanceNucleicAcidSubunitSugar, FSugarList.Link)){3};
end;

function TFhirSubstanceNucleicAcidSubunit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'subunit') then
  begin
    SubunitElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'sequence') then
  begin
    SequenceElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'length') then
  begin
    LengthElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'sequenceAttachment') then
  begin
    SequenceAttachment := propValue as TFhirAttachment{4b};
    result := propValue;
  end
  else if (propName = 'fivePrime') then
  begin
    FivePrime := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'threePrime') then
  begin
    ThreePrime := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'linkage') then
  begin
    LinkageList.add(propValue as TFhirSubstanceNucleicAcidSubunitLinkage){2a};
    result := propValue;
  end
  else if (propName = 'sugar') then
  begin
    SugarList.add(propValue as TFhirSubstanceNucleicAcidSubunitSugar){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceNucleicAcidSubunit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'linkage') then LinkageList.insertItem(index, propValue as TFhirSubstanceNucleicAcidSubunitLinkage){2a}
  else if (propName = 'sugar') then SugarList.insertItem(index, propValue as TFhirSubstanceNucleicAcidSubunitSugar){2a}
  else inherited;
end;

function TFhirSubstanceNucleicAcidSubunit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'subunit') then result := TFhirInteger.create() {5b}
  else if (propName = 'sequence') then result := TFhirString.create() {5b}
  else if (propName = 'length') then result := TFhirInteger.create() {5b}
  else if (propName = 'sequenceAttachment') then result := TFhirAttachment.create(){4b}
  else if (propName = 'fivePrime') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'threePrime') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'linkage') then result := LinkageList.new(){2}
  else if (propName = 'sugar') then result := SugarList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceNucleicAcidSubunit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'subunit') then result := 'integer'
  else if (propName = 'sequence') then result := 'string'
  else if (propName = 'length') then result := 'integer'
  else if (propName = 'sequenceAttachment') then result := 'Attachment'
  else if (propName = 'fivePrime') then result := 'CodeableConcept'
  else if (propName = 'threePrime') then result := 'CodeableConcept'
  else if (propName = 'linkage') then result := ''
  else if (propName = 'sugar') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceNucleicAcidSubunit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'subunit') then SubunitElement := nil
  else if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'length') then LengthElement := nil
  else if (propName = 'sequenceAttachment') then SequenceAttachmentElement := nil
  else if (propName = 'fivePrime') then FivePrimeElement := nil
  else if (propName = 'threePrime') then ThreePrimeElement := nil
  else if (propName = 'linkage') then deletePropertyValue('linkage', LinkageList, value) {2}
  else if (propName = 'sugar') then deletePropertyValue('sugar', SugarList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceNucleicAcidSubunit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'subunit') then SubunitElement := asInteger(new){5b}
  else if (propName = 'sequence') then SequenceElement := asString(new){5b}
  else if (propName = 'length') then LengthElement := asInteger(new){5b}
  else if (propName = 'sequenceAttachment') then SequenceAttachmentElement := new as TFhirAttachment{4}
  else if (propName = 'fivePrime') then FivePrimeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'threePrime') then ThreePrimeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'linkage') then replacePropertyValue('linkage', LinkageList, existing, new) {2}
  else if (propName = 'sugar') then replacePropertyValue('sugar', SugarList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceNucleicAcidSubunit.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'linkage') then LinkageList.move(source, destination){2a}
  else if (propName = 'sugar') then SugarList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceNucleicAcidSubunit.fhirType : string;
begin
  result := 'subunit';
end;

function TFhirSubstanceNucleicAcidSubunit.Link : TFhirSubstanceNucleicAcidSubunit;
begin
  result := TFhirSubstanceNucleicAcidSubunit(inherited Link);
end;

function TFhirSubstanceNucleicAcidSubunit.Clone : TFhirSubstanceNucleicAcidSubunit;
begin
  result := TFhirSubstanceNucleicAcidSubunit(inherited Clone);
end;

function TFhirSubstanceNucleicAcidSubunit.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceNucleicAcidSubunit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceNucleicAcidSubunit)) then
    result := false
  else
  begin
    o := TFhirSubstanceNucleicAcidSubunit(other);
    result := compareDeep(subunitElement, o.subunitElement, true) and compareDeep(sequenceElement, o.sequenceElement, true) and 
      compareDeep(lengthElement, o.lengthElement, true) and compareDeep(sequenceAttachmentElement, o.sequenceAttachmentElement, true) and 
      compareDeep(fivePrimeElement, o.fivePrimeElement, true) and compareDeep(threePrimeElement, o.threePrimeElement, true) and 
      compareDeep(linkageList, o.linkageList, true) and compareDeep(sugarList, o.sugarList, true);
  end;
end;

function TFhirSubstanceNucleicAcidSubunit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubunit) and isEmptyProp(FSequence) and isEmptyProp(FLength) and isEmptyProp(FSequenceAttachment) and isEmptyProp(FFivePrime) and isEmptyProp(FThreePrime) and isEmptyProp(FlinkageList) and isEmptyProp(FsugarList);
end;

procedure TFhirSubstanceNucleicAcidSubunit.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('subunit');
  fields.add('sequence');
  fields.add('length');
  fields.add('sequenceAttachment');
  fields.add('fivePrime');
  fields.add('threePrime');
  fields.add('linkage');
  fields.add('sugar');
end;

{ TFhirSubstanceNucleicAcidSubunit }

Procedure TFhirSubstanceNucleicAcidSubunit.SetSubunit(value : TFhirInteger);
begin
  FSubunit.free;
  FSubunit := value;
end;

Function TFhirSubstanceNucleicAcidSubunit.GetSubunitST : String;
begin
  if FSubunit = nil then
    result := ''
  else
    result := FSubunit.value;
end;

Procedure TFhirSubstanceNucleicAcidSubunit.SetSubunitST(value : String);
begin
  if value <> '' then
  begin
    if FSubunit = nil then
      FSubunit := TFhirInteger.create;
    FSubunit.value := value
  end
  else if FSubunit <> nil then
    FSubunit.value := '';
end;

Procedure TFhirSubstanceNucleicAcidSubunit.SetSequence(value : TFhirString);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirSubstanceNucleicAcidSubunit.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirSubstanceNucleicAcidSubunit.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirString.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirSubstanceNucleicAcidSubunit.SetLength(value : TFhirInteger);
begin
  FLength.free;
  FLength := value;
end;

Function TFhirSubstanceNucleicAcidSubunit.GetLengthST : String;
begin
  if FLength = nil then
    result := ''
  else
    result := FLength.value;
end;

Procedure TFhirSubstanceNucleicAcidSubunit.SetLengthST(value : String);
begin
  if value <> '' then
  begin
    if FLength = nil then
      FLength := TFhirInteger.create;
    FLength.value := value
  end
  else if FLength <> nil then
    FLength.value := '';
end;

Procedure TFhirSubstanceNucleicAcidSubunit.SetSequenceAttachment(value : TFhirAttachment);
begin
  FSequenceAttachment.free;
  FSequenceAttachment := value;
end;

Procedure TFhirSubstanceNucleicAcidSubunit.SetFivePrime(value : TFhirCodeableConcept);
begin
  FFivePrime.free;
  FFivePrime := value;
end;

Procedure TFhirSubstanceNucleicAcidSubunit.SetThreePrime(value : TFhirCodeableConcept);
begin
  FThreePrime.free;
  FThreePrime := value;
end;

Function TFhirSubstanceNucleicAcidSubunit.GetLinkageList : TFhirSubstanceNucleicAcidSubunitLinkageList;
begin
  if FLinkageList = nil then
    FLinkageList := TFhirSubstanceNucleicAcidSubunitLinkageList.Create;
  result := FLinkageList;
end;

Function TFhirSubstanceNucleicAcidSubunit.GetHasLinkageList : boolean;
begin
  result := (FLinkageList <> nil) and (FLinkageList.count > 0);
end;

Function TFhirSubstanceNucleicAcidSubunit.GetSugarList : TFhirSubstanceNucleicAcidSubunitSugarList;
begin
  if FSugarList = nil then
    FSugarList := TFhirSubstanceNucleicAcidSubunitSugarList.Create;
  result := FSugarList;
end;

Function TFhirSubstanceNucleicAcidSubunit.GetHasSugarList : boolean;
begin
  result := (FSugarList <> nil) and (FSugarList.count > 0);
end;

function TFhirSubstanceNucleicAcidSubunit.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSubunit.sizeInBytes);
  inc(result, FSequence.sizeInBytes);
  inc(result, FLength.sizeInBytes);
  inc(result, FSequenceAttachment.sizeInBytes);
  inc(result, FFivePrime.sizeInBytes);
  inc(result, FThreePrime.sizeInBytes);
  inc(result, FlinkageList.sizeInBytes);
  inc(result, FsugarList.sizeInBytes);
end;

{ TFhirSubstanceNucleicAcidSubunitListEnumerator }

Constructor TFhirSubstanceNucleicAcidSubunitListEnumerator.Create(list : TFhirSubstanceNucleicAcidSubunitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceNucleicAcidSubunitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceNucleicAcidSubunitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceNucleicAcidSubunitListEnumerator.GetCurrent : TFhirSubstanceNucleicAcidSubunit;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceNucleicAcidSubunitListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceNucleicAcidSubunitList }
procedure TFhirSubstanceNucleicAcidSubunitList.AddItem(value: TFhirSubstanceNucleicAcidSubunit);
begin
  assert(value.ClassName = 'TFhirSubstanceNucleicAcidSubunit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceNucleicAcidSubunit');
  add(value);
end;

function TFhirSubstanceNucleicAcidSubunitList.Append: TFhirSubstanceNucleicAcidSubunit;
begin
  result := TFhirSubstanceNucleicAcidSubunit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunitList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceNucleicAcidSubunitList.GetEnumerator : TFhirSubstanceNucleicAcidSubunitListEnumerator;
begin
  result := TFhirSubstanceNucleicAcidSubunitListEnumerator.Create(self.link);
end;

function TFhirSubstanceNucleicAcidSubunitList.Clone: TFhirSubstanceNucleicAcidSubunitList;
begin
  result := TFhirSubstanceNucleicAcidSubunitList(inherited Clone);
end;

function TFhirSubstanceNucleicAcidSubunitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceNucleicAcidSubunitList.GetItemN(index: Integer): TFhirSubstanceNucleicAcidSubunit;
begin
  result := TFhirSubstanceNucleicAcidSubunit(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidSubunitList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceNucleicAcidSubunit;
end;
function TFhirSubstanceNucleicAcidSubunitList.IndexOf(value: TFhirSubstanceNucleicAcidSubunit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceNucleicAcidSubunitList.Insert(index: Integer): TFhirSubstanceNucleicAcidSubunit;
begin
  result := TFhirSubstanceNucleicAcidSubunit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunitList.InsertItem(index: Integer; value: TFhirSubstanceNucleicAcidSubunit);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunit);
  Inherited Insert(index, value);
end;

function TFhirSubstanceNucleicAcidSubunitList.Item(index: Integer): TFhirSubstanceNucleicAcidSubunit;
begin
  result := TFhirSubstanceNucleicAcidSubunit(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidSubunitList.Link: TFhirSubstanceNucleicAcidSubunitList;
begin
  result := TFhirSubstanceNucleicAcidSubunitList(inherited Link);
end;

procedure TFhirSubstanceNucleicAcidSubunitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceNucleicAcidSubunitList.SetItemByIndex(index: Integer; value: TFhirSubstanceNucleicAcidSubunit);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunit);
  FhirSubstanceNucleicAcidSubunits[index] := value;
end;

procedure TFhirSubstanceNucleicAcidSubunitList.SetItemN(index: Integer; value: TFhirSubstanceNucleicAcidSubunit);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunit);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceNucleicAcidSubunitLinkage }

constructor TFhirSubstanceNucleicAcidSubunitLinkage.Create;
begin
  inherited;
end;

destructor TFhirSubstanceNucleicAcidSubunitLinkage.Destroy;
begin
  FConnectivity.free;
  FIdentifier.free;
  FName.free;
  FResidueSite.free;
  inherited;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.Assign(oSource : TFslObject);
begin
  inherited;
  connectivityElement := TFhirSubstanceNucleicAcidSubunitLinkage(oSource).connectivityElement.Clone;
  identifier := TFhirSubstanceNucleicAcidSubunitLinkage(oSource).identifier.Clone;
  nameElement := TFhirSubstanceNucleicAcidSubunitLinkage(oSource).nameElement.Clone;
  residueSiteElement := TFhirSubstanceNucleicAcidSubunitLinkage(oSource).residueSiteElement.Clone;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'connectivity') Then
     list.add(self.link, 'connectivity', FConnectivity.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'residueSite') Then
     list.add(self.link, 'residueSite', FResidueSite.Link);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'connectivity', 'string', false, TFhirString, FConnectivity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'residueSite', 'string', false, TFhirString, FResidueSite.Link));{2}
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'connectivity') then
  begin
    ConnectivityElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'residueSite') then
  begin
    ResidueSiteElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'connectivity') then result := TFhirString.create() {5b}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'residueSite') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'connectivity') then result := 'string'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'residueSite') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'connectivity') then ConnectivityElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'residueSite') then ResidueSiteElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'connectivity') then ConnectivityElement := asString(new){5b}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'residueSite') then ResidueSiteElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.fhirType : string;
begin
  result := 'linkage';
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.Link : TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage(inherited Link);
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.Clone : TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage(inherited Clone);
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceNucleicAcidSubunitLinkage)) then
    result := false
  else
  begin
    o := TFhirSubstanceNucleicAcidSubunitLinkage(other);
    result := compareDeep(connectivityElement, o.connectivityElement, true) and 
      compareDeep(identifierElement, o.identifierElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(residueSiteElement, o.residueSiteElement, true);
  end;
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FConnectivity) and isEmptyProp(FIdentifier) and isEmptyProp(FName) and isEmptyProp(FResidueSite);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('connectivity');
  fields.add('identifier');
  fields.add('name');
  fields.add('residueSite');
end;

{ TFhirSubstanceNucleicAcidSubunitLinkage }

Procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetConnectivity(value : TFhirString);
begin
  FConnectivity.free;
  FConnectivity := value;
end;

Function TFhirSubstanceNucleicAcidSubunitLinkage.GetConnectivityST : String;
begin
  if FConnectivity = nil then
    result := ''
  else
    result := FConnectivity.value;
end;

Procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetConnectivityST(value : String);
begin
  if value <> '' then
  begin
    if FConnectivity = nil then
      FConnectivity := TFhirString.create;
    FConnectivity.value := value
  end
  else if FConnectivity <> nil then
    FConnectivity.value := '';
end;

Procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirSubstanceNucleicAcidSubunitLinkage.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetResidueSite(value : TFhirString);
begin
  FResidueSite.free;
  FResidueSite := value;
end;

Function TFhirSubstanceNucleicAcidSubunitLinkage.GetResidueSiteST : String;
begin
  if FResidueSite = nil then
    result := ''
  else
    result := FResidueSite.value;
end;

Procedure TFhirSubstanceNucleicAcidSubunitLinkage.SetResidueSiteST(value : String);
begin
  if value <> '' then
  begin
    if FResidueSite = nil then
      FResidueSite := TFhirString.create;
    FResidueSite.value := value
  end
  else if FResidueSite <> nil then
    FResidueSite.value := '';
end;

function TFhirSubstanceNucleicAcidSubunitLinkage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FConnectivity.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FResidueSite.sizeInBytes);
end;

{ TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator }

Constructor TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator.Create(list : TFhirSubstanceNucleicAcidSubunitLinkageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator.GetCurrent : TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceNucleicAcidSubunitLinkageList }
procedure TFhirSubstanceNucleicAcidSubunitLinkageList.AddItem(value: TFhirSubstanceNucleicAcidSubunitLinkage);
begin
  assert(value.ClassName = 'TFhirSubstanceNucleicAcidSubunitLinkage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceNucleicAcidSubunitLinkage');
  add(value);
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.Append: TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkageList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.GetEnumerator : TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkageListEnumerator.Create(self.link);
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.Clone: TFhirSubstanceNucleicAcidSubunitLinkageList;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkageList(inherited Clone);
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.GetItemN(index: Integer): TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage;
end;
function TFhirSubstanceNucleicAcidSubunitLinkageList.IndexOf(value: TFhirSubstanceNucleicAcidSubunitLinkage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.Insert(index: Integer): TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkageList.InsertItem(index: Integer; value: TFhirSubstanceNucleicAcidSubunitLinkage);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunitLinkage);
  Inherited Insert(index, value);
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.Item(index: Integer): TFhirSubstanceNucleicAcidSubunitLinkage;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkage(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidSubunitLinkageList.Link: TFhirSubstanceNucleicAcidSubunitLinkageList;
begin
  result := TFhirSubstanceNucleicAcidSubunitLinkageList(inherited Link);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkageList.SetItemByIndex(index: Integer; value: TFhirSubstanceNucleicAcidSubunitLinkage);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunitLinkage);
  FhirSubstanceNucleicAcidSubunitLinkages[index] := value;
end;

procedure TFhirSubstanceNucleicAcidSubunitLinkageList.SetItemN(index: Integer; value: TFhirSubstanceNucleicAcidSubunitLinkage);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunitLinkage);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceNucleicAcidSubunitSugar }

constructor TFhirSubstanceNucleicAcidSubunitSugar.Create;
begin
  inherited;
end;

destructor TFhirSubstanceNucleicAcidSubunitSugar.Destroy;
begin
  FIdentifier.free;
  FName.free;
  FResidueSite.free;
  inherited;
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirSubstanceNucleicAcidSubunitSugar(oSource).identifier.Clone;
  nameElement := TFhirSubstanceNucleicAcidSubunitSugar(oSource).nameElement.Clone;
  residueSiteElement := TFhirSubstanceNucleicAcidSubunitSugar(oSource).residueSiteElement.Clone;
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'residueSite') Then
     list.add(self.link, 'residueSite', FResidueSite.Link);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'residueSite', 'string', false, TFhirString, FResidueSite.Link));{2}
end;

function TFhirSubstanceNucleicAcidSubunitSugar.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'residueSite') then
  begin
    ResidueSiteElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceNucleicAcidSubunitSugar.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'residueSite') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceNucleicAcidSubunitSugar.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'residueSite') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'residueSite') then ResidueSiteElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'residueSite') then ResidueSiteElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceNucleicAcidSubunitSugar.fhirType : string;
begin
  result := 'sugar';
end;

function TFhirSubstanceNucleicAcidSubunitSugar.Link : TFhirSubstanceNucleicAcidSubunitSugar;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar(inherited Link);
end;

function TFhirSubstanceNucleicAcidSubunitSugar.Clone : TFhirSubstanceNucleicAcidSubunitSugar;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar(inherited Clone);
end;

function TFhirSubstanceNucleicAcidSubunitSugar.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceNucleicAcidSubunitSugar;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceNucleicAcidSubunitSugar)) then
    result := false
  else
  begin
    o := TFhirSubstanceNucleicAcidSubunitSugar(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(residueSiteElement, o.residueSiteElement, true);
  end;
end;

function TFhirSubstanceNucleicAcidSubunitSugar.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FName) and isEmptyProp(FResidueSite);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugar.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('name');
  fields.add('residueSite');
end;

{ TFhirSubstanceNucleicAcidSubunitSugar }

Procedure TFhirSubstanceNucleicAcidSubunitSugar.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirSubstanceNucleicAcidSubunitSugar.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirSubstanceNucleicAcidSubunitSugar.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirSubstanceNucleicAcidSubunitSugar.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirSubstanceNucleicAcidSubunitSugar.SetResidueSite(value : TFhirString);
begin
  FResidueSite.free;
  FResidueSite := value;
end;

Function TFhirSubstanceNucleicAcidSubunitSugar.GetResidueSiteST : String;
begin
  if FResidueSite = nil then
    result := ''
  else
    result := FResidueSite.value;
end;

Procedure TFhirSubstanceNucleicAcidSubunitSugar.SetResidueSiteST(value : String);
begin
  if value <> '' then
  begin
    if FResidueSite = nil then
      FResidueSite := TFhirString.create;
    FResidueSite.value := value
  end
  else if FResidueSite <> nil then
    FResidueSite.value := '';
end;

function TFhirSubstanceNucleicAcidSubunitSugar.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FResidueSite.sizeInBytes);
end;

{ TFhirSubstanceNucleicAcidSubunitSugarListEnumerator }

Constructor TFhirSubstanceNucleicAcidSubunitSugarListEnumerator.Create(list : TFhirSubstanceNucleicAcidSubunitSugarList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceNucleicAcidSubunitSugarListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceNucleicAcidSubunitSugarListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceNucleicAcidSubunitSugarListEnumerator.GetCurrent : TFhirSubstanceNucleicAcidSubunitSugar;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceNucleicAcidSubunitSugarListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceNucleicAcidSubunitSugarList }
procedure TFhirSubstanceNucleicAcidSubunitSugarList.AddItem(value: TFhirSubstanceNucleicAcidSubunitSugar);
begin
  assert(value.ClassName = 'TFhirSubstanceNucleicAcidSubunitSugar', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceNucleicAcidSubunitSugar');
  add(value);
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.Append: TFhirSubstanceNucleicAcidSubunitSugar;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunitSugarList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.GetEnumerator : TFhirSubstanceNucleicAcidSubunitSugarListEnumerator;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugarListEnumerator.Create(self.link);
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.Clone: TFhirSubstanceNucleicAcidSubunitSugarList;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugarList(inherited Clone);
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.GetItemN(index: Integer): TFhirSubstanceNucleicAcidSubunitSugar;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar;
end;
function TFhirSubstanceNucleicAcidSubunitSugarList.IndexOf(value: TFhirSubstanceNucleicAcidSubunitSugar): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.Insert(index: Integer): TFhirSubstanceNucleicAcidSubunitSugar;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidSubunitSugarList.InsertItem(index: Integer; value: TFhirSubstanceNucleicAcidSubunitSugar);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunitSugar);
  Inherited Insert(index, value);
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.Item(index: Integer): TFhirSubstanceNucleicAcidSubunitSugar;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugar(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidSubunitSugarList.Link: TFhirSubstanceNucleicAcidSubunitSugarList;
begin
  result := TFhirSubstanceNucleicAcidSubunitSugarList(inherited Link);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugarList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceNucleicAcidSubunitSugarList.SetItemByIndex(index: Integer; value: TFhirSubstanceNucleicAcidSubunitSugar);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunitSugar);
  FhirSubstanceNucleicAcidSubunitSugars[index] := value;
end;

procedure TFhirSubstanceNucleicAcidSubunitSugarList.SetItemN(index: Integer; value: TFhirSubstanceNucleicAcidSubunitSugar);
begin
  assert(value is TFhirSubstanceNucleicAcidSubunitSugar);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceNucleicAcid }

constructor TFhirSubstanceNucleicAcid.Create;
begin
  inherited;
end;

destructor TFhirSubstanceNucleicAcid.Destroy;
begin
  FSequenceType.free;
  FNumberOfSubunits.free;
  FAreaOfHybridisation.free;
  FOligoNucleotideType.free;
  FSubunitList.Free;
  inherited;
end;

function TFhirSubstanceNucleicAcid.GetResourceType : TFhirResourceType;
begin
  result := frtSubstanceNucleicAcid;
end;

procedure TFhirSubstanceNucleicAcid.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceType := TFhirSubstanceNucleicAcid(oSource).sequenceType.Clone;
  numberOfSubunitsElement := TFhirSubstanceNucleicAcid(oSource).numberOfSubunitsElement.Clone;
  areaOfHybridisationElement := TFhirSubstanceNucleicAcid(oSource).areaOfHybridisationElement.Clone;
  oligoNucleotideType := TFhirSubstanceNucleicAcid(oSource).oligoNucleotideType.Clone;
  if (TFhirSubstanceNucleicAcid(oSource).FSubunitList = nil) then
  begin
    FSubunitList.free;
    FSubunitList := nil;
  end
  else
  begin
    if FSubunitList = nil then
      FSubunitList := TFhirSubstanceNucleicAcidSubunitList.Create;
    FSubunitList.Assign(TFhirSubstanceNucleicAcid(oSource).FSubunitList);
  end;
end;

procedure TFhirSubstanceNucleicAcid.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequenceType') Then
     list.add(self.link, 'sequenceType', FSequenceType.Link);
  if (child_name = 'numberOfSubunits') Then
     list.add(self.link, 'numberOfSubunits', FNumberOfSubunits.Link);
  if (child_name = 'areaOfHybridisation') Then
     list.add(self.link, 'areaOfHybridisation', FAreaOfHybridisation.Link);
  if (child_name = 'oligoNucleotideType') Then
     list.add(self.link, 'oligoNucleotideType', FOligoNucleotideType.Link);
  if (child_name = 'subunit') Then
    list.addAll(self, 'subunit', FSubunitList);
end;

procedure TFhirSubstanceNucleicAcid.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequenceType', 'CodeableConcept', false, TFhirCodeableConcept, FSequenceType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'numberOfSubunits', 'integer', false, TFhirInteger, FNumberOfSubunits.Link));{2}
  oList.add(TFHIRProperty.create(self, 'areaOfHybridisation', 'string', false, TFhirString, FAreaOfHybridisation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'oligoNucleotideType', 'CodeableConcept', false, TFhirCodeableConcept, FOligoNucleotideType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subunit', '', true, TFhirSubstanceNucleicAcidSubunit, FSubunitList.Link)){3};
end;

function TFhirSubstanceNucleicAcid.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequenceType') then
  begin
    SequenceType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'numberOfSubunits') then
  begin
    NumberOfSubunitsElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'areaOfHybridisation') then
  begin
    AreaOfHybridisationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'oligoNucleotideType') then
  begin
    OligoNucleotideType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subunit') then
  begin
    SubunitList.add(propValue as TFhirSubstanceNucleicAcidSubunit){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSubstanceNucleicAcid.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'subunit') then SubunitList.insertItem(index, propValue as TFhirSubstanceNucleicAcidSubunit){2a}
  else inherited;
end;

function TFhirSubstanceNucleicAcid.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'sequenceType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'numberOfSubunits') then result := TFhirInteger.create() {5b}
  else if (propName = 'areaOfHybridisation') then result := TFhirString.create() {5b}
  else if (propName = 'oligoNucleotideType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subunit') then result := SubunitList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceNucleicAcid.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequenceType') then result := 'CodeableConcept'
  else if (propName = 'numberOfSubunits') then result := 'integer'
  else if (propName = 'areaOfHybridisation') then result := 'string'
  else if (propName = 'oligoNucleotideType') then result := 'CodeableConcept'
  else if (propName = 'subunit') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceNucleicAcid.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'sequenceType') then SequenceTypeElement := nil
  else if (propName = 'numberOfSubunits') then NumberOfSubunitsElement := nil
  else if (propName = 'areaOfHybridisation') then AreaOfHybridisationElement := nil
  else if (propName = 'oligoNucleotideType') then OligoNucleotideTypeElement := nil
  else if (propName = 'subunit') then deletePropertyValue('subunit', SubunitList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceNucleicAcid.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequenceType') then SequenceTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'numberOfSubunits') then NumberOfSubunitsElement := asInteger(new){5b}
  else if (propName = 'areaOfHybridisation') then AreaOfHybridisationElement := asString(new){5b}
  else if (propName = 'oligoNucleotideType') then OligoNucleotideTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subunit') then replacePropertyValue('subunit', SubunitList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceNucleicAcid.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'subunit') then SubunitList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceNucleicAcid.fhirType : string;
begin
  result := 'SubstanceNucleicAcid';
end;

function TFhirSubstanceNucleicAcid.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequenceType) and isEmptyProp(FNumberOfSubunits) and isEmptyProp(FAreaOfHybridisation) and isEmptyProp(FOligoNucleotideType) and isEmptyProp(FsubunitList);
end;

function TFhirSubstanceNucleicAcid.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceNucleicAcid;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceNucleicAcid)) then
    result := false
  else
  begin
    o := TFhirSubstanceNucleicAcid(other);
    result := compareDeep(sequenceTypeElement, o.sequenceTypeElement, true) and 
      compareDeep(numberOfSubunitsElement, o.numberOfSubunitsElement, true) and compareDeep(areaOfHybridisationElement, o.areaOfHybridisationElement, true) and 
      compareDeep(oligoNucleotideTypeElement, o.oligoNucleotideTypeElement, true) and 
      compareDeep(subunitList, o.subunitList, true);
  end;
end;

function TFhirSubstanceNucleicAcid.Link : TFhirSubstanceNucleicAcid;
begin
  result := TFhirSubstanceNucleicAcid(inherited Link);
end;

function TFhirSubstanceNucleicAcid.Clone : TFhirSubstanceNucleicAcid;
begin
  result := TFhirSubstanceNucleicAcid(inherited Clone);
end;

procedure TFhirSubstanceNucleicAcid.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('sequenceType');
  fields.add('numberOfSubunits');
  fields.add('areaOfHybridisation');
  fields.add('oligoNucleotideType');
  fields.add('subunit');
end;

{ TFhirSubstanceNucleicAcid }

Procedure TFhirSubstanceNucleicAcid.SetSequenceType(value : TFhirCodeableConcept);
begin
  FSequenceType.free;
  FSequenceType := value;
end;

Procedure TFhirSubstanceNucleicAcid.SetNumberOfSubunits(value : TFhirInteger);
begin
  FNumberOfSubunits.free;
  FNumberOfSubunits := value;
end;

Function TFhirSubstanceNucleicAcid.GetNumberOfSubunitsST : String;
begin
  if FNumberOfSubunits = nil then
    result := ''
  else
    result := FNumberOfSubunits.value;
end;

Procedure TFhirSubstanceNucleicAcid.SetNumberOfSubunitsST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfSubunits = nil then
      FNumberOfSubunits := TFhirInteger.create;
    FNumberOfSubunits.value := value
  end
  else if FNumberOfSubunits <> nil then
    FNumberOfSubunits.value := '';
end;

Procedure TFhirSubstanceNucleicAcid.SetAreaOfHybridisation(value : TFhirString);
begin
  FAreaOfHybridisation.free;
  FAreaOfHybridisation := value;
end;

Function TFhirSubstanceNucleicAcid.GetAreaOfHybridisationST : String;
begin
  if FAreaOfHybridisation = nil then
    result := ''
  else
    result := FAreaOfHybridisation.value;
end;

Procedure TFhirSubstanceNucleicAcid.SetAreaOfHybridisationST(value : String);
begin
  if value <> '' then
  begin
    if FAreaOfHybridisation = nil then
      FAreaOfHybridisation := TFhirString.create;
    FAreaOfHybridisation.value := value
  end
  else if FAreaOfHybridisation <> nil then
    FAreaOfHybridisation.value := '';
end;

Procedure TFhirSubstanceNucleicAcid.SetOligoNucleotideType(value : TFhirCodeableConcept);
begin
  FOligoNucleotideType.free;
  FOligoNucleotideType := value;
end;

Function TFhirSubstanceNucleicAcid.GetSubunitList : TFhirSubstanceNucleicAcidSubunitList;
begin
  if FSubunitList = nil then
    FSubunitList := TFhirSubstanceNucleicAcidSubunitList.Create;
  result := FSubunitList;
end;

Function TFhirSubstanceNucleicAcid.GetHasSubunitList : boolean;
begin
  result := (FSubunitList <> nil) and (FSubunitList.count > 0);
end;

function TFhirSubstanceNucleicAcid.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequenceType.sizeInBytes);
  inc(result, FNumberOfSubunits.sizeInBytes);
  inc(result, FAreaOfHybridisation.sizeInBytes);
  inc(result, FOligoNucleotideType.sizeInBytes);
  inc(result, FsubunitList.sizeInBytes);
end;

{ TFhirSubstanceNucleicAcidListEnumerator }

Constructor TFhirSubstanceNucleicAcidListEnumerator.Create(list : TFhirSubstanceNucleicAcidList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceNucleicAcidListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceNucleicAcidListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceNucleicAcidListEnumerator.GetCurrent : TFhirSubstanceNucleicAcid;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceNucleicAcidListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceNucleicAcidList }
procedure TFhirSubstanceNucleicAcidList.AddItem(value: TFhirSubstanceNucleicAcid);
begin
  assert(value.ClassName = 'TFhirSubstanceNucleicAcid', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceNucleicAcid');
  add(value);
end;

function TFhirSubstanceNucleicAcidList.Append: TFhirSubstanceNucleicAcid;
begin
  result := TFhirSubstanceNucleicAcid.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceNucleicAcidList.GetEnumerator : TFhirSubstanceNucleicAcidListEnumerator;
begin
  result := TFhirSubstanceNucleicAcidListEnumerator.Create(self.link);
end;

function TFhirSubstanceNucleicAcidList.Clone: TFhirSubstanceNucleicAcidList;
begin
  result := TFhirSubstanceNucleicAcidList(inherited Clone);
end;

function TFhirSubstanceNucleicAcidList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceNucleicAcidList.GetItemN(index: Integer): TFhirSubstanceNucleicAcid;
begin
  result := TFhirSubstanceNucleicAcid(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceNucleicAcid;
end;
function TFhirSubstanceNucleicAcidList.IndexOf(value: TFhirSubstanceNucleicAcid): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceNucleicAcidList.Insert(index: Integer): TFhirSubstanceNucleicAcid;
begin
  result := TFhirSubstanceNucleicAcid.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceNucleicAcidList.InsertItem(index: Integer; value: TFhirSubstanceNucleicAcid);
begin
  assert(value is TFhirSubstanceNucleicAcid);
  Inherited Insert(index, value);
end;

function TFhirSubstanceNucleicAcidList.Item(index: Integer): TFhirSubstanceNucleicAcid;
begin
  result := TFhirSubstanceNucleicAcid(ObjectByIndex[index]);
end;

function TFhirSubstanceNucleicAcidList.Link: TFhirSubstanceNucleicAcidList;
begin
  result := TFhirSubstanceNucleicAcidList(inherited Link);
end;

procedure TFhirSubstanceNucleicAcidList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceNucleicAcidList.SetItemByIndex(index: Integer; value: TFhirSubstanceNucleicAcid);
begin
  assert(value is TFhirSubstanceNucleicAcid);
  FhirSubstanceNucleicAcids[index] := value;
end;

procedure TFhirSubstanceNucleicAcidList.SetItemN(index: Integer; value: TFhirSubstanceNucleicAcid);
begin
  assert(value is TFhirSubstanceNucleicAcid);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCENUCLEICACID}

{$IFDEF FHIR_SUBSTANCEPOLYMER}

{ TFhirSubstancePolymerMonomerSet }

constructor TFhirSubstancePolymerMonomerSet.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymerMonomerSet.Destroy;
begin
  FRatioType.free;
  FStartingMaterialList.Free;
  inherited;
end;

procedure TFhirSubstancePolymerMonomerSet.Assign(oSource : TFslObject);
begin
  inherited;
  ratioType := TFhirSubstancePolymerMonomerSet(oSource).ratioType.Clone;
  if (TFhirSubstancePolymerMonomerSet(oSource).FStartingMaterialList = nil) then
  begin
    FStartingMaterialList.free;
    FStartingMaterialList := nil;
  end
  else
  begin
    if FStartingMaterialList = nil then
      FStartingMaterialList := TFhirSubstancePolymerMonomerSetStartingMaterialList.Create;
    FStartingMaterialList.Assign(TFhirSubstancePolymerMonomerSet(oSource).FStartingMaterialList);
  end;
end;

procedure TFhirSubstancePolymerMonomerSet.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'ratioType') Then
     list.add(self.link, 'ratioType', FRatioType.Link);
  if (child_name = 'startingMaterial') Then
    list.addAll(self, 'startingMaterial', FStartingMaterialList);
end;

procedure TFhirSubstancePolymerMonomerSet.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'ratioType', 'CodeableConcept', false, TFhirCodeableConcept, FRatioType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'startingMaterial', '', true, TFhirSubstancePolymerMonomerSetStartingMaterial, FStartingMaterialList.Link)){3};
end;

function TFhirSubstancePolymerMonomerSet.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'ratioType') then
  begin
    RatioType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'startingMaterial') then
  begin
    StartingMaterialList.add(propValue as TFhirSubstancePolymerMonomerSetStartingMaterial){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstancePolymerMonomerSet.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'startingMaterial') then StartingMaterialList.insertItem(index, propValue as TFhirSubstancePolymerMonomerSetStartingMaterial){2a}
  else inherited;
end;

function TFhirSubstancePolymerMonomerSet.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'ratioType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'startingMaterial') then result := StartingMaterialList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymerMonomerSet.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'ratioType') then result := 'CodeableConcept'
  else if (propName = 'startingMaterial') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymerMonomerSet.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'ratioType') then RatioTypeElement := nil
  else if (propName = 'startingMaterial') then deletePropertyValue('startingMaterial', StartingMaterialList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymerMonomerSet.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'ratioType') then RatioTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'startingMaterial') then replacePropertyValue('startingMaterial', StartingMaterialList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymerMonomerSet.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'startingMaterial') then StartingMaterialList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymerMonomerSet.fhirType : string;
begin
  result := 'monomerSet';
end;

function TFhirSubstancePolymerMonomerSet.Link : TFhirSubstancePolymerMonomerSet;
begin
  result := TFhirSubstancePolymerMonomerSet(inherited Link);
end;

function TFhirSubstancePolymerMonomerSet.Clone : TFhirSubstancePolymerMonomerSet;
begin
  result := TFhirSubstancePolymerMonomerSet(inherited Clone);
end;

function TFhirSubstancePolymerMonomerSet.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymerMonomerSet;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymerMonomerSet)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymerMonomerSet(other);
    result := compareDeep(ratioTypeElement, o.ratioTypeElement, true) and compareDeep(startingMaterialList, o.startingMaterialList, true);
  end;
end;

function TFhirSubstancePolymerMonomerSet.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRatioType) and isEmptyProp(FstartingMaterialList);
end;

procedure TFhirSubstancePolymerMonomerSet.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('ratioType');
  fields.add('startingMaterial');
end;

{ TFhirSubstancePolymerMonomerSet }

Procedure TFhirSubstancePolymerMonomerSet.SetRatioType(value : TFhirCodeableConcept);
begin
  FRatioType.free;
  FRatioType := value;
end;

Function TFhirSubstancePolymerMonomerSet.GetStartingMaterialList : TFhirSubstancePolymerMonomerSetStartingMaterialList;
begin
  if FStartingMaterialList = nil then
    FStartingMaterialList := TFhirSubstancePolymerMonomerSetStartingMaterialList.Create;
  result := FStartingMaterialList;
end;

Function TFhirSubstancePolymerMonomerSet.GetHasStartingMaterialList : boolean;
begin
  result := (FStartingMaterialList <> nil) and (FStartingMaterialList.count > 0);
end;

function TFhirSubstancePolymerMonomerSet.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRatioType.sizeInBytes);
  inc(result, FstartingMaterialList.sizeInBytes);
end;

{ TFhirSubstancePolymerMonomerSetListEnumerator }

Constructor TFhirSubstancePolymerMonomerSetListEnumerator.Create(list : TFhirSubstancePolymerMonomerSetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerMonomerSetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerMonomerSetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerMonomerSetListEnumerator.GetCurrent : TFhirSubstancePolymerMonomerSet;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerMonomerSetListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstancePolymerMonomerSetList }
procedure TFhirSubstancePolymerMonomerSetList.AddItem(value: TFhirSubstancePolymerMonomerSet);
begin
  assert(value.ClassName = 'TFhirSubstancePolymerMonomerSet', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymerMonomerSet');
  add(value);
end;

function TFhirSubstancePolymerMonomerSetList.Append: TFhirSubstancePolymerMonomerSet;
begin
  result := TFhirSubstancePolymerMonomerSet.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerMonomerSetList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerMonomerSetList.GetEnumerator : TFhirSubstancePolymerMonomerSetListEnumerator;
begin
  result := TFhirSubstancePolymerMonomerSetListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerMonomerSetList.Clone: TFhirSubstancePolymerMonomerSetList;
begin
  result := TFhirSubstancePolymerMonomerSetList(inherited Clone);
end;

function TFhirSubstancePolymerMonomerSetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerMonomerSetList.GetItemN(index: Integer): TFhirSubstancePolymerMonomerSet;
begin
  result := TFhirSubstancePolymerMonomerSet(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerMonomerSetList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymerMonomerSet;
end;
function TFhirSubstancePolymerMonomerSetList.IndexOf(value: TFhirSubstancePolymerMonomerSet): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerMonomerSetList.Insert(index: Integer): TFhirSubstancePolymerMonomerSet;
begin
  result := TFhirSubstancePolymerMonomerSet.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerMonomerSetList.InsertItem(index: Integer; value: TFhirSubstancePolymerMonomerSet);
begin
  assert(value is TFhirSubstancePolymerMonomerSet);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerMonomerSetList.Item(index: Integer): TFhirSubstancePolymerMonomerSet;
begin
  result := TFhirSubstancePolymerMonomerSet(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerMonomerSetList.Link: TFhirSubstancePolymerMonomerSetList;
begin
  result := TFhirSubstancePolymerMonomerSetList(inherited Link);
end;

procedure TFhirSubstancePolymerMonomerSetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerMonomerSetList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymerMonomerSet);
begin
  assert(value is TFhirSubstancePolymerMonomerSet);
  FhirSubstancePolymerMonomerSets[index] := value;
end;

procedure TFhirSubstancePolymerMonomerSetList.SetItemN(index: Integer; value: TFhirSubstancePolymerMonomerSet);
begin
  assert(value is TFhirSubstancePolymerMonomerSet);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstancePolymerMonomerSetStartingMaterial }

constructor TFhirSubstancePolymerMonomerSetStartingMaterial.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymerMonomerSetStartingMaterial.Destroy;
begin
  FMaterial.free;
  FType_.free;
  FIsDefining.free;
  FAmount.free;
  inherited;
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.Assign(oSource : TFslObject);
begin
  inherited;
  material := TFhirSubstancePolymerMonomerSetStartingMaterial(oSource).material.Clone;
  type_ := TFhirSubstancePolymerMonomerSetStartingMaterial(oSource).type_.Clone;
  isDefiningElement := TFhirSubstancePolymerMonomerSetStartingMaterial(oSource).isDefiningElement.Clone;
  amount := TFhirSubstancePolymerMonomerSetStartingMaterial(oSource).amount.Clone;
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'material') Then
     list.add(self.link, 'material', FMaterial.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'isDefining') Then
     list.add(self.link, 'isDefining', FIsDefining.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'material', 'CodeableConcept', false, TFhirCodeableConcept, FMaterial.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'isDefining', 'boolean', false, TFhirBoolean, FIsDefining.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'SubstanceAmount', false, TFhirSubstanceAmount, FAmount.Link));{2}
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'material') then
  begin
    Material := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'isDefining') then
  begin
    IsDefiningElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirSubstanceAmount{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'material') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'isDefining') then result := TFhirBoolean.create() {5b}
  else if (propName = 'amount') then result := TFhirSubstanceAmount.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'material') then result := 'CodeableConcept'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'isDefining') then result := 'boolean'
  else if (propName = 'amount') then result := 'SubstanceAmount'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'material') then MaterialElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'isDefining') then IsDefiningElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'material') then MaterialElement := new as TFhirCodeableConcept{4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'isDefining') then IsDefiningElement := asBoolean(new){5b}
  else if (propName = 'amount') then AmountElement := new as TFhirSubstanceAmount{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.fhirType : string;
begin
  result := 'startingMaterial';
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.Link : TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial(inherited Link);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.Clone : TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial(inherited Clone);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymerMonomerSetStartingMaterial)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymerMonomerSetStartingMaterial(other);
    result := compareDeep(materialElement, o.materialElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(isDefiningElement, o.isDefiningElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMaterial) and isEmptyProp(FType_) and isEmptyProp(FIsDefining) and isEmptyProp(FAmount);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterial.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('material');
  fields.add('type');
  fields.add('isDefining');
  fields.add('amount');
end;

{ TFhirSubstancePolymerMonomerSetStartingMaterial }

Procedure TFhirSubstancePolymerMonomerSetStartingMaterial.SetMaterial(value : TFhirCodeableConcept);
begin
  FMaterial.free;
  FMaterial := value;
end;

Procedure TFhirSubstancePolymerMonomerSetStartingMaterial.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSubstancePolymerMonomerSetStartingMaterial.SetIsDefining(value : TFhirBoolean);
begin
  FIsDefining.free;
  FIsDefining := value;
end;

Function TFhirSubstancePolymerMonomerSetStartingMaterial.GetIsDefiningST : Boolean;
begin
  if FIsDefining = nil then
    result := false
  else
    result := FIsDefining.value;
end;

Procedure TFhirSubstancePolymerMonomerSetStartingMaterial.SetIsDefiningST(value : Boolean);
begin
  if FIsDefining = nil then
    FIsDefining := TFhirBoolean.create;
  FIsDefining.value := value
end;

Procedure TFhirSubstancePolymerMonomerSetStartingMaterial.SetAmount(value : TFhirSubstanceAmount);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterial.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMaterial.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FIsDefining.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator }

Constructor TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator.Create(list : TFhirSubstancePolymerMonomerSetStartingMaterialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator.GetCurrent : TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstancePolymerMonomerSetStartingMaterialList }
procedure TFhirSubstancePolymerMonomerSetStartingMaterialList.AddItem(value: TFhirSubstancePolymerMonomerSetStartingMaterial);
begin
  assert(value.ClassName = 'TFhirSubstancePolymerMonomerSetStartingMaterial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymerMonomerSetStartingMaterial');
  add(value);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.Append: TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterialList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.GetEnumerator : TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterialListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.Clone: TFhirSubstancePolymerMonomerSetStartingMaterialList;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterialList(inherited Clone);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.GetItemN(index: Integer): TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial;
end;
function TFhirSubstancePolymerMonomerSetStartingMaterialList.IndexOf(value: TFhirSubstancePolymerMonomerSetStartingMaterial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.Insert(index: Integer): TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterialList.InsertItem(index: Integer; value: TFhirSubstancePolymerMonomerSetStartingMaterial);
begin
  assert(value is TFhirSubstancePolymerMonomerSetStartingMaterial);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.Item(index: Integer): TFhirSubstancePolymerMonomerSetStartingMaterial;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterial(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerMonomerSetStartingMaterialList.Link: TFhirSubstancePolymerMonomerSetStartingMaterialList;
begin
  result := TFhirSubstancePolymerMonomerSetStartingMaterialList(inherited Link);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterialList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymerMonomerSetStartingMaterial);
begin
  assert(value is TFhirSubstancePolymerMonomerSetStartingMaterial);
  FhirSubstancePolymerMonomerSetStartingMaterials[index] := value;
end;

procedure TFhirSubstancePolymerMonomerSetStartingMaterialList.SetItemN(index: Integer; value: TFhirSubstancePolymerMonomerSetStartingMaterial);
begin
  assert(value is TFhirSubstancePolymerMonomerSetStartingMaterial);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstancePolymerRepeat }

constructor TFhirSubstancePolymerRepeat.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymerRepeat.Destroy;
begin
  FNumberOfUnits.free;
  FAverageMolecularFormula.free;
  FRepeatUnitAmountType.free;
  FRepeatUnitList.Free;
  inherited;
end;

procedure TFhirSubstancePolymerRepeat.Assign(oSource : TFslObject);
begin
  inherited;
  numberOfUnitsElement := TFhirSubstancePolymerRepeat(oSource).numberOfUnitsElement.Clone;
  averageMolecularFormulaElement := TFhirSubstancePolymerRepeat(oSource).averageMolecularFormulaElement.Clone;
  repeatUnitAmountType := TFhirSubstancePolymerRepeat(oSource).repeatUnitAmountType.Clone;
  if (TFhirSubstancePolymerRepeat(oSource).FRepeatUnitList = nil) then
  begin
    FRepeatUnitList.free;
    FRepeatUnitList := nil;
  end
  else
  begin
    if FRepeatUnitList = nil then
      FRepeatUnitList := TFhirSubstancePolymerRepeatRepeatUnitList.Create;
    FRepeatUnitList.Assign(TFhirSubstancePolymerRepeat(oSource).FRepeatUnitList);
  end;
end;

procedure TFhirSubstancePolymerRepeat.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'numberOfUnits') Then
     list.add(self.link, 'numberOfUnits', FNumberOfUnits.Link);
  if (child_name = 'averageMolecularFormula') Then
     list.add(self.link, 'averageMolecularFormula', FAverageMolecularFormula.Link);
  if (child_name = 'repeatUnitAmountType') Then
     list.add(self.link, 'repeatUnitAmountType', FRepeatUnitAmountType.Link);
  if (child_name = 'repeatUnit') Then
    list.addAll(self, 'repeatUnit', FRepeatUnitList);
end;

procedure TFhirSubstancePolymerRepeat.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'numberOfUnits', 'integer', false, TFhirInteger, FNumberOfUnits.Link));{2}
  oList.add(TFHIRProperty.create(self, 'averageMolecularFormula', 'string', false, TFhirString, FAverageMolecularFormula.Link));{2}
  oList.add(TFHIRProperty.create(self, 'repeatUnitAmountType', 'CodeableConcept', false, TFhirCodeableConcept, FRepeatUnitAmountType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'repeatUnit', '', true, TFhirSubstancePolymerRepeatRepeatUnit, FRepeatUnitList.Link)){3};
end;

function TFhirSubstancePolymerRepeat.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'numberOfUnits') then
  begin
    NumberOfUnitsElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'averageMolecularFormula') then
  begin
    AverageMolecularFormulaElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'repeatUnitAmountType') then
  begin
    RepeatUnitAmountType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'repeatUnit') then
  begin
    RepeatUnitList.add(propValue as TFhirSubstancePolymerRepeatRepeatUnit){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstancePolymerRepeat.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'repeatUnit') then RepeatUnitList.insertItem(index, propValue as TFhirSubstancePolymerRepeatRepeatUnit){2a}
  else inherited;
end;

function TFhirSubstancePolymerRepeat.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'numberOfUnits') then result := TFhirInteger.create() {5b}
  else if (propName = 'averageMolecularFormula') then result := TFhirString.create() {5b}
  else if (propName = 'repeatUnitAmountType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'repeatUnit') then result := RepeatUnitList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymerRepeat.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'numberOfUnits') then result := 'integer'
  else if (propName = 'averageMolecularFormula') then result := 'string'
  else if (propName = 'repeatUnitAmountType') then result := 'CodeableConcept'
  else if (propName = 'repeatUnit') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymerRepeat.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'numberOfUnits') then NumberOfUnitsElement := nil
  else if (propName = 'averageMolecularFormula') then AverageMolecularFormulaElement := nil
  else if (propName = 'repeatUnitAmountType') then RepeatUnitAmountTypeElement := nil
  else if (propName = 'repeatUnit') then deletePropertyValue('repeatUnit', RepeatUnitList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymerRepeat.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'numberOfUnits') then NumberOfUnitsElement := asInteger(new){5b}
  else if (propName = 'averageMolecularFormula') then AverageMolecularFormulaElement := asString(new){5b}
  else if (propName = 'repeatUnitAmountType') then RepeatUnitAmountTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'repeatUnit') then replacePropertyValue('repeatUnit', RepeatUnitList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymerRepeat.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'repeatUnit') then RepeatUnitList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymerRepeat.fhirType : string;
begin
  result := 'repeat';
end;

function TFhirSubstancePolymerRepeat.Link : TFhirSubstancePolymerRepeat;
begin
  result := TFhirSubstancePolymerRepeat(inherited Link);
end;

function TFhirSubstancePolymerRepeat.Clone : TFhirSubstancePolymerRepeat;
begin
  result := TFhirSubstancePolymerRepeat(inherited Clone);
end;

function TFhirSubstancePolymerRepeat.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymerRepeat;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymerRepeat)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymerRepeat(other);
    result := compareDeep(numberOfUnitsElement, o.numberOfUnitsElement, true) and 
      compareDeep(averageMolecularFormulaElement, o.averageMolecularFormulaElement, true) and 
      compareDeep(repeatUnitAmountTypeElement, o.repeatUnitAmountTypeElement, true) and 
      compareDeep(repeatUnitList, o.repeatUnitList, true);
  end;
end;

function TFhirSubstancePolymerRepeat.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FNumberOfUnits) and isEmptyProp(FAverageMolecularFormula) and isEmptyProp(FRepeatUnitAmountType) and isEmptyProp(FrepeatUnitList);
end;

procedure TFhirSubstancePolymerRepeat.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('numberOfUnits');
  fields.add('averageMolecularFormula');
  fields.add('repeatUnitAmountType');
  fields.add('repeatUnit');
end;

{ TFhirSubstancePolymerRepeat }

Procedure TFhirSubstancePolymerRepeat.SetNumberOfUnits(value : TFhirInteger);
begin
  FNumberOfUnits.free;
  FNumberOfUnits := value;
end;

Function TFhirSubstancePolymerRepeat.GetNumberOfUnitsST : String;
begin
  if FNumberOfUnits = nil then
    result := ''
  else
    result := FNumberOfUnits.value;
end;

Procedure TFhirSubstancePolymerRepeat.SetNumberOfUnitsST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfUnits = nil then
      FNumberOfUnits := TFhirInteger.create;
    FNumberOfUnits.value := value
  end
  else if FNumberOfUnits <> nil then
    FNumberOfUnits.value := '';
end;

Procedure TFhirSubstancePolymerRepeat.SetAverageMolecularFormula(value : TFhirString);
begin
  FAverageMolecularFormula.free;
  FAverageMolecularFormula := value;
end;

Function TFhirSubstancePolymerRepeat.GetAverageMolecularFormulaST : String;
begin
  if FAverageMolecularFormula = nil then
    result := ''
  else
    result := FAverageMolecularFormula.value;
end;

Procedure TFhirSubstancePolymerRepeat.SetAverageMolecularFormulaST(value : String);
begin
  if value <> '' then
  begin
    if FAverageMolecularFormula = nil then
      FAverageMolecularFormula := TFhirString.create;
    FAverageMolecularFormula.value := value
  end
  else if FAverageMolecularFormula <> nil then
    FAverageMolecularFormula.value := '';
end;

Procedure TFhirSubstancePolymerRepeat.SetRepeatUnitAmountType(value : TFhirCodeableConcept);
begin
  FRepeatUnitAmountType.free;
  FRepeatUnitAmountType := value;
end;

Function TFhirSubstancePolymerRepeat.GetRepeatUnitList : TFhirSubstancePolymerRepeatRepeatUnitList;
begin
  if FRepeatUnitList = nil then
    FRepeatUnitList := TFhirSubstancePolymerRepeatRepeatUnitList.Create;
  result := FRepeatUnitList;
end;

Function TFhirSubstancePolymerRepeat.GetHasRepeatUnitList : boolean;
begin
  result := (FRepeatUnitList <> nil) and (FRepeatUnitList.count > 0);
end;

function TFhirSubstancePolymerRepeat.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FNumberOfUnits.sizeInBytes);
  inc(result, FAverageMolecularFormula.sizeInBytes);
  inc(result, FRepeatUnitAmountType.sizeInBytes);
  inc(result, FrepeatUnitList.sizeInBytes);
end;

{ TFhirSubstancePolymerRepeatListEnumerator }

Constructor TFhirSubstancePolymerRepeatListEnumerator.Create(list : TFhirSubstancePolymerRepeatList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerRepeatListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerRepeatListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerRepeatListEnumerator.GetCurrent : TFhirSubstancePolymerRepeat;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerRepeatListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstancePolymerRepeatList }
procedure TFhirSubstancePolymerRepeatList.AddItem(value: TFhirSubstancePolymerRepeat);
begin
  assert(value.ClassName = 'TFhirSubstancePolymerRepeat', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymerRepeat');
  add(value);
end;

function TFhirSubstancePolymerRepeatList.Append: TFhirSubstancePolymerRepeat;
begin
  result := TFhirSubstancePolymerRepeat.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerRepeatList.GetEnumerator : TFhirSubstancePolymerRepeatListEnumerator;
begin
  result := TFhirSubstancePolymerRepeatListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerRepeatList.Clone: TFhirSubstancePolymerRepeatList;
begin
  result := TFhirSubstancePolymerRepeatList(inherited Clone);
end;

function TFhirSubstancePolymerRepeatList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerRepeatList.GetItemN(index: Integer): TFhirSubstancePolymerRepeat;
begin
  result := TFhirSubstancePolymerRepeat(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymerRepeat;
end;
function TFhirSubstancePolymerRepeatList.IndexOf(value: TFhirSubstancePolymerRepeat): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerRepeatList.Insert(index: Integer): TFhirSubstancePolymerRepeat;
begin
  result := TFhirSubstancePolymerRepeat.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatList.InsertItem(index: Integer; value: TFhirSubstancePolymerRepeat);
begin
  assert(value is TFhirSubstancePolymerRepeat);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerRepeatList.Item(index: Integer): TFhirSubstancePolymerRepeat;
begin
  result := TFhirSubstancePolymerRepeat(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatList.Link: TFhirSubstancePolymerRepeatList;
begin
  result := TFhirSubstancePolymerRepeatList(inherited Link);
end;

procedure TFhirSubstancePolymerRepeatList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerRepeatList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymerRepeat);
begin
  assert(value is TFhirSubstancePolymerRepeat);
  FhirSubstancePolymerRepeats[index] := value;
end;

procedure TFhirSubstancePolymerRepeatList.SetItemN(index: Integer; value: TFhirSubstancePolymerRepeat);
begin
  assert(value is TFhirSubstancePolymerRepeat);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstancePolymerRepeatRepeatUnit }

constructor TFhirSubstancePolymerRepeatRepeatUnit.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymerRepeatRepeatUnit.Destroy;
begin
  FOrientationOfPolymerisation.free;
  FRepeatUnit.free;
  FAmount.free;
  FDegreeOfPolymerisationList.Free;
  FStructuralRepresentationList.Free;
  inherited;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.Assign(oSource : TFslObject);
begin
  inherited;
  orientationOfPolymerisation := TFhirSubstancePolymerRepeatRepeatUnit(oSource).orientationOfPolymerisation.Clone;
  repeatUnitElement := TFhirSubstancePolymerRepeatRepeatUnit(oSource).repeatUnitElement.Clone;
  amount := TFhirSubstancePolymerRepeatRepeatUnit(oSource).amount.Clone;
  if (TFhirSubstancePolymerRepeatRepeatUnit(oSource).FDegreeOfPolymerisationList = nil) then
  begin
    FDegreeOfPolymerisationList.free;
    FDegreeOfPolymerisationList := nil;
  end
  else
  begin
    if FDegreeOfPolymerisationList = nil then
      FDegreeOfPolymerisationList := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Create;
    FDegreeOfPolymerisationList.Assign(TFhirSubstancePolymerRepeatRepeatUnit(oSource).FDegreeOfPolymerisationList);
  end;
  if (TFhirSubstancePolymerRepeatRepeatUnit(oSource).FStructuralRepresentationList = nil) then
  begin
    FStructuralRepresentationList.free;
    FStructuralRepresentationList := nil;
  end
  else
  begin
    if FStructuralRepresentationList = nil then
      FStructuralRepresentationList := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Create;
    FStructuralRepresentationList.Assign(TFhirSubstancePolymerRepeatRepeatUnit(oSource).FStructuralRepresentationList);
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'orientationOfPolymerisation') Then
     list.add(self.link, 'orientationOfPolymerisation', FOrientationOfPolymerisation.Link);
  if (child_name = 'repeatUnit') Then
     list.add(self.link, 'repeatUnit', FRepeatUnit.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'degreeOfPolymerisation') Then
    list.addAll(self, 'degreeOfPolymerisation', FDegreeOfPolymerisationList);
  if (child_name = 'structuralRepresentation') Then
    list.addAll(self, 'structuralRepresentation', FStructuralRepresentationList);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'orientationOfPolymerisation', 'CodeableConcept', false, TFhirCodeableConcept, FOrientationOfPolymerisation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'repeatUnit', 'string', false, TFhirString, FRepeatUnit.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'SubstanceAmount', false, TFhirSubstanceAmount, FAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'degreeOfPolymerisation', '', true, TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation, FDegreeOfPolymerisationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'structuralRepresentation', '', true, TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation, FStructuralRepresentationList.Link)){3};
end;

function TFhirSubstancePolymerRepeatRepeatUnit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'orientationOfPolymerisation') then
  begin
    OrientationOfPolymerisation := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'repeatUnit') then
  begin
    RepeatUnitElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirSubstanceAmount{4b};
    result := propValue;
  end
  else if (propName = 'degreeOfPolymerisation') then
  begin
    DegreeOfPolymerisationList.add(propValue as TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation){2a};
    result := propValue;
  end
  else if (propName = 'structuralRepresentation') then
  begin
    StructuralRepresentationList.add(propValue as TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'degreeOfPolymerisation') then DegreeOfPolymerisationList.insertItem(index, propValue as TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation){2a}
  else if (propName = 'structuralRepresentation') then StructuralRepresentationList.insertItem(index, propValue as TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation){2a}
  else inherited;
end;

function TFhirSubstancePolymerRepeatRepeatUnit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'orientationOfPolymerisation') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'repeatUnit') then result := TFhirString.create() {5b}
  else if (propName = 'amount') then result := TFhirSubstanceAmount.create(){4b}
  else if (propName = 'degreeOfPolymerisation') then result := DegreeOfPolymerisationList.new(){2}
  else if (propName = 'structuralRepresentation') then result := StructuralRepresentationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymerRepeatRepeatUnit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'orientationOfPolymerisation') then result := 'CodeableConcept'
  else if (propName = 'repeatUnit') then result := 'string'
  else if (propName = 'amount') then result := 'SubstanceAmount'
  else if (propName = 'degreeOfPolymerisation') then result := ''
  else if (propName = 'structuralRepresentation') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'orientationOfPolymerisation') then OrientationOfPolymerisationElement := nil
  else if (propName = 'repeatUnit') then RepeatUnitElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'degreeOfPolymerisation') then deletePropertyValue('degreeOfPolymerisation', DegreeOfPolymerisationList, value) {2}
  else if (propName = 'structuralRepresentation') then deletePropertyValue('structuralRepresentation', StructuralRepresentationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'orientationOfPolymerisation') then OrientationOfPolymerisationElement := new as TFhirCodeableConcept{4}
  else if (propName = 'repeatUnit') then RepeatUnitElement := asString(new){5b}
  else if (propName = 'amount') then AmountElement := new as TFhirSubstanceAmount{4}
  else if (propName = 'degreeOfPolymerisation') then replacePropertyValue('degreeOfPolymerisation', DegreeOfPolymerisationList, existing, new) {2}
  else if (propName = 'structuralRepresentation') then replacePropertyValue('structuralRepresentation', StructuralRepresentationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'degreeOfPolymerisation') then DegreeOfPolymerisationList.move(source, destination){2a}
  else if (propName = 'structuralRepresentation') then StructuralRepresentationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymerRepeatRepeatUnit.fhirType : string;
begin
  result := 'repeatUnit';
end;

function TFhirSubstancePolymerRepeatRepeatUnit.Link : TFhirSubstancePolymerRepeatRepeatUnit;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit(inherited Link);
end;

function TFhirSubstancePolymerRepeatRepeatUnit.Clone : TFhirSubstancePolymerRepeatRepeatUnit;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit(inherited Clone);
end;

function TFhirSubstancePolymerRepeatRepeatUnit.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymerRepeatRepeatUnit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymerRepeatRepeatUnit)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymerRepeatRepeatUnit(other);
    result := compareDeep(orientationOfPolymerisationElement, o.orientationOfPolymerisationElement, true) and 
      compareDeep(repeatUnitElement, o.repeatUnitElement, true) and compareDeep(amountElement, o.amountElement, true) and 
      compareDeep(degreeOfPolymerisationList, o.degreeOfPolymerisationList, true) and 
      compareDeep(structuralRepresentationList, o.structuralRepresentationList, true);
  end;
end;

function TFhirSubstancePolymerRepeatRepeatUnit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOrientationOfPolymerisation) and isEmptyProp(FRepeatUnit) and isEmptyProp(FAmount) and isEmptyProp(FdegreeOfPolymerisationList) and isEmptyProp(FstructuralRepresentationList);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnit.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('orientationOfPolymerisation');
  fields.add('repeatUnit');
  fields.add('amount');
  fields.add('degreeOfPolymerisation');
  fields.add('structuralRepresentation');
end;

{ TFhirSubstancePolymerRepeatRepeatUnit }

Procedure TFhirSubstancePolymerRepeatRepeatUnit.SetOrientationOfPolymerisation(value : TFhirCodeableConcept);
begin
  FOrientationOfPolymerisation.free;
  FOrientationOfPolymerisation := value;
end;

Procedure TFhirSubstancePolymerRepeatRepeatUnit.SetRepeatUnit(value : TFhirString);
begin
  FRepeatUnit.free;
  FRepeatUnit := value;
end;

Function TFhirSubstancePolymerRepeatRepeatUnit.GetRepeatUnitST : String;
begin
  if FRepeatUnit = nil then
    result := ''
  else
    result := FRepeatUnit.value;
end;

Procedure TFhirSubstancePolymerRepeatRepeatUnit.SetRepeatUnitST(value : String);
begin
  if value <> '' then
  begin
    if FRepeatUnit = nil then
      FRepeatUnit := TFhirString.create;
    FRepeatUnit.value := value
  end
  else if FRepeatUnit <> nil then
    FRepeatUnit.value := '';
end;

Procedure TFhirSubstancePolymerRepeatRepeatUnit.SetAmount(value : TFhirSubstanceAmount);
begin
  FAmount.free;
  FAmount := value;
end;

Function TFhirSubstancePolymerRepeatRepeatUnit.GetDegreeOfPolymerisationList : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList;
begin
  if FDegreeOfPolymerisationList = nil then
    FDegreeOfPolymerisationList := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Create;
  result := FDegreeOfPolymerisationList;
end;

Function TFhirSubstancePolymerRepeatRepeatUnit.GetHasDegreeOfPolymerisationList : boolean;
begin
  result := (FDegreeOfPolymerisationList <> nil) and (FDegreeOfPolymerisationList.count > 0);
end;

Function TFhirSubstancePolymerRepeatRepeatUnit.GetStructuralRepresentationList : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList;
begin
  if FStructuralRepresentationList = nil then
    FStructuralRepresentationList := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Create;
  result := FStructuralRepresentationList;
end;

Function TFhirSubstancePolymerRepeatRepeatUnit.GetHasStructuralRepresentationList : boolean;
begin
  result := (FStructuralRepresentationList <> nil) and (FStructuralRepresentationList.count > 0);
end;

function TFhirSubstancePolymerRepeatRepeatUnit.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOrientationOfPolymerisation.sizeInBytes);
  inc(result, FRepeatUnit.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FdegreeOfPolymerisationList.sizeInBytes);
  inc(result, FstructuralRepresentationList.sizeInBytes);
end;

{ TFhirSubstancePolymerRepeatRepeatUnitListEnumerator }

Constructor TFhirSubstancePolymerRepeatRepeatUnitListEnumerator.Create(list : TFhirSubstancePolymerRepeatRepeatUnitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerRepeatRepeatUnitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerRepeatRepeatUnitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerRepeatRepeatUnitListEnumerator.GetCurrent : TFhirSubstancePolymerRepeatRepeatUnit;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerRepeatRepeatUnitListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstancePolymerRepeatRepeatUnitList }
procedure TFhirSubstancePolymerRepeatRepeatUnitList.AddItem(value: TFhirSubstancePolymerRepeatRepeatUnit);
begin
  assert(value.ClassName = 'TFhirSubstancePolymerRepeatRepeatUnit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymerRepeatRepeatUnit');
  add(value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.Append: TFhirSubstancePolymerRepeatRepeatUnit;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.GetEnumerator : TFhirSubstancePolymerRepeatRepeatUnitListEnumerator;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.Clone: TFhirSubstancePolymerRepeatRepeatUnitList;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitList(inherited Clone);
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.GetItemN(index: Integer): TFhirSubstancePolymerRepeatRepeatUnit;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit;
end;
function TFhirSubstancePolymerRepeatRepeatUnitList.IndexOf(value: TFhirSubstancePolymerRepeatRepeatUnit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.Insert(index: Integer): TFhirSubstancePolymerRepeatRepeatUnit;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitList.InsertItem(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnit);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnit);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.Item(index: Integer): TFhirSubstancePolymerRepeatRepeatUnit;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnit(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatRepeatUnitList.Link: TFhirSubstancePolymerRepeatRepeatUnitList;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitList(inherited Link);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnit);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnit);
  FhirSubstancePolymerRepeatRepeatUnits[index] := value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitList.SetItemN(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnit);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnit);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation }

constructor TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.Destroy;
begin
  FDegree.free;
  FAmount.free;
  inherited;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.Assign(oSource : TFslObject);
begin
  inherited;
  degree := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(oSource).degree.Clone;
  amount := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(oSource).amount.Clone;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'degree') Then
     list.add(self.link, 'degree', FDegree.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'degree', 'CodeableConcept', false, TFhirCodeableConcept, FDegree.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'SubstanceAmount', false, TFhirSubstanceAmount, FAmount.Link));{2}
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'degree') then
  begin
    Degree := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirSubstanceAmount{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'degree') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'amount') then result := TFhirSubstanceAmount.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'degree') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'SubstanceAmount'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'degree') then DegreeElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'degree') then DegreeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'amount') then AmountElement := new as TFhirSubstanceAmount{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.fhirType : string;
begin
  result := 'degreeOfPolymerisation';
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.Link : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(inherited Link);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.Clone : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(inherited Clone);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(other);
    result := compareDeep(degreeElement, o.degreeElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDegree) and isEmptyProp(FAmount);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('degree');
  fields.add('amount');
end;

{ TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation }

Procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.SetDegree(value : TFhirCodeableConcept);
begin
  FDegree.free;
  FDegree := value;
end;

Procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.SetAmount(value : TFhirSubstanceAmount);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDegree.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator }

Constructor TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator.Create(list : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator.GetCurrent : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList }
procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.AddItem(value: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
begin
  assert(value.ClassName = 'TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation');
  add(value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Append: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.GetEnumerator : TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Clone: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList(inherited Clone);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.GetItemN(index: Integer): TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
end;
function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.IndexOf(value: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Insert(index: Integer): TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.InsertItem(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Item(index: Integer): TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Link: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList(inherited Link);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
  FhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisations[index] := value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisationList.SetItemN(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnitDegreeOfPolymerisation);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation }

constructor TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.Destroy;
begin
  FType_.free;
  FRepresentation.free;
  FAttachment.free;
  inherited;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(oSource).type_.Clone;
  representationElement := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(oSource).representationElement.Clone;
  attachment := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(oSource).attachment.Clone;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'representation') Then
     list.add(self.link, 'representation', FRepresentation.Link);
  if (child_name = 'attachment') Then
     list.add(self.link, 'attachment', FAttachment.Link);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'representation', 'string', false, TFhirString, FRepresentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'attachment', 'Attachment', false, TFhirAttachment, FAttachment.Link));{2}
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'representation') then
  begin
    RepresentationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'attachment') then
  begin
    Attachment := propValue as TFhirAttachment{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'representation') then result := TFhirString.create() {5b}
  else if (propName = 'attachment') then result := TFhirAttachment.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'representation') then result := 'string'
  else if (propName = 'attachment') then result := 'Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'representation') then RepresentationElement := nil
  else if (propName = 'attachment') then AttachmentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'representation') then RepresentationElement := asString(new){5b}
  else if (propName = 'attachment') then AttachmentElement := new as TFhirAttachment{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.fhirType : string;
begin
  result := 'structuralRepresentation';
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.Link : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(inherited Link);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.Clone : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(inherited Clone);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(representationElement, o.representationElement, true) and 
      compareDeep(attachmentElement, o.attachmentElement, true);
  end;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FRepresentation) and isEmptyProp(FAttachment);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('representation');
  fields.add('attachment');
end;

{ TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation }

Procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.SetRepresentation(value : TFhirString);
begin
  FRepresentation.free;
  FRepresentation := value;
end;

Function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.GetRepresentationST : String;
begin
  if FRepresentation = nil then
    result := ''
  else
    result := FRepresentation.value;
end;

Procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.SetRepresentationST(value : String);
begin
  if value <> '' then
  begin
    if FRepresentation = nil then
      FRepresentation := TFhirString.create;
    FRepresentation.value := value
  end
  else if FRepresentation <> nil then
    FRepresentation.value := '';
end;

Procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.SetAttachment(value : TFhirAttachment);
begin
  FAttachment.free;
  FAttachment := value;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FRepresentation.sizeInBytes);
  inc(result, FAttachment.sizeInBytes);
end;

{ TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator }

Constructor TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator.Create(list : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator.GetCurrent : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList }
procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.AddItem(value: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
begin
  assert(value.ClassName = 'TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation');
  add(value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Append: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.GetEnumerator : TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Clone: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList(inherited Clone);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.GetItemN(index: Integer): TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
end;
function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.IndexOf(value: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Insert(index: Integer): TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.InsertItem(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Item(index: Integer): TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Link: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList;
begin
  result := TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList(inherited Link);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
  FhirSubstancePolymerRepeatRepeatUnitStructuralRepresentations[index] := value;
end;

procedure TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentationList.SetItemN(index: Integer; value: TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
begin
  assert(value is TFhirSubstancePolymerRepeatRepeatUnitStructuralRepresentation);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstancePolymer }

constructor TFhirSubstancePolymer.Create;
begin
  inherited;
end;

destructor TFhirSubstancePolymer.Destroy;
begin
  FClass_.free;
  FGeometry.free;
  FCopolymerConnectivityList.Free;
  FModificationList.Free;
  FMonomerSetList.Free;
  FRepeat_List.Free;
  inherited;
end;

function TFhirSubstancePolymer.GetResourceType : TFhirResourceType;
begin
  result := frtSubstancePolymer;
end;

procedure TFhirSubstancePolymer.Assign(oSource : TFslObject);
begin
  inherited;
  class_ := TFhirSubstancePolymer(oSource).class_.Clone;
  geometry := TFhirSubstancePolymer(oSource).geometry.Clone;
  if (TFhirSubstancePolymer(oSource).FCopolymerConnectivityList = nil) then
  begin
    FCopolymerConnectivityList.free;
    FCopolymerConnectivityList := nil;
  end
  else
  begin
    if FCopolymerConnectivityList = nil then
      FCopolymerConnectivityList := TFhirCodeableConceptList.Create;
    FCopolymerConnectivityList.Assign(TFhirSubstancePolymer(oSource).FCopolymerConnectivityList);
  end;
  if (TFhirSubstancePolymer(oSource).FModificationList = nil) then
  begin
    FModificationList.free;
    FModificationList := nil;
  end
  else
  begin
    if FModificationList = nil then
      FModificationList := TFhirStringList.Create;
    FModificationList.Assign(TFhirSubstancePolymer(oSource).FModificationList);
  end;
  if (TFhirSubstancePolymer(oSource).FMonomerSetList = nil) then
  begin
    FMonomerSetList.free;
    FMonomerSetList := nil;
  end
  else
  begin
    if FMonomerSetList = nil then
      FMonomerSetList := TFhirSubstancePolymerMonomerSetList.Create;
    FMonomerSetList.Assign(TFhirSubstancePolymer(oSource).FMonomerSetList);
  end;
  if (TFhirSubstancePolymer(oSource).FRepeat_List = nil) then
  begin
    FRepeat_List.free;
    FRepeat_List := nil;
  end
  else
  begin
    if FRepeat_List = nil then
      FRepeat_List := TFhirSubstancePolymerRepeatList.Create;
    FRepeat_List.Assign(TFhirSubstancePolymer(oSource).FRepeat_List);
  end;
end;

procedure TFhirSubstancePolymer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'class') Then
     list.add(self.link, 'class', FClass_.Link);
  if (child_name = 'geometry') Then
     list.add(self.link, 'geometry', FGeometry.Link);
  if (child_name = 'copolymerConnectivity') Then
    list.addAll(self, 'copolymerConnectivity', FCopolymerConnectivityList);
  if (child_name = 'modification') Then
    list.addAll(self, 'modification', FModificationList);
  if (child_name = 'monomerSet') Then
    list.addAll(self, 'monomerSet', FMonomerSetList);
  if (child_name = 'repeat') Then
    list.addAll(self, 'repeat', FRepeat_List);
end;

procedure TFhirSubstancePolymer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'class', 'CodeableConcept', false, TFhirCodeableConcept, FClass_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'geometry', 'CodeableConcept', false, TFhirCodeableConcept, FGeometry.Link));{2}
  oList.add(TFHIRProperty.create(self, 'copolymerConnectivity', 'CodeableConcept', true, TFhirCodeableConcept, FCopolymerConnectivityList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'modification', 'string', true, TFhirString, FModificationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'monomerSet', '', true, TFhirSubstancePolymerMonomerSet, FMonomerSetList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'repeat', '', true, TFhirSubstancePolymerRepeat, FRepeat_List.Link)){3};
end;

function TFhirSubstancePolymer.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'class') then
  begin
    Class_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'geometry') then
  begin
    Geometry := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'copolymerConnectivity') then
  begin
    CopolymerConnectivityList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'modification') then
  begin
    ModificationList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'monomerSet') then
  begin
    MonomerSetList.add(propValue as TFhirSubstancePolymerMonomerSet){2a};
    result := propValue;
  end
  else if (propName = 'repeat') then
  begin
    Repeat_List.add(propValue as TFhirSubstancePolymerRepeat){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSubstancePolymer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'copolymerConnectivity') then CopolymerConnectivityList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'modification') then ModificationList.insertItem(index, asString(propValue)){2}
  else if (propName = 'monomerSet') then MonomerSetList.insertItem(index, propValue as TFhirSubstancePolymerMonomerSet){2a}
  else if (propName = 'repeat') then Repeat_List.insertItem(index, propValue as TFhirSubstancePolymerRepeat){2a}
  else inherited;
end;

function TFhirSubstancePolymer.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'class') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'geometry') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'copolymerConnectivity') then result := CopolymerConnectivityList.new(){2}
  else if (propName = 'modification') then result := ModificationList.new(){2}
  else if (propName = 'monomerSet') then result := MonomerSetList.new(){2}
  else if (propName = 'repeat') then result := Repeat_List.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstancePolymer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'class') then result := 'CodeableConcept'
  else if (propName = 'geometry') then result := 'CodeableConcept'
  else if (propName = 'copolymerConnectivity') then result := 'CodeableConcept'
  else if (propName = 'modification') then result := 'string'
  else if (propName = 'monomerSet') then result := ''
  else if (propName = 'repeat') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstancePolymer.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'class') then Class_Element := nil
  else if (propName = 'geometry') then GeometryElement := nil
  else if (propName = 'copolymerConnectivity') then deletePropertyValue('copolymerConnectivity', CopolymerConnectivityList, value) {2}
  else if (propName = 'modification') then deletePropertyValue('modification', ModificationList, value) {2}
  else if (propName = 'monomerSet') then deletePropertyValue('monomerSet', MonomerSetList, value) {2}
  else if (propName = 'repeat') then deletePropertyValue('repeat', Repeat_List, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstancePolymer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'class') then Class_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'geometry') then GeometryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'copolymerConnectivity') then replacePropertyValue('copolymerConnectivity', CopolymerConnectivityList, existing, new) {2}
  else if (propName = 'modification') then replacePropertyValue('modification', ModificationList, existing, new) {2}
  else if (propName = 'monomerSet') then replacePropertyValue('monomerSet', MonomerSetList, existing, new) {2}
  else if (propName = 'repeat') then replacePropertyValue('repeat', Repeat_List, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstancePolymer.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'copolymerConnectivity') then CopolymerConnectivityList.move(source, destination){2a}
  else if (propName = 'modification') then ModificationList.move(source, destination){2}
  else if (propName = 'monomerSet') then MonomerSetList.move(source, destination){2a}
  else if (propName = 'repeat') then Repeat_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstancePolymer.fhirType : string;
begin
  result := 'SubstancePolymer';
end;

function TFhirSubstancePolymer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FClass_) and isEmptyProp(FGeometry) and isEmptyProp(FcopolymerConnectivityList) and isEmptyProp(FmodificationList) and isEmptyProp(FmonomerSetList) and isEmptyProp(Frepeat_List);
end;

function TFhirSubstancePolymer.equals(other : TObject) : boolean; 
var
  o : TFhirSubstancePolymer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstancePolymer)) then
    result := false
  else
  begin
    o := TFhirSubstancePolymer(other);
    result := compareDeep(class_Element, o.class_Element, true) and compareDeep(geometryElement, o.geometryElement, true) and 
      compareDeep(copolymerConnectivityList, o.copolymerConnectivityList, true) and 
      compareDeep(modificationList, o.modificationList, true) and compareDeep(monomerSetList, o.monomerSetList, true) and 
      compareDeep(repeat_List, o.repeat_List, true);
  end;
end;

function TFhirSubstancePolymer.Link : TFhirSubstancePolymer;
begin
  result := TFhirSubstancePolymer(inherited Link);
end;

function TFhirSubstancePolymer.Clone : TFhirSubstancePolymer;
begin
  result := TFhirSubstancePolymer(inherited Clone);
end;

procedure TFhirSubstancePolymer.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('class');
  fields.add('geometry');
  fields.add('copolymerConnectivity');
  fields.add('modification');
  fields.add('monomerSet');
  fields.add('repeat');
end;

{ TFhirSubstancePolymer }

Procedure TFhirSubstancePolymer.SetClass_(value : TFhirCodeableConcept);
begin
  FClass_.free;
  FClass_ := value;
end;

Procedure TFhirSubstancePolymer.SetGeometry(value : TFhirCodeableConcept);
begin
  FGeometry.free;
  FGeometry := value;
end;

Function TFhirSubstancePolymer.GetCopolymerConnectivityList : TFhirCodeableConceptList;
begin
  if FCopolymerConnectivityList = nil then
    FCopolymerConnectivityList := TFhirCodeableConceptList.Create;
  result := FCopolymerConnectivityList;
end;

Function TFhirSubstancePolymer.GetHasCopolymerConnectivityList : boolean;
begin
  result := (FCopolymerConnectivityList <> nil) and (FCopolymerConnectivityList.count > 0);
end;

Function TFhirSubstancePolymer.GetModificationList : TFhirStringList;
begin
  if FModificationList = nil then
    FModificationList := TFhirStringList.Create;
  result := FModificationList;
end;

Function TFhirSubstancePolymer.GetHasModificationList : boolean;
begin
  result := (FModificationList <> nil) and (FModificationList.count > 0);
end;

Function TFhirSubstancePolymer.GetMonomerSetList : TFhirSubstancePolymerMonomerSetList;
begin
  if FMonomerSetList = nil then
    FMonomerSetList := TFhirSubstancePolymerMonomerSetList.Create;
  result := FMonomerSetList;
end;

Function TFhirSubstancePolymer.GetHasMonomerSetList : boolean;
begin
  result := (FMonomerSetList <> nil) and (FMonomerSetList.count > 0);
end;

Function TFhirSubstancePolymer.GetRepeat_List : TFhirSubstancePolymerRepeatList;
begin
  if FRepeat_List = nil then
    FRepeat_List := TFhirSubstancePolymerRepeatList.Create;
  result := FRepeat_List;
end;

Function TFhirSubstancePolymer.GetHasRepeat_List : boolean;
begin
  result := (FRepeat_List <> nil) and (FRepeat_List.count > 0);
end;

function TFhirSubstancePolymer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FClass_.sizeInBytes);
  inc(result, FGeometry.sizeInBytes);
  inc(result, FcopolymerConnectivityList.sizeInBytes);
  inc(result, FmodificationList.sizeInBytes);
  inc(result, FmonomerSetList.sizeInBytes);
  inc(result, Frepeat_List.sizeInBytes);
end;

{ TFhirSubstancePolymerListEnumerator }

Constructor TFhirSubstancePolymerListEnumerator.Create(list : TFhirSubstancePolymerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstancePolymerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstancePolymerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstancePolymerListEnumerator.GetCurrent : TFhirSubstancePolymer;
begin
  Result := FList[FIndex];
end;

function TFhirSubstancePolymerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstancePolymerList }
procedure TFhirSubstancePolymerList.AddItem(value: TFhirSubstancePolymer);
begin
  assert(value.ClassName = 'TFhirSubstancePolymer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstancePolymer');
  add(value);
end;

function TFhirSubstancePolymerList.Append: TFhirSubstancePolymer;
begin
  result := TFhirSubstancePolymer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerList.ClearItems;
begin
  Clear;
end;

function TFhirSubstancePolymerList.GetEnumerator : TFhirSubstancePolymerListEnumerator;
begin
  result := TFhirSubstancePolymerListEnumerator.Create(self.link);
end;

function TFhirSubstancePolymerList.Clone: TFhirSubstancePolymerList;
begin
  result := TFhirSubstancePolymerList(inherited Clone);
end;

function TFhirSubstancePolymerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstancePolymerList.GetItemN(index: Integer): TFhirSubstancePolymer;
begin
  result := TFhirSubstancePolymer(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstancePolymer;
end;
function TFhirSubstancePolymerList.IndexOf(value: TFhirSubstancePolymer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstancePolymerList.Insert(index: Integer): TFhirSubstancePolymer;
begin
  result := TFhirSubstancePolymer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstancePolymerList.InsertItem(index: Integer; value: TFhirSubstancePolymer);
begin
  assert(value is TFhirSubstancePolymer);
  Inherited Insert(index, value);
end;

function TFhirSubstancePolymerList.Item(index: Integer): TFhirSubstancePolymer;
begin
  result := TFhirSubstancePolymer(ObjectByIndex[index]);
end;

function TFhirSubstancePolymerList.Link: TFhirSubstancePolymerList;
begin
  result := TFhirSubstancePolymerList(inherited Link);
end;

procedure TFhirSubstancePolymerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstancePolymerList.SetItemByIndex(index: Integer; value: TFhirSubstancePolymer);
begin
  assert(value is TFhirSubstancePolymer);
  FhirSubstancePolymers[index] := value;
end;

procedure TFhirSubstancePolymerList.SetItemN(index: Integer; value: TFhirSubstancePolymer);
begin
  assert(value is TFhirSubstancePolymer);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCEPOLYMER}

{$IFDEF FHIR_SUBSTANCEPROTEIN}

{ TFhirSubstanceProteinSubunit }

constructor TFhirSubstanceProteinSubunit.Create;
begin
  inherited;
end;

destructor TFhirSubstanceProteinSubunit.Destroy;
begin
  FSubunit.free;
  FSequence.free;
  FLength.free;
  FSequenceAttachment.free;
  FNTerminalModificationId.free;
  FNTerminalModification.free;
  FCTerminalModificationId.free;
  FCTerminalModification.free;
  inherited;
end;

procedure TFhirSubstanceProteinSubunit.Assign(oSource : TFslObject);
begin
  inherited;
  subunitElement := TFhirSubstanceProteinSubunit(oSource).subunitElement.Clone;
  sequenceElement := TFhirSubstanceProteinSubunit(oSource).sequenceElement.Clone;
  lengthElement := TFhirSubstanceProteinSubunit(oSource).lengthElement.Clone;
  sequenceAttachment := TFhirSubstanceProteinSubunit(oSource).sequenceAttachment.Clone;
  nTerminalModificationId := TFhirSubstanceProteinSubunit(oSource).nTerminalModificationId.Clone;
  nTerminalModificationElement := TFhirSubstanceProteinSubunit(oSource).nTerminalModificationElement.Clone;
  cTerminalModificationId := TFhirSubstanceProteinSubunit(oSource).cTerminalModificationId.Clone;
  cTerminalModificationElement := TFhirSubstanceProteinSubunit(oSource).cTerminalModificationElement.Clone;
end;

procedure TFhirSubstanceProteinSubunit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'subunit') Then
     list.add(self.link, 'subunit', FSubunit.Link);
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'length') Then
     list.add(self.link, 'length', FLength.Link);
  if (child_name = 'sequenceAttachment') Then
     list.add(self.link, 'sequenceAttachment', FSequenceAttachment.Link);
  if (child_name = 'nTerminalModificationId') Then
     list.add(self.link, 'nTerminalModificationId', FNTerminalModificationId.Link);
  if (child_name = 'nTerminalModification') Then
     list.add(self.link, 'nTerminalModification', FNTerminalModification.Link);
  if (child_name = 'cTerminalModificationId') Then
     list.add(self.link, 'cTerminalModificationId', FCTerminalModificationId.Link);
  if (child_name = 'cTerminalModification') Then
     list.add(self.link, 'cTerminalModification', FCTerminalModification.Link);
end;

procedure TFhirSubstanceProteinSubunit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'subunit', 'integer', false, TFhirInteger, FSubunit.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sequence', 'string', false, TFhirString, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'length', 'integer', false, TFhirInteger, FLength.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sequenceAttachment', 'Attachment', false, TFhirAttachment, FSequenceAttachment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'nTerminalModificationId', 'Identifier', false, TFhirIdentifier, FNTerminalModificationId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'nTerminalModification', 'string', false, TFhirString, FNTerminalModification.Link));{2}
  oList.add(TFHIRProperty.create(self, 'cTerminalModificationId', 'Identifier', false, TFhirIdentifier, FCTerminalModificationId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'cTerminalModification', 'string', false, TFhirString, FCTerminalModification.Link));{2}
end;

function TFhirSubstanceProteinSubunit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'subunit') then
  begin
    SubunitElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'sequence') then
  begin
    SequenceElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'length') then
  begin
    LengthElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'sequenceAttachment') then
  begin
    SequenceAttachment := propValue as TFhirAttachment{4b};
    result := propValue;
  end
  else if (propName = 'nTerminalModificationId') then
  begin
    NTerminalModificationId := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'nTerminalModification') then
  begin
    NTerminalModificationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'cTerminalModificationId') then
  begin
    CTerminalModificationId := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'cTerminalModification') then
  begin
    CTerminalModificationElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceProteinSubunit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceProteinSubunit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'subunit') then result := TFhirInteger.create() {5b}
  else if (propName = 'sequence') then result := TFhirString.create() {5b}
  else if (propName = 'length') then result := TFhirInteger.create() {5b}
  else if (propName = 'sequenceAttachment') then result := TFhirAttachment.create(){4b}
  else if (propName = 'nTerminalModificationId') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'nTerminalModification') then result := TFhirString.create() {5b}
  else if (propName = 'cTerminalModificationId') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'cTerminalModification') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceProteinSubunit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'subunit') then result := 'integer'
  else if (propName = 'sequence') then result := 'string'
  else if (propName = 'length') then result := 'integer'
  else if (propName = 'sequenceAttachment') then result := 'Attachment'
  else if (propName = 'nTerminalModificationId') then result := 'Identifier'
  else if (propName = 'nTerminalModification') then result := 'string'
  else if (propName = 'cTerminalModificationId') then result := 'Identifier'
  else if (propName = 'cTerminalModification') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceProteinSubunit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'subunit') then SubunitElement := nil
  else if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'length') then LengthElement := nil
  else if (propName = 'sequenceAttachment') then SequenceAttachmentElement := nil
  else if (propName = 'nTerminalModificationId') then NTerminalModificationIdElement := nil
  else if (propName = 'nTerminalModification') then NTerminalModificationElement := nil
  else if (propName = 'cTerminalModificationId') then CTerminalModificationIdElement := nil
  else if (propName = 'cTerminalModification') then CTerminalModificationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceProteinSubunit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'subunit') then SubunitElement := asInteger(new){5b}
  else if (propName = 'sequence') then SequenceElement := asString(new){5b}
  else if (propName = 'length') then LengthElement := asInteger(new){5b}
  else if (propName = 'sequenceAttachment') then SequenceAttachmentElement := new as TFhirAttachment{4}
  else if (propName = 'nTerminalModificationId') then NTerminalModificationIdElement := new as TFhirIdentifier{4}
  else if (propName = 'nTerminalModification') then NTerminalModificationElement := asString(new){5b}
  else if (propName = 'cTerminalModificationId') then CTerminalModificationIdElement := new as TFhirIdentifier{4}
  else if (propName = 'cTerminalModification') then CTerminalModificationElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceProteinSubunit.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceProteinSubunit.fhirType : string;
begin
  result := 'subunit';
end;

function TFhirSubstanceProteinSubunit.Link : TFhirSubstanceProteinSubunit;
begin
  result := TFhirSubstanceProteinSubunit(inherited Link);
end;

function TFhirSubstanceProteinSubunit.Clone : TFhirSubstanceProteinSubunit;
begin
  result := TFhirSubstanceProteinSubunit(inherited Clone);
end;

function TFhirSubstanceProteinSubunit.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceProteinSubunit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceProteinSubunit)) then
    result := false
  else
  begin
    o := TFhirSubstanceProteinSubunit(other);
    result := compareDeep(subunitElement, o.subunitElement, true) and compareDeep(sequenceElement, o.sequenceElement, true) and 
      compareDeep(lengthElement, o.lengthElement, true) and compareDeep(sequenceAttachmentElement, o.sequenceAttachmentElement, true) and 
      compareDeep(nTerminalModificationIdElement, o.nTerminalModificationIdElement, true) and 
      compareDeep(nTerminalModificationElement, o.nTerminalModificationElement, true) and 
      compareDeep(cTerminalModificationIdElement, o.cTerminalModificationIdElement, true) and 
      compareDeep(cTerminalModificationElement, o.cTerminalModificationElement, true);
  end;
end;

function TFhirSubstanceProteinSubunit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubunit) and isEmptyProp(FSequence) and isEmptyProp(FLength) and isEmptyProp(FSequenceAttachment) and isEmptyProp(FNTerminalModificationId) and isEmptyProp(FNTerminalModification) and isEmptyProp(FCTerminalModificationId) and isEmptyProp(FCTerminalModification);
end;

procedure TFhirSubstanceProteinSubunit.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('subunit');
  fields.add('sequence');
  fields.add('length');
  fields.add('sequenceAttachment');
  fields.add('nTerminalModificationId');
  fields.add('nTerminalModification');
  fields.add('cTerminalModificationId');
  fields.add('cTerminalModification');
end;

{ TFhirSubstanceProteinSubunit }

Procedure TFhirSubstanceProteinSubunit.SetSubunit(value : TFhirInteger);
begin
  FSubunit.free;
  FSubunit := value;
end;

Function TFhirSubstanceProteinSubunit.GetSubunitST : String;
begin
  if FSubunit = nil then
    result := ''
  else
    result := FSubunit.value;
end;

Procedure TFhirSubstanceProteinSubunit.SetSubunitST(value : String);
begin
  if value <> '' then
  begin
    if FSubunit = nil then
      FSubunit := TFhirInteger.create;
    FSubunit.value := value
  end
  else if FSubunit <> nil then
    FSubunit.value := '';
end;

Procedure TFhirSubstanceProteinSubunit.SetSequence(value : TFhirString);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirSubstanceProteinSubunit.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirSubstanceProteinSubunit.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirString.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirSubstanceProteinSubunit.SetLength(value : TFhirInteger);
begin
  FLength.free;
  FLength := value;
end;

Function TFhirSubstanceProteinSubunit.GetLengthST : String;
begin
  if FLength = nil then
    result := ''
  else
    result := FLength.value;
end;

Procedure TFhirSubstanceProteinSubunit.SetLengthST(value : String);
begin
  if value <> '' then
  begin
    if FLength = nil then
      FLength := TFhirInteger.create;
    FLength.value := value
  end
  else if FLength <> nil then
    FLength.value := '';
end;

Procedure TFhirSubstanceProteinSubunit.SetSequenceAttachment(value : TFhirAttachment);
begin
  FSequenceAttachment.free;
  FSequenceAttachment := value;
end;

Procedure TFhirSubstanceProteinSubunit.SetNTerminalModificationId(value : TFhirIdentifier);
begin
  FNTerminalModificationId.free;
  FNTerminalModificationId := value;
end;

Procedure TFhirSubstanceProteinSubunit.SetNTerminalModification(value : TFhirString);
begin
  FNTerminalModification.free;
  FNTerminalModification := value;
end;

Function TFhirSubstanceProteinSubunit.GetNTerminalModificationST : String;
begin
  if FNTerminalModification = nil then
    result := ''
  else
    result := FNTerminalModification.value;
end;

Procedure TFhirSubstanceProteinSubunit.SetNTerminalModificationST(value : String);
begin
  if value <> '' then
  begin
    if FNTerminalModification = nil then
      FNTerminalModification := TFhirString.create;
    FNTerminalModification.value := value
  end
  else if FNTerminalModification <> nil then
    FNTerminalModification.value := '';
end;

Procedure TFhirSubstanceProteinSubunit.SetCTerminalModificationId(value : TFhirIdentifier);
begin
  FCTerminalModificationId.free;
  FCTerminalModificationId := value;
end;

Procedure TFhirSubstanceProteinSubunit.SetCTerminalModification(value : TFhirString);
begin
  FCTerminalModification.free;
  FCTerminalModification := value;
end;

Function TFhirSubstanceProteinSubunit.GetCTerminalModificationST : String;
begin
  if FCTerminalModification = nil then
    result := ''
  else
    result := FCTerminalModification.value;
end;

Procedure TFhirSubstanceProteinSubunit.SetCTerminalModificationST(value : String);
begin
  if value <> '' then
  begin
    if FCTerminalModification = nil then
      FCTerminalModification := TFhirString.create;
    FCTerminalModification.value := value
  end
  else if FCTerminalModification <> nil then
    FCTerminalModification.value := '';
end;

function TFhirSubstanceProteinSubunit.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSubunit.sizeInBytes);
  inc(result, FSequence.sizeInBytes);
  inc(result, FLength.sizeInBytes);
  inc(result, FSequenceAttachment.sizeInBytes);
  inc(result, FNTerminalModificationId.sizeInBytes);
  inc(result, FNTerminalModification.sizeInBytes);
  inc(result, FCTerminalModificationId.sizeInBytes);
  inc(result, FCTerminalModification.sizeInBytes);
end;

{ TFhirSubstanceProteinSubunitListEnumerator }

Constructor TFhirSubstanceProteinSubunitListEnumerator.Create(list : TFhirSubstanceProteinSubunitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceProteinSubunitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceProteinSubunitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceProteinSubunitListEnumerator.GetCurrent : TFhirSubstanceProteinSubunit;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceProteinSubunitListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceProteinSubunitList }
procedure TFhirSubstanceProteinSubunitList.AddItem(value: TFhirSubstanceProteinSubunit);
begin
  assert(value.ClassName = 'TFhirSubstanceProteinSubunit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceProteinSubunit');
  add(value);
end;

function TFhirSubstanceProteinSubunitList.Append: TFhirSubstanceProteinSubunit;
begin
  result := TFhirSubstanceProteinSubunit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceProteinSubunitList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceProteinSubunitList.GetEnumerator : TFhirSubstanceProteinSubunitListEnumerator;
begin
  result := TFhirSubstanceProteinSubunitListEnumerator.Create(self.link);
end;

function TFhirSubstanceProteinSubunitList.Clone: TFhirSubstanceProteinSubunitList;
begin
  result := TFhirSubstanceProteinSubunitList(inherited Clone);
end;

function TFhirSubstanceProteinSubunitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceProteinSubunitList.GetItemN(index: Integer): TFhirSubstanceProteinSubunit;
begin
  result := TFhirSubstanceProteinSubunit(ObjectByIndex[index]);
end;

function TFhirSubstanceProteinSubunitList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceProteinSubunit;
end;
function TFhirSubstanceProteinSubunitList.IndexOf(value: TFhirSubstanceProteinSubunit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceProteinSubunitList.Insert(index: Integer): TFhirSubstanceProteinSubunit;
begin
  result := TFhirSubstanceProteinSubunit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceProteinSubunitList.InsertItem(index: Integer; value: TFhirSubstanceProteinSubunit);
begin
  assert(value is TFhirSubstanceProteinSubunit);
  Inherited Insert(index, value);
end;

function TFhirSubstanceProteinSubunitList.Item(index: Integer): TFhirSubstanceProteinSubunit;
begin
  result := TFhirSubstanceProteinSubunit(ObjectByIndex[index]);
end;

function TFhirSubstanceProteinSubunitList.Link: TFhirSubstanceProteinSubunitList;
begin
  result := TFhirSubstanceProteinSubunitList(inherited Link);
end;

procedure TFhirSubstanceProteinSubunitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceProteinSubunitList.SetItemByIndex(index: Integer; value: TFhirSubstanceProteinSubunit);
begin
  assert(value is TFhirSubstanceProteinSubunit);
  FhirSubstanceProteinSubunits[index] := value;
end;

procedure TFhirSubstanceProteinSubunitList.SetItemN(index: Integer; value: TFhirSubstanceProteinSubunit);
begin
  assert(value is TFhirSubstanceProteinSubunit);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceProtein }

constructor TFhirSubstanceProtein.Create;
begin
  inherited;
end;

destructor TFhirSubstanceProtein.Destroy;
begin
  FSequenceType.free;
  FNumberOfSubunits.free;
  FDisulfideLinkageList.Free;
  FSubunitList.Free;
  inherited;
end;

function TFhirSubstanceProtein.GetResourceType : TFhirResourceType;
begin
  result := frtSubstanceProtein;
end;

procedure TFhirSubstanceProtein.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceType := TFhirSubstanceProtein(oSource).sequenceType.Clone;
  numberOfSubunitsElement := TFhirSubstanceProtein(oSource).numberOfSubunitsElement.Clone;
  if (TFhirSubstanceProtein(oSource).FDisulfideLinkageList = nil) then
  begin
    FDisulfideLinkageList.free;
    FDisulfideLinkageList := nil;
  end
  else
  begin
    if FDisulfideLinkageList = nil then
      FDisulfideLinkageList := TFhirStringList.Create;
    FDisulfideLinkageList.Assign(TFhirSubstanceProtein(oSource).FDisulfideLinkageList);
  end;
  if (TFhirSubstanceProtein(oSource).FSubunitList = nil) then
  begin
    FSubunitList.free;
    FSubunitList := nil;
  end
  else
  begin
    if FSubunitList = nil then
      FSubunitList := TFhirSubstanceProteinSubunitList.Create;
    FSubunitList.Assign(TFhirSubstanceProtein(oSource).FSubunitList);
  end;
end;

procedure TFhirSubstanceProtein.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequenceType') Then
     list.add(self.link, 'sequenceType', FSequenceType.Link);
  if (child_name = 'numberOfSubunits') Then
     list.add(self.link, 'numberOfSubunits', FNumberOfSubunits.Link);
  if (child_name = 'disulfideLinkage') Then
    list.addAll(self, 'disulfideLinkage', FDisulfideLinkageList);
  if (child_name = 'subunit') Then
    list.addAll(self, 'subunit', FSubunitList);
end;

procedure TFhirSubstanceProtein.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequenceType', 'CodeableConcept', false, TFhirCodeableConcept, FSequenceType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'numberOfSubunits', 'integer', false, TFhirInteger, FNumberOfSubunits.Link));{2}
  oList.add(TFHIRProperty.create(self, 'disulfideLinkage', 'string', true, TFhirString, FDisulfideLinkageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subunit', '', true, TFhirSubstanceProteinSubunit, FSubunitList.Link)){3};
end;

function TFhirSubstanceProtein.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequenceType') then
  begin
    SequenceType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'numberOfSubunits') then
  begin
    NumberOfSubunitsElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'disulfideLinkage') then
  begin
    DisulfideLinkageList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'subunit') then
  begin
    SubunitList.add(propValue as TFhirSubstanceProteinSubunit){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSubstanceProtein.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'disulfideLinkage') then DisulfideLinkageList.insertItem(index, asString(propValue)){2}
  else if (propName = 'subunit') then SubunitList.insertItem(index, propValue as TFhirSubstanceProteinSubunit){2a}
  else inherited;
end;

function TFhirSubstanceProtein.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'sequenceType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'numberOfSubunits') then result := TFhirInteger.create() {5b}
  else if (propName = 'disulfideLinkage') then result := DisulfideLinkageList.new(){2}
  else if (propName = 'subunit') then result := SubunitList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceProtein.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequenceType') then result := 'CodeableConcept'
  else if (propName = 'numberOfSubunits') then result := 'integer'
  else if (propName = 'disulfideLinkage') then result := 'string'
  else if (propName = 'subunit') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceProtein.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'sequenceType') then SequenceTypeElement := nil
  else if (propName = 'numberOfSubunits') then NumberOfSubunitsElement := nil
  else if (propName = 'disulfideLinkage') then deletePropertyValue('disulfideLinkage', DisulfideLinkageList, value) {2}
  else if (propName = 'subunit') then deletePropertyValue('subunit', SubunitList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceProtein.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequenceType') then SequenceTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'numberOfSubunits') then NumberOfSubunitsElement := asInteger(new){5b}
  else if (propName = 'disulfideLinkage') then replacePropertyValue('disulfideLinkage', DisulfideLinkageList, existing, new) {2}
  else if (propName = 'subunit') then replacePropertyValue('subunit', SubunitList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceProtein.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'disulfideLinkage') then DisulfideLinkageList.move(source, destination){2}
  else if (propName = 'subunit') then SubunitList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceProtein.fhirType : string;
begin
  result := 'SubstanceProtein';
end;

function TFhirSubstanceProtein.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequenceType) and isEmptyProp(FNumberOfSubunits) and isEmptyProp(FdisulfideLinkageList) and isEmptyProp(FsubunitList);
end;

function TFhirSubstanceProtein.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceProtein;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceProtein)) then
    result := false
  else
  begin
    o := TFhirSubstanceProtein(other);
    result := compareDeep(sequenceTypeElement, o.sequenceTypeElement, true) and 
      compareDeep(numberOfSubunitsElement, o.numberOfSubunitsElement, true) and compareDeep(disulfideLinkageList, o.disulfideLinkageList, true) and 
      compareDeep(subunitList, o.subunitList, true);
  end;
end;

function TFhirSubstanceProtein.Link : TFhirSubstanceProtein;
begin
  result := TFhirSubstanceProtein(inherited Link);
end;

function TFhirSubstanceProtein.Clone : TFhirSubstanceProtein;
begin
  result := TFhirSubstanceProtein(inherited Clone);
end;

procedure TFhirSubstanceProtein.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('sequenceType');
  fields.add('numberOfSubunits');
  fields.add('disulfideLinkage');
  fields.add('subunit');
end;

{ TFhirSubstanceProtein }

Procedure TFhirSubstanceProtein.SetSequenceType(value : TFhirCodeableConcept);
begin
  FSequenceType.free;
  FSequenceType := value;
end;

Procedure TFhirSubstanceProtein.SetNumberOfSubunits(value : TFhirInteger);
begin
  FNumberOfSubunits.free;
  FNumberOfSubunits := value;
end;

Function TFhirSubstanceProtein.GetNumberOfSubunitsST : String;
begin
  if FNumberOfSubunits = nil then
    result := ''
  else
    result := FNumberOfSubunits.value;
end;

Procedure TFhirSubstanceProtein.SetNumberOfSubunitsST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfSubunits = nil then
      FNumberOfSubunits := TFhirInteger.create;
    FNumberOfSubunits.value := value
  end
  else if FNumberOfSubunits <> nil then
    FNumberOfSubunits.value := '';
end;

Function TFhirSubstanceProtein.GetDisulfideLinkageList : TFhirStringList;
begin
  if FDisulfideLinkageList = nil then
    FDisulfideLinkageList := TFhirStringList.Create;
  result := FDisulfideLinkageList;
end;

Function TFhirSubstanceProtein.GetHasDisulfideLinkageList : boolean;
begin
  result := (FDisulfideLinkageList <> nil) and (FDisulfideLinkageList.count > 0);
end;

Function TFhirSubstanceProtein.GetSubunitList : TFhirSubstanceProteinSubunitList;
begin
  if FSubunitList = nil then
    FSubunitList := TFhirSubstanceProteinSubunitList.Create;
  result := FSubunitList;
end;

Function TFhirSubstanceProtein.GetHasSubunitList : boolean;
begin
  result := (FSubunitList <> nil) and (FSubunitList.count > 0);
end;

function TFhirSubstanceProtein.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequenceType.sizeInBytes);
  inc(result, FNumberOfSubunits.sizeInBytes);
  inc(result, FdisulfideLinkageList.sizeInBytes);
  inc(result, FsubunitList.sizeInBytes);
end;

{ TFhirSubstanceProteinListEnumerator }

Constructor TFhirSubstanceProteinListEnumerator.Create(list : TFhirSubstanceProteinList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceProteinListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceProteinListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceProteinListEnumerator.GetCurrent : TFhirSubstanceProtein;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceProteinListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceProteinList }
procedure TFhirSubstanceProteinList.AddItem(value: TFhirSubstanceProtein);
begin
  assert(value.ClassName = 'TFhirSubstanceProtein', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceProtein');
  add(value);
end;

function TFhirSubstanceProteinList.Append: TFhirSubstanceProtein;
begin
  result := TFhirSubstanceProtein.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceProteinList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceProteinList.GetEnumerator : TFhirSubstanceProteinListEnumerator;
begin
  result := TFhirSubstanceProteinListEnumerator.Create(self.link);
end;

function TFhirSubstanceProteinList.Clone: TFhirSubstanceProteinList;
begin
  result := TFhirSubstanceProteinList(inherited Clone);
end;

function TFhirSubstanceProteinList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceProteinList.GetItemN(index: Integer): TFhirSubstanceProtein;
begin
  result := TFhirSubstanceProtein(ObjectByIndex[index]);
end;

function TFhirSubstanceProteinList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceProtein;
end;
function TFhirSubstanceProteinList.IndexOf(value: TFhirSubstanceProtein): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceProteinList.Insert(index: Integer): TFhirSubstanceProtein;
begin
  result := TFhirSubstanceProtein.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceProteinList.InsertItem(index: Integer; value: TFhirSubstanceProtein);
begin
  assert(value is TFhirSubstanceProtein);
  Inherited Insert(index, value);
end;

function TFhirSubstanceProteinList.Item(index: Integer): TFhirSubstanceProtein;
begin
  result := TFhirSubstanceProtein(ObjectByIndex[index]);
end;

function TFhirSubstanceProteinList.Link: TFhirSubstanceProteinList;
begin
  result := TFhirSubstanceProteinList(inherited Link);
end;

procedure TFhirSubstanceProteinList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceProteinList.SetItemByIndex(index: Integer; value: TFhirSubstanceProtein);
begin
  assert(value is TFhirSubstanceProtein);
  FhirSubstanceProteins[index] := value;
end;

procedure TFhirSubstanceProteinList.SetItemN(index: Integer; value: TFhirSubstanceProtein);
begin
  assert(value is TFhirSubstanceProtein);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCEPROTEIN}

{$IFDEF FHIR_SUBSTANCEREFERENCEINFORMATION}

{ TFhirSubstanceReferenceInformationGene }

constructor TFhirSubstanceReferenceInformationGene.Create;
begin
  inherited;
end;

destructor TFhirSubstanceReferenceInformationGene.Destroy;
begin
  FGeneSequenceOrigin.free;
  FGene.free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceReferenceInformationGene.Assign(oSource : TFslObject);
begin
  inherited;
  geneSequenceOrigin := TFhirSubstanceReferenceInformationGene(oSource).geneSequenceOrigin.Clone;
  gene := TFhirSubstanceReferenceInformationGene(oSource).gene.Clone;
  if (TFhirSubstanceReferenceInformationGene(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList{TFhirDocumentReference}.Create;
    FSourceList.Assign(TFhirSubstanceReferenceInformationGene(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceReferenceInformationGene.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'geneSequenceOrigin') Then
     list.add(self.link, 'geneSequenceOrigin', FGeneSequenceOrigin.Link);
  if (child_name = 'gene') Then
     list.add(self.link, 'gene', FGene.Link);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceReferenceInformationGene.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'geneSequenceOrigin', 'CodeableConcept', false, TFhirCodeableConcept, FGeneSequenceOrigin.Link));{2}
  oList.add(TFHIRProperty.create(self, 'gene', 'CodeableConcept', false, TFhirCodeableConcept, FGene.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference(DocumentReference)', true, TFhirReference{TFhirDocumentReference}, FSourceList.Link)){3};
end;

function TFhirSubstanceReferenceInformationGene.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'geneSequenceOrigin') then
  begin
    GeneSequenceOrigin := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'gene') then
  begin
    Gene := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference{TFhirDocumentReference}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceReferenceInformationGene.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference{TFhirDocumentReference}){2a}
  else inherited;
end;

function TFhirSubstanceReferenceInformationGene.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'geneSequenceOrigin') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'gene') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'source') then result := SourceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceReferenceInformationGene.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'geneSequenceOrigin') then result := 'CodeableConcept'
  else if (propName = 'gene') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceReferenceInformationGene.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'geneSequenceOrigin') then GeneSequenceOriginElement := nil
  else if (propName = 'gene') then GeneElement := nil
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceReferenceInformationGene.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'geneSequenceOrigin') then GeneSequenceOriginElement := new as TFhirCodeableConcept{4}
  else if (propName = 'gene') then GeneElement := new as TFhirCodeableConcept{4}
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceReferenceInformationGene.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'source') then SourceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceReferenceInformationGene.fhirType : string;
begin
  result := 'gene';
end;

function TFhirSubstanceReferenceInformationGene.Link : TFhirSubstanceReferenceInformationGene;
begin
  result := TFhirSubstanceReferenceInformationGene(inherited Link);
end;

function TFhirSubstanceReferenceInformationGene.Clone : TFhirSubstanceReferenceInformationGene;
begin
  result := TFhirSubstanceReferenceInformationGene(inherited Clone);
end;

function TFhirSubstanceReferenceInformationGene.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceReferenceInformationGene;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceReferenceInformationGene)) then
    result := false
  else
  begin
    o := TFhirSubstanceReferenceInformationGene(other);
    result := compareDeep(geneSequenceOriginElement, o.geneSequenceOriginElement, true) and 
      compareDeep(geneElement, o.geneElement, true) and compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceReferenceInformationGene.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FGeneSequenceOrigin) and isEmptyProp(FGene) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceReferenceInformationGene.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('geneSequenceOrigin');
  fields.add('gene');
  fields.add('source');
end;

{ TFhirSubstanceReferenceInformationGene }

Procedure TFhirSubstanceReferenceInformationGene.SetGeneSequenceOrigin(value : TFhirCodeableConcept);
begin
  FGeneSequenceOrigin.free;
  FGeneSequenceOrigin := value;
end;

Procedure TFhirSubstanceReferenceInformationGene.SetGene(value : TFhirCodeableConcept);
begin
  FGene.free;
  FGene := value;
end;

Function TFhirSubstanceReferenceInformationGene.GetSourceList : TFhirReferenceList{TFhirDocumentReference};
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList{TFhirDocumentReference}.Create;
  result := FSourceList;
end;

Function TFhirSubstanceReferenceInformationGene.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

function TFhirSubstanceReferenceInformationGene.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FGeneSequenceOrigin.sizeInBytes);
  inc(result, FGene.sizeInBytes);
  inc(result, FsourceList.sizeInBytes);
end;

{ TFhirSubstanceReferenceInformationGeneListEnumerator }

Constructor TFhirSubstanceReferenceInformationGeneListEnumerator.Create(list : TFhirSubstanceReferenceInformationGeneList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceReferenceInformationGeneListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceReferenceInformationGeneListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceReferenceInformationGeneListEnumerator.GetCurrent : TFhirSubstanceReferenceInformationGene;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceReferenceInformationGeneListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceReferenceInformationGeneList }
procedure TFhirSubstanceReferenceInformationGeneList.AddItem(value: TFhirSubstanceReferenceInformationGene);
begin
  assert(value.ClassName = 'TFhirSubstanceReferenceInformationGene', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceReferenceInformationGene');
  add(value);
end;

function TFhirSubstanceReferenceInformationGeneList.Append: TFhirSubstanceReferenceInformationGene;
begin
  result := TFhirSubstanceReferenceInformationGene.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationGeneList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceReferenceInformationGeneList.GetEnumerator : TFhirSubstanceReferenceInformationGeneListEnumerator;
begin
  result := TFhirSubstanceReferenceInformationGeneListEnumerator.Create(self.link);
end;

function TFhirSubstanceReferenceInformationGeneList.Clone: TFhirSubstanceReferenceInformationGeneList;
begin
  result := TFhirSubstanceReferenceInformationGeneList(inherited Clone);
end;

function TFhirSubstanceReferenceInformationGeneList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceReferenceInformationGeneList.GetItemN(index: Integer): TFhirSubstanceReferenceInformationGene;
begin
  result := TFhirSubstanceReferenceInformationGene(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationGeneList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceReferenceInformationGene;
end;
function TFhirSubstanceReferenceInformationGeneList.IndexOf(value: TFhirSubstanceReferenceInformationGene): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceReferenceInformationGeneList.Insert(index: Integer): TFhirSubstanceReferenceInformationGene;
begin
  result := TFhirSubstanceReferenceInformationGene.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationGeneList.InsertItem(index: Integer; value: TFhirSubstanceReferenceInformationGene);
begin
  assert(value is TFhirSubstanceReferenceInformationGene);
  Inherited Insert(index, value);
end;

function TFhirSubstanceReferenceInformationGeneList.Item(index: Integer): TFhirSubstanceReferenceInformationGene;
begin
  result := TFhirSubstanceReferenceInformationGene(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationGeneList.Link: TFhirSubstanceReferenceInformationGeneList;
begin
  result := TFhirSubstanceReferenceInformationGeneList(inherited Link);
end;

procedure TFhirSubstanceReferenceInformationGeneList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceReferenceInformationGeneList.SetItemByIndex(index: Integer; value: TFhirSubstanceReferenceInformationGene);
begin
  assert(value is TFhirSubstanceReferenceInformationGene);
  FhirSubstanceReferenceInformationGenes[index] := value;
end;

procedure TFhirSubstanceReferenceInformationGeneList.SetItemN(index: Integer; value: TFhirSubstanceReferenceInformationGene);
begin
  assert(value is TFhirSubstanceReferenceInformationGene);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceReferenceInformationGeneElement }

constructor TFhirSubstanceReferenceInformationGeneElement.Create;
begin
  inherited;
end;

destructor TFhirSubstanceReferenceInformationGeneElement.Destroy;
begin
  FType_.free;
  FElement.free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceReferenceInformationGeneElement.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirSubstanceReferenceInformationGeneElement(oSource).type_.Clone;
  element := TFhirSubstanceReferenceInformationGeneElement(oSource).element.Clone;
  if (TFhirSubstanceReferenceInformationGeneElement(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList{TFhirDocumentReference}.Create;
    FSourceList.Assign(TFhirSubstanceReferenceInformationGeneElement(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceReferenceInformationGeneElement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'element') Then
     list.add(self.link, 'element', FElement.Link);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceReferenceInformationGeneElement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'element', 'Identifier', false, TFhirIdentifier, FElement.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference(DocumentReference)', true, TFhirReference{TFhirDocumentReference}, FSourceList.Link)){3};
end;

function TFhirSubstanceReferenceInformationGeneElement.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'element') then
  begin
    Element := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference{TFhirDocumentReference}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceReferenceInformationGeneElement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference{TFhirDocumentReference}){2a}
  else inherited;
end;

function TFhirSubstanceReferenceInformationGeneElement.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'element') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'source') then result := SourceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceReferenceInformationGeneElement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'element') then result := 'Identifier'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceReferenceInformationGeneElement.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'element') then ElementElement := nil
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceReferenceInformationGeneElement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'element') then ElementElement := new as TFhirIdentifier{4}
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceReferenceInformationGeneElement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'source') then SourceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceReferenceInformationGeneElement.fhirType : string;
begin
  result := 'geneElement';
end;

function TFhirSubstanceReferenceInformationGeneElement.Link : TFhirSubstanceReferenceInformationGeneElement;
begin
  result := TFhirSubstanceReferenceInformationGeneElement(inherited Link);
end;

function TFhirSubstanceReferenceInformationGeneElement.Clone : TFhirSubstanceReferenceInformationGeneElement;
begin
  result := TFhirSubstanceReferenceInformationGeneElement(inherited Clone);
end;

function TFhirSubstanceReferenceInformationGeneElement.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceReferenceInformationGeneElement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceReferenceInformationGeneElement)) then
    result := false
  else
  begin
    o := TFhirSubstanceReferenceInformationGeneElement(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(elementElement, o.elementElement, true) and 
      compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceReferenceInformationGeneElement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FElement) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceReferenceInformationGeneElement.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('element');
  fields.add('source');
end;

{ TFhirSubstanceReferenceInformationGeneElement }

Procedure TFhirSubstanceReferenceInformationGeneElement.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSubstanceReferenceInformationGeneElement.SetElement(value : TFhirIdentifier);
begin
  FElement.free;
  FElement := value;
end;

Function TFhirSubstanceReferenceInformationGeneElement.GetSourceList : TFhirReferenceList{TFhirDocumentReference};
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList{TFhirDocumentReference}.Create;
  result := FSourceList;
end;

Function TFhirSubstanceReferenceInformationGeneElement.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

function TFhirSubstanceReferenceInformationGeneElement.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FElement.sizeInBytes);
  inc(result, FsourceList.sizeInBytes);
end;

{ TFhirSubstanceReferenceInformationGeneElementListEnumerator }

Constructor TFhirSubstanceReferenceInformationGeneElementListEnumerator.Create(list : TFhirSubstanceReferenceInformationGeneElementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceReferenceInformationGeneElementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceReferenceInformationGeneElementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceReferenceInformationGeneElementListEnumerator.GetCurrent : TFhirSubstanceReferenceInformationGeneElement;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceReferenceInformationGeneElementListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceReferenceInformationGeneElementList }
procedure TFhirSubstanceReferenceInformationGeneElementList.AddItem(value: TFhirSubstanceReferenceInformationGeneElement);
begin
  assert(value.ClassName = 'TFhirSubstanceReferenceInformationGeneElement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceReferenceInformationGeneElement');
  add(value);
end;

function TFhirSubstanceReferenceInformationGeneElementList.Append: TFhirSubstanceReferenceInformationGeneElement;
begin
  result := TFhirSubstanceReferenceInformationGeneElement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationGeneElementList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceReferenceInformationGeneElementList.GetEnumerator : TFhirSubstanceReferenceInformationGeneElementListEnumerator;
begin
  result := TFhirSubstanceReferenceInformationGeneElementListEnumerator.Create(self.link);
end;

function TFhirSubstanceReferenceInformationGeneElementList.Clone: TFhirSubstanceReferenceInformationGeneElementList;
begin
  result := TFhirSubstanceReferenceInformationGeneElementList(inherited Clone);
end;

function TFhirSubstanceReferenceInformationGeneElementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceReferenceInformationGeneElementList.GetItemN(index: Integer): TFhirSubstanceReferenceInformationGeneElement;
begin
  result := TFhirSubstanceReferenceInformationGeneElement(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationGeneElementList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceReferenceInformationGeneElement;
end;
function TFhirSubstanceReferenceInformationGeneElementList.IndexOf(value: TFhirSubstanceReferenceInformationGeneElement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceReferenceInformationGeneElementList.Insert(index: Integer): TFhirSubstanceReferenceInformationGeneElement;
begin
  result := TFhirSubstanceReferenceInformationGeneElement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationGeneElementList.InsertItem(index: Integer; value: TFhirSubstanceReferenceInformationGeneElement);
begin
  assert(value is TFhirSubstanceReferenceInformationGeneElement);
  Inherited Insert(index, value);
end;

function TFhirSubstanceReferenceInformationGeneElementList.Item(index: Integer): TFhirSubstanceReferenceInformationGeneElement;
begin
  result := TFhirSubstanceReferenceInformationGeneElement(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationGeneElementList.Link: TFhirSubstanceReferenceInformationGeneElementList;
begin
  result := TFhirSubstanceReferenceInformationGeneElementList(inherited Link);
end;

procedure TFhirSubstanceReferenceInformationGeneElementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceReferenceInformationGeneElementList.SetItemByIndex(index: Integer; value: TFhirSubstanceReferenceInformationGeneElement);
begin
  assert(value is TFhirSubstanceReferenceInformationGeneElement);
  FhirSubstanceReferenceInformationGeneElements[index] := value;
end;

procedure TFhirSubstanceReferenceInformationGeneElementList.SetItemN(index: Integer; value: TFhirSubstanceReferenceInformationGeneElement);
begin
  assert(value is TFhirSubstanceReferenceInformationGeneElement);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceReferenceInformationClassification }

constructor TFhirSubstanceReferenceInformationClassification.Create;
begin
  inherited;
end;

destructor TFhirSubstanceReferenceInformationClassification.Destroy;
begin
  FDomain.free;
  FClassification.free;
  FSubtypeList.Free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceReferenceInformationClassification.Assign(oSource : TFslObject);
begin
  inherited;
  domain := TFhirSubstanceReferenceInformationClassification(oSource).domain.Clone;
  classification := TFhirSubstanceReferenceInformationClassification(oSource).classification.Clone;
  if (TFhirSubstanceReferenceInformationClassification(oSource).FSubtypeList = nil) then
  begin
    FSubtypeList.free;
    FSubtypeList := nil;
  end
  else
  begin
    if FSubtypeList = nil then
      FSubtypeList := TFhirCodeableConceptList.Create;
    FSubtypeList.Assign(TFhirSubstanceReferenceInformationClassification(oSource).FSubtypeList);
  end;
  if (TFhirSubstanceReferenceInformationClassification(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList{TFhirDocumentReference}.Create;
    FSourceList.Assign(TFhirSubstanceReferenceInformationClassification(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceReferenceInformationClassification.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'domain') Then
     list.add(self.link, 'domain', FDomain.Link);
  if (child_name = 'classification') Then
     list.add(self.link, 'classification', FClassification.Link);
  if (child_name = 'subtype') Then
    list.addAll(self, 'subtype', FSubtypeList);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceReferenceInformationClassification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'domain', 'CodeableConcept', false, TFhirCodeableConcept, FDomain.Link));{2}
  oList.add(TFHIRProperty.create(self, 'classification', 'CodeableConcept', false, TFhirCodeableConcept, FClassification.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subtype', 'CodeableConcept', true, TFhirCodeableConcept, FSubtypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'source', 'Reference(DocumentReference)', true, TFhirReference{TFhirDocumentReference}, FSourceList.Link)){3};
end;

function TFhirSubstanceReferenceInformationClassification.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'domain') then
  begin
    Domain := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'classification') then
  begin
    Classification := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subtype') then
  begin
    SubtypeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference{TFhirDocumentReference}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceReferenceInformationClassification.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'subtype') then SubtypeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference{TFhirDocumentReference}){2a}
  else inherited;
end;

function TFhirSubstanceReferenceInformationClassification.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'domain') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'classification') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subtype') then result := SubtypeList.new(){2}
  else if (propName = 'source') then result := SourceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceReferenceInformationClassification.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'domain') then result := 'CodeableConcept'
  else if (propName = 'classification') then result := 'CodeableConcept'
  else if (propName = 'subtype') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceReferenceInformationClassification.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'domain') then DomainElement := nil
  else if (propName = 'classification') then ClassificationElement := nil
  else if (propName = 'subtype') then deletePropertyValue('subtype', SubtypeList, value) {2}
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceReferenceInformationClassification.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'domain') then DomainElement := new as TFhirCodeableConcept{4}
  else if (propName = 'classification') then ClassificationElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subtype') then replacePropertyValue('subtype', SubtypeList, existing, new) {2}
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceReferenceInformationClassification.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'subtype') then SubtypeList.move(source, destination){2a}
  else if (propName = 'source') then SourceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceReferenceInformationClassification.fhirType : string;
begin
  result := 'classification';
end;

function TFhirSubstanceReferenceInformationClassification.Link : TFhirSubstanceReferenceInformationClassification;
begin
  result := TFhirSubstanceReferenceInformationClassification(inherited Link);
end;

function TFhirSubstanceReferenceInformationClassification.Clone : TFhirSubstanceReferenceInformationClassification;
begin
  result := TFhirSubstanceReferenceInformationClassification(inherited Clone);
end;

function TFhirSubstanceReferenceInformationClassification.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceReferenceInformationClassification;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceReferenceInformationClassification)) then
    result := false
  else
  begin
    o := TFhirSubstanceReferenceInformationClassification(other);
    result := compareDeep(domainElement, o.domainElement, true) and compareDeep(classificationElement, o.classificationElement, true) and 
      compareDeep(subtypeList, o.subtypeList, true) and compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceReferenceInformationClassification.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDomain) and isEmptyProp(FClassification) and isEmptyProp(FsubtypeList) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceReferenceInformationClassification.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('domain');
  fields.add('classification');
  fields.add('subtype');
  fields.add('source');
end;

{ TFhirSubstanceReferenceInformationClassification }

Procedure TFhirSubstanceReferenceInformationClassification.SetDomain(value : TFhirCodeableConcept);
begin
  FDomain.free;
  FDomain := value;
end;

Procedure TFhirSubstanceReferenceInformationClassification.SetClassification(value : TFhirCodeableConcept);
begin
  FClassification.free;
  FClassification := value;
end;

Function TFhirSubstanceReferenceInformationClassification.GetSubtypeList : TFhirCodeableConceptList;
begin
  if FSubtypeList = nil then
    FSubtypeList := TFhirCodeableConceptList.Create;
  result := FSubtypeList;
end;

Function TFhirSubstanceReferenceInformationClassification.GetHasSubtypeList : boolean;
begin
  result := (FSubtypeList <> nil) and (FSubtypeList.count > 0);
end;

Function TFhirSubstanceReferenceInformationClassification.GetSourceList : TFhirReferenceList{TFhirDocumentReference};
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList{TFhirDocumentReference}.Create;
  result := FSourceList;
end;

Function TFhirSubstanceReferenceInformationClassification.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

function TFhirSubstanceReferenceInformationClassification.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDomain.sizeInBytes);
  inc(result, FClassification.sizeInBytes);
  inc(result, FsubtypeList.sizeInBytes);
  inc(result, FsourceList.sizeInBytes);
end;

{ TFhirSubstanceReferenceInformationClassificationListEnumerator }

Constructor TFhirSubstanceReferenceInformationClassificationListEnumerator.Create(list : TFhirSubstanceReferenceInformationClassificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceReferenceInformationClassificationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceReferenceInformationClassificationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceReferenceInformationClassificationListEnumerator.GetCurrent : TFhirSubstanceReferenceInformationClassification;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceReferenceInformationClassificationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceReferenceInformationClassificationList }
procedure TFhirSubstanceReferenceInformationClassificationList.AddItem(value: TFhirSubstanceReferenceInformationClassification);
begin
  assert(value.ClassName = 'TFhirSubstanceReferenceInformationClassification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceReferenceInformationClassification');
  add(value);
end;

function TFhirSubstanceReferenceInformationClassificationList.Append: TFhirSubstanceReferenceInformationClassification;
begin
  result := TFhirSubstanceReferenceInformationClassification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationClassificationList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceReferenceInformationClassificationList.GetEnumerator : TFhirSubstanceReferenceInformationClassificationListEnumerator;
begin
  result := TFhirSubstanceReferenceInformationClassificationListEnumerator.Create(self.link);
end;

function TFhirSubstanceReferenceInformationClassificationList.Clone: TFhirSubstanceReferenceInformationClassificationList;
begin
  result := TFhirSubstanceReferenceInformationClassificationList(inherited Clone);
end;

function TFhirSubstanceReferenceInformationClassificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceReferenceInformationClassificationList.GetItemN(index: Integer): TFhirSubstanceReferenceInformationClassification;
begin
  result := TFhirSubstanceReferenceInformationClassification(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationClassificationList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceReferenceInformationClassification;
end;
function TFhirSubstanceReferenceInformationClassificationList.IndexOf(value: TFhirSubstanceReferenceInformationClassification): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceReferenceInformationClassificationList.Insert(index: Integer): TFhirSubstanceReferenceInformationClassification;
begin
  result := TFhirSubstanceReferenceInformationClassification.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationClassificationList.InsertItem(index: Integer; value: TFhirSubstanceReferenceInformationClassification);
begin
  assert(value is TFhirSubstanceReferenceInformationClassification);
  Inherited Insert(index, value);
end;

function TFhirSubstanceReferenceInformationClassificationList.Item(index: Integer): TFhirSubstanceReferenceInformationClassification;
begin
  result := TFhirSubstanceReferenceInformationClassification(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationClassificationList.Link: TFhirSubstanceReferenceInformationClassificationList;
begin
  result := TFhirSubstanceReferenceInformationClassificationList(inherited Link);
end;

procedure TFhirSubstanceReferenceInformationClassificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceReferenceInformationClassificationList.SetItemByIndex(index: Integer; value: TFhirSubstanceReferenceInformationClassification);
begin
  assert(value is TFhirSubstanceReferenceInformationClassification);
  FhirSubstanceReferenceInformationClassifications[index] := value;
end;

procedure TFhirSubstanceReferenceInformationClassificationList.SetItemN(index: Integer; value: TFhirSubstanceReferenceInformationClassification);
begin
  assert(value is TFhirSubstanceReferenceInformationClassification);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceReferenceInformationTarget }

constructor TFhirSubstanceReferenceInformationTarget.Create;
begin
  inherited;
end;

destructor TFhirSubstanceReferenceInformationTarget.Destroy;
begin
  FTarget.free;
  FType_.free;
  FInteraction.free;
  FOrganism.free;
  FOrganismType.free;
  FAmount.free;
  FAmountType.free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceReferenceInformationTarget.Assign(oSource : TFslObject);
begin
  inherited;
  target := TFhirSubstanceReferenceInformationTarget(oSource).target.Clone;
  type_ := TFhirSubstanceReferenceInformationTarget(oSource).type_.Clone;
  interaction := TFhirSubstanceReferenceInformationTarget(oSource).interaction.Clone;
  organism := TFhirSubstanceReferenceInformationTarget(oSource).organism.Clone;
  organismType := TFhirSubstanceReferenceInformationTarget(oSource).organismType.Clone;
  amount := TFhirSubstanceReferenceInformationTarget(oSource).amount.Clone;
  amountType := TFhirSubstanceReferenceInformationTarget(oSource).amountType.Clone;
  if (TFhirSubstanceReferenceInformationTarget(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList{TFhirDocumentReference}.Create;
    FSourceList.Assign(TFhirSubstanceReferenceInformationTarget(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceReferenceInformationTarget.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'interaction') Then
     list.add(self.link, 'interaction', FInteraction.Link);
  if (child_name = 'organism') Then
     list.add(self.link, 'organism', FOrganism.Link);
  if (child_name = 'organismType') Then
     list.add(self.link, 'organismType', FOrganismType.Link);
  if (child_name = 'amount[x]') or (child_name = 'amount') Then
     list.add(self.link, 'amount[x]', FAmount.Link);
  if (child_name = 'amountType') Then
     list.add(self.link, 'amountType', FAmountType.Link);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceReferenceInformationTarget.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'target', 'Identifier', false, TFhirIdentifier, FTarget.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'interaction', 'CodeableConcept', false, TFhirCodeableConcept, FInteraction.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organism', 'CodeableConcept', false, TFhirCodeableConcept, FOrganism.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organismType', 'CodeableConcept', false, TFhirCodeableConcept, FOrganismType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount[x]', 'Quantity|Range|string', false, TFhirType, FAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amountType', 'CodeableConcept', false, TFhirCodeableConcept, FAmountType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference(DocumentReference)', true, TFhirReference{TFhirDocumentReference}, FSourceList.Link)){3};
end;

function TFhirSubstanceReferenceInformationTarget.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'target') then
  begin
    Target := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'interaction') then
  begin
    Interaction := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'organism') then
  begin
    Organism := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'organismType') then
  begin
    OrganismType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'String'])) then
  begin
    Amount := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'amountType') then
  begin
    AmountType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference{TFhirDocumentReference}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceReferenceInformationTarget.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference{TFhirDocumentReference}){2a}
  else inherited;
end;

function TFhirSubstanceReferenceInformationTarget.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'target') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'interaction') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'organism') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'organismType') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'String'])) then raise EFHIRException.create('Cannot make property Amount'){4x}
  else if (propName = 'amountType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'source') then result := SourceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceReferenceInformationTarget.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'target') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'interaction') then result := 'CodeableConcept'
  else if (propName = 'organism') then result := 'CodeableConcept'
  else if (propName = 'organismType') then result := 'CodeableConcept'
  else if (propName = 'amount[x]') then result := 'Quantity|Range|string'
  else if (propName = 'amountType') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceReferenceInformationTarget.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'target') then TargetElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'interaction') then InteractionElement := nil
  else if (propName = 'organism') then OrganismElement := nil
  else if (propName = 'organismType') then OrganismTypeElement := nil
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'String'])) then AmountElement := nil{4x}
  else if (propName = 'amountType') then AmountTypeElement := nil
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceReferenceInformationTarget.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'target') then TargetElement := new as TFhirIdentifier{4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'interaction') then InteractionElement := new as TFhirCodeableConcept{4}
  else if (propName = 'organism') then OrganismElement := new as TFhirCodeableConcept{4}
  else if (propName = 'organismType') then OrganismTypeElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'String'])) then AmountElement := new as TFhirType{4x}
  else if (propName = 'amountType') then AmountTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceReferenceInformationTarget.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'source') then SourceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceReferenceInformationTarget.fhirType : string;
begin
  result := 'target';
end;

function TFhirSubstanceReferenceInformationTarget.Link : TFhirSubstanceReferenceInformationTarget;
begin
  result := TFhirSubstanceReferenceInformationTarget(inherited Link);
end;

function TFhirSubstanceReferenceInformationTarget.Clone : TFhirSubstanceReferenceInformationTarget;
begin
  result := TFhirSubstanceReferenceInformationTarget(inherited Clone);
end;

function TFhirSubstanceReferenceInformationTarget.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceReferenceInformationTarget;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceReferenceInformationTarget)) then
    result := false
  else
  begin
    o := TFhirSubstanceReferenceInformationTarget(other);
    result := compareDeep(targetElement, o.targetElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(interactionElement, o.interactionElement, true) and compareDeep(organismElement, o.organismElement, true) and 
      compareDeep(organismTypeElement, o.organismTypeElement, true) and compareDeep(amountElement, o.amountElement, true) and 
      compareDeep(amountTypeElement, o.amountTypeElement, true) and compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceReferenceInformationTarget.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTarget) and isEmptyProp(FType_) and isEmptyProp(FInteraction) and isEmptyProp(FOrganism) and isEmptyProp(FOrganismType) and isEmptyProp(FAmount) and isEmptyProp(FAmountType) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceReferenceInformationTarget.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('target');
  fields.add('type');
  fields.add('interaction');
  fields.add('organism');
  fields.add('organismType');
  fields.add('amount[x]');
  fields.add('amountType');
  fields.add('source');
end;

{ TFhirSubstanceReferenceInformationTarget }

Procedure TFhirSubstanceReferenceInformationTarget.SetTarget(value : TFhirIdentifier);
begin
  FTarget.free;
  FTarget := value;
end;

Procedure TFhirSubstanceReferenceInformationTarget.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSubstanceReferenceInformationTarget.SetInteraction(value : TFhirCodeableConcept);
begin
  FInteraction.free;
  FInteraction := value;
end;

Procedure TFhirSubstanceReferenceInformationTarget.SetOrganism(value : TFhirCodeableConcept);
begin
  FOrganism.free;
  FOrganism := value;
end;

Procedure TFhirSubstanceReferenceInformationTarget.SetOrganismType(value : TFhirCodeableConcept);
begin
  FOrganismType.free;
  FOrganismType := value;
end;

Procedure TFhirSubstanceReferenceInformationTarget.SetAmount(value : TFhirType);
begin
  FAmount.free;
  FAmount := value;
end;

Procedure TFhirSubstanceReferenceInformationTarget.SetAmountType(value : TFhirCodeableConcept);
begin
  FAmountType.free;
  FAmountType := value;
end;

Function TFhirSubstanceReferenceInformationTarget.GetSourceList : TFhirReferenceList{TFhirDocumentReference};
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList{TFhirDocumentReference}.Create;
  result := FSourceList;
end;

Function TFhirSubstanceReferenceInformationTarget.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

function TFhirSubstanceReferenceInformationTarget.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FTarget.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FInteraction.sizeInBytes);
  inc(result, FOrganism.sizeInBytes);
  inc(result, FOrganismType.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FAmountType.sizeInBytes);
  inc(result, FsourceList.sizeInBytes);
end;

{ TFhirSubstanceReferenceInformationTargetListEnumerator }

Constructor TFhirSubstanceReferenceInformationTargetListEnumerator.Create(list : TFhirSubstanceReferenceInformationTargetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceReferenceInformationTargetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceReferenceInformationTargetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceReferenceInformationTargetListEnumerator.GetCurrent : TFhirSubstanceReferenceInformationTarget;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceReferenceInformationTargetListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceReferenceInformationTargetList }
procedure TFhirSubstanceReferenceInformationTargetList.AddItem(value: TFhirSubstanceReferenceInformationTarget);
begin
  assert(value.ClassName = 'TFhirSubstanceReferenceInformationTarget', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceReferenceInformationTarget');
  add(value);
end;

function TFhirSubstanceReferenceInformationTargetList.Append: TFhirSubstanceReferenceInformationTarget;
begin
  result := TFhirSubstanceReferenceInformationTarget.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationTargetList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceReferenceInformationTargetList.GetEnumerator : TFhirSubstanceReferenceInformationTargetListEnumerator;
begin
  result := TFhirSubstanceReferenceInformationTargetListEnumerator.Create(self.link);
end;

function TFhirSubstanceReferenceInformationTargetList.Clone: TFhirSubstanceReferenceInformationTargetList;
begin
  result := TFhirSubstanceReferenceInformationTargetList(inherited Clone);
end;

function TFhirSubstanceReferenceInformationTargetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceReferenceInformationTargetList.GetItemN(index: Integer): TFhirSubstanceReferenceInformationTarget;
begin
  result := TFhirSubstanceReferenceInformationTarget(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationTargetList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceReferenceInformationTarget;
end;
function TFhirSubstanceReferenceInformationTargetList.IndexOf(value: TFhirSubstanceReferenceInformationTarget): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceReferenceInformationTargetList.Insert(index: Integer): TFhirSubstanceReferenceInformationTarget;
begin
  result := TFhirSubstanceReferenceInformationTarget.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationTargetList.InsertItem(index: Integer; value: TFhirSubstanceReferenceInformationTarget);
begin
  assert(value is TFhirSubstanceReferenceInformationTarget);
  Inherited Insert(index, value);
end;

function TFhirSubstanceReferenceInformationTargetList.Item(index: Integer): TFhirSubstanceReferenceInformationTarget;
begin
  result := TFhirSubstanceReferenceInformationTarget(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationTargetList.Link: TFhirSubstanceReferenceInformationTargetList;
begin
  result := TFhirSubstanceReferenceInformationTargetList(inherited Link);
end;

procedure TFhirSubstanceReferenceInformationTargetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceReferenceInformationTargetList.SetItemByIndex(index: Integer; value: TFhirSubstanceReferenceInformationTarget);
begin
  assert(value is TFhirSubstanceReferenceInformationTarget);
  FhirSubstanceReferenceInformationTargets[index] := value;
end;

procedure TFhirSubstanceReferenceInformationTargetList.SetItemN(index: Integer; value: TFhirSubstanceReferenceInformationTarget);
begin
  assert(value is TFhirSubstanceReferenceInformationTarget);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceReferenceInformation }

constructor TFhirSubstanceReferenceInformation.Create;
begin
  inherited;
end;

destructor TFhirSubstanceReferenceInformation.Destroy;
begin
  FComment.free;
  FGeneList.Free;
  FGeneElementList.Free;
  FClassificationList.Free;
  FTargetList.Free;
  inherited;
end;

function TFhirSubstanceReferenceInformation.GetResourceType : TFhirResourceType;
begin
  result := frtSubstanceReferenceInformation;
end;

procedure TFhirSubstanceReferenceInformation.Assign(oSource : TFslObject);
begin
  inherited;
  commentElement := TFhirSubstanceReferenceInformation(oSource).commentElement.Clone;
  if (TFhirSubstanceReferenceInformation(oSource).FGeneList = nil) then
  begin
    FGeneList.free;
    FGeneList := nil;
  end
  else
  begin
    if FGeneList = nil then
      FGeneList := TFhirSubstanceReferenceInformationGeneList.Create;
    FGeneList.Assign(TFhirSubstanceReferenceInformation(oSource).FGeneList);
  end;
  if (TFhirSubstanceReferenceInformation(oSource).FGeneElementList = nil) then
  begin
    FGeneElementList.free;
    FGeneElementList := nil;
  end
  else
  begin
    if FGeneElementList = nil then
      FGeneElementList := TFhirSubstanceReferenceInformationGeneElementList.Create;
    FGeneElementList.Assign(TFhirSubstanceReferenceInformation(oSource).FGeneElementList);
  end;
  if (TFhirSubstanceReferenceInformation(oSource).FClassificationList = nil) then
  begin
    FClassificationList.free;
    FClassificationList := nil;
  end
  else
  begin
    if FClassificationList = nil then
      FClassificationList := TFhirSubstanceReferenceInformationClassificationList.Create;
    FClassificationList.Assign(TFhirSubstanceReferenceInformation(oSource).FClassificationList);
  end;
  if (TFhirSubstanceReferenceInformation(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirSubstanceReferenceInformationTargetList.Create;
    FTargetList.Assign(TFhirSubstanceReferenceInformation(oSource).FTargetList);
  end;
end;

procedure TFhirSubstanceReferenceInformation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'gene') Then
    list.addAll(self, 'gene', FGeneList);
  if (child_name = 'geneElement') Then
    list.addAll(self, 'geneElement', FGeneElementList);
  if (child_name = 'classification') Then
    list.addAll(self, 'classification', FClassificationList);
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
end;

procedure TFhirSubstanceReferenceInformation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'gene', '', true, TFhirSubstanceReferenceInformationGene, FGeneList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'geneElement', '', true, TFhirSubstanceReferenceInformationGeneElement, FGeneElementList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'classification', '', true, TFhirSubstanceReferenceInformationClassification, FClassificationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'target', '', true, TFhirSubstanceReferenceInformationTarget, FTargetList.Link)){3};
end;

function TFhirSubstanceReferenceInformation.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'gene') then
  begin
    GeneList.add(propValue as TFhirSubstanceReferenceInformationGene){2a};
    result := propValue;
  end
  else if (propName = 'geneElement') then
  begin
    GeneElementList.add(propValue as TFhirSubstanceReferenceInformationGeneElement){2a};
    result := propValue;
  end
  else if (propName = 'classification') then
  begin
    ClassificationList.add(propValue as TFhirSubstanceReferenceInformationClassification){2a};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirSubstanceReferenceInformationTarget){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSubstanceReferenceInformation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'gene') then GeneList.insertItem(index, propValue as TFhirSubstanceReferenceInformationGene){2a}
  else if (propName = 'geneElement') then GeneElementList.insertItem(index, propValue as TFhirSubstanceReferenceInformationGeneElement){2a}
  else if (propName = 'classification') then ClassificationList.insertItem(index, propValue as TFhirSubstanceReferenceInformationClassification){2a}
  else if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirSubstanceReferenceInformationTarget){2a}
  else inherited;
end;

function TFhirSubstanceReferenceInformation.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'comment') then result := TFhirString.create() {5b}
  else if (propName = 'gene') then result := GeneList.new(){2}
  else if (propName = 'geneElement') then result := GeneElementList.new(){2}
  else if (propName = 'classification') then result := ClassificationList.new(){2}
  else if (propName = 'target') then result := TargetList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceReferenceInformation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'comment') then result := 'string'
  else if (propName = 'gene') then result := ''
  else if (propName = 'geneElement') then result := ''
  else if (propName = 'classification') then result := ''
  else if (propName = 'target') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceReferenceInformation.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'comment') then CommentElement := nil
  else if (propName = 'gene') then deletePropertyValue('gene', GeneList, value) {2}
  else if (propName = 'geneElement') then deletePropertyValue('geneElement', GeneElementList, value) {2}
  else if (propName = 'classification') then deletePropertyValue('classification', ClassificationList, value) {2}
  else if (propName = 'target') then deletePropertyValue('target', TargetList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceReferenceInformation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'comment') then CommentElement := asString(new){5b}
  else if (propName = 'gene') then replacePropertyValue('gene', GeneList, existing, new) {2}
  else if (propName = 'geneElement') then replacePropertyValue('geneElement', GeneElementList, existing, new) {2}
  else if (propName = 'classification') then replacePropertyValue('classification', ClassificationList, existing, new) {2}
  else if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceReferenceInformation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'gene') then GeneList.move(source, destination){2a}
  else if (propName = 'geneElement') then GeneElementList.move(source, destination){2a}
  else if (propName = 'classification') then ClassificationList.move(source, destination){2a}
  else if (propName = 'target') then TargetList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceReferenceInformation.fhirType : string;
begin
  result := 'SubstanceReferenceInformation';
end;

function TFhirSubstanceReferenceInformation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FComment) and isEmptyProp(FgeneList) and isEmptyProp(FgeneElementList) and isEmptyProp(FclassificationList) and isEmptyProp(FtargetList);
end;

function TFhirSubstanceReferenceInformation.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceReferenceInformation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceReferenceInformation)) then
    result := false
  else
  begin
    o := TFhirSubstanceReferenceInformation(other);
    result := compareDeep(commentElement, o.commentElement, true) and compareDeep(geneList, o.geneList, true) and 
      compareDeep(geneElementList, o.geneElementList, true) and compareDeep(classificationList, o.classificationList, true) and 
      compareDeep(targetList, o.targetList, true);
  end;
end;

function TFhirSubstanceReferenceInformation.Link : TFhirSubstanceReferenceInformation;
begin
  result := TFhirSubstanceReferenceInformation(inherited Link);
end;

function TFhirSubstanceReferenceInformation.Clone : TFhirSubstanceReferenceInformation;
begin
  result := TFhirSubstanceReferenceInformation(inherited Clone);
end;

procedure TFhirSubstanceReferenceInformation.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('comment');
  fields.add('gene');
  fields.add('geneElement');
  fields.add('classification');
  fields.add('target');
end;

{ TFhirSubstanceReferenceInformation }

Procedure TFhirSubstanceReferenceInformation.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirSubstanceReferenceInformation.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirSubstanceReferenceInformation.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

Function TFhirSubstanceReferenceInformation.GetGeneList : TFhirSubstanceReferenceInformationGeneList;
begin
  if FGeneList = nil then
    FGeneList := TFhirSubstanceReferenceInformationGeneList.Create;
  result := FGeneList;
end;

Function TFhirSubstanceReferenceInformation.GetHasGeneList : boolean;
begin
  result := (FGeneList <> nil) and (FGeneList.count > 0);
end;

Function TFhirSubstanceReferenceInformation.GetGeneElementList : TFhirSubstanceReferenceInformationGeneElementList;
begin
  if FGeneElementList = nil then
    FGeneElementList := TFhirSubstanceReferenceInformationGeneElementList.Create;
  result := FGeneElementList;
end;

Function TFhirSubstanceReferenceInformation.GetHasGeneElementList : boolean;
begin
  result := (FGeneElementList <> nil) and (FGeneElementList.count > 0);
end;

Function TFhirSubstanceReferenceInformation.GetClassificationList : TFhirSubstanceReferenceInformationClassificationList;
begin
  if FClassificationList = nil then
    FClassificationList := TFhirSubstanceReferenceInformationClassificationList.Create;
  result := FClassificationList;
end;

Function TFhirSubstanceReferenceInformation.GetHasClassificationList : boolean;
begin
  result := (FClassificationList <> nil) and (FClassificationList.count > 0);
end;

Function TFhirSubstanceReferenceInformation.GetTargetList : TFhirSubstanceReferenceInformationTargetList;
begin
  if FTargetList = nil then
    FTargetList := TFhirSubstanceReferenceInformationTargetList.Create;
  result := FTargetList;
end;

Function TFhirSubstanceReferenceInformation.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

function TFhirSubstanceReferenceInformation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FComment.sizeInBytes);
  inc(result, FgeneList.sizeInBytes);
  inc(result, FgeneElementList.sizeInBytes);
  inc(result, FclassificationList.sizeInBytes);
  inc(result, FtargetList.sizeInBytes);
end;

{ TFhirSubstanceReferenceInformationListEnumerator }

Constructor TFhirSubstanceReferenceInformationListEnumerator.Create(list : TFhirSubstanceReferenceInformationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceReferenceInformationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceReferenceInformationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceReferenceInformationListEnumerator.GetCurrent : TFhirSubstanceReferenceInformation;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceReferenceInformationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceReferenceInformationList }
procedure TFhirSubstanceReferenceInformationList.AddItem(value: TFhirSubstanceReferenceInformation);
begin
  assert(value.ClassName = 'TFhirSubstanceReferenceInformation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceReferenceInformation');
  add(value);
end;

function TFhirSubstanceReferenceInformationList.Append: TFhirSubstanceReferenceInformation;
begin
  result := TFhirSubstanceReferenceInformation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceReferenceInformationList.GetEnumerator : TFhirSubstanceReferenceInformationListEnumerator;
begin
  result := TFhirSubstanceReferenceInformationListEnumerator.Create(self.link);
end;

function TFhirSubstanceReferenceInformationList.Clone: TFhirSubstanceReferenceInformationList;
begin
  result := TFhirSubstanceReferenceInformationList(inherited Clone);
end;

function TFhirSubstanceReferenceInformationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceReferenceInformationList.GetItemN(index: Integer): TFhirSubstanceReferenceInformation;
begin
  result := TFhirSubstanceReferenceInformation(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceReferenceInformation;
end;
function TFhirSubstanceReferenceInformationList.IndexOf(value: TFhirSubstanceReferenceInformation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceReferenceInformationList.Insert(index: Integer): TFhirSubstanceReferenceInformation;
begin
  result := TFhirSubstanceReferenceInformation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceReferenceInformationList.InsertItem(index: Integer; value: TFhirSubstanceReferenceInformation);
begin
  assert(value is TFhirSubstanceReferenceInformation);
  Inherited Insert(index, value);
end;

function TFhirSubstanceReferenceInformationList.Item(index: Integer): TFhirSubstanceReferenceInformation;
begin
  result := TFhirSubstanceReferenceInformation(ObjectByIndex[index]);
end;

function TFhirSubstanceReferenceInformationList.Link: TFhirSubstanceReferenceInformationList;
begin
  result := TFhirSubstanceReferenceInformationList(inherited Link);
end;

procedure TFhirSubstanceReferenceInformationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceReferenceInformationList.SetItemByIndex(index: Integer; value: TFhirSubstanceReferenceInformation);
begin
  assert(value is TFhirSubstanceReferenceInformation);
  FhirSubstanceReferenceInformations[index] := value;
end;

procedure TFhirSubstanceReferenceInformationList.SetItemN(index: Integer; value: TFhirSubstanceReferenceInformation);
begin
  assert(value is TFhirSubstanceReferenceInformation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCEREFERENCEINFORMATION}

{$IFDEF FHIR_SUBSTANCESOURCEMATERIAL}

{ TFhirSubstanceSourceMaterialFractionDescription }

constructor TFhirSubstanceSourceMaterialFractionDescription.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterialFractionDescription.Destroy;
begin
  FFraction.free;
  FMaterialType.free;
  inherited;
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.Assign(oSource : TFslObject);
begin
  inherited;
  fractionElement := TFhirSubstanceSourceMaterialFractionDescription(oSource).fractionElement.Clone;
  materialType := TFhirSubstanceSourceMaterialFractionDescription(oSource).materialType.Clone;
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'fraction') Then
     list.add(self.link, 'fraction', FFraction.Link);
  if (child_name = 'materialType') Then
     list.add(self.link, 'materialType', FMaterialType.Link);
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'fraction', 'string', false, TFhirString, FFraction.Link));{2}
  oList.add(TFHIRProperty.create(self, 'materialType', 'CodeableConcept', false, TFhirCodeableConcept, FMaterialType.Link));{2}
end;

function TFhirSubstanceSourceMaterialFractionDescription.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'fraction') then
  begin
    FractionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'materialType') then
  begin
    MaterialType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSourceMaterialFractionDescription.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'fraction') then result := TFhirString.create() {5b}
  else if (propName = 'materialType') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterialFractionDescription.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'fraction') then result := 'string'
  else if (propName = 'materialType') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'fraction') then FractionElement := nil
  else if (propName = 'materialType') then MaterialTypeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'fraction') then FractionElement := asString(new){5b}
  else if (propName = 'materialType') then MaterialTypeElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterialFractionDescription.fhirType : string;
begin
  result := 'fractionDescription';
end;

function TFhirSubstanceSourceMaterialFractionDescription.Link : TFhirSubstanceSourceMaterialFractionDescription;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription(inherited Link);
end;

function TFhirSubstanceSourceMaterialFractionDescription.Clone : TFhirSubstanceSourceMaterialFractionDescription;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription(inherited Clone);
end;

function TFhirSubstanceSourceMaterialFractionDescription.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterialFractionDescription;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterialFractionDescription)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterialFractionDescription(other);
    result := compareDeep(fractionElement, o.fractionElement, true) and compareDeep(materialTypeElement, o.materialTypeElement, true);
  end;
end;

function TFhirSubstanceSourceMaterialFractionDescription.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFraction) and isEmptyProp(FMaterialType);
end;

procedure TFhirSubstanceSourceMaterialFractionDescription.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('fraction');
  fields.add('materialType');
end;

{ TFhirSubstanceSourceMaterialFractionDescription }

Procedure TFhirSubstanceSourceMaterialFractionDescription.SetFraction(value : TFhirString);
begin
  FFraction.free;
  FFraction := value;
end;

Function TFhirSubstanceSourceMaterialFractionDescription.GetFractionST : String;
begin
  if FFraction = nil then
    result := ''
  else
    result := FFraction.value;
end;

Procedure TFhirSubstanceSourceMaterialFractionDescription.SetFractionST(value : String);
begin
  if value <> '' then
  begin
    if FFraction = nil then
      FFraction := TFhirString.create;
    FFraction.value := value
  end
  else if FFraction <> nil then
    FFraction.value := '';
end;

Procedure TFhirSubstanceSourceMaterialFractionDescription.SetMaterialType(value : TFhirCodeableConcept);
begin
  FMaterialType.free;
  FMaterialType := value;
end;

function TFhirSubstanceSourceMaterialFractionDescription.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FFraction.sizeInBytes);
  inc(result, FMaterialType.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator }

Constructor TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator.Create(list : TFhirSubstanceSourceMaterialFractionDescriptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator.GetCurrent : TFhirSubstanceSourceMaterialFractionDescription;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialFractionDescriptionList }
procedure TFhirSubstanceSourceMaterialFractionDescriptionList.AddItem(value: TFhirSubstanceSourceMaterialFractionDescription);
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterialFractionDescription', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterialFractionDescription');
  add(value);
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.Append: TFhirSubstanceSourceMaterialFractionDescription;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialFractionDescriptionList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.GetEnumerator : TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialFractionDescriptionListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.Clone: TFhirSubstanceSourceMaterialFractionDescriptionList;
begin
  result := TFhirSubstanceSourceMaterialFractionDescriptionList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.GetItemN(index: Integer): TFhirSubstanceSourceMaterialFractionDescription;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription;
end;
function TFhirSubstanceSourceMaterialFractionDescriptionList.IndexOf(value: TFhirSubstanceSourceMaterialFractionDescription): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.Insert(index: Integer): TFhirSubstanceSourceMaterialFractionDescription;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialFractionDescriptionList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterialFractionDescription);
begin
  assert(value is TFhirSubstanceSourceMaterialFractionDescription);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.Item(index: Integer): TFhirSubstanceSourceMaterialFractionDescription;
begin
  result := TFhirSubstanceSourceMaterialFractionDescription(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialFractionDescriptionList.Link: TFhirSubstanceSourceMaterialFractionDescriptionList;
begin
  result := TFhirSubstanceSourceMaterialFractionDescriptionList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialFractionDescriptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialFractionDescriptionList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterialFractionDescription);
begin
  assert(value is TFhirSubstanceSourceMaterialFractionDescription);
  FhirSubstanceSourceMaterialFractionDescriptions[index] := value;
end;

procedure TFhirSubstanceSourceMaterialFractionDescriptionList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterialFractionDescription);
begin
  assert(value is TFhirSubstanceSourceMaterialFractionDescription);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSourceMaterialOrganism }

constructor TFhirSubstanceSourceMaterialOrganism.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterialOrganism.Destroy;
begin
  FFamily.free;
  FGenus.free;
  FSpecies.free;
  FIntraspecificType.free;
  FIntraspecificDescription.free;
  FAuthorList.Free;
  FHybrid.free;
  FOrganismGeneral.free;
  inherited;
end;

procedure TFhirSubstanceSourceMaterialOrganism.Assign(oSource : TFslObject);
begin
  inherited;
  family := TFhirSubstanceSourceMaterialOrganism(oSource).family.Clone;
  genus := TFhirSubstanceSourceMaterialOrganism(oSource).genus.Clone;
  species := TFhirSubstanceSourceMaterialOrganism(oSource).species.Clone;
  intraspecificType := TFhirSubstanceSourceMaterialOrganism(oSource).intraspecificType.Clone;
  intraspecificDescriptionElement := TFhirSubstanceSourceMaterialOrganism(oSource).intraspecificDescriptionElement.Clone;
  if (TFhirSubstanceSourceMaterialOrganism(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirSubstanceSourceMaterialOrganismAuthorList.Create;
    FAuthorList.Assign(TFhirSubstanceSourceMaterialOrganism(oSource).FAuthorList);
  end;
  hybrid := TFhirSubstanceSourceMaterialOrganism(oSource).hybrid.Clone;
  organismGeneral := TFhirSubstanceSourceMaterialOrganism(oSource).organismGeneral.Clone;
end;

procedure TFhirSubstanceSourceMaterialOrganism.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'family') Then
     list.add(self.link, 'family', FFamily.Link);
  if (child_name = 'genus') Then
     list.add(self.link, 'genus', FGenus.Link);
  if (child_name = 'species') Then
     list.add(self.link, 'species', FSpecies.Link);
  if (child_name = 'intraspecificType') Then
     list.add(self.link, 'intraspecificType', FIntraspecificType.Link);
  if (child_name = 'intraspecificDescription') Then
     list.add(self.link, 'intraspecificDescription', FIntraspecificDescription.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'hybrid') Then
     list.add(self.link, 'hybrid', FHybrid.Link);
  if (child_name = 'organismGeneral') Then
     list.add(self.link, 'organismGeneral', FOrganismGeneral.Link);
end;

procedure TFhirSubstanceSourceMaterialOrganism.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'family', 'CodeableConcept', false, TFhirCodeableConcept, FFamily.Link));{2}
  oList.add(TFHIRProperty.create(self, 'genus', 'CodeableConcept', false, TFhirCodeableConcept, FGenus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'species', 'CodeableConcept', false, TFhirCodeableConcept, FSpecies.Link));{2}
  oList.add(TFHIRProperty.create(self, 'intraspecificType', 'CodeableConcept', false, TFhirCodeableConcept, FIntraspecificType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'intraspecificDescription', 'string', false, TFhirString, FIntraspecificDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', '', true, TFhirSubstanceSourceMaterialOrganismAuthor, FAuthorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'hybrid', '', false, TFhirSubstanceSourceMaterialOrganismHybrid, FHybrid.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organismGeneral', '', false, TFhirSubstanceSourceMaterialOrganismOrganismGeneral, FOrganismGeneral.Link));{2}
end;

function TFhirSubstanceSourceMaterialOrganism.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'family') then
  begin
    Family := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'genus') then
  begin
    Genus := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'species') then
  begin
    Species := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'intraspecificType') then
  begin
    IntraspecificType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'intraspecificDescription') then
  begin
    IntraspecificDescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirSubstanceSourceMaterialOrganismAuthor){2a};
    result := propValue;
  end
  else if (propName = 'hybrid') then
  begin
    Hybrid := propValue as TFhirSubstanceSourceMaterialOrganismHybrid{4b};
    result := propValue;
  end
  else if (propName = 'organismGeneral') then
  begin
    OrganismGeneral := propValue as TFhirSubstanceSourceMaterialOrganismOrganismGeneral{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSourceMaterialOrganism.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirSubstanceSourceMaterialOrganismAuthor){2a}
  else inherited;
end;

function TFhirSubstanceSourceMaterialOrganism.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'family') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'genus') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'species') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'intraspecificType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'intraspecificDescription') then result := TFhirString.create() {5b}
  else if (propName = 'author') then result := AuthorList.new(){2}
  else if (propName = 'hybrid') then result := TFhirSubstanceSourceMaterialOrganismHybrid.create(){4b}
  else if (propName = 'organismGeneral') then result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterialOrganism.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'family') then result := 'CodeableConcept'
  else if (propName = 'genus') then result := 'CodeableConcept'
  else if (propName = 'species') then result := 'CodeableConcept'
  else if (propName = 'intraspecificType') then result := 'CodeableConcept'
  else if (propName = 'intraspecificDescription') then result := 'string'
  else if (propName = 'author') then result := ''
  else if (propName = 'hybrid') then result := ''
  else if (propName = 'organismGeneral') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterialOrganism.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'family') then FamilyElement := nil
  else if (propName = 'genus') then GenusElement := nil
  else if (propName = 'species') then SpeciesElement := nil
  else if (propName = 'intraspecificType') then IntraspecificTypeElement := nil
  else if (propName = 'intraspecificDescription') then IntraspecificDescriptionElement := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value) {2}
  else if (propName = 'hybrid') then HybridElement := nil
  else if (propName = 'organismGeneral') then OrganismGeneralElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterialOrganism.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'family') then FamilyElement := new as TFhirCodeableConcept{4}
  else if (propName = 'genus') then GenusElement := new as TFhirCodeableConcept{4}
  else if (propName = 'species') then SpeciesElement := new as TFhirCodeableConcept{4}
  else if (propName = 'intraspecificType') then IntraspecificTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'intraspecificDescription') then IntraspecificDescriptionElement := asString(new){5b}
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new) {2}
  else if (propName = 'hybrid') then HybridElement := new as TFhirSubstanceSourceMaterialOrganismHybrid{4}
  else if (propName = 'organismGeneral') then OrganismGeneralElement := new as TFhirSubstanceSourceMaterialOrganismOrganismGeneral{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterialOrganism.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'author') then AuthorList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterialOrganism.fhirType : string;
begin
  result := 'organism';
end;

function TFhirSubstanceSourceMaterialOrganism.Link : TFhirSubstanceSourceMaterialOrganism;
begin
  result := TFhirSubstanceSourceMaterialOrganism(inherited Link);
end;

function TFhirSubstanceSourceMaterialOrganism.Clone : TFhirSubstanceSourceMaterialOrganism;
begin
  result := TFhirSubstanceSourceMaterialOrganism(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganism.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterialOrganism;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterialOrganism)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterialOrganism(other);
    result := compareDeep(familyElement, o.familyElement, true) and compareDeep(genusElement, o.genusElement, true) and 
      compareDeep(speciesElement, o.speciesElement, true) and compareDeep(intraspecificTypeElement, o.intraspecificTypeElement, true) and 
      compareDeep(intraspecificDescriptionElement, o.intraspecificDescriptionElement, true) and 
      compareDeep(authorList, o.authorList, true) and compareDeep(hybridElement, o.hybridElement, true) and 
      compareDeep(organismGeneralElement, o.organismGeneralElement, true);
  end;
end;

function TFhirSubstanceSourceMaterialOrganism.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFamily) and isEmptyProp(FGenus) and isEmptyProp(FSpecies) and isEmptyProp(FIntraspecificType) and isEmptyProp(FIntraspecificDescription) and isEmptyProp(FauthorList) and isEmptyProp(FHybrid) and isEmptyProp(FOrganismGeneral);
end;

procedure TFhirSubstanceSourceMaterialOrganism.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('family');
  fields.add('genus');
  fields.add('species');
  fields.add('intraspecificType');
  fields.add('intraspecificDescription');
  fields.add('author');
  fields.add('hybrid');
  fields.add('organismGeneral');
end;

{ TFhirSubstanceSourceMaterialOrganism }

Procedure TFhirSubstanceSourceMaterialOrganism.SetFamily(value : TFhirCodeableConcept);
begin
  FFamily.free;
  FFamily := value;
end;

Procedure TFhirSubstanceSourceMaterialOrganism.SetGenus(value : TFhirCodeableConcept);
begin
  FGenus.free;
  FGenus := value;
end;

Procedure TFhirSubstanceSourceMaterialOrganism.SetSpecies(value : TFhirCodeableConcept);
begin
  FSpecies.free;
  FSpecies := value;
end;

Procedure TFhirSubstanceSourceMaterialOrganism.SetIntraspecificType(value : TFhirCodeableConcept);
begin
  FIntraspecificType.free;
  FIntraspecificType := value;
end;

Procedure TFhirSubstanceSourceMaterialOrganism.SetIntraspecificDescription(value : TFhirString);
begin
  FIntraspecificDescription.free;
  FIntraspecificDescription := value;
end;

Function TFhirSubstanceSourceMaterialOrganism.GetIntraspecificDescriptionST : String;
begin
  if FIntraspecificDescription = nil then
    result := ''
  else
    result := FIntraspecificDescription.value;
end;

Procedure TFhirSubstanceSourceMaterialOrganism.SetIntraspecificDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FIntraspecificDescription = nil then
      FIntraspecificDescription := TFhirString.create;
    FIntraspecificDescription.value := value
  end
  else if FIntraspecificDescription <> nil then
    FIntraspecificDescription.value := '';
end;

Function TFhirSubstanceSourceMaterialOrganism.GetAuthorList : TFhirSubstanceSourceMaterialOrganismAuthorList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirSubstanceSourceMaterialOrganismAuthorList.Create;
  result := FAuthorList;
end;

Function TFhirSubstanceSourceMaterialOrganism.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

Procedure TFhirSubstanceSourceMaterialOrganism.SetHybrid(value : TFhirSubstanceSourceMaterialOrganismHybrid);
begin
  FHybrid.free;
  FHybrid := value;
end;

Procedure TFhirSubstanceSourceMaterialOrganism.SetOrganismGeneral(value : TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
begin
  FOrganismGeneral.free;
  FOrganismGeneral := value;
end;

function TFhirSubstanceSourceMaterialOrganism.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FFamily.sizeInBytes);
  inc(result, FGenus.sizeInBytes);
  inc(result, FSpecies.sizeInBytes);
  inc(result, FIntraspecificType.sizeInBytes);
  inc(result, FIntraspecificDescription.sizeInBytes);
  inc(result, FauthorList.sizeInBytes);
  inc(result, FHybrid.sizeInBytes);
  inc(result, FOrganismGeneral.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialOrganismListEnumerator }

Constructor TFhirSubstanceSourceMaterialOrganismListEnumerator.Create(list : TFhirSubstanceSourceMaterialOrganismList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialOrganismListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialOrganismListEnumerator.GetCurrent : TFhirSubstanceSourceMaterialOrganism;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialOrganismListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialOrganismList }
procedure TFhirSubstanceSourceMaterialOrganismList.AddItem(value: TFhirSubstanceSourceMaterialOrganism);
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterialOrganism', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterialOrganism');
  add(value);
end;

function TFhirSubstanceSourceMaterialOrganismList.Append: TFhirSubstanceSourceMaterialOrganism;
begin
  result := TFhirSubstanceSourceMaterialOrganism.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialOrganismList.GetEnumerator : TFhirSubstanceSourceMaterialOrganismListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialOrganismListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialOrganismList.Clone: TFhirSubstanceSourceMaterialOrganismList;
begin
  result := TFhirSubstanceSourceMaterialOrganismList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialOrganismList.GetItemN(index: Integer): TFhirSubstanceSourceMaterialOrganism;
begin
  result := TFhirSubstanceSourceMaterialOrganism(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterialOrganism;
end;
function TFhirSubstanceSourceMaterialOrganismList.IndexOf(value: TFhirSubstanceSourceMaterialOrganism): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialOrganismList.Insert(index: Integer): TFhirSubstanceSourceMaterialOrganism;
begin
  result := TFhirSubstanceSourceMaterialOrganism.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterialOrganism);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganism);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialOrganismList.Item(index: Integer): TFhirSubstanceSourceMaterialOrganism;
begin
  result := TFhirSubstanceSourceMaterialOrganism(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismList.Link: TFhirSubstanceSourceMaterialOrganismList;
begin
  result := TFhirSubstanceSourceMaterialOrganismList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialOrganismList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterialOrganism);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganism);
  FhirSubstanceSourceMaterialOrganisms[index] := value;
end;

procedure TFhirSubstanceSourceMaterialOrganismList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterialOrganism);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganism);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSourceMaterialOrganismAuthor }

constructor TFhirSubstanceSourceMaterialOrganismAuthor.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterialOrganismAuthor.Destroy;
begin
  FAuthorType.free;
  FAuthorDescription.free;
  inherited;
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.Assign(oSource : TFslObject);
begin
  inherited;
  authorType := TFhirSubstanceSourceMaterialOrganismAuthor(oSource).authorType.Clone;
  authorDescriptionElement := TFhirSubstanceSourceMaterialOrganismAuthor(oSource).authorDescriptionElement.Clone;
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'authorType') Then
     list.add(self.link, 'authorType', FAuthorType.Link);
  if (child_name = 'authorDescription') Then
     list.add(self.link, 'authorDescription', FAuthorDescription.Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'authorType', 'CodeableConcept', false, TFhirCodeableConcept, FAuthorType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authorDescription', 'string', false, TFhirString, FAuthorDescription.Link));{2}
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'authorType') then
  begin
    AuthorType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'authorDescription') then
  begin
    AuthorDescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'authorType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'authorDescription') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'authorType') then result := 'CodeableConcept'
  else if (propName = 'authorDescription') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'authorType') then AuthorTypeElement := nil
  else if (propName = 'authorDescription') then AuthorDescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'authorType') then AuthorTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'authorDescription') then AuthorDescriptionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.fhirType : string;
begin
  result := 'author';
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.Link : TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor(inherited Link);
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.Clone : TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterialOrganismAuthor)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterialOrganismAuthor(other);
    result := compareDeep(authorTypeElement, o.authorTypeElement, true) and compareDeep(authorDescriptionElement, o.authorDescriptionElement, true);
  end;
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAuthorType) and isEmptyProp(FAuthorDescription);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthor.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('authorType');
  fields.add('authorDescription');
end;

{ TFhirSubstanceSourceMaterialOrganismAuthor }

Procedure TFhirSubstanceSourceMaterialOrganismAuthor.SetAuthorType(value : TFhirCodeableConcept);
begin
  FAuthorType.free;
  FAuthorType := value;
end;

Procedure TFhirSubstanceSourceMaterialOrganismAuthor.SetAuthorDescription(value : TFhirString);
begin
  FAuthorDescription.free;
  FAuthorDescription := value;
end;

Function TFhirSubstanceSourceMaterialOrganismAuthor.GetAuthorDescriptionST : String;
begin
  if FAuthorDescription = nil then
    result := ''
  else
    result := FAuthorDescription.value;
end;

Procedure TFhirSubstanceSourceMaterialOrganismAuthor.SetAuthorDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FAuthorDescription = nil then
      FAuthorDescription := TFhirString.create;
    FAuthorDescription.value := value
  end
  else if FAuthorDescription <> nil then
    FAuthorDescription.value := '';
end;

function TFhirSubstanceSourceMaterialOrganismAuthor.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAuthorType.sizeInBytes);
  inc(result, FAuthorDescription.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator }

Constructor TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator.Create(list : TFhirSubstanceSourceMaterialOrganismAuthorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator.GetCurrent : TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialOrganismAuthorList }
procedure TFhirSubstanceSourceMaterialOrganismAuthorList.AddItem(value: TFhirSubstanceSourceMaterialOrganismAuthor);
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterialOrganismAuthor', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterialOrganismAuthor');
  add(value);
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.Append: TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthorList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.GetEnumerator : TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthorListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.Clone: TFhirSubstanceSourceMaterialOrganismAuthorList;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthorList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.GetItemN(index: Integer): TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor;
end;
function TFhirSubstanceSourceMaterialOrganismAuthorList.IndexOf(value: TFhirSubstanceSourceMaterialOrganismAuthor): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.Insert(index: Integer): TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthorList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterialOrganismAuthor);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismAuthor);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.Item(index: Integer): TFhirSubstanceSourceMaterialOrganismAuthor;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthor(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismAuthorList.Link: TFhirSubstanceSourceMaterialOrganismAuthorList;
begin
  result := TFhirSubstanceSourceMaterialOrganismAuthorList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthorList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterialOrganismAuthor);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismAuthor);
  FhirSubstanceSourceMaterialOrganismAuthors[index] := value;
end;

procedure TFhirSubstanceSourceMaterialOrganismAuthorList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterialOrganismAuthor);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismAuthor);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSourceMaterialOrganismHybrid }

constructor TFhirSubstanceSourceMaterialOrganismHybrid.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterialOrganismHybrid.Destroy;
begin
  FMaternalOrganismId.free;
  FMaternalOrganismName.free;
  FPaternalOrganismId.free;
  FPaternalOrganismName.free;
  FHybridType.free;
  inherited;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.Assign(oSource : TFslObject);
begin
  inherited;
  maternalOrganismIdElement := TFhirSubstanceSourceMaterialOrganismHybrid(oSource).maternalOrganismIdElement.Clone;
  maternalOrganismNameElement := TFhirSubstanceSourceMaterialOrganismHybrid(oSource).maternalOrganismNameElement.Clone;
  paternalOrganismIdElement := TFhirSubstanceSourceMaterialOrganismHybrid(oSource).paternalOrganismIdElement.Clone;
  paternalOrganismNameElement := TFhirSubstanceSourceMaterialOrganismHybrid(oSource).paternalOrganismNameElement.Clone;
  hybridType := TFhirSubstanceSourceMaterialOrganismHybrid(oSource).hybridType.Clone;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'maternalOrganismId') Then
     list.add(self.link, 'maternalOrganismId', FMaternalOrganismId.Link);
  if (child_name = 'maternalOrganismName') Then
     list.add(self.link, 'maternalOrganismName', FMaternalOrganismName.Link);
  if (child_name = 'paternalOrganismId') Then
     list.add(self.link, 'paternalOrganismId', FPaternalOrganismId.Link);
  if (child_name = 'paternalOrganismName') Then
     list.add(self.link, 'paternalOrganismName', FPaternalOrganismName.Link);
  if (child_name = 'hybridType') Then
     list.add(self.link, 'hybridType', FHybridType.Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'maternalOrganismId', 'string', false, TFhirString, FMaternalOrganismId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maternalOrganismName', 'string', false, TFhirString, FMaternalOrganismName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'paternalOrganismId', 'string', false, TFhirString, FPaternalOrganismId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'paternalOrganismName', 'string', false, TFhirString, FPaternalOrganismName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'hybridType', 'CodeableConcept', false, TFhirCodeableConcept, FHybridType.Link));{2}
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'maternalOrganismId') then
  begin
    MaternalOrganismIdElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'maternalOrganismName') then
  begin
    MaternalOrganismNameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'paternalOrganismId') then
  begin
    PaternalOrganismIdElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'paternalOrganismName') then
  begin
    PaternalOrganismNameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'hybridType') then
  begin
    HybridType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'maternalOrganismId') then result := TFhirString.create() {5b}
  else if (propName = 'maternalOrganismName') then result := TFhirString.create() {5b}
  else if (propName = 'paternalOrganismId') then result := TFhirString.create() {5b}
  else if (propName = 'paternalOrganismName') then result := TFhirString.create() {5b}
  else if (propName = 'hybridType') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'maternalOrganismId') then result := 'string'
  else if (propName = 'maternalOrganismName') then result := 'string'
  else if (propName = 'paternalOrganismId') then result := 'string'
  else if (propName = 'paternalOrganismName') then result := 'string'
  else if (propName = 'hybridType') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'maternalOrganismId') then MaternalOrganismIdElement := nil
  else if (propName = 'maternalOrganismName') then MaternalOrganismNameElement := nil
  else if (propName = 'paternalOrganismId') then PaternalOrganismIdElement := nil
  else if (propName = 'paternalOrganismName') then PaternalOrganismNameElement := nil
  else if (propName = 'hybridType') then HybridTypeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'maternalOrganismId') then MaternalOrganismIdElement := asString(new){5b}
  else if (propName = 'maternalOrganismName') then MaternalOrganismNameElement := asString(new){5b}
  else if (propName = 'paternalOrganismId') then PaternalOrganismIdElement := asString(new){5b}
  else if (propName = 'paternalOrganismName') then PaternalOrganismNameElement := asString(new){5b}
  else if (propName = 'hybridType') then HybridTypeElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.fhirType : string;
begin
  result := 'hybrid';
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.Link : TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid(inherited Link);
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.Clone : TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterialOrganismHybrid)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterialOrganismHybrid(other);
    result := compareDeep(maternalOrganismIdElement, o.maternalOrganismIdElement, true) and 
      compareDeep(maternalOrganismNameElement, o.maternalOrganismNameElement, true) and 
      compareDeep(paternalOrganismIdElement, o.paternalOrganismIdElement, true) and 
      compareDeep(paternalOrganismNameElement, o.paternalOrganismNameElement, true) and 
      compareDeep(hybridTypeElement, o.hybridTypeElement, true);
  end;
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMaternalOrganismId) and isEmptyProp(FMaternalOrganismName) and isEmptyProp(FPaternalOrganismId) and isEmptyProp(FPaternalOrganismName) and isEmptyProp(FHybridType);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybrid.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('maternalOrganismId');
  fields.add('maternalOrganismName');
  fields.add('paternalOrganismId');
  fields.add('paternalOrganismName');
  fields.add('hybridType');
end;

{ TFhirSubstanceSourceMaterialOrganismHybrid }

Procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetMaternalOrganismId(value : TFhirString);
begin
  FMaternalOrganismId.free;
  FMaternalOrganismId := value;
end;

Function TFhirSubstanceSourceMaterialOrganismHybrid.GetMaternalOrganismIdST : String;
begin
  if FMaternalOrganismId = nil then
    result := ''
  else
    result := FMaternalOrganismId.value;
end;

Procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetMaternalOrganismIdST(value : String);
begin
  if value <> '' then
  begin
    if FMaternalOrganismId = nil then
      FMaternalOrganismId := TFhirString.create;
    FMaternalOrganismId.value := value
  end
  else if FMaternalOrganismId <> nil then
    FMaternalOrganismId.value := '';
end;

Procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetMaternalOrganismName(value : TFhirString);
begin
  FMaternalOrganismName.free;
  FMaternalOrganismName := value;
end;

Function TFhirSubstanceSourceMaterialOrganismHybrid.GetMaternalOrganismNameST : String;
begin
  if FMaternalOrganismName = nil then
    result := ''
  else
    result := FMaternalOrganismName.value;
end;

Procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetMaternalOrganismNameST(value : String);
begin
  if value <> '' then
  begin
    if FMaternalOrganismName = nil then
      FMaternalOrganismName := TFhirString.create;
    FMaternalOrganismName.value := value
  end
  else if FMaternalOrganismName <> nil then
    FMaternalOrganismName.value := '';
end;

Procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetPaternalOrganismId(value : TFhirString);
begin
  FPaternalOrganismId.free;
  FPaternalOrganismId := value;
end;

Function TFhirSubstanceSourceMaterialOrganismHybrid.GetPaternalOrganismIdST : String;
begin
  if FPaternalOrganismId = nil then
    result := ''
  else
    result := FPaternalOrganismId.value;
end;

Procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetPaternalOrganismIdST(value : String);
begin
  if value <> '' then
  begin
    if FPaternalOrganismId = nil then
      FPaternalOrganismId := TFhirString.create;
    FPaternalOrganismId.value := value
  end
  else if FPaternalOrganismId <> nil then
    FPaternalOrganismId.value := '';
end;

Procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetPaternalOrganismName(value : TFhirString);
begin
  FPaternalOrganismName.free;
  FPaternalOrganismName := value;
end;

Function TFhirSubstanceSourceMaterialOrganismHybrid.GetPaternalOrganismNameST : String;
begin
  if FPaternalOrganismName = nil then
    result := ''
  else
    result := FPaternalOrganismName.value;
end;

Procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetPaternalOrganismNameST(value : String);
begin
  if value <> '' then
  begin
    if FPaternalOrganismName = nil then
      FPaternalOrganismName := TFhirString.create;
    FPaternalOrganismName.value := value
  end
  else if FPaternalOrganismName <> nil then
    FPaternalOrganismName.value := '';
end;

Procedure TFhirSubstanceSourceMaterialOrganismHybrid.SetHybridType(value : TFhirCodeableConcept);
begin
  FHybridType.free;
  FHybridType := value;
end;

function TFhirSubstanceSourceMaterialOrganismHybrid.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMaternalOrganismId.sizeInBytes);
  inc(result, FMaternalOrganismName.sizeInBytes);
  inc(result, FPaternalOrganismId.sizeInBytes);
  inc(result, FPaternalOrganismName.sizeInBytes);
  inc(result, FHybridType.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialOrganismHybridListEnumerator }

Constructor TFhirSubstanceSourceMaterialOrganismHybridListEnumerator.Create(list : TFhirSubstanceSourceMaterialOrganismHybridList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialOrganismHybridListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismHybridListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialOrganismHybridListEnumerator.GetCurrent : TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialOrganismHybridListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialOrganismHybridList }
procedure TFhirSubstanceSourceMaterialOrganismHybridList.AddItem(value: TFhirSubstanceSourceMaterialOrganismHybrid);
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterialOrganismHybrid', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterialOrganismHybrid');
  add(value);
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.Append: TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybridList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.GetEnumerator : TFhirSubstanceSourceMaterialOrganismHybridListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybridListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.Clone: TFhirSubstanceSourceMaterialOrganismHybridList;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybridList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.GetItemN(index: Integer): TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid;
end;
function TFhirSubstanceSourceMaterialOrganismHybridList.IndexOf(value: TFhirSubstanceSourceMaterialOrganismHybrid): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.Insert(index: Integer): TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybridList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterialOrganismHybrid);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismHybrid);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.Item(index: Integer): TFhirSubstanceSourceMaterialOrganismHybrid;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybrid(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismHybridList.Link: TFhirSubstanceSourceMaterialOrganismHybridList;
begin
  result := TFhirSubstanceSourceMaterialOrganismHybridList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybridList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialOrganismHybridList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterialOrganismHybrid);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismHybrid);
  FhirSubstanceSourceMaterialOrganismHybrids[index] := value;
end;

procedure TFhirSubstanceSourceMaterialOrganismHybridList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterialOrganismHybrid);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismHybrid);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSourceMaterialOrganismOrganismGeneral }

constructor TFhirSubstanceSourceMaterialOrganismOrganismGeneral.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterialOrganismOrganismGeneral.Destroy;
begin
  FKingdom.free;
  FPhylum.free;
  FClass_.free;
  FOrder.free;
  inherited;
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.Assign(oSource : TFslObject);
begin
  inherited;
  kingdom := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(oSource).kingdom.Clone;
  phylum := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(oSource).phylum.Clone;
  class_ := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(oSource).class_.Clone;
  order := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(oSource).order.Clone;
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'kingdom') Then
     list.add(self.link, 'kingdom', FKingdom.Link);
  if (child_name = 'phylum') Then
     list.add(self.link, 'phylum', FPhylum.Link);
  if (child_name = 'class') Then
     list.add(self.link, 'class', FClass_.Link);
  if (child_name = 'order') Then
     list.add(self.link, 'order', FOrder.Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'kingdom', 'CodeableConcept', false, TFhirCodeableConcept, FKingdom.Link));{2}
  oList.add(TFHIRProperty.create(self, 'phylum', 'CodeableConcept', false, TFhirCodeableConcept, FPhylum.Link));{2}
  oList.add(TFHIRProperty.create(self, 'class', 'CodeableConcept', false, TFhirCodeableConcept, FClass_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'order', 'CodeableConcept', false, TFhirCodeableConcept, FOrder.Link));{2}
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'kingdom') then
  begin
    Kingdom := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'phylum') then
  begin
    Phylum := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'order') then
  begin
    Order := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'kingdom') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'phylum') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'class') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'order') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'kingdom') then result := 'CodeableConcept'
  else if (propName = 'phylum') then result := 'CodeableConcept'
  else if (propName = 'class') then result := 'CodeableConcept'
  else if (propName = 'order') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'kingdom') then KingdomElement := nil
  else if (propName = 'phylum') then PhylumElement := nil
  else if (propName = 'class') then Class_Element := nil
  else if (propName = 'order') then OrderElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'kingdom') then KingdomElement := new as TFhirCodeableConcept{4}
  else if (propName = 'phylum') then PhylumElement := new as TFhirCodeableConcept{4}
  else if (propName = 'class') then Class_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'order') then OrderElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.fhirType : string;
begin
  result := 'organismGeneral';
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.Link : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(inherited Link);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.Clone : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterialOrganismOrganismGeneral)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(other);
    result := compareDeep(kingdomElement, o.kingdomElement, true) and compareDeep(phylumElement, o.phylumElement, true) and 
      compareDeep(class_Element, o.class_Element, true) and compareDeep(orderElement, o.orderElement, true);
  end;
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FKingdom) and isEmptyProp(FPhylum) and isEmptyProp(FClass_) and isEmptyProp(FOrder);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('kingdom');
  fields.add('phylum');
  fields.add('class');
  fields.add('order');
end;

{ TFhirSubstanceSourceMaterialOrganismOrganismGeneral }

Procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.SetKingdom(value : TFhirCodeableConcept);
begin
  FKingdom.free;
  FKingdom := value;
end;

Procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.SetPhylum(value : TFhirCodeableConcept);
begin
  FPhylum.free;
  FPhylum := value;
end;

Procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.SetClass_(value : TFhirCodeableConcept);
begin
  FClass_.free;
  FClass_ := value;
end;

Procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneral.SetOrder(value : TFhirCodeableConcept);
begin
  FOrder.free;
  FOrder := value;
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneral.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FKingdom.sizeInBytes);
  inc(result, FPhylum.sizeInBytes);
  inc(result, FClass_.sizeInBytes);
  inc(result, FOrder.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator }

Constructor TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator.Create(list : TFhirSubstanceSourceMaterialOrganismOrganismGeneralList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator.GetCurrent : TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialOrganismOrganismGeneralList }
procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.AddItem(value: TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterialOrganismOrganismGeneral', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterialOrganismOrganismGeneral');
  add(value);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Append: TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.GetEnumerator : TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneralListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Clone: TFhirSubstanceSourceMaterialOrganismOrganismGeneralList;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneralList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.GetItemN(index: Integer): TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
end;
function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.IndexOf(value: TFhirSubstanceSourceMaterialOrganismOrganismGeneral): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Insert(index: Integer): TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Item(index: Integer): TFhirSubstanceSourceMaterialOrganismOrganismGeneral;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneral(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Link: TFhirSubstanceSourceMaterialOrganismOrganismGeneralList;
begin
  result := TFhirSubstanceSourceMaterialOrganismOrganismGeneralList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
  FhirSubstanceSourceMaterialOrganismOrganismGenerals[index] := value;
end;

procedure TFhirSubstanceSourceMaterialOrganismOrganismGeneralList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
begin
  assert(value is TFhirSubstanceSourceMaterialOrganismOrganismGeneral);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSourceMaterialPartDescription }

constructor TFhirSubstanceSourceMaterialPartDescription.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterialPartDescription.Destroy;
begin
  FPart.free;
  FPartLocation.free;
  inherited;
end;

procedure TFhirSubstanceSourceMaterialPartDescription.Assign(oSource : TFslObject);
begin
  inherited;
  part := TFhirSubstanceSourceMaterialPartDescription(oSource).part.Clone;
  partLocation := TFhirSubstanceSourceMaterialPartDescription(oSource).partLocation.Clone;
end;

procedure TFhirSubstanceSourceMaterialPartDescription.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'part') Then
     list.add(self.link, 'part', FPart.Link);
  if (child_name = 'partLocation') Then
     list.add(self.link, 'partLocation', FPartLocation.Link);
end;

procedure TFhirSubstanceSourceMaterialPartDescription.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'part', 'CodeableConcept', false, TFhirCodeableConcept, FPart.Link));{2}
  oList.add(TFHIRProperty.create(self, 'partLocation', 'CodeableConcept', false, TFhirCodeableConcept, FPartLocation.Link));{2}
end;

function TFhirSubstanceSourceMaterialPartDescription.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'part') then
  begin
    Part := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'partLocation') then
  begin
    PartLocation := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSourceMaterialPartDescription.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSourceMaterialPartDescription.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'part') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'partLocation') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterialPartDescription.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'part') then result := 'CodeableConcept'
  else if (propName = 'partLocation') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterialPartDescription.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'part') then PartElement := nil
  else if (propName = 'partLocation') then PartLocationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterialPartDescription.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'part') then PartElement := new as TFhirCodeableConcept{4}
  else if (propName = 'partLocation') then PartLocationElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterialPartDescription.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterialPartDescription.fhirType : string;
begin
  result := 'partDescription';
end;

function TFhirSubstanceSourceMaterialPartDescription.Link : TFhirSubstanceSourceMaterialPartDescription;
begin
  result := TFhirSubstanceSourceMaterialPartDescription(inherited Link);
end;

function TFhirSubstanceSourceMaterialPartDescription.Clone : TFhirSubstanceSourceMaterialPartDescription;
begin
  result := TFhirSubstanceSourceMaterialPartDescription(inherited Clone);
end;

function TFhirSubstanceSourceMaterialPartDescription.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterialPartDescription;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterialPartDescription)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterialPartDescription(other);
    result := compareDeep(partElement, o.partElement, true) and compareDeep(partLocationElement, o.partLocationElement, true);
  end;
end;

function TFhirSubstanceSourceMaterialPartDescription.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPart) and isEmptyProp(FPartLocation);
end;

procedure TFhirSubstanceSourceMaterialPartDescription.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('part');
  fields.add('partLocation');
end;

{ TFhirSubstanceSourceMaterialPartDescription }

Procedure TFhirSubstanceSourceMaterialPartDescription.SetPart(value : TFhirCodeableConcept);
begin
  FPart.free;
  FPart := value;
end;

Procedure TFhirSubstanceSourceMaterialPartDescription.SetPartLocation(value : TFhirCodeableConcept);
begin
  FPartLocation.free;
  FPartLocation := value;
end;

function TFhirSubstanceSourceMaterialPartDescription.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPart.sizeInBytes);
  inc(result, FPartLocation.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialPartDescriptionListEnumerator }

Constructor TFhirSubstanceSourceMaterialPartDescriptionListEnumerator.Create(list : TFhirSubstanceSourceMaterialPartDescriptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialPartDescriptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialPartDescriptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialPartDescriptionListEnumerator.GetCurrent : TFhirSubstanceSourceMaterialPartDescription;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialPartDescriptionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialPartDescriptionList }
procedure TFhirSubstanceSourceMaterialPartDescriptionList.AddItem(value: TFhirSubstanceSourceMaterialPartDescription);
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterialPartDescription', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterialPartDescription');
  add(value);
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.Append: TFhirSubstanceSourceMaterialPartDescription;
begin
  result := TFhirSubstanceSourceMaterialPartDescription.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialPartDescriptionList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.GetEnumerator : TFhirSubstanceSourceMaterialPartDescriptionListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialPartDescriptionListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.Clone: TFhirSubstanceSourceMaterialPartDescriptionList;
begin
  result := TFhirSubstanceSourceMaterialPartDescriptionList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.GetItemN(index: Integer): TFhirSubstanceSourceMaterialPartDescription;
begin
  result := TFhirSubstanceSourceMaterialPartDescription(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterialPartDescription;
end;
function TFhirSubstanceSourceMaterialPartDescriptionList.IndexOf(value: TFhirSubstanceSourceMaterialPartDescription): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.Insert(index: Integer): TFhirSubstanceSourceMaterialPartDescription;
begin
  result := TFhirSubstanceSourceMaterialPartDescription.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialPartDescriptionList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterialPartDescription);
begin
  assert(value is TFhirSubstanceSourceMaterialPartDescription);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.Item(index: Integer): TFhirSubstanceSourceMaterialPartDescription;
begin
  result := TFhirSubstanceSourceMaterialPartDescription(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialPartDescriptionList.Link: TFhirSubstanceSourceMaterialPartDescriptionList;
begin
  result := TFhirSubstanceSourceMaterialPartDescriptionList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialPartDescriptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialPartDescriptionList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterialPartDescription);
begin
  assert(value is TFhirSubstanceSourceMaterialPartDescription);
  FhirSubstanceSourceMaterialPartDescriptions[index] := value;
end;

procedure TFhirSubstanceSourceMaterialPartDescriptionList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterialPartDescription);
begin
  assert(value is TFhirSubstanceSourceMaterialPartDescription);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSourceMaterial }

constructor TFhirSubstanceSourceMaterial.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSourceMaterial.Destroy;
begin
  FSourceMaterialClass.free;
  FSourceMaterialType.free;
  FSourceMaterialState.free;
  FOrganismId.free;
  FOrganismName.free;
  FParentSubstanceIdList.Free;
  FParentSubstanceNameList.Free;
  FCountryOfOriginList.Free;
  FGeographicalLocationList.Free;
  FDevelopmentStage.free;
  FFractionDescriptionList.Free;
  FOrganism.free;
  FPartDescriptionList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterial.GetResourceType : TFhirResourceType;
begin
  result := frtSubstanceSourceMaterial;
end;

procedure TFhirSubstanceSourceMaterial.Assign(oSource : TFslObject);
begin
  inherited;
  sourceMaterialClass := TFhirSubstanceSourceMaterial(oSource).sourceMaterialClass.Clone;
  sourceMaterialType := TFhirSubstanceSourceMaterial(oSource).sourceMaterialType.Clone;
  sourceMaterialState := TFhirSubstanceSourceMaterial(oSource).sourceMaterialState.Clone;
  organismId := TFhirSubstanceSourceMaterial(oSource).organismId.Clone;
  organismNameElement := TFhirSubstanceSourceMaterial(oSource).organismNameElement.Clone;
  if (TFhirSubstanceSourceMaterial(oSource).FParentSubstanceIdList = nil) then
  begin
    FParentSubstanceIdList.free;
    FParentSubstanceIdList := nil;
  end
  else
  begin
    if FParentSubstanceIdList = nil then
      FParentSubstanceIdList := TFhirIdentifierList.Create;
    FParentSubstanceIdList.Assign(TFhirSubstanceSourceMaterial(oSource).FParentSubstanceIdList);
  end;
  if (TFhirSubstanceSourceMaterial(oSource).FParentSubstanceNameList = nil) then
  begin
    FParentSubstanceNameList.free;
    FParentSubstanceNameList := nil;
  end
  else
  begin
    if FParentSubstanceNameList = nil then
      FParentSubstanceNameList := TFhirStringList.Create;
    FParentSubstanceNameList.Assign(TFhirSubstanceSourceMaterial(oSource).FParentSubstanceNameList);
  end;
  if (TFhirSubstanceSourceMaterial(oSource).FCountryOfOriginList = nil) then
  begin
    FCountryOfOriginList.free;
    FCountryOfOriginList := nil;
  end
  else
  begin
    if FCountryOfOriginList = nil then
      FCountryOfOriginList := TFhirCodeableConceptList.Create;
    FCountryOfOriginList.Assign(TFhirSubstanceSourceMaterial(oSource).FCountryOfOriginList);
  end;
  if (TFhirSubstanceSourceMaterial(oSource).FGeographicalLocationList = nil) then
  begin
    FGeographicalLocationList.free;
    FGeographicalLocationList := nil;
  end
  else
  begin
    if FGeographicalLocationList = nil then
      FGeographicalLocationList := TFhirStringList.Create;
    FGeographicalLocationList.Assign(TFhirSubstanceSourceMaterial(oSource).FGeographicalLocationList);
  end;
  developmentStage := TFhirSubstanceSourceMaterial(oSource).developmentStage.Clone;
  if (TFhirSubstanceSourceMaterial(oSource).FFractionDescriptionList = nil) then
  begin
    FFractionDescriptionList.free;
    FFractionDescriptionList := nil;
  end
  else
  begin
    if FFractionDescriptionList = nil then
      FFractionDescriptionList := TFhirSubstanceSourceMaterialFractionDescriptionList.Create;
    FFractionDescriptionList.Assign(TFhirSubstanceSourceMaterial(oSource).FFractionDescriptionList);
  end;
  organism := TFhirSubstanceSourceMaterial(oSource).organism.Clone;
  if (TFhirSubstanceSourceMaterial(oSource).FPartDescriptionList = nil) then
  begin
    FPartDescriptionList.free;
    FPartDescriptionList := nil;
  end
  else
  begin
    if FPartDescriptionList = nil then
      FPartDescriptionList := TFhirSubstanceSourceMaterialPartDescriptionList.Create;
    FPartDescriptionList.Assign(TFhirSubstanceSourceMaterial(oSource).FPartDescriptionList);
  end;
end;

procedure TFhirSubstanceSourceMaterial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sourceMaterialClass') Then
     list.add(self.link, 'sourceMaterialClass', FSourceMaterialClass.Link);
  if (child_name = 'sourceMaterialType') Then
     list.add(self.link, 'sourceMaterialType', FSourceMaterialType.Link);
  if (child_name = 'sourceMaterialState') Then
     list.add(self.link, 'sourceMaterialState', FSourceMaterialState.Link);
  if (child_name = 'organismId') Then
     list.add(self.link, 'organismId', FOrganismId.Link);
  if (child_name = 'organismName') Then
     list.add(self.link, 'organismName', FOrganismName.Link);
  if (child_name = 'parentSubstanceId') Then
    list.addAll(self, 'parentSubstanceId', FParentSubstanceIdList);
  if (child_name = 'parentSubstanceName') Then
    list.addAll(self, 'parentSubstanceName', FParentSubstanceNameList);
  if (child_name = 'countryOfOrigin') Then
    list.addAll(self, 'countryOfOrigin', FCountryOfOriginList);
  if (child_name = 'geographicalLocation') Then
    list.addAll(self, 'geographicalLocation', FGeographicalLocationList);
  if (child_name = 'developmentStage') Then
     list.add(self.link, 'developmentStage', FDevelopmentStage.Link);
  if (child_name = 'fractionDescription') Then
    list.addAll(self, 'fractionDescription', FFractionDescriptionList);
  if (child_name = 'organism') Then
     list.add(self.link, 'organism', FOrganism.Link);
  if (child_name = 'partDescription') Then
    list.addAll(self, 'partDescription', FPartDescriptionList);
end;

procedure TFhirSubstanceSourceMaterial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sourceMaterialClass', 'CodeableConcept', false, TFhirCodeableConcept, FSourceMaterialClass.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sourceMaterialType', 'CodeableConcept', false, TFhirCodeableConcept, FSourceMaterialType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sourceMaterialState', 'CodeableConcept', false, TFhirCodeableConcept, FSourceMaterialState.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organismId', 'Identifier', false, TFhirIdentifier, FOrganismId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organismName', 'string', false, TFhirString, FOrganismName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parentSubstanceId', 'Identifier', true, TFhirIdentifier, FParentSubstanceIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'parentSubstanceName', 'string', true, TFhirString, FParentSubstanceNameList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'countryOfOrigin', 'CodeableConcept', true, TFhirCodeableConcept, FCountryOfOriginList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'geographicalLocation', 'string', true, TFhirString, FGeographicalLocationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'developmentStage', 'CodeableConcept', false, TFhirCodeableConcept, FDevelopmentStage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'fractionDescription', '', true, TFhirSubstanceSourceMaterialFractionDescription, FFractionDescriptionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'organism', '', false, TFhirSubstanceSourceMaterialOrganism, FOrganism.Link));{2}
  oList.add(TFHIRProperty.create(self, 'partDescription', '', true, TFhirSubstanceSourceMaterialPartDescription, FPartDescriptionList.Link)){3};
end;

function TFhirSubstanceSourceMaterial.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sourceMaterialClass') then
  begin
    SourceMaterialClass := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'sourceMaterialType') then
  begin
    SourceMaterialType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'sourceMaterialState') then
  begin
    SourceMaterialState := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'organismId') then
  begin
    OrganismId := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'organismName') then
  begin
    OrganismNameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'parentSubstanceId') then
  begin
    ParentSubstanceIdList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'parentSubstanceName') then
  begin
    ParentSubstanceNameList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'countryOfOrigin') then
  begin
    CountryOfOriginList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'geographicalLocation') then
  begin
    GeographicalLocationList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'developmentStage') then
  begin
    DevelopmentStage := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'fractionDescription') then
  begin
    FractionDescriptionList.add(propValue as TFhirSubstanceSourceMaterialFractionDescription){2a};
    result := propValue;
  end
  else if (propName = 'organism') then
  begin
    Organism := propValue as TFhirSubstanceSourceMaterialOrganism{4b};
    result := propValue;
  end
  else if (propName = 'partDescription') then
  begin
    PartDescriptionList.add(propValue as TFhirSubstanceSourceMaterialPartDescription){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSubstanceSourceMaterial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'parentSubstanceId') then ParentSubstanceIdList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'parentSubstanceName') then ParentSubstanceNameList.insertItem(index, asString(propValue)){2}
  else if (propName = 'countryOfOrigin') then CountryOfOriginList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'geographicalLocation') then GeographicalLocationList.insertItem(index, asString(propValue)){2}
  else if (propName = 'fractionDescription') then FractionDescriptionList.insertItem(index, propValue as TFhirSubstanceSourceMaterialFractionDescription){2a}
  else if (propName = 'partDescription') then PartDescriptionList.insertItem(index, propValue as TFhirSubstanceSourceMaterialPartDescription){2a}
  else inherited;
end;

function TFhirSubstanceSourceMaterial.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'sourceMaterialClass') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'sourceMaterialType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'sourceMaterialState') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'organismId') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'organismName') then result := TFhirString.create() {5b}
  else if (propName = 'parentSubstanceId') then result := ParentSubstanceIdList.new(){2}
  else if (propName = 'parentSubstanceName') then result := ParentSubstanceNameList.new(){2}
  else if (propName = 'countryOfOrigin') then result := CountryOfOriginList.new(){2}
  else if (propName = 'geographicalLocation') then result := GeographicalLocationList.new(){2}
  else if (propName = 'developmentStage') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'fractionDescription') then result := FractionDescriptionList.new(){2}
  else if (propName = 'organism') then result := TFhirSubstanceSourceMaterialOrganism.create(){4b}
  else if (propName = 'partDescription') then result := PartDescriptionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSourceMaterial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sourceMaterialClass') then result := 'CodeableConcept'
  else if (propName = 'sourceMaterialType') then result := 'CodeableConcept'
  else if (propName = 'sourceMaterialState') then result := 'CodeableConcept'
  else if (propName = 'organismId') then result := 'Identifier'
  else if (propName = 'organismName') then result := 'string'
  else if (propName = 'parentSubstanceId') then result := 'Identifier'
  else if (propName = 'parentSubstanceName') then result := 'string'
  else if (propName = 'countryOfOrigin') then result := 'CodeableConcept'
  else if (propName = 'geographicalLocation') then result := 'string'
  else if (propName = 'developmentStage') then result := 'CodeableConcept'
  else if (propName = 'fractionDescription') then result := ''
  else if (propName = 'organism') then result := ''
  else if (propName = 'partDescription') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSourceMaterial.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'sourceMaterialClass') then SourceMaterialClassElement := nil
  else if (propName = 'sourceMaterialType') then SourceMaterialTypeElement := nil
  else if (propName = 'sourceMaterialState') then SourceMaterialStateElement := nil
  else if (propName = 'organismId') then OrganismIdElement := nil
  else if (propName = 'organismName') then OrganismNameElement := nil
  else if (propName = 'parentSubstanceId') then deletePropertyValue('parentSubstanceId', ParentSubstanceIdList, value) {2}
  else if (propName = 'parentSubstanceName') then deletePropertyValue('parentSubstanceName', ParentSubstanceNameList, value) {2}
  else if (propName = 'countryOfOrigin') then deletePropertyValue('countryOfOrigin', CountryOfOriginList, value) {2}
  else if (propName = 'geographicalLocation') then deletePropertyValue('geographicalLocation', GeographicalLocationList, value) {2}
  else if (propName = 'developmentStage') then DevelopmentStageElement := nil
  else if (propName = 'fractionDescription') then deletePropertyValue('fractionDescription', FractionDescriptionList, value) {2}
  else if (propName = 'organism') then OrganismElement := nil
  else if (propName = 'partDescription') then deletePropertyValue('partDescription', PartDescriptionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSourceMaterial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sourceMaterialClass') then SourceMaterialClassElement := new as TFhirCodeableConcept{4}
  else if (propName = 'sourceMaterialType') then SourceMaterialTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'sourceMaterialState') then SourceMaterialStateElement := new as TFhirCodeableConcept{4}
  else if (propName = 'organismId') then OrganismIdElement := new as TFhirIdentifier{4}
  else if (propName = 'organismName') then OrganismNameElement := asString(new){5b}
  else if (propName = 'parentSubstanceId') then replacePropertyValue('parentSubstanceId', ParentSubstanceIdList, existing, new) {2}
  else if (propName = 'parentSubstanceName') then replacePropertyValue('parentSubstanceName', ParentSubstanceNameList, existing, new) {2}
  else if (propName = 'countryOfOrigin') then replacePropertyValue('countryOfOrigin', CountryOfOriginList, existing, new) {2}
  else if (propName = 'geographicalLocation') then replacePropertyValue('geographicalLocation', GeographicalLocationList, existing, new) {2}
  else if (propName = 'developmentStage') then DevelopmentStageElement := new as TFhirCodeableConcept{4}
  else if (propName = 'fractionDescription') then replacePropertyValue('fractionDescription', FractionDescriptionList, existing, new) {2}
  else if (propName = 'organism') then OrganismElement := new as TFhirSubstanceSourceMaterialOrganism{4}
  else if (propName = 'partDescription') then replacePropertyValue('partDescription', PartDescriptionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSourceMaterial.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'parentSubstanceId') then ParentSubstanceIdList.move(source, destination){2a}
  else if (propName = 'parentSubstanceName') then ParentSubstanceNameList.move(source, destination){2}
  else if (propName = 'countryOfOrigin') then CountryOfOriginList.move(source, destination){2a}
  else if (propName = 'geographicalLocation') then GeographicalLocationList.move(source, destination){2}
  else if (propName = 'fractionDescription') then FractionDescriptionList.move(source, destination){2a}
  else if (propName = 'partDescription') then PartDescriptionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSourceMaterial.fhirType : string;
begin
  result := 'SubstanceSourceMaterial';
end;

function TFhirSubstanceSourceMaterial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSourceMaterialClass) and isEmptyProp(FSourceMaterialType) and isEmptyProp(FSourceMaterialState) and isEmptyProp(FOrganismId) and isEmptyProp(FOrganismName) and isEmptyProp(FparentSubstanceIdList) and isEmptyProp(FparentSubstanceNameList) and isEmptyProp(FcountryOfOriginList) and isEmptyProp(FgeographicalLocationList) and isEmptyProp(FDevelopmentStage) and isEmptyProp(FfractionDescriptionList) and isEmptyProp(FOrganism) and isEmptyProp(FpartDescriptionList);
end;

function TFhirSubstanceSourceMaterial.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSourceMaterial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSourceMaterial)) then
    result := false
  else
  begin
    o := TFhirSubstanceSourceMaterial(other);
    result := compareDeep(sourceMaterialClassElement, o.sourceMaterialClassElement, true) and 
      compareDeep(sourceMaterialTypeElement, o.sourceMaterialTypeElement, true) and 
      compareDeep(sourceMaterialStateElement, o.sourceMaterialStateElement, true) and 
      compareDeep(organismIdElement, o.organismIdElement, true) and compareDeep(organismNameElement, o.organismNameElement, true) and 
      compareDeep(parentSubstanceIdList, o.parentSubstanceIdList, true) and compareDeep(parentSubstanceNameList, o.parentSubstanceNameList, true) and 
      compareDeep(countryOfOriginList, o.countryOfOriginList, true) and compareDeep(geographicalLocationList, o.geographicalLocationList, true) and 
      compareDeep(developmentStageElement, o.developmentStageElement, true) and compareDeep(fractionDescriptionList, o.fractionDescriptionList, true) and 
      compareDeep(organismElement, o.organismElement, true) and compareDeep(partDescriptionList, o.partDescriptionList, true);
  end;
end;

function TFhirSubstanceSourceMaterial.Link : TFhirSubstanceSourceMaterial;
begin
  result := TFhirSubstanceSourceMaterial(inherited Link);
end;

function TFhirSubstanceSourceMaterial.Clone : TFhirSubstanceSourceMaterial;
begin
  result := TFhirSubstanceSourceMaterial(inherited Clone);
end;

procedure TFhirSubstanceSourceMaterial.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('sourceMaterialClass');
  fields.add('sourceMaterialType');
  fields.add('sourceMaterialState');
  fields.add('organismId');
  fields.add('organismName');
  fields.add('parentSubstanceId');
  fields.add('parentSubstanceName');
  fields.add('countryOfOrigin');
  fields.add('geographicalLocation');
  fields.add('developmentStage');
  fields.add('fractionDescription');
  fields.add('organism');
  fields.add('partDescription');
end;

{ TFhirSubstanceSourceMaterial }

Procedure TFhirSubstanceSourceMaterial.SetSourceMaterialClass(value : TFhirCodeableConcept);
begin
  FSourceMaterialClass.free;
  FSourceMaterialClass := value;
end;

Procedure TFhirSubstanceSourceMaterial.SetSourceMaterialType(value : TFhirCodeableConcept);
begin
  FSourceMaterialType.free;
  FSourceMaterialType := value;
end;

Procedure TFhirSubstanceSourceMaterial.SetSourceMaterialState(value : TFhirCodeableConcept);
begin
  FSourceMaterialState.free;
  FSourceMaterialState := value;
end;

Procedure TFhirSubstanceSourceMaterial.SetOrganismId(value : TFhirIdentifier);
begin
  FOrganismId.free;
  FOrganismId := value;
end;

Procedure TFhirSubstanceSourceMaterial.SetOrganismName(value : TFhirString);
begin
  FOrganismName.free;
  FOrganismName := value;
end;

Function TFhirSubstanceSourceMaterial.GetOrganismNameST : String;
begin
  if FOrganismName = nil then
    result := ''
  else
    result := FOrganismName.value;
end;

Procedure TFhirSubstanceSourceMaterial.SetOrganismNameST(value : String);
begin
  if value <> '' then
  begin
    if FOrganismName = nil then
      FOrganismName := TFhirString.create;
    FOrganismName.value := value
  end
  else if FOrganismName <> nil then
    FOrganismName.value := '';
end;

Function TFhirSubstanceSourceMaterial.GetParentSubstanceIdList : TFhirIdentifierList;
begin
  if FParentSubstanceIdList = nil then
    FParentSubstanceIdList := TFhirIdentifierList.Create;
  result := FParentSubstanceIdList;
end;

Function TFhirSubstanceSourceMaterial.GetHasParentSubstanceIdList : boolean;
begin
  result := (FParentSubstanceIdList <> nil) and (FParentSubstanceIdList.count > 0);
end;

Function TFhirSubstanceSourceMaterial.GetParentSubstanceNameList : TFhirStringList;
begin
  if FParentSubstanceNameList = nil then
    FParentSubstanceNameList := TFhirStringList.Create;
  result := FParentSubstanceNameList;
end;

Function TFhirSubstanceSourceMaterial.GetHasParentSubstanceNameList : boolean;
begin
  result := (FParentSubstanceNameList <> nil) and (FParentSubstanceNameList.count > 0);
end;

Function TFhirSubstanceSourceMaterial.GetCountryOfOriginList : TFhirCodeableConceptList;
begin
  if FCountryOfOriginList = nil then
    FCountryOfOriginList := TFhirCodeableConceptList.Create;
  result := FCountryOfOriginList;
end;

Function TFhirSubstanceSourceMaterial.GetHasCountryOfOriginList : boolean;
begin
  result := (FCountryOfOriginList <> nil) and (FCountryOfOriginList.count > 0);
end;

Function TFhirSubstanceSourceMaterial.GetGeographicalLocationList : TFhirStringList;
begin
  if FGeographicalLocationList = nil then
    FGeographicalLocationList := TFhirStringList.Create;
  result := FGeographicalLocationList;
end;

Function TFhirSubstanceSourceMaterial.GetHasGeographicalLocationList : boolean;
begin
  result := (FGeographicalLocationList <> nil) and (FGeographicalLocationList.count > 0);
end;

Procedure TFhirSubstanceSourceMaterial.SetDevelopmentStage(value : TFhirCodeableConcept);
begin
  FDevelopmentStage.free;
  FDevelopmentStage := value;
end;

Function TFhirSubstanceSourceMaterial.GetFractionDescriptionList : TFhirSubstanceSourceMaterialFractionDescriptionList;
begin
  if FFractionDescriptionList = nil then
    FFractionDescriptionList := TFhirSubstanceSourceMaterialFractionDescriptionList.Create;
  result := FFractionDescriptionList;
end;

Function TFhirSubstanceSourceMaterial.GetHasFractionDescriptionList : boolean;
begin
  result := (FFractionDescriptionList <> nil) and (FFractionDescriptionList.count > 0);
end;

Procedure TFhirSubstanceSourceMaterial.SetOrganism(value : TFhirSubstanceSourceMaterialOrganism);
begin
  FOrganism.free;
  FOrganism := value;
end;

Function TFhirSubstanceSourceMaterial.GetPartDescriptionList : TFhirSubstanceSourceMaterialPartDescriptionList;
begin
  if FPartDescriptionList = nil then
    FPartDescriptionList := TFhirSubstanceSourceMaterialPartDescriptionList.Create;
  result := FPartDescriptionList;
end;

Function TFhirSubstanceSourceMaterial.GetHasPartDescriptionList : boolean;
begin
  result := (FPartDescriptionList <> nil) and (FPartDescriptionList.count > 0);
end;

function TFhirSubstanceSourceMaterial.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSourceMaterialClass.sizeInBytes);
  inc(result, FSourceMaterialType.sizeInBytes);
  inc(result, FSourceMaterialState.sizeInBytes);
  inc(result, FOrganismId.sizeInBytes);
  inc(result, FOrganismName.sizeInBytes);
  inc(result, FparentSubstanceIdList.sizeInBytes);
  inc(result, FparentSubstanceNameList.sizeInBytes);
  inc(result, FcountryOfOriginList.sizeInBytes);
  inc(result, FgeographicalLocationList.sizeInBytes);
  inc(result, FDevelopmentStage.sizeInBytes);
  inc(result, FfractionDescriptionList.sizeInBytes);
  inc(result, FOrganism.sizeInBytes);
  inc(result, FpartDescriptionList.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialListEnumerator }

Constructor TFhirSubstanceSourceMaterialListEnumerator.Create(list : TFhirSubstanceSourceMaterialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSourceMaterialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSourceMaterialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSourceMaterialListEnumerator.GetCurrent : TFhirSubstanceSourceMaterial;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSourceMaterialListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSourceMaterialList }
procedure TFhirSubstanceSourceMaterialList.AddItem(value: TFhirSubstanceSourceMaterial);
begin
  assert(value.ClassName = 'TFhirSubstanceSourceMaterial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSourceMaterial');
  add(value);
end;

function TFhirSubstanceSourceMaterialList.Append: TFhirSubstanceSourceMaterial;
begin
  result := TFhirSubstanceSourceMaterial.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSourceMaterialList.GetEnumerator : TFhirSubstanceSourceMaterialListEnumerator;
begin
  result := TFhirSubstanceSourceMaterialListEnumerator.Create(self.link);
end;

function TFhirSubstanceSourceMaterialList.Clone: TFhirSubstanceSourceMaterialList;
begin
  result := TFhirSubstanceSourceMaterialList(inherited Clone);
end;

function TFhirSubstanceSourceMaterialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSourceMaterialList.GetItemN(index: Integer): TFhirSubstanceSourceMaterial;
begin
  result := TFhirSubstanceSourceMaterial(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSourceMaterial;
end;
function TFhirSubstanceSourceMaterialList.IndexOf(value: TFhirSubstanceSourceMaterial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSourceMaterialList.Insert(index: Integer): TFhirSubstanceSourceMaterial;
begin
  result := TFhirSubstanceSourceMaterial.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSourceMaterialList.InsertItem(index: Integer; value: TFhirSubstanceSourceMaterial);
begin
  assert(value is TFhirSubstanceSourceMaterial);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSourceMaterialList.Item(index: Integer): TFhirSubstanceSourceMaterial;
begin
  result := TFhirSubstanceSourceMaterial(ObjectByIndex[index]);
end;

function TFhirSubstanceSourceMaterialList.Link: TFhirSubstanceSourceMaterialList;
begin
  result := TFhirSubstanceSourceMaterialList(inherited Link);
end;

procedure TFhirSubstanceSourceMaterialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSourceMaterialList.SetItemByIndex(index: Integer; value: TFhirSubstanceSourceMaterial);
begin
  assert(value is TFhirSubstanceSourceMaterial);
  FhirSubstanceSourceMaterials[index] := value;
end;

procedure TFhirSubstanceSourceMaterialList.SetItemN(index: Integer; value: TFhirSubstanceSourceMaterial);
begin
  assert(value is TFhirSubstanceSourceMaterial);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCESOURCEMATERIAL}

{$IFDEF FHIR_SUBSTANCESPECIFICATION}

{ TFhirSubstanceSpecificationMoiety }

constructor TFhirSubstanceSpecificationMoiety.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSpecificationMoiety.Destroy;
begin
  FRole.free;
  FIdentifier.free;
  FName.free;
  FStereochemistry.free;
  FOpticalActivity.free;
  FMolecularFormula.free;
  FAmount.free;
  inherited;
end;

procedure TFhirSubstanceSpecificationMoiety.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirSubstanceSpecificationMoiety(oSource).role.Clone;
  identifier := TFhirSubstanceSpecificationMoiety(oSource).identifier.Clone;
  nameElement := TFhirSubstanceSpecificationMoiety(oSource).nameElement.Clone;
  stereochemistry := TFhirSubstanceSpecificationMoiety(oSource).stereochemistry.Clone;
  opticalActivity := TFhirSubstanceSpecificationMoiety(oSource).opticalActivity.Clone;
  molecularFormulaElement := TFhirSubstanceSpecificationMoiety(oSource).molecularFormulaElement.Clone;
  amount := TFhirSubstanceSpecificationMoiety(oSource).amount.Clone;
end;

procedure TFhirSubstanceSpecificationMoiety.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'stereochemistry') Then
     list.add(self.link, 'stereochemistry', FStereochemistry.Link);
  if (child_name = 'opticalActivity') Then
     list.add(self.link, 'opticalActivity', FOpticalActivity.Link);
  if (child_name = 'molecularFormula') Then
     list.add(self.link, 'molecularFormula', FMolecularFormula.Link);
  if (child_name = 'amount[x]') or (child_name = 'amount') Then
     list.add(self.link, 'amount[x]', FAmount.Link);
end;

procedure TFhirSubstanceSpecificationMoiety.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'stereochemistry', 'CodeableConcept', false, TFhirCodeableConcept, FStereochemistry.Link));{2}
  oList.add(TFHIRProperty.create(self, 'opticalActivity', 'CodeableConcept', false, TFhirCodeableConcept, FOpticalActivity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'molecularFormula', 'string', false, TFhirString, FMolecularFormula.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount[x]', 'Quantity|string', false, TFhirType, FAmount.Link));{2}
end;

function TFhirSubstanceSpecificationMoiety.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'stereochemistry') then
  begin
    Stereochemistry := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'opticalActivity') then
  begin
    OpticalActivity := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'molecularFormula') then
  begin
    MolecularFormulaElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then
  begin
    Amount := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSpecificationMoiety.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSpecificationMoiety.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'stereochemistry') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'opticalActivity') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'molecularFormula') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then raise EFHIRException.create('Cannot make property Amount'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSpecificationMoiety.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'stereochemistry') then result := 'CodeableConcept'
  else if (propName = 'opticalActivity') then result := 'CodeableConcept'
  else if (propName = 'molecularFormula') then result := 'string'
  else if (propName = 'amount[x]') then result := 'Quantity|string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSpecificationMoiety.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'stereochemistry') then StereochemistryElement := nil
  else if (propName = 'opticalActivity') then OpticalActivityElement := nil
  else if (propName = 'molecularFormula') then MolecularFormulaElement := nil
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then AmountElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSpecificationMoiety.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'stereochemistry') then StereochemistryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'opticalActivity') then OpticalActivityElement := new as TFhirCodeableConcept{4}
  else if (propName = 'molecularFormula') then MolecularFormulaElement := asString(new){5b}
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then AmountElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSpecificationMoiety.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSpecificationMoiety.fhirType : string;
begin
  result := 'moiety';
end;

function TFhirSubstanceSpecificationMoiety.Link : TFhirSubstanceSpecificationMoiety;
begin
  result := TFhirSubstanceSpecificationMoiety(inherited Link);
end;

function TFhirSubstanceSpecificationMoiety.Clone : TFhirSubstanceSpecificationMoiety;
begin
  result := TFhirSubstanceSpecificationMoiety(inherited Clone);
end;

function TFhirSubstanceSpecificationMoiety.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSpecificationMoiety;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSpecificationMoiety)) then
    result := false
  else
  begin
    o := TFhirSubstanceSpecificationMoiety(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(identifierElement, o.identifierElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(stereochemistryElement, o.stereochemistryElement, true) and 
      compareDeep(opticalActivityElement, o.opticalActivityElement, true) and compareDeep(molecularFormulaElement, o.molecularFormulaElement, true) and 
      compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirSubstanceSpecificationMoiety.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FIdentifier) and isEmptyProp(FName) and isEmptyProp(FStereochemistry) and isEmptyProp(FOpticalActivity) and isEmptyProp(FMolecularFormula) and isEmptyProp(FAmount);
end;

procedure TFhirSubstanceSpecificationMoiety.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('identifier');
  fields.add('name');
  fields.add('stereochemistry');
  fields.add('opticalActivity');
  fields.add('molecularFormula');
  fields.add('amount[x]');
end;

{ TFhirSubstanceSpecificationMoiety }

Procedure TFhirSubstanceSpecificationMoiety.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirSubstanceSpecificationMoiety.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirSubstanceSpecificationMoiety.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirSubstanceSpecificationMoiety.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirSubstanceSpecificationMoiety.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirSubstanceSpecificationMoiety.SetStereochemistry(value : TFhirCodeableConcept);
begin
  FStereochemistry.free;
  FStereochemistry := value;
end;

Procedure TFhirSubstanceSpecificationMoiety.SetOpticalActivity(value : TFhirCodeableConcept);
begin
  FOpticalActivity.free;
  FOpticalActivity := value;
end;

Procedure TFhirSubstanceSpecificationMoiety.SetMolecularFormula(value : TFhirString);
begin
  FMolecularFormula.free;
  FMolecularFormula := value;
end;

Function TFhirSubstanceSpecificationMoiety.GetMolecularFormulaST : String;
begin
  if FMolecularFormula = nil then
    result := ''
  else
    result := FMolecularFormula.value;
end;

Procedure TFhirSubstanceSpecificationMoiety.SetMolecularFormulaST(value : String);
begin
  if value <> '' then
  begin
    if FMolecularFormula = nil then
      FMolecularFormula := TFhirString.create;
    FMolecularFormula.value := value
  end
  else if FMolecularFormula <> nil then
    FMolecularFormula.value := '';
end;

Procedure TFhirSubstanceSpecificationMoiety.SetAmount(value : TFhirType);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirSubstanceSpecificationMoiety.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRole.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FStereochemistry.sizeInBytes);
  inc(result, FOpticalActivity.sizeInBytes);
  inc(result, FMolecularFormula.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirSubstanceSpecificationMoietyListEnumerator }

Constructor TFhirSubstanceSpecificationMoietyListEnumerator.Create(list : TFhirSubstanceSpecificationMoietyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSpecificationMoietyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSpecificationMoietyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSpecificationMoietyListEnumerator.GetCurrent : TFhirSubstanceSpecificationMoiety;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSpecificationMoietyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSpecificationMoietyList }
procedure TFhirSubstanceSpecificationMoietyList.AddItem(value: TFhirSubstanceSpecificationMoiety);
begin
  assert(value.ClassName = 'TFhirSubstanceSpecificationMoiety', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSpecificationMoiety');
  add(value);
end;

function TFhirSubstanceSpecificationMoietyList.Append: TFhirSubstanceSpecificationMoiety;
begin
  result := TFhirSubstanceSpecificationMoiety.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationMoietyList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSpecificationMoietyList.GetEnumerator : TFhirSubstanceSpecificationMoietyListEnumerator;
begin
  result := TFhirSubstanceSpecificationMoietyListEnumerator.Create(self.link);
end;

function TFhirSubstanceSpecificationMoietyList.Clone: TFhirSubstanceSpecificationMoietyList;
begin
  result := TFhirSubstanceSpecificationMoietyList(inherited Clone);
end;

function TFhirSubstanceSpecificationMoietyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSpecificationMoietyList.GetItemN(index: Integer): TFhirSubstanceSpecificationMoiety;
begin
  result := TFhirSubstanceSpecificationMoiety(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationMoietyList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSpecificationMoiety;
end;
function TFhirSubstanceSpecificationMoietyList.IndexOf(value: TFhirSubstanceSpecificationMoiety): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSpecificationMoietyList.Insert(index: Integer): TFhirSubstanceSpecificationMoiety;
begin
  result := TFhirSubstanceSpecificationMoiety.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationMoietyList.InsertItem(index: Integer; value: TFhirSubstanceSpecificationMoiety);
begin
  assert(value is TFhirSubstanceSpecificationMoiety);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSpecificationMoietyList.Item(index: Integer): TFhirSubstanceSpecificationMoiety;
begin
  result := TFhirSubstanceSpecificationMoiety(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationMoietyList.Link: TFhirSubstanceSpecificationMoietyList;
begin
  result := TFhirSubstanceSpecificationMoietyList(inherited Link);
end;

procedure TFhirSubstanceSpecificationMoietyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSpecificationMoietyList.SetItemByIndex(index: Integer; value: TFhirSubstanceSpecificationMoiety);
begin
  assert(value is TFhirSubstanceSpecificationMoiety);
  FhirSubstanceSpecificationMoieties[index] := value;
end;

procedure TFhirSubstanceSpecificationMoietyList.SetItemN(index: Integer; value: TFhirSubstanceSpecificationMoiety);
begin
  assert(value is TFhirSubstanceSpecificationMoiety);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSpecificationProperty }

constructor TFhirSubstanceSpecificationProperty.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSpecificationProperty.Destroy;
begin
  FCategory.free;
  FCode.free;
  FParameters.free;
  FDefiningSubstance.free;
  FAmount.free;
  inherited;
end;

procedure TFhirSubstanceSpecificationProperty.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirSubstanceSpecificationProperty(oSource).category.Clone;
  code := TFhirSubstanceSpecificationProperty(oSource).code.Clone;
  parametersElement := TFhirSubstanceSpecificationProperty(oSource).parametersElement.Clone;
  definingSubstance := TFhirSubstanceSpecificationProperty(oSource).definingSubstance.Clone;
  amount := TFhirSubstanceSpecificationProperty(oSource).amount.Clone;
end;

procedure TFhirSubstanceSpecificationProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'parameters') Then
     list.add(self.link, 'parameters', FParameters.Link);
  if (child_name = 'definingSubstance[x]') or (child_name = 'definingSubstance') Then
     list.add(self.link, 'definingSubstance[x]', FDefiningSubstance.Link);
  if (child_name = 'amount[x]') or (child_name = 'amount') Then
     list.add(self.link, 'amount[x]', FAmount.Link);
end;

procedure TFhirSubstanceSpecificationProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parameters', 'string', false, TFhirString, FParameters.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definingSubstance[x]', 'Reference(SubstanceSpecification)|CodeableConcept', false, TFhirType, FDefiningSubstance.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount[x]', 'Quantity|string', false, TFhirType, FAmount.Link));{2}
end;

function TFhirSubstanceSpecificationProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'parameters') then
  begin
    ParametersElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'definingSubstance', ['Reference', 'CodeableConcept'])) then
  begin
    DefiningSubstance := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then
  begin
    Amount := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSpecificationProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSpecificationProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'parameters') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'definingSubstance', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property DefiningSubstance'){4x}
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then raise EFHIRException.create('Cannot make property Amount'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSpecificationProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'parameters') then result := 'string'
  else if (propName = 'definingSubstance[x]') then result := 'Reference|CodeableConcept'
  else if (propName = 'amount[x]') then result := 'Quantity|string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSpecificationProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'parameters') then ParametersElement := nil
  else if (isMatchingName(propName, 'definingSubstance', ['Reference', 'CodeableConcept'])) then DefiningSubstanceElement := nil{4x}
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then AmountElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSpecificationProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'parameters') then ParametersElement := asString(new){5b}
  else if (isMatchingName(propName, 'definingSubstance', ['Reference', 'CodeableConcept'])) then DefiningSubstanceElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then AmountElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSpecificationProperty.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSpecificationProperty.fhirType : string;
begin
  result := 'property';
end;

function TFhirSubstanceSpecificationProperty.Link : TFhirSubstanceSpecificationProperty;
begin
  result := TFhirSubstanceSpecificationProperty(inherited Link);
end;

function TFhirSubstanceSpecificationProperty.Clone : TFhirSubstanceSpecificationProperty;
begin
  result := TFhirSubstanceSpecificationProperty(inherited Clone);
end;

function TFhirSubstanceSpecificationProperty.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSpecificationProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSpecificationProperty)) then
    result := false
  else
  begin
    o := TFhirSubstanceSpecificationProperty(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(parametersElement, o.parametersElement, true) and compareDeep(definingSubstanceElement, o.definingSubstanceElement, true) and 
      compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirSubstanceSpecificationProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FCode) and isEmptyProp(FParameters) and isEmptyProp(FDefiningSubstance) and isEmptyProp(FAmount);
end;

procedure TFhirSubstanceSpecificationProperty.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('code');
  fields.add('parameters');
  fields.add('definingSubstance[x]');
  fields.add('amount[x]');
end;

{ TFhirSubstanceSpecificationProperty }

Procedure TFhirSubstanceSpecificationProperty.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirSubstanceSpecificationProperty.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirSubstanceSpecificationProperty.SetParameters(value : TFhirString);
begin
  FParameters.free;
  FParameters := value;
end;

Function TFhirSubstanceSpecificationProperty.GetParametersST : String;
begin
  if FParameters = nil then
    result := ''
  else
    result := FParameters.value;
end;

Procedure TFhirSubstanceSpecificationProperty.SetParametersST(value : String);
begin
  if value <> '' then
  begin
    if FParameters = nil then
      FParameters := TFhirString.create;
    FParameters.value := value
  end
  else if FParameters <> nil then
    FParameters.value := '';
end;

Procedure TFhirSubstanceSpecificationProperty.SetDefiningSubstance(value : TFhirType);
begin
  FDefiningSubstance.free;
  FDefiningSubstance := value;
end;

Procedure TFhirSubstanceSpecificationProperty.SetAmount(value : TFhirType);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirSubstanceSpecificationProperty.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FParameters.sizeInBytes);
  inc(result, FDefiningSubstance.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirSubstanceSpecificationPropertyListEnumerator }

Constructor TFhirSubstanceSpecificationPropertyListEnumerator.Create(list : TFhirSubstanceSpecificationPropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSpecificationPropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSpecificationPropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSpecificationPropertyListEnumerator.GetCurrent : TFhirSubstanceSpecificationProperty;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSpecificationPropertyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSpecificationPropertyList }
procedure TFhirSubstanceSpecificationPropertyList.AddItem(value: TFhirSubstanceSpecificationProperty);
begin
  assert(value.ClassName = 'TFhirSubstanceSpecificationProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSpecificationProperty');
  add(value);
end;

function TFhirSubstanceSpecificationPropertyList.Append: TFhirSubstanceSpecificationProperty;
begin
  result := TFhirSubstanceSpecificationProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationPropertyList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSpecificationPropertyList.GetEnumerator : TFhirSubstanceSpecificationPropertyListEnumerator;
begin
  result := TFhirSubstanceSpecificationPropertyListEnumerator.Create(self.link);
end;

function TFhirSubstanceSpecificationPropertyList.Clone: TFhirSubstanceSpecificationPropertyList;
begin
  result := TFhirSubstanceSpecificationPropertyList(inherited Clone);
end;

function TFhirSubstanceSpecificationPropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSpecificationPropertyList.GetItemN(index: Integer): TFhirSubstanceSpecificationProperty;
begin
  result := TFhirSubstanceSpecificationProperty(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationPropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSpecificationProperty;
end;
function TFhirSubstanceSpecificationPropertyList.IndexOf(value: TFhirSubstanceSpecificationProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSpecificationPropertyList.Insert(index: Integer): TFhirSubstanceSpecificationProperty;
begin
  result := TFhirSubstanceSpecificationProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationPropertyList.InsertItem(index: Integer; value: TFhirSubstanceSpecificationProperty);
begin
  assert(value is TFhirSubstanceSpecificationProperty);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSpecificationPropertyList.Item(index: Integer): TFhirSubstanceSpecificationProperty;
begin
  result := TFhirSubstanceSpecificationProperty(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationPropertyList.Link: TFhirSubstanceSpecificationPropertyList;
begin
  result := TFhirSubstanceSpecificationPropertyList(inherited Link);
end;

procedure TFhirSubstanceSpecificationPropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSpecificationPropertyList.SetItemByIndex(index: Integer; value: TFhirSubstanceSpecificationProperty);
begin
  assert(value is TFhirSubstanceSpecificationProperty);
  FhirSubstanceSpecificationProperties[index] := value;
end;

procedure TFhirSubstanceSpecificationPropertyList.SetItemN(index: Integer; value: TFhirSubstanceSpecificationProperty);
begin
  assert(value is TFhirSubstanceSpecificationProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSpecificationStructure }

constructor TFhirSubstanceSpecificationStructure.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSpecificationStructure.Destroy;
begin
  FStereochemistry.free;
  FOpticalActivity.free;
  FMolecularFormula.free;
  FMolecularFormulaByMoiety.free;
  FIsotopeList.Free;
  FMolecularWeight.free;
  FSourceList.Free;
  FRepresentationList.Free;
  inherited;
end;

procedure TFhirSubstanceSpecificationStructure.Assign(oSource : TFslObject);
begin
  inherited;
  stereochemistry := TFhirSubstanceSpecificationStructure(oSource).stereochemistry.Clone;
  opticalActivity := TFhirSubstanceSpecificationStructure(oSource).opticalActivity.Clone;
  molecularFormulaElement := TFhirSubstanceSpecificationStructure(oSource).molecularFormulaElement.Clone;
  molecularFormulaByMoietyElement := TFhirSubstanceSpecificationStructure(oSource).molecularFormulaByMoietyElement.Clone;
  if (TFhirSubstanceSpecificationStructure(oSource).FIsotopeList = nil) then
  begin
    FIsotopeList.free;
    FIsotopeList := nil;
  end
  else
  begin
    if FIsotopeList = nil then
      FIsotopeList := TFhirSubstanceSpecificationStructureIsotopeList.Create;
    FIsotopeList.Assign(TFhirSubstanceSpecificationStructure(oSource).FIsotopeList);
  end;
  molecularWeight := TFhirSubstanceSpecificationStructure(oSource).molecularWeight.Clone;
  if (TFhirSubstanceSpecificationStructure(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList{TFhirDocumentReference}.Create;
    FSourceList.Assign(TFhirSubstanceSpecificationStructure(oSource).FSourceList);
  end;
  if (TFhirSubstanceSpecificationStructure(oSource).FRepresentationList = nil) then
  begin
    FRepresentationList.free;
    FRepresentationList := nil;
  end
  else
  begin
    if FRepresentationList = nil then
      FRepresentationList := TFhirSubstanceSpecificationStructureRepresentationList.Create;
    FRepresentationList.Assign(TFhirSubstanceSpecificationStructure(oSource).FRepresentationList);
  end;
end;

procedure TFhirSubstanceSpecificationStructure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'stereochemistry') Then
     list.add(self.link, 'stereochemistry', FStereochemistry.Link);
  if (child_name = 'opticalActivity') Then
     list.add(self.link, 'opticalActivity', FOpticalActivity.Link);
  if (child_name = 'molecularFormula') Then
     list.add(self.link, 'molecularFormula', FMolecularFormula.Link);
  if (child_name = 'molecularFormulaByMoiety') Then
     list.add(self.link, 'molecularFormulaByMoiety', FMolecularFormulaByMoiety.Link);
  if (child_name = 'isotope') Then
    list.addAll(self, 'isotope', FIsotopeList);
  if (child_name = 'molecularWeight') Then
     list.add(self.link, 'molecularWeight', FMolecularWeight.Link);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
  if (child_name = 'representation') Then
    list.addAll(self, 'representation', FRepresentationList);
end;

procedure TFhirSubstanceSpecificationStructure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'stereochemistry', 'CodeableConcept', false, TFhirCodeableConcept, FStereochemistry.Link));{2}
  oList.add(TFHIRProperty.create(self, 'opticalActivity', 'CodeableConcept', false, TFhirCodeableConcept, FOpticalActivity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'molecularFormula', 'string', false, TFhirString, FMolecularFormula.Link));{2}
  oList.add(TFHIRProperty.create(self, 'molecularFormulaByMoiety', 'string', false, TFhirString, FMolecularFormulaByMoiety.Link));{2}
  oList.add(TFHIRProperty.create(self, 'isotope', '', true, TFhirSubstanceSpecificationStructureIsotope, FIsotopeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'molecularWeight', '@SubstanceSpecification.structure.isotope.molecularWeight', false, TFhirSubstanceSpecificationStructureIsotopeMolecularWeight, FMolecularWeight.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference(DocumentReference)', true, TFhirReference{TFhirDocumentReference}, FSourceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'representation', '', true, TFhirSubstanceSpecificationStructureRepresentation, FRepresentationList.Link)){3};
end;

function TFhirSubstanceSpecificationStructure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'stereochemistry') then
  begin
    Stereochemistry := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'opticalActivity') then
  begin
    OpticalActivity := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'molecularFormula') then
  begin
    MolecularFormulaElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'molecularFormulaByMoiety') then
  begin
    MolecularFormulaByMoietyElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'isotope') then
  begin
    IsotopeList.add(propValue as TFhirSubstanceSpecificationStructureIsotope){2a};
    result := propValue;
  end
  else if (propName = 'molecularWeight') then
  begin
    MolecularWeight := propValue as TFhirSubstanceSpecificationStructureIsotopeMolecularWeight{4b};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference{TFhirDocumentReference}){2a};
    result := propValue;
  end
  else if (propName = 'representation') then
  begin
    RepresentationList.add(propValue as TFhirSubstanceSpecificationStructureRepresentation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSpecificationStructure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'isotope') then IsotopeList.insertItem(index, propValue as TFhirSubstanceSpecificationStructureIsotope){2a}
  else if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference{TFhirDocumentReference}){2a}
  else if (propName = 'representation') then RepresentationList.insertItem(index, propValue as TFhirSubstanceSpecificationStructureRepresentation){2a}
  else inherited;
end;

function TFhirSubstanceSpecificationStructure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'stereochemistry') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'opticalActivity') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'molecularFormula') then result := TFhirString.create() {5b}
  else if (propName = 'molecularFormulaByMoiety') then result := TFhirString.create() {5b}
  else if (propName = 'isotope') then result := IsotopeList.new(){2}
  else if (propName = 'molecularWeight') then result := TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.create(){4b}
  else if (propName = 'source') then result := SourceList.new(){2}
  else if (propName = 'representation') then result := RepresentationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSpecificationStructure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'stereochemistry') then result := 'CodeableConcept'
  else if (propName = 'opticalActivity') then result := 'CodeableConcept'
  else if (propName = 'molecularFormula') then result := 'string'
  else if (propName = 'molecularFormulaByMoiety') then result := 'string'
  else if (propName = 'isotope') then result := ''
  else if (propName = 'molecularWeight') then result := '@SubstanceSpecification.structure.isotope.molecularWeight'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'representation') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSpecificationStructure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'stereochemistry') then StereochemistryElement := nil
  else if (propName = 'opticalActivity') then OpticalActivityElement := nil
  else if (propName = 'molecularFormula') then MolecularFormulaElement := nil
  else if (propName = 'molecularFormulaByMoiety') then MolecularFormulaByMoietyElement := nil
  else if (propName = 'isotope') then deletePropertyValue('isotope', IsotopeList, value) {2}
  else if (propName = 'molecularWeight') then MolecularWeightElement := nil
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value) {2}
  else if (propName = 'representation') then deletePropertyValue('representation', RepresentationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSpecificationStructure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'stereochemistry') then StereochemistryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'opticalActivity') then OpticalActivityElement := new as TFhirCodeableConcept{4}
  else if (propName = 'molecularFormula') then MolecularFormulaElement := asString(new){5b}
  else if (propName = 'molecularFormulaByMoiety') then MolecularFormulaByMoietyElement := asString(new){5b}
  else if (propName = 'isotope') then replacePropertyValue('isotope', IsotopeList, existing, new) {2}
  else if (propName = 'molecularWeight') then MolecularWeightElement := new as TFhirSubstanceSpecificationStructureIsotopeMolecularWeight{4}
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new) {2}
  else if (propName = 'representation') then replacePropertyValue('representation', RepresentationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSpecificationStructure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'isotope') then IsotopeList.move(source, destination){2a}
  else if (propName = 'source') then SourceList.move(source, destination){2a}
  else if (propName = 'representation') then RepresentationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSpecificationStructure.fhirType : string;
begin
  result := 'structure';
end;

function TFhirSubstanceSpecificationStructure.Link : TFhirSubstanceSpecificationStructure;
begin
  result := TFhirSubstanceSpecificationStructure(inherited Link);
end;

function TFhirSubstanceSpecificationStructure.Clone : TFhirSubstanceSpecificationStructure;
begin
  result := TFhirSubstanceSpecificationStructure(inherited Clone);
end;

function TFhirSubstanceSpecificationStructure.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSpecificationStructure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSpecificationStructure)) then
    result := false
  else
  begin
    o := TFhirSubstanceSpecificationStructure(other);
    result := compareDeep(stereochemistryElement, o.stereochemistryElement, true) and 
      compareDeep(opticalActivityElement, o.opticalActivityElement, true) and compareDeep(molecularFormulaElement, o.molecularFormulaElement, true) and 
      compareDeep(molecularFormulaByMoietyElement, o.molecularFormulaByMoietyElement, true) and 
      compareDeep(isotopeList, o.isotopeList, true) and compareDeep(molecularWeightElement, o.molecularWeightElement, true) and 
      compareDeep(sourceList, o.sourceList, true) and compareDeep(representationList, o.representationList, true);
  end;
end;

function TFhirSubstanceSpecificationStructure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStereochemistry) and isEmptyProp(FOpticalActivity) and isEmptyProp(FMolecularFormula) and isEmptyProp(FMolecularFormulaByMoiety) and isEmptyProp(FisotopeList) and isEmptyProp(FMolecularWeight) and isEmptyProp(FsourceList) and isEmptyProp(FrepresentationList);
end;

procedure TFhirSubstanceSpecificationStructure.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('stereochemistry');
  fields.add('opticalActivity');
  fields.add('molecularFormula');
  fields.add('molecularFormulaByMoiety');
  fields.add('isotope');
  fields.add('molecularWeight');
  fields.add('source');
  fields.add('representation');
end;

{ TFhirSubstanceSpecificationStructure }

Procedure TFhirSubstanceSpecificationStructure.SetStereochemistry(value : TFhirCodeableConcept);
begin
  FStereochemistry.free;
  FStereochemistry := value;
end;

Procedure TFhirSubstanceSpecificationStructure.SetOpticalActivity(value : TFhirCodeableConcept);
begin
  FOpticalActivity.free;
  FOpticalActivity := value;
end;

Procedure TFhirSubstanceSpecificationStructure.SetMolecularFormula(value : TFhirString);
begin
  FMolecularFormula.free;
  FMolecularFormula := value;
end;

Function TFhirSubstanceSpecificationStructure.GetMolecularFormulaST : String;
begin
  if FMolecularFormula = nil then
    result := ''
  else
    result := FMolecularFormula.value;
end;

Procedure TFhirSubstanceSpecificationStructure.SetMolecularFormulaST(value : String);
begin
  if value <> '' then
  begin
    if FMolecularFormula = nil then
      FMolecularFormula := TFhirString.create;
    FMolecularFormula.value := value
  end
  else if FMolecularFormula <> nil then
    FMolecularFormula.value := '';
end;

Procedure TFhirSubstanceSpecificationStructure.SetMolecularFormulaByMoiety(value : TFhirString);
begin
  FMolecularFormulaByMoiety.free;
  FMolecularFormulaByMoiety := value;
end;

Function TFhirSubstanceSpecificationStructure.GetMolecularFormulaByMoietyST : String;
begin
  if FMolecularFormulaByMoiety = nil then
    result := ''
  else
    result := FMolecularFormulaByMoiety.value;
end;

Procedure TFhirSubstanceSpecificationStructure.SetMolecularFormulaByMoietyST(value : String);
begin
  if value <> '' then
  begin
    if FMolecularFormulaByMoiety = nil then
      FMolecularFormulaByMoiety := TFhirString.create;
    FMolecularFormulaByMoiety.value := value
  end
  else if FMolecularFormulaByMoiety <> nil then
    FMolecularFormulaByMoiety.value := '';
end;

Function TFhirSubstanceSpecificationStructure.GetIsotopeList : TFhirSubstanceSpecificationStructureIsotopeList;
begin
  if FIsotopeList = nil then
    FIsotopeList := TFhirSubstanceSpecificationStructureIsotopeList.Create;
  result := FIsotopeList;
end;

Function TFhirSubstanceSpecificationStructure.GetHasIsotopeList : boolean;
begin
  result := (FIsotopeList <> nil) and (FIsotopeList.count > 0);
end;

Procedure TFhirSubstanceSpecificationStructure.SetMolecularWeight(value : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight);
begin
  FMolecularWeight.free;
  FMolecularWeight := value;
end;

Function TFhirSubstanceSpecificationStructure.GetSourceList : TFhirReferenceList{TFhirDocumentReference};
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList{TFhirDocumentReference}.Create;
  result := FSourceList;
end;

Function TFhirSubstanceSpecificationStructure.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

Function TFhirSubstanceSpecificationStructure.GetRepresentationList : TFhirSubstanceSpecificationStructureRepresentationList;
begin
  if FRepresentationList = nil then
    FRepresentationList := TFhirSubstanceSpecificationStructureRepresentationList.Create;
  result := FRepresentationList;
end;

Function TFhirSubstanceSpecificationStructure.GetHasRepresentationList : boolean;
begin
  result := (FRepresentationList <> nil) and (FRepresentationList.count > 0);
end;

function TFhirSubstanceSpecificationStructure.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStereochemistry.sizeInBytes);
  inc(result, FOpticalActivity.sizeInBytes);
  inc(result, FMolecularFormula.sizeInBytes);
  inc(result, FMolecularFormulaByMoiety.sizeInBytes);
  inc(result, FisotopeList.sizeInBytes);
  inc(result, FMolecularWeight.sizeInBytes);
  inc(result, FsourceList.sizeInBytes);
  inc(result, FrepresentationList.sizeInBytes);
end;

{ TFhirSubstanceSpecificationStructureListEnumerator }

Constructor TFhirSubstanceSpecificationStructureListEnumerator.Create(list : TFhirSubstanceSpecificationStructureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSpecificationStructureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSpecificationStructureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSpecificationStructureListEnumerator.GetCurrent : TFhirSubstanceSpecificationStructure;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSpecificationStructureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSpecificationStructureList }
procedure TFhirSubstanceSpecificationStructureList.AddItem(value: TFhirSubstanceSpecificationStructure);
begin
  assert(value.ClassName = 'TFhirSubstanceSpecificationStructure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSpecificationStructure');
  add(value);
end;

function TFhirSubstanceSpecificationStructureList.Append: TFhirSubstanceSpecificationStructure;
begin
  result := TFhirSubstanceSpecificationStructure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationStructureList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSpecificationStructureList.GetEnumerator : TFhirSubstanceSpecificationStructureListEnumerator;
begin
  result := TFhirSubstanceSpecificationStructureListEnumerator.Create(self.link);
end;

function TFhirSubstanceSpecificationStructureList.Clone: TFhirSubstanceSpecificationStructureList;
begin
  result := TFhirSubstanceSpecificationStructureList(inherited Clone);
end;

function TFhirSubstanceSpecificationStructureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSpecificationStructureList.GetItemN(index: Integer): TFhirSubstanceSpecificationStructure;
begin
  result := TFhirSubstanceSpecificationStructure(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationStructureList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSpecificationStructure;
end;
function TFhirSubstanceSpecificationStructureList.IndexOf(value: TFhirSubstanceSpecificationStructure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSpecificationStructureList.Insert(index: Integer): TFhirSubstanceSpecificationStructure;
begin
  result := TFhirSubstanceSpecificationStructure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationStructureList.InsertItem(index: Integer; value: TFhirSubstanceSpecificationStructure);
begin
  assert(value is TFhirSubstanceSpecificationStructure);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSpecificationStructureList.Item(index: Integer): TFhirSubstanceSpecificationStructure;
begin
  result := TFhirSubstanceSpecificationStructure(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationStructureList.Link: TFhirSubstanceSpecificationStructureList;
begin
  result := TFhirSubstanceSpecificationStructureList(inherited Link);
end;

procedure TFhirSubstanceSpecificationStructureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSpecificationStructureList.SetItemByIndex(index: Integer; value: TFhirSubstanceSpecificationStructure);
begin
  assert(value is TFhirSubstanceSpecificationStructure);
  FhirSubstanceSpecificationStructures[index] := value;
end;

procedure TFhirSubstanceSpecificationStructureList.SetItemN(index: Integer; value: TFhirSubstanceSpecificationStructure);
begin
  assert(value is TFhirSubstanceSpecificationStructure);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSpecificationStructureIsotope }

constructor TFhirSubstanceSpecificationStructureIsotope.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSpecificationStructureIsotope.Destroy;
begin
  FIdentifier.free;
  FName.free;
  FSubstitution.free;
  FHalfLife.free;
  FMolecularWeight.free;
  inherited;
end;

procedure TFhirSubstanceSpecificationStructureIsotope.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirSubstanceSpecificationStructureIsotope(oSource).identifier.Clone;
  name := TFhirSubstanceSpecificationStructureIsotope(oSource).name.Clone;
  substitution := TFhirSubstanceSpecificationStructureIsotope(oSource).substitution.Clone;
  halfLife := TFhirSubstanceSpecificationStructureIsotope(oSource).halfLife.Clone;
  molecularWeight := TFhirSubstanceSpecificationStructureIsotope(oSource).molecularWeight.Clone;
end;

procedure TFhirSubstanceSpecificationStructureIsotope.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'substitution') Then
     list.add(self.link, 'substitution', FSubstitution.Link);
  if (child_name = 'halfLife') Then
     list.add(self.link, 'halfLife', FHalfLife.Link);
  if (child_name = 'molecularWeight') Then
     list.add(self.link, 'molecularWeight', FMolecularWeight.Link);
end;

procedure TFhirSubstanceSpecificationStructureIsotope.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'CodeableConcept', false, TFhirCodeableConcept, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'substitution', 'CodeableConcept', false, TFhirCodeableConcept, FSubstitution.Link));{2}
  oList.add(TFHIRProperty.create(self, 'halfLife', 'Quantity', false, TFhirQuantity, FHalfLife.Link));{2}
  oList.add(TFHIRProperty.create(self, 'molecularWeight', '', false, TFhirSubstanceSpecificationStructureIsotopeMolecularWeight, FMolecularWeight.Link));{2}
end;

function TFhirSubstanceSpecificationStructureIsotope.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    Name := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'substitution') then
  begin
    Substitution := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'halfLife') then
  begin
    HalfLife := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'molecularWeight') then
  begin
    MolecularWeight := propValue as TFhirSubstanceSpecificationStructureIsotopeMolecularWeight{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSpecificationStructureIsotope.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSpecificationStructureIsotope.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'name') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'substitution') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'halfLife') then result := TFhirQuantity.create(){4b}
  else if (propName = 'molecularWeight') then result := TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSpecificationStructureIsotope.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'CodeableConcept'
  else if (propName = 'substitution') then result := 'CodeableConcept'
  else if (propName = 'halfLife') then result := 'Quantity'
  else if (propName = 'molecularWeight') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSpecificationStructureIsotope.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'substitution') then SubstitutionElement := nil
  else if (propName = 'halfLife') then HalfLifeElement := nil
  else if (propName = 'molecularWeight') then MolecularWeightElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSpecificationStructureIsotope.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'name') then NameElement := new as TFhirCodeableConcept{4}
  else if (propName = 'substitution') then SubstitutionElement := new as TFhirCodeableConcept{4}
  else if (propName = 'halfLife') then HalfLifeElement := new as TFhirQuantity{4}
  else if (propName = 'molecularWeight') then MolecularWeightElement := new as TFhirSubstanceSpecificationStructureIsotopeMolecularWeight{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSpecificationStructureIsotope.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSpecificationStructureIsotope.fhirType : string;
begin
  result := 'isotope';
end;

function TFhirSubstanceSpecificationStructureIsotope.Link : TFhirSubstanceSpecificationStructureIsotope;
begin
  result := TFhirSubstanceSpecificationStructureIsotope(inherited Link);
end;

function TFhirSubstanceSpecificationStructureIsotope.Clone : TFhirSubstanceSpecificationStructureIsotope;
begin
  result := TFhirSubstanceSpecificationStructureIsotope(inherited Clone);
end;

function TFhirSubstanceSpecificationStructureIsotope.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSpecificationStructureIsotope;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSpecificationStructureIsotope)) then
    result := false
  else
  begin
    o := TFhirSubstanceSpecificationStructureIsotope(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(substitutionElement, o.substitutionElement, true) and compareDeep(halfLifeElement, o.halfLifeElement, true) and 
      compareDeep(molecularWeightElement, o.molecularWeightElement, true);
  end;
end;

function TFhirSubstanceSpecificationStructureIsotope.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FName) and isEmptyProp(FSubstitution) and isEmptyProp(FHalfLife) and isEmptyProp(FMolecularWeight);
end;

procedure TFhirSubstanceSpecificationStructureIsotope.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('name');
  fields.add('substitution');
  fields.add('halfLife');
  fields.add('molecularWeight');
end;

{ TFhirSubstanceSpecificationStructureIsotope }

Procedure TFhirSubstanceSpecificationStructureIsotope.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirSubstanceSpecificationStructureIsotope.SetName(value : TFhirCodeableConcept);
begin
  FName.free;
  FName := value;
end;

Procedure TFhirSubstanceSpecificationStructureIsotope.SetSubstitution(value : TFhirCodeableConcept);
begin
  FSubstitution.free;
  FSubstitution := value;
end;

Procedure TFhirSubstanceSpecificationStructureIsotope.SetHalfLife(value : TFhirQuantity);
begin
  FHalfLife.free;
  FHalfLife := value;
end;

Procedure TFhirSubstanceSpecificationStructureIsotope.SetMolecularWeight(value : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight);
begin
  FMolecularWeight.free;
  FMolecularWeight := value;
end;

function TFhirSubstanceSpecificationStructureIsotope.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FSubstitution.sizeInBytes);
  inc(result, FHalfLife.sizeInBytes);
  inc(result, FMolecularWeight.sizeInBytes);
end;

{ TFhirSubstanceSpecificationStructureIsotopeListEnumerator }

Constructor TFhirSubstanceSpecificationStructureIsotopeListEnumerator.Create(list : TFhirSubstanceSpecificationStructureIsotopeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSpecificationStructureIsotopeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSpecificationStructureIsotopeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSpecificationStructureIsotopeListEnumerator.GetCurrent : TFhirSubstanceSpecificationStructureIsotope;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSpecificationStructureIsotopeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSpecificationStructureIsotopeList }
procedure TFhirSubstanceSpecificationStructureIsotopeList.AddItem(value: TFhirSubstanceSpecificationStructureIsotope);
begin
  assert(value.ClassName = 'TFhirSubstanceSpecificationStructureIsotope', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSpecificationStructureIsotope');
  add(value);
end;

function TFhirSubstanceSpecificationStructureIsotopeList.Append: TFhirSubstanceSpecificationStructureIsotope;
begin
  result := TFhirSubstanceSpecificationStructureIsotope.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationStructureIsotopeList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSpecificationStructureIsotopeList.GetEnumerator : TFhirSubstanceSpecificationStructureIsotopeListEnumerator;
begin
  result := TFhirSubstanceSpecificationStructureIsotopeListEnumerator.Create(self.link);
end;

function TFhirSubstanceSpecificationStructureIsotopeList.Clone: TFhirSubstanceSpecificationStructureIsotopeList;
begin
  result := TFhirSubstanceSpecificationStructureIsotopeList(inherited Clone);
end;

function TFhirSubstanceSpecificationStructureIsotopeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSpecificationStructureIsotopeList.GetItemN(index: Integer): TFhirSubstanceSpecificationStructureIsotope;
begin
  result := TFhirSubstanceSpecificationStructureIsotope(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationStructureIsotopeList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSpecificationStructureIsotope;
end;
function TFhirSubstanceSpecificationStructureIsotopeList.IndexOf(value: TFhirSubstanceSpecificationStructureIsotope): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSpecificationStructureIsotopeList.Insert(index: Integer): TFhirSubstanceSpecificationStructureIsotope;
begin
  result := TFhirSubstanceSpecificationStructureIsotope.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationStructureIsotopeList.InsertItem(index: Integer; value: TFhirSubstanceSpecificationStructureIsotope);
begin
  assert(value is TFhirSubstanceSpecificationStructureIsotope);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSpecificationStructureIsotopeList.Item(index: Integer): TFhirSubstanceSpecificationStructureIsotope;
begin
  result := TFhirSubstanceSpecificationStructureIsotope(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationStructureIsotopeList.Link: TFhirSubstanceSpecificationStructureIsotopeList;
begin
  result := TFhirSubstanceSpecificationStructureIsotopeList(inherited Link);
end;

procedure TFhirSubstanceSpecificationStructureIsotopeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSpecificationStructureIsotopeList.SetItemByIndex(index: Integer; value: TFhirSubstanceSpecificationStructureIsotope);
begin
  assert(value is TFhirSubstanceSpecificationStructureIsotope);
  FhirSubstanceSpecificationStructureIsotopes[index] := value;
end;

procedure TFhirSubstanceSpecificationStructureIsotopeList.SetItemN(index: Integer; value: TFhirSubstanceSpecificationStructureIsotope);
begin
  assert(value is TFhirSubstanceSpecificationStructureIsotope);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSpecificationStructureIsotopeMolecularWeight }

constructor TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.Destroy;
begin
  FMethod.free;
  FType_.free;
  FAmount.free;
  inherited;
end;

procedure TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.Assign(oSource : TFslObject);
begin
  inherited;
  method := TFhirSubstanceSpecificationStructureIsotopeMolecularWeight(oSource).method.Clone;
  type_ := TFhirSubstanceSpecificationStructureIsotopeMolecularWeight(oSource).type_.Clone;
  amount := TFhirSubstanceSpecificationStructureIsotopeMolecularWeight(oSource).amount.Clone;
end;

procedure TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link));{2}
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'method') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'amount') then result := TFhirQuantity.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'method') then MethodElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'method') then MethodElement := new as TFhirCodeableConcept{4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.fhirType : string;
begin
  result := 'molecularWeight';
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.Link : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight;
begin
  result := TFhirSubstanceSpecificationStructureIsotopeMolecularWeight(inherited Link);
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.Clone : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight;
begin
  result := TFhirSubstanceSpecificationStructureIsotopeMolecularWeight(inherited Clone);
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSpecificationStructureIsotopeMolecularWeight)) then
    result := false
  else
  begin
    o := TFhirSubstanceSpecificationStructureIsotopeMolecularWeight(other);
    result := compareDeep(methodElement, o.methodElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMethod) and isEmptyProp(FType_) and isEmptyProp(FAmount);
end;

procedure TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('method');
  fields.add('type');
  fields.add('amount');
end;

{ TFhirSubstanceSpecificationStructureIsotopeMolecularWeight }

Procedure TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMethod.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirSubstanceSpecificationStructureIsotopeMolecularWeightListEnumerator }

Constructor TFhirSubstanceSpecificationStructureIsotopeMolecularWeightListEnumerator.Create(list : TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSpecificationStructureIsotopeMolecularWeightListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeightListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeightListEnumerator.GetCurrent : TFhirSubstanceSpecificationStructureIsotopeMolecularWeight;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeightListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList }
procedure TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList.AddItem(value: TFhirSubstanceSpecificationStructureIsotopeMolecularWeight);
begin
  assert(value.ClassName = 'TFhirSubstanceSpecificationStructureIsotopeMolecularWeight', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSpecificationStructureIsotopeMolecularWeight');
  add(value);
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList.Append: TFhirSubstanceSpecificationStructureIsotopeMolecularWeight;
begin
  result := TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList.GetEnumerator : TFhirSubstanceSpecificationStructureIsotopeMolecularWeightListEnumerator;
begin
  result := TFhirSubstanceSpecificationStructureIsotopeMolecularWeightListEnumerator.Create(self.link);
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList.Clone: TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList;
begin
  result := TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList(inherited Clone);
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList.GetItemN(index: Integer): TFhirSubstanceSpecificationStructureIsotopeMolecularWeight;
begin
  result := TFhirSubstanceSpecificationStructureIsotopeMolecularWeight(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSpecificationStructureIsotopeMolecularWeight;
end;
function TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList.IndexOf(value: TFhirSubstanceSpecificationStructureIsotopeMolecularWeight): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList.Insert(index: Integer): TFhirSubstanceSpecificationStructureIsotopeMolecularWeight;
begin
  result := TFhirSubstanceSpecificationStructureIsotopeMolecularWeight.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList.InsertItem(index: Integer; value: TFhirSubstanceSpecificationStructureIsotopeMolecularWeight);
begin
  assert(value is TFhirSubstanceSpecificationStructureIsotopeMolecularWeight);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList.Item(index: Integer): TFhirSubstanceSpecificationStructureIsotopeMolecularWeight;
begin
  result := TFhirSubstanceSpecificationStructureIsotopeMolecularWeight(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList.Link: TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList;
begin
  result := TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList(inherited Link);
end;

procedure TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList.SetItemByIndex(index: Integer; value: TFhirSubstanceSpecificationStructureIsotopeMolecularWeight);
begin
  assert(value is TFhirSubstanceSpecificationStructureIsotopeMolecularWeight);
  FhirSubstanceSpecificationStructureIsotopeMolecularWeights[index] := value;
end;

procedure TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList.SetItemN(index: Integer; value: TFhirSubstanceSpecificationStructureIsotopeMolecularWeight);
begin
  assert(value is TFhirSubstanceSpecificationStructureIsotopeMolecularWeight);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSpecificationStructureRepresentation }

constructor TFhirSubstanceSpecificationStructureRepresentation.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSpecificationStructureRepresentation.Destroy;
begin
  FType_.free;
  FRepresentation.free;
  FAttachment.free;
  inherited;
end;

procedure TFhirSubstanceSpecificationStructureRepresentation.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirSubstanceSpecificationStructureRepresentation(oSource).type_.Clone;
  representationElement := TFhirSubstanceSpecificationStructureRepresentation(oSource).representationElement.Clone;
  attachment := TFhirSubstanceSpecificationStructureRepresentation(oSource).attachment.Clone;
end;

procedure TFhirSubstanceSpecificationStructureRepresentation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'representation') Then
     list.add(self.link, 'representation', FRepresentation.Link);
  if (child_name = 'attachment') Then
     list.add(self.link, 'attachment', FAttachment.Link);
end;

procedure TFhirSubstanceSpecificationStructureRepresentation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'representation', 'string', false, TFhirString, FRepresentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'attachment', 'Attachment', false, TFhirAttachment, FAttachment.Link));{2}
end;

function TFhirSubstanceSpecificationStructureRepresentation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'representation') then
  begin
    RepresentationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'attachment') then
  begin
    Attachment := propValue as TFhirAttachment{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSpecificationStructureRepresentation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSpecificationStructureRepresentation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'representation') then result := TFhirString.create() {5b}
  else if (propName = 'attachment') then result := TFhirAttachment.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSpecificationStructureRepresentation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'representation') then result := 'string'
  else if (propName = 'attachment') then result := 'Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSpecificationStructureRepresentation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'representation') then RepresentationElement := nil
  else if (propName = 'attachment') then AttachmentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSpecificationStructureRepresentation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'representation') then RepresentationElement := asString(new){5b}
  else if (propName = 'attachment') then AttachmentElement := new as TFhirAttachment{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSpecificationStructureRepresentation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSpecificationStructureRepresentation.fhirType : string;
begin
  result := 'representation';
end;

function TFhirSubstanceSpecificationStructureRepresentation.Link : TFhirSubstanceSpecificationStructureRepresentation;
begin
  result := TFhirSubstanceSpecificationStructureRepresentation(inherited Link);
end;

function TFhirSubstanceSpecificationStructureRepresentation.Clone : TFhirSubstanceSpecificationStructureRepresentation;
begin
  result := TFhirSubstanceSpecificationStructureRepresentation(inherited Clone);
end;

function TFhirSubstanceSpecificationStructureRepresentation.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSpecificationStructureRepresentation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSpecificationStructureRepresentation)) then
    result := false
  else
  begin
    o := TFhirSubstanceSpecificationStructureRepresentation(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(representationElement, o.representationElement, true) and 
      compareDeep(attachmentElement, o.attachmentElement, true);
  end;
end;

function TFhirSubstanceSpecificationStructureRepresentation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FRepresentation) and isEmptyProp(FAttachment);
end;

procedure TFhirSubstanceSpecificationStructureRepresentation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('representation');
  fields.add('attachment');
end;

{ TFhirSubstanceSpecificationStructureRepresentation }

Procedure TFhirSubstanceSpecificationStructureRepresentation.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSubstanceSpecificationStructureRepresentation.SetRepresentation(value : TFhirString);
begin
  FRepresentation.free;
  FRepresentation := value;
end;

Function TFhirSubstanceSpecificationStructureRepresentation.GetRepresentationST : String;
begin
  if FRepresentation = nil then
    result := ''
  else
    result := FRepresentation.value;
end;

Procedure TFhirSubstanceSpecificationStructureRepresentation.SetRepresentationST(value : String);
begin
  if value <> '' then
  begin
    if FRepresentation = nil then
      FRepresentation := TFhirString.create;
    FRepresentation.value := value
  end
  else if FRepresentation <> nil then
    FRepresentation.value := '';
end;

Procedure TFhirSubstanceSpecificationStructureRepresentation.SetAttachment(value : TFhirAttachment);
begin
  FAttachment.free;
  FAttachment := value;
end;

function TFhirSubstanceSpecificationStructureRepresentation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FRepresentation.sizeInBytes);
  inc(result, FAttachment.sizeInBytes);
end;

{ TFhirSubstanceSpecificationStructureRepresentationListEnumerator }

Constructor TFhirSubstanceSpecificationStructureRepresentationListEnumerator.Create(list : TFhirSubstanceSpecificationStructureRepresentationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSpecificationStructureRepresentationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSpecificationStructureRepresentationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSpecificationStructureRepresentationListEnumerator.GetCurrent : TFhirSubstanceSpecificationStructureRepresentation;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSpecificationStructureRepresentationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSpecificationStructureRepresentationList }
procedure TFhirSubstanceSpecificationStructureRepresentationList.AddItem(value: TFhirSubstanceSpecificationStructureRepresentation);
begin
  assert(value.ClassName = 'TFhirSubstanceSpecificationStructureRepresentation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSpecificationStructureRepresentation');
  add(value);
end;

function TFhirSubstanceSpecificationStructureRepresentationList.Append: TFhirSubstanceSpecificationStructureRepresentation;
begin
  result := TFhirSubstanceSpecificationStructureRepresentation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationStructureRepresentationList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSpecificationStructureRepresentationList.GetEnumerator : TFhirSubstanceSpecificationStructureRepresentationListEnumerator;
begin
  result := TFhirSubstanceSpecificationStructureRepresentationListEnumerator.Create(self.link);
end;

function TFhirSubstanceSpecificationStructureRepresentationList.Clone: TFhirSubstanceSpecificationStructureRepresentationList;
begin
  result := TFhirSubstanceSpecificationStructureRepresentationList(inherited Clone);
end;

function TFhirSubstanceSpecificationStructureRepresentationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSpecificationStructureRepresentationList.GetItemN(index: Integer): TFhirSubstanceSpecificationStructureRepresentation;
begin
  result := TFhirSubstanceSpecificationStructureRepresentation(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationStructureRepresentationList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSpecificationStructureRepresentation;
end;
function TFhirSubstanceSpecificationStructureRepresentationList.IndexOf(value: TFhirSubstanceSpecificationStructureRepresentation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSpecificationStructureRepresentationList.Insert(index: Integer): TFhirSubstanceSpecificationStructureRepresentation;
begin
  result := TFhirSubstanceSpecificationStructureRepresentation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationStructureRepresentationList.InsertItem(index: Integer; value: TFhirSubstanceSpecificationStructureRepresentation);
begin
  assert(value is TFhirSubstanceSpecificationStructureRepresentation);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSpecificationStructureRepresentationList.Item(index: Integer): TFhirSubstanceSpecificationStructureRepresentation;
begin
  result := TFhirSubstanceSpecificationStructureRepresentation(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationStructureRepresentationList.Link: TFhirSubstanceSpecificationStructureRepresentationList;
begin
  result := TFhirSubstanceSpecificationStructureRepresentationList(inherited Link);
end;

procedure TFhirSubstanceSpecificationStructureRepresentationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSpecificationStructureRepresentationList.SetItemByIndex(index: Integer; value: TFhirSubstanceSpecificationStructureRepresentation);
begin
  assert(value is TFhirSubstanceSpecificationStructureRepresentation);
  FhirSubstanceSpecificationStructureRepresentations[index] := value;
end;

procedure TFhirSubstanceSpecificationStructureRepresentationList.SetItemN(index: Integer; value: TFhirSubstanceSpecificationStructureRepresentation);
begin
  assert(value is TFhirSubstanceSpecificationStructureRepresentation);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSpecificationCode }

constructor TFhirSubstanceSpecificationCode.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSpecificationCode.Destroy;
begin
  FCode.free;
  FStatus.free;
  FStatusDate.free;
  FComment.free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceSpecificationCode.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirSubstanceSpecificationCode(oSource).code.Clone;
  status := TFhirSubstanceSpecificationCode(oSource).status.Clone;
  statusDateElement := TFhirSubstanceSpecificationCode(oSource).statusDateElement.Clone;
  commentElement := TFhirSubstanceSpecificationCode(oSource).commentElement.Clone;
  if (TFhirSubstanceSpecificationCode(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList{TFhirDocumentReference}.Create;
    FSourceList.Assign(TFhirSubstanceSpecificationCode(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceSpecificationCode.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceSpecificationCode.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'statusDate', 'dateTime', false, TFhirDateTime, FStatusDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference(DocumentReference)', true, TFhirReference{TFhirDocumentReference}, FSourceList.Link)){3};
end;

function TFhirSubstanceSpecificationCode.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference{TFhirDocumentReference}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSpecificationCode.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference{TFhirDocumentReference}){2a}
  else inherited;
end;

function TFhirSubstanceSpecificationCode.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'status') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'statusDate') then result := TFhirDateTime.create() {5b}
  else if (propName = 'comment') then result := TFhirString.create() {5b}
  else if (propName = 'source') then result := SourceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSpecificationCode.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'statusDate') then result := 'dateTime'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSpecificationCode.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSpecificationCode.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept{4}
  else if (propName = 'statusDate') then StatusDateElement := asDateTime(new){5b}
  else if (propName = 'comment') then CommentElement := asString(new){5b}
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSpecificationCode.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'source') then SourceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSpecificationCode.fhirType : string;
begin
  result := 'code';
end;

function TFhirSubstanceSpecificationCode.Link : TFhirSubstanceSpecificationCode;
begin
  result := TFhirSubstanceSpecificationCode(inherited Link);
end;

function TFhirSubstanceSpecificationCode.Clone : TFhirSubstanceSpecificationCode;
begin
  result := TFhirSubstanceSpecificationCode(inherited Clone);
end;

function TFhirSubstanceSpecificationCode.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSpecificationCode;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSpecificationCode)) then
    result := false
  else
  begin
    o := TFhirSubstanceSpecificationCode(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusDateElement, o.statusDateElement, true) and compareDeep(commentElement, o.commentElement, true) and 
      compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceSpecificationCode.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FStatus) and isEmptyProp(FStatusDate) and isEmptyProp(FComment) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceSpecificationCode.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('status');
  fields.add('statusDate');
  fields.add('comment');
  fields.add('source');
end;

{ TFhirSubstanceSpecificationCode }

Procedure TFhirSubstanceSpecificationCode.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirSubstanceSpecificationCode.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

Procedure TFhirSubstanceSpecificationCode.SetStatusDate(value : TFhirDateTime);
begin
  FStatusDate.free;
  FStatusDate := value;
end;

Function TFhirSubstanceSpecificationCode.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

Procedure TFhirSubstanceSpecificationCode.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDateTime.create;
  FStatusDate.value := value
end;

Procedure TFhirSubstanceSpecificationCode.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirSubstanceSpecificationCode.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirSubstanceSpecificationCode.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

Function TFhirSubstanceSpecificationCode.GetSourceList : TFhirReferenceList{TFhirDocumentReference};
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList{TFhirDocumentReference}.Create;
  result := FSourceList;
end;

Function TFhirSubstanceSpecificationCode.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

function TFhirSubstanceSpecificationCode.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStatusDate.sizeInBytes);
  inc(result, FComment.sizeInBytes);
  inc(result, FsourceList.sizeInBytes);
end;

{ TFhirSubstanceSpecificationCodeListEnumerator }

Constructor TFhirSubstanceSpecificationCodeListEnumerator.Create(list : TFhirSubstanceSpecificationCodeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSpecificationCodeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSpecificationCodeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSpecificationCodeListEnumerator.GetCurrent : TFhirSubstanceSpecificationCode;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSpecificationCodeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSpecificationCodeList }
procedure TFhirSubstanceSpecificationCodeList.AddItem(value: TFhirSubstanceSpecificationCode);
begin
  assert(value.ClassName = 'TFhirSubstanceSpecificationCode', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSpecificationCode');
  add(value);
end;

function TFhirSubstanceSpecificationCodeList.Append: TFhirSubstanceSpecificationCode;
begin
  result := TFhirSubstanceSpecificationCode.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationCodeList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSpecificationCodeList.GetEnumerator : TFhirSubstanceSpecificationCodeListEnumerator;
begin
  result := TFhirSubstanceSpecificationCodeListEnumerator.Create(self.link);
end;

function TFhirSubstanceSpecificationCodeList.Clone: TFhirSubstanceSpecificationCodeList;
begin
  result := TFhirSubstanceSpecificationCodeList(inherited Clone);
end;

function TFhirSubstanceSpecificationCodeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSpecificationCodeList.GetItemN(index: Integer): TFhirSubstanceSpecificationCode;
begin
  result := TFhirSubstanceSpecificationCode(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationCodeList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSpecificationCode;
end;
function TFhirSubstanceSpecificationCodeList.IndexOf(value: TFhirSubstanceSpecificationCode): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSpecificationCodeList.Insert(index: Integer): TFhirSubstanceSpecificationCode;
begin
  result := TFhirSubstanceSpecificationCode.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationCodeList.InsertItem(index: Integer; value: TFhirSubstanceSpecificationCode);
begin
  assert(value is TFhirSubstanceSpecificationCode);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSpecificationCodeList.Item(index: Integer): TFhirSubstanceSpecificationCode;
begin
  result := TFhirSubstanceSpecificationCode(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationCodeList.Link: TFhirSubstanceSpecificationCodeList;
begin
  result := TFhirSubstanceSpecificationCodeList(inherited Link);
end;

procedure TFhirSubstanceSpecificationCodeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSpecificationCodeList.SetItemByIndex(index: Integer; value: TFhirSubstanceSpecificationCode);
begin
  assert(value is TFhirSubstanceSpecificationCode);
  FhirSubstanceSpecificationCodes[index] := value;
end;

procedure TFhirSubstanceSpecificationCodeList.SetItemN(index: Integer; value: TFhirSubstanceSpecificationCode);
begin
  assert(value is TFhirSubstanceSpecificationCode);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSpecificationName }

constructor TFhirSubstanceSpecificationName.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSpecificationName.Destroy;
begin
  FName.free;
  FType_.free;
  FStatus.free;
  FPreferred.free;
  FLanguageList.Free;
  FDomainList.Free;
  FJurisdictionList.Free;
  FSynonymList.Free;
  FTranslationList.Free;
  FOfficialList.Free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceSpecificationName.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirSubstanceSpecificationName(oSource).nameElement.Clone;
  type_ := TFhirSubstanceSpecificationName(oSource).type_.Clone;
  status := TFhirSubstanceSpecificationName(oSource).status.Clone;
  preferredElement := TFhirSubstanceSpecificationName(oSource).preferredElement.Clone;
  if (TFhirSubstanceSpecificationName(oSource).FLanguageList = nil) then
  begin
    FLanguageList.free;
    FLanguageList := nil;
  end
  else
  begin
    if FLanguageList = nil then
      FLanguageList := TFhirCodeableConceptList.Create;
    FLanguageList.Assign(TFhirSubstanceSpecificationName(oSource).FLanguageList);
  end;
  if (TFhirSubstanceSpecificationName(oSource).FDomainList = nil) then
  begin
    FDomainList.free;
    FDomainList := nil;
  end
  else
  begin
    if FDomainList = nil then
      FDomainList := TFhirCodeableConceptList.Create;
    FDomainList.Assign(TFhirSubstanceSpecificationName(oSource).FDomainList);
  end;
  if (TFhirSubstanceSpecificationName(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirSubstanceSpecificationName(oSource).FJurisdictionList);
  end;
  if (TFhirSubstanceSpecificationName(oSource).FSynonymList = nil) then
  begin
    FSynonymList.free;
    FSynonymList := nil;
  end
  else
  begin
    if FSynonymList = nil then
      FSynonymList := TFhirSubstanceSpecificationNameList.Create;
    FSynonymList.Assign(TFhirSubstanceSpecificationName(oSource).FSynonymList);
  end;
  if (TFhirSubstanceSpecificationName(oSource).FTranslationList = nil) then
  begin
    FTranslationList.free;
    FTranslationList := nil;
  end
  else
  begin
    if FTranslationList = nil then
      FTranslationList := TFhirSubstanceSpecificationNameList.Create;
    FTranslationList.Assign(TFhirSubstanceSpecificationName(oSource).FTranslationList);
  end;
  if (TFhirSubstanceSpecificationName(oSource).FOfficialList = nil) then
  begin
    FOfficialList.free;
    FOfficialList := nil;
  end
  else
  begin
    if FOfficialList = nil then
      FOfficialList := TFhirSubstanceSpecificationNameOfficialList.Create;
    FOfficialList.Assign(TFhirSubstanceSpecificationName(oSource).FOfficialList);
  end;
  if (TFhirSubstanceSpecificationName(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList{TFhirDocumentReference}.Create;
    FSourceList.Assign(TFhirSubstanceSpecificationName(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceSpecificationName.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'preferred') Then
     list.add(self.link, 'preferred', FPreferred.Link);
  if (child_name = 'language') Then
    list.addAll(self, 'language', FLanguageList);
  if (child_name = 'domain') Then
    list.addAll(self, 'domain', FDomainList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'synonym') Then
    list.addAll(self, 'synonym', FSynonymList);
  if (child_name = 'translation') Then
    list.addAll(self, 'translation', FTranslationList);
  if (child_name = 'official') Then
    list.addAll(self, 'official', FOfficialList);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceSpecificationName.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'preferred', 'boolean', false, TFhirBoolean, FPreferred.Link));{2}
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', true, TFhirCodeableConcept, FLanguageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'domain', 'CodeableConcept', true, TFhirCodeableConcept, FDomainList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'synonym', '@SubstanceSpecification.name', true, TFhirSubstanceSpecificationName, FSynonymList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'translation', '@SubstanceSpecification.name', true, TFhirSubstanceSpecificationName, FTranslationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'official', '', true, TFhirSubstanceSpecificationNameOfficial, FOfficialList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'source', 'Reference(DocumentReference)', true, TFhirReference{TFhirDocumentReference}, FSourceList.Link)){3};
end;

function TFhirSubstanceSpecificationName.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'preferred') then
  begin
    PreferredElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    LanguageList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'domain') then
  begin
    DomainList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'synonym') then
  begin
    SynonymList.add(propValue as TFhirSubstanceSpecificationName){2a};
    result := propValue;
  end
  else if (propName = 'translation') then
  begin
    TranslationList.add(propValue as TFhirSubstanceSpecificationName){2a};
    result := propValue;
  end
  else if (propName = 'official') then
  begin
    OfficialList.add(propValue as TFhirSubstanceSpecificationNameOfficial){2a};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference{TFhirDocumentReference}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSpecificationName.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'language') then LanguageList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'domain') then DomainList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'synonym') then SynonymList.insertItem(index, propValue as TFhirSubstanceSpecificationName){2a}
  else if (propName = 'translation') then TranslationList.insertItem(index, propValue as TFhirSubstanceSpecificationName){2a}
  else if (propName = 'official') then OfficialList.insertItem(index, propValue as TFhirSubstanceSpecificationNameOfficial){2a}
  else if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference{TFhirDocumentReference}){2a}
  else inherited;
end;

function TFhirSubstanceSpecificationName.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'status') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'preferred') then result := TFhirBoolean.create() {5b}
  else if (propName = 'language') then result := LanguageList.new(){2}
  else if (propName = 'domain') then result := DomainList.new(){2}
  else if (propName = 'jurisdiction') then result := JurisdictionList.new(){2}
  else if (propName = 'synonym') then result := SynonymList.new(){2}
  else if (propName = 'translation') then result := TranslationList.new(){2}
  else if (propName = 'official') then result := OfficialList.new(){2}
  else if (propName = 'source') then result := SourceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSpecificationName.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'preferred') then result := 'boolean'
  else if (propName = 'language') then result := 'CodeableConcept'
  else if (propName = 'domain') then result := 'CodeableConcept'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'synonym') then result := '@SubstanceSpecification.name'
  else if (propName = 'translation') then result := '@SubstanceSpecification.name'
  else if (propName = 'official') then result := ''
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSpecificationName.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'preferred') then PreferredElement := nil
  else if (propName = 'language') then deletePropertyValue('language', LanguageList, value) {2}
  else if (propName = 'domain') then deletePropertyValue('domain', DomainList, value) {2}
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value) {2}
  else if (propName = 'synonym') then deletePropertyValue('synonym', SynonymList, value) {2}
  else if (propName = 'translation') then deletePropertyValue('translation', TranslationList, value) {2}
  else if (propName = 'official') then deletePropertyValue('official', OfficialList, value) {2}
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSpecificationName.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept{4}
  else if (propName = 'preferred') then PreferredElement := asBoolean(new){5b}
  else if (propName = 'language') then replacePropertyValue('language', LanguageList, existing, new) {2}
  else if (propName = 'domain') then replacePropertyValue('domain', DomainList, existing, new) {2}
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new) {2}
  else if (propName = 'synonym') then replacePropertyValue('synonym', SynonymList, existing, new) {2}
  else if (propName = 'translation') then replacePropertyValue('translation', TranslationList, existing, new) {2}
  else if (propName = 'official') then replacePropertyValue('official', OfficialList, existing, new) {2}
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSpecificationName.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'language') then LanguageList.move(source, destination){2a}
  else if (propName = 'domain') then DomainList.move(source, destination){2a}
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination){2a}
  else if (propName = 'synonym') then SynonymList.move(source, destination){2a}
  else if (propName = 'translation') then TranslationList.move(source, destination){2a}
  else if (propName = 'official') then OfficialList.move(source, destination){2a}
  else if (propName = 'source') then SourceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSpecificationName.fhirType : string;
begin
  result := 'name';
end;

function TFhirSubstanceSpecificationName.Link : TFhirSubstanceSpecificationName;
begin
  result := TFhirSubstanceSpecificationName(inherited Link);
end;

function TFhirSubstanceSpecificationName.Clone : TFhirSubstanceSpecificationName;
begin
  result := TFhirSubstanceSpecificationName(inherited Clone);
end;

function TFhirSubstanceSpecificationName.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSpecificationName;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSpecificationName)) then
    result := false
  else
  begin
    o := TFhirSubstanceSpecificationName(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(preferredElement, o.preferredElement, true) and 
      compareDeep(languageList, o.languageList, true) and compareDeep(domainList, o.domainList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(synonymList, o.synonymList, true) and 
      compareDeep(translationList, o.translationList, true) and compareDeep(officialList, o.officialList, true) and 
      compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceSpecificationName.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FType_) and isEmptyProp(FStatus) and isEmptyProp(FPreferred) and isEmptyProp(FlanguageList) and isEmptyProp(FdomainList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FsynonymList) and isEmptyProp(FtranslationList) and isEmptyProp(FofficialList) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceSpecificationName.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('type');
  fields.add('status');
  fields.add('preferred');
  fields.add('language');
  fields.add('domain');
  fields.add('jurisdiction');
  fields.add('synonym');
  fields.add('translation');
  fields.add('official');
  fields.add('source');
end;

{ TFhirSubstanceSpecificationName }

Procedure TFhirSubstanceSpecificationName.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirSubstanceSpecificationName.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirSubstanceSpecificationName.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirSubstanceSpecificationName.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSubstanceSpecificationName.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

Procedure TFhirSubstanceSpecificationName.SetPreferred(value : TFhirBoolean);
begin
  FPreferred.free;
  FPreferred := value;
end;

Function TFhirSubstanceSpecificationName.GetPreferredST : Boolean;
begin
  if FPreferred = nil then
    result := false
  else
    result := FPreferred.value;
end;

Procedure TFhirSubstanceSpecificationName.SetPreferredST(value : Boolean);
begin
  if FPreferred = nil then
    FPreferred := TFhirBoolean.create;
  FPreferred.value := value
end;

Function TFhirSubstanceSpecificationName.GetLanguageList : TFhirCodeableConceptList;
begin
  if FLanguageList = nil then
    FLanguageList := TFhirCodeableConceptList.Create;
  result := FLanguageList;
end;

Function TFhirSubstanceSpecificationName.GetHasLanguageList : boolean;
begin
  result := (FLanguageList <> nil) and (FLanguageList.count > 0);
end;

Function TFhirSubstanceSpecificationName.GetDomainList : TFhirCodeableConceptList;
begin
  if FDomainList = nil then
    FDomainList := TFhirCodeableConceptList.Create;
  result := FDomainList;
end;

Function TFhirSubstanceSpecificationName.GetHasDomainList : boolean;
begin
  result := (FDomainList <> nil) and (FDomainList.count > 0);
end;

Function TFhirSubstanceSpecificationName.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

Function TFhirSubstanceSpecificationName.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

Function TFhirSubstanceSpecificationName.GetSynonymList : TFhirSubstanceSpecificationNameList;
begin
  if FSynonymList = nil then
    FSynonymList := TFhirSubstanceSpecificationNameList.Create;
  result := FSynonymList;
end;

Function TFhirSubstanceSpecificationName.GetHasSynonymList : boolean;
begin
  result := (FSynonymList <> nil) and (FSynonymList.count > 0);
end;

Function TFhirSubstanceSpecificationName.GetTranslationList : TFhirSubstanceSpecificationNameList;
begin
  if FTranslationList = nil then
    FTranslationList := TFhirSubstanceSpecificationNameList.Create;
  result := FTranslationList;
end;

Function TFhirSubstanceSpecificationName.GetHasTranslationList : boolean;
begin
  result := (FTranslationList <> nil) and (FTranslationList.count > 0);
end;

Function TFhirSubstanceSpecificationName.GetOfficialList : TFhirSubstanceSpecificationNameOfficialList;
begin
  if FOfficialList = nil then
    FOfficialList := TFhirSubstanceSpecificationNameOfficialList.Create;
  result := FOfficialList;
end;

Function TFhirSubstanceSpecificationName.GetHasOfficialList : boolean;
begin
  result := (FOfficialList <> nil) and (FOfficialList.count > 0);
end;

Function TFhirSubstanceSpecificationName.GetSourceList : TFhirReferenceList{TFhirDocumentReference};
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList{TFhirDocumentReference}.Create;
  result := FSourceList;
end;

Function TFhirSubstanceSpecificationName.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

function TFhirSubstanceSpecificationName.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPreferred.sizeInBytes);
  inc(result, FlanguageList.sizeInBytes);
  inc(result, FdomainList.sizeInBytes);
  inc(result, FjurisdictionList.sizeInBytes);
  inc(result, FsynonymList.sizeInBytes);
  inc(result, FtranslationList.sizeInBytes);
  inc(result, FofficialList.sizeInBytes);
  inc(result, FsourceList.sizeInBytes);
end;

{ TFhirSubstanceSpecificationNameListEnumerator }

Constructor TFhirSubstanceSpecificationNameListEnumerator.Create(list : TFhirSubstanceSpecificationNameList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSpecificationNameListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSpecificationNameListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSpecificationNameListEnumerator.GetCurrent : TFhirSubstanceSpecificationName;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSpecificationNameListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSpecificationNameList }
procedure TFhirSubstanceSpecificationNameList.AddItem(value: TFhirSubstanceSpecificationName);
begin
  assert(value.ClassName = 'TFhirSubstanceSpecificationName', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSpecificationName');
  add(value);
end;

function TFhirSubstanceSpecificationNameList.Append: TFhirSubstanceSpecificationName;
begin
  result := TFhirSubstanceSpecificationName.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationNameList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSpecificationNameList.GetEnumerator : TFhirSubstanceSpecificationNameListEnumerator;
begin
  result := TFhirSubstanceSpecificationNameListEnumerator.Create(self.link);
end;

function TFhirSubstanceSpecificationNameList.Clone: TFhirSubstanceSpecificationNameList;
begin
  result := TFhirSubstanceSpecificationNameList(inherited Clone);
end;

function TFhirSubstanceSpecificationNameList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSpecificationNameList.GetItemN(index: Integer): TFhirSubstanceSpecificationName;
begin
  result := TFhirSubstanceSpecificationName(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationNameList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSpecificationName;
end;
function TFhirSubstanceSpecificationNameList.IndexOf(value: TFhirSubstanceSpecificationName): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSpecificationNameList.Insert(index: Integer): TFhirSubstanceSpecificationName;
begin
  result := TFhirSubstanceSpecificationName.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationNameList.InsertItem(index: Integer; value: TFhirSubstanceSpecificationName);
begin
  assert(value is TFhirSubstanceSpecificationName);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSpecificationNameList.Item(index: Integer): TFhirSubstanceSpecificationName;
begin
  result := TFhirSubstanceSpecificationName(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationNameList.Link: TFhirSubstanceSpecificationNameList;
begin
  result := TFhirSubstanceSpecificationNameList(inherited Link);
end;

procedure TFhirSubstanceSpecificationNameList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSpecificationNameList.SetItemByIndex(index: Integer; value: TFhirSubstanceSpecificationName);
begin
  assert(value is TFhirSubstanceSpecificationName);
  FhirSubstanceSpecificationNames[index] := value;
end;

procedure TFhirSubstanceSpecificationNameList.SetItemN(index: Integer; value: TFhirSubstanceSpecificationName);
begin
  assert(value is TFhirSubstanceSpecificationName);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSpecificationNameOfficial }

constructor TFhirSubstanceSpecificationNameOfficial.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSpecificationNameOfficial.Destroy;
begin
  FAuthority.free;
  FStatus.free;
  FDate.free;
  inherited;
end;

procedure TFhirSubstanceSpecificationNameOfficial.Assign(oSource : TFslObject);
begin
  inherited;
  authority := TFhirSubstanceSpecificationNameOfficial(oSource).authority.Clone;
  status := TFhirSubstanceSpecificationNameOfficial(oSource).status.Clone;
  dateElement := TFhirSubstanceSpecificationNameOfficial(oSource).dateElement.Clone;
end;

procedure TFhirSubstanceSpecificationNameOfficial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'authority') Then
     list.add(self.link, 'authority', FAuthority.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
end;

procedure TFhirSubstanceSpecificationNameOfficial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'authority', 'CodeableConcept', false, TFhirCodeableConcept, FAuthority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
end;

function TFhirSubstanceSpecificationNameOfficial.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'authority') then
  begin
    Authority := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSpecificationNameOfficial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceSpecificationNameOfficial.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'authority') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'status') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSpecificationNameOfficial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'authority') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSpecificationNameOfficial.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'authority') then AuthorityElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'date') then DateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSpecificationNameOfficial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'authority') then AuthorityElement := new as TFhirCodeableConcept{4}
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept{4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSpecificationNameOfficial.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSpecificationNameOfficial.fhirType : string;
begin
  result := 'official';
end;

function TFhirSubstanceSpecificationNameOfficial.Link : TFhirSubstanceSpecificationNameOfficial;
begin
  result := TFhirSubstanceSpecificationNameOfficial(inherited Link);
end;

function TFhirSubstanceSpecificationNameOfficial.Clone : TFhirSubstanceSpecificationNameOfficial;
begin
  result := TFhirSubstanceSpecificationNameOfficial(inherited Clone);
end;

function TFhirSubstanceSpecificationNameOfficial.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSpecificationNameOfficial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSpecificationNameOfficial)) then
    result := false
  else
  begin
    o := TFhirSubstanceSpecificationNameOfficial(other);
    result := compareDeep(authorityElement, o.authorityElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(dateElement, o.dateElement, true);
  end;
end;

function TFhirSubstanceSpecificationNameOfficial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAuthority) and isEmptyProp(FStatus) and isEmptyProp(FDate);
end;

procedure TFhirSubstanceSpecificationNameOfficial.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('authority');
  fields.add('status');
  fields.add('date');
end;

{ TFhirSubstanceSpecificationNameOfficial }

Procedure TFhirSubstanceSpecificationNameOfficial.SetAuthority(value : TFhirCodeableConcept);
begin
  FAuthority.free;
  FAuthority := value;
end;

Procedure TFhirSubstanceSpecificationNameOfficial.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

Procedure TFhirSubstanceSpecificationNameOfficial.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirSubstanceSpecificationNameOfficial.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirSubstanceSpecificationNameOfficial.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

function TFhirSubstanceSpecificationNameOfficial.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAuthority.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FDate.sizeInBytes);
end;

{ TFhirSubstanceSpecificationNameOfficialListEnumerator }

Constructor TFhirSubstanceSpecificationNameOfficialListEnumerator.Create(list : TFhirSubstanceSpecificationNameOfficialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSpecificationNameOfficialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSpecificationNameOfficialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSpecificationNameOfficialListEnumerator.GetCurrent : TFhirSubstanceSpecificationNameOfficial;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSpecificationNameOfficialListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSpecificationNameOfficialList }
procedure TFhirSubstanceSpecificationNameOfficialList.AddItem(value: TFhirSubstanceSpecificationNameOfficial);
begin
  assert(value.ClassName = 'TFhirSubstanceSpecificationNameOfficial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSpecificationNameOfficial');
  add(value);
end;

function TFhirSubstanceSpecificationNameOfficialList.Append: TFhirSubstanceSpecificationNameOfficial;
begin
  result := TFhirSubstanceSpecificationNameOfficial.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationNameOfficialList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSpecificationNameOfficialList.GetEnumerator : TFhirSubstanceSpecificationNameOfficialListEnumerator;
begin
  result := TFhirSubstanceSpecificationNameOfficialListEnumerator.Create(self.link);
end;

function TFhirSubstanceSpecificationNameOfficialList.Clone: TFhirSubstanceSpecificationNameOfficialList;
begin
  result := TFhirSubstanceSpecificationNameOfficialList(inherited Clone);
end;

function TFhirSubstanceSpecificationNameOfficialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSpecificationNameOfficialList.GetItemN(index: Integer): TFhirSubstanceSpecificationNameOfficial;
begin
  result := TFhirSubstanceSpecificationNameOfficial(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationNameOfficialList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSpecificationNameOfficial;
end;
function TFhirSubstanceSpecificationNameOfficialList.IndexOf(value: TFhirSubstanceSpecificationNameOfficial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSpecificationNameOfficialList.Insert(index: Integer): TFhirSubstanceSpecificationNameOfficial;
begin
  result := TFhirSubstanceSpecificationNameOfficial.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationNameOfficialList.InsertItem(index: Integer; value: TFhirSubstanceSpecificationNameOfficial);
begin
  assert(value is TFhirSubstanceSpecificationNameOfficial);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSpecificationNameOfficialList.Item(index: Integer): TFhirSubstanceSpecificationNameOfficial;
begin
  result := TFhirSubstanceSpecificationNameOfficial(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationNameOfficialList.Link: TFhirSubstanceSpecificationNameOfficialList;
begin
  result := TFhirSubstanceSpecificationNameOfficialList(inherited Link);
end;

procedure TFhirSubstanceSpecificationNameOfficialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSpecificationNameOfficialList.SetItemByIndex(index: Integer; value: TFhirSubstanceSpecificationNameOfficial);
begin
  assert(value is TFhirSubstanceSpecificationNameOfficial);
  FhirSubstanceSpecificationNameOfficials[index] := value;
end;

procedure TFhirSubstanceSpecificationNameOfficialList.SetItemN(index: Integer; value: TFhirSubstanceSpecificationNameOfficial);
begin
  assert(value is TFhirSubstanceSpecificationNameOfficial);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSpecificationRelationship }

constructor TFhirSubstanceSpecificationRelationship.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSpecificationRelationship.Destroy;
begin
  FSubstance.free;
  FRelationship.free;
  FIsDefining.free;
  FAmount.free;
  FAmountRatioLowLimit.free;
  FAmountType.free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceSpecificationRelationship.Assign(oSource : TFslObject);
begin
  inherited;
  substance := TFhirSubstanceSpecificationRelationship(oSource).substance.Clone;
  relationship := TFhirSubstanceSpecificationRelationship(oSource).relationship.Clone;
  isDefiningElement := TFhirSubstanceSpecificationRelationship(oSource).isDefiningElement.Clone;
  amount := TFhirSubstanceSpecificationRelationship(oSource).amount.Clone;
  amountRatioLowLimit := TFhirSubstanceSpecificationRelationship(oSource).amountRatioLowLimit.Clone;
  amountType := TFhirSubstanceSpecificationRelationship(oSource).amountType.Clone;
  if (TFhirSubstanceSpecificationRelationship(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList{TFhirDocumentReference}.Create;
    FSourceList.Assign(TFhirSubstanceSpecificationRelationship(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceSpecificationRelationship.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'substance[x]') or (child_name = 'substance') Then
     list.add(self.link, 'substance[x]', FSubstance.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'isDefining') Then
     list.add(self.link, 'isDefining', FIsDefining.Link);
  if (child_name = 'amount[x]') or (child_name = 'amount') Then
     list.add(self.link, 'amount[x]', FAmount.Link);
  if (child_name = 'amountRatioLowLimit') Then
     list.add(self.link, 'amountRatioLowLimit', FAmountRatioLowLimit.Link);
  if (child_name = 'amountType') Then
     list.add(self.link, 'amountType', FAmountType.Link);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceSpecificationRelationship.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'substance[x]', 'Reference(SubstanceSpecification)|CodeableConcept', false, TFhirType, FSubstance.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', false, TFhirCodeableConcept, FRelationship.Link));{2}
  oList.add(TFHIRProperty.create(self, 'isDefining', 'boolean', false, TFhirBoolean, FIsDefining.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount[x]', 'Quantity|Range|Ratio|string', false, TFhirType, FAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amountRatioLowLimit', 'Ratio', false, TFhirRatio, FAmountRatioLowLimit.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amountType', 'CodeableConcept', false, TFhirCodeableConcept, FAmountType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference(DocumentReference)', true, TFhirReference{TFhirDocumentReference}, FSourceList.Link)){3};
end;

function TFhirSubstanceSpecificationRelationship.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'substance', ['Reference', 'CodeableConcept'])) then
  begin
    Substance := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'isDefining') then
  begin
    IsDefiningElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'Ratio', 'String'])) then
  begin
    Amount := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'amountRatioLowLimit') then
  begin
    AmountRatioLowLimit := propValue as TFhirRatio{4b};
    result := propValue;
  end
  else if (propName = 'amountType') then
  begin
    AmountType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference{TFhirDocumentReference}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceSpecificationRelationship.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference{TFhirDocumentReference}){2a}
  else inherited;
end;

function TFhirSubstanceSpecificationRelationship.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'substance', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Substance'){4x}
  else if (propName = 'relationship') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'isDefining') then result := TFhirBoolean.create() {5b}
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'Ratio', 'String'])) then raise EFHIRException.create('Cannot make property Amount'){4x}
  else if (propName = 'amountRatioLowLimit') then result := TFhirRatio.create(){4b}
  else if (propName = 'amountType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'source') then result := SourceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSpecificationRelationship.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'substance[x]') then result := 'Reference|CodeableConcept'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'isDefining') then result := 'boolean'
  else if (propName = 'amount[x]') then result := 'Quantity|Range|Ratio|string'
  else if (propName = 'amountRatioLowLimit') then result := 'Ratio'
  else if (propName = 'amountType') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSpecificationRelationship.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'substance', ['Reference', 'CodeableConcept'])) then SubstanceElement := nil{4x}
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'isDefining') then IsDefiningElement := nil
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'Ratio', 'String'])) then AmountElement := nil{4x}
  else if (propName = 'amountRatioLowLimit') then AmountRatioLowLimitElement := nil
  else if (propName = 'amountType') then AmountTypeElement := nil
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSpecificationRelationship.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'substance', ['Reference', 'CodeableConcept'])) then SubstanceElement := new as TFhirType{4x}
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCodeableConcept{4}
  else if (propName = 'isDefining') then IsDefiningElement := asBoolean(new){5b}
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'Ratio', 'String'])) then AmountElement := new as TFhirType{4x}
  else if (propName = 'amountRatioLowLimit') then AmountRatioLowLimitElement := new as TFhirRatio{4}
  else if (propName = 'amountType') then AmountTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSpecificationRelationship.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'source') then SourceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSpecificationRelationship.fhirType : string;
begin
  result := 'relationship';
end;

function TFhirSubstanceSpecificationRelationship.Link : TFhirSubstanceSpecificationRelationship;
begin
  result := TFhirSubstanceSpecificationRelationship(inherited Link);
end;

function TFhirSubstanceSpecificationRelationship.Clone : TFhirSubstanceSpecificationRelationship;
begin
  result := TFhirSubstanceSpecificationRelationship(inherited Clone);
end;

function TFhirSubstanceSpecificationRelationship.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSpecificationRelationship;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSpecificationRelationship)) then
    result := false
  else
  begin
    o := TFhirSubstanceSpecificationRelationship(other);
    result := compareDeep(substanceElement, o.substanceElement, true) and compareDeep(relationshipElement, o.relationshipElement, true) and 
      compareDeep(isDefiningElement, o.isDefiningElement, true) and compareDeep(amountElement, o.amountElement, true) and 
      compareDeep(amountRatioLowLimitElement, o.amountRatioLowLimitElement, true) and 
      compareDeep(amountTypeElement, o.amountTypeElement, true) and compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceSpecificationRelationship.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubstance) and isEmptyProp(FRelationship) and isEmptyProp(FIsDefining) and isEmptyProp(FAmount) and isEmptyProp(FAmountRatioLowLimit) and isEmptyProp(FAmountType) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceSpecificationRelationship.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('substance[x]');
  fields.add('relationship');
  fields.add('isDefining');
  fields.add('amount[x]');
  fields.add('amountRatioLowLimit');
  fields.add('amountType');
  fields.add('source');
end;

{ TFhirSubstanceSpecificationRelationship }

Procedure TFhirSubstanceSpecificationRelationship.SetSubstance(value : TFhirType);
begin
  FSubstance.free;
  FSubstance := value;
end;

Procedure TFhirSubstanceSpecificationRelationship.SetRelationship(value : TFhirCodeableConcept);
begin
  FRelationship.free;
  FRelationship := value;
end;

Procedure TFhirSubstanceSpecificationRelationship.SetIsDefining(value : TFhirBoolean);
begin
  FIsDefining.free;
  FIsDefining := value;
end;

Function TFhirSubstanceSpecificationRelationship.GetIsDefiningST : Boolean;
begin
  if FIsDefining = nil then
    result := false
  else
    result := FIsDefining.value;
end;

Procedure TFhirSubstanceSpecificationRelationship.SetIsDefiningST(value : Boolean);
begin
  if FIsDefining = nil then
    FIsDefining := TFhirBoolean.create;
  FIsDefining.value := value
end;

Procedure TFhirSubstanceSpecificationRelationship.SetAmount(value : TFhirType);
begin
  FAmount.free;
  FAmount := value;
end;

Procedure TFhirSubstanceSpecificationRelationship.SetAmountRatioLowLimit(value : TFhirRatio);
begin
  FAmountRatioLowLimit.free;
  FAmountRatioLowLimit := value;
end;

Procedure TFhirSubstanceSpecificationRelationship.SetAmountType(value : TFhirCodeableConcept);
begin
  FAmountType.free;
  FAmountType := value;
end;

Function TFhirSubstanceSpecificationRelationship.GetSourceList : TFhirReferenceList{TFhirDocumentReference};
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList{TFhirDocumentReference}.Create;
  result := FSourceList;
end;

Function TFhirSubstanceSpecificationRelationship.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

function TFhirSubstanceSpecificationRelationship.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSubstance.sizeInBytes);
  inc(result, FRelationship.sizeInBytes);
  inc(result, FIsDefining.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FAmountRatioLowLimit.sizeInBytes);
  inc(result, FAmountType.sizeInBytes);
  inc(result, FsourceList.sizeInBytes);
end;

{ TFhirSubstanceSpecificationRelationshipListEnumerator }

Constructor TFhirSubstanceSpecificationRelationshipListEnumerator.Create(list : TFhirSubstanceSpecificationRelationshipList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSpecificationRelationshipListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSpecificationRelationshipListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSpecificationRelationshipListEnumerator.GetCurrent : TFhirSubstanceSpecificationRelationship;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSpecificationRelationshipListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSpecificationRelationshipList }
procedure TFhirSubstanceSpecificationRelationshipList.AddItem(value: TFhirSubstanceSpecificationRelationship);
begin
  assert(value.ClassName = 'TFhirSubstanceSpecificationRelationship', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSpecificationRelationship');
  add(value);
end;

function TFhirSubstanceSpecificationRelationshipList.Append: TFhirSubstanceSpecificationRelationship;
begin
  result := TFhirSubstanceSpecificationRelationship.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationRelationshipList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSpecificationRelationshipList.GetEnumerator : TFhirSubstanceSpecificationRelationshipListEnumerator;
begin
  result := TFhirSubstanceSpecificationRelationshipListEnumerator.Create(self.link);
end;

function TFhirSubstanceSpecificationRelationshipList.Clone: TFhirSubstanceSpecificationRelationshipList;
begin
  result := TFhirSubstanceSpecificationRelationshipList(inherited Clone);
end;

function TFhirSubstanceSpecificationRelationshipList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSpecificationRelationshipList.GetItemN(index: Integer): TFhirSubstanceSpecificationRelationship;
begin
  result := TFhirSubstanceSpecificationRelationship(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationRelationshipList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSpecificationRelationship;
end;
function TFhirSubstanceSpecificationRelationshipList.IndexOf(value: TFhirSubstanceSpecificationRelationship): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSpecificationRelationshipList.Insert(index: Integer): TFhirSubstanceSpecificationRelationship;
begin
  result := TFhirSubstanceSpecificationRelationship.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationRelationshipList.InsertItem(index: Integer; value: TFhirSubstanceSpecificationRelationship);
begin
  assert(value is TFhirSubstanceSpecificationRelationship);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSpecificationRelationshipList.Item(index: Integer): TFhirSubstanceSpecificationRelationship;
begin
  result := TFhirSubstanceSpecificationRelationship(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationRelationshipList.Link: TFhirSubstanceSpecificationRelationshipList;
begin
  result := TFhirSubstanceSpecificationRelationshipList(inherited Link);
end;

procedure TFhirSubstanceSpecificationRelationshipList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSpecificationRelationshipList.SetItemByIndex(index: Integer; value: TFhirSubstanceSpecificationRelationship);
begin
  assert(value is TFhirSubstanceSpecificationRelationship);
  FhirSubstanceSpecificationRelationships[index] := value;
end;

procedure TFhirSubstanceSpecificationRelationshipList.SetItemN(index: Integer; value: TFhirSubstanceSpecificationRelationship);
begin
  assert(value is TFhirSubstanceSpecificationRelationship);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceSpecification }

constructor TFhirSubstanceSpecification.Create;
begin
  inherited;
end;

destructor TFhirSubstanceSpecification.Destroy;
begin
  FIdentifier.free;
  FType_.free;
  FStatus.free;
  FDomain.free;
  FDescription.free;
  FSourceList.Free;
  FComment.free;
  FMoietyList.Free;
  FProperty_List.Free;
  FReferenceInformation.free;
  FStructure.free;
  FCodeList.Free;
  FNameList.Free;
  FMolecularWeightList.Free;
  FRelationshipList.Free;
  FNucleicAcid.free;
  FPolymer.free;
  FProtein.free;
  FSourceMaterial.free;
  inherited;
end;

function TFhirSubstanceSpecification.GetResourceType : TFhirResourceType;
begin
  result := frtSubstanceSpecification;
end;

procedure TFhirSubstanceSpecification.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirSubstanceSpecification(oSource).identifier.Clone;
  type_ := TFhirSubstanceSpecification(oSource).type_.Clone;
  status := TFhirSubstanceSpecification(oSource).status.Clone;
  domain := TFhirSubstanceSpecification(oSource).domain.Clone;
  descriptionElement := TFhirSubstanceSpecification(oSource).descriptionElement.Clone;
  if (TFhirSubstanceSpecification(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList{TFhirDocumentReference}.Create;
    FSourceList.Assign(TFhirSubstanceSpecification(oSource).FSourceList);
  end;
  commentElement := TFhirSubstanceSpecification(oSource).commentElement.Clone;
  if (TFhirSubstanceSpecification(oSource).FMoietyList = nil) then
  begin
    FMoietyList.free;
    FMoietyList := nil;
  end
  else
  begin
    if FMoietyList = nil then
      FMoietyList := TFhirSubstanceSpecificationMoietyList.Create;
    FMoietyList.Assign(TFhirSubstanceSpecification(oSource).FMoietyList);
  end;
  if (TFhirSubstanceSpecification(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirSubstanceSpecificationPropertyList.Create;
    FProperty_List.Assign(TFhirSubstanceSpecification(oSource).FProperty_List);
  end;
  referenceInformation := TFhirSubstanceSpecification(oSource).referenceInformation.Clone;
  structure := TFhirSubstanceSpecification(oSource).structure.Clone;
  if (TFhirSubstanceSpecification(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirSubstanceSpecificationCodeList.Create;
    FCodeList.Assign(TFhirSubstanceSpecification(oSource).FCodeList);
  end;
  if (TFhirSubstanceSpecification(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirSubstanceSpecificationNameList.Create;
    FNameList.Assign(TFhirSubstanceSpecification(oSource).FNameList);
  end;
  if (TFhirSubstanceSpecification(oSource).FMolecularWeightList = nil) then
  begin
    FMolecularWeightList.free;
    FMolecularWeightList := nil;
  end
  else
  begin
    if FMolecularWeightList = nil then
      FMolecularWeightList := TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList.Create;
    FMolecularWeightList.Assign(TFhirSubstanceSpecification(oSource).FMolecularWeightList);
  end;
  if (TFhirSubstanceSpecification(oSource).FRelationshipList = nil) then
  begin
    FRelationshipList.free;
    FRelationshipList := nil;
  end
  else
  begin
    if FRelationshipList = nil then
      FRelationshipList := TFhirSubstanceSpecificationRelationshipList.Create;
    FRelationshipList.Assign(TFhirSubstanceSpecification(oSource).FRelationshipList);
  end;
  nucleicAcid := TFhirSubstanceSpecification(oSource).nucleicAcid.Clone;
  polymer := TFhirSubstanceSpecification(oSource).polymer.Clone;
  protein := TFhirSubstanceSpecification(oSource).protein.Clone;
  sourceMaterial := TFhirSubstanceSpecification(oSource).sourceMaterial.Clone;
end;

procedure TFhirSubstanceSpecification.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'domain') Then
     list.add(self.link, 'domain', FDomain.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'moiety') Then
    list.addAll(self, 'moiety', FMoietyList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'referenceInformation') Then
     list.add(self.link, 'referenceInformation', FReferenceInformation.Link);
  if (child_name = 'structure') Then
     list.add(self.link, 'structure', FStructure.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'molecularWeight') Then
    list.addAll(self, 'molecularWeight', FMolecularWeightList);
  if (child_name = 'relationship') Then
    list.addAll(self, 'relationship', FRelationshipList);
  if (child_name = 'nucleicAcid') Then
     list.add(self.link, 'nucleicAcid', FNucleicAcid.Link);
  if (child_name = 'polymer') Then
     list.add(self.link, 'polymer', FPolymer.Link);
  if (child_name = 'protein') Then
     list.add(self.link, 'protein', FProtein.Link);
  if (child_name = 'sourceMaterial') Then
     list.add(self.link, 'sourceMaterial', FSourceMaterial.Link);
end;

procedure TFhirSubstanceSpecification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'domain', 'CodeableConcept', false, TFhirCodeableConcept, FDomain.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference(DocumentReference)', true, TFhirReference{TFhirDocumentReference}, FSourceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'moiety', '', true, TFhirSubstanceSpecificationMoiety, FMoietyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'property', '', true, TFhirSubstanceSpecificationProperty, FProperty_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'referenceInformation', 'Reference(SubstanceReferenceInformation)', false, TFhirReference{TFhirSubstanceReferenceInformation}, FReferenceInformation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'structure', '', false, TFhirSubstanceSpecificationStructure, FStructure.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', '', true, TFhirSubstanceSpecificationCode, FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'name', '', true, TFhirSubstanceSpecificationName, FNameList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'molecularWeight', '@SubstanceSpecification.structure.isotope.molecularWeight', true, TFhirSubstanceSpecificationStructureIsotopeMolecularWeight, FMolecularWeightList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relationship', '', true, TFhirSubstanceSpecificationRelationship, FRelationshipList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'nucleicAcid', 'Reference(SubstanceNucleicAcid)', false, TFhirReference{TFhirSubstanceNucleicAcid}, FNucleicAcid.Link));{2}
  oList.add(TFHIRProperty.create(self, 'polymer', 'Reference(SubstancePolymer)', false, TFhirReference{TFhirSubstancePolymer}, FPolymer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'protein', 'Reference(SubstanceProtein)', false, TFhirReference{TFhirSubstanceProtein}, FProtein.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sourceMaterial', 'Reference(SubstanceSourceMaterial)', false, TFhirReference{TFhirSubstanceSourceMaterial}, FSourceMaterial.Link));{2}
end;

function TFhirSubstanceSpecification.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'domain') then
  begin
    Domain := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference{TFhirDocumentReference}){2a};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'moiety') then
  begin
    MoietyList.add(propValue as TFhirSubstanceSpecificationMoiety){2a};
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirSubstanceSpecificationProperty){2a};
    result := propValue;
  end
  else if (propName = 'referenceInformation') then
  begin
    ReferenceInformation := propValue as TFhirReference{TFhirSubstanceReferenceInformation}{4b};
    result := propValue;
  end
  else if (propName = 'structure') then
  begin
    Structure := propValue as TFhirSubstanceSpecificationStructure{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirSubstanceSpecificationCode){2a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirSubstanceSpecificationName){2a};
    result := propValue;
  end
  else if (propName = 'molecularWeight') then
  begin
    MolecularWeightList.add(propValue as TFhirSubstanceSpecificationStructureIsotopeMolecularWeight){2a};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    RelationshipList.add(propValue as TFhirSubstanceSpecificationRelationship){2a};
    result := propValue;
  end
  else if (propName = 'nucleicAcid') then
  begin
    NucleicAcid := propValue as TFhirReference{TFhirSubstanceNucleicAcid}{4b};
    result := propValue;
  end
  else if (propName = 'polymer') then
  begin
    Polymer := propValue as TFhirReference{TFhirSubstancePolymer}{4b};
    result := propValue;
  end
  else if (propName = 'protein') then
  begin
    Protein := propValue as TFhirReference{TFhirSubstanceProtein}{4b};
    result := propValue;
  end
  else if (propName = 'sourceMaterial') then
  begin
    SourceMaterial := propValue as TFhirReference{TFhirSubstanceSourceMaterial}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSubstanceSpecification.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference{TFhirDocumentReference}){2a}
  else if (propName = 'moiety') then MoietyList.insertItem(index, propValue as TFhirSubstanceSpecificationMoiety){2a}
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirSubstanceSpecificationProperty){2a}
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirSubstanceSpecificationCode){2a}
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirSubstanceSpecificationName){2a}
  else if (propName = 'molecularWeight') then MolecularWeightList.insertItem(index, propValue as TFhirSubstanceSpecificationStructureIsotopeMolecularWeight){2a}
  else if (propName = 'relationship') then RelationshipList.insertItem(index, propValue as TFhirSubstanceSpecificationRelationship){2a}
  else inherited;
end;

function TFhirSubstanceSpecification.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'status') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'domain') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'source') then result := SourceList.new(){2}
  else if (propName = 'comment') then result := TFhirString.create() {5b}
  else if (propName = 'moiety') then result := MoietyList.new(){2}
  else if (propName = 'property') then result := Property_List.new(){2}
  else if (propName = 'referenceInformation') then result := TFhirReference{TFhirSubstanceReferenceInformation}.create(){4b}
  else if (propName = 'structure') then result := TFhirSubstanceSpecificationStructure.create(){4b}
  else if (propName = 'code') then result := CodeList.new(){2}
  else if (propName = 'name') then result := NameList.new(){2}
  else if (propName = 'molecularWeight') then result := MolecularWeightList.new(){2}
  else if (propName = 'relationship') then result := RelationshipList.new(){2}
  else if (propName = 'nucleicAcid') then result := TFhirReference{TFhirSubstanceNucleicAcid}.create(){4b}
  else if (propName = 'polymer') then result := TFhirReference{TFhirSubstancePolymer}.create(){4b}
  else if (propName = 'protein') then result := TFhirReference{TFhirSubstanceProtein}.create(){4b}
  else if (propName = 'sourceMaterial') then result := TFhirReference{TFhirSubstanceSourceMaterial}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceSpecification.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'domain') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'moiety') then result := ''
  else if (propName = 'property') then result := ''
  else if (propName = 'referenceInformation') then result := 'Reference'
  else if (propName = 'structure') then result := ''
  else if (propName = 'code') then result := ''
  else if (propName = 'name') then result := ''
  else if (propName = 'molecularWeight') then result := '@SubstanceSpecification.structure.isotope.molecularWeight'
  else if (propName = 'relationship') then result := ''
  else if (propName = 'nucleicAcid') then result := 'Reference'
  else if (propName = 'polymer') then result := 'Reference'
  else if (propName = 'protein') then result := 'Reference'
  else if (propName = 'sourceMaterial') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceSpecification.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'domain') then DomainElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value) {2}
  else if (propName = 'comment') then CommentElement := nil
  else if (propName = 'moiety') then deletePropertyValue('moiety', MoietyList, value) {2}
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value) {2}
  else if (propName = 'referenceInformation') then ReferenceInformationElement := nil
  else if (propName = 'structure') then StructureElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value) {2}
  else if (propName = 'name') then deletePropertyValue('name', NameList, value) {2}
  else if (propName = 'molecularWeight') then deletePropertyValue('molecularWeight', MolecularWeightList, value) {2}
  else if (propName = 'relationship') then deletePropertyValue('relationship', RelationshipList, value) {2}
  else if (propName = 'nucleicAcid') then NucleicAcidElement := nil
  else if (propName = 'polymer') then PolymerElement := nil
  else if (propName = 'protein') then ProteinElement := nil
  else if (propName = 'sourceMaterial') then SourceMaterialElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceSpecification.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept{4}
  else if (propName = 'domain') then DomainElement := new as TFhirCodeableConcept{4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new) {2}
  else if (propName = 'comment') then CommentElement := asString(new){5b}
  else if (propName = 'moiety') then replacePropertyValue('moiety', MoietyList, existing, new) {2}
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new) {2}
  else if (propName = 'referenceInformation') then ReferenceInformationElement := new as TFhirReference{TFhirSubstanceReferenceInformation}{4}
  else if (propName = 'structure') then StructureElement := new as TFhirSubstanceSpecificationStructure{4}
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {2}
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new) {2}
  else if (propName = 'molecularWeight') then replacePropertyValue('molecularWeight', MolecularWeightList, existing, new) {2}
  else if (propName = 'relationship') then replacePropertyValue('relationship', RelationshipList, existing, new) {2}
  else if (propName = 'nucleicAcid') then NucleicAcidElement := new as TFhirReference{TFhirSubstanceNucleicAcid}{4}
  else if (propName = 'polymer') then PolymerElement := new as TFhirReference{TFhirSubstancePolymer}{4}
  else if (propName = 'protein') then ProteinElement := new as TFhirReference{TFhirSubstanceProtein}{4}
  else if (propName = 'sourceMaterial') then SourceMaterialElement := new as TFhirReference{TFhirSubstanceSourceMaterial}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceSpecification.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'source') then SourceList.move(source, destination){2a}
  else if (propName = 'moiety') then MoietyList.move(source, destination){2a}
  else if (propName = 'property') then Property_List.move(source, destination){2a}
  else if (propName = 'code') then CodeList.move(source, destination){2a}
  else if (propName = 'name') then NameList.move(source, destination){2a}
  else if (propName = 'molecularWeight') then MolecularWeightList.move(source, destination){2a}
  else if (propName = 'relationship') then RelationshipList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceSpecification.fhirType : string;
begin
  result := 'SubstanceSpecification';
end;

function TFhirSubstanceSpecification.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FType_) and isEmptyProp(FStatus) and isEmptyProp(FDomain) and isEmptyProp(FDescription) and isEmptyProp(FsourceList) and isEmptyProp(FComment) and isEmptyProp(FmoietyList) and isEmptyProp(Fproperty_List) and isEmptyProp(FReferenceInformation) and isEmptyProp(FStructure) and isEmptyProp(FcodeList) and isEmptyProp(FnameList) and isEmptyProp(FmolecularWeightList) and isEmptyProp(FrelationshipList) and isEmptyProp(FNucleicAcid) and isEmptyProp(FPolymer) and isEmptyProp(FProtein) and isEmptyProp(FSourceMaterial);
end;

function TFhirSubstanceSpecification.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceSpecification;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceSpecification)) then
    result := false
  else
  begin
    o := TFhirSubstanceSpecification(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(domainElement, o.domainElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(sourceList, o.sourceList, true) and 
      compareDeep(commentElement, o.commentElement, true) and compareDeep(moietyList, o.moietyList, true) and 
      compareDeep(property_List, o.property_List, true) and compareDeep(referenceInformationElement, o.referenceInformationElement, true) and 
      compareDeep(structureElement, o.structureElement, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(nameList, o.nameList, true) and compareDeep(molecularWeightList, o.molecularWeightList, true) and 
      compareDeep(relationshipList, o.relationshipList, true) and compareDeep(nucleicAcidElement, o.nucleicAcidElement, true) and 
      compareDeep(polymerElement, o.polymerElement, true) and compareDeep(proteinElement, o.proteinElement, true) and 
      compareDeep(sourceMaterialElement, o.sourceMaterialElement, true);
  end;
end;

function TFhirSubstanceSpecification.Link : TFhirSubstanceSpecification;
begin
  result := TFhirSubstanceSpecification(inherited Link);
end;

function TFhirSubstanceSpecification.Clone : TFhirSubstanceSpecification;
begin
  result := TFhirSubstanceSpecification(inherited Clone);
end;

procedure TFhirSubstanceSpecification.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('status');
  fields.add('domain');
  fields.add('description');
  fields.add('source');
  fields.add('comment');
  fields.add('moiety');
  fields.add('property');
  fields.add('referenceInformation');
  fields.add('structure');
  fields.add('code');
  fields.add('name');
  fields.add('molecularWeight');
  fields.add('relationship');
  fields.add('nucleicAcid');
  fields.add('polymer');
  fields.add('protein');
  fields.add('sourceMaterial');
end;

{ TFhirSubstanceSpecification }

Procedure TFhirSubstanceSpecification.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirSubstanceSpecification.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSubstanceSpecification.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

Procedure TFhirSubstanceSpecification.SetDomain(value : TFhirCodeableConcept);
begin
  FDomain.free;
  FDomain := value;
end;

Procedure TFhirSubstanceSpecification.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirSubstanceSpecification.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirSubstanceSpecification.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirSubstanceSpecification.GetSourceList : TFhirReferenceList{TFhirDocumentReference};
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList{TFhirDocumentReference}.Create;
  result := FSourceList;
end;

Function TFhirSubstanceSpecification.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

Procedure TFhirSubstanceSpecification.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirSubstanceSpecification.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirSubstanceSpecification.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

Function TFhirSubstanceSpecification.GetMoietyList : TFhirSubstanceSpecificationMoietyList;
begin
  if FMoietyList = nil then
    FMoietyList := TFhirSubstanceSpecificationMoietyList.Create;
  result := FMoietyList;
end;

Function TFhirSubstanceSpecification.GetHasMoietyList : boolean;
begin
  result := (FMoietyList <> nil) and (FMoietyList.count > 0);
end;

Function TFhirSubstanceSpecification.GetProperty_List : TFhirSubstanceSpecificationPropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirSubstanceSpecificationPropertyList.Create;
  result := FProperty_List;
end;

Function TFhirSubstanceSpecification.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

Procedure TFhirSubstanceSpecification.SetReferenceInformation(value : TFhirReference{TFhirSubstanceReferenceInformation});
begin
  FReferenceInformation.free;
  FReferenceInformation := value;
end;

Procedure TFhirSubstanceSpecification.SetStructure(value : TFhirSubstanceSpecificationStructure);
begin
  FStructure.free;
  FStructure := value;
end;

Function TFhirSubstanceSpecification.GetCodeList : TFhirSubstanceSpecificationCodeList;
begin
  if FCodeList = nil then
    FCodeList := TFhirSubstanceSpecificationCodeList.Create;
  result := FCodeList;
end;

Function TFhirSubstanceSpecification.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

Function TFhirSubstanceSpecification.GetNameList : TFhirSubstanceSpecificationNameList;
begin
  if FNameList = nil then
    FNameList := TFhirSubstanceSpecificationNameList.Create;
  result := FNameList;
end;

Function TFhirSubstanceSpecification.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

Function TFhirSubstanceSpecification.GetMolecularWeightList : TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList;
begin
  if FMolecularWeightList = nil then
    FMolecularWeightList := TFhirSubstanceSpecificationStructureIsotopeMolecularWeightList.Create;
  result := FMolecularWeightList;
end;

Function TFhirSubstanceSpecification.GetHasMolecularWeightList : boolean;
begin
  result := (FMolecularWeightList <> nil) and (FMolecularWeightList.count > 0);
end;

Function TFhirSubstanceSpecification.GetRelationshipList : TFhirSubstanceSpecificationRelationshipList;
begin
  if FRelationshipList = nil then
    FRelationshipList := TFhirSubstanceSpecificationRelationshipList.Create;
  result := FRelationshipList;
end;

Function TFhirSubstanceSpecification.GetHasRelationshipList : boolean;
begin
  result := (FRelationshipList <> nil) and (FRelationshipList.count > 0);
end;

Procedure TFhirSubstanceSpecification.SetNucleicAcid(value : TFhirReference{TFhirSubstanceNucleicAcid});
begin
  FNucleicAcid.free;
  FNucleicAcid := value;
end;

Procedure TFhirSubstanceSpecification.SetPolymer(value : TFhirReference{TFhirSubstancePolymer});
begin
  FPolymer.free;
  FPolymer := value;
end;

Procedure TFhirSubstanceSpecification.SetProtein(value : TFhirReference{TFhirSubstanceProtein});
begin
  FProtein.free;
  FProtein := value;
end;

Procedure TFhirSubstanceSpecification.SetSourceMaterial(value : TFhirReference{TFhirSubstanceSourceMaterial});
begin
  FSourceMaterial.free;
  FSourceMaterial := value;
end;

function TFhirSubstanceSpecification.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FDomain.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FsourceList.sizeInBytes);
  inc(result, FComment.sizeInBytes);
  inc(result, FmoietyList.sizeInBytes);
  inc(result, Fproperty_List.sizeInBytes);
  inc(result, FReferenceInformation.sizeInBytes);
  inc(result, FStructure.sizeInBytes);
  inc(result, FcodeList.sizeInBytes);
  inc(result, FnameList.sizeInBytes);
  inc(result, FmolecularWeightList.sizeInBytes);
  inc(result, FrelationshipList.sizeInBytes);
  inc(result, FNucleicAcid.sizeInBytes);
  inc(result, FPolymer.sizeInBytes);
  inc(result, FProtein.sizeInBytes);
  inc(result, FSourceMaterial.sizeInBytes);
end;

{ TFhirSubstanceSpecificationListEnumerator }

Constructor TFhirSubstanceSpecificationListEnumerator.Create(list : TFhirSubstanceSpecificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceSpecificationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceSpecificationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceSpecificationListEnumerator.GetCurrent : TFhirSubstanceSpecification;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceSpecificationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceSpecificationList }
procedure TFhirSubstanceSpecificationList.AddItem(value: TFhirSubstanceSpecification);
begin
  assert(value.ClassName = 'TFhirSubstanceSpecification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceSpecification');
  add(value);
end;

function TFhirSubstanceSpecificationList.Append: TFhirSubstanceSpecification;
begin
  result := TFhirSubstanceSpecification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceSpecificationList.GetEnumerator : TFhirSubstanceSpecificationListEnumerator;
begin
  result := TFhirSubstanceSpecificationListEnumerator.Create(self.link);
end;

function TFhirSubstanceSpecificationList.Clone: TFhirSubstanceSpecificationList;
begin
  result := TFhirSubstanceSpecificationList(inherited Clone);
end;

function TFhirSubstanceSpecificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceSpecificationList.GetItemN(index: Integer): TFhirSubstanceSpecification;
begin
  result := TFhirSubstanceSpecification(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceSpecification;
end;
function TFhirSubstanceSpecificationList.IndexOf(value: TFhirSubstanceSpecification): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceSpecificationList.Insert(index: Integer): TFhirSubstanceSpecification;
begin
  result := TFhirSubstanceSpecification.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceSpecificationList.InsertItem(index: Integer; value: TFhirSubstanceSpecification);
begin
  assert(value is TFhirSubstanceSpecification);
  Inherited Insert(index, value);
end;

function TFhirSubstanceSpecificationList.Item(index: Integer): TFhirSubstanceSpecification;
begin
  result := TFhirSubstanceSpecification(ObjectByIndex[index]);
end;

function TFhirSubstanceSpecificationList.Link: TFhirSubstanceSpecificationList;
begin
  result := TFhirSubstanceSpecificationList(inherited Link);
end;

procedure TFhirSubstanceSpecificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceSpecificationList.SetItemByIndex(index: Integer; value: TFhirSubstanceSpecification);
begin
  assert(value is TFhirSubstanceSpecification);
  FhirSubstanceSpecifications[index] := value;
end;

procedure TFhirSubstanceSpecificationList.SetItemN(index: Integer; value: TFhirSubstanceSpecification);
begin
  assert(value is TFhirSubstanceSpecification);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCESPECIFICATION}

end.

