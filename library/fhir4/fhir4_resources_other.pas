unit fhir4_resources_other;

{$I fhir4.inc}

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to
     endorse or promote products derived from this software without specific
     prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

}

{$I fhir.inc}

interface

// FHIR v4.0.0 generated 2019-01-21T22:41:56+11:00

uses
  SysUtils, Classes,
  fsl_base, fsl_utilities, fsl_stream,
  fhir_objects, 
  fhir4_types, fhir4_resources_base, fhir4_resources_canonical;

Type
{$IFDEF FHIR_PARAMETERS}
  TFhirParametersParameter = class;
  TFhirParametersParameterList = class;
  TFhirParameters = class;
  TFhirParametersList = class;
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_AUDITEVENT}
  TFhirAuditEventAgent = class;
  TFhirAuditEventAgentList = class;
  TFhirAuditEventAgentNetwork = class;
  TFhirAuditEventAgentNetworkList = class;
  TFhirAuditEventSource = class;
  TFhirAuditEventSourceList = class;
  TFhirAuditEventEntity = class;
  TFhirAuditEventEntityList = class;
  TFhirAuditEventEntityDetail = class;
  TFhirAuditEventEntityDetailList = class;
  TFhirAuditEvent = class;
  TFhirAuditEventList = class;
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BINARY}
  TFhirBinary = class;
  TFhirBinaryList = class;
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BUNDLE}
  TFhirBundleLink = class;
  TFhirBundleLinkList = class;
  TFhirBundleEntry = class;
  TFhirBundleEntryList = class;
  TFhirBundleEntrySearch = class;
  TFhirBundleEntrySearchList = class;
  TFhirBundleEntryRequest = class;
  TFhirBundleEntryRequestList = class;
  TFhirBundleEntryResponse = class;
  TFhirBundleEntryResponseList = class;
  TFhirBundle = class;
  TFhirBundleList = class;
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CONSENT}
  TFhirConsentPolicy = class;
  TFhirConsentPolicyList = class;
  TFhirConsentVerification = class;
  TFhirConsentVerificationList = class;
  TFhirConsentProvision = class;
  TFhirConsentProvisionList = class;
  TFhirConsentProvisionActor = class;
  TFhirConsentProvisionActorList = class;
  TFhirConsentProvisionData = class;
  TFhirConsentProvisionDataList = class;
  TFhirConsent = class;
  TFhirConsentList = class;
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  TFhirContractContentDefinition = class;
  TFhirContractContentDefinitionList = class;
  TFhirContractTerm = class;
  TFhirContractTermList = class;
  TFhirContractTermSecurityLabel = class;
  TFhirContractTermSecurityLabelList = class;
  TFhirContractTermOffer = class;
  TFhirContractTermOfferList = class;
  TFhirContractTermOfferParty = class;
  TFhirContractTermOfferPartyList = class;
  TFhirContractTermOfferAnswer = class;
  TFhirContractTermOfferAnswerList = class;
  TFhirContractTermAsset = class;
  TFhirContractTermAssetList = class;
  TFhirContractTermAssetContext = class;
  TFhirContractTermAssetContextList = class;
  TFhirContractTermAssetValuedItem = class;
  TFhirContractTermAssetValuedItemList = class;
  TFhirContractTermAction = class;
  TFhirContractTermActionList = class;
  TFhirContractTermActionSubject = class;
  TFhirContractTermActionSubjectList = class;
  TFhirContractSigner = class;
  TFhirContractSignerList = class;
  TFhirContractFriendly = class;
  TFhirContractFriendlyList = class;
  TFhirContractLegal = class;
  TFhirContractLegalList = class;
  TFhirContractRule = class;
  TFhirContractRuleList = class;
  TFhirContract = class;
  TFhirContractList = class;
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_EFFECTEVIDENCESYNTHESIS}
  TFhirEffectEvidenceSynthesisSampleSize = class;
  TFhirEffectEvidenceSynthesisSampleSizeList = class;
  TFhirEffectEvidenceSynthesisResultsByExposure = class;
  TFhirEffectEvidenceSynthesisResultsByExposureList = class;
  TFhirEffectEvidenceSynthesisEffectEstimate = class;
  TFhirEffectEvidenceSynthesisEffectEstimateList = class;
  TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate = class;
  TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList = class;
  TFhirEffectEvidenceSynthesisCertainty = class;
  TFhirEffectEvidenceSynthesisCertaintyList = class;
  TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent = class;
  TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList = class;
  TFhirEffectEvidenceSynthesis = class;
  TFhirEffectEvidenceSynthesisList = class;
{$ENDIF FHIR_EFFECTEVIDENCESYNTHESIS}
{$IFDEF FHIR_EVIDENCE}
  TFhirEvidence = class;
  TFhirEvidenceList = class;
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEVARIABLE}
  TFhirEvidenceVariableCharacteristic = class;
  TFhirEvidenceVariableCharacteristicList = class;
  TFhirEvidenceVariable = class;
  TFhirEvidenceVariableList = class;
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_GUIDANCERESPONSE}
  TFhirGuidanceResponse = class;
  TFhirGuidanceResponseList = class;
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_LINKAGE}
  TFhirLinkageItem = class;
  TFhirLinkageItemList = class;
  TFhirLinkage = class;
  TFhirLinkageList = class;
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  TFhirListEntry = class;
  TFhirListEntryList = class;
  TFhirList = class;
  TFhirListList = class;
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_MEASUREREPORT}
  TFhirMeasureReportGroup = class;
  TFhirMeasureReportGroupList = class;
  TFhirMeasureReportGroupPopulation = class;
  TFhirMeasureReportGroupPopulationList = class;
  TFhirMeasureReportGroupStratifier = class;
  TFhirMeasureReportGroupStratifierList = class;
  TFhirMeasureReportGroupStratifierStratum = class;
  TFhirMeasureReportGroupStratifierStratumList = class;
  TFhirMeasureReportGroupStratifierStratumComponent = class;
  TFhirMeasureReportGroupStratifierStratumComponentList = class;
  TFhirMeasureReportGroupStratifierStratumPopulation = class;
  TFhirMeasureReportGroupStratifierStratumPopulationList = class;
  TFhirMeasureReport = class;
  TFhirMeasureReportList = class;
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MESSAGEHEADER}
  TFhirMessageHeaderDestination = class;
  TFhirMessageHeaderDestinationList = class;
  TFhirMessageHeaderSource = class;
  TFhirMessageHeaderSourceList = class;
  TFhirMessageHeaderResponse = class;
  TFhirMessageHeaderResponseList = class;
  TFhirMessageHeader = class;
  TFhirMessageHeaderList = class;
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_OPERATIONOUTCOME}
  TFhirOperationOutcomeIssue = class;
  TFhirOperationOutcomeIssueList = class;
  TFhirOperationOutcome = class;
  TFhirOperationOutcomeList = class;
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_PROVENANCE}
  TFhirProvenanceAgent = class;
  TFhirProvenanceAgentList = class;
  TFhirProvenanceEntity = class;
  TFhirProvenanceEntityList = class;
  TFhirProvenance = class;
  TFhirProvenanceList = class;
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_REQUESTGROUP}
  TFhirRequestGroupAction = class;
  TFhirRequestGroupActionList = class;
  TFhirRequestGroupActionCondition = class;
  TFhirRequestGroupActionConditionList = class;
  TFhirRequestGroupActionRelatedAction = class;
  TFhirRequestGroupActionRelatedActionList = class;
  TFhirRequestGroup = class;
  TFhirRequestGroupList = class;
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHDEFINITION}
  TFhirResearchDefinition = class;
  TFhirResearchDefinitionList = class;
{$ENDIF FHIR_RESEARCHDEFINITION}
{$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
  TFhirResearchElementDefinitionCharacteristic = class;
  TFhirResearchElementDefinitionCharacteristicList = class;
  TFhirResearchElementDefinition = class;
  TFhirResearchElementDefinitionList = class;
{$ENDIF FHIR_RESEARCHELEMENTDEFINITION}
{$IFDEF FHIR_RESEARCHSTUDY}
  TFhirResearchStudyArm = class;
  TFhirResearchStudyArmList = class;
  TFhirResearchStudyObjective = class;
  TFhirResearchStudyObjectiveList = class;
  TFhirResearchStudy = class;
  TFhirResearchStudyList = class;
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  TFhirResearchSubject = class;
  TFhirResearchSubjectList = class;
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_RISKEVIDENCESYNTHESIS}
  TFhirRiskEvidenceSynthesisSampleSize = class;
  TFhirRiskEvidenceSynthesisSampleSizeList = class;
  TFhirRiskEvidenceSynthesisRiskEstimate = class;
  TFhirRiskEvidenceSynthesisRiskEstimateList = class;
  TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate = class;
  TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList = class;
  TFhirRiskEvidenceSynthesisCertainty = class;
  TFhirRiskEvidenceSynthesisCertaintyList = class;
  TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent = class;
  TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList = class;
  TFhirRiskEvidenceSynthesis = class;
  TFhirRiskEvidenceSynthesisList = class;
{$ENDIF FHIR_RISKEVIDENCESYNTHESIS}
{$IFDEF FHIR_SUBSCRIPTION}
  TFhirSubscriptionChannel = class;
  TFhirSubscriptionChannelList = class;
  TFhirSubscription = class;
  TFhirSubscriptionList = class;
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_TASK}
  TFhirTaskRestriction = class;
  TFhirTaskRestrictionList = class;
  TFhirTaskInput = class;
  TFhirTaskInputList = class;
  TFhirTaskOutput = class;
  TFhirTaskOutputList = class;
  TFhirTask = class;
  TFhirTaskList = class;
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
  TFhirTestReportParticipant = class;
  TFhirTestReportParticipantList = class;
  TFhirTestReportSetup = class;
  TFhirTestReportSetupList = class;
  TFhirTestReportSetupAction = class;
  TFhirTestReportSetupActionList = class;
  TFhirTestReportSetupActionOperation = class;
  TFhirTestReportSetupActionOperationList = class;
  TFhirTestReportSetupActionAssert = class;
  TFhirTestReportSetupActionAssertList = class;
  TFhirTestReportTest = class;
  TFhirTestReportTestList = class;
  TFhirTestReportTestAction = class;
  TFhirTestReportTestActionList = class;
  TFhirTestReportTeardown = class;
  TFhirTestReportTeardownList = class;
  TFhirTestReportTeardownAction = class;
  TFhirTestReportTeardownActionList = class;
  TFhirTestReport = class;
  TFhirTestReportList = class;
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_VERIFICATIONRESULT}
  TFhirVerificationResultPrimarySource = class;
  TFhirVerificationResultPrimarySourceList = class;
  TFhirVerificationResultAttestation = class;
  TFhirVerificationResultAttestationList = class;
  TFhirVerificationResultValidator = class;
  TFhirVerificationResultValidatorList = class;
  TFhirVerificationResult = class;
  TFhirVerificationResultList = class;
{$ENDIF FHIR_VERIFICATIONRESULT}

{$IFDEF FHIR_PARAMETERS}

  // A parameter passed to or received from the operation.
  TFhirParametersParameter = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FValue : TFhirType;
    FResource : TFhirResource;
    FpartList : TFhirParametersParameterList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetValue(value : TFhirType);
    Procedure SetResource(value : TFhirResource);
    function GetPartList : TFhirParametersParameterList;
    function GetHasPartList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirParametersParameter; overload;
    function Clone : TFhirParametersParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  published
    // Typed access to The name of the parameter (reference to the operation definition).
    property name : String read GetNameST write SetNameST;
    // The name of the parameter (reference to the operation definition).
    property nameElement : TFhirString read FName write SetName;

    // Typed access to If the parameter is a data type. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // If the parameter is a data type.
    property valueElement : TFhirType read FValue write SetValue;

    // Typed access to If the parameter is a whole resource. (defined for API consistency)
    property resource : TFhirResource read FResource write SetResource;
    // If the parameter is a whole resource.
    property resourceElement : TFhirResource read FResource write SetResource;

    // A named part of a multi-part parameter.
    property partList : TFhirParametersParameterList read GetPartList;
    property hasPartList : boolean read GetHasPartList;

  end;

  TFhirParametersParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirParametersParameterList;
    function GetCurrent : TFhirParametersParameter;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirParametersParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirParametersParameter read GetCurrent;
  end;

  TFhirParametersParameterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirParametersParameter;
    procedure SetItemN(index : Integer; value : TFhirParametersParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirParametersParameterList; Overload;
    function Clone : TFhirParametersParameterList; Overload;
    function GetEnumerator : TFhirParametersParameterListEnumerator;
    

    //  Add a FhirParametersParameter to the end of the list.
    function Append : TFhirParametersParameter;

    
    // Add an already existing FhirParametersParameter to the end of the list.
    procedure AddItem(value : TFhirParametersParameter); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirParametersParameter) : Integer;

    // Insert FhirParametersParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirParametersParameter;
    

    // Insert an existing FhirParametersParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirParametersParameter);
    
    // Get the iIndexth FhirParametersParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirParametersParameter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirParametersParameter;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirParametersParameters[index : Integer] : TFhirParametersParameter read GetItemN write SetItemN; default;
  End;

  // This resource is a non-persisted resource used to pass information into and back from an [operation](operations.html). It has no other use, and there is no RESTful endpoint associated with it.
  TFhirParameters = class (TFhirResource)
  protected
    FparameterList : TFhirParametersParameterList;
    function GetParameterList : TFhirParametersParameterList;
    function GetHasParameterList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirParameters; overload;
    function Clone : TFhirParameters; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  published
    // A parameter passed to or received from the operation.
    property parameterList : TFhirParametersParameterList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

  end;

  TFhirParametersListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirParametersList;
    function GetCurrent : TFhirParameters;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirParametersList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirParameters read GetCurrent;
  end;

  TFhirParametersList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirParameters;
    procedure SetItemN(index : Integer; value : TFhirParameters);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirParametersList; Overload;
    function Clone : TFhirParametersList; Overload;
    function GetEnumerator : TFhirParametersListEnumerator;
    

    //  Add a FhirParameters to the end of the list.
    function Append : TFhirParameters;

    
    // Add an already existing FhirParameters to the end of the list.
    procedure AddItem(value : TFhirParameters); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirParameters) : Integer;
    

    // Insert FhirParameters before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirParameters;
    

    // Insert an existing FhirParameters before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirParameters);
    
    // Get the iIndexth FhirParameters. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirParameters);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirParameters;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirParameters[index : Integer] : TFhirParameters read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PARAMETERS}

{$IFDEF FHIR_AUDITEVENT}

  // An actor taking an active role in the event or activity that is logged.
  TFhirAuditEventAgent = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FroleList : TFhirCodeableConceptList;
    FWho : TFhirReference{TFhirPractitionerRole};
    FAltId : TFhirString;
    FName : TFhirString;
    FRequestor : TFhirBoolean;
    FLocation : TFhirReference{TFhirLocation};
    FpolicyList : TFhirUriList;
    FMedia : TFhirCoding;
    FNetwork : TFhirAuditEventAgentNetwork;
    FpurposeOfUseList : TFhirCodeableConceptList;
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetRoleList : TFhirCodeableConceptList;
    function GetHasRoleList : Boolean;
    Procedure SetWho(value : TFhirReference{TFhirPractitionerRole});
    Procedure SetAltId(value : TFhirString);
    Function GetAltIdST : String;
    Procedure SetAltIdST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetRequestor(value : TFhirBoolean);
    Function GetRequestorST : Boolean;
    Procedure SetRequestorST(value : Boolean);
    Procedure SetLocation(value : TFhirReference{TFhirLocation});
    function GetPolicyList : TFhirUriList;
    function GetHasPolicyList : Boolean;
    Procedure SetMedia(value : TFhirCoding);
    Procedure SetNetwork(value : TFhirAuditEventAgentNetwork);
    function GetPurposeOfUseList : TFhirCodeableConceptList;
    function GetHasPurposeOfUseList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventAgent; overload;
    function Clone : TFhirAuditEventAgent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Specification of the participation type the user plays when performing the event. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Specification of the participation type the user plays when performing the event.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The security role that the user was acting under, that come from local codes defined by the access control security system (e.g. RBAC, ABAC) used in the local context.
    property roleList : TFhirCodeableConceptList read GetRoleList;
    property hasRoleList : boolean read GetHasRoleList;

    // Typed access to Reference to who this agent is that was involved in the event. (defined for API consistency)
    property who : TFhirReference{TFhirPractitionerRole} read FWho write SetWho;
    // Reference to who this agent is that was involved in the event.
    property whoElement : TFhirReference{TFhirPractitionerRole} read FWho write SetWho;

    // Typed access to Alternative agent Identifier. For a human, this should be a user identifier text string from authentication system. This identifier would be one known to a common authentication system (e.g. single sign-on), if available.
    property altId : String read GetAltIdST write SetAltIdST;
    // Alternative agent Identifier. For a human, this should be a user identifier text string from authentication system. This identifier would be one known to a common authentication system (e.g. single sign-on), if available.
    property altIdElement : TFhirString read FAltId write SetAltId;

    // Typed access to Human-meaningful name for the agent.
    property name : String read GetNameST write SetNameST;
    // Human-meaningful name for the agent.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Indicator that the user is or is not the requestor, or initiator, for the event being audited.
    property requestor : Boolean read GetRequestorST write SetRequestorST;
    // Indicator that the user is or is not the requestor, or initiator, for the event being audited.
    property requestorElement : TFhirBoolean read FRequestor write SetRequestor;

    // Typed access to Where the event occurred. (defined for API consistency)
    property location : TFhirReference{TFhirLocation} read FLocation write SetLocation;
    // Where the event occurred.
    property locationElement : TFhirReference{TFhirLocation} read FLocation write SetLocation;

    // The policy or plan that authorized the activity being recorded. Typically, a single activity may have multiple applicable policies, such as patient consent, guarantor funding, etc. The policy would also indicate the security token used.
    property policyList : TFhirUriList read GetPolicyList;
    property hasPolicyList : boolean read GetHasPolicyList;

    // Typed access to Type of media involved. Used when the event is about exporting/importing onto media. (defined for API consistency)
    property media : TFhirCoding read FMedia write SetMedia;
    // Type of media involved. Used when the event is about exporting/importing onto media.
    property mediaElement : TFhirCoding read FMedia write SetMedia;

    // Typed access to Logical network location for application activity, if the activity has a network location. (defined for API consistency)
    property network : TFhirAuditEventAgentNetwork read FNetwork write SetNetwork;
    // Logical network location for application activity, if the activity has a network location.
    property networkElement : TFhirAuditEventAgentNetwork read FNetwork write SetNetwork;

    // The reason (purpose of use), specific to this agent, that was used during the event being recorded.
    property purposeOfUseList : TFhirCodeableConceptList read GetPurposeOfUseList;
    property hasPurposeOfUseList : boolean read GetHasPurposeOfUseList;

  end;

  TFhirAuditEventAgentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventAgentList;
    function GetCurrent : TFhirAuditEventAgent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventAgentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventAgent read GetCurrent;
  end;

  TFhirAuditEventAgentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAuditEventAgent;
    procedure SetItemN(index : Integer; value : TFhirAuditEventAgent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAuditEventAgentList; Overload;
    function Clone : TFhirAuditEventAgentList; Overload;
    function GetEnumerator : TFhirAuditEventAgentListEnumerator;
    

    //  Add a FhirAuditEventAgent to the end of the list.
    function Append : TFhirAuditEventAgent;

    
    // Add an already existing FhirAuditEventAgent to the end of the list.
    procedure AddItem(value : TFhirAuditEventAgent); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventAgent) : Integer;
    

    // Insert FhirAuditEventAgent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventAgent;
    

    // Insert an existing FhirAuditEventAgent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventAgent);
    
    // Get the iIndexth FhirAuditEventAgent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventAgent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventAgent;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirAuditEventAgents[index : Integer] : TFhirAuditEventAgent read GetItemN write SetItemN; default;
  End;

  // Logical network location for application activity, if the activity has a network location.
  TFhirAuditEventAgentNetwork = class (TFhirBackboneElement)
  protected
    FAddress : TFhirString;
    FType_ : TFhirEnum;
    Procedure SetAddress(value : TFhirString);
    Function GetAddressST : String;
    Procedure SetAddressST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirNetworkTypeEnum;
    Procedure SetType_ST(value : TFhirNetworkTypeEnum);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventAgentNetwork; overload;
    function Clone : TFhirAuditEventAgentNetwork; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An identifier for the network access point of the user device for the audit event.
    property address : String read GetAddressST write SetAddressST;
    // An identifier for the network access point of the user device for the audit event.
    property addressElement : TFhirString read FAddress write SetAddress;

    // An identifier for the type of network access point that originated the audit event.
    property type_ : TFhirNetworkTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

  end;

  TFhirAuditEventAgentNetworkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventAgentNetworkList;
    function GetCurrent : TFhirAuditEventAgentNetwork;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventAgentNetworkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventAgentNetwork read GetCurrent;
  end;

  TFhirAuditEventAgentNetworkList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAuditEventAgentNetwork;
    procedure SetItemN(index : Integer; value : TFhirAuditEventAgentNetwork);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAuditEventAgentNetworkList; Overload;
    function Clone : TFhirAuditEventAgentNetworkList; Overload;
    function GetEnumerator : TFhirAuditEventAgentNetworkListEnumerator;
    

    //  Add a FhirAuditEventAgentNetwork to the end of the list.
    function Append : TFhirAuditEventAgentNetwork;

    
    // Add an already existing FhirAuditEventAgentNetwork to the end of the list.
    procedure AddItem(value : TFhirAuditEventAgentNetwork); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventAgentNetwork) : Integer;
    

    // Insert FhirAuditEventAgentNetwork before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventAgentNetwork;
    

    // Insert an existing FhirAuditEventAgentNetwork before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventAgentNetwork);
    
    // Get the iIndexth FhirAuditEventAgentNetwork. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventAgentNetwork);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventAgentNetwork;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirAuditEventAgentNetworks[index : Integer] : TFhirAuditEventAgentNetwork read GetItemN write SetItemN; default;
  End;

  // The system that is reporting the event.
  TFhirAuditEventSource = class (TFhirBackboneElement)
  protected
    FSite : TFhirString;
    FObserver : TFhirReference{TFhirPractitionerRole};
    Ftype_List : TFhirCodingList;
    Procedure SetSite(value : TFhirString);
    Function GetSiteST : String;
    Procedure SetSiteST(value : String);
    Procedure SetObserver(value : TFhirReference{TFhirPractitionerRole});
    function GetType_List : TFhirCodingList;
    function GetHasType_List : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventSource; overload;
    function Clone : TFhirAuditEventSource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Logical source location within the healthcare enterprise network.  For example, a hospital or other provider location within a multi-entity provider group.
    property site : String read GetSiteST write SetSiteST;
    // Logical source location within the healthcare enterprise network.  For example, a hospital or other provider location within a multi-entity provider group.
    property siteElement : TFhirString read FSite write SetSite;

    // Typed access to Identifier of the source where the event was detected. (defined for API consistency)
    property observer : TFhirReference{TFhirPractitionerRole} read FObserver write SetObserver;
    // Identifier of the source where the event was detected.
    property observerElement : TFhirReference{TFhirPractitionerRole} read FObserver write SetObserver;

    // Code specifying the type of source where event originated.
    property type_List : TFhirCodingList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

  end;

  TFhirAuditEventSourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventSourceList;
    function GetCurrent : TFhirAuditEventSource;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventSourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventSource read GetCurrent;
  end;

  TFhirAuditEventSourceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAuditEventSource;
    procedure SetItemN(index : Integer; value : TFhirAuditEventSource);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAuditEventSourceList; Overload;
    function Clone : TFhirAuditEventSourceList; Overload;
    function GetEnumerator : TFhirAuditEventSourceListEnumerator;
    

    //  Add a FhirAuditEventSource to the end of the list.
    function Append : TFhirAuditEventSource;

    
    // Add an already existing FhirAuditEventSource to the end of the list.
    procedure AddItem(value : TFhirAuditEventSource); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventSource) : Integer;
    

    // Insert FhirAuditEventSource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventSource;
    

    // Insert an existing FhirAuditEventSource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventSource);
    
    // Get the iIndexth FhirAuditEventSource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventSource);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventSource;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirAuditEventSources[index : Integer] : TFhirAuditEventSource read GetItemN write SetItemN; default;
  End;

  // Specific instances of data or objects that have been accessed.
  TFhirAuditEventEntity = class (TFhirBackboneElement)
  protected
    FWhat : TFhirReference{TFhirReference};
    FType_ : TFhirCoding;
    FRole : TFhirCoding;
    FLifecycle : TFhirCoding;
    FsecurityLabelList : TFhirCodingList;
    FName : TFhirString;
    FDescription : TFhirString;
    FQuery : TFhirBase64Binary;
    FdetailList : TFhirAuditEventEntityDetailList;
    Procedure SetWhat(value : TFhirReference{TFhirReference});
    Procedure SetType_(value : TFhirCoding);
    Procedure SetRole(value : TFhirCoding);
    Procedure SetLifecycle(value : TFhirCoding);
    function GetSecurityLabelList : TFhirCodingList;
    function GetHasSecurityLabelList : Boolean;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetQuery(value : TFhirBase64Binary);
    Function GetQueryST : TBytes;
    Procedure SetQueryST(value : TBytes);
    function GetDetailList : TFhirAuditEventEntityDetailList;
    function GetHasDetailList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventEntity; overload;
    function Clone : TFhirAuditEventEntity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Identifies a specific instance of the entity. The reference should be version specific. (defined for API consistency)
    property what : TFhirReference{TFhirReference} read FWhat write SetWhat;
    // Identifies a specific instance of the entity. The reference should be version specific.
    property whatElement : TFhirReference{TFhirReference} read FWhat write SetWhat;

    // Typed access to The type of the object that was involved in this audit event. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // The type of the object that was involved in this audit event.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to Code representing the role the entity played in the event being audited. (defined for API consistency)
    property role : TFhirCoding read FRole write SetRole;
    // Code representing the role the entity played in the event being audited.
    property roleElement : TFhirCoding read FRole write SetRole;

    // Typed access to Identifier for the data life-cycle stage for the entity. (defined for API consistency)
    property lifecycle : TFhirCoding read FLifecycle write SetLifecycle;
    // Identifier for the data life-cycle stage for the entity.
    property lifecycleElement : TFhirCoding read FLifecycle write SetLifecycle;

    // Security labels for the identified entity.
    property securityLabelList : TFhirCodingList read GetSecurityLabelList;
    property hasSecurityLabelList : boolean read GetHasSecurityLabelList;

    // Typed access to A name of the entity in the audit event.
    property name : String read GetNameST write SetNameST;
    // A name of the entity in the audit event.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Text that describes the entity in more detail.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Text that describes the entity in more detail.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The query parameters for a query-type entities.
    property query : TBytes read GetQueryST write SetQueryST;
    // The query parameters for a query-type entities.
    property queryElement : TFhirBase64Binary read FQuery write SetQuery;

    // Tagged value pairs for conveying additional information about the entity.
    property detailList : TFhirAuditEventEntityDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirAuditEventEntityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventEntityList;
    function GetCurrent : TFhirAuditEventEntity;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventEntityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventEntity read GetCurrent;
  end;

  TFhirAuditEventEntityList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAuditEventEntity;
    procedure SetItemN(index : Integer; value : TFhirAuditEventEntity);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAuditEventEntityList; Overload;
    function Clone : TFhirAuditEventEntityList; Overload;
    function GetEnumerator : TFhirAuditEventEntityListEnumerator;
    

    //  Add a FhirAuditEventEntity to the end of the list.
    function Append : TFhirAuditEventEntity;

    
    // Add an already existing FhirAuditEventEntity to the end of the list.
    procedure AddItem(value : TFhirAuditEventEntity); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventEntity) : Integer;
    

    // Insert FhirAuditEventEntity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventEntity;
    

    // Insert an existing FhirAuditEventEntity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventEntity);
    
    // Get the iIndexth FhirAuditEventEntity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventEntity);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventEntity;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirAuditEventEntities[index : Integer] : TFhirAuditEventEntity read GetItemN write SetItemN; default;
  End;

  // Tagged value pairs for conveying additional information about the entity.
  TFhirAuditEventEntityDetail = class (TFhirBackboneElement)
  protected
    FType_ : TFhirString;
    FValue : TFhirType;
    Procedure SetType_(value : TFhirString);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetValue(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventEntityDetail; overload;
    function Clone : TFhirAuditEventEntityDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The type of extra detail provided in the value.
    property type_ : String read GetType_ST write SetType_ST;
    // The type of extra detail provided in the value.
    property type_Element : TFhirString read FType_ write SetType_;

    // Typed access to The  value of the extra detail. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // The  value of the extra detail.
    property valueElement : TFhirType read FValue write SetValue;

  end;

  TFhirAuditEventEntityDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventEntityDetailList;
    function GetCurrent : TFhirAuditEventEntityDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventEntityDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventEntityDetail read GetCurrent;
  end;

  TFhirAuditEventEntityDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAuditEventEntityDetail;
    procedure SetItemN(index : Integer; value : TFhirAuditEventEntityDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAuditEventEntityDetailList; Overload;
    function Clone : TFhirAuditEventEntityDetailList; Overload;
    function GetEnumerator : TFhirAuditEventEntityDetailListEnumerator;
    

    //  Add a FhirAuditEventEntityDetail to the end of the list.
    function Append : TFhirAuditEventEntityDetail;

    
    // Add an already existing FhirAuditEventEntityDetail to the end of the list.
    procedure AddItem(value : TFhirAuditEventEntityDetail); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventEntityDetail) : Integer;
    

    // Insert FhirAuditEventEntityDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventEntityDetail;
    

    // Insert an existing FhirAuditEventEntityDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventEntityDetail);
    
    // Get the iIndexth FhirAuditEventEntityDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventEntityDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventEntityDetail;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirAuditEventEntityDetails[index : Integer] : TFhirAuditEventEntityDetail read GetItemN write SetItemN; default;
  End;

  // A record of an event made for purposes of maintaining a security log. Typical uses include detection of intrusion attempts and monitoring for inappropriate usage.
  TFhirAuditEvent = class (TFhirDomainResource)
  protected
    FType_ : TFhirCoding;
    FsubtypeList : TFhirCodingList;
    FAction : TFhirEnum;
    FPeriod : TFhirPeriod;
    FRecorded : TFhirInstant;
    FOutcome : TFhirEnum;
    FOutcomeDesc : TFhirString;
    FpurposeOfEventList : TFhirCodeableConceptList;
    FagentList : TFhirAuditEventAgentList;
    FSource : TFhirAuditEventSource;
    FentityList : TFhirAuditEventEntityList;
    Procedure SetType_(value : TFhirCoding);
    function GetSubtypeList : TFhirCodingList;
    function GetHasSubtypeList : Boolean;
    Procedure SetAction(value : TFhirEnum);
    Function GetActionST : TFhirAuditEventActionEnum;
    Procedure SetActionST(value : TFhirAuditEventActionEnum);
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetRecorded(value : TFhirInstant);
    Function GetRecordedST : TFslDateTime;
    Procedure SetRecordedST(value : TFslDateTime);
    Procedure SetOutcome(value : TFhirEnum);
    Function GetOutcomeST : TFhirAuditEventOutcomeEnum;
    Procedure SetOutcomeST(value : TFhirAuditEventOutcomeEnum);
    Procedure SetOutcomeDesc(value : TFhirString);
    Function GetOutcomeDescST : String;
    Procedure SetOutcomeDescST(value : String);
    function GetPurposeOfEventList : TFhirCodeableConceptList;
    function GetHasPurposeOfEventList : Boolean;
    function GetAgentList : TFhirAuditEventAgentList;
    function GetHasAgentList : Boolean;
    Procedure SetSource(value : TFhirAuditEventSource);
    function GetEntityList : TFhirAuditEventEntityList;
    function GetHasEntityList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEvent; overload;
    function Clone : TFhirAuditEvent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Identifier for a family of the event.  For example, a menu item, program, rule, policy, function code, application name or URL. It identifies the performed function. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // Identifier for a family of the event.  For example, a menu item, program, rule, policy, function code, application name or URL. It identifies the performed function.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Identifier for the category of event.
    property subtypeList : TFhirCodingList read GetSubtypeList;
    property hasSubtypeList : boolean read GetHasSubtypeList;

    // Indicator for type of action performed during the event that generated the audit.
    property action : TFhirAuditEventActionEnum read GetActionST write SetActionST;
    property actionElement : TFhirEnum read FAction write SetAction;

    // Typed access to The period during which the activity occurred. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period during which the activity occurred.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to The time when the event was recorded.
    property recorded : TFslDateTime read GetRecordedST write SetRecordedST;
    // The time when the event was recorded.
    property recordedElement : TFhirInstant read FRecorded write SetRecorded;

    // Indicates whether the event succeeded or failed.
    property outcome : TFhirAuditEventOutcomeEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A free text description of the outcome of the event.
    property outcomeDesc : String read GetOutcomeDescST write SetOutcomeDescST;
    // A free text description of the outcome of the event.
    property outcomeDescElement : TFhirString read FOutcomeDesc write SetOutcomeDesc;

    // The purposeOfUse (reason) that was used during the event being recorded.
    property purposeOfEventList : TFhirCodeableConceptList read GetPurposeOfEventList;
    property hasPurposeOfEventList : boolean read GetHasPurposeOfEventList;

    // An actor taking an active role in the event or activity that is logged.
    property agentList : TFhirAuditEventAgentList read GetAgentList;
    property hasAgentList : boolean read GetHasAgentList;

    // Typed access to The system that is reporting the event. (defined for API consistency)
    property source : TFhirAuditEventSource read FSource write SetSource;
    // The system that is reporting the event.
    property sourceElement : TFhirAuditEventSource read FSource write SetSource;

    // Specific instances of data or objects that have been accessed.
    property entityList : TFhirAuditEventEntityList read GetEntityList;
    property hasEntityList : boolean read GetHasEntityList;

  end;

  TFhirAuditEventListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventList;
    function GetCurrent : TFhirAuditEvent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEvent read GetCurrent;
  end;

  TFhirAuditEventList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAuditEvent;
    procedure SetItemN(index : Integer; value : TFhirAuditEvent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAuditEventList; Overload;
    function Clone : TFhirAuditEventList; Overload;
    function GetEnumerator : TFhirAuditEventListEnumerator;
    

    //  Add a FhirAuditEvent to the end of the list.
    function Append : TFhirAuditEvent;

    
    // Add an already existing FhirAuditEvent to the end of the list.
    procedure AddItem(value : TFhirAuditEvent); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEvent) : Integer;
    

    // Insert FhirAuditEvent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEvent;
    

    // Insert an existing FhirAuditEvent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEvent);
    
    // Get the iIndexth FhirAuditEvent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEvent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEvent;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirAuditEvents[index : Integer] : TFhirAuditEvent read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_AUDITEVENT}

{$IFDEF FHIR_BINARY}

  // A resource that represents the data of a single raw artifact as digital content accessible in its native format.  A Binary resource can contain any content, whether text, image, pdf, zip archive, etc.
  TFhirBinary = class (TFhirResource)
  protected
    FContentType : TFhirCode;
    FSecurityContext : TFhirReference{TFhirReference};
    FData : TFhirBase64Binary;
    Procedure SetContentType(value : TFhirCode);
    Function GetContentTypeST : String;
    Procedure SetContentTypeST(value : String);
    Procedure SetSecurityContext(value : TFhirReference{TFhirReference});
    Procedure SetData(value : TFhirBase64Binary);
    Function GetDataST : TBytes;
    Procedure SetDataST(value : TBytes);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBinary; overload;
    function Clone : TFhirBinary; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to MimeType of the binary content represented as a standard MimeType (BCP 13).
    property contentType : String read GetContentTypeST write SetContentTypeST;
    // MimeType of the binary content represented as a standard MimeType (BCP 13).
    property contentTypeElement : TFhirCode read FContentType write SetContentType;

    // Typed access to This element identifies another resource that can be used as a proxy of the security sensitivity to use when deciding and enforcing access control rules for the Binary resource. Given that the Binary resource contains very few elements that can be used to determine the sensitivity of the data and relationships to individuals, the referenced resource stands in as a proxy equivalent for this purpose. This referenced resource may be related to the Binary (e.g. Media, DocumentReference), or may be some non-related Resource purely as a security proxy. E.g. to identify that the binary resource relates to a patient, and access should only be granted to applications that have access to the patient. (defined for API consistency)
    property securityContext : TFhirReference{TFhirReference} read FSecurityContext write SetSecurityContext;
    // This element identifies another resource that can be used as a proxy of the security sensitivity to use when deciding and enforcing access control rules for the Binary resource. Given that the Binary resource contains very few elements that can be used to determine the sensitivity of the data and relationships to individuals, the referenced resource stands in as a proxy equivalent for this purpose. This referenced resource may be related to the Binary (e.g. Media, DocumentReference), or may be some non-related Resource purely as a security proxy. E.g. to identify that the binary resource relates to a patient, and access should only be granted to applications that have access to the patient.
    property securityContextElement : TFhirReference{TFhirReference} read FSecurityContext write SetSecurityContext;

    // Typed access to The actual content, base64 encoded.
    property data : TBytes read GetDataST write SetDataST;
    // The actual content, base64 encoded.
    property dataElement : TFhirBase64Binary read FData write SetData;

  end;

  TFhirBinaryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBinaryList;
    function GetCurrent : TFhirBinary;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBinaryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBinary read GetCurrent;
  end;

  TFhirBinaryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBinary;
    procedure SetItemN(index : Integer; value : TFhirBinary);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBinaryList; Overload;
    function Clone : TFhirBinaryList; Overload;
    function GetEnumerator : TFhirBinaryListEnumerator;
    

    //  Add a FhirBinary to the end of the list.
    function Append : TFhirBinary;

    
    // Add an already existing FhirBinary to the end of the list.
    procedure AddItem(value : TFhirBinary); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBinary) : Integer;
    

    // Insert FhirBinary before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBinary;
    

    // Insert an existing FhirBinary before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBinary);
    
    // Get the iIndexth FhirBinary. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBinary);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBinary;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirBinaries[index : Integer] : TFhirBinary read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BINARY}

{$IFDEF FHIR_BUNDLE}

  // A series of links that provide context to this bundle.
  TFhirBundleLink = class (TFhirBackboneElement)
  protected
    FRelation : TFhirString;
    FUrl : TFhirUri;
    Procedure SetRelation(value : TFhirString);
    Function GetRelationST : String;
    Procedure SetRelationST(value : String);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleLink; overload;
    function Clone : TFhirBundleLink; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A name which details the functional use for this link - see [http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1](http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1).
    property relation : String read GetRelationST write SetRelationST;
    // A name which details the functional use for this link - see [http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1](http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1).
    property relationElement : TFhirString read FRelation write SetRelation;

    // Typed access to The reference details for the link.
    property url : String read GetUrlST write SetUrlST;
    // The reference details for the link.
    property urlElement : TFhirUri read FUrl write SetUrl;

  end;

  TFhirBundleLinkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleLinkList;
    function GetCurrent : TFhirBundleLink;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBundleLinkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleLink read GetCurrent;
  end;

  TFhirBundleLinkList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBundleLink;
    procedure SetItemN(index : Integer; value : TFhirBundleLink);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBundleLinkList; Overload;
    function Clone : TFhirBundleLinkList; Overload;
    function GetEnumerator : TFhirBundleLinkListEnumerator;
    

    //  Add a FhirBundleLink to the end of the list.
    function Append : TFhirBundleLink;

    
    // Add an already existing FhirBundleLink to the end of the list.
    procedure AddItem(value : TFhirBundleLink); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleLink) : Integer;
    

    // Insert FhirBundleLink before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleLink;
    

    // Insert an existing FhirBundleLink before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleLink);
    
    // Get the iIndexth FhirBundleLink. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleLink);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleLink;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirBundleLinks[index : Integer] : TFhirBundleLink read GetItemN write SetItemN; default;
  End;

  // An entry in a bundle resource - will either contain a resource or information about a resource (transactions and history only).
  TFhirBundleEntry = class (TFhirBackboneElement)
  protected
    Flink_List : TFhirBundleLinkList;
    FFullUrl : TFhirUri;
    FResource : TFhirResource;
    FSearch : TFhirBundleEntrySearch;
    FRequest : TFhirBundleEntryRequest;
    FResponse : TFhirBundleEntryResponse;
    function GetLink_List : TFhirBundleLinkList;
    function GetHasLink_List : Boolean;
    Procedure SetFullUrl(value : TFhirUri);
    Function GetFullUrlST : String;
    Procedure SetFullUrlST(value : String);
    Procedure SetResource(value : TFhirResource);
    Procedure SetSearch(value : TFhirBundleEntrySearch);
    Procedure SetRequest(value : TFhirBundleEntryRequest);
    Procedure SetResponse(value : TFhirBundleEntryResponse);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleEntry; overload;
    function Clone : TFhirBundleEntry; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A series of links that provide context to this entry.
    property link_List : TFhirBundleLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

    // Typed access to The Absolute URL for the resource.  The fullUrl SHALL NOT disagree with the id in the resource - i.e. if the fullUrl is not a urn:uuid, the URL shall be version-independent URL consistent with the Resource.id. The fullUrl is a version independent reference to the resource. The fullUrl element SHALL have a value except that:  * fullUrl can be empty on a POST (although it does not need to when specifying a temporary id for reference in the bundle) * Results from operations might involve resources that are not identified.
    property fullUrl : String read GetFullUrlST write SetFullUrlST;
    // The Absolute URL for the resource.  The fullUrl SHALL NOT disagree with the id in the resource - i.e. if the fullUrl is not a urn:uuid, the URL shall be version-independent URL consistent with the Resource.id. The fullUrl is a version independent reference to the resource. The fullUrl element SHALL have a value except that:  * fullUrl can be empty on a POST (although it does not need to when specifying a temporary id for reference in the bundle) * Results from operations might involve resources that are not identified.
    property fullUrlElement : TFhirUri read FFullUrl write SetFullUrl;

    // Typed access to The Resource for the entry. The purpose/meaning of the resource is determined by the Bundle.type. (defined for API consistency)
    property resource : TFhirResource read FResource write SetResource;
    // The Resource for the entry. The purpose/meaning of the resource is determined by the Bundle.type.
    property resourceElement : TFhirResource read FResource write SetResource;

    // Typed access to Information about the search process that lead to the creation of this entry. (defined for API consistency)
    property search : TFhirBundleEntrySearch read FSearch write SetSearch;
    // Information about the search process that lead to the creation of this entry.
    property searchElement : TFhirBundleEntrySearch read FSearch write SetSearch;

    // Typed access to Additional information about how this entry should be processed as part of a transaction or batch.  For history, it shows how the entry was processed to create the version contained in the entry. (defined for API consistency)
    property request : TFhirBundleEntryRequest read FRequest write SetRequest;
    // Additional information about how this entry should be processed as part of a transaction or batch.  For history, it shows how the entry was processed to create the version contained in the entry.
    property requestElement : TFhirBundleEntryRequest read FRequest write SetRequest;

    // Typed access to Indicates the results of processing the corresponding 'request' entry in the batch or transaction being responded to or what the results of an operation where when returning history. (defined for API consistency)
    property response : TFhirBundleEntryResponse read FResponse write SetResponse;
    // Indicates the results of processing the corresponding 'request' entry in the batch or transaction being responded to or what the results of an operation where when returning history.
    property responseElement : TFhirBundleEntryResponse read FResponse write SetResponse;

  end;

  TFhirBundleEntryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleEntryList;
    function GetCurrent : TFhirBundleEntry;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBundleEntryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleEntry read GetCurrent;
  end;

  TFhirBundleEntryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBundleEntry;
    procedure SetItemN(index : Integer; value : TFhirBundleEntry);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBundleEntryList; Overload;
    function Clone : TFhirBundleEntryList; Overload;
    function GetEnumerator : TFhirBundleEntryListEnumerator;
    

    //  Add a FhirBundleEntry to the end of the list.
    function Append : TFhirBundleEntry;

    
    // Add an already existing FhirBundleEntry to the end of the list.
    procedure AddItem(value : TFhirBundleEntry); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleEntry) : Integer;
    

    // Insert FhirBundleEntry before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleEntry;
    

    // Insert an existing FhirBundleEntry before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleEntry);
    
    // Get the iIndexth FhirBundleEntry. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleEntry);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleEntry;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirBundleEntries[index : Integer] : TFhirBundleEntry read GetItemN write SetItemN; default;
  End;

  // Information about the search process that lead to the creation of this entry.
  TFhirBundleEntrySearch = class (TFhirBackboneElement)
  protected
    FMode : TFhirEnum;
    FScore : TFhirDecimal;
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirSearchEntryModeEnum;
    Procedure SetModeST(value : TFhirSearchEntryModeEnum);
    Procedure SetScore(value : TFhirDecimal);
    Function GetScoreST : String;
    Procedure SetScoreST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleEntrySearch; overload;
    function Clone : TFhirBundleEntrySearch; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Why this entry is in the result set - whether it's included as a match or because of an _include requirement, or to convey information or warning information about the search process.
    property mode : TFhirSearchEntryModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to When searching, the server's search ranking score for the entry.
    property score : String read GetScoreST write SetScoreST;
    // When searching, the server's search ranking score for the entry.
    property scoreElement : TFhirDecimal read FScore write SetScore;

  end;

  TFhirBundleEntrySearchListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleEntrySearchList;
    function GetCurrent : TFhirBundleEntrySearch;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBundleEntrySearchList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleEntrySearch read GetCurrent;
  end;

  TFhirBundleEntrySearchList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBundleEntrySearch;
    procedure SetItemN(index : Integer; value : TFhirBundleEntrySearch);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBundleEntrySearchList; Overload;
    function Clone : TFhirBundleEntrySearchList; Overload;
    function GetEnumerator : TFhirBundleEntrySearchListEnumerator;
    

    //  Add a FhirBundleEntrySearch to the end of the list.
    function Append : TFhirBundleEntrySearch;

    
    // Add an already existing FhirBundleEntrySearch to the end of the list.
    procedure AddItem(value : TFhirBundleEntrySearch); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleEntrySearch) : Integer;
    

    // Insert FhirBundleEntrySearch before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleEntrySearch;
    

    // Insert an existing FhirBundleEntrySearch before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleEntrySearch);
    
    // Get the iIndexth FhirBundleEntrySearch. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleEntrySearch);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleEntrySearch;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirBundleEntrySearches[index : Integer] : TFhirBundleEntrySearch read GetItemN write SetItemN; default;
  End;

  // Additional information about how this entry should be processed as part of a transaction or batch.  For history, it shows how the entry was processed to create the version contained in the entry.
  TFhirBundleEntryRequest = class (TFhirBackboneElement)
  protected
    FMethod : TFhirEnum;
    FUrl : TFhirUri;
    FIfNoneMatch : TFhirString;
    FIfModifiedSince : TFhirInstant;
    FIfMatch : TFhirString;
    FIfNoneExist : TFhirString;
    Procedure SetMethod(value : TFhirEnum);
    Function GetMethodST : TFhirHttpVerbEnum;
    Procedure SetMethodST(value : TFhirHttpVerbEnum);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetIfNoneMatch(value : TFhirString);
    Function GetIfNoneMatchST : String;
    Procedure SetIfNoneMatchST(value : String);
    Procedure SetIfModifiedSince(value : TFhirInstant);
    Function GetIfModifiedSinceST : TFslDateTime;
    Procedure SetIfModifiedSinceST(value : TFslDateTime);
    Procedure SetIfMatch(value : TFhirString);
    Function GetIfMatchST : String;
    Procedure SetIfMatchST(value : String);
    Procedure SetIfNoneExist(value : TFhirString);
    Function GetIfNoneExistST : String;
    Procedure SetIfNoneExistST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleEntryRequest; overload;
    function Clone : TFhirBundleEntryRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // In a transaction or batch, this is the HTTP action to be executed for this entry. In a history bundle, this indicates the HTTP action that occurred.
    property method : TFhirHttpVerbEnum read GetMethodST write SetMethodST;
    property methodElement : TFhirEnum read FMethod write SetMethod;

    // Typed access to The URL for this entry, relative to the root (the address to which the request is posted).
    property url : String read GetUrlST write SetUrlST;
    // The URL for this entry, relative to the root (the address to which the request is posted).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to If the ETag values match, return a 304 Not Modified status. See the API documentation for ["Conditional Read"](http.html#cread).
    property ifNoneMatch : String read GetIfNoneMatchST write SetIfNoneMatchST;
    // If the ETag values match, return a 304 Not Modified status. See the API documentation for ["Conditional Read"](http.html#cread).
    property ifNoneMatchElement : TFhirString read FIfNoneMatch write SetIfNoneMatch;

    // Typed access to Only perform the operation if the last updated date matches. See the API documentation for ["Conditional Read"](http.html#cread).
    property ifModifiedSince : TFslDateTime read GetIfModifiedSinceST write SetIfModifiedSinceST;
    // Only perform the operation if the last updated date matches. See the API documentation for ["Conditional Read"](http.html#cread).
    property ifModifiedSinceElement : TFhirInstant read FIfModifiedSince write SetIfModifiedSince;

    // Typed access to Only perform the operation if the Etag value matches. For more information, see the API section ["Managing Resource Contention"](http.html#concurrency).
    property ifMatch : String read GetIfMatchST write SetIfMatchST;
    // Only perform the operation if the Etag value matches. For more information, see the API section ["Managing Resource Contention"](http.html#concurrency).
    property ifMatchElement : TFhirString read FIfMatch write SetIfMatch;

    // Typed access to Instruct the server not to perform the create if a specified resource already exists. For further information, see the API documentation for ["Conditional Create"](http.html#ccreate). This is just the query portion of the URL - what follows the "?" (not including the "?").
    property ifNoneExist : String read GetIfNoneExistST write SetIfNoneExistST;
    // Instruct the server not to perform the create if a specified resource already exists. For further information, see the API documentation for ["Conditional Create"](http.html#ccreate). This is just the query portion of the URL - what follows the "?" (not including the "?").
    property ifNoneExistElement : TFhirString read FIfNoneExist write SetIfNoneExist;

  end;

  TFhirBundleEntryRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleEntryRequestList;
    function GetCurrent : TFhirBundleEntryRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBundleEntryRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleEntryRequest read GetCurrent;
  end;

  TFhirBundleEntryRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBundleEntryRequest;
    procedure SetItemN(index : Integer; value : TFhirBundleEntryRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBundleEntryRequestList; Overload;
    function Clone : TFhirBundleEntryRequestList; Overload;
    function GetEnumerator : TFhirBundleEntryRequestListEnumerator;
    

    //  Add a FhirBundleEntryRequest to the end of the list.
    function Append : TFhirBundleEntryRequest;

    
    // Add an already existing FhirBundleEntryRequest to the end of the list.
    procedure AddItem(value : TFhirBundleEntryRequest); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleEntryRequest) : Integer;
    

    // Insert FhirBundleEntryRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleEntryRequest;
    

    // Insert an existing FhirBundleEntryRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleEntryRequest);
    
    // Get the iIndexth FhirBundleEntryRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleEntryRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleEntryRequest;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirBundleEntryRequests[index : Integer] : TFhirBundleEntryRequest read GetItemN write SetItemN; default;
  End;

  // Indicates the results of processing the corresponding 'request' entry in the batch or transaction being responded to or what the results of an operation where when returning history.
  TFhirBundleEntryResponse = class (TFhirBackboneElement)
  protected
    FStatus : TFhirString;
    FLocation : TFhirUri;
    FEtag : TFhirString;
    FLastModified : TFhirInstant;
    FOutcome : TFhirResource;
    Procedure SetStatus(value : TFhirString);
    Function GetStatusST : String;
    Procedure SetStatusST(value : String);
    Procedure SetLocation(value : TFhirUri);
    Function GetLocationST : String;
    Procedure SetLocationST(value : String);
    Procedure SetEtag(value : TFhirString);
    Function GetEtagST : String;
    Procedure SetEtagST(value : String);
    Procedure SetLastModified(value : TFhirInstant);
    Function GetLastModifiedST : TFslDateTime;
    Procedure SetLastModifiedST(value : TFslDateTime);
    Procedure SetOutcome(value : TFhirResource);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleEntryResponse; overload;
    function Clone : TFhirBundleEntryResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The status code returned by processing this entry. The status SHALL start with a 3 digit HTTP code (e.g. 404) and may contain the standard HTTP description associated with the status code.
    property status : String read GetStatusST write SetStatusST;
    // The status code returned by processing this entry. The status SHALL start with a 3 digit HTTP code (e.g. 404) and may contain the standard HTTP description associated with the status code.
    property statusElement : TFhirString read FStatus write SetStatus;

    // Typed access to The location header created by processing this operation, populated if the operation returns a location.
    property location : String read GetLocationST write SetLocationST;
    // The location header created by processing this operation, populated if the operation returns a location.
    property locationElement : TFhirUri read FLocation write SetLocation;

    // Typed access to The Etag for the resource, if the operation for the entry produced a versioned resource (see [Resource Metadata and Versioning](http.html#versioning) and [Managing Resource Contention](http.html#concurrency)).
    property etag : String read GetEtagST write SetEtagST;
    // The Etag for the resource, if the operation for the entry produced a versioned resource (see [Resource Metadata and Versioning](http.html#versioning) and [Managing Resource Contention](http.html#concurrency)).
    property etagElement : TFhirString read FEtag write SetEtag;

    // Typed access to The date/time that the resource was modified on the server.
    property lastModified : TFslDateTime read GetLastModifiedST write SetLastModifiedST;
    // The date/time that the resource was modified on the server.
    property lastModifiedElement : TFhirInstant read FLastModified write SetLastModified;

    // Typed access to An OperationOutcome containing hints and warnings produced as part of processing this entry in a batch or transaction. (defined for API consistency)
    property outcome : TFhirResource read FOutcome write SetOutcome;
    // An OperationOutcome containing hints and warnings produced as part of processing this entry in a batch or transaction.
    property outcomeElement : TFhirResource read FOutcome write SetOutcome;

  end;

  TFhirBundleEntryResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleEntryResponseList;
    function GetCurrent : TFhirBundleEntryResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBundleEntryResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleEntryResponse read GetCurrent;
  end;

  TFhirBundleEntryResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBundleEntryResponse;
    procedure SetItemN(index : Integer; value : TFhirBundleEntryResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBundleEntryResponseList; Overload;
    function Clone : TFhirBundleEntryResponseList; Overload;
    function GetEnumerator : TFhirBundleEntryResponseListEnumerator;
    

    //  Add a FhirBundleEntryResponse to the end of the list.
    function Append : TFhirBundleEntryResponse;

    
    // Add an already existing FhirBundleEntryResponse to the end of the list.
    procedure AddItem(value : TFhirBundleEntryResponse); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleEntryResponse) : Integer;
    

    // Insert FhirBundleEntryResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleEntryResponse;
    

    // Insert an existing FhirBundleEntryResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleEntryResponse);
    
    // Get the iIndexth FhirBundleEntryResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleEntryResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleEntryResponse;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirBundleEntryResponses[index : Integer] : TFhirBundleEntryResponse read GetItemN write SetItemN; default;
  End;

  // A container for a collection of resources.
  TFhirBundle = class (TFhirResource)
  protected
    FIdentifier : TFhirIdentifier;
    FType_ : TFhirEnum;
    FTimestamp : TFhirInstant;
    FTotal : TFhirUnsignedInt;
    Flink_List : TFhirBundleLinkList;
    FentryList : TFhirBundleEntryList;
    FSignature : TFhirSignature;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirBundleTypeEnum;
    Procedure SetType_ST(value : TFhirBundleTypeEnum);
    Procedure SetTimestamp(value : TFhirInstant);
    Function GetTimestampST : TFslDateTime;
    Procedure SetTimestampST(value : TFslDateTime);
    Procedure SetTotal(value : TFhirUnsignedInt);
    Function GetTotalST : String;
    Procedure SetTotalST(value : String);
    function GetLink_List : TFhirBundleLinkList;
    function GetHasLink_List : Boolean;
    function GetEntryList : TFhirBundleEntryList;
    function GetHasEntryList : Boolean;
    Procedure SetSignature(value : TFhirSignature);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundle; overload;
    function Clone : TFhirBundle; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A persistent identifier for the bundle that won't change as a bundle is copied from server to server. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A persistent identifier for the bundle that won't change as a bundle is copied from server to server.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Indicates the purpose of this bundle - how it is intended to be used.
    property type_ : TFhirBundleTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The date/time that the bundle was assembled - i.e. when the resources were placed in the bundle.
    property timestamp : TFslDateTime read GetTimestampST write SetTimestampST;
    // The date/time that the bundle was assembled - i.e. when the resources were placed in the bundle.
    property timestampElement : TFhirInstant read FTimestamp write SetTimestamp;

    // Typed access to If a set of search matches, this is the total number of entries of type 'match' across all pages in the search.  It does not include search.mode = 'include' or 'outcome' entries and it does not provide a count of the number of entries in the Bundle.
    property total : String read GetTotalST write SetTotalST;
    // If a set of search matches, this is the total number of entries of type 'match' across all pages in the search.  It does not include search.mode = 'include' or 'outcome' entries and it does not provide a count of the number of entries in the Bundle.
    property totalElement : TFhirUnsignedInt read FTotal write SetTotal;

    // A series of links that provide context to this bundle.
    property link_List : TFhirBundleLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

    // An entry in a bundle resource - will either contain a resource or information about a resource (transactions and history only).
    property entryList : TFhirBundleEntryList read GetEntryList;
    property hasEntryList : boolean read GetHasEntryList;

    // Typed access to Digital Signature - base64 encoded. XML-DSig or a JWT. (defined for API consistency)
    property signature : TFhirSignature read FSignature write SetSignature;
    // Digital Signature - base64 encoded. XML-DSig or a JWT.
    property signatureElement : TFhirSignature read FSignature write SetSignature;

  end;

  TFhirBundleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleList;
    function GetCurrent : TFhirBundle;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBundleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundle read GetCurrent;
  end;

  TFhirBundleList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBundle;
    procedure SetItemN(index : Integer; value : TFhirBundle);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBundleList; Overload;
    function Clone : TFhirBundleList; Overload;
    function GetEnumerator : TFhirBundleListEnumerator;
    

    //  Add a FhirBundle to the end of the list.
    function Append : TFhirBundle;

    
    // Add an already existing FhirBundle to the end of the list.
    procedure AddItem(value : TFhirBundle); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundle) : Integer;
    

    // Insert FhirBundle before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundle;
    

    // Insert an existing FhirBundle before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundle);
    
    // Get the iIndexth FhirBundle. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundle);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBundle;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirBundles[index : Integer] : TFhirBundle read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BUNDLE}

{$IFDEF FHIR_CONSENT}

  // The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
  TFhirConsentPolicy = class (TFhirBackboneElement)
  protected
    FAuthority : TFhirUri;
    FUri : TFhirUri;
    Procedure SetAuthority(value : TFhirUri);
    Function GetAuthorityST : String;
    Procedure SetAuthorityST(value : String);
    Procedure SetUri(value : TFhirUri);
    Function GetUriST : String;
    Procedure SetUriST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentPolicy; overload;
    function Clone : TFhirConsentPolicy; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Entity or Organization having regulatory jurisdiction or accountability for  enforcing policies pertaining to Consent Directives.
    property authority : String read GetAuthorityST write SetAuthorityST;
    // Entity or Organization having regulatory jurisdiction or accountability for  enforcing policies pertaining to Consent Directives.
    property authorityElement : TFhirUri read FAuthority write SetAuthority;

    // Typed access to The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
    property uri : String read GetUriST write SetUriST;
    // The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
    property uriElement : TFhirUri read FUri write SetUri;

  end;

  TFhirConsentPolicyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentPolicyList;
    function GetCurrent : TFhirConsentPolicy;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConsentPolicyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentPolicy read GetCurrent;
  end;

  TFhirConsentPolicyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConsentPolicy;
    procedure SetItemN(index : Integer; value : TFhirConsentPolicy);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConsentPolicyList; Overload;
    function Clone : TFhirConsentPolicyList; Overload;
    function GetEnumerator : TFhirConsentPolicyListEnumerator;
    

    //  Add a FhirConsentPolicy to the end of the list.
    function Append : TFhirConsentPolicy;

    
    // Add an already existing FhirConsentPolicy to the end of the list.
    procedure AddItem(value : TFhirConsentPolicy); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentPolicy) : Integer;
    

    // Insert FhirConsentPolicy before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentPolicy;
    

    // Insert an existing FhirConsentPolicy before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentPolicy);
    
    // Get the iIndexth FhirConsentPolicy. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentPolicy);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentPolicy;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConsentPolicies[index : Integer] : TFhirConsentPolicy read GetItemN write SetItemN; default;
  End;

  // Whether a treatment instruction (e.g. artificial respiration yes or no) was verified with the patient, his/her family or another authorized person.
  TFhirConsentVerification = class (TFhirBackboneElement)
  protected
    FVerified : TFhirBoolean;
    FVerifiedWith : TFhirReference{TFhirPatient};
    FVerificationDate : TFhirDateTime;
    Procedure SetVerified(value : TFhirBoolean);
    Function GetVerifiedST : Boolean;
    Procedure SetVerifiedST(value : Boolean);
    Procedure SetVerifiedWith(value : TFhirReference{TFhirPatient});
    Procedure SetVerificationDate(value : TFhirDateTime);
    Function GetVerificationDateST : TFslDateTime;
    Procedure SetVerificationDateST(value : TFslDateTime);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentVerification; overload;
    function Clone : TFhirConsentVerification; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Has the instruction been verified.
    property verified : Boolean read GetVerifiedST write SetVerifiedST;
    // Has the instruction been verified.
    property verifiedElement : TFhirBoolean read FVerified write SetVerified;

    // Typed access to Who verified the instruction (Patient, Relative or other Authorized Person). (defined for API consistency)
    property verifiedWith : TFhirReference{TFhirPatient} read FVerifiedWith write SetVerifiedWith;
    // Who verified the instruction (Patient, Relative or other Authorized Person).
    property verifiedWithElement : TFhirReference{TFhirPatient} read FVerifiedWith write SetVerifiedWith;

    // Typed access to Date verification was collected.
    property verificationDate : TFslDateTime read GetVerificationDateST write SetVerificationDateST;
    // Date verification was collected.
    property verificationDateElement : TFhirDateTime read FVerificationDate write SetVerificationDate;

  end;

  TFhirConsentVerificationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentVerificationList;
    function GetCurrent : TFhirConsentVerification;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConsentVerificationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentVerification read GetCurrent;
  end;

  TFhirConsentVerificationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConsentVerification;
    procedure SetItemN(index : Integer; value : TFhirConsentVerification);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConsentVerificationList; Overload;
    function Clone : TFhirConsentVerificationList; Overload;
    function GetEnumerator : TFhirConsentVerificationListEnumerator;
    

    //  Add a FhirConsentVerification to the end of the list.
    function Append : TFhirConsentVerification;

    
    // Add an already existing FhirConsentVerification to the end of the list.
    procedure AddItem(value : TFhirConsentVerification); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentVerification) : Integer;
    

    // Insert FhirConsentVerification before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentVerification;
    

    // Insert an existing FhirConsentVerification before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentVerification);
    
    // Get the iIndexth FhirConsentVerification. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentVerification);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentVerification;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConsentVerifications[index : Integer] : TFhirConsentVerification read GetItemN write SetItemN; default;
  End;

  // An exception to the base policy of this consent. An exception can be an addition or removal of access permissions.
  TFhirConsentProvision = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FPeriod : TFhirPeriod;
    FactorList : TFhirConsentProvisionActorList;
    FactionList : TFhirCodeableConceptList;
    FsecurityLabelList : TFhirCodingList;
    FpurposeList : TFhirCodingList;
    Fclass_List : TFhirCodingList;
    FcodeList : TFhirCodeableConceptList;
    FDataPeriod : TFhirPeriod;
    FdataList : TFhirConsentProvisionDataList;
    FprovisionList : TFhirConsentProvisionList;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirConsentProvisionTypeEnum;
    Procedure SetType_ST(value : TFhirConsentProvisionTypeEnum);
    Procedure SetPeriod(value : TFhirPeriod);
    function GetActorList : TFhirConsentProvisionActorList;
    function GetHasActorList : Boolean;
    function GetActionList : TFhirCodeableConceptList;
    function GetHasActionList : Boolean;
    function GetSecurityLabelList : TFhirCodingList;
    function GetHasSecurityLabelList : Boolean;
    function GetPurposeList : TFhirCodingList;
    function GetHasPurposeList : Boolean;
    function GetClass_List : TFhirCodingList;
    function GetHasClass_List : Boolean;
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    Procedure SetDataPeriod(value : TFhirPeriod);
    function GetDataList : TFhirConsentProvisionDataList;
    function GetHasDataList : Boolean;
    function GetProvisionList : TFhirConsentProvisionList;
    function GetHasProvisionList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentProvision; overload;
    function Clone : TFhirConsentProvision; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Action  to take - permit or deny - when the rule conditions are met.  Not permitted in root rule, required in all nested rules.
    property type_ : TFhirConsentProvisionTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The timeframe in this rule is valid. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The timeframe in this rule is valid.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Who or what is controlled by this rule. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
    property actorList : TFhirConsentProvisionActorList read GetActorList;
    property hasActorList : boolean read GetHasActorList;

    // Actions controlled by this Rule.
    property actionList : TFhirCodeableConceptList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

    // A security label, comprised of 0..* security label fields (Privacy tags), which define which resources are controlled by this exception.
    property securityLabelList : TFhirCodingList read GetSecurityLabelList;
    property hasSecurityLabelList : boolean read GetHasSecurityLabelList;

    // The context of the activities a user is taking - why the user is accessing the data - that are controlled by this rule.
    property purposeList : TFhirCodingList read GetPurposeList;
    property hasPurposeList : boolean read GetHasPurposeList;

    // The class of information covered by this rule. The type can be a FHIR resource type, a profile on a type, or a CDA document, or some other type that indicates what sort of information the consent relates to.
    property class_List : TFhirCodingList read GetClass_List;
    property hasClass_List : boolean read GetHasClass_List;

    // If this code is found in an instance, then the rule applies.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Typed access to Clinical or Operational Relevant period of time that bounds the data controlled by this rule. (defined for API consistency)
    property dataPeriod : TFhirPeriod read FDataPeriod write SetDataPeriod;
    // Clinical or Operational Relevant period of time that bounds the data controlled by this rule.
    property dataPeriodElement : TFhirPeriod read FDataPeriod write SetDataPeriod;

    // The resources controlled by this rule if specific resources are referenced.
    property dataList : TFhirConsentProvisionDataList read GetDataList;
    property hasDataList : boolean read GetHasDataList;

    // Rules which provide exceptions to the base rule or subrules.
    property provisionList : TFhirConsentProvisionList read GetProvisionList;
    property hasProvisionList : boolean read GetHasProvisionList;

  end;

  TFhirConsentProvisionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentProvisionList;
    function GetCurrent : TFhirConsentProvision;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConsentProvisionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentProvision read GetCurrent;
  end;

  TFhirConsentProvisionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConsentProvision;
    procedure SetItemN(index : Integer; value : TFhirConsentProvision);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConsentProvisionList; Overload;
    function Clone : TFhirConsentProvisionList; Overload;
    function GetEnumerator : TFhirConsentProvisionListEnumerator;
    

    //  Add a FhirConsentProvision to the end of the list.
    function Append : TFhirConsentProvision;

    
    // Add an already existing FhirConsentProvision to the end of the list.
    procedure AddItem(value : TFhirConsentProvision); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentProvision) : Integer;
    

    // Insert FhirConsentProvision before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentProvision;
    

    // Insert an existing FhirConsentProvision before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentProvision);
    
    // Get the iIndexth FhirConsentProvision. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentProvision);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentProvision;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConsentProvisions[index : Integer] : TFhirConsentProvision read GetItemN write SetItemN; default;
  End;

  // Who or what is controlled by this rule. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
  TFhirConsentProvisionActor = class (TFhirBackboneElement)
  protected
    FRole : TFhirCodeableConcept;
    FReference : TFhirReference{TFhirDevice};
    Procedure SetRole(value : TFhirCodeableConcept);
    Procedure SetReference(value : TFhirReference{TFhirDevice});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentProvisionActor; overload;
    function Clone : TFhirConsentProvisionActor; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to How the individual is involved in the resources content that is described in the exception. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // How the individual is involved in the resources content that is described in the exception.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The resource that identifies the actor. To identify actors by type, use group to identify a set of actors by some property they share (e.g. 'admitting officers'). (defined for API consistency)
    property reference : TFhirReference{TFhirDevice} read FReference write SetReference;
    // The resource that identifies the actor. To identify actors by type, use group to identify a set of actors by some property they share (e.g. 'admitting officers').
    property referenceElement : TFhirReference{TFhirDevice} read FReference write SetReference;

  end;

  TFhirConsentProvisionActorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentProvisionActorList;
    function GetCurrent : TFhirConsentProvisionActor;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConsentProvisionActorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentProvisionActor read GetCurrent;
  end;

  TFhirConsentProvisionActorList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConsentProvisionActor;
    procedure SetItemN(index : Integer; value : TFhirConsentProvisionActor);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConsentProvisionActorList; Overload;
    function Clone : TFhirConsentProvisionActorList; Overload;
    function GetEnumerator : TFhirConsentProvisionActorListEnumerator;
    

    //  Add a FhirConsentProvisionActor to the end of the list.
    function Append : TFhirConsentProvisionActor;

    
    // Add an already existing FhirConsentProvisionActor to the end of the list.
    procedure AddItem(value : TFhirConsentProvisionActor); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentProvisionActor) : Integer;
    

    // Insert FhirConsentProvisionActor before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentProvisionActor;
    

    // Insert an existing FhirConsentProvisionActor before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentProvisionActor);
    
    // Get the iIndexth FhirConsentProvisionActor. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentProvisionActor);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentProvisionActor;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConsentProvisionActors[index : Integer] : TFhirConsentProvisionActor read GetItemN write SetItemN; default;
  End;

  // The resources controlled by this rule if specific resources are referenced.
  TFhirConsentProvisionData = class (TFhirBackboneElement)
  protected
    FMeaning : TFhirEnum;
    FReference : TFhirReference{TFhirReference};
    Procedure SetMeaning(value : TFhirEnum);
    Function GetMeaningST : TFhirConsentDataMeaningEnum;
    Procedure SetMeaningST(value : TFhirConsentDataMeaningEnum);
    Procedure SetReference(value : TFhirReference{TFhirReference});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentProvisionData; overload;
    function Clone : TFhirConsentProvisionData; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // How the resource reference is interpreted when testing consent restrictions.
    property meaning : TFhirConsentDataMeaningEnum read GetMeaningST write SetMeaningST;
    property meaningElement : TFhirEnum read FMeaning write SetMeaning;

    // Typed access to A reference to a specific resource that defines which resources are covered by this consent. (defined for API consistency)
    property reference : TFhirReference{TFhirReference} read FReference write SetReference;
    // A reference to a specific resource that defines which resources are covered by this consent.
    property referenceElement : TFhirReference{TFhirReference} read FReference write SetReference;

  end;

  TFhirConsentProvisionDataListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentProvisionDataList;
    function GetCurrent : TFhirConsentProvisionData;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConsentProvisionDataList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentProvisionData read GetCurrent;
  end;

  TFhirConsentProvisionDataList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConsentProvisionData;
    procedure SetItemN(index : Integer; value : TFhirConsentProvisionData);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConsentProvisionDataList; Overload;
    function Clone : TFhirConsentProvisionDataList; Overload;
    function GetEnumerator : TFhirConsentProvisionDataListEnumerator;
    

    //  Add a FhirConsentProvisionData to the end of the list.
    function Append : TFhirConsentProvisionData;

    
    // Add an already existing FhirConsentProvisionData to the end of the list.
    procedure AddItem(value : TFhirConsentProvisionData); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentProvisionData) : Integer;
    

    // Insert FhirConsentProvisionData before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentProvisionData;
    

    // Insert an existing FhirConsentProvisionData before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentProvisionData);
    
    // Get the iIndexth FhirConsentProvisionData. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentProvisionData);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentProvisionData;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConsentProvisionData[index : Integer] : TFhirConsentProvisionData read GetItemN write SetItemN; default;
  End;

  // A record of a healthcare consumer?s  choices, which permits or denies identified recipient(s) or recipient role(s) to perform one or more actions within a given policy context, for specific purposes and periods of time.
  TFhirConsent = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FScope : TFhirCodeableConcept;
    FcategoryList : TFhirCodeableConceptList;
    FPatient : TFhirReference{TFhirPatient};
    FDateTime : TFhirDateTime;
    FperformerList : TFhirReferenceList{TFhirOrganization};
    ForganizationList : TFhirReferenceList{TFhirOrganization};
    FSource : TFhirType;
    FpolicyList : TFhirConsentPolicyList;
    FPolicyRule : TFhirCodeableConcept;
    FverificationList : TFhirConsentVerificationList;
    FProvision : TFhirConsentProvision;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirConsentStateCodesEnum;
    Procedure SetStatusST(value : TFhirConsentStateCodesEnum);
    Procedure SetScope(value : TFhirCodeableConcept);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetDateTime(value : TFhirDateTime);
    Function GetDateTimeST : TFslDateTime;
    Procedure SetDateTimeST(value : TFslDateTime);
    function GetPerformerList : TFhirReferenceList{TFhirOrganization};
    function GetHasPerformerList : Boolean;
    function GetOrganizationList : TFhirReferenceList{TFhirOrganization};
    function GetHasOrganizationList : Boolean;
    Procedure SetSource(value : TFhirType);
    function GetPolicyList : TFhirConsentPolicyList;
    function GetHasPolicyList : Boolean;
    Procedure SetPolicyRule(value : TFhirCodeableConcept);
    function GetVerificationList : TFhirConsentVerificationList;
    function GetHasVerificationList : Boolean;
    Procedure SetProvision(value : TFhirConsentProvision);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsent; overload;
    function Clone : TFhirConsent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Unique identifier for this copy of the Consent Statement.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates the current state of this consent.
    property status : TFhirConsentStateCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A selector of the type of consent being presented: ADR, Privacy, Treatment, Research.  This list is now extensible. (defined for API consistency)
    property scope : TFhirCodeableConcept read FScope write SetScope;
    // A selector of the type of consent being presented: ADR, Privacy, Treatment, Research.  This list is now extensible.
    property scopeElement : TFhirCodeableConcept read FScope write SetScope;

    // A classification of the type of consents found in the statement. This element supports indexing and retrieval of consent statements.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to The patient/healthcare consumer to whom this consent applies. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The patient/healthcare consumer to whom this consent applies.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to When this  Consent was issued / created / indexed.
    property dateTime : TFslDateTime read GetDateTimeST write SetDateTimeST;
    // When this  Consent was issued / created / indexed.
    property dateTimeElement : TFhirDateTime read FDateTime write SetDateTime;

    // Either the Grantor, which is the entity responsible for granting the rights listed in a Consent Directive or the Grantee, which is the entity responsible for complying with the Consent Directive, including any obligations or limitations on authorizations and enforcement of prohibitions.
    property performerList : TFhirReferenceList{TFhirOrganization} read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // The organization that manages the consent, and the framework within which it is executed.
    property organizationList : TFhirReferenceList{TFhirOrganization} read GetOrganizationList;
    property hasOrganizationList : boolean read GetHasOrganizationList;

    // Typed access to The source on which this consent statement is based. The source might be a scanned original paper form, or a reference to a consent that links back to such a source, a reference to a document repository (e.g. XDS) that stores the original consent document. (defined for API consistency)
    property source : TFhirType read FSource write SetSource;
    // The source on which this consent statement is based. The source might be a scanned original paper form, or a reference to a consent that links back to such a source, a reference to a document repository (e.g. XDS) that stores the original consent document.
    property sourceElement : TFhirType read FSource write SetSource;

    // The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
    property policyList : TFhirConsentPolicyList read GetPolicyList;
    property hasPolicyList : boolean read GetHasPolicyList;

    // Typed access to A reference to the specific base computable regulation or policy. (defined for API consistency)
    property policyRule : TFhirCodeableConcept read FPolicyRule write SetPolicyRule;
    // A reference to the specific base computable regulation or policy.
    property policyRuleElement : TFhirCodeableConcept read FPolicyRule write SetPolicyRule;

    // Whether a treatment instruction (e.g. artificial respiration yes or no) was verified with the patient, his/her family or another authorized person.
    property verificationList : TFhirConsentVerificationList read GetVerificationList;
    property hasVerificationList : boolean read GetHasVerificationList;

    // Typed access to An exception to the base policy of this consent. An exception can be an addition or removal of access permissions. (defined for API consistency)
    property provision : TFhirConsentProvision read FProvision write SetProvision;
    // An exception to the base policy of this consent. An exception can be an addition or removal of access permissions.
    property provisionElement : TFhirConsentProvision read FProvision write SetProvision;

  end;

  TFhirConsentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentList;
    function GetCurrent : TFhirConsent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConsentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsent read GetCurrent;
  end;

  TFhirConsentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConsent;
    procedure SetItemN(index : Integer; value : TFhirConsent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConsentList; Overload;
    function Clone : TFhirConsentList; Overload;
    function GetEnumerator : TFhirConsentListEnumerator;
    

    //  Add a FhirConsent to the end of the list.
    function Append : TFhirConsent;

    
    // Add an already existing FhirConsent to the end of the list.
    procedure AddItem(value : TFhirConsent); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsent) : Integer;
    

    // Insert FhirConsent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsent;
    

    // Insert an existing FhirConsent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsent);
    
    // Get the iIndexth FhirConsent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConsent;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirConsents[index : Integer] : TFhirConsent read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CONSENT}

{$IFDEF FHIR_CONTRACT}

  // Precusory content developed with a focus and intent of supporting the formation a Contract instance, which may be associated with and transformable into a Contract.
  TFhirContractContentDefinition = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FSubType : TFhirCodeableConcept;
    FPublisher : TFhirReference{TFhirPractitioner};
    FPublicationDate : TFhirDateTime;
    FPublicationStatus : TFhirEnum;
    FCopyright : TFhirMarkdown;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetSubType(value : TFhirCodeableConcept);
    Procedure SetPublisher(value : TFhirReference{TFhirPractitioner});
    Procedure SetPublicationDate(value : TFhirDateTime);
    Function GetPublicationDateST : TFslDateTime;
    Procedure SetPublicationDateST(value : TFslDateTime);
    Procedure SetPublicationStatus(value : TFhirEnum);
    Function GetPublicationStatusST : TFhirContractPublicationstatusEnum;
    Procedure SetPublicationStatusST(value : TFhirContractPublicationstatusEnum);
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractContentDefinition; overload;
    function Clone : TFhirContractContentDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Precusory content structure and use, i.e., a boilerplate, template, application for a contract such as an insurance policy or benefits under a program, e.g., workers compensation. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Precusory content structure and use, i.e., a boilerplate, template, application for a contract such as an insurance policy or benefits under a program, e.g., workers compensation.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Detailed Precusory content type. (defined for API consistency)
    property subType : TFhirCodeableConcept read FSubType write SetSubType;
    // Detailed Precusory content type.
    property subTypeElement : TFhirCodeableConcept read FSubType write SetSubType;

    // Typed access to The  individual or organization that {$IFNDEF FPC}Published{$ENDIF} the Contract precursor content. (defined for API consistency)
    property publisher : TFhirReference{TFhirPractitioner} read FPublisher write SetPublisher;
    // The  individual or organization that {$IFNDEF FPC}Published{$ENDIF} the Contract precursor content.
    property publisherElement : TFhirReference{TFhirPractitioner} read FPublisher write SetPublisher;

    // Typed access to The date (and optionally time) when the contract was {$IFNDEF FPC}Published{$ENDIF}. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the contract changes.
    property publicationDate : TFslDateTime read GetPublicationDateST write SetPublicationDateST;
    // The date (and optionally time) when the contract was {$IFNDEF FPC}Published{$ENDIF}. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the contract changes.
    property publicationDateElement : TFhirDateTime read FPublicationDate write SetPublicationDate;

    // draft | active | retired | unknown.
    property publicationStatus : TFhirContractPublicationstatusEnum read GetPublicationStatusST write SetPublicationStatusST;
    property publicationStatusElement : TFhirEnum read FPublicationStatus write SetPublicationStatus;

    // Typed access to A copyright statement relating to Contract precursor content. Copyright statements are generally legal restrictions on the use and publishing of the Contract precursor content.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to Contract precursor content. Copyright statements are generally legal restrictions on the use and publishing of the Contract precursor content.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

  end;

  TFhirContractContentDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractContentDefinitionList;
    function GetCurrent : TFhirContractContentDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractContentDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractContentDefinition read GetCurrent;
  end;

  TFhirContractContentDefinitionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractContentDefinition;
    procedure SetItemN(index : Integer; value : TFhirContractContentDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractContentDefinitionList; Overload;
    function Clone : TFhirContractContentDefinitionList; Overload;
    function GetEnumerator : TFhirContractContentDefinitionListEnumerator;
    

    //  Add a FhirContractContentDefinition to the end of the list.
    function Append : TFhirContractContentDefinition;

    
    // Add an already existing FhirContractContentDefinition to the end of the list.
    procedure AddItem(value : TFhirContractContentDefinition); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractContentDefinition) : Integer;
    

    // Insert FhirContractContentDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractContentDefinition;
    

    // Insert an existing FhirContractContentDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractContentDefinition);
    
    // Get the iIndexth FhirContractContentDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractContentDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractContentDefinition;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirContractContentDefinitions[index : Integer] : TFhirContractContentDefinition read GetItemN write SetItemN; default;
  End;

  // One or more Contract Provisions, which may be related and conveyed as a group, and may contain nested groups.
  TFhirContractTerm = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FIssued : TFhirDateTime;
    FApplies : TFhirPeriod;
    FTopic : TFhirType;
    FType_ : TFhirCodeableConcept;
    FSubType : TFhirCodeableConcept;
    FText : TFhirString;
    FsecurityLabelList : TFhirContractTermSecurityLabelList;
    FOffer : TFhirContractTermOffer;
    FassetList : TFhirContractTermAssetList;
    FactionList : TFhirContractTermActionList;
    FgroupList : TFhirContractTermList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetIssued(value : TFhirDateTime);
    Function GetIssuedST : TFslDateTime;
    Procedure SetIssuedST(value : TFslDateTime);
    Procedure SetApplies(value : TFhirPeriod);
    Procedure SetTopic(value : TFhirType);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetSubType(value : TFhirCodeableConcept);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    function GetSecurityLabelList : TFhirContractTermSecurityLabelList;
    function GetHasSecurityLabelList : Boolean;
    Procedure SetOffer(value : TFhirContractTermOffer);
    function GetAssetList : TFhirContractTermAssetList;
    function GetHasAssetList : Boolean;
    function GetActionList : TFhirContractTermActionList;
    function GetHasActionList : Boolean;
    function GetGroupList : TFhirContractTermList;
    function GetHasGroupList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTerm; overload;
    function Clone : TFhirContractTerm; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Unique identifier for this particular Contract Provision. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Unique identifier for this particular Contract Provision.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to When this Contract Provision was issued.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // When this Contract Provision was issued.
    property issuedElement : TFhirDateTime read FIssued write SetIssued;

    // Typed access to Relevant time or time-period when this Contract Provision is applicable. (defined for API consistency)
    property applies : TFhirPeriod read FApplies write SetApplies;
    // Relevant time or time-period when this Contract Provision is applicable.
    property appliesElement : TFhirPeriod read FApplies write SetApplies;

    // Typed access to The entity that the term applies to. (defined for API consistency)
    property topic : TFhirType read FTopic write SetTopic;
    // The entity that the term applies to.
    property topicElement : TFhirType read FTopic write SetTopic;

    // Typed access to A legal clause or condition contained within a contract that requires one or both parties to perform a particular requirement by some specified time or prevents one or both parties from performing a particular requirement by some specified time. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A legal clause or condition contained within a contract that requires one or both parties to perform a particular requirement by some specified time or prevents one or both parties from performing a particular requirement by some specified time.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A specialized legal clause or condition based on overarching contract type. (defined for API consistency)
    property subType : TFhirCodeableConcept read FSubType write SetSubType;
    // A specialized legal clause or condition based on overarching contract type.
    property subTypeElement : TFhirCodeableConcept read FSubType write SetSubType;

    // Typed access to Statement of a provision in a policy or a contract.
    property text : String read GetTextST write SetTextST;
    // Statement of a provision in a policy or a contract.
    property textElement : TFhirString read FText write SetText;

    // Security labels that protect the handling of information about the term and its elements, which may be specifically identified..
    property securityLabelList : TFhirContractTermSecurityLabelList read GetSecurityLabelList;
    property hasSecurityLabelList : boolean read GetHasSecurityLabelList;

    // Typed access to The matter of concern in the context of this provision of the agrement. (defined for API consistency)
    property offer : TFhirContractTermOffer read FOffer write SetOffer;
    // The matter of concern in the context of this provision of the agrement.
    property offerElement : TFhirContractTermOffer read FOffer write SetOffer;

    // Contract Term Asset List.
    property assetList : TFhirContractTermAssetList read GetAssetList;
    property hasAssetList : boolean read GetHasAssetList;

    // An actor taking a role in an activity for which it can be assigned some degree of responsibility for the activity taking place.
    property actionList : TFhirContractTermActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

    // Nested group of Contract Provisions.
    property groupList : TFhirContractTermList read GetGroupList;
    property hasGroupList : boolean read GetHasGroupList;

  end;

  TFhirContractTermListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermList;
    function GetCurrent : TFhirContractTerm;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractTermList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTerm read GetCurrent;
  end;

  TFhirContractTermList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractTerm;
    procedure SetItemN(index : Integer; value : TFhirContractTerm);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractTermList; Overload;
    function Clone : TFhirContractTermList; Overload;
    function GetEnumerator : TFhirContractTermListEnumerator;
    

    //  Add a FhirContractTerm to the end of the list.
    function Append : TFhirContractTerm;

    
    // Add an already existing FhirContractTerm to the end of the list.
    procedure AddItem(value : TFhirContractTerm); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTerm) : Integer;
    

    // Insert FhirContractTerm before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTerm;
    

    // Insert an existing FhirContractTerm before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTerm);
    
    // Get the iIndexth FhirContractTerm. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTerm);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTerm;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirContractTerms[index : Integer] : TFhirContractTerm read GetItemN write SetItemN; default;
  End;

  // Security labels that protect the handling of information about the term and its elements, which may be specifically identified..
  TFhirContractTermSecurityLabel = class (TFhirBackboneElement)
  protected
    FnumberList : TFhirUnsignedIntList;
    FClassification : TFhirCoding;
    FcategoryList : TFhirCodingList;
    FcontrolList : TFhirCodingList;
    function GetNumberList : TFhirUnsignedIntList;
    function GetHasNumberList : Boolean;
    Procedure SetClassification(value : TFhirCoding);
    function GetCategoryList : TFhirCodingList;
    function GetHasCategoryList : Boolean;
    function GetControlList : TFhirCodingList;
    function GetHasControlList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermSecurityLabel; overload;
    function Clone : TFhirContractTermSecurityLabel; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Number used to link this term or term element to the applicable Security Label.
    property numberList : TFhirUnsignedIntList read GetNumberList;
    property hasNumberList : boolean read GetHasNumberList;

    // Typed access to Security label privacy tag that species the level of confidentiality protection required for this term and/or term elements. (defined for API consistency)
    property classification : TFhirCoding read FClassification write SetClassification;
    // Security label privacy tag that species the level of confidentiality protection required for this term and/or term elements.
    property classificationElement : TFhirCoding read FClassification write SetClassification;

    // Security label privacy tag that species the applicable privacy and security policies governing this term and/or term elements.
    property categoryList : TFhirCodingList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Security label privacy tag that species the manner in which term and/or term elements are to be protected.
    property controlList : TFhirCodingList read GetControlList;
    property hasControlList : boolean read GetHasControlList;

  end;

  TFhirContractTermSecurityLabelListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermSecurityLabelList;
    function GetCurrent : TFhirContractTermSecurityLabel;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractTermSecurityLabelList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermSecurityLabel read GetCurrent;
  end;

  TFhirContractTermSecurityLabelList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractTermSecurityLabel;
    procedure SetItemN(index : Integer; value : TFhirContractTermSecurityLabel);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractTermSecurityLabelList; Overload;
    function Clone : TFhirContractTermSecurityLabelList; Overload;
    function GetEnumerator : TFhirContractTermSecurityLabelListEnumerator;
    

    //  Add a FhirContractTermSecurityLabel to the end of the list.
    function Append : TFhirContractTermSecurityLabel;

    
    // Add an already existing FhirContractTermSecurityLabel to the end of the list.
    procedure AddItem(value : TFhirContractTermSecurityLabel); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermSecurityLabel) : Integer;
    

    // Insert FhirContractTermSecurityLabel before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermSecurityLabel;
    

    // Insert an existing FhirContractTermSecurityLabel before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermSecurityLabel);
    
    // Get the iIndexth FhirContractTermSecurityLabel. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermSecurityLabel);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermSecurityLabel;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirContractTermSecurityLabels[index : Integer] : TFhirContractTermSecurityLabel read GetItemN write SetItemN; default;
  End;

  // The matter of concern in the context of this provision of the agrement.
  TFhirContractTermOffer = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FpartyList : TFhirContractTermOfferPartyList;
    FTopic : TFhirReference{TFhirReference};
    FType_ : TFhirCodeableConcept;
    FDecision : TFhirCodeableConcept;
    FdecisionModeList : TFhirCodeableConceptList;
    FanswerList : TFhirContractTermOfferAnswerList;
    FText : TFhirString;
    FlinkIdList : TFhirStringList;
    FsecurityLabelNumberList : TFhirUnsignedIntList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetPartyList : TFhirContractTermOfferPartyList;
    function GetHasPartyList : Boolean;
    Procedure SetTopic(value : TFhirReference{TFhirReference});
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetDecision(value : TFhirCodeableConcept);
    function GetDecisionModeList : TFhirCodeableConceptList;
    function GetHasDecisionModeList : Boolean;
    function GetAnswerList : TFhirContractTermOfferAnswerList;
    function GetHasAnswerList : Boolean;
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    function GetLinkIdList : TFhirStringList;
    function GetHasLinkIdList : Boolean;
    function GetSecurityLabelNumberList : TFhirUnsignedIntList;
    function GetHasSecurityLabelNumberList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermOffer; overload;
    function Clone : TFhirContractTermOffer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Unique identifier for this particular Contract Provision.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Offer Recipient.
    property partyList : TFhirContractTermOfferPartyList read GetPartyList;
    property hasPartyList : boolean read GetHasPartyList;

    // Typed access to The owner of an asset has the residual control rights over the asset: the right to decide all usages of the asset in any way not inconsistent with a prior contract, custom, or law (Hart, 1995, p. 30). (defined for API consistency)
    property topic : TFhirReference{TFhirReference} read FTopic write SetTopic;
    // The owner of an asset has the residual control rights over the asset: the right to decide all usages of the asset in any way not inconsistent with a prior contract, custom, or law (Hart, 1995, p. 30).
    property topicElement : TFhirReference{TFhirReference} read FTopic write SetTopic;

    // Typed access to Type of Contract Provision such as specific requirements, purposes for actions, obligations, prohibitions, e.g. life time maximum benefit. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of Contract Provision such as specific requirements, purposes for actions, obligations, prohibitions, e.g. life time maximum benefit.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Type of choice made by accepting party with respect to an offer made by an offeror/ grantee. (defined for API consistency)
    property decision : TFhirCodeableConcept read FDecision write SetDecision;
    // Type of choice made by accepting party with respect to an offer made by an offeror/ grantee.
    property decisionElement : TFhirCodeableConcept read FDecision write SetDecision;

    // How the decision about a Contract was conveyed.
    property decisionModeList : TFhirCodeableConceptList read GetDecisionModeList;
    property hasDecisionModeList : boolean read GetHasDecisionModeList;

    // Response to offer text.
    property answerList : TFhirContractTermOfferAnswerList read GetAnswerList;
    property hasAnswerList : boolean read GetHasAnswerList;

    // Typed access to Human readable form of this Contract Offer.
    property text : String read GetTextST write SetTextST;
    // Human readable form of this Contract Offer.
    property textElement : TFhirString read FText write SetText;

    // The id of the clause or question text of the offer in the referenced questionnaire/response.
    property linkIdList : TFhirStringList read GetLinkIdList;
    property hasLinkIdList : boolean read GetHasLinkIdList;

    // Security labels that protects the offer.
    property securityLabelNumberList : TFhirUnsignedIntList read GetSecurityLabelNumberList;
    property hasSecurityLabelNumberList : boolean read GetHasSecurityLabelNumberList;

  end;

  TFhirContractTermOfferListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermOfferList;
    function GetCurrent : TFhirContractTermOffer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractTermOfferList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermOffer read GetCurrent;
  end;

  TFhirContractTermOfferList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractTermOffer;
    procedure SetItemN(index : Integer; value : TFhirContractTermOffer);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractTermOfferList; Overload;
    function Clone : TFhirContractTermOfferList; Overload;
    function GetEnumerator : TFhirContractTermOfferListEnumerator;
    

    //  Add a FhirContractTermOffer to the end of the list.
    function Append : TFhirContractTermOffer;

    
    // Add an already existing FhirContractTermOffer to the end of the list.
    procedure AddItem(value : TFhirContractTermOffer); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermOffer) : Integer;
    

    // Insert FhirContractTermOffer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermOffer;
    

    // Insert an existing FhirContractTermOffer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermOffer);
    
    // Get the iIndexth FhirContractTermOffer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermOffer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermOffer;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirContractTermOffers[index : Integer] : TFhirContractTermOffer read GetItemN write SetItemN; default;
  End;

  // Offer Recipient.
  TFhirContractTermOfferParty = class (TFhirBackboneElement)
  protected
    FreferenceList : TFhirReferenceList{TFhirPatient};
    FRole : TFhirCodeableConcept;
    function GetReferenceList : TFhirReferenceList{TFhirPatient};
    function GetHasReferenceList : Boolean;
    Procedure SetRole(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermOfferParty; overload;
    function Clone : TFhirContractTermOfferParty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Participant in the offer.
    property referenceList : TFhirReferenceList{TFhirPatient} read GetReferenceList;
    property hasReferenceList : boolean read GetHasReferenceList;

    // Typed access to How the party participates in the offer. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // How the party participates in the offer.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

  end;

  TFhirContractTermOfferPartyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermOfferPartyList;
    function GetCurrent : TFhirContractTermOfferParty;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractTermOfferPartyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermOfferParty read GetCurrent;
  end;

  TFhirContractTermOfferPartyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractTermOfferParty;
    procedure SetItemN(index : Integer; value : TFhirContractTermOfferParty);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractTermOfferPartyList; Overload;
    function Clone : TFhirContractTermOfferPartyList; Overload;
    function GetEnumerator : TFhirContractTermOfferPartyListEnumerator;
    

    //  Add a FhirContractTermOfferParty to the end of the list.
    function Append : TFhirContractTermOfferParty;

    
    // Add an already existing FhirContractTermOfferParty to the end of the list.
    procedure AddItem(value : TFhirContractTermOfferParty); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermOfferParty) : Integer;
    

    // Insert FhirContractTermOfferParty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermOfferParty;
    

    // Insert an existing FhirContractTermOfferParty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermOfferParty);
    
    // Get the iIndexth FhirContractTermOfferParty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermOfferParty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermOfferParty;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirContractTermOfferParties[index : Integer] : TFhirContractTermOfferParty read GetItemN write SetItemN; default;
  End;

  // Response to offer text.
  TFhirContractTermOfferAnswer = class (TFhirBackboneElement)
  protected
    FValue : TFhirType;
    Procedure SetValue(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermOfferAnswer; overload;
    function Clone : TFhirContractTermOfferAnswer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
    property valueElement : TFhirType read FValue write SetValue;

  end;

  TFhirContractTermOfferAnswerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermOfferAnswerList;
    function GetCurrent : TFhirContractTermOfferAnswer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractTermOfferAnswerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermOfferAnswer read GetCurrent;
  end;

  TFhirContractTermOfferAnswerList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractTermOfferAnswer;
    procedure SetItemN(index : Integer; value : TFhirContractTermOfferAnswer);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractTermOfferAnswerList; Overload;
    function Clone : TFhirContractTermOfferAnswerList; Overload;
    function GetEnumerator : TFhirContractTermOfferAnswerListEnumerator;
    

    //  Add a FhirContractTermOfferAnswer to the end of the list.
    function Append : TFhirContractTermOfferAnswer;

    
    // Add an already existing FhirContractTermOfferAnswer to the end of the list.
    procedure AddItem(value : TFhirContractTermOfferAnswer); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermOfferAnswer) : Integer;
    

    // Insert FhirContractTermOfferAnswer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermOfferAnswer;
    

    // Insert an existing FhirContractTermOfferAnswer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermOfferAnswer);
    
    // Get the iIndexth FhirContractTermOfferAnswer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermOfferAnswer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermOfferAnswer;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirContractTermOfferAnswers[index : Integer] : TFhirContractTermOfferAnswer read GetItemN write SetItemN; default;
  End;

  // Contract Term Asset List.
  TFhirContractTermAsset = class (TFhirBackboneElement)
  protected
    FScope : TFhirCodeableConcept;
    Ftype_List : TFhirCodeableConceptList;
    FtypeReferenceList : TFhirReferenceList{TFhirReference};
    FsubtypeList : TFhirCodeableConceptList;
    FRelationship : TFhirCoding;
    FcontextList : TFhirContractTermAssetContextList;
    FCondition : TFhirString;
    FperiodTypeList : TFhirCodeableConceptList;
    FperiodList : TFhirPeriodList;
    FusePeriodList : TFhirPeriodList;
    FText : TFhirString;
    FlinkIdList : TFhirStringList;
    FanswerList : TFhirContractTermOfferAnswerList;
    FsecurityLabelNumberList : TFhirUnsignedIntList;
    FvaluedItemList : TFhirContractTermAssetValuedItemList;
    Procedure SetScope(value : TFhirCodeableConcept);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetTypeReferenceList : TFhirReferenceList{TFhirReference};
    function GetHasTypeReferenceList : Boolean;
    function GetSubtypeList : TFhirCodeableConceptList;
    function GetHasSubtypeList : Boolean;
    Procedure SetRelationship(value : TFhirCoding);
    function GetContextList : TFhirContractTermAssetContextList;
    function GetHasContextList : Boolean;
    Procedure SetCondition(value : TFhirString);
    Function GetConditionST : String;
    Procedure SetConditionST(value : String);
    function GetPeriodTypeList : TFhirCodeableConceptList;
    function GetHasPeriodTypeList : Boolean;
    function GetPeriodList : TFhirPeriodList;
    function GetHasPeriodList : Boolean;
    function GetUsePeriodList : TFhirPeriodList;
    function GetHasUsePeriodList : Boolean;
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    function GetLinkIdList : TFhirStringList;
    function GetHasLinkIdList : Boolean;
    function GetAnswerList : TFhirContractTermOfferAnswerList;
    function GetHasAnswerList : Boolean;
    function GetSecurityLabelNumberList : TFhirUnsignedIntList;
    function GetHasSecurityLabelNumberList : Boolean;
    function GetValuedItemList : TFhirContractTermAssetValuedItemList;
    function GetHasValuedItemList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermAsset; overload;
    function Clone : TFhirContractTermAsset; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Differentiates the kind of the asset . (defined for API consistency)
    property scope : TFhirCodeableConcept read FScope write SetScope;
    // Differentiates the kind of the asset .
    property scopeElement : TFhirCodeableConcept read FScope write SetScope;

    // Target entity type about which the term may be concerned.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Associated entities.
    property typeReferenceList : TFhirReferenceList{TFhirReference} read GetTypeReferenceList;
    property hasTypeReferenceList : boolean read GetHasTypeReferenceList;

    // May be a subtype or part of an offered asset.
    property subtypeList : TFhirCodeableConceptList read GetSubtypeList;
    property hasSubtypeList : boolean read GetHasSubtypeList;

    // Typed access to Specifies the applicability of the term to an asset resource instance, and instances it refers to orinstances that refer to it, and/or are owned by the offeree. (defined for API consistency)
    property relationship : TFhirCoding read FRelationship write SetRelationship;
    // Specifies the applicability of the term to an asset resource instance, and instances it refers to orinstances that refer to it, and/or are owned by the offeree.
    property relationshipElement : TFhirCoding read FRelationship write SetRelationship;

    // Circumstance of the asset.
    property contextList : TFhirContractTermAssetContextList read GetContextList;
    property hasContextList : boolean read GetHasContextList;

    // Typed access to Description of the quality and completeness of the asset that imay be a factor in its valuation.
    property condition : String read GetConditionST write SetConditionST;
    // Description of the quality and completeness of the asset that imay be a factor in its valuation.
    property conditionElement : TFhirString read FCondition write SetCondition;

    // Type of Asset availability for use or ownership.
    property periodTypeList : TFhirCodeableConceptList read GetPeriodTypeList;
    property hasPeriodTypeList : boolean read GetHasPeriodTypeList;

    // Asset relevant contractual time period.
    property periodList : TFhirPeriodList read GetPeriodList;
    property hasPeriodList : boolean read GetHasPeriodList;

    // Time period of asset use.
    property usePeriodList : TFhirPeriodList read GetUsePeriodList;
    property hasUsePeriodList : boolean read GetHasUsePeriodList;

    // Typed access to Clause or question text (Prose Object) concerning the asset in a linked form, such as a QuestionnaireResponse used in the formation of the contract.
    property text : String read GetTextST write SetTextST;
    // Clause or question text (Prose Object) concerning the asset in a linked form, such as a QuestionnaireResponse used in the formation of the contract.
    property textElement : TFhirString read FText write SetText;

    // Id [identifier??] of the clause or question text about the asset in the referenced form or QuestionnaireResponse.
    property linkIdList : TFhirStringList read GetLinkIdList;
    property hasLinkIdList : boolean read GetHasLinkIdList;

    // Response to assets.
    property answerList : TFhirContractTermOfferAnswerList read GetAnswerList;
    property hasAnswerList : boolean read GetHasAnswerList;

    // Security labels that protects the asset.
    property securityLabelNumberList : TFhirUnsignedIntList read GetSecurityLabelNumberList;
    property hasSecurityLabelNumberList : boolean read GetHasSecurityLabelNumberList;

    // Contract Valued Item List.
    property valuedItemList : TFhirContractTermAssetValuedItemList read GetValuedItemList;
    property hasValuedItemList : boolean read GetHasValuedItemList;

  end;

  TFhirContractTermAssetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermAssetList;
    function GetCurrent : TFhirContractTermAsset;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractTermAssetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermAsset read GetCurrent;
  end;

  TFhirContractTermAssetList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractTermAsset;
    procedure SetItemN(index : Integer; value : TFhirContractTermAsset);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractTermAssetList; Overload;
    function Clone : TFhirContractTermAssetList; Overload;
    function GetEnumerator : TFhirContractTermAssetListEnumerator;
    

    //  Add a FhirContractTermAsset to the end of the list.
    function Append : TFhirContractTermAsset;

    
    // Add an already existing FhirContractTermAsset to the end of the list.
    procedure AddItem(value : TFhirContractTermAsset); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermAsset) : Integer;
    

    // Insert FhirContractTermAsset before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermAsset;
    

    // Insert an existing FhirContractTermAsset before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermAsset);
    
    // Get the iIndexth FhirContractTermAsset. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermAsset);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermAsset;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirContractTermAssets[index : Integer] : TFhirContractTermAsset read GetItemN write SetItemN; default;
  End;

  // Circumstance of the asset.
  TFhirContractTermAssetContext = class (TFhirBackboneElement)
  protected
    FReference : TFhirReference{TFhirReference};
    FcodeList : TFhirCodeableConceptList;
    FText : TFhirString;
    Procedure SetReference(value : TFhirReference{TFhirReference});
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermAssetContext; overload;
    function Clone : TFhirContractTermAssetContext; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Asset context reference may include the creator, custodian, or owning Person or Organization (e.g., bank, repository),  location held, e.g., building,  jurisdiction. (defined for API consistency)
    property reference : TFhirReference{TFhirReference} read FReference write SetReference;
    // Asset context reference may include the creator, custodian, or owning Person or Organization (e.g., bank, repository),  location held, e.g., building,  jurisdiction.
    property referenceElement : TFhirReference{TFhirReference} read FReference write SetReference;

    // Coded representation of the context generally or of the Referenced entity, such as the asset holder type or location.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Typed access to Context description.
    property text : String read GetTextST write SetTextST;
    // Context description.
    property textElement : TFhirString read FText write SetText;

  end;

  TFhirContractTermAssetContextListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermAssetContextList;
    function GetCurrent : TFhirContractTermAssetContext;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractTermAssetContextList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermAssetContext read GetCurrent;
  end;

  TFhirContractTermAssetContextList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractTermAssetContext;
    procedure SetItemN(index : Integer; value : TFhirContractTermAssetContext);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractTermAssetContextList; Overload;
    function Clone : TFhirContractTermAssetContextList; Overload;
    function GetEnumerator : TFhirContractTermAssetContextListEnumerator;
    

    //  Add a FhirContractTermAssetContext to the end of the list.
    function Append : TFhirContractTermAssetContext;

    
    // Add an already existing FhirContractTermAssetContext to the end of the list.
    procedure AddItem(value : TFhirContractTermAssetContext); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermAssetContext) : Integer;
    

    // Insert FhirContractTermAssetContext before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermAssetContext;
    

    // Insert an existing FhirContractTermAssetContext before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermAssetContext);
    
    // Get the iIndexth FhirContractTermAssetContext. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermAssetContext);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermAssetContext;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirContractTermAssetContexts[index : Integer] : TFhirContractTermAssetContext read GetItemN write SetItemN; default;
  End;

  // Contract Valued Item List.
  TFhirContractTermAssetValuedItem = class (TFhirBackboneElement)
  protected
    FEntity : TFhirType;
    FIdentifier : TFhirIdentifier;
    FEffectiveTime : TFhirDateTime;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FPoints : TFhirDecimal;
    FNet : TFhirMoney;
    FPayment : TFhirString;
    FPaymentDate : TFhirDateTime;
    FResponsible : TFhirReference{TFhirOrganization};
    FRecipient : TFhirReference{TFhirOrganization};
    FlinkIdList : TFhirStringList;
    FsecurityLabelNumberList : TFhirUnsignedIntList;
    Procedure SetEntity(value : TFhirType);
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetEffectiveTime(value : TFhirDateTime);
    Function GetEffectiveTimeST : TFslDateTime;
    Procedure SetEffectiveTimeST(value : TFslDateTime);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetPoints(value : TFhirDecimal);
    Function GetPointsST : String;
    Procedure SetPointsST(value : String);
    Procedure SetNet(value : TFhirMoney);
    Procedure SetPayment(value : TFhirString);
    Function GetPaymentST : String;
    Procedure SetPaymentST(value : String);
    Procedure SetPaymentDate(value : TFhirDateTime);
    Function GetPaymentDateST : TFslDateTime;
    Procedure SetPaymentDateST(value : TFslDateTime);
    Procedure SetResponsible(value : TFhirReference{TFhirOrganization});
    Procedure SetRecipient(value : TFhirReference{TFhirOrganization});
    function GetLinkIdList : TFhirStringList;
    function GetHasLinkIdList : Boolean;
    function GetSecurityLabelNumberList : TFhirUnsignedIntList;
    function GetHasSecurityLabelNumberList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermAssetValuedItem; overload;
    function Clone : TFhirContractTermAssetValuedItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Specific type of Contract Valued Item that may be priced. (defined for API consistency)
    property entity : TFhirType read FEntity write SetEntity;
    // Specific type of Contract Valued Item that may be priced.
    property entityElement : TFhirType read FEntity write SetEntity;

    // Typed access to Identifies a Contract Valued Item instance. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifies a Contract Valued Item instance.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Indicates the time during which this Contract ValuedItem information is effective.
    property effectiveTime : TFslDateTime read GetEffectiveTimeST write SetEffectiveTimeST;
    // Indicates the time during which this Contract ValuedItem information is effective.
    property effectiveTimeElement : TFhirDateTime read FEffectiveTime write SetEffectiveTime;

    // Typed access to Specifies the units by which the Contract Valued Item is measured or counted, and quantifies the countable or measurable Contract Valued Item instances. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Specifies the units by which the Contract Valued Item is measured or counted, and quantifies the countable or measurable Contract Valued Item instances.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to A Contract Valued Item unit valuation measure. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // A Contract Valued Item unit valuation measure.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of the Contract Valued Item delivered. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of the Contract Valued Item delivered. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the Contract Valued Item delivered. The concept of Points allows for assignment of point values for a Contract Valued Item, such that a monetary amount can be assigned to each point.
    property points : String read GetPointsST write SetPointsST;
    // An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the Contract Valued Item delivered. The concept of Points allows for assignment of point values for a Contract Valued Item, such that a monetary amount can be assigned to each point.
    property pointsElement : TFhirDecimal read FPoints write SetPoints;

    // Typed access to Expresses the product of the Contract Valued Item unitQuantity and the unitPriceAmt. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // Expresses the product of the Contract Valued Item unitQuantity and the unitPriceAmt. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
    property netElement : TFhirMoney read FNet write SetNet;

    // Typed access to Terms of valuation.
    property payment : String read GetPaymentST write SetPaymentST;
    // Terms of valuation.
    property paymentElement : TFhirString read FPayment write SetPayment;

    // Typed access to When payment is due.
    property paymentDate : TFslDateTime read GetPaymentDateST write SetPaymentDateST;
    // When payment is due.
    property paymentDateElement : TFhirDateTime read FPaymentDate write SetPaymentDate;

    // Typed access to Who will make payment. (defined for API consistency)
    property responsible : TFhirReference{TFhirOrganization} read FResponsible write SetResponsible;
    // Who will make payment.
    property responsibleElement : TFhirReference{TFhirOrganization} read FResponsible write SetResponsible;

    // Typed access to Who will receive payment. (defined for API consistency)
    property recipient : TFhirReference{TFhirOrganization} read FRecipient write SetRecipient;
    // Who will receive payment.
    property recipientElement : TFhirReference{TFhirOrganization} read FRecipient write SetRecipient;

    // Id  of the clause or question text related to the context of this valuedItem in the referenced form or QuestionnaireResponse.
    property linkIdList : TFhirStringList read GetLinkIdList;
    property hasLinkIdList : boolean read GetHasLinkIdList;

    // A set of security labels that define which terms are controlled by this condition.
    property securityLabelNumberList : TFhirUnsignedIntList read GetSecurityLabelNumberList;
    property hasSecurityLabelNumberList : boolean read GetHasSecurityLabelNumberList;

  end;

  TFhirContractTermAssetValuedItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermAssetValuedItemList;
    function GetCurrent : TFhirContractTermAssetValuedItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractTermAssetValuedItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermAssetValuedItem read GetCurrent;
  end;

  TFhirContractTermAssetValuedItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractTermAssetValuedItem;
    procedure SetItemN(index : Integer; value : TFhirContractTermAssetValuedItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractTermAssetValuedItemList; Overload;
    function Clone : TFhirContractTermAssetValuedItemList; Overload;
    function GetEnumerator : TFhirContractTermAssetValuedItemListEnumerator;
    

    //  Add a FhirContractTermAssetValuedItem to the end of the list.
    function Append : TFhirContractTermAssetValuedItem;

    
    // Add an already existing FhirContractTermAssetValuedItem to the end of the list.
    procedure AddItem(value : TFhirContractTermAssetValuedItem); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermAssetValuedItem) : Integer;
    

    // Insert FhirContractTermAssetValuedItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermAssetValuedItem;
    

    // Insert an existing FhirContractTermAssetValuedItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermAssetValuedItem);
    
    // Get the iIndexth FhirContractTermAssetValuedItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermAssetValuedItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermAssetValuedItem;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirContractTermAssetValuedItems[index : Integer] : TFhirContractTermAssetValuedItem read GetItemN write SetItemN; default;
  End;

  // An actor taking a role in an activity for which it can be assigned some degree of responsibility for the activity taking place.
  TFhirContractTermAction = class (TFhirBackboneElement)
  protected
    FDoNotPerform : TFhirBoolean;
    FType_ : TFhirCodeableConcept;
    FsubjectList : TFhirContractTermActionSubjectList;
    FIntent : TFhirCodeableConcept;
    FlinkIdList : TFhirStringList;
    FStatus : TFhirCodeableConcept;
    FContext : TFhirReference{TFhirEncounter};
    FcontextLinkIdList : TFhirStringList;
    FOccurrence : TFhirType;
    FrequesterList : TFhirReferenceList{TFhirPatient};
    FrequesterLinkIdList : TFhirStringList;
    FperformerTypeList : TFhirCodeableConceptList;
    FPerformerRole : TFhirCodeableConcept;
    FPerformer : TFhirReference{TFhirRelatedPerson};
    FperformerLinkIdList : TFhirStringList;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList{TFhirCondition};
    FreasonList : TFhirStringList;
    FreasonLinkIdList : TFhirStringList;
    FnoteList : TFhirAnnotationList;
    FsecurityLabelNumberList : TFhirUnsignedIntList;
    Procedure SetDoNotPerform(value : TFhirBoolean);
    Function GetDoNotPerformST : Boolean;
    Procedure SetDoNotPerformST(value : Boolean);
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetSubjectList : TFhirContractTermActionSubjectList;
    function GetHasSubjectList : Boolean;
    Procedure SetIntent(value : TFhirCodeableConcept);
    function GetLinkIdList : TFhirStringList;
    function GetHasLinkIdList : Boolean;
    Procedure SetStatus(value : TFhirCodeableConcept);
    Procedure SetContext(value : TFhirReference{TFhirEncounter});
    function GetContextLinkIdList : TFhirStringList;
    function GetHasContextLinkIdList : Boolean;
    Procedure SetOccurrence(value : TFhirType);
    function GetRequesterList : TFhirReferenceList{TFhirPatient};
    function GetHasRequesterList : Boolean;
    function GetRequesterLinkIdList : TFhirStringList;
    function GetHasRequesterLinkIdList : Boolean;
    function GetPerformerTypeList : TFhirCodeableConceptList;
    function GetHasPerformerTypeList : Boolean;
    Procedure SetPerformerRole(value : TFhirCodeableConcept);
    Procedure SetPerformer(value : TFhirReference{TFhirRelatedPerson});
    function GetPerformerLinkIdList : TFhirStringList;
    function GetHasPerformerLinkIdList : Boolean;
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList{TFhirCondition};
    function GetHasReasonReferenceList : Boolean;
    function GetReasonList : TFhirStringList;
    function GetHasReasonList : Boolean;
    function GetReasonLinkIdList : TFhirStringList;
    function GetHasReasonLinkIdList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetSecurityLabelNumberList : TFhirUnsignedIntList;
    function GetHasSecurityLabelNumberList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermAction; overload;
    function Clone : TFhirContractTermAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to True if the term prohibits the  action.
    property doNotPerform : Boolean read GetDoNotPerformST write SetDoNotPerformST;
    // True if the term prohibits the  action.
    property doNotPerformElement : TFhirBoolean read FDoNotPerform write SetDoNotPerform;

    // Typed access to Activity or service obligation to be done or not done, performed or not performed, effectuated or not by this Contract term. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Activity or service obligation to be done or not done, performed or not performed, effectuated or not by this Contract term.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Entity of the action.
    property subjectList : TFhirContractTermActionSubjectList read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // Typed access to Reason or purpose for the action stipulated by this Contract Provision. (defined for API consistency)
    property intent : TFhirCodeableConcept read FIntent write SetIntent;
    // Reason or purpose for the action stipulated by this Contract Provision.
    property intentElement : TFhirCodeableConcept read FIntent write SetIntent;

    // Id [identifier??] of the clause or question text related to this action in the referenced form or QuestionnaireResponse.
    property linkIdList : TFhirStringList read GetLinkIdList;
    property hasLinkIdList : boolean read GetHasLinkIdList;

    // Typed access to Current state of the term action. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // Current state of the term action.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to Encounter or Episode with primary association to specified term activity. (defined for API consistency)
    property context : TFhirReference{TFhirEncounter} read FContext write SetContext;
    // Encounter or Episode with primary association to specified term activity.
    property contextElement : TFhirReference{TFhirEncounter} read FContext write SetContext;

    // Id [identifier??] of the clause or question text related to the requester of this action in the referenced form or QuestionnaireResponse.
    property contextLinkIdList : TFhirStringList read GetContextLinkIdList;
    property hasContextLinkIdList : boolean read GetHasContextLinkIdList;

    // Typed access to When action happens. (defined for API consistency)
    property occurrence : TFhirType read FOccurrence write SetOccurrence;
    // When action happens.
    property occurrenceElement : TFhirType read FOccurrence write SetOccurrence;

    // Who or what initiated the action and has responsibility for its activation.
    property requesterList : TFhirReferenceList{TFhirPatient} read GetRequesterList;
    property hasRequesterList : boolean read GetHasRequesterList;

    // Id [identifier??] of the clause or question text related to the requester of this action in the referenced form or QuestionnaireResponse.
    property requesterLinkIdList : TFhirStringList read GetRequesterLinkIdList;
    property hasRequesterLinkIdList : boolean read GetHasRequesterLinkIdList;

    // The type of individual that is desired or required to perform or not perform the action.
    property performerTypeList : TFhirCodeableConceptList read GetPerformerTypeList;
    property hasPerformerTypeList : boolean read GetHasPerformerTypeList;

    // Typed access to The type of role or competency of an individual desired or required to perform or not perform the action. (defined for API consistency)
    property performerRole : TFhirCodeableConcept read FPerformerRole write SetPerformerRole;
    // The type of role or competency of an individual desired or required to perform or not perform the action.
    property performerRoleElement : TFhirCodeableConcept read FPerformerRole write SetPerformerRole;

    // Typed access to Indicates who or what is being asked to perform (or not perform) the ction. (defined for API consistency)
    property performer : TFhirReference{TFhirRelatedPerson} read FPerformer write SetPerformer;
    // Indicates who or what is being asked to perform (or not perform) the ction.
    property performerElement : TFhirReference{TFhirRelatedPerson} read FPerformer write SetPerformer;

    // Id [identifier??] of the clause or question text related to the reason type or reference of this  action in the referenced form or QuestionnaireResponse.
    property performerLinkIdList : TFhirStringList read GetPerformerLinkIdList;
    property hasPerformerLinkIdList : boolean read GetHasPerformerLinkIdList;

    // Rationale for the action to be performed or not performed. Describes why the action is permitted or prohibited.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Indicates another resource whose existence justifies permitting or not permitting this action.
    property reasonReferenceList : TFhirReferenceList{TFhirCondition} read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Describes why the action is to be performed or not performed in textual form.
    property reasonList : TFhirStringList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Id [identifier??] of the clause or question text related to the reason type or reference of this  action in the referenced form or QuestionnaireResponse.
    property reasonLinkIdList : TFhirStringList read GetReasonLinkIdList;
    property hasReasonLinkIdList : boolean read GetHasReasonLinkIdList;

    // Comments made about the term action made by the requester, performer, subject or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Security labels that protects the action.
    property securityLabelNumberList : TFhirUnsignedIntList read GetSecurityLabelNumberList;
    property hasSecurityLabelNumberList : boolean read GetHasSecurityLabelNumberList;

  end;

  TFhirContractTermActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermActionList;
    function GetCurrent : TFhirContractTermAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractTermActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermAction read GetCurrent;
  end;

  TFhirContractTermActionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractTermAction;
    procedure SetItemN(index : Integer; value : TFhirContractTermAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractTermActionList; Overload;
    function Clone : TFhirContractTermActionList; Overload;
    function GetEnumerator : TFhirContractTermActionListEnumerator;
    

    //  Add a FhirContractTermAction to the end of the list.
    function Append : TFhirContractTermAction;

    
    // Add an already existing FhirContractTermAction to the end of the list.
    procedure AddItem(value : TFhirContractTermAction); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermAction) : Integer;
    

    // Insert FhirContractTermAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermAction;
    

    // Insert an existing FhirContractTermAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermAction);
    
    // Get the iIndexth FhirContractTermAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermAction;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirContractTermActions[index : Integer] : TFhirContractTermAction read GetItemN write SetItemN; default;
  End;

  // Entity of the action.
  TFhirContractTermActionSubject = class (TFhirBackboneElement)
  protected
    FreferenceList : TFhirReferenceList{TFhirPatient};
    FRole : TFhirCodeableConcept;
    function GetReferenceList : TFhirReferenceList{TFhirPatient};
    function GetHasReferenceList : Boolean;
    Procedure SetRole(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermActionSubject; overload;
    function Clone : TFhirContractTermActionSubject; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The entity the action is performed or not performed on or for.
    property referenceList : TFhirReferenceList{TFhirPatient} read GetReferenceList;
    property hasReferenceList : boolean read GetHasReferenceList;

    // Typed access to Role type of agent assigned roles in this Contract. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Role type of agent assigned roles in this Contract.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

  end;

  TFhirContractTermActionSubjectListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermActionSubjectList;
    function GetCurrent : TFhirContractTermActionSubject;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractTermActionSubjectList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermActionSubject read GetCurrent;
  end;

  TFhirContractTermActionSubjectList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractTermActionSubject;
    procedure SetItemN(index : Integer; value : TFhirContractTermActionSubject);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractTermActionSubjectList; Overload;
    function Clone : TFhirContractTermActionSubjectList; Overload;
    function GetEnumerator : TFhirContractTermActionSubjectListEnumerator;
    

    //  Add a FhirContractTermActionSubject to the end of the list.
    function Append : TFhirContractTermActionSubject;

    
    // Add an already existing FhirContractTermActionSubject to the end of the list.
    procedure AddItem(value : TFhirContractTermActionSubject); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermActionSubject) : Integer;
    

    // Insert FhirContractTermActionSubject before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermActionSubject;
    

    // Insert an existing FhirContractTermActionSubject before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermActionSubject);
    
    // Get the iIndexth FhirContractTermActionSubject. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermActionSubject);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermActionSubject;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirContractTermActionSubjects[index : Integer] : TFhirContractTermActionSubject read GetItemN write SetItemN; default;
  End;

  // Parties with legal standing in the Contract, including the principal parties, the grantor(s) and grantee(s), which are any person or organization bound by the contract, and any ancillary parties, which facilitate the execution of the contract such as a notary or witness.
  TFhirContractSigner = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCoding;
    FParty : TFhirReference{TFhirOrganization};
    FsignatureList : TFhirSignatureList;
    Procedure SetType_(value : TFhirCoding);
    Procedure SetParty(value : TFhirReference{TFhirOrganization});
    function GetSignatureList : TFhirSignatureList;
    function GetHasSignatureList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractSigner; overload;
    function Clone : TFhirContractSigner; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Role of this Contract signer, e.g. notary, grantee. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // Role of this Contract signer, e.g. notary, grantee.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to Party which is a signator to this Contract. (defined for API consistency)
    property party : TFhirReference{TFhirOrganization} read FParty write SetParty;
    // Party which is a signator to this Contract.
    property partyElement : TFhirReference{TFhirOrganization} read FParty write SetParty;

    // Legally binding Contract DSIG signature contents in Base64.
    property signatureList : TFhirSignatureList read GetSignatureList;
    property hasSignatureList : boolean read GetHasSignatureList;

  end;

  TFhirContractSignerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractSignerList;
    function GetCurrent : TFhirContractSigner;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractSignerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractSigner read GetCurrent;
  end;

  TFhirContractSignerList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractSigner;
    procedure SetItemN(index : Integer; value : TFhirContractSigner);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractSignerList; Overload;
    function Clone : TFhirContractSignerList; Overload;
    function GetEnumerator : TFhirContractSignerListEnumerator;
    

    //  Add a FhirContractSigner to the end of the list.
    function Append : TFhirContractSigner;

    
    // Add an already existing FhirContractSigner to the end of the list.
    procedure AddItem(value : TFhirContractSigner); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractSigner) : Integer;
    

    // Insert FhirContractSigner before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractSigner;
    

    // Insert an existing FhirContractSigner before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractSigner);
    
    // Get the iIndexth FhirContractSigner. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractSigner);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractSigner;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirContractSigners[index : Integer] : TFhirContractSigner read GetItemN write SetItemN; default;
  End;

  // The "patient friendly language" versionof the Contract in whole or in parts. "Patient friendly language" means the representation of the Contract and Contract Provisions in a manner that is readily accessible and understandable by a layperson in accordance with best practices for communication styles that ensure that those agreeing to or signing the Contract understand the roles, actions, obligations, responsibilities, and implication of the agreement.
  TFhirContractFriendly = class (TFhirBackboneElement)
  protected
    FContent : TFhirType;
    Procedure SetContent(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractFriendly; overload;
    function Clone : TFhirContractFriendly; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Human readable rendering of this Contract in a format and representation intended to enhance comprehension and ensure understandability. (defined for API consistency)
    property content : TFhirType read FContent write SetContent;
    // Human readable rendering of this Contract in a format and representation intended to enhance comprehension and ensure understandability.
    property contentElement : TFhirType read FContent write SetContent;

  end;

  TFhirContractFriendlyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractFriendlyList;
    function GetCurrent : TFhirContractFriendly;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractFriendlyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractFriendly read GetCurrent;
  end;

  TFhirContractFriendlyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractFriendly;
    procedure SetItemN(index : Integer; value : TFhirContractFriendly);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractFriendlyList; Overload;
    function Clone : TFhirContractFriendlyList; Overload;
    function GetEnumerator : TFhirContractFriendlyListEnumerator;
    

    //  Add a FhirContractFriendly to the end of the list.
    function Append : TFhirContractFriendly;

    
    // Add an already existing FhirContractFriendly to the end of the list.
    procedure AddItem(value : TFhirContractFriendly); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractFriendly) : Integer;
    

    // Insert FhirContractFriendly before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractFriendly;
    

    // Insert an existing FhirContractFriendly before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractFriendly);
    
    // Get the iIndexth FhirContractFriendly. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractFriendly);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractFriendly;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirContractFriendlies[index : Integer] : TFhirContractFriendly read GetItemN write SetItemN; default;
  End;

  // List of Legal expressions or representations of this Contract.
  TFhirContractLegal = class (TFhirBackboneElement)
  protected
    FContent : TFhirType;
    Procedure SetContent(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractLegal; overload;
    function Clone : TFhirContractLegal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Contract legal text in human renderable form. (defined for API consistency)
    property content : TFhirType read FContent write SetContent;
    // Contract legal text in human renderable form.
    property contentElement : TFhirType read FContent write SetContent;

  end;

  TFhirContractLegalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractLegalList;
    function GetCurrent : TFhirContractLegal;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractLegalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractLegal read GetCurrent;
  end;

  TFhirContractLegalList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractLegal;
    procedure SetItemN(index : Integer; value : TFhirContractLegal);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractLegalList; Overload;
    function Clone : TFhirContractLegalList; Overload;
    function GetEnumerator : TFhirContractLegalListEnumerator;
    

    //  Add a FhirContractLegal to the end of the list.
    function Append : TFhirContractLegal;

    
    // Add an already existing FhirContractLegal to the end of the list.
    procedure AddItem(value : TFhirContractLegal); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractLegal) : Integer;
    

    // Insert FhirContractLegal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractLegal;
    

    // Insert an existing FhirContractLegal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractLegal);
    
    // Get the iIndexth FhirContractLegal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractLegal);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractLegal;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirContractLegals[index : Integer] : TFhirContractLegal read GetItemN write SetItemN; default;
  End;

  // List of Computable Policy Rule Language Representations of this Contract.
  TFhirContractRule = class (TFhirBackboneElement)
  protected
    FContent : TFhirType;
    Procedure SetContent(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractRule; overload;
    function Clone : TFhirContractRule; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Computable Contract conveyed using a policy rule language (e.g. XACML, DKAL, SecPal). (defined for API consistency)
    property content : TFhirType read FContent write SetContent;
    // Computable Contract conveyed using a policy rule language (e.g. XACML, DKAL, SecPal).
    property contentElement : TFhirType read FContent write SetContent;

  end;

  TFhirContractRuleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractRuleList;
    function GetCurrent : TFhirContractRule;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractRuleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractRule read GetCurrent;
  end;

  TFhirContractRuleList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContractRule;
    procedure SetItemN(index : Integer; value : TFhirContractRule);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractRuleList; Overload;
    function Clone : TFhirContractRuleList; Overload;
    function GetEnumerator : TFhirContractRuleListEnumerator;
    

    //  Add a FhirContractRule to the end of the list.
    function Append : TFhirContractRule;

    
    // Add an already existing FhirContractRule to the end of the list.
    procedure AddItem(value : TFhirContractRule); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractRule) : Integer;
    

    // Insert FhirContractRule before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractRule;
    

    // Insert an existing FhirContractRule before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractRule);
    
    // Get the iIndexth FhirContractRule. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractRule);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractRule;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirContractRules[index : Integer] : TFhirContractRule read GetItemN write SetItemN; default;
  End;

  // Legally enforceable, formally recorded unilateral or bilateral directive i.e., a policy or agreement.
  TFhirContract = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FUrl : TFhirUri;
    FVersion : TFhirString;
    FStatus : TFhirEnum;
    FLegalState : TFhirCodeableConcept;
    FInstantiatesCanonical : TFhirReference{TFhirContract};
    FInstantiatesUri : TFhirUri;
    FContentDerivative : TFhirCodeableConcept;
    FIssued : TFhirDateTime;
    FApplies : TFhirPeriod;
    FExpirationType : TFhirCodeableConcept;
    FsubjectList : TFhirReferenceList{TFhirReference};
    FauthorityList : TFhirReferenceList{TFhirOrganization};
    FdomainList : TFhirReferenceList{TFhirLocation};
    FsiteList : TFhirReferenceList{TFhirLocation};
    FName : TFhirString;
    FTitle : TFhirString;
    FSubtitle : TFhirString;
    FaliasList : TFhirStringList;
    FAuthor : TFhirReference{TFhirPatient};
    FScope : TFhirCodeableConcept;
    FTopic : TFhirType;
    FType_ : TFhirCodeableConcept;
    FsubTypeList : TFhirCodeableConceptList;
    FContentDefinition : TFhirContractContentDefinition;
    FtermList : TFhirContractTermList;
    FsupportingInfoList : TFhirReferenceList{TFhirReference};
    FrelevantHistoryList : TFhirReferenceList{TFhirProvenance};
    FsignerList : TFhirContractSignerList;
    FfriendlyList : TFhirContractFriendlyList;
    FlegalList : TFhirContractLegalList;
    FruleList : TFhirContractRuleList;
    FLegallyBinding : TFhirType;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirContractStatusEnum;
    Procedure SetStatusST(value : TFhirContractStatusEnum);
    Procedure SetLegalState(value : TFhirCodeableConcept);
    Procedure SetInstantiatesCanonical(value : TFhirReference{TFhirContract});
    Procedure SetInstantiatesUri(value : TFhirUri);
    Function GetInstantiatesUriST : String;
    Procedure SetInstantiatesUriST(value : String);
    Procedure SetContentDerivative(value : TFhirCodeableConcept);
    Procedure SetIssued(value : TFhirDateTime);
    Function GetIssuedST : TFslDateTime;
    Procedure SetIssuedST(value : TFslDateTime);
    Procedure SetApplies(value : TFhirPeriod);
    Procedure SetExpirationType(value : TFhirCodeableConcept);
    function GetSubjectList : TFhirReferenceList{TFhirReference};
    function GetHasSubjectList : Boolean;
    function GetAuthorityList : TFhirReferenceList{TFhirOrganization};
    function GetHasAuthorityList : Boolean;
    function GetDomainList : TFhirReferenceList{TFhirLocation};
    function GetHasDomainList : Boolean;
    function GetSiteList : TFhirReferenceList{TFhirLocation};
    function GetHasSiteList : Boolean;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetSubtitle(value : TFhirString);
    Function GetSubtitleST : String;
    Procedure SetSubtitleST(value : String);
    function GetAliasList : TFhirStringList;
    function GetHasAliasList : Boolean;
    Procedure SetAuthor(value : TFhirReference{TFhirPatient});
    Procedure SetScope(value : TFhirCodeableConcept);
    Procedure SetTopic(value : TFhirType);
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetSubTypeList : TFhirCodeableConceptList;
    function GetHasSubTypeList : Boolean;
    Procedure SetContentDefinition(value : TFhirContractContentDefinition);
    function GetTermList : TFhirContractTermList;
    function GetHasTermList : Boolean;
    function GetSupportingInfoList : TFhirReferenceList{TFhirReference};
    function GetHasSupportingInfoList : Boolean;
    function GetRelevantHistoryList : TFhirReferenceList{TFhirProvenance};
    function GetHasRelevantHistoryList : Boolean;
    function GetSignerList : TFhirContractSignerList;
    function GetHasSignerList : Boolean;
    function GetFriendlyList : TFhirContractFriendlyList;
    function GetHasFriendlyList : Boolean;
    function GetLegalList : TFhirContractLegalList;
    function GetHasLegalList : Boolean;
    function GetRuleList : TFhirContractRuleList;
    function GetHasRuleList : Boolean;
    Procedure SetLegallyBinding(value : TFhirType);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContract; overload;
    function Clone : TFhirContract; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Unique identifier for this Contract or a derivative that references a Source Contract.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Canonical identifier for this contract, represented as a URI (globally unique).
    property url : String read GetUrlST write SetUrlST;
    // Canonical identifier for this contract, represented as a URI (globally unique).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to An edition identifier used for business purposes to label business significant variants.
    property version : String read GetVersionST write SetVersionST;
    // An edition identifier used for business purposes to label business significant variants.
    property versionElement : TFhirString read FVersion write SetVersion;

    // The status of the resource instance.
    property status : TFhirContractStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Legal states of the formation of a legal instrument, which is a formally executed written document that can be formally attributed to its author, records and formally expresses a legally enforceable act, process, or contractual duty, obligation, or right, and therefore evidences that act, process, or agreement. (defined for API consistency)
    property legalState : TFhirCodeableConcept read FLegalState write SetLegalState;
    // Legal states of the formation of a legal instrument, which is a formally executed written document that can be formally attributed to its author, records and formally expresses a legally enforceable act, process, or contractual duty, obligation, or right, and therefore evidences that act, process, or agreement.
    property legalStateElement : TFhirCodeableConcept read FLegalState write SetLegalState;

    // Typed access to The URL pointing to a FHIR-defined Contract Definition that is adhered to in whole or part by this Contract. (defined for API consistency)
    property instantiatesCanonical : TFhirReference{TFhirContract} read FInstantiatesCanonical write SetInstantiatesCanonical;
    // The URL pointing to a FHIR-defined Contract Definition that is adhered to in whole or part by this Contract.
    property instantiatesCanonicalElement : TFhirReference{TFhirContract} read FInstantiatesCanonical write SetInstantiatesCanonical;

    // Typed access to The URL pointing to an externally maintained definition that is adhered to in whole or in part by this Contract.
    property instantiatesUri : String read GetInstantiatesUriST write SetInstantiatesUriST;
    // The URL pointing to an externally maintained definition that is adhered to in whole or in part by this Contract.
    property instantiatesUriElement : TFhirUri read FInstantiatesUri write SetInstantiatesUri;

    // Typed access to The minimal content derived from the basal information source at a specific stage in its lifecycle. (defined for API consistency)
    property contentDerivative : TFhirCodeableConcept read FContentDerivative write SetContentDerivative;
    // The minimal content derived from the basal information source at a specific stage in its lifecycle.
    property contentDerivativeElement : TFhirCodeableConcept read FContentDerivative write SetContentDerivative;

    // Typed access to When this  Contract was issued.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // When this  Contract was issued.
    property issuedElement : TFhirDateTime read FIssued write SetIssued;

    // Typed access to Relevant time or time-period when this Contract is applicable. (defined for API consistency)
    property applies : TFhirPeriod read FApplies write SetApplies;
    // Relevant time or time-period when this Contract is applicable.
    property appliesElement : TFhirPeriod read FApplies write SetApplies;

    // Typed access to Event resulting in discontinuation or termination of this Contract instance by one or more parties to the contract. (defined for API consistency)
    property expirationType : TFhirCodeableConcept read FExpirationType write SetExpirationType;
    // Event resulting in discontinuation or termination of this Contract instance by one or more parties to the contract.
    property expirationTypeElement : TFhirCodeableConcept read FExpirationType write SetExpirationType;

    // The target entity impacted by or of interest to parties to the agreement.
    property subjectList : TFhirReferenceList{TFhirReference} read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // A formally or informally recognized grouping of people, principals, organizations, or jurisdictions formed for the purpose of achieving some form of collective action such as the promulgation, administration and enforcement of contracts and policies.
    property authorityList : TFhirReferenceList{TFhirOrganization} read GetAuthorityList;
    property hasAuthorityList : boolean read GetHasAuthorityList;

    // Recognized governance framework or system operating with a circumscribed scope in accordance with specified principles, policies, processes or procedures for managing rights, actions, or behaviors of parties or principals relative to resources.
    property domainList : TFhirReferenceList{TFhirLocation} read GetDomainList;
    property hasDomainList : boolean read GetHasDomainList;

    // Sites in which the contract is complied with,  exercised, or in force.
    property siteList : TFhirReferenceList{TFhirLocation} read GetSiteList;
    property hasSiteList : boolean read GetHasSiteList;

    // Typed access to A natural language name identifying this Contract definition, derivative, or instance in any legal state. Provides additional information about its content. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying this Contract definition, derivative, or instance in any legal state. Provides additional information about its content. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for this Contract definition, derivative, or instance in any legal state.t giving additional information about its content.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for this Contract definition, derivative, or instance in any legal state.t giving additional information about its content.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to An explanatory or alternate user-friendly title for this Contract definition, derivative, or instance in any legal state.t giving additional information about its content.
    property subtitle : String read GetSubtitleST write SetSubtitleST;
    // An explanatory or alternate user-friendly title for this Contract definition, derivative, or instance in any legal state.t giving additional information about its content.
    property subtitleElement : TFhirString read FSubtitle write SetSubtitle;

    // Alternative representation of the title for this Contract definition, derivative, or instance in any legal state., e.g., a domain specific contract number related to legislation.
    property aliasList : TFhirStringList read GetAliasList;
    property hasAliasList : boolean read GetHasAliasList;

    // Typed access to The individual or organization that authored the Contract definition, derivative, or instance in any legal state. (defined for API consistency)
    property author : TFhirReference{TFhirPatient} read FAuthor write SetAuthor;
    // The individual or organization that authored the Contract definition, derivative, or instance in any legal state.
    property authorElement : TFhirReference{TFhirPatient} read FAuthor write SetAuthor;

    // Typed access to A selector of legal concerns for this Contract definition, derivative, or instance in any legal state. (defined for API consistency)
    property scope : TFhirCodeableConcept read FScope write SetScope;
    // A selector of legal concerns for this Contract definition, derivative, or instance in any legal state.
    property scopeElement : TFhirCodeableConcept read FScope write SetScope;

    // Typed access to Narrows the range of legal concerns to focus on the achievement of specific contractual objectives. (defined for API consistency)
    property topic : TFhirType read FTopic write SetTopic;
    // Narrows the range of legal concerns to focus on the achievement of specific contractual objectives.
    property topicElement : TFhirType read FTopic write SetTopic;

    // Typed access to A high-level category for the legal instrument, whether constructed as a Contract definition, derivative, or instance in any legal state.  Provides additional information about its content within the context of the Contract's scope to distinguish the kinds of systems that would be interested in the contract. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A high-level category for the legal instrument, whether constructed as a Contract definition, derivative, or instance in any legal state.  Provides additional information about its content within the context of the Contract's scope to distinguish the kinds of systems that would be interested in the contract.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Sub-category for the Contract that distinguishes the kinds of systems that would be interested in the Contract within the context of the Contract's scope.
    property subTypeList : TFhirCodeableConceptList read GetSubTypeList;
    property hasSubTypeList : boolean read GetHasSubTypeList;

    // Typed access to Precusory content developed with a focus and intent of supporting the formation a Contract instance, which may be associated with and transformable into a Contract. (defined for API consistency)
    property contentDefinition : TFhirContractContentDefinition read FContentDefinition write SetContentDefinition;
    // Precusory content developed with a focus and intent of supporting the formation a Contract instance, which may be associated with and transformable into a Contract.
    property contentDefinitionElement : TFhirContractContentDefinition read FContentDefinition write SetContentDefinition;

    // One or more Contract Provisions, which may be related and conveyed as a group, and may contain nested groups.
    property termList : TFhirContractTermList read GetTermList;
    property hasTermList : boolean read GetHasTermList;

    // Information that may be needed by/relevant to the performer in their execution of this term action.
    property supportingInfoList : TFhirReferenceList{TFhirReference} read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Links to Provenance records for past versions of this Contract definition, derivative, or instance, which identify key state transitions or updates that are likely to be relevant to a user looking at the current version of the Contract.  The Provence.entity indicates the target that was changed in the update. http://build.fhir.org/provenance-definitions.html#Provenance.entity.
    property relevantHistoryList : TFhirReferenceList{TFhirProvenance} read GetRelevantHistoryList;
    property hasRelevantHistoryList : boolean read GetHasRelevantHistoryList;

    // Parties with legal standing in the Contract, including the principal parties, the grantor(s) and grantee(s), which are any person or organization bound by the contract, and any ancillary parties, which facilitate the execution of the contract such as a notary or witness.
    property signerList : TFhirContractSignerList read GetSignerList;
    property hasSignerList : boolean read GetHasSignerList;

    // The "patient friendly language" versionof the Contract in whole or in parts. "Patient friendly language" means the representation of the Contract and Contract Provisions in a manner that is readily accessible and understandable by a layperson in accordance with best practices for communication styles that ensure that those agreeing to or signing the Contract understand the roles, actions, obligations, responsibilities, and implication of the agreement.
    property friendlyList : TFhirContractFriendlyList read GetFriendlyList;
    property hasFriendlyList : boolean read GetHasFriendlyList;

    // List of Legal expressions or representations of this Contract.
    property legalList : TFhirContractLegalList read GetLegalList;
    property hasLegalList : boolean read GetHasLegalList;

    // List of Computable Policy Rule Language Representations of this Contract.
    property ruleList : TFhirContractRuleList read GetRuleList;
    property hasRuleList : boolean read GetHasRuleList;

    // Typed access to Legally binding Contract: This is the signed and legally recognized representation of the Contract, which is considered the "source of truth" and which would be the basis for legal action related to enforcement of this Contract. (defined for API consistency)
    property legallyBinding : TFhirType read FLegallyBinding write SetLegallyBinding;
    // Legally binding Contract: This is the signed and legally recognized representation of the Contract, which is considered the "source of truth" and which would be the basis for legal action related to enforcement of this Contract.
    property legallyBindingElement : TFhirType read FLegallyBinding write SetLegallyBinding;

  end;

  TFhirContractListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractList;
    function GetCurrent : TFhirContract;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContractList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContract read GetCurrent;
  end;

  TFhirContractList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContract;
    procedure SetItemN(index : Integer; value : TFhirContract);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContractList; Overload;
    function Clone : TFhirContractList; Overload;
    function GetEnumerator : TFhirContractListEnumerator;
    

    //  Add a FhirContract to the end of the list.
    function Append : TFhirContract;

    
    // Add an already existing FhirContract to the end of the list.
    procedure AddItem(value : TFhirContract); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContract) : Integer;
    

    // Insert FhirContract before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContract;
    

    // Insert an existing FhirContract before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContract);
    
    // Get the iIndexth FhirContract. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContract);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContract;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirContracts[index : Integer] : TFhirContract read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CONTRACT}

{$IFDEF FHIR_EFFECTEVIDENCESYNTHESIS}

  // A description of the size of the sample involved in the synthesis.
  TFhirEffectEvidenceSynthesisSampleSize = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FNumberOfStudies : TFhirInteger;
    FNumberOfParticipants : TFhirInteger;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetNumberOfStudies(value : TFhirInteger);
    Function GetNumberOfStudiesST : String;
    Procedure SetNumberOfStudiesST(value : String);
    Procedure SetNumberOfParticipants(value : TFhirInteger);
    Function GetNumberOfParticipantsST : String;
    Procedure SetNumberOfParticipantsST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEffectEvidenceSynthesisSampleSize; overload;
    function Clone : TFhirEffectEvidenceSynthesisSampleSize; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Human-readable summary of sample size.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human-readable summary of sample size.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Number of studies included in this evidence synthesis.
    property numberOfStudies : String read GetNumberOfStudiesST write SetNumberOfStudiesST;
    // Number of studies included in this evidence synthesis.
    property numberOfStudiesElement : TFhirInteger read FNumberOfStudies write SetNumberOfStudies;

    // Typed access to Number of participants included in this evidence synthesis.
    property numberOfParticipants : String read GetNumberOfParticipantsST write SetNumberOfParticipantsST;
    // Number of participants included in this evidence synthesis.
    property numberOfParticipantsElement : TFhirInteger read FNumberOfParticipants write SetNumberOfParticipants;

  end;

  TFhirEffectEvidenceSynthesisSampleSizeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEffectEvidenceSynthesisSampleSizeList;
    function GetCurrent : TFhirEffectEvidenceSynthesisSampleSize;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEffectEvidenceSynthesisSampleSizeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEffectEvidenceSynthesisSampleSize read GetCurrent;
  end;

  TFhirEffectEvidenceSynthesisSampleSizeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEffectEvidenceSynthesisSampleSize;
    procedure SetItemN(index : Integer; value : TFhirEffectEvidenceSynthesisSampleSize);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEffectEvidenceSynthesisSampleSizeList; Overload;
    function Clone : TFhirEffectEvidenceSynthesisSampleSizeList; Overload;
    function GetEnumerator : TFhirEffectEvidenceSynthesisSampleSizeListEnumerator;
    

    //  Add a FhirEffectEvidenceSynthesisSampleSize to the end of the list.
    function Append : TFhirEffectEvidenceSynthesisSampleSize;

    
    // Add an already existing FhirEffectEvidenceSynthesisSampleSize to the end of the list.
    procedure AddItem(value : TFhirEffectEvidenceSynthesisSampleSize); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEffectEvidenceSynthesisSampleSize) : Integer;
    

    // Insert FhirEffectEvidenceSynthesisSampleSize before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEffectEvidenceSynthesisSampleSize;
    

    // Insert an existing FhirEffectEvidenceSynthesisSampleSize before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEffectEvidenceSynthesisSampleSize);
    
    // Get the iIndexth FhirEffectEvidenceSynthesisSampleSize. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEffectEvidenceSynthesisSampleSize);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEffectEvidenceSynthesisSampleSize;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEffectEvidenceSynthesisSampleSizes[index : Integer] : TFhirEffectEvidenceSynthesisSampleSize read GetItemN write SetItemN; default;
  End;

  // A description of the results for each exposure considered in the effect estimate.
  TFhirEffectEvidenceSynthesisResultsByExposure = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FExposureState : TFhirEnum;
    FVariantState : TFhirCodeableConcept;
    FRiskEvidenceSynthesis : TFhirReference{TFhirRiskEvidenceSynthesis};
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetExposureState(value : TFhirEnum);
    Function GetExposureStateST : TFhirExposureStateEnum;
    Procedure SetExposureStateST(value : TFhirExposureStateEnum);
    Procedure SetVariantState(value : TFhirCodeableConcept);
    Procedure SetRiskEvidenceSynthesis(value : TFhirReference{TFhirRiskEvidenceSynthesis});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEffectEvidenceSynthesisResultsByExposure; overload;
    function Clone : TFhirEffectEvidenceSynthesisResultsByExposure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Human-readable summary of results by exposure state.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human-readable summary of results by exposure state.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Whether these results are for the exposure state or alternative exposure state.
    property exposureState : TFhirExposureStateEnum read GetExposureStateST write SetExposureStateST;
    property exposureStateElement : TFhirEnum read FExposureState write SetExposureState;

    // Typed access to Used to define variant exposure states such as low-risk state. (defined for API consistency)
    property variantState : TFhirCodeableConcept read FVariantState write SetVariantState;
    // Used to define variant exposure states such as low-risk state.
    property variantStateElement : TFhirCodeableConcept read FVariantState write SetVariantState;

    // Typed access to Reference to a RiskEvidenceSynthesis resource. (defined for API consistency)
    property riskEvidenceSynthesis : TFhirReference{TFhirRiskEvidenceSynthesis} read FRiskEvidenceSynthesis write SetRiskEvidenceSynthesis;
    // Reference to a RiskEvidenceSynthesis resource.
    property riskEvidenceSynthesisElement : TFhirReference{TFhirRiskEvidenceSynthesis} read FRiskEvidenceSynthesis write SetRiskEvidenceSynthesis;

  end;

  TFhirEffectEvidenceSynthesisResultsByExposureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEffectEvidenceSynthesisResultsByExposureList;
    function GetCurrent : TFhirEffectEvidenceSynthesisResultsByExposure;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEffectEvidenceSynthesisResultsByExposureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEffectEvidenceSynthesisResultsByExposure read GetCurrent;
  end;

  TFhirEffectEvidenceSynthesisResultsByExposureList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEffectEvidenceSynthesisResultsByExposure;
    procedure SetItemN(index : Integer; value : TFhirEffectEvidenceSynthesisResultsByExposure);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEffectEvidenceSynthesisResultsByExposureList; Overload;
    function Clone : TFhirEffectEvidenceSynthesisResultsByExposureList; Overload;
    function GetEnumerator : TFhirEffectEvidenceSynthesisResultsByExposureListEnumerator;
    

    //  Add a FhirEffectEvidenceSynthesisResultsByExposure to the end of the list.
    function Append : TFhirEffectEvidenceSynthesisResultsByExposure;

    
    // Add an already existing FhirEffectEvidenceSynthesisResultsByExposure to the end of the list.
    procedure AddItem(value : TFhirEffectEvidenceSynthesisResultsByExposure); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEffectEvidenceSynthesisResultsByExposure) : Integer;
    

    // Insert FhirEffectEvidenceSynthesisResultsByExposure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEffectEvidenceSynthesisResultsByExposure;
    

    // Insert an existing FhirEffectEvidenceSynthesisResultsByExposure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEffectEvidenceSynthesisResultsByExposure);
    
    // Get the iIndexth FhirEffectEvidenceSynthesisResultsByExposure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEffectEvidenceSynthesisResultsByExposure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEffectEvidenceSynthesisResultsByExposure;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEffectEvidenceSynthesisResultsByExposures[index : Integer] : TFhirEffectEvidenceSynthesisResultsByExposure read GetItemN write SetItemN; default;
  End;

  // The estimated effect of the exposure variant.
  TFhirEffectEvidenceSynthesisEffectEstimate = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FType_ : TFhirCodeableConcept;
    FVariantState : TFhirCodeableConcept;
    FValue : TFhirDecimal;
    FUnitOfMeasure : TFhirCodeableConcept;
    FprecisionEstimateList : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetVariantState(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirDecimal);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
    Procedure SetUnitOfMeasure(value : TFhirCodeableConcept);
    function GetPrecisionEstimateList : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList;
    function GetHasPrecisionEstimateList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEffectEvidenceSynthesisEffectEstimate; overload;
    function Clone : TFhirEffectEvidenceSynthesisEffectEstimate; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Human-readable summary of effect estimate.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human-readable summary of effect estimate.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Examples include relative risk and mean difference. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Examples include relative risk and mean difference.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Used to define variant exposure states such as low-risk state. (defined for API consistency)
    property variantState : TFhirCodeableConcept read FVariantState write SetVariantState;
    // Used to define variant exposure states such as low-risk state.
    property variantStateElement : TFhirCodeableConcept read FVariantState write SetVariantState;

    // Typed access to The point estimate of the effect estimate.
    property value : String read GetValueST write SetValueST;
    // The point estimate of the effect estimate.
    property valueElement : TFhirDecimal read FValue write SetValue;

    // Typed access to Specifies the UCUM unit for the outcome. (defined for API consistency)
    property unitOfMeasure : TFhirCodeableConcept read FUnitOfMeasure write SetUnitOfMeasure;
    // Specifies the UCUM unit for the outcome.
    property unitOfMeasureElement : TFhirCodeableConcept read FUnitOfMeasure write SetUnitOfMeasure;

    // A description of the precision of the estimate for the effect.
    property precisionEstimateList : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList read GetPrecisionEstimateList;
    property hasPrecisionEstimateList : boolean read GetHasPrecisionEstimateList;

  end;

  TFhirEffectEvidenceSynthesisEffectEstimateListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEffectEvidenceSynthesisEffectEstimateList;
    function GetCurrent : TFhirEffectEvidenceSynthesisEffectEstimate;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEffectEvidenceSynthesisEffectEstimateList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEffectEvidenceSynthesisEffectEstimate read GetCurrent;
  end;

  TFhirEffectEvidenceSynthesisEffectEstimateList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEffectEvidenceSynthesisEffectEstimate;
    procedure SetItemN(index : Integer; value : TFhirEffectEvidenceSynthesisEffectEstimate);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEffectEvidenceSynthesisEffectEstimateList; Overload;
    function Clone : TFhirEffectEvidenceSynthesisEffectEstimateList; Overload;
    function GetEnumerator : TFhirEffectEvidenceSynthesisEffectEstimateListEnumerator;
    

    //  Add a FhirEffectEvidenceSynthesisEffectEstimate to the end of the list.
    function Append : TFhirEffectEvidenceSynthesisEffectEstimate;

    
    // Add an already existing FhirEffectEvidenceSynthesisEffectEstimate to the end of the list.
    procedure AddItem(value : TFhirEffectEvidenceSynthesisEffectEstimate); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEffectEvidenceSynthesisEffectEstimate) : Integer;
    

    // Insert FhirEffectEvidenceSynthesisEffectEstimate before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEffectEvidenceSynthesisEffectEstimate;
    

    // Insert an existing FhirEffectEvidenceSynthesisEffectEstimate before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEffectEvidenceSynthesisEffectEstimate);
    
    // Get the iIndexth FhirEffectEvidenceSynthesisEffectEstimate. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEffectEvidenceSynthesisEffectEstimate);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEffectEvidenceSynthesisEffectEstimate;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEffectEvidenceSynthesisEffectEstimates[index : Integer] : TFhirEffectEvidenceSynthesisEffectEstimate read GetItemN write SetItemN; default;
  End;

  // A description of the precision of the estimate for the effect.
  TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FLevel : TFhirDecimal;
    FFrom : TFhirDecimal;
    FTo_ : TFhirDecimal;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetLevel(value : TFhirDecimal);
    Function GetLevelST : String;
    Procedure SetLevelST(value : String);
    Procedure SetFrom(value : TFhirDecimal);
    Function GetFromST : String;
    Procedure SetFromST(value : String);
    Procedure SetTo_(value : TFhirDecimal);
    Function GetTo_ST : String;
    Procedure SetTo_ST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate; overload;
    function Clone : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Examples include confidence interval and interquartile range. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Examples include confidence interval and interquartile range.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Use 95 for a 95% confidence interval.
    property level : String read GetLevelST write SetLevelST;
    // Use 95 for a 95% confidence interval.
    property levelElement : TFhirDecimal read FLevel write SetLevel;

    // Typed access to Lower bound of confidence interval.
    property from : String read GetFromST write SetFromST;
    // Lower bound of confidence interval.
    property fromElement : TFhirDecimal read FFrom write SetFrom;

    // Typed access to Upper bound of confidence interval.
    property to_ : String read GetTo_ST write SetTo_ST;
    // Upper bound of confidence interval.
    property to_Element : TFhirDecimal read FTo_ write SetTo_;

  end;

  TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList;
    function GetCurrent : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate read GetCurrent;
  end;

  TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate;
    procedure SetItemN(index : Integer; value : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList; Overload;
    function Clone : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList; Overload;
    function GetEnumerator : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateListEnumerator;
    

    //  Add a FhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate to the end of the list.
    function Append : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate;

    
    // Add an already existing FhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate to the end of the list.
    procedure AddItem(value : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate) : Integer;
    

    // Insert FhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate;
    

    // Insert an existing FhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate);
    
    // Get the iIndexth FhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimates[index : Integer] : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate read GetItemN write SetItemN; default;
  End;

  // A description of the certainty of the effect estimate.
  TFhirEffectEvidenceSynthesisCertainty = class (TFhirBackboneElement)
  protected
    FratingList : TFhirCodeableConceptList;
    FnoteList : TFhirAnnotationList;
    FcertaintySubcomponentList : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList;
    function GetRatingList : TFhirCodeableConceptList;
    function GetHasRatingList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetCertaintySubcomponentList : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList;
    function GetHasCertaintySubcomponentList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEffectEvidenceSynthesisCertainty; overload;
    function Clone : TFhirEffectEvidenceSynthesisCertainty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A rating of the certainty of the effect estimate.
    property ratingList : TFhirCodeableConceptList read GetRatingList;
    property hasRatingList : boolean read GetHasRatingList;

    // A human-readable string to clarify or explain concepts about the resource.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // A description of a component of the overall certainty.
    property certaintySubcomponentList : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList read GetCertaintySubcomponentList;
    property hasCertaintySubcomponentList : boolean read GetHasCertaintySubcomponentList;

  end;

  TFhirEffectEvidenceSynthesisCertaintyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEffectEvidenceSynthesisCertaintyList;
    function GetCurrent : TFhirEffectEvidenceSynthesisCertainty;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEffectEvidenceSynthesisCertaintyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEffectEvidenceSynthesisCertainty read GetCurrent;
  end;

  TFhirEffectEvidenceSynthesisCertaintyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEffectEvidenceSynthesisCertainty;
    procedure SetItemN(index : Integer; value : TFhirEffectEvidenceSynthesisCertainty);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEffectEvidenceSynthesisCertaintyList; Overload;
    function Clone : TFhirEffectEvidenceSynthesisCertaintyList; Overload;
    function GetEnumerator : TFhirEffectEvidenceSynthesisCertaintyListEnumerator;
    

    //  Add a FhirEffectEvidenceSynthesisCertainty to the end of the list.
    function Append : TFhirEffectEvidenceSynthesisCertainty;

    
    // Add an already existing FhirEffectEvidenceSynthesisCertainty to the end of the list.
    procedure AddItem(value : TFhirEffectEvidenceSynthesisCertainty); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEffectEvidenceSynthesisCertainty) : Integer;
    

    // Insert FhirEffectEvidenceSynthesisCertainty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEffectEvidenceSynthesisCertainty;
    

    // Insert an existing FhirEffectEvidenceSynthesisCertainty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEffectEvidenceSynthesisCertainty);
    
    // Get the iIndexth FhirEffectEvidenceSynthesisCertainty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEffectEvidenceSynthesisCertainty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEffectEvidenceSynthesisCertainty;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEffectEvidenceSynthesisCertainties[index : Integer] : TFhirEffectEvidenceSynthesisCertainty read GetItemN write SetItemN; default;
  End;

  // A description of a component of the overall certainty.
  TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FratingList : TFhirCodeableConceptList;
    FnoteList : TFhirAnnotationList;
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetRatingList : TFhirCodeableConceptList;
    function GetHasRatingList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent; overload;
    function Clone : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Type of subcomponent of certainty rating. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of subcomponent of certainty rating.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // A rating of a subcomponent of rating certainty.
    property ratingList : TFhirCodeableConceptList read GetRatingList;
    property hasRatingList : boolean read GetHasRatingList;

    // A human-readable string to clarify or explain concepts about the resource.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList;
    function GetCurrent : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent read GetCurrent;
  end;

  TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent;
    procedure SetItemN(index : Integer; value : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList; Overload;
    function Clone : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList; Overload;
    function GetEnumerator : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentListEnumerator;
    

    //  Add a FhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent to the end of the list.
    function Append : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent;

    
    // Add an already existing FhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent to the end of the list.
    procedure AddItem(value : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent) : Integer;
    

    // Insert FhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent;
    

    // Insert an existing FhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent);
    
    // Get the iIndexth FhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEffectEvidenceSynthesisCertaintyCertaintySubcomponents[index : Integer] : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent read GetItemN write SetItemN; default;
  End;

  // The EffectEvidenceSynthesis resource describes the difference in an outcome between exposures states in a population where the effect estimate is derived from a combination of research studies.
  TFhirEffectEvidenceSynthesis = class (TFhirMetadataResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FnoteList : TFhirAnnotationList;
    FCopyright : TFhirMarkdown;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FtopicList : TFhirCodeableConceptList;
    FauthorList : TFhirContactDetailList;
    FeditorList : TFhirContactDetailList;
    FreviewerList : TFhirContactDetailList;
    FendorserList : TFhirContactDetailList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    FSynthesisType : TFhirCodeableConcept;
    FStudyType : TFhirCodeableConcept;
    FPopulation : TFhirReference{TFhirEvidenceVariable};
    FExposure : TFhirReference{TFhirEvidenceVariable};
    FExposureAlternative : TFhirReference{TFhirEvidenceVariable};
    FOutcome : TFhirReference{TFhirEvidenceVariable};
    FSampleSize : TFhirEffectEvidenceSynthesisSampleSize;
    FresultsByExposureList : TFhirEffectEvidenceSynthesisResultsByExposureList;
    FeffectEstimateList : TFhirEffectEvidenceSynthesisEffectEstimateList;
    FcertaintyList : TFhirEffectEvidenceSynthesisCertaintyList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    Procedure SetApprovalDate(value : TFhirDate);
    Function GetApprovalDateST : TFslDateTime;
    Procedure SetApprovalDateST(value : TFslDateTime);
    Procedure SetLastReviewDate(value : TFhirDate);
    Function GetLastReviewDateST : TFslDateTime;
    Procedure SetLastReviewDateST(value : TFslDateTime);
    Procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetTopicList : TFhirCodeableConceptList;
    function GetHasTopicList : Boolean;
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    Procedure SetSynthesisType(value : TFhirCodeableConcept);
    Procedure SetStudyType(value : TFhirCodeableConcept);
    Procedure SetPopulation(value : TFhirReference{TFhirEvidenceVariable});
    Procedure SetExposure(value : TFhirReference{TFhirEvidenceVariable});
    Procedure SetExposureAlternative(value : TFhirReference{TFhirEvidenceVariable});
    Procedure SetOutcome(value : TFhirReference{TFhirEvidenceVariable});
    Procedure SetSampleSize(value : TFhirEffectEvidenceSynthesisSampleSize);
    function GetResultsByExposureList : TFhirEffectEvidenceSynthesisResultsByExposureList;
    function GetHasResultsByExposureList : Boolean;
    function GetEffectEstimateList : TFhirEffectEvidenceSynthesisEffectEstimateList;
    function GetHasEffectEstimateList : Boolean;
    function GetCertaintyList : TFhirEffectEvidenceSynthesisCertaintyList;
    function GetHasCertaintyList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEffectEvidenceSynthesis; overload;
    function Clone : TFhirEffectEvidenceSynthesis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this effect evidence synthesis when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this effect evidence synthesis is (or will be) {$IFNDEF FPC}Published{$ENDIF}. This URL can be the target of a canonical reference. It SHALL remain the same when the effect evidence synthesis is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this effect evidence synthesis when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this effect evidence synthesis is (or will be) {$IFNDEF FPC}Published{$ENDIF}. This URL can be the target of a canonical reference. It SHALL remain the same when the effect evidence synthesis is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this effect evidence synthesis when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the effect evidence synthesis when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the effect evidence synthesis author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the effect evidence synthesis when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the effect evidence synthesis author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the effect evidence synthesis. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the effect evidence synthesis. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the effect evidence synthesis.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the effect evidence synthesis.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this effect evidence synthesis. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The date  (and optionally time) when the effect evidence synthesis was {$IFNDEF FPC}Published{$ENDIF}. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the effect evidence synthesis changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the effect evidence synthesis was {$IFNDEF FPC}Published{$ENDIF}. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the effect evidence synthesis changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that {$IFNDEF FPC}Published{$ENDIF} the effect evidence synthesis.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that {$IFNDEF FPC}Published{$ENDIF} the effect evidence synthesis.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the effect evidence synthesis from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the effect evidence synthesis from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // A human-readable string to clarify or explain concepts about the resource.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate effect evidence synthesis instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the effect evidence synthesis is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to A copyright statement relating to the effect evidence synthesis and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the effect evidence synthesis.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the effect evidence synthesis and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the effect evidence synthesis.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the effect evidence synthesis content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the effect evidence synthesis content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // Descriptive topics related to the content of the EffectEvidenceSynthesis. Topics provide a high-level categorization grouping types of EffectEvidenceSynthesiss that can be useful for filtering and searching.
    property topicList : TFhirCodeableConceptList read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // An individiual or organization primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individual or organization primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individual or organization primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individual or organization responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Related artifacts such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // Typed access to Type of synthesis eg meta-analysis. (defined for API consistency)
    property synthesisType : TFhirCodeableConcept read FSynthesisType write SetSynthesisType;
    // Type of synthesis eg meta-analysis.
    property synthesisTypeElement : TFhirCodeableConcept read FSynthesisType write SetSynthesisType;

    // Typed access to Type of study eg randomized trial. (defined for API consistency)
    property studyType : TFhirCodeableConcept read FStudyType write SetStudyType;
    // Type of study eg randomized trial.
    property studyTypeElement : TFhirCodeableConcept read FStudyType write SetStudyType;

    // Typed access to A reference to a EvidenceVariable resource that defines the population for the research. (defined for API consistency)
    property population : TFhirReference{TFhirEvidenceVariable} read FPopulation write SetPopulation;
    // A reference to a EvidenceVariable resource that defines the population for the research.
    property populationElement : TFhirReference{TFhirEvidenceVariable} read FPopulation write SetPopulation;

    // Typed access to A reference to a EvidenceVariable resource that defines the exposure for the research. (defined for API consistency)
    property exposure : TFhirReference{TFhirEvidenceVariable} read FExposure write SetExposure;
    // A reference to a EvidenceVariable resource that defines the exposure for the research.
    property exposureElement : TFhirReference{TFhirEvidenceVariable} read FExposure write SetExposure;

    // Typed access to A reference to a EvidenceVariable resource that defines the comparison exposure for the research. (defined for API consistency)
    property exposureAlternative : TFhirReference{TFhirEvidenceVariable} read FExposureAlternative write SetExposureAlternative;
    // A reference to a EvidenceVariable resource that defines the comparison exposure for the research.
    property exposureAlternativeElement : TFhirReference{TFhirEvidenceVariable} read FExposureAlternative write SetExposureAlternative;

    // Typed access to A reference to a EvidenceVariable resomece that defines the outcome for the research. (defined for API consistency)
    property outcome : TFhirReference{TFhirEvidenceVariable} read FOutcome write SetOutcome;
    // A reference to a EvidenceVariable resomece that defines the outcome for the research.
    property outcomeElement : TFhirReference{TFhirEvidenceVariable} read FOutcome write SetOutcome;

    // Typed access to A description of the size of the sample involved in the synthesis. (defined for API consistency)
    property sampleSize : TFhirEffectEvidenceSynthesisSampleSize read FSampleSize write SetSampleSize;
    // A description of the size of the sample involved in the synthesis.
    property sampleSizeElement : TFhirEffectEvidenceSynthesisSampleSize read FSampleSize write SetSampleSize;

    // A description of the results for each exposure considered in the effect estimate.
    property resultsByExposureList : TFhirEffectEvidenceSynthesisResultsByExposureList read GetResultsByExposureList;
    property hasResultsByExposureList : boolean read GetHasResultsByExposureList;

    // The estimated effect of the exposure variant.
    property effectEstimateList : TFhirEffectEvidenceSynthesisEffectEstimateList read GetEffectEstimateList;
    property hasEffectEstimateList : boolean read GetHasEffectEstimateList;

    // A description of the certainty of the effect estimate.
    property certaintyList : TFhirEffectEvidenceSynthesisCertaintyList read GetCertaintyList;
    property hasCertaintyList : boolean read GetHasCertaintyList;

  end;

  TFhirEffectEvidenceSynthesisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEffectEvidenceSynthesisList;
    function GetCurrent : TFhirEffectEvidenceSynthesis;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEffectEvidenceSynthesisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEffectEvidenceSynthesis read GetCurrent;
  end;

  TFhirEffectEvidenceSynthesisList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEffectEvidenceSynthesis;
    procedure SetItemN(index : Integer; value : TFhirEffectEvidenceSynthesis);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEffectEvidenceSynthesisList; Overload;
    function Clone : TFhirEffectEvidenceSynthesisList; Overload;
    function GetEnumerator : TFhirEffectEvidenceSynthesisListEnumerator;
    

    //  Add a FhirEffectEvidenceSynthesis to the end of the list.
    function Append : TFhirEffectEvidenceSynthesis;

    
    // Add an already existing FhirEffectEvidenceSynthesis to the end of the list.
    procedure AddItem(value : TFhirEffectEvidenceSynthesis); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEffectEvidenceSynthesis) : Integer;
    

    // Insert FhirEffectEvidenceSynthesis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEffectEvidenceSynthesis;
    

    // Insert an existing FhirEffectEvidenceSynthesis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEffectEvidenceSynthesis);
    
    // Get the iIndexth FhirEffectEvidenceSynthesis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEffectEvidenceSynthesis);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEffectEvidenceSynthesis;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEffectEvidenceSyntheses[index : Integer] : TFhirEffectEvidenceSynthesis read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_EFFECTEVIDENCESYNTHESIS}

{$IFDEF FHIR_EVIDENCE}

  // The Evidence resource describes the conditional state (population and any exposures being compared within the population) and outcome (if specified) that the knowledge (evidence, assertion, recommendation) is about.
  TFhirEvidence = class (TFhirMetadataResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FShortTitle : TFhirString;
    FSubtitle : TFhirString;
    FnoteList : TFhirAnnotationList;
    FCopyright : TFhirMarkdown;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FtopicList : TFhirCodeableConceptList;
    FauthorList : TFhirContactDetailList;
    FeditorList : TFhirContactDetailList;
    FreviewerList : TFhirContactDetailList;
    FendorserList : TFhirContactDetailList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    FExposureBackground : TFhirReference{TFhirEvidenceVariable};
    FexposureVariantList : TFhirReferenceList{TFhirEvidenceVariable};
    FoutcomeList : TFhirReferenceList{TFhirEvidenceVariable};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetShortTitle(value : TFhirString);
    Function GetShortTitleST : String;
    Procedure SetShortTitleST(value : String);
    Procedure SetSubtitle(value : TFhirString);
    Function GetSubtitleST : String;
    Procedure SetSubtitleST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    Procedure SetApprovalDate(value : TFhirDate);
    Function GetApprovalDateST : TFslDateTime;
    Procedure SetApprovalDateST(value : TFslDateTime);
    Procedure SetLastReviewDate(value : TFhirDate);
    Function GetLastReviewDateST : TFslDateTime;
    Procedure SetLastReviewDateST(value : TFslDateTime);
    Procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetTopicList : TFhirCodeableConceptList;
    function GetHasTopicList : Boolean;
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    Procedure SetExposureBackground(value : TFhirReference{TFhirEvidenceVariable});
    function GetExposureVariantList : TFhirReferenceList{TFhirEvidenceVariable};
    function GetHasExposureVariantList : Boolean;
    function GetOutcomeList : TFhirReferenceList{TFhirEvidenceVariable};
    function GetHasOutcomeList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidence; overload;
    function Clone : TFhirEvidence; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this evidence when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this evidence is (or will be) {$IFNDEF FPC}Published{$ENDIF}. This URL can be the target of a canonical reference. It SHALL remain the same when the evidence is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this evidence when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this evidence is (or will be) {$IFNDEF FPC}Published{$ENDIF}. This URL can be the target of a canonical reference. It SHALL remain the same when the evidence is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this evidence when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the evidence when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the evidence author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the evidence when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the evidence author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the evidence. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the evidence. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the evidence.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the evidence.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to The short title provides an alternate title for use in informal descriptive contexts where the full, formal title is not necessary.
    property shortTitle : String read GetShortTitleST write SetShortTitleST;
    // The short title provides an alternate title for use in informal descriptive contexts where the full, formal title is not necessary.
    property shortTitleElement : TFhirString read FShortTitle write SetShortTitle;

    // Typed access to An explanatory or alternate title for the Evidence giving additional information about its content.
    property subtitle : String read GetSubtitleST write SetSubtitleST;
    // An explanatory or alternate title for the Evidence giving additional information about its content.
    property subtitleElement : TFhirString read FSubtitle write SetSubtitle;

    // The status of this evidence. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The date  (and optionally time) when the evidence was {$IFNDEF FPC}Published{$ENDIF}. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the evidence changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the evidence was {$IFNDEF FPC}Published{$ENDIF}. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the evidence changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that {$IFNDEF FPC}Published{$ENDIF} the evidence.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that {$IFNDEF FPC}Published{$ENDIF} the evidence.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the evidence from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the evidence from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // A human-readable string to clarify or explain concepts about the resource.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate evidence instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the evidence is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to A copyright statement relating to the evidence and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the evidence.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the evidence and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the evidence.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the evidence content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the evidence content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // Descriptive topics related to the content of the Evidence. Topics provide a high-level categorization grouping types of Evidences that can be useful for filtering and searching.
    property topicList : TFhirCodeableConceptList read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // An individiual or organization primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individual or organization primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individual or organization primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individual or organization responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Related artifacts such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // Typed access to A reference to a EvidenceVariable resource that defines the population for the research. (defined for API consistency)
    property exposureBackground : TFhirReference{TFhirEvidenceVariable} read FExposureBackground write SetExposureBackground;
    // A reference to a EvidenceVariable resource that defines the population for the research.
    property exposureBackgroundElement : TFhirReference{TFhirEvidenceVariable} read FExposureBackground write SetExposureBackground;

    // A reference to a EvidenceVariable resource that defines the exposure for the research.
    property exposureVariantList : TFhirReferenceList{TFhirEvidenceVariable} read GetExposureVariantList;
    property hasExposureVariantList : boolean read GetHasExposureVariantList;

    // A reference to a EvidenceVariable resomece that defines the outcome for the research.
    property outcomeList : TFhirReferenceList{TFhirEvidenceVariable} read GetOutcomeList;
    property hasOutcomeList : boolean read GetHasOutcomeList;

  end;

  TFhirEvidenceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceList;
    function GetCurrent : TFhirEvidence;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidence read GetCurrent;
  end;

  TFhirEvidenceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEvidence;
    procedure SetItemN(index : Integer; value : TFhirEvidence);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEvidenceList; Overload;
    function Clone : TFhirEvidenceList; Overload;
    function GetEnumerator : TFhirEvidenceListEnumerator;
    

    //  Add a FhirEvidence to the end of the list.
    function Append : TFhirEvidence;

    
    // Add an already existing FhirEvidence to the end of the list.
    procedure AddItem(value : TFhirEvidence); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidence) : Integer;
    

    // Insert FhirEvidence before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidence;
    

    // Insert an existing FhirEvidence before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidence);
    
    // Get the iIndexth FhirEvidence. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidence);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidence;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEvidences[index : Integer] : TFhirEvidence read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_EVIDENCE}

{$IFDEF FHIR_EVIDENCEVARIABLE}

  // A characteristic that defines the members of the evidence element. Multiple characteristics are applied with "and" semantics.
  TFhirEvidenceVariableCharacteristic = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FDefinition : TFhirType;
    FusageContextList : TFhirUsageContextList;
    FExclude : TFhirBoolean;
    FParticipantEffective : TFhirType;
    FTimeFromStart : TFhirDuration;
    FGroupMeasure : TFhirEnum;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetDefinition(value : TFhirType);
    function GetUsageContextList : TFhirUsageContextList;
    function GetHasUsageContextList : Boolean;
    Procedure SetExclude(value : TFhirBoolean);
    Function GetExcludeST : Boolean;
    Procedure SetExcludeST(value : Boolean);
    Procedure SetParticipantEffective(value : TFhirType);
    Procedure SetTimeFromStart(value : TFhirDuration);
    Procedure SetGroupMeasure(value : TFhirEnum);
    Function GetGroupMeasureST : TFhirGroupMeasureEnum;
    Procedure SetGroupMeasureST(value : TFhirGroupMeasureEnum);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceVariableCharacteristic; overload;
    function Clone : TFhirEvidenceVariableCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A short, natural language description of the characteristic that could be used to communicate the criteria to an end-user.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A short, natural language description of the characteristic that could be used to communicate the criteria to an end-user.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Define members of the evidence element using Codes (such as condition, medication, or observation), Expressions ( using an expression language such as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in the last year). (defined for API consistency)
    property definition : TFhirType read FDefinition write SetDefinition;
    // Define members of the evidence element using Codes (such as condition, medication, or observation), Expressions ( using an expression language such as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in the last year).
    property definitionElement : TFhirType read FDefinition write SetDefinition;

    // Use UsageContext to define the members of the population, such as Age Ranges, Genders, Settings.
    property usageContextList : TFhirUsageContextList read GetUsageContextList;
    property hasUsageContextList : boolean read GetHasUsageContextList;

    // Typed access to When true, members with this characteristic are excluded from the element.
    property exclude : Boolean read GetExcludeST write SetExcludeST;
    // When true, members with this characteristic are excluded from the element.
    property excludeElement : TFhirBoolean read FExclude write SetExclude;

    // Typed access to Indicates what effective period the study covers. (defined for API consistency)
    property participantEffective : TFhirType read FParticipantEffective write SetParticipantEffective;
    // Indicates what effective period the study covers.
    property participantEffectiveElement : TFhirType read FParticipantEffective write SetParticipantEffective;

    // Typed access to Indicates duration from the participant's study entry. (defined for API consistency)
    property timeFromStart : TFhirDuration read FTimeFromStart write SetTimeFromStart;
    // Indicates duration from the participant's study entry.
    property timeFromStartElement : TFhirDuration read FTimeFromStart write SetTimeFromStart;

    // Indicates how elements are aggregated within the study effective period.
    property groupMeasure : TFhirGroupMeasureEnum read GetGroupMeasureST write SetGroupMeasureST;
    property groupMeasureElement : TFhirEnum read FGroupMeasure write SetGroupMeasure;

  end;

  TFhirEvidenceVariableCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceVariableCharacteristicList;
    function GetCurrent : TFhirEvidenceVariableCharacteristic;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceVariableCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceVariableCharacteristic read GetCurrent;
  end;

  TFhirEvidenceVariableCharacteristicList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEvidenceVariableCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirEvidenceVariableCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEvidenceVariableCharacteristicList; Overload;
    function Clone : TFhirEvidenceVariableCharacteristicList; Overload;
    function GetEnumerator : TFhirEvidenceVariableCharacteristicListEnumerator;
    

    //  Add a FhirEvidenceVariableCharacteristic to the end of the list.
    function Append : TFhirEvidenceVariableCharacteristic;

    
    // Add an already existing FhirEvidenceVariableCharacteristic to the end of the list.
    procedure AddItem(value : TFhirEvidenceVariableCharacteristic); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceVariableCharacteristic) : Integer;
    

    // Insert FhirEvidenceVariableCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceVariableCharacteristic;
    

    // Insert an existing FhirEvidenceVariableCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceVariableCharacteristic);
    
    // Get the iIndexth FhirEvidenceVariableCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceVariableCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceVariableCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEvidenceVariableCharacteristics[index : Integer] : TFhirEvidenceVariableCharacteristic read GetItemN write SetItemN; default;
  End;

  // The EvidenceVariable resource describes a "PICO" element that knowledge (evidence, assertion, recommendation) is about.
  TFhirEvidenceVariable = class (TFhirMetadataResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FShortTitle : TFhirString;
    FSubtitle : TFhirString;
    FnoteList : TFhirAnnotationList;
    FCopyright : TFhirMarkdown;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FtopicList : TFhirCodeableConceptList;
    FauthorList : TFhirContactDetailList;
    FeditorList : TFhirContactDetailList;
    FreviewerList : TFhirContactDetailList;
    FendorserList : TFhirContactDetailList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    FType_ : TFhirEnum;
    FcharacteristicList : TFhirEvidenceVariableCharacteristicList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetShortTitle(value : TFhirString);
    Function GetShortTitleST : String;
    Procedure SetShortTitleST(value : String);
    Procedure SetSubtitle(value : TFhirString);
    Function GetSubtitleST : String;
    Procedure SetSubtitleST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    Procedure SetApprovalDate(value : TFhirDate);
    Function GetApprovalDateST : TFslDateTime;
    Procedure SetApprovalDateST(value : TFslDateTime);
    Procedure SetLastReviewDate(value : TFhirDate);
    Function GetLastReviewDateST : TFslDateTime;
    Procedure SetLastReviewDateST(value : TFslDateTime);
    Procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetTopicList : TFhirCodeableConceptList;
    function GetHasTopicList : Boolean;
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirVariableTypeEnum;
    Procedure SetType_ST(value : TFhirVariableTypeEnum);
    function GetCharacteristicList : TFhirEvidenceVariableCharacteristicList;
    function GetHasCharacteristicList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceVariable; overload;
    function Clone : TFhirEvidenceVariable; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this evidence variable when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this evidence variable is (or will be) {$IFNDEF FPC}Published{$ENDIF}. This URL can be the target of a canonical reference. It SHALL remain the same when the evidence variable is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this evidence variable when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this evidence variable is (or will be) {$IFNDEF FPC}Published{$ENDIF}. This URL can be the target of a canonical reference. It SHALL remain the same when the evidence variable is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this evidence variable when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the evidence variable when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the evidence variable author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the evidence variable when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the evidence variable author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the evidence variable. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the evidence variable. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the evidence variable.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the evidence variable.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to The short title provides an alternate title for use in informal descriptive contexts where the full, formal title is not necessary.
    property shortTitle : String read GetShortTitleST write SetShortTitleST;
    // The short title provides an alternate title for use in informal descriptive contexts where the full, formal title is not necessary.
    property shortTitleElement : TFhirString read FShortTitle write SetShortTitle;

    // Typed access to An explanatory or alternate title for the EvidenceVariable giving additional information about its content.
    property subtitle : String read GetSubtitleST write SetSubtitleST;
    // An explanatory or alternate title for the EvidenceVariable giving additional information about its content.
    property subtitleElement : TFhirString read FSubtitle write SetSubtitle;

    // The status of this evidence variable. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The date  (and optionally time) when the evidence variable was {$IFNDEF FPC}Published{$ENDIF}. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the evidence variable changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the evidence variable was {$IFNDEF FPC}Published{$ENDIF}. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the evidence variable changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that {$IFNDEF FPC}Published{$ENDIF} the evidence variable.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that {$IFNDEF FPC}Published{$ENDIF} the evidence variable.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the evidence variable from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the evidence variable from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // A human-readable string to clarify or explain concepts about the resource.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate evidence variable instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the evidence variable is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to A copyright statement relating to the evidence variable and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the evidence variable.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the evidence variable and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the evidence variable.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the evidence variable content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the evidence variable content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // Descriptive topics related to the content of the EvidenceVariable. Topics provide a high-level categorization grouping types of EvidenceVariables that can be useful for filtering and searching.
    property topicList : TFhirCodeableConceptList read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // An individiual or organization primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individual or organization primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individual or organization primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individual or organization responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Related artifacts such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // The type of evidence element, a population, an exposure, or an outcome.
    property type_ : TFhirVariableTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // A characteristic that defines the members of the evidence element. Multiple characteristics are applied with "and" semantics.
    property characteristicList : TFhirEvidenceVariableCharacteristicList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

  end;

  TFhirEvidenceVariableListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceVariableList;
    function GetCurrent : TFhirEvidenceVariable;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceVariableList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceVariable read GetCurrent;
  end;

  TFhirEvidenceVariableList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEvidenceVariable;
    procedure SetItemN(index : Integer; value : TFhirEvidenceVariable);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEvidenceVariableList; Overload;
    function Clone : TFhirEvidenceVariableList; Overload;
    function GetEnumerator : TFhirEvidenceVariableListEnumerator;
    

    //  Add a FhirEvidenceVariable to the end of the list.
    function Append : TFhirEvidenceVariable;

    
    // Add an already existing FhirEvidenceVariable to the end of the list.
    procedure AddItem(value : TFhirEvidenceVariable); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceVariable) : Integer;
    

    // Insert FhirEvidenceVariable before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceVariable;
    

    // Insert an existing FhirEvidenceVariable before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceVariable);
    
    // Get the iIndexth FhirEvidenceVariable. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceVariable);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceVariable;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEvidenceVariables[index : Integer] : TFhirEvidenceVariable read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_EVIDENCEVARIABLE}

{$IFDEF FHIR_GUIDANCERESPONSE}

  // A guidance response is the formal response to a guidance request, including any output parameters returned by the evaluation, as well as the description of any proposed actions to be taken.
  TFhirGuidanceResponse = class (TFhirDomainResource)
  protected
    FRequestIdentifier : TFhirIdentifier;
    FidentifierList : TFhirIdentifierList;
    FModule : TFhirType;
    FStatus : TFhirEnum;
    FSubject : TFhirReference{TFhirPatient};
    FEncounter : TFhirReference{TFhirEncounter};
    FOccurrenceDateTime : TFhirDateTime;
    FPerformer : TFhirReference{TFhirDevice};
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList{TFhirCondition};
    FnoteList : TFhirAnnotationList;
    FevaluationMessageList : TFhirReferenceList{TFhirOperationOutcome};
    FOutputParameters : TFhirReference{TFhirParameters};
    FResult : TFhirReference{TFhirCarePlan};
    FdataRequirementList : TFhirDataRequirementList;
    Procedure SetRequestIdentifier(value : TFhirIdentifier);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetModule(value : TFhirType);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirGuidanceResponseStatusEnum;
    Procedure SetStatusST(value : TFhirGuidanceResponseStatusEnum);
    Procedure SetSubject(value : TFhirReference{TFhirPatient});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetOccurrenceDateTime(value : TFhirDateTime);
    Function GetOccurrenceDateTimeST : TFslDateTime;
    Procedure SetOccurrenceDateTimeST(value : TFslDateTime);
    Procedure SetPerformer(value : TFhirReference{TFhirDevice});
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList{TFhirCondition};
    function GetHasReasonReferenceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetEvaluationMessageList : TFhirReferenceList{TFhirOperationOutcome};
    function GetHasEvaluationMessageList : Boolean;
    Procedure SetOutputParameters(value : TFhirReference{TFhirParameters});
    Procedure SetResult(value : TFhirReference{TFhirCarePlan});
    function GetDataRequirementList : TFhirDataRequirementList;
    function GetHasDataRequirementList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGuidanceResponse; overload;
    function Clone : TFhirGuidanceResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The identifier of the request associated with this response. If an identifier was given as part of the request, it will be reproduced here to enable the requester to more easily identify the response in a multi-request scenario. (defined for API consistency)
    property requestIdentifier : TFhirIdentifier read FRequestIdentifier write SetRequestIdentifier;
    // The identifier of the request associated with this response. If an identifier was given as part of the request, it will be reproduced here to enable the requester to more easily identify the response in a multi-request scenario.
    property requestIdentifierElement : TFhirIdentifier read FRequestIdentifier write SetRequestIdentifier;

    // Allows a service to provide  unique, business identifiers for the response.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to An identifier, CodeableConcept or canonical reference to the guidance that was requested. (defined for API consistency)
    property module : TFhirType read FModule write SetModule;
    // An identifier, CodeableConcept or canonical reference to the guidance that was requested.
    property moduleElement : TFhirType read FModule write SetModule;

    // The status of the response. If the evaluation is completed successfully, the status will indicate success. However, in order to complete the evaluation, the engine may require more information. In this case, the status will be data-required, and the response will contain a description of the additional required information. If the evaluation completed successfully, but the engine determines that a potentially more accurate response could be provided if more data was available, the status will be data-requested, and the response will contain a description of the additional requested information.
    property status : TFhirGuidanceResponseStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The patient for which the request was processed. (defined for API consistency)
    property subject : TFhirReference{TFhirPatient} read FSubject write SetSubject;
    // The patient for which the request was processed.
    property subjectElement : TFhirReference{TFhirPatient} read FSubject write SetSubject;

    // Typed access to The encounter during which this response was created or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // The encounter during which this response was created or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to Indicates when the guidance response was processed.
    property occurrenceDateTime : TFslDateTime read GetOccurrenceDateTimeST write SetOccurrenceDateTimeST;
    // Indicates when the guidance response was processed.
    property occurrenceDateTimeElement : TFhirDateTime read FOccurrenceDateTime write SetOccurrenceDateTime;

    // Typed access to Provides a reference to the device that performed the guidance. (defined for API consistency)
    property performer : TFhirReference{TFhirDevice} read FPerformer write SetPerformer;
    // Provides a reference to the device that performed the guidance.
    property performerElement : TFhirReference{TFhirDevice} read FPerformer write SetPerformer;

    // Describes the reason for the guidance response in coded or textual form.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Indicates the reason the request was initiated. This is typically provided as a parameter to the evaluation and echoed by the service, although for some use cases, such as subscription- or event-based scenarios, it may provide an indication of the cause for the response.
    property reasonReferenceList : TFhirReferenceList{TFhirCondition} read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Provides a mechanism to communicate additional information about the response.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Messages resulting from the evaluation of the artifact or artifacts. As part of evaluating the request, the engine may produce informational or warning messages. These messages will be provided by this element.
    property evaluationMessageList : TFhirReferenceList{TFhirOperationOutcome} read GetEvaluationMessageList;
    property hasEvaluationMessageList : boolean read GetHasEvaluationMessageList;

    // Typed access to The output parameters of the evaluation, if any. Many modules will result in the return of specific resources such as procedure or communication requests that are returned as part of the operation result. However, modules may define specific outputs that would be returned as the result of the evaluation, and these would be returned in this element. (defined for API consistency)
    property outputParameters : TFhirReference{TFhirParameters} read FOutputParameters write SetOutputParameters;
    // The output parameters of the evaluation, if any. Many modules will result in the return of specific resources such as procedure or communication requests that are returned as part of the operation result. However, modules may define specific outputs that would be returned as the result of the evaluation, and these would be returned in this element.
    property outputParametersElement : TFhirReference{TFhirParameters} read FOutputParameters write SetOutputParameters;

    // Typed access to The actions, if any, produced by the evaluation of the artifact. (defined for API consistency)
    property result : TFhirReference{TFhirCarePlan} read FResult write SetResult;
    // The actions, if any, produced by the evaluation of the artifact.
    property resultElement : TFhirReference{TFhirCarePlan} read FResult write SetResult;

    // If the evaluation could not be completed due to lack of information, or additional information would potentially result in a more accurate response, this element will a description of the data required in order to proceed with the evaluation. A subsequent request to the service should include this data.
    property dataRequirementList : TFhirDataRequirementList read GetDataRequirementList;
    property hasDataRequirementList : boolean read GetHasDataRequirementList;

  end;

  TFhirGuidanceResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGuidanceResponseList;
    function GetCurrent : TFhirGuidanceResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirGuidanceResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGuidanceResponse read GetCurrent;
  end;

  TFhirGuidanceResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirGuidanceResponse;
    procedure SetItemN(index : Integer; value : TFhirGuidanceResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirGuidanceResponseList; Overload;
    function Clone : TFhirGuidanceResponseList; Overload;
    function GetEnumerator : TFhirGuidanceResponseListEnumerator;
    

    //  Add a FhirGuidanceResponse to the end of the list.
    function Append : TFhirGuidanceResponse;

    
    // Add an already existing FhirGuidanceResponse to the end of the list.
    procedure AddItem(value : TFhirGuidanceResponse); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGuidanceResponse) : Integer;
    

    // Insert FhirGuidanceResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGuidanceResponse;
    

    // Insert an existing FhirGuidanceResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGuidanceResponse);
    
    // Get the iIndexth FhirGuidanceResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGuidanceResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGuidanceResponse;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirGuidanceResponses[index : Integer] : TFhirGuidanceResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_GUIDANCERESPONSE}

{$IFDEF FHIR_LINKAGE}

  // Identifies which record considered as the reference to the same real-world occurrence as well as how the items should be evaluated within the collection of linked items.
  TFhirLinkageItem = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FResource : TFhirReference{TFhirReference};
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirLinkageTypeEnum;
    Procedure SetType_ST(value : TFhirLinkageTypeEnum);
    Procedure SetResource(value : TFhirReference{TFhirReference});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLinkageItem; overload;
    function Clone : TFhirLinkageItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Distinguishes which item is "source of truth" (if any) and which items are no longer considered to be current representations.
    property type_ : TFhirLinkageTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The resource instance being linked as part of the group. (defined for API consistency)
    property resource : TFhirReference{TFhirReference} read FResource write SetResource;
    // The resource instance being linked as part of the group.
    property resourceElement : TFhirReference{TFhirReference} read FResource write SetResource;

  end;

  TFhirLinkageItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLinkageItemList;
    function GetCurrent : TFhirLinkageItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirLinkageItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLinkageItem read GetCurrent;
  end;

  TFhirLinkageItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirLinkageItem;
    procedure SetItemN(index : Integer; value : TFhirLinkageItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirLinkageItemList; Overload;
    function Clone : TFhirLinkageItemList; Overload;
    function GetEnumerator : TFhirLinkageItemListEnumerator;
    

    //  Add a FhirLinkageItem to the end of the list.
    function Append : TFhirLinkageItem;

    
    // Add an already existing FhirLinkageItem to the end of the list.
    procedure AddItem(value : TFhirLinkageItem); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLinkageItem) : Integer;
    

    // Insert FhirLinkageItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLinkageItem;
    

    // Insert an existing FhirLinkageItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLinkageItem);
    
    // Get the iIndexth FhirLinkageItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLinkageItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirLinkageItem;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirLinkageItems[index : Integer] : TFhirLinkageItem read GetItemN write SetItemN; default;
  End;

  // Identifies two or more records (resource instances) that refer to the same real-world "occurrence".
  TFhirLinkage = class (TFhirDomainResource)
  protected
    FActive : TFhirBoolean;
    FAuthor : TFhirReference{TFhirPractitioner};
    FitemList : TFhirLinkageItemList;
    Procedure SetActive(value : TFhirBoolean);
    Function GetActiveST : Boolean;
    Procedure SetActiveST(value : Boolean);
    Procedure SetAuthor(value : TFhirReference{TFhirPractitioner});
    function GetItemList : TFhirLinkageItemList;
    function GetHasItemList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLinkage; overload;
    function Clone : TFhirLinkage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Indicates whether the asserted set of linkages are considered to be "in effect".
    property active : Boolean read GetActiveST write SetActiveST;
    // Indicates whether the asserted set of linkages are considered to be "in effect".
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to Identifies the user or organization responsible for asserting the linkages as well as the user or organization who establishes the context in which the nature of each linkage is evaluated. (defined for API consistency)
    property author : TFhirReference{TFhirPractitioner} read FAuthor write SetAuthor;
    // Identifies the user or organization responsible for asserting the linkages as well as the user or organization who establishes the context in which the nature of each linkage is evaluated.
    property authorElement : TFhirReference{TFhirPractitioner} read FAuthor write SetAuthor;

    // Identifies which record considered as the reference to the same real-world occurrence as well as how the items should be evaluated within the collection of linked items.
    property itemList : TFhirLinkageItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirLinkageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLinkageList;
    function GetCurrent : TFhirLinkage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirLinkageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLinkage read GetCurrent;
  end;

  TFhirLinkageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirLinkage;
    procedure SetItemN(index : Integer; value : TFhirLinkage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirLinkageList; Overload;
    function Clone : TFhirLinkageList; Overload;
    function GetEnumerator : TFhirLinkageListEnumerator;
    

    //  Add a FhirLinkage to the end of the list.
    function Append : TFhirLinkage;

    
    // Add an already existing FhirLinkage to the end of the list.
    procedure AddItem(value : TFhirLinkage); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLinkage) : Integer;
    

    // Insert FhirLinkage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLinkage;
    

    // Insert an existing FhirLinkage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLinkage);
    
    // Get the iIndexth FhirLinkage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLinkage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirLinkage;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirLinkages[index : Integer] : TFhirLinkage read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_LINKAGE}

{$IFDEF FHIR_LIST}

  // Entries in this list.
  TFhirListEntry = class (TFhirBackboneElement)
  protected
    FFlag : TFhirCodeableConcept;
    FDeleted : TFhirBoolean;
    FDate : TFhirDateTime;
    FItem : TFhirReference{TFhirReference};
    Procedure SetFlag(value : TFhirCodeableConcept);
    Procedure SetDeleted(value : TFhirBoolean);
    Function GetDeletedST : Boolean;
    Procedure SetDeletedST(value : Boolean);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetItem(value : TFhirReference{TFhirReference});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirListEntry; overload;
    function Clone : TFhirListEntry; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The flag allows the system constructing the list to indicate the role and significance of the item in the list. (defined for API consistency)
    property flag : TFhirCodeableConcept read FFlag write SetFlag;
    // The flag allows the system constructing the list to indicate the role and significance of the item in the list.
    property flagElement : TFhirCodeableConcept read FFlag write SetFlag;

    // Typed access to True if this item is marked as deleted in the list.
    property deleted : Boolean read GetDeletedST write SetDeletedST;
    // True if this item is marked as deleted in the list.
    property deletedElement : TFhirBoolean read FDeleted write SetDeleted;

    // Typed access to When this item was added to the list.
    property date : TFslDateTime read GetDateST write SetDateST;
    // When this item was added to the list.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to A reference to the actual resource from which data was derived. (defined for API consistency)
    property item : TFhirReference{TFhirReference} read FItem write SetItem;
    // A reference to the actual resource from which data was derived.
    property itemElement : TFhirReference{TFhirReference} read FItem write SetItem;

  end;

  TFhirListEntryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirListEntryList;
    function GetCurrent : TFhirListEntry;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirListEntryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirListEntry read GetCurrent;
  end;

  TFhirListEntryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirListEntry;
    procedure SetItemN(index : Integer; value : TFhirListEntry);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirListEntryList; Overload;
    function Clone : TFhirListEntryList; Overload;
    function GetEnumerator : TFhirListEntryListEnumerator;
    

    //  Add a FhirListEntry to the end of the list.
    function Append : TFhirListEntry;

    
    // Add an already existing FhirListEntry to the end of the list.
    procedure AddItem(value : TFhirListEntry); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirListEntry) : Integer;
    

    // Insert FhirListEntry before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirListEntry;
    

    // Insert an existing FhirListEntry before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirListEntry);
    
    // Get the iIndexth FhirListEntry. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirListEntry);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirListEntry;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirListEntries[index : Integer] : TFhirListEntry read GetItemN write SetItemN; default;
  End;

  // A list is a curated collection of resources.
  TFhirList = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FMode : TFhirEnum;
    FTitle : TFhirString;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference{TFhirPatient};
    FEncounter : TFhirReference{TFhirEncounter};
    FDate : TFhirDateTime;
    FSource : TFhirReference{TFhirPractitioner};
    FOrderedBy : TFhirCodeableConcept;
    FnoteList : TFhirAnnotationList;
    FentryList : TFhirListEntryList;
    FEmptyReason : TFhirCodeableConcept;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirListStatusEnum;
    Procedure SetStatusST(value : TFhirListStatusEnum);
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirListModeEnum;
    Procedure SetModeST(value : TFhirListModeEnum);
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{TFhirPatient});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetSource(value : TFhirReference{TFhirPractitioner});
    Procedure SetOrderedBy(value : TFhirCodeableConcept);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetEntryList : TFhirListEntryList;
    function GetHasEntryList : Boolean;
    Procedure SetEmptyReason(value : TFhirCodeableConcept);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirList; overload;
    function Clone : TFhirList; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifier for the List assigned for business purposes outside the context of FHIR.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates the current state of this list.
    property status : TFhirListStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // How this list was prepared - whether it is a working list that is suitable for being maintained on an ongoing basis, or if it represents a snapshot of a list of items from another source, or whether it is a prepared list where items may be marked as added, modified or deleted.
    property mode : TFhirListModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to A label for the list assigned by the author.
    property title : String read GetTitleST write SetTitleST;
    // A label for the list assigned by the author.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to This code defines the purpose of the list - why it was created. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // This code defines the purpose of the list - why it was created.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The common subject (or patient) of the resources that are in the list if there is one. (defined for API consistency)
    property subject : TFhirReference{TFhirPatient} read FSubject write SetSubject;
    // The common subject (or patient) of the resources that are in the list if there is one.
    property subjectElement : TFhirReference{TFhirPatient} read FSubject write SetSubject;

    // Typed access to The encounter that is the context in which this list was created. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // The encounter that is the context in which this list was created.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to The date that the list was prepared.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date that the list was prepared.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The entity responsible for deciding what the contents of the list were. Where the list was created by a human, this is the same as the author of the list. (defined for API consistency)
    property source : TFhirReference{TFhirPractitioner} read FSource write SetSource;
    // The entity responsible for deciding what the contents of the list were. Where the list was created by a human, this is the same as the author of the list.
    property sourceElement : TFhirReference{TFhirPractitioner} read FSource write SetSource;

    // Typed access to What order applies to the items in the list. (defined for API consistency)
    property orderedBy : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;
    // What order applies to the items in the list.
    property orderedByElement : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;

    // Comments that apply to the overall list.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Entries in this list.
    property entryList : TFhirListEntryList read GetEntryList;
    property hasEntryList : boolean read GetHasEntryList;

    // Typed access to If the list is empty, why the list is empty. (defined for API consistency)
    property emptyReason : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;
    // If the list is empty, why the list is empty.
    property emptyReasonElement : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;

  end;

  TFhirListListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirListList;
    function GetCurrent : TFhirList;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirListList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirList read GetCurrent;
  end;

  TFhirListList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirList;
    procedure SetItemN(index : Integer; value : TFhirList);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirListList; Overload;
    function Clone : TFhirListList; Overload;
    function GetEnumerator : TFhirListListEnumerator;
    

    //  Add a FhirList to the end of the list.
    function Append : TFhirList;

    
    // Add an already existing FhirList to the end of the list.
    procedure AddItem(value : TFhirList); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirList) : Integer;
    

    // Insert FhirList before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirList;
    

    // Insert an existing FhirList before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirList);
    
    // Get the iIndexth FhirList. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirList);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirList;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirLists[index : Integer] : TFhirList read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_LIST}

{$IFDEF FHIR_MEASUREREPORT}

  // The results of the calculation, one for each population group in the measure.
  TFhirMeasureReportGroup = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FpopulationList : TFhirMeasureReportGroupPopulationList;
    FMeasureScore : TFhirQuantity;
    FstratifierList : TFhirMeasureReportGroupStratifierList;
    Procedure SetCode(value : TFhirCodeableConcept);
    function GetPopulationList : TFhirMeasureReportGroupPopulationList;
    function GetHasPopulationList : Boolean;
    Procedure SetMeasureScore(value : TFhirQuantity);
    function GetStratifierList : TFhirMeasureReportGroupStratifierList;
    function GetHasStratifierList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroup; overload;
    function Clone : TFhirMeasureReportGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The meaning of the population group as defined in the measure definition. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The meaning of the population group as defined in the measure definition.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // The populations that make up the population group, one for each type of population appropriate for the measure.
    property populationList : TFhirMeasureReportGroupPopulationList read GetPopulationList;
    property hasPopulationList : boolean read GetHasPopulationList;

    // Typed access to The measure score for this population group, calculated as appropriate for the measure type and scoring method, and based on the contents of the populations defined in the group. (defined for API consistency)
    property measureScore : TFhirQuantity read FMeasureScore write SetMeasureScore;
    // The measure score for this population group, calculated as appropriate for the measure type and scoring method, and based on the contents of the populations defined in the group.
    property measureScoreElement : TFhirQuantity read FMeasureScore write SetMeasureScore;

    // When a measure includes multiple stratifiers, there will be a stratifier group for each stratifier defined by the measure.
    property stratifierList : TFhirMeasureReportGroupStratifierList read GetStratifierList;
    property hasStratifierList : boolean read GetHasStratifierList;

  end;

  TFhirMeasureReportGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupList;
    function GetCurrent : TFhirMeasureReportGroup;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroup read GetCurrent;
  end;

  TFhirMeasureReportGroupList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMeasureReportGroup;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMeasureReportGroupList; Overload;
    function Clone : TFhirMeasureReportGroupList; Overload;
    function GetEnumerator : TFhirMeasureReportGroupListEnumerator;
    

    //  Add a FhirMeasureReportGroup to the end of the list.
    function Append : TFhirMeasureReportGroup;

    
    // Add an already existing FhirMeasureReportGroup to the end of the list.
    procedure AddItem(value : TFhirMeasureReportGroup); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroup) : Integer;
    

    // Insert FhirMeasureReportGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroup;
    

    // Insert an existing FhirMeasureReportGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroup);
    
    // Get the iIndexth FhirMeasureReportGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroup;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMeasureReportGroups[index : Integer] : TFhirMeasureReportGroup read GetItemN write SetItemN; default;
  End;

  // The populations that make up the population group, one for each type of population appropriate for the measure.
  TFhirMeasureReportGroupPopulation = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FCount : TFhirInteger;
    FSubjectResults : TFhirReference{TFhirList};
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetCount(value : TFhirInteger);
    Function GetCountST : String;
    Procedure SetCountST(value : String);
    Procedure SetSubjectResults(value : TFhirReference{TFhirList});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroupPopulation; overload;
    function Clone : TFhirMeasureReportGroupPopulation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The type of the population. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The type of the population.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The number of members of the population.
    property count : String read GetCountST write SetCountST;
    // The number of members of the population.
    property countElement : TFhirInteger read FCount write SetCount;

    // Typed access to This element refers to a List of subject level MeasureReport resources, one for each subject in this population. (defined for API consistency)
    property subjectResults : TFhirReference{TFhirList} read FSubjectResults write SetSubjectResults;
    // This element refers to a List of subject level MeasureReport resources, one for each subject in this population.
    property subjectResultsElement : TFhirReference{TFhirList} read FSubjectResults write SetSubjectResults;

  end;

  TFhirMeasureReportGroupPopulationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupPopulationList;
    function GetCurrent : TFhirMeasureReportGroupPopulation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupPopulationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroupPopulation read GetCurrent;
  end;

  TFhirMeasureReportGroupPopulationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMeasureReportGroupPopulation;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroupPopulation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMeasureReportGroupPopulationList; Overload;
    function Clone : TFhirMeasureReportGroupPopulationList; Overload;
    function GetEnumerator : TFhirMeasureReportGroupPopulationListEnumerator;
    

    //  Add a FhirMeasureReportGroupPopulation to the end of the list.
    function Append : TFhirMeasureReportGroupPopulation;

    
    // Add an already existing FhirMeasureReportGroupPopulation to the end of the list.
    procedure AddItem(value : TFhirMeasureReportGroupPopulation); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroupPopulation) : Integer;
    

    // Insert FhirMeasureReportGroupPopulation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroupPopulation;
    

    // Insert an existing FhirMeasureReportGroupPopulation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroupPopulation);
    
    // Get the iIndexth FhirMeasureReportGroupPopulation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroupPopulation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroupPopulation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMeasureReportGroupPopulations[index : Integer] : TFhirMeasureReportGroupPopulation read GetItemN write SetItemN; default;
  End;

  // When a measure includes multiple stratifiers, there will be a stratifier group for each stratifier defined by the measure.
  TFhirMeasureReportGroupStratifier = class (TFhirBackboneElement)
  protected
    FcodeList : TFhirCodeableConceptList;
    FstratumList : TFhirMeasureReportGroupStratifierStratumList;
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetStratumList : TFhirMeasureReportGroupStratifierStratumList;
    function GetHasStratumList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroupStratifier; overload;
    function Clone : TFhirMeasureReportGroupStratifier; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The meaning of this stratifier, as defined in the measure definition.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // This element contains the results for a single stratum within the stratifier. For example, when stratifying on administrative gender, there will be four strata, one for each possible gender value.
    property stratumList : TFhirMeasureReportGroupStratifierStratumList read GetStratumList;
    property hasStratumList : boolean read GetHasStratumList;

  end;

  TFhirMeasureReportGroupStratifierListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupStratifierList;
    function GetCurrent : TFhirMeasureReportGroupStratifier;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupStratifierList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroupStratifier read GetCurrent;
  end;

  TFhirMeasureReportGroupStratifierList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMeasureReportGroupStratifier;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroupStratifier);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMeasureReportGroupStratifierList; Overload;
    function Clone : TFhirMeasureReportGroupStratifierList; Overload;
    function GetEnumerator : TFhirMeasureReportGroupStratifierListEnumerator;
    

    //  Add a FhirMeasureReportGroupStratifier to the end of the list.
    function Append : TFhirMeasureReportGroupStratifier;

    
    // Add an already existing FhirMeasureReportGroupStratifier to the end of the list.
    procedure AddItem(value : TFhirMeasureReportGroupStratifier); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroupStratifier) : Integer;
    

    // Insert FhirMeasureReportGroupStratifier before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroupStratifier;
    

    // Insert an existing FhirMeasureReportGroupStratifier before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroupStratifier);
    
    // Get the iIndexth FhirMeasureReportGroupStratifier. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroupStratifier);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroupStratifier;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMeasureReportGroupStratifiers[index : Integer] : TFhirMeasureReportGroupStratifier read GetItemN write SetItemN; default;
  End;

  // This element contains the results for a single stratum within the stratifier. For example, when stratifying on administrative gender, there will be four strata, one for each possible gender value.
  TFhirMeasureReportGroupStratifierStratum = class (TFhirBackboneElement)
  protected
    FValue : TFhirCodeableConcept;
    FcomponentList : TFhirMeasureReportGroupStratifierStratumComponentList;
    FpopulationList : TFhirMeasureReportGroupStratifierStratumPopulationList;
    FMeasureScore : TFhirQuantity;
    Procedure SetValue(value : TFhirCodeableConcept);
    function GetComponentList : TFhirMeasureReportGroupStratifierStratumComponentList;
    function GetHasComponentList : Boolean;
    function GetPopulationList : TFhirMeasureReportGroupStratifierStratumPopulationList;
    function GetHasPopulationList : Boolean;
    Procedure SetMeasureScore(value : TFhirQuantity);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroupStratifierStratum; overload;
    function Clone : TFhirMeasureReportGroupStratifierStratum; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The value for this stratum, expressed as a CodeableConcept. When defining stratifiers on complex values, the value must be rendered such that the value for each stratum within the stratifier is unique. (defined for API consistency)
    property value : TFhirCodeableConcept read FValue write SetValue;
    // The value for this stratum, expressed as a CodeableConcept. When defining stratifiers on complex values, the value must be rendered such that the value for each stratum within the stratifier is unique.
    property valueElement : TFhirCodeableConcept read FValue write SetValue;

    // A stratifier component value.
    property componentList : TFhirMeasureReportGroupStratifierStratumComponentList read GetComponentList;
    property hasComponentList : boolean read GetHasComponentList;

    // The populations that make up the stratum, one for each type of population appropriate to the measure.
    property populationList : TFhirMeasureReportGroupStratifierStratumPopulationList read GetPopulationList;
    property hasPopulationList : boolean read GetHasPopulationList;

    // Typed access to The measure score for this stratum, calculated as appropriate for the measure type and scoring method, and based on only the members of this stratum. (defined for API consistency)
    property measureScore : TFhirQuantity read FMeasureScore write SetMeasureScore;
    // The measure score for this stratum, calculated as appropriate for the measure type and scoring method, and based on only the members of this stratum.
    property measureScoreElement : TFhirQuantity read FMeasureScore write SetMeasureScore;

  end;

  TFhirMeasureReportGroupStratifierStratumListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupStratifierStratumList;
    function GetCurrent : TFhirMeasureReportGroupStratifierStratum;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupStratifierStratumList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroupStratifierStratum read GetCurrent;
  end;

  TFhirMeasureReportGroupStratifierStratumList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMeasureReportGroupStratifierStratum;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroupStratifierStratum);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMeasureReportGroupStratifierStratumList; Overload;
    function Clone : TFhirMeasureReportGroupStratifierStratumList; Overload;
    function GetEnumerator : TFhirMeasureReportGroupStratifierStratumListEnumerator;
    

    //  Add a FhirMeasureReportGroupStratifierStratum to the end of the list.
    function Append : TFhirMeasureReportGroupStratifierStratum;

    
    // Add an already existing FhirMeasureReportGroupStratifierStratum to the end of the list.
    procedure AddItem(value : TFhirMeasureReportGroupStratifierStratum); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroupStratifierStratum) : Integer;
    

    // Insert FhirMeasureReportGroupStratifierStratum before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroupStratifierStratum;
    

    // Insert an existing FhirMeasureReportGroupStratifierStratum before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroupStratifierStratum);
    
    // Get the iIndexth FhirMeasureReportGroupStratifierStratum. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroupStratifierStratum);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroupStratifierStratum;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMeasureReportGroupStratifierStrata[index : Integer] : TFhirMeasureReportGroupStratifierStratum read GetItemN write SetItemN; default;
  End;

  // A stratifier component value.
  TFhirMeasureReportGroupStratifierStratumComponent = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirCodeableConcept;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroupStratifierStratumComponent; overload;
    function Clone : TFhirMeasureReportGroupStratifierStratumComponent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The code for the stratum component value. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The code for the stratum component value.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The stratum component value. (defined for API consistency)
    property value : TFhirCodeableConcept read FValue write SetValue;
    // The stratum component value.
    property valueElement : TFhirCodeableConcept read FValue write SetValue;

  end;

  TFhirMeasureReportGroupStratifierStratumComponentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupStratifierStratumComponentList;
    function GetCurrent : TFhirMeasureReportGroupStratifierStratumComponent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupStratifierStratumComponentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroupStratifierStratumComponent read GetCurrent;
  end;

  TFhirMeasureReportGroupStratifierStratumComponentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMeasureReportGroupStratifierStratumComponent;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroupStratifierStratumComponent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMeasureReportGroupStratifierStratumComponentList; Overload;
    function Clone : TFhirMeasureReportGroupStratifierStratumComponentList; Overload;
    function GetEnumerator : TFhirMeasureReportGroupStratifierStratumComponentListEnumerator;
    

    //  Add a FhirMeasureReportGroupStratifierStratumComponent to the end of the list.
    function Append : TFhirMeasureReportGroupStratifierStratumComponent;

    
    // Add an already existing FhirMeasureReportGroupStratifierStratumComponent to the end of the list.
    procedure AddItem(value : TFhirMeasureReportGroupStratifierStratumComponent); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroupStratifierStratumComponent) : Integer;
    

    // Insert FhirMeasureReportGroupStratifierStratumComponent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroupStratifierStratumComponent;
    

    // Insert an existing FhirMeasureReportGroupStratifierStratumComponent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroupStratifierStratumComponent);
    
    // Get the iIndexth FhirMeasureReportGroupStratifierStratumComponent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroupStratifierStratumComponent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroupStratifierStratumComponent;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMeasureReportGroupStratifierStratumComponents[index : Integer] : TFhirMeasureReportGroupStratifierStratumComponent read GetItemN write SetItemN; default;
  End;

  // The populations that make up the stratum, one for each type of population appropriate to the measure.
  TFhirMeasureReportGroupStratifierStratumPopulation = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FCount : TFhirInteger;
    FSubjectResults : TFhirReference{TFhirList};
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetCount(value : TFhirInteger);
    Function GetCountST : String;
    Procedure SetCountST(value : String);
    Procedure SetSubjectResults(value : TFhirReference{TFhirList});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroupStratifierStratumPopulation; overload;
    function Clone : TFhirMeasureReportGroupStratifierStratumPopulation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The type of the population. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The type of the population.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The number of members of the population in this stratum.
    property count : String read GetCountST write SetCountST;
    // The number of members of the population in this stratum.
    property countElement : TFhirInteger read FCount write SetCount;

    // Typed access to This element refers to a List of subject level MeasureReport resources, one for each subject in this population in this stratum. (defined for API consistency)
    property subjectResults : TFhirReference{TFhirList} read FSubjectResults write SetSubjectResults;
    // This element refers to a List of subject level MeasureReport resources, one for each subject in this population in this stratum.
    property subjectResultsElement : TFhirReference{TFhirList} read FSubjectResults write SetSubjectResults;

  end;

  TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupStratifierStratumPopulationList;
    function GetCurrent : TFhirMeasureReportGroupStratifierStratumPopulation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupStratifierStratumPopulationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroupStratifierStratumPopulation read GetCurrent;
  end;

  TFhirMeasureReportGroupStratifierStratumPopulationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMeasureReportGroupStratifierStratumPopulation;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroupStratifierStratumPopulation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMeasureReportGroupStratifierStratumPopulationList; Overload;
    function Clone : TFhirMeasureReportGroupStratifierStratumPopulationList; Overload;
    function GetEnumerator : TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator;
    

    //  Add a FhirMeasureReportGroupStratifierStratumPopulation to the end of the list.
    function Append : TFhirMeasureReportGroupStratifierStratumPopulation;

    
    // Add an already existing FhirMeasureReportGroupStratifierStratumPopulation to the end of the list.
    procedure AddItem(value : TFhirMeasureReportGroupStratifierStratumPopulation); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroupStratifierStratumPopulation) : Integer;
    

    // Insert FhirMeasureReportGroupStratifierStratumPopulation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroupStratifierStratumPopulation;
    

    // Insert an existing FhirMeasureReportGroupStratifierStratumPopulation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroupStratifierStratumPopulation);
    
    // Get the iIndexth FhirMeasureReportGroupStratifierStratumPopulation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroupStratifierStratumPopulation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroupStratifierStratumPopulation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMeasureReportGroupStratifierStratumPopulations[index : Integer] : TFhirMeasureReportGroupStratifierStratumPopulation read GetItemN write SetItemN; default;
  End;

  // The MeasureReport resource contains the results of the calculation of a measure; and optionally a reference to the resources involved in that calculation.
  TFhirMeasureReport = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirEnum;
    FMeasure : TFhirCanonical;
    FSubject : TFhirReference{TFhirPatient};
    FDate : TFhirDateTime;
    FReporter : TFhirReference{TFhirPractitioner};
    FPeriod : TFhirPeriod;
    FImprovementNotation : TFhirCodeableConcept;
    FgroupList : TFhirMeasureReportGroupList;
    FevaluatedResourceList : TFhirReferenceList{TFhirReference};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirMeasureReportStatusEnum;
    Procedure SetStatusST(value : TFhirMeasureReportStatusEnum);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirMeasureReportTypeEnum;
    Procedure SetType_ST(value : TFhirMeasureReportTypeEnum);
    Procedure SetMeasure(value : TFhirCanonical);
    Function GetMeasureST : String;
    Procedure SetMeasureST(value : String);
    Procedure SetSubject(value : TFhirReference{TFhirPatient});
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetReporter(value : TFhirReference{TFhirPractitioner});
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetImprovementNotation(value : TFhirCodeableConcept);
    function GetGroupList : TFhirMeasureReportGroupList;
    function GetHasGroupList : Boolean;
    function GetEvaluatedResourceList : TFhirReferenceList{TFhirReference};
    function GetHasEvaluatedResourceList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReport; overload;
    function Clone : TFhirMeasureReport; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A formal identifier that is used to identify this MeasureReport when it is represented in other formats or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The MeasureReport status. No data will be available until the MeasureReport status is complete.
    property status : TFhirMeasureReportStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The type of measure report. This may be an individual report, which provides the score for the measure for an individual member of the population; a subject-listing, which returns the list of members that meet the various criteria in the measure; a summary report, which returns a population count for each of the criteria in the measure; or a data-collection, which enables the MeasureReport to be used to exchange the data-of-interest for a quality measure.
    property type_ : TFhirMeasureReportTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A reference to the Measure that was calculated to produce this report.
    property measure : String read GetMeasureST write SetMeasureST;
    // A reference to the Measure that was calculated to produce this report.
    property measureElement : TFhirCanonical read FMeasure write SetMeasure;

    // Typed access to Optional subject identifying the individual or individuals the report is for. (defined for API consistency)
    property subject : TFhirReference{TFhirPatient} read FSubject write SetSubject;
    // Optional subject identifying the individual or individuals the report is for.
    property subjectElement : TFhirReference{TFhirPatient} read FSubject write SetSubject;

    // Typed access to The date this measure report was generated.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date this measure report was generated.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The individual, location, or organization that is reporting the data. (defined for API consistency)
    property reporter : TFhirReference{TFhirPractitioner} read FReporter write SetReporter;
    // The individual, location, or organization that is reporting the data.
    property reporterElement : TFhirReference{TFhirPractitioner} read FReporter write SetReporter;

    // Typed access to The reporting period for which the report was calculated. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The reporting period for which the report was calculated.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Whether improvement in the measure is noted by an increase or decrease in the measure score. (defined for API consistency)
    property improvementNotation : TFhirCodeableConcept read FImprovementNotation write SetImprovementNotation;
    // Whether improvement in the measure is noted by an increase or decrease in the measure score.
    property improvementNotationElement : TFhirCodeableConcept read FImprovementNotation write SetImprovementNotation;

    // The results of the calculation, one for each population group in the measure.
    property groupList : TFhirMeasureReportGroupList read GetGroupList;
    property hasGroupList : boolean read GetHasGroupList;

    // A reference to a Bundle containing the Resources that were used in the calculation of this measure.
    property evaluatedResourceList : TFhirReferenceList{TFhirReference} read GetEvaluatedResourceList;
    property hasEvaluatedResourceList : boolean read GetHasEvaluatedResourceList;

  end;

  TFhirMeasureReportListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportList;
    function GetCurrent : TFhirMeasureReport;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReport read GetCurrent;
  end;

  TFhirMeasureReportList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMeasureReport;
    procedure SetItemN(index : Integer; value : TFhirMeasureReport);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMeasureReportList; Overload;
    function Clone : TFhirMeasureReportList; Overload;
    function GetEnumerator : TFhirMeasureReportListEnumerator;
    

    //  Add a FhirMeasureReport to the end of the list.
    function Append : TFhirMeasureReport;

    
    // Add an already existing FhirMeasureReport to the end of the list.
    procedure AddItem(value : TFhirMeasureReport); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReport) : Integer;
    

    // Insert FhirMeasureReport before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReport;
    

    // Insert an existing FhirMeasureReport before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReport);
    
    // Get the iIndexth FhirMeasureReport. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReport);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReport;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMeasureReports[index : Integer] : TFhirMeasureReport read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEASUREREPORT}

{$IFDEF FHIR_MESSAGEHEADER}

  // The destination application which the message is intended for.
  TFhirMessageHeaderDestination = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FTarget : TFhirReference{TFhirDevice};
    FEndpoint : TFhirUrl;
    FReceiver : TFhirReference{TFhirPractitioner};
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetTarget(value : TFhirReference{TFhirDevice});
    Procedure SetEndpoint(value : TFhirUrl);
    Function GetEndpointST : String;
    Procedure SetEndpointST(value : String);
    Procedure SetReceiver(value : TFhirReference{TFhirPractitioner});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageHeaderDestination; overload;
    function Clone : TFhirMessageHeaderDestination; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Human-readable name for the target system.
    property name : String read GetNameST write SetNameST;
    // Human-readable name for the target system.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Identifies the target end system in situations where the initial message transmission is to an intermediary system. (defined for API consistency)
    property target : TFhirReference{TFhirDevice} read FTarget write SetTarget;
    // Identifies the target end system in situations where the initial message transmission is to an intermediary system.
    property targetElement : TFhirReference{TFhirDevice} read FTarget write SetTarget;

    // Typed access to Indicates where the message should be routed to.
    property endpoint : String read GetEndpointST write SetEndpointST;
    // Indicates where the message should be routed to.
    property endpointElement : TFhirUrl read FEndpoint write SetEndpoint;

    // Typed access to Allows data conveyed by a message to be addressed to a particular person or department when routing to a specific application isn't sufficient. (defined for API consistency)
    property receiver : TFhirReference{TFhirPractitioner} read FReceiver write SetReceiver;
    // Allows data conveyed by a message to be addressed to a particular person or department when routing to a specific application isn't sufficient.
    property receiverElement : TFhirReference{TFhirPractitioner} read FReceiver write SetReceiver;

  end;

  TFhirMessageHeaderDestinationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderDestinationList;
    function GetCurrent : TFhirMessageHeaderDestination;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMessageHeaderDestinationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeaderDestination read GetCurrent;
  end;

  TFhirMessageHeaderDestinationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMessageHeaderDestination;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderDestination);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMessageHeaderDestinationList; Overload;
    function Clone : TFhirMessageHeaderDestinationList; Overload;
    function GetEnumerator : TFhirMessageHeaderDestinationListEnumerator;
    

    //  Add a FhirMessageHeaderDestination to the end of the list.
    function Append : TFhirMessageHeaderDestination;

    
    // Add an already existing FhirMessageHeaderDestination to the end of the list.
    procedure AddItem(value : TFhirMessageHeaderDestination); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageHeaderDestination) : Integer;
    

    // Insert FhirMessageHeaderDestination before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageHeaderDestination;
    

    // Insert an existing FhirMessageHeaderDestination before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderDestination);
    
    // Get the iIndexth FhirMessageHeaderDestination. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderDestination);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageHeaderDestination;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMessageHeaderDestinations[index : Integer] : TFhirMessageHeaderDestination read GetItemN write SetItemN; default;
  End;

  // The source application from which this message originated.
  TFhirMessageHeaderSource = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FSoftware : TFhirString;
    FVersion : TFhirString;
    FContact : TFhirContactPoint;
    FEndpoint : TFhirUrl;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetSoftware(value : TFhirString);
    Function GetSoftwareST : String;
    Procedure SetSoftwareST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetContact(value : TFhirContactPoint);
    Procedure SetEndpoint(value : TFhirUrl);
    Function GetEndpointST : String;
    Procedure SetEndpointST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageHeaderSource; overload;
    function Clone : TFhirMessageHeaderSource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Human-readable name for the source system.
    property name : String read GetNameST write SetNameST;
    // Human-readable name for the source system.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to May include configuration or other information useful in debugging.
    property software : String read GetSoftwareST write SetSoftwareST;
    // May include configuration or other information useful in debugging.
    property softwareElement : TFhirString read FSoftware write SetSoftware;

    // Typed access to Can convey versions of multiple systems in situations where a message passes through multiple hands.
    property version : String read GetVersionST write SetVersionST;
    // Can convey versions of multiple systems in situations where a message passes through multiple hands.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to An e-mail, phone, website or other contact point to use to resolve issues with message communications. (defined for API consistency)
    property contact : TFhirContactPoint read FContact write SetContact;
    // An e-mail, phone, website or other contact point to use to resolve issues with message communications.
    property contactElement : TFhirContactPoint read FContact write SetContact;

    // Typed access to Identifies the routing target to send acknowledgements to.
    property endpoint : String read GetEndpointST write SetEndpointST;
    // Identifies the routing target to send acknowledgements to.
    property endpointElement : TFhirUrl read FEndpoint write SetEndpoint;

  end;

  TFhirMessageHeaderSourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderSourceList;
    function GetCurrent : TFhirMessageHeaderSource;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMessageHeaderSourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeaderSource read GetCurrent;
  end;

  TFhirMessageHeaderSourceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMessageHeaderSource;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderSource);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMessageHeaderSourceList; Overload;
    function Clone : TFhirMessageHeaderSourceList; Overload;
    function GetEnumerator : TFhirMessageHeaderSourceListEnumerator;
    

    //  Add a FhirMessageHeaderSource to the end of the list.
    function Append : TFhirMessageHeaderSource;

    
    // Add an already existing FhirMessageHeaderSource to the end of the list.
    procedure AddItem(value : TFhirMessageHeaderSource); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageHeaderSource) : Integer;
    

    // Insert FhirMessageHeaderSource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageHeaderSource;
    

    // Insert an existing FhirMessageHeaderSource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderSource);
    
    // Get the iIndexth FhirMessageHeaderSource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderSource);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageHeaderSource;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMessageHeaderSources[index : Integer] : TFhirMessageHeaderSource read GetItemN write SetItemN; default;
  End;

  // Information about the message that this message is a response to.  Only present if this message is a response.
  TFhirMessageHeaderResponse = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirId;
    FCode : TFhirEnum;
    FDetails : TFhirReference{TFhirOperationOutcome};
    Procedure SetIdentifier(value : TFhirId);
    Function GetIdentifierST : String;
    Procedure SetIdentifierST(value : String);
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirResponseCodeEnum;
    Procedure SetCodeST(value : TFhirResponseCodeEnum);
    Procedure SetDetails(value : TFhirReference{TFhirOperationOutcome});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageHeaderResponse; overload;
    function Clone : TFhirMessageHeaderResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The MessageHeader.id of the message to which this message is a response.
    property identifier : String read GetIdentifierST write SetIdentifierST;
    // The MessageHeader.id of the message to which this message is a response.
    property identifierElement : TFhirId read FIdentifier write SetIdentifier;

    // Code that identifies the type of response to the message - whether it was successful or not, and whether it should be resent or not.
    property code : TFhirResponseCodeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to Full details of any issues found in the message. (defined for API consistency)
    property details : TFhirReference{TFhirOperationOutcome} read FDetails write SetDetails;
    // Full details of any issues found in the message.
    property detailsElement : TFhirReference{TFhirOperationOutcome} read FDetails write SetDetails;

  end;

  TFhirMessageHeaderResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderResponseList;
    function GetCurrent : TFhirMessageHeaderResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMessageHeaderResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeaderResponse read GetCurrent;
  end;

  TFhirMessageHeaderResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMessageHeaderResponse;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMessageHeaderResponseList; Overload;
    function Clone : TFhirMessageHeaderResponseList; Overload;
    function GetEnumerator : TFhirMessageHeaderResponseListEnumerator;
    

    //  Add a FhirMessageHeaderResponse to the end of the list.
    function Append : TFhirMessageHeaderResponse;

    
    // Add an already existing FhirMessageHeaderResponse to the end of the list.
    procedure AddItem(value : TFhirMessageHeaderResponse); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageHeaderResponse) : Integer;
    

    // Insert FhirMessageHeaderResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageHeaderResponse;
    

    // Insert an existing FhirMessageHeaderResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderResponse);
    
    // Get the iIndexth FhirMessageHeaderResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageHeaderResponse;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMessageHeaderResponses[index : Integer] : TFhirMessageHeaderResponse read GetItemN write SetItemN; default;
  End;

  // The header for a message exchange that is either requesting or responding to an action.  The reference(s) that are the subject of the action as well as other information related to the action are typically transmitted in a bundle in which the MessageHeader resource instance is the first resource in the bundle.
  TFhirMessageHeader = class (TFhirDomainResource)
  protected
    FEvent : TFhirType;
    FdestinationList : TFhirMessageHeaderDestinationList;
    FSender : TFhirReference{TFhirPractitioner};
    FEnterer : TFhirReference{TFhirPractitioner};
    FAuthor : TFhirReference{TFhirPractitioner};
    FSource : TFhirMessageHeaderSource;
    FResponsible : TFhirReference{TFhirPractitioner};
    FReason : TFhirCodeableConcept;
    FResponse : TFhirMessageHeaderResponse;
    FfocusList : TFhirReferenceList{TFhirReference};
    FDefinition : TFhirCanonical;
    Procedure SetEvent(value : TFhirType);
    function GetDestinationList : TFhirMessageHeaderDestinationList;
    function GetHasDestinationList : Boolean;
    Procedure SetSender(value : TFhirReference{TFhirPractitioner});
    Procedure SetEnterer(value : TFhirReference{TFhirPractitioner});
    Procedure SetAuthor(value : TFhirReference{TFhirPractitioner});
    Procedure SetSource(value : TFhirMessageHeaderSource);
    Procedure SetResponsible(value : TFhirReference{TFhirPractitioner});
    Procedure SetReason(value : TFhirCodeableConcept);
    Procedure SetResponse(value : TFhirMessageHeaderResponse);
    function GetFocusList : TFhirReferenceList{TFhirReference};
    function GetHasFocusList : Boolean;
    Procedure SetDefinition(value : TFhirCanonical);
    Function GetDefinitionST : String;
    Procedure SetDefinitionST(value : String);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageHeader; overload;
    function Clone : TFhirMessageHeader; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Code that identifies the event this message represents and connects it with its definition. Events defined as part of the FHIR specification have the system value "http://terminology.hl7.org/CodeSystem/message-events".  Alternatively uri to the EventDefinition. (defined for API consistency)
    property event : TFhirType read FEvent write SetEvent;
    // Code that identifies the event this message represents and connects it with its definition. Events defined as part of the FHIR specification have the system value "http://terminology.hl7.org/CodeSystem/message-events".  Alternatively uri to the EventDefinition.
    property eventElement : TFhirType read FEvent write SetEvent;

    // The destination application which the message is intended for.
    property destinationList : TFhirMessageHeaderDestinationList read GetDestinationList;
    property hasDestinationList : boolean read GetHasDestinationList;

    // Typed access to Identifies the sending system to allow the use of a trust relationship. (defined for API consistency)
    property sender : TFhirReference{TFhirPractitioner} read FSender write SetSender;
    // Identifies the sending system to allow the use of a trust relationship.
    property senderElement : TFhirReference{TFhirPractitioner} read FSender write SetSender;

    // Typed access to The person or device that performed the data entry leading to this message. When there is more than one candidate, pick the most proximal to the message. Can provide other enterers in extensions. (defined for API consistency)
    property enterer : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;
    // The person or device that performed the data entry leading to this message. When there is more than one candidate, pick the most proximal to the message. Can provide other enterers in extensions.
    property entererElement : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;

    // Typed access to The logical author of the message - the person or device that decided the described event should happen. When there is more than one candidate, pick the most proximal to the MessageHeader. Can provide other authors in extensions. (defined for API consistency)
    property author : TFhirReference{TFhirPractitioner} read FAuthor write SetAuthor;
    // The logical author of the message - the person or device that decided the described event should happen. When there is more than one candidate, pick the most proximal to the MessageHeader. Can provide other authors in extensions.
    property authorElement : TFhirReference{TFhirPractitioner} read FAuthor write SetAuthor;

    // Typed access to The source application from which this message originated. (defined for API consistency)
    property source : TFhirMessageHeaderSource read FSource write SetSource;
    // The source application from which this message originated.
    property sourceElement : TFhirMessageHeaderSource read FSource write SetSource;

    // Typed access to The person or organization that accepts overall responsibility for the contents of the message. The implication is that the message event happened under the policies of the responsible party. (defined for API consistency)
    property responsible : TFhirReference{TFhirPractitioner} read FResponsible write SetResponsible;
    // The person or organization that accepts overall responsibility for the contents of the message. The implication is that the message event happened under the policies of the responsible party.
    property responsibleElement : TFhirReference{TFhirPractitioner} read FResponsible write SetResponsible;

    // Typed access to Coded indication of the cause for the event - indicates  a reason for the occurrence of the event that is a focus of this message. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // Coded indication of the cause for the event - indicates  a reason for the occurrence of the event that is a focus of this message.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

    // Typed access to Information about the message that this message is a response to.  Only present if this message is a response. (defined for API consistency)
    property response : TFhirMessageHeaderResponse read FResponse write SetResponse;
    // Information about the message that this message is a response to.  Only present if this message is a response.
    property responseElement : TFhirMessageHeaderResponse read FResponse write SetResponse;

    // The actual data of the message - a reference to the root/focus class of the event.
    property focusList : TFhirReferenceList{TFhirReference} read GetFocusList;
    property hasFocusList : boolean read GetHasFocusList;

    // Typed access to Permanent link to the MessageDefinition for this message.
    property definition : String read GetDefinitionST write SetDefinitionST;
    // Permanent link to the MessageDefinition for this message.
    property definitionElement : TFhirCanonical read FDefinition write SetDefinition;

  end;

  TFhirMessageHeaderListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderList;
    function GetCurrent : TFhirMessageHeader;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMessageHeaderList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeader read GetCurrent;
  end;

  TFhirMessageHeaderList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMessageHeader;
    procedure SetItemN(index : Integer; value : TFhirMessageHeader);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMessageHeaderList; Overload;
    function Clone : TFhirMessageHeaderList; Overload;
    function GetEnumerator : TFhirMessageHeaderListEnumerator;
    

    //  Add a FhirMessageHeader to the end of the list.
    function Append : TFhirMessageHeader;

    
    // Add an already existing FhirMessageHeader to the end of the list.
    procedure AddItem(value : TFhirMessageHeader); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageHeader) : Integer;
    

    // Insert FhirMessageHeader before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageHeader;
    

    // Insert an existing FhirMessageHeader before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageHeader);
    
    // Get the iIndexth FhirMessageHeader. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeader);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageHeader;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMessageHeaders[index : Integer] : TFhirMessageHeader read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MESSAGEHEADER}

{$IFDEF FHIR_OPERATIONOUTCOME}

  // An error, warning, or information message that results from a system action.
  TFhirOperationOutcomeIssue = class (TFhirBackboneElement)
  protected
    FSeverity : TFhirEnum;
    FCode : TFhirEnum;
    FDetails : TFhirCodeableConcept;
    FDiagnostics : TFhirString;
    FlocationList : TFhirStringList;
    FexpressionList : TFhirStringList;
    Procedure SetSeverity(value : TFhirEnum);
    Function GetSeverityST : TFhirIssueSeverityEnum;
    Procedure SetSeverityST(value : TFhirIssueSeverityEnum);
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirIssueTypeEnum;
    Procedure SetCodeST(value : TFhirIssueTypeEnum);
    Procedure SetDetails(value : TFhirCodeableConcept);
    Procedure SetDiagnostics(value : TFhirString);
    Function GetDiagnosticsST : String;
    Procedure SetDiagnosticsST(value : String);
    function GetLocationList : TFhirStringList;
    function GetHasLocationList : Boolean;
    function GetExpressionList : TFhirStringList;
    function GetHasExpressionList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationOutcomeIssue; overload;
    function Clone : TFhirOperationOutcomeIssue; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Indicates whether the issue indicates a variation from successful processing.
    property severity : TFhirIssueSeverityEnum read GetSeverityST write SetSeverityST;
    property severityElement : TFhirEnum read FSeverity write SetSeverity;

    // Describes the type of the issue. The system that creates an OperationOutcome SHALL choose the most applicable code from the IssueType value set, and may additional provide its own code for the error in the details element.
    property code : TFhirIssueTypeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to Additional details about the error. This may be a text description of the error or a system code that identifies the error. (defined for API consistency)
    property details : TFhirCodeableConcept read FDetails write SetDetails;
    // Additional details about the error. This may be a text description of the error or a system code that identifies the error.
    property detailsElement : TFhirCodeableConcept read FDetails write SetDetails;

    // Typed access to Additional diagnostic information about the issue.
    property diagnostics : String read GetDiagnosticsST write SetDiagnosticsST;
    // Additional diagnostic information about the issue.
    property diagnosticsElement : TFhirString read FDiagnostics write SetDiagnostics;

    // This element is deprecated because it is XML specific. It is replaced by issue.expression, which is format independent, and simpler to parse.   For resource issues, this will be a simple XPath limited to element names, repetition indicators and the default child accessor that identifies one of the elements in the resource that caused this issue to be raised.  For HTTP errors, will be "http." + the parameter name.
    property locationList : TFhirStringList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // A [simple subset of FHIRPath](fhirpath.html#simple) limited to element names, repetition indicators and the default child accessor that identifies one of the elements in the resource that caused this issue to be raised.
    property expressionList : TFhirStringList read GetExpressionList;
    property hasExpressionList : boolean read GetHasExpressionList;

  end;

  TFhirOperationOutcomeIssueListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationOutcomeIssueList;
    function GetCurrent : TFhirOperationOutcomeIssue;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOperationOutcomeIssueList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationOutcomeIssue read GetCurrent;
  end;

  TFhirOperationOutcomeIssueList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOperationOutcomeIssue;
    procedure SetItemN(index : Integer; value : TFhirOperationOutcomeIssue);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOperationOutcomeIssueList; Overload;
    function Clone : TFhirOperationOutcomeIssueList; Overload;
    function GetEnumerator : TFhirOperationOutcomeIssueListEnumerator;
    

    //  Add a FhirOperationOutcomeIssue to the end of the list.
    function Append : TFhirOperationOutcomeIssue;

    
    // Add an already existing FhirOperationOutcomeIssue to the end of the list.
    procedure AddItem(value : TFhirOperationOutcomeIssue); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationOutcomeIssue) : Integer;
    

    // Insert FhirOperationOutcomeIssue before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationOutcomeIssue;
    

    // Insert an existing FhirOperationOutcomeIssue before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationOutcomeIssue);
    
    // Get the iIndexth FhirOperationOutcomeIssue. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationOutcomeIssue);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationOutcomeIssue;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirOperationOutcomeIssues[index : Integer] : TFhirOperationOutcomeIssue read GetItemN write SetItemN; default;
  End;

  // A collection of error, warning, or information messages that result from a system action.
  TFhirOperationOutcome = class (TFhirDomainResource)
  protected
    FissueList : TFhirOperationOutcomeIssueList;
    function GetIssueList : TFhirOperationOutcomeIssueList;
    function GetHasIssueList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationOutcome; overload;
    function Clone : TFhirOperationOutcome; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // An error, warning, or information message that results from a system action.
    property issueList : TFhirOperationOutcomeIssueList read GetIssueList;
    property hasIssueList : boolean read GetHasIssueList;

  end;

  TFhirOperationOutcomeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationOutcomeList;
    function GetCurrent : TFhirOperationOutcome;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOperationOutcomeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationOutcome read GetCurrent;
  end;

  TFhirOperationOutcomeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOperationOutcome;
    procedure SetItemN(index : Integer; value : TFhirOperationOutcome);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOperationOutcomeList; Overload;
    function Clone : TFhirOperationOutcomeList; Overload;
    function GetEnumerator : TFhirOperationOutcomeListEnumerator;
    

    //  Add a FhirOperationOutcome to the end of the list.
    function Append : TFhirOperationOutcome;

    
    // Add an already existing FhirOperationOutcome to the end of the list.
    procedure AddItem(value : TFhirOperationOutcome); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationOutcome) : Integer;
    

    // Insert FhirOperationOutcome before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationOutcome;
    

    // Insert an existing FhirOperationOutcome before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationOutcome);
    
    // Get the iIndexth FhirOperationOutcome. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationOutcome);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationOutcome;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirOperationOutcomes[index : Integer] : TFhirOperationOutcome read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_OPERATIONOUTCOME}

{$IFDEF FHIR_PROVENANCE}

  // An actor taking a role in an activity  for which it can be assigned some degree of responsibility for the activity taking place.
  TFhirProvenanceAgent = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FroleList : TFhirCodeableConceptList;
    FWho : TFhirReference{TFhirPractitioner};
    FOnBehalfOf : TFhirReference{TFhirPractitioner};
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetRoleList : TFhirCodeableConceptList;
    function GetHasRoleList : Boolean;
    Procedure SetWho(value : TFhirReference{TFhirPractitioner});
    Procedure SetOnBehalfOf(value : TFhirReference{TFhirPractitioner});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProvenanceAgent; overload;
    function Clone : TFhirProvenanceAgent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The participation the agent had with respect to the activity. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The participation the agent had with respect to the activity.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The function of the agent with respect to the activity. The security role enabling the agent with respect to the activity.
    property roleList : TFhirCodeableConceptList read GetRoleList;
    property hasRoleList : boolean read GetHasRoleList;

    // Typed access to The individual, device or organization that participated in the event. (defined for API consistency)
    property who : TFhirReference{TFhirPractitioner} read FWho write SetWho;
    // The individual, device or organization that participated in the event.
    property whoElement : TFhirReference{TFhirPractitioner} read FWho write SetWho;

    // Typed access to The individual, device, or organization for whom the change was made. (defined for API consistency)
    property onBehalfOf : TFhirReference{TFhirPractitioner} read FOnBehalfOf write SetOnBehalfOf;
    // The individual, device, or organization for whom the change was made.
    property onBehalfOfElement : TFhirReference{TFhirPractitioner} read FOnBehalfOf write SetOnBehalfOf;

  end;

  TFhirProvenanceAgentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProvenanceAgentList;
    function GetCurrent : TFhirProvenanceAgent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProvenanceAgentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProvenanceAgent read GetCurrent;
  end;

  TFhirProvenanceAgentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProvenanceAgent;
    procedure SetItemN(index : Integer; value : TFhirProvenanceAgent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProvenanceAgentList; Overload;
    function Clone : TFhirProvenanceAgentList; Overload;
    function GetEnumerator : TFhirProvenanceAgentListEnumerator;
    

    //  Add a FhirProvenanceAgent to the end of the list.
    function Append : TFhirProvenanceAgent;

    
    // Add an already existing FhirProvenanceAgent to the end of the list.
    procedure AddItem(value : TFhirProvenanceAgent); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProvenanceAgent) : Integer;
    

    // Insert FhirProvenanceAgent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProvenanceAgent;
    

    // Insert an existing FhirProvenanceAgent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProvenanceAgent);
    
    // Get the iIndexth FhirProvenanceAgent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProvenanceAgent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirProvenanceAgent;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirProvenanceAgents[index : Integer] : TFhirProvenanceAgent read GetItemN write SetItemN; default;
  End;

  // An entity used in this activity.
  TFhirProvenanceEntity = class (TFhirBackboneElement)
  protected
    FRole : TFhirEnum;
    FWhat : TFhirReference{TFhirReference};
    FagentList : TFhirProvenanceAgentList;
    Procedure SetRole(value : TFhirEnum);
    Function GetRoleST : TFhirProvenanceEntityRoleEnum;
    Procedure SetRoleST(value : TFhirProvenanceEntityRoleEnum);
    Procedure SetWhat(value : TFhirReference{TFhirReference});
    function GetAgentList : TFhirProvenanceAgentList;
    function GetHasAgentList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProvenanceEntity; overload;
    function Clone : TFhirProvenanceEntity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // How the entity was used during the activity.
    property role : TFhirProvenanceEntityRoleEnum read GetRoleST write SetRoleST;
    property roleElement : TFhirEnum read FRole write SetRole;

    // Typed access to Identity of the  Entity used. May be a logical or physical uri and maybe absolute or relative. (defined for API consistency)
    property what : TFhirReference{TFhirReference} read FWhat write SetWhat;
    // Identity of the  Entity used. May be a logical or physical uri and maybe absolute or relative.
    property whatElement : TFhirReference{TFhirReference} read FWhat write SetWhat;

    // The entity is attributed to an agent to express the agent's responsibility for that entity, possibly along with other agents. This description can be understood as shorthand for saying that the agent was responsible for the activity which generated the entity.
    property agentList : TFhirProvenanceAgentList read GetAgentList;
    property hasAgentList : boolean read GetHasAgentList;

  end;

  TFhirProvenanceEntityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProvenanceEntityList;
    function GetCurrent : TFhirProvenanceEntity;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProvenanceEntityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProvenanceEntity read GetCurrent;
  end;

  TFhirProvenanceEntityList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProvenanceEntity;
    procedure SetItemN(index : Integer; value : TFhirProvenanceEntity);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProvenanceEntityList; Overload;
    function Clone : TFhirProvenanceEntityList; Overload;
    function GetEnumerator : TFhirProvenanceEntityListEnumerator;
    

    //  Add a FhirProvenanceEntity to the end of the list.
    function Append : TFhirProvenanceEntity;

    
    // Add an already existing FhirProvenanceEntity to the end of the list.
    procedure AddItem(value : TFhirProvenanceEntity); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProvenanceEntity) : Integer;
    

    // Insert FhirProvenanceEntity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProvenanceEntity;
    

    // Insert an existing FhirProvenanceEntity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProvenanceEntity);
    
    // Get the iIndexth FhirProvenanceEntity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProvenanceEntity);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirProvenanceEntity;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirProvenanceEntities[index : Integer] : TFhirProvenanceEntity read GetItemN write SetItemN; default;
  End;

  // Provenance of a resource is a record that describes entities and processes involved in producing and delivering or otherwise influencing that resource. Provenance provides a critical foundation for assessing authenticity, enabling trust, and allowing reproducibility. Provenance assertions are a form of contextual metadata and can themselves become important records with their own provenance. Provenance statement indicates clinical significance in terms of confidence in authenticity, reliability, and trustworthiness, integrity, and stage in lifecycle (e.g. Document Completion - has the artifact been legally authenticated), all of which may impact security, privacy, and trust policies.
  TFhirProvenance = class (TFhirDomainResource)
  protected
    FtargetList : TFhirReferenceList{TFhirReference};
    FOccurred : TFhirType;
    FRecorded : TFhirInstant;
    FpolicyList : TFhirUriList;
    FLocation : TFhirReference{TFhirLocation};
    FreasonList : TFhirCodeableConceptList;
    FActivity : TFhirCodeableConcept;
    FagentList : TFhirProvenanceAgentList;
    FentityList : TFhirProvenanceEntityList;
    FsignatureList : TFhirSignatureList;
    function GetTargetList : TFhirReferenceList{TFhirReference};
    function GetHasTargetList : Boolean;
    Procedure SetOccurred(value : TFhirType);
    Procedure SetRecorded(value : TFhirInstant);
    Function GetRecordedST : TFslDateTime;
    Procedure SetRecordedST(value : TFslDateTime);
    function GetPolicyList : TFhirUriList;
    function GetHasPolicyList : Boolean;
    Procedure SetLocation(value : TFhirReference{TFhirLocation});
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
    Procedure SetActivity(value : TFhirCodeableConcept);
    function GetAgentList : TFhirProvenanceAgentList;
    function GetHasAgentList : Boolean;
    function GetEntityList : TFhirProvenanceEntityList;
    function GetHasEntityList : Boolean;
    function GetSignatureList : TFhirSignatureList;
    function GetHasSignatureList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProvenance; overload;
    function Clone : TFhirProvenance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The Reference(s) that were generated or updated by  the activity described in this resource. A provenance can point to more than one target if multiple resources were created/updated by the same activity.
    property targetList : TFhirReferenceList{TFhirReference} read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

    // Typed access to The period during which the activity occurred. (defined for API consistency)
    property occurred : TFhirType read FOccurred write SetOccurred;
    // The period during which the activity occurred.
    property occurredElement : TFhirType read FOccurred write SetOccurred;

    // Typed access to The instant of time at which the activity was recorded.
    property recorded : TFslDateTime read GetRecordedST write SetRecordedST;
    // The instant of time at which the activity was recorded.
    property recordedElement : TFhirInstant read FRecorded write SetRecorded;

    // Policy or plan the activity was defined by. Typically, a single activity may have multiple applicable policy documents, such as patient consent, guarantor funding, etc.
    property policyList : TFhirUriList read GetPolicyList;
    property hasPolicyList : boolean read GetHasPolicyList;

    // Typed access to Where the activity occurred, if relevant. (defined for API consistency)
    property location : TFhirReference{TFhirLocation} read FLocation write SetLocation;
    // Where the activity occurred, if relevant.
    property locationElement : TFhirReference{TFhirLocation} read FLocation write SetLocation;

    // The reason that the activity was taking place.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Typed access to An activity is something that occurs over a period of time and acts upon or with entities; it may include consuming, processing, transforming, modifying, relocating, using, or generating entities. (defined for API consistency)
    property activity : TFhirCodeableConcept read FActivity write SetActivity;
    // An activity is something that occurs over a period of time and acts upon or with entities; it may include consuming, processing, transforming, modifying, relocating, using, or generating entities.
    property activityElement : TFhirCodeableConcept read FActivity write SetActivity;

    // An actor taking a role in an activity  for which it can be assigned some degree of responsibility for the activity taking place.
    property agentList : TFhirProvenanceAgentList read GetAgentList;
    property hasAgentList : boolean read GetHasAgentList;

    // An entity used in this activity.
    property entityList : TFhirProvenanceEntityList read GetEntityList;
    property hasEntityList : boolean read GetHasEntityList;

    // A digital signature on the target Reference(s). The signer should match a Provenance.agent. The purpose of the signature is indicated.
    property signatureList : TFhirSignatureList read GetSignatureList;
    property hasSignatureList : boolean read GetHasSignatureList;

  end;

  TFhirProvenanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProvenanceList;
    function GetCurrent : TFhirProvenance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProvenanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProvenance read GetCurrent;
  end;

  TFhirProvenanceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProvenance;
    procedure SetItemN(index : Integer; value : TFhirProvenance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProvenanceList; Overload;
    function Clone : TFhirProvenanceList; Overload;
    function GetEnumerator : TFhirProvenanceListEnumerator;
    

    //  Add a FhirProvenance to the end of the list.
    function Append : TFhirProvenance;

    
    // Add an already existing FhirProvenance to the end of the list.
    procedure AddItem(value : TFhirProvenance); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProvenance) : Integer;
    

    // Insert FhirProvenance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProvenance;
    

    // Insert an existing FhirProvenance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProvenance);
    
    // Get the iIndexth FhirProvenance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProvenance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirProvenance;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirProvenances[index : Integer] : TFhirProvenance read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PROVENANCE}

{$IFDEF FHIR_REQUESTGROUP}

  // The actions, if any, produced by the evaluation of the artifact.
  TFhirRequestGroupAction = class (TFhirBackboneElement)
  protected
    FPrefix : TFhirString;
    FTitle : TFhirString;
    FDescription : TFhirString;
    FTextEquivalent : TFhirString;
    FPriority : TFhirEnum;
    FcodeList : TFhirCodeableConceptList;
    FdocumentationList : TFhirRelatedArtifactList;
    FconditionList : TFhirRequestGroupActionConditionList;
    FrelatedActionList : TFhirRequestGroupActionRelatedActionList;
    FTiming : TFhirType;
    FparticipantList : TFhirReferenceList{TFhirPatient};
    FType_ : TFhirCodeableConcept;
    FGroupingBehavior : TFhirEnum;
    FSelectionBehavior : TFhirEnum;
    FRequiredBehavior : TFhirEnum;
    FPrecheckBehavior : TFhirEnum;
    FCardinalityBehavior : TFhirEnum;
    FResource : TFhirReference{TFhirReference};
    FactionList : TFhirRequestGroupActionList;
    Procedure SetPrefix(value : TFhirString);
    Function GetPrefixST : String;
    Procedure SetPrefixST(value : String);
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetTextEquivalent(value : TFhirString);
    Function GetTextEquivalentST : String;
    Procedure SetTextEquivalentST(value : String);
    Procedure SetPriority(value : TFhirEnum);
    Function GetPriorityST : TFhirRequestPriorityEnum;
    Procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetDocumentationList : TFhirRelatedArtifactList;
    function GetHasDocumentationList : Boolean;
    function GetConditionList : TFhirRequestGroupActionConditionList;
    function GetHasConditionList : Boolean;
    function GetRelatedActionList : TFhirRequestGroupActionRelatedActionList;
    function GetHasRelatedActionList : Boolean;
    Procedure SetTiming(value : TFhirType);
    function GetParticipantList : TFhirReferenceList{TFhirPatient};
    function GetHasParticipantList : Boolean;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetGroupingBehavior(value : TFhirEnum);
    Function GetGroupingBehaviorST : TFhirActionGroupingBehaviorEnum;
    Procedure SetGroupingBehaviorST(value : TFhirActionGroupingBehaviorEnum);
    Procedure SetSelectionBehavior(value : TFhirEnum);
    Function GetSelectionBehaviorST : TFhirActionSelectionBehaviorEnum;
    Procedure SetSelectionBehaviorST(value : TFhirActionSelectionBehaviorEnum);
    Procedure SetRequiredBehavior(value : TFhirEnum);
    Function GetRequiredBehaviorST : TFhirActionRequiredBehaviorEnum;
    Procedure SetRequiredBehaviorST(value : TFhirActionRequiredBehaviorEnum);
    Procedure SetPrecheckBehavior(value : TFhirEnum);
    Function GetPrecheckBehaviorST : TFhirActionPrecheckBehaviorEnum;
    Procedure SetPrecheckBehaviorST(value : TFhirActionPrecheckBehaviorEnum);
    Procedure SetCardinalityBehavior(value : TFhirEnum);
    Function GetCardinalityBehaviorST : TFhirActionCardinalityBehaviorEnum;
    Procedure SetCardinalityBehaviorST(value : TFhirActionCardinalityBehaviorEnum);
    Procedure SetResource(value : TFhirReference{TFhirReference});
    function GetActionList : TFhirRequestGroupActionList;
    function GetHasActionList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestGroupAction; overload;
    function Clone : TFhirRequestGroupAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A user-visible prefix for the action.
    property prefix : String read GetPrefixST write SetPrefixST;
    // A user-visible prefix for the action.
    property prefixElement : TFhirString read FPrefix write SetPrefix;

    // Typed access to The title of the action displayed to a user.
    property title : String read GetTitleST write SetTitleST;
    // The title of the action displayed to a user.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to A short description of the action used to provide a summary to display to the user.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A short description of the action used to provide a summary to display to the user.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to A text equivalent of the action to be performed. This provides a human-interpretable description of the action when the definition is consumed by a system that might not be capable of interpreting it dynamically.
    property textEquivalent : String read GetTextEquivalentST write SetTextEquivalentST;
    // A text equivalent of the action to be performed. This provides a human-interpretable description of the action when the definition is consumed by a system that might not be capable of interpreting it dynamically.
    property textEquivalentElement : TFhirString read FTextEquivalent write SetTextEquivalent;

    // Indicates how quickly the action should be addressed with respect to other actions.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // A code that provides meaning for the action or action group. For example, a section may have a LOINC code for a section of a documentation template.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Didactic or other informational resources associated with the action that can be provided to the CDS recipient. Information resources can include inline text commentary and links to web resources.
    property documentationList : TFhirRelatedArtifactList read GetDocumentationList;
    property hasDocumentationList : boolean read GetHasDocumentationList;

    // An expression that describes applicability criteria, or start/stop conditions for the action.
    property conditionList : TFhirRequestGroupActionConditionList read GetConditionList;
    property hasConditionList : boolean read GetHasConditionList;

    // A relationship to another action such as "before" or "30-60 minutes after start of".
    property relatedActionList : TFhirRequestGroupActionRelatedActionList read GetRelatedActionList;
    property hasRelatedActionList : boolean read GetHasRelatedActionList;

    // Typed access to An optional value describing when the action should be performed. (defined for API consistency)
    property timing : TFhirType read FTiming write SetTiming;
    // An optional value describing when the action should be performed.
    property timingElement : TFhirType read FTiming write SetTiming;

    // The participant that should perform or be responsible for this action.
    property participantList : TFhirReferenceList{TFhirPatient} read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Typed access to The type of action to perform (create, update, remove). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of action to perform (create, update, remove).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Defines the grouping behavior for the action and its children.
    property groupingBehavior : TFhirActionGroupingBehaviorEnum read GetGroupingBehaviorST write SetGroupingBehaviorST;
    property groupingBehaviorElement : TFhirEnum read FGroupingBehavior write SetGroupingBehavior;

    // Defines the selection behavior for the action and its children.
    property selectionBehavior : TFhirActionSelectionBehaviorEnum read GetSelectionBehaviorST write SetSelectionBehaviorST;
    property selectionBehaviorElement : TFhirEnum read FSelectionBehavior write SetSelectionBehavior;

    // Defines expectations around whether an action is required.
    property requiredBehavior : TFhirActionRequiredBehaviorEnum read GetRequiredBehaviorST write SetRequiredBehaviorST;
    property requiredBehaviorElement : TFhirEnum read FRequiredBehavior write SetRequiredBehavior;

    // Defines whether the action should usually be preselected.
    property precheckBehavior : TFhirActionPrecheckBehaviorEnum read GetPrecheckBehaviorST write SetPrecheckBehaviorST;
    property precheckBehaviorElement : TFhirEnum read FPrecheckBehavior write SetPrecheckBehavior;

    // Defines whether the action can be selected multiple times.
    property cardinalityBehavior : TFhirActionCardinalityBehaviorEnum read GetCardinalityBehaviorST write SetCardinalityBehaviorST;
    property cardinalityBehaviorElement : TFhirEnum read FCardinalityBehavior write SetCardinalityBehavior;

    // Typed access to The resource that is the target of the action (e.g. CommunicationRequest). (defined for API consistency)
    property resource : TFhirReference{TFhirReference} read FResource write SetResource;
    // The resource that is the target of the action (e.g. CommunicationRequest).
    property resourceElement : TFhirReference{TFhirReference} read FResource write SetResource;

    // Sub actions.
    property actionList : TFhirRequestGroupActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirRequestGroupActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestGroupActionList;
    function GetCurrent : TFhirRequestGroupAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRequestGroupActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestGroupAction read GetCurrent;
  end;

  TFhirRequestGroupActionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRequestGroupAction;
    procedure SetItemN(index : Integer; value : TFhirRequestGroupAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRequestGroupActionList; Overload;
    function Clone : TFhirRequestGroupActionList; Overload;
    function GetEnumerator : TFhirRequestGroupActionListEnumerator;
    

    //  Add a FhirRequestGroupAction to the end of the list.
    function Append : TFhirRequestGroupAction;

    
    // Add an already existing FhirRequestGroupAction to the end of the list.
    procedure AddItem(value : TFhirRequestGroupAction); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestGroupAction) : Integer;
    

    // Insert FhirRequestGroupAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestGroupAction;
    

    // Insert an existing FhirRequestGroupAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestGroupAction);
    
    // Get the iIndexth FhirRequestGroupAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestGroupAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestGroupAction;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirRequestGroupActions[index : Integer] : TFhirRequestGroupAction read GetItemN write SetItemN; default;
  End;

  // An expression that describes applicability criteria, or start/stop conditions for the action.
  TFhirRequestGroupActionCondition = class (TFhirBackboneElement)
  protected
    FKind : TFhirEnum;
    FExpression : TFhirExpression;
    Procedure SetKind(value : TFhirEnum);
    Function GetKindST : TFhirActionConditionKindEnum;
    Procedure SetKindST(value : TFhirActionConditionKindEnum);
    Procedure SetExpression(value : TFhirExpression);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestGroupActionCondition; overload;
    function Clone : TFhirRequestGroupActionCondition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The kind of condition.
    property kind : TFhirActionConditionKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to An expression that returns true or false, indicating whether or not the condition is satisfied. (defined for API consistency)
    property expression : TFhirExpression read FExpression write SetExpression;
    // An expression that returns true or false, indicating whether or not the condition is satisfied.
    property expressionElement : TFhirExpression read FExpression write SetExpression;

  end;

  TFhirRequestGroupActionConditionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestGroupActionConditionList;
    function GetCurrent : TFhirRequestGroupActionCondition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRequestGroupActionConditionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestGroupActionCondition read GetCurrent;
  end;

  TFhirRequestGroupActionConditionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRequestGroupActionCondition;
    procedure SetItemN(index : Integer; value : TFhirRequestGroupActionCondition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRequestGroupActionConditionList; Overload;
    function Clone : TFhirRequestGroupActionConditionList; Overload;
    function GetEnumerator : TFhirRequestGroupActionConditionListEnumerator;
    

    //  Add a FhirRequestGroupActionCondition to the end of the list.
    function Append : TFhirRequestGroupActionCondition;

    
    // Add an already existing FhirRequestGroupActionCondition to the end of the list.
    procedure AddItem(value : TFhirRequestGroupActionCondition); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestGroupActionCondition) : Integer;
    

    // Insert FhirRequestGroupActionCondition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestGroupActionCondition;
    

    // Insert an existing FhirRequestGroupActionCondition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestGroupActionCondition);
    
    // Get the iIndexth FhirRequestGroupActionCondition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestGroupActionCondition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestGroupActionCondition;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirRequestGroupActionConditions[index : Integer] : TFhirRequestGroupActionCondition read GetItemN write SetItemN; default;
  End;

  // A relationship to another action such as "before" or "30-60 minutes after start of".
  TFhirRequestGroupActionRelatedAction = class (TFhirBackboneElement)
  protected
    FActionId : TFhirId;
    FRelationship : TFhirEnum;
    FOffset : TFhirType;
    Procedure SetActionId(value : TFhirId);
    Function GetActionIdST : String;
    Procedure SetActionIdST(value : String);
    Procedure SetRelationship(value : TFhirEnum);
    Function GetRelationshipST : TFhirActionRelationshipTypeEnum;
    Procedure SetRelationshipST(value : TFhirActionRelationshipTypeEnum);
    Procedure SetOffset(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestGroupActionRelatedAction; overload;
    function Clone : TFhirRequestGroupActionRelatedAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The element id of the action this is related to.
    property actionId : String read GetActionIdST write SetActionIdST;
    // The element id of the action this is related to.
    property actionIdElement : TFhirId read FActionId write SetActionId;

    // The relationship of this action to the related action.
    property relationship : TFhirActionRelationshipTypeEnum read GetRelationshipST write SetRelationshipST;
    property relationshipElement : TFhirEnum read FRelationship write SetRelationship;

    // Typed access to A duration or range of durations to apply to the relationship. For example, 30-60 minutes before. (defined for API consistency)
    property offset : TFhirType read FOffset write SetOffset;
    // A duration or range of durations to apply to the relationship. For example, 30-60 minutes before.
    property offsetElement : TFhirType read FOffset write SetOffset;

  end;

  TFhirRequestGroupActionRelatedActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestGroupActionRelatedActionList;
    function GetCurrent : TFhirRequestGroupActionRelatedAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRequestGroupActionRelatedActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestGroupActionRelatedAction read GetCurrent;
  end;

  TFhirRequestGroupActionRelatedActionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRequestGroupActionRelatedAction;
    procedure SetItemN(index : Integer; value : TFhirRequestGroupActionRelatedAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRequestGroupActionRelatedActionList; Overload;
    function Clone : TFhirRequestGroupActionRelatedActionList; Overload;
    function GetEnumerator : TFhirRequestGroupActionRelatedActionListEnumerator;
    

    //  Add a FhirRequestGroupActionRelatedAction to the end of the list.
    function Append : TFhirRequestGroupActionRelatedAction;

    
    // Add an already existing FhirRequestGroupActionRelatedAction to the end of the list.
    procedure AddItem(value : TFhirRequestGroupActionRelatedAction); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestGroupActionRelatedAction) : Integer;
    

    // Insert FhirRequestGroupActionRelatedAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestGroupActionRelatedAction;
    

    // Insert an existing FhirRequestGroupActionRelatedAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestGroupActionRelatedAction);
    
    // Get the iIndexth FhirRequestGroupActionRelatedAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestGroupActionRelatedAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestGroupActionRelatedAction;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirRequestGroupActionRelatedActions[index : Integer] : TFhirRequestGroupActionRelatedAction read GetItemN write SetItemN; default;
  End;

  // A group of related requests that can be used to capture intended activities that have inter-dependencies such as "give this medication after that one".
  TFhirRequestGroup = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FbasedOnList : TFhirReferenceList{TFhirReference};
    FreplacesList : TFhirReferenceList{TFhirReference};
    FGroupIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FIntent : TFhirEnum;
    FPriority : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference{TFhirPatient};
    FEncounter : TFhirReference{TFhirEncounter};
    FAuthoredOn : TFhirDateTime;
    FAuthor : TFhirReference{TFhirDevice};
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList{TFhirCondition};
    FnoteList : TFhirAnnotationList;
    FactionList : TFhirRequestGroupActionList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetBasedOnList : TFhirReferenceList{TFhirReference};
    function GetHasBasedOnList : Boolean;
    function GetReplacesList : TFhirReferenceList{TFhirReference};
    function GetHasReplacesList : Boolean;
    Procedure SetGroupIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirRequestStatusEnum;
    Procedure SetStatusST(value : TFhirRequestStatusEnum);
    Procedure SetIntent(value : TFhirEnum);
    Function GetIntentST : TFhirRequestIntentEnum;
    Procedure SetIntentST(value : TFhirRequestIntentEnum);
    Procedure SetPriority(value : TFhirEnum);
    Function GetPriorityST : TFhirRequestPriorityEnum;
    Procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{TFhirPatient});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetAuthoredOn(value : TFhirDateTime);
    Function GetAuthoredOnST : TFslDateTime;
    Procedure SetAuthoredOnST(value : TFslDateTime);
    Procedure SetAuthor(value : TFhirReference{TFhirDevice});
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList{TFhirCondition};
    function GetHasReasonReferenceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetActionList : TFhirRequestGroupActionList;
    function GetHasActionList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestGroup; overload;
    function Clone : TFhirRequestGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Allows a service to provide a unique, business identifier for the request.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A canonical URL referencing a FHIR-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this request.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // A URL referencing an externally defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this request.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // A plan, proposal or order that is fulfilled in whole or in part by this request.
    property basedOnList : TFhirReferenceList{TFhirReference} read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Completed or terminated request(s) whose function is taken by this new request.
    property replacesList : TFhirReferenceList{TFhirReference} read GetReplacesList;
    property hasReplacesList : boolean read GetHasReplacesList;

    // Typed access to A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition, prescription or similar form. (defined for API consistency)
    property groupIdentifier : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;
    // A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition, prescription or similar form.
    property groupIdentifierElement : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;

    // The current state of the request. For request groups, the status reflects the status of all the requests in the group.
    property status : TFhirRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Indicates the level of authority/intentionality associated with the request and where the request fits into the workflow chain.
    property intent : TFhirRequestIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Indicates how quickly the request should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to A code that identifies what the overall request group is. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies what the overall request group is.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The subject for which the request group was created. (defined for API consistency)
    property subject : TFhirReference{TFhirPatient} read FSubject write SetSubject;
    // The subject for which the request group was created.
    property subjectElement : TFhirReference{TFhirPatient} read FSubject write SetSubject;

    // Typed access to Describes the context of the request group, if any. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // Describes the context of the request group, if any.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to Indicates when the request group was created.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // Indicates when the request group was created.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to Provides a reference to the author of the request group. (defined for API consistency)
    property author : TFhirReference{TFhirDevice} read FAuthor write SetAuthor;
    // Provides a reference to the author of the request group.
    property authorElement : TFhirReference{TFhirDevice} read FAuthor write SetAuthor;

    // Describes the reason for the request group in coded or textual form.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Indicates another resource whose existence justifies this request group.
    property reasonReferenceList : TFhirReferenceList{TFhirCondition} read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Provides a mechanism to communicate additional information about the response.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // The actions, if any, produced by the evaluation of the artifact.
    property actionList : TFhirRequestGroupActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirRequestGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestGroupList;
    function GetCurrent : TFhirRequestGroup;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRequestGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestGroup read GetCurrent;
  end;

  TFhirRequestGroupList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRequestGroup;
    procedure SetItemN(index : Integer; value : TFhirRequestGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRequestGroupList; Overload;
    function Clone : TFhirRequestGroupList; Overload;
    function GetEnumerator : TFhirRequestGroupListEnumerator;
    

    //  Add a FhirRequestGroup to the end of the list.
    function Append : TFhirRequestGroup;

    
    // Add an already existing FhirRequestGroup to the end of the list.
    procedure AddItem(value : TFhirRequestGroup); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestGroup) : Integer;
    

    // Insert FhirRequestGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestGroup;
    

    // Insert an existing FhirRequestGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestGroup);
    
    // Get the iIndexth FhirRequestGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestGroup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestGroup;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirRequestGroups[index : Integer] : TFhirRequestGroup read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_REQUESTGROUP}

{$IFDEF FHIR_RESEARCHDEFINITION}

  // The ResearchDefinition resource describes the conditional state (population and any exposures being compared within the population) and outcome (if specified) that the knowledge (evidence, assertion, recommendation) is about.
  TFhirResearchDefinition = class (TFhirMetadataResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FShortTitle : TFhirString;
    FSubtitle : TFhirString;
    FSubject : TFhirType;
    FcommentList : TFhirStringList;
    FPurpose : TFhirMarkdown;
    FUsage : TFhirString;
    FCopyright : TFhirMarkdown;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FtopicList : TFhirCodeableConceptList;
    FauthorList : TFhirContactDetailList;
    FeditorList : TFhirContactDetailList;
    FreviewerList : TFhirContactDetailList;
    FendorserList : TFhirContactDetailList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    Flibrary_List : TFhirCanonicalList;
    FPopulation : TFhirReference{TFhirResearchElementDefinition};
    FExposure : TFhirReference{TFhirResearchElementDefinition};
    FExposureAlternative : TFhirReference{TFhirResearchElementDefinition};
    FOutcome : TFhirReference{TFhirResearchElementDefinition};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetShortTitle(value : TFhirString);
    Function GetShortTitleST : String;
    Procedure SetShortTitleST(value : String);
    Procedure SetSubtitle(value : TFhirString);
    Function GetSubtitleST : String;
    Procedure SetSubtitleST(value : String);
    Procedure SetSubject(value : TFhirType);
    function GetCommentList : TFhirStringList;
    function GetHasCommentList : Boolean;
    Procedure SetPurpose(value : TFhirMarkdown);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
    Procedure SetUsage(value : TFhirString);
    Function GetUsageST : String;
    Procedure SetUsageST(value : String);
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    Procedure SetApprovalDate(value : TFhirDate);
    Function GetApprovalDateST : TFslDateTime;
    Procedure SetApprovalDateST(value : TFslDateTime);
    Procedure SetLastReviewDate(value : TFhirDate);
    Function GetLastReviewDateST : TFslDateTime;
    Procedure SetLastReviewDateST(value : TFslDateTime);
    Procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetTopicList : TFhirCodeableConceptList;
    function GetHasTopicList : Boolean;
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetLibrary_List : TFhirCanonicalList;
    function GetHasLibrary_List : Boolean;
    Procedure SetPopulation(value : TFhirReference{TFhirResearchElementDefinition});
    Procedure SetExposure(value : TFhirReference{TFhirResearchElementDefinition});
    Procedure SetExposureAlternative(value : TFhirReference{TFhirResearchElementDefinition});
    Procedure SetOutcome(value : TFhirReference{TFhirResearchElementDefinition});
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchDefinition; overload;
    function Clone : TFhirResearchDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this research definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this research definition is (or will be) {$IFNDEF FPC}Published{$ENDIF}. This URL can be the target of a canonical reference. It SHALL remain the same when the research definition is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this research definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this research definition is (or will be) {$IFNDEF FPC}Published{$ENDIF}. This URL can be the target of a canonical reference. It SHALL remain the same when the research definition is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this research definition when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the research definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the research definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the research definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the research definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the research definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the research definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the research definition.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the research definition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to The short title provides an alternate title for use in informal descriptive contexts where the full, formal title is not necessary.
    property shortTitle : String read GetShortTitleST write SetShortTitleST;
    // The short title provides an alternate title for use in informal descriptive contexts where the full, formal title is not necessary.
    property shortTitleElement : TFhirString read FShortTitle write SetShortTitle;

    // Typed access to An explanatory or alternate title for the ResearchDefinition giving additional information about its content.
    property subtitle : String read GetSubtitleST write SetSubtitleST;
    // An explanatory or alternate title for the ResearchDefinition giving additional information about its content.
    property subtitleElement : TFhirString read FSubtitle write SetSubtitle;

    // The status of this research definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this research definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this research definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The intended subjects for the ResearchDefinition. If this element is not provided, a Patient subject is assumed, but the subject of the ResearchDefinition can be anything. (defined for API consistency)
    property subject : TFhirType read FSubject write SetSubject;
    // The intended subjects for the ResearchDefinition. If this element is not provided, a Patient subject is assumed, but the subject of the ResearchDefinition can be anything.
    property subjectElement : TFhirType read FSubject write SetSubject;

    // Typed access to The date  (and optionally time) when the research definition was {$IFNDEF FPC}Published{$ENDIF}. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the research definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the research definition was {$IFNDEF FPC}Published{$ENDIF}. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the research definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that {$IFNDEF FPC}Published{$ENDIF} the research definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that {$IFNDEF FPC}Published{$ENDIF} the research definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the research definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the research definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // A human-readable string to clarify or explain concepts about the resource.
    property commentList : TFhirStringList read GetCommentList;
    property hasCommentList : boolean read GetHasCommentList;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate research definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the research definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this research definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this research definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A detailed description, from a clinical perspective, of how the ResearchDefinition is used.
    property usage : String read GetUsageST write SetUsageST;
    // A detailed description, from a clinical perspective, of how the ResearchDefinition is used.
    property usageElement : TFhirString read FUsage write SetUsage;

    // Typed access to A copyright statement relating to the research definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the research definition.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the research definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the research definition.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the research definition content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the research definition content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // Descriptive topics related to the content of the ResearchDefinition. Topics provide a high-level categorization grouping types of ResearchDefinitions that can be useful for filtering and searching.
    property topicList : TFhirCodeableConceptList read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // An individiual or organization primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individual or organization primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individual or organization primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individual or organization responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Related artifacts such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // A reference to a Library resource containing the formal logic used by the ResearchDefinition.
    property library_List : TFhirCanonicalList read GetLibrary_List;
    property hasLibrary_List : boolean read GetHasLibrary_List;

    // Typed access to A reference to a ResearchElementDefinition resource that defines the population for the research. (defined for API consistency)
    property population : TFhirReference{TFhirResearchElementDefinition} read FPopulation write SetPopulation;
    // A reference to a ResearchElementDefinition resource that defines the population for the research.
    property populationElement : TFhirReference{TFhirResearchElementDefinition} read FPopulation write SetPopulation;

    // Typed access to A reference to a ResearchElementDefinition resource that defines the exposure for the research. (defined for API consistency)
    property exposure : TFhirReference{TFhirResearchElementDefinition} read FExposure write SetExposure;
    // A reference to a ResearchElementDefinition resource that defines the exposure for the research.
    property exposureElement : TFhirReference{TFhirResearchElementDefinition} read FExposure write SetExposure;

    // Typed access to A reference to a ResearchElementDefinition resource that defines the exposureAlternative for the research. (defined for API consistency)
    property exposureAlternative : TFhirReference{TFhirResearchElementDefinition} read FExposureAlternative write SetExposureAlternative;
    // A reference to a ResearchElementDefinition resource that defines the exposureAlternative for the research.
    property exposureAlternativeElement : TFhirReference{TFhirResearchElementDefinition} read FExposureAlternative write SetExposureAlternative;

    // Typed access to A reference to a ResearchElementDefinition resomece that defines the outcome for the research. (defined for API consistency)
    property outcome : TFhirReference{TFhirResearchElementDefinition} read FOutcome write SetOutcome;
    // A reference to a ResearchElementDefinition resomece that defines the outcome for the research.
    property outcomeElement : TFhirReference{TFhirResearchElementDefinition} read FOutcome write SetOutcome;

  end;

  TFhirResearchDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchDefinitionList;
    function GetCurrent : TFhirResearchDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirResearchDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchDefinition read GetCurrent;
  end;

  TFhirResearchDefinitionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirResearchDefinition;
    procedure SetItemN(index : Integer; value : TFhirResearchDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirResearchDefinitionList; Overload;
    function Clone : TFhirResearchDefinitionList; Overload;
    function GetEnumerator : TFhirResearchDefinitionListEnumerator;
    

    //  Add a FhirResearchDefinition to the end of the list.
    function Append : TFhirResearchDefinition;

    
    // Add an already existing FhirResearchDefinition to the end of the list.
    procedure AddItem(value : TFhirResearchDefinition); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchDefinition) : Integer;
    

    // Insert FhirResearchDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchDefinition;
    

    // Insert an existing FhirResearchDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchDefinition);
    
    // Get the iIndexth FhirResearchDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchDefinition;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirResearchDefinitions[index : Integer] : TFhirResearchDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RESEARCHDEFINITION}

{$IFDEF FHIR_RESEARCHELEMENTDEFINITION}

  // A characteristic that defines the members of the research element. Multiple characteristics are applied with "and" semantics.
  TFhirResearchElementDefinitionCharacteristic = class (TFhirBackboneElement)
  protected
    FDefinition : TFhirType;
    FusageContextList : TFhirUsageContextList;
    FExclude : TFhirBoolean;
    FUnitOfMeasure : TFhirCodeableConcept;
    FStudyEffectiveDescription : TFhirString;
    FStudyEffective : TFhirType;
    FStudyEffectiveTimeFromStart : TFhirDuration;
    FStudyEffectiveGroupMeasure : TFhirEnum;
    FParticipantEffectiveDescription : TFhirString;
    FParticipantEffective : TFhirType;
    FParticipantEffectiveTimeFromStart : TFhirDuration;
    FParticipantEffectiveGroupMeasure : TFhirEnum;
    Procedure SetDefinition(value : TFhirType);
    function GetUsageContextList : TFhirUsageContextList;
    function GetHasUsageContextList : Boolean;
    Procedure SetExclude(value : TFhirBoolean);
    Function GetExcludeST : Boolean;
    Procedure SetExcludeST(value : Boolean);
    Procedure SetUnitOfMeasure(value : TFhirCodeableConcept);
    Procedure SetStudyEffectiveDescription(value : TFhirString);
    Function GetStudyEffectiveDescriptionST : String;
    Procedure SetStudyEffectiveDescriptionST(value : String);
    Procedure SetStudyEffective(value : TFhirType);
    Procedure SetStudyEffectiveTimeFromStart(value : TFhirDuration);
    Procedure SetStudyEffectiveGroupMeasure(value : TFhirEnum);
    Function GetStudyEffectiveGroupMeasureST : TFhirGroupMeasureEnum;
    Procedure SetStudyEffectiveGroupMeasureST(value : TFhirGroupMeasureEnum);
    Procedure SetParticipantEffectiveDescription(value : TFhirString);
    Function GetParticipantEffectiveDescriptionST : String;
    Procedure SetParticipantEffectiveDescriptionST(value : String);
    Procedure SetParticipantEffective(value : TFhirType);
    Procedure SetParticipantEffectiveTimeFromStart(value : TFhirDuration);
    Procedure SetParticipantEffectiveGroupMeasure(value : TFhirEnum);
    Function GetParticipantEffectiveGroupMeasureST : TFhirGroupMeasureEnum;
    Procedure SetParticipantEffectiveGroupMeasureST(value : TFhirGroupMeasureEnum);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchElementDefinitionCharacteristic; overload;
    function Clone : TFhirResearchElementDefinitionCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Define members of the research element using Codes (such as condition, medication, or observation), Expressions ( using an expression language such as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in the last year). (defined for API consistency)
    property definition : TFhirType read FDefinition write SetDefinition;
    // Define members of the research element using Codes (such as condition, medication, or observation), Expressions ( using an expression language such as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in the last year).
    property definitionElement : TFhirType read FDefinition write SetDefinition;

    // Use UsageContext to define the members of the population, such as Age Ranges, Genders, Settings.
    property usageContextList : TFhirUsageContextList read GetUsageContextList;
    property hasUsageContextList : boolean read GetHasUsageContextList;

    // Typed access to When true, members with this characteristic are excluded from the element.
    property exclude : Boolean read GetExcludeST write SetExcludeST;
    // When true, members with this characteristic are excluded from the element.
    property excludeElement : TFhirBoolean read FExclude write SetExclude;

    // Typed access to Specifies the UCUM unit for the outcome. (defined for API consistency)
    property unitOfMeasure : TFhirCodeableConcept read FUnitOfMeasure write SetUnitOfMeasure;
    // Specifies the UCUM unit for the outcome.
    property unitOfMeasureElement : TFhirCodeableConcept read FUnitOfMeasure write SetUnitOfMeasure;

    // Typed access to A narrative description of the time period the study covers.
    property studyEffectiveDescription : String read GetStudyEffectiveDescriptionST write SetStudyEffectiveDescriptionST;
    // A narrative description of the time period the study covers.
    property studyEffectiveDescriptionElement : TFhirString read FStudyEffectiveDescription write SetStudyEffectiveDescription;

    // Typed access to Indicates what effective period the study covers. (defined for API consistency)
    property studyEffective : TFhirType read FStudyEffective write SetStudyEffective;
    // Indicates what effective period the study covers.
    property studyEffectiveElement : TFhirType read FStudyEffective write SetStudyEffective;

    // Typed access to Indicates duration from the study initiation. (defined for API consistency)
    property studyEffectiveTimeFromStart : TFhirDuration read FStudyEffectiveTimeFromStart write SetStudyEffectiveTimeFromStart;
    // Indicates duration from the study initiation.
    property studyEffectiveTimeFromStartElement : TFhirDuration read FStudyEffectiveTimeFromStart write SetStudyEffectiveTimeFromStart;

    // Indicates how elements are aggregated within the study effective period.
    property studyEffectiveGroupMeasure : TFhirGroupMeasureEnum read GetStudyEffectiveGroupMeasureST write SetStudyEffectiveGroupMeasureST;
    property studyEffectiveGroupMeasureElement : TFhirEnum read FStudyEffectiveGroupMeasure write SetStudyEffectiveGroupMeasure;

    // Typed access to A narrative description of the time period the study covers.
    property participantEffectiveDescription : String read GetParticipantEffectiveDescriptionST write SetParticipantEffectiveDescriptionST;
    // A narrative description of the time period the study covers.
    property participantEffectiveDescriptionElement : TFhirString read FParticipantEffectiveDescription write SetParticipantEffectiveDescription;

    // Typed access to Indicates what effective period the study covers. (defined for API consistency)
    property participantEffective : TFhirType read FParticipantEffective write SetParticipantEffective;
    // Indicates what effective period the study covers.
    property participantEffectiveElement : TFhirType read FParticipantEffective write SetParticipantEffective;

    // Typed access to Indicates duration from the participant's study entry. (defined for API consistency)
    property participantEffectiveTimeFromStart : TFhirDuration read FParticipantEffectiveTimeFromStart write SetParticipantEffectiveTimeFromStart;
    // Indicates duration from the participant's study entry.
    property participantEffectiveTimeFromStartElement : TFhirDuration read FParticipantEffectiveTimeFromStart write SetParticipantEffectiveTimeFromStart;

    // Indicates how elements are aggregated within the study effective period.
    property participantEffectiveGroupMeasure : TFhirGroupMeasureEnum read GetParticipantEffectiveGroupMeasureST write SetParticipantEffectiveGroupMeasureST;
    property participantEffectiveGroupMeasureElement : TFhirEnum read FParticipantEffectiveGroupMeasure write SetParticipantEffectiveGroupMeasure;

  end;

  TFhirResearchElementDefinitionCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchElementDefinitionCharacteristicList;
    function GetCurrent : TFhirResearchElementDefinitionCharacteristic;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirResearchElementDefinitionCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchElementDefinitionCharacteristic read GetCurrent;
  end;

  TFhirResearchElementDefinitionCharacteristicList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirResearchElementDefinitionCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirResearchElementDefinitionCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirResearchElementDefinitionCharacteristicList; Overload;
    function Clone : TFhirResearchElementDefinitionCharacteristicList; Overload;
    function GetEnumerator : TFhirResearchElementDefinitionCharacteristicListEnumerator;
    

    //  Add a FhirResearchElementDefinitionCharacteristic to the end of the list.
    function Append : TFhirResearchElementDefinitionCharacteristic;

    
    // Add an already existing FhirResearchElementDefinitionCharacteristic to the end of the list.
    procedure AddItem(value : TFhirResearchElementDefinitionCharacteristic); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchElementDefinitionCharacteristic) : Integer;
    

    // Insert FhirResearchElementDefinitionCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchElementDefinitionCharacteristic;
    

    // Insert an existing FhirResearchElementDefinitionCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchElementDefinitionCharacteristic);
    
    // Get the iIndexth FhirResearchElementDefinitionCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchElementDefinitionCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchElementDefinitionCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirResearchElementDefinitionCharacteristics[index : Integer] : TFhirResearchElementDefinitionCharacteristic read GetItemN write SetItemN; default;
  End;

  // The ResearchElementDefinition resource describes a "PICO" element that knowledge (evidence, assertion, recommendation) is about.
  TFhirResearchElementDefinition = class (TFhirMetadataResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FShortTitle : TFhirString;
    FSubtitle : TFhirString;
    FSubject : TFhirType;
    FcommentList : TFhirStringList;
    FPurpose : TFhirMarkdown;
    FUsage : TFhirString;
    FCopyright : TFhirMarkdown;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FtopicList : TFhirCodeableConceptList;
    FauthorList : TFhirContactDetailList;
    FeditorList : TFhirContactDetailList;
    FreviewerList : TFhirContactDetailList;
    FendorserList : TFhirContactDetailList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    Flibrary_List : TFhirCanonicalList;
    FType_ : TFhirEnum;
    FVariableType : TFhirEnum;
    FcharacteristicList : TFhirResearchElementDefinitionCharacteristicList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetShortTitle(value : TFhirString);
    Function GetShortTitleST : String;
    Procedure SetShortTitleST(value : String);
    Procedure SetSubtitle(value : TFhirString);
    Function GetSubtitleST : String;
    Procedure SetSubtitleST(value : String);
    Procedure SetSubject(value : TFhirType);
    function GetCommentList : TFhirStringList;
    function GetHasCommentList : Boolean;
    Procedure SetPurpose(value : TFhirMarkdown);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
    Procedure SetUsage(value : TFhirString);
    Function GetUsageST : String;
    Procedure SetUsageST(value : String);
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    Procedure SetApprovalDate(value : TFhirDate);
    Function GetApprovalDateST : TFslDateTime;
    Procedure SetApprovalDateST(value : TFslDateTime);
    Procedure SetLastReviewDate(value : TFhirDate);
    Function GetLastReviewDateST : TFslDateTime;
    Procedure SetLastReviewDateST(value : TFslDateTime);
    Procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetTopicList : TFhirCodeableConceptList;
    function GetHasTopicList : Boolean;
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetLibrary_List : TFhirCanonicalList;
    function GetHasLibrary_List : Boolean;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirResearchElementTypeEnum;
    Procedure SetType_ST(value : TFhirResearchElementTypeEnum);
    Procedure SetVariableType(value : TFhirEnum);
    Function GetVariableTypeST : TFhirVariableTypeEnum;
    Procedure SetVariableTypeST(value : TFhirVariableTypeEnum);
    function GetCharacteristicList : TFhirResearchElementDefinitionCharacteristicList;
    function GetHasCharacteristicList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchElementDefinition; overload;
    function Clone : TFhirResearchElementDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this research element definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this research element definition is (or will be) {$IFNDEF FPC}Published{$ENDIF}. This URL can be the target of a canonical reference. It SHALL remain the same when the research element definition is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this research element definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this research element definition is (or will be) {$IFNDEF FPC}Published{$ENDIF}. This URL can be the target of a canonical reference. It SHALL remain the same when the research element definition is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this research element definition when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the research element definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the research element definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the research element definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the research element definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the research element definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the research element definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the research element definition.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the research element definition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to The short title provides an alternate title for use in informal descriptive contexts where the full, formal title is not necessary.
    property shortTitle : String read GetShortTitleST write SetShortTitleST;
    // The short title provides an alternate title for use in informal descriptive contexts where the full, formal title is not necessary.
    property shortTitleElement : TFhirString read FShortTitle write SetShortTitle;

    // Typed access to An explanatory or alternate title for the ResearchElementDefinition giving additional information about its content.
    property subtitle : String read GetSubtitleST write SetSubtitleST;
    // An explanatory or alternate title for the ResearchElementDefinition giving additional information about its content.
    property subtitleElement : TFhirString read FSubtitle write SetSubtitle;

    // The status of this research element definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this research element definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this research element definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The intended subjects for the ResearchElementDefinition. If this element is not provided, a Patient subject is assumed, but the subject of the ResearchElementDefinition can be anything. (defined for API consistency)
    property subject : TFhirType read FSubject write SetSubject;
    // The intended subjects for the ResearchElementDefinition. If this element is not provided, a Patient subject is assumed, but the subject of the ResearchElementDefinition can be anything.
    property subjectElement : TFhirType read FSubject write SetSubject;

    // Typed access to The date  (and optionally time) when the research element definition was {$IFNDEF FPC}Published{$ENDIF}. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the research element definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the research element definition was {$IFNDEF FPC}Published{$ENDIF}. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the research element definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that {$IFNDEF FPC}Published{$ENDIF} the research element definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that {$IFNDEF FPC}Published{$ENDIF} the research element definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the research element definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the research element definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // A human-readable string to clarify or explain concepts about the resource.
    property commentList : TFhirStringList read GetCommentList;
    property hasCommentList : boolean read GetHasCommentList;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate research element definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the research element definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this research element definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this research element definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A detailed description, from a clinical perspective, of how the ResearchElementDefinition is used.
    property usage : String read GetUsageST write SetUsageST;
    // A detailed description, from a clinical perspective, of how the ResearchElementDefinition is used.
    property usageElement : TFhirString read FUsage write SetUsage;

    // Typed access to A copyright statement relating to the research element definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the research element definition.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the research element definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the research element definition.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the research element definition content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the research element definition content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // Descriptive topics related to the content of the ResearchElementDefinition. Topics provide a high-level categorization grouping types of ResearchElementDefinitions that can be useful for filtering and searching.
    property topicList : TFhirCodeableConceptList read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // An individiual or organization primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individual or organization primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individual or organization primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individual or organization responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Related artifacts such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // A reference to a Library resource containing the formal logic used by the ResearchElementDefinition.
    property library_List : TFhirCanonicalList read GetLibrary_List;
    property hasLibrary_List : boolean read GetHasLibrary_List;

    // The type of research element, a population, an exposure, or an outcome.
    property type_ : TFhirResearchElementTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // The type of the outcome (e.g. Dichotomous, Continuous, or Descriptive).
    property variableType : TFhirVariableTypeEnum read GetVariableTypeST write SetVariableTypeST;
    property variableTypeElement : TFhirEnum read FVariableType write SetVariableType;

    // A characteristic that defines the members of the research element. Multiple characteristics are applied with "and" semantics.
    property characteristicList : TFhirResearchElementDefinitionCharacteristicList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

  end;

  TFhirResearchElementDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchElementDefinitionList;
    function GetCurrent : TFhirResearchElementDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirResearchElementDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchElementDefinition read GetCurrent;
  end;

  TFhirResearchElementDefinitionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirResearchElementDefinition;
    procedure SetItemN(index : Integer; value : TFhirResearchElementDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirResearchElementDefinitionList; Overload;
    function Clone : TFhirResearchElementDefinitionList; Overload;
    function GetEnumerator : TFhirResearchElementDefinitionListEnumerator;
    

    //  Add a FhirResearchElementDefinition to the end of the list.
    function Append : TFhirResearchElementDefinition;

    
    // Add an already existing FhirResearchElementDefinition to the end of the list.
    procedure AddItem(value : TFhirResearchElementDefinition); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchElementDefinition) : Integer;
    

    // Insert FhirResearchElementDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchElementDefinition;
    

    // Insert an existing FhirResearchElementDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchElementDefinition);
    
    // Get the iIndexth FhirResearchElementDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchElementDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchElementDefinition;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirResearchElementDefinitions[index : Integer] : TFhirResearchElementDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RESEARCHELEMENTDEFINITION}

{$IFDEF FHIR_RESEARCHSTUDY}

  // Describes an expected sequence of events for one of the participants of a study.  E.g. Exposure to drug A, wash-out, exposure to drug B, wash-out, follow-up.
  TFhirResearchStudyArm = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FType_ : TFhirCodeableConcept;
    FDescription : TFhirString;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchStudyArm; overload;
    function Clone : TFhirResearchStudyArm; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Unique, human-readable label for this arm of the study.
    property name : String read GetNameST write SetNameST;
    // Unique, human-readable label for this arm of the study.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Categorization of study arm, e.g. experimental, active comparator, placebo comparater. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Categorization of study arm, e.g. experimental, active comparator, placebo comparater.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A succinct description of the path through the study that would be followed by a subject adhering to this arm.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A succinct description of the path through the study that would be followed by a subject adhering to this arm.
    property descriptionElement : TFhirString read FDescription write SetDescription;

  end;

  TFhirResearchStudyArmListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchStudyArmList;
    function GetCurrent : TFhirResearchStudyArm;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirResearchStudyArmList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchStudyArm read GetCurrent;
  end;

  TFhirResearchStudyArmList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirResearchStudyArm;
    procedure SetItemN(index : Integer; value : TFhirResearchStudyArm);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirResearchStudyArmList; Overload;
    function Clone : TFhirResearchStudyArmList; Overload;
    function GetEnumerator : TFhirResearchStudyArmListEnumerator;
    

    //  Add a FhirResearchStudyArm to the end of the list.
    function Append : TFhirResearchStudyArm;

    
    // Add an already existing FhirResearchStudyArm to the end of the list.
    procedure AddItem(value : TFhirResearchStudyArm); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchStudyArm) : Integer;
    

    // Insert FhirResearchStudyArm before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchStudyArm;
    

    // Insert an existing FhirResearchStudyArm before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchStudyArm);
    
    // Get the iIndexth FhirResearchStudyArm. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchStudyArm);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchStudyArm;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirResearchStudyArms[index : Integer] : TFhirResearchStudyArm read GetItemN write SetItemN; default;
  End;

  // A goal that the study is aiming to achieve in terms of a scientific question to be answered by the analysis of data collected during the study.
  TFhirResearchStudyObjective = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FType_ : TFhirCodeableConcept;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetType_(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchStudyObjective; overload;
    function Clone : TFhirResearchStudyObjective; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Unique, human-readable label for this objective of the study.
    property name : String read GetNameST write SetNameST;
    // Unique, human-readable label for this objective of the study.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The kind of study objective. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of study objective.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

  end;

  TFhirResearchStudyObjectiveListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchStudyObjectiveList;
    function GetCurrent : TFhirResearchStudyObjective;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirResearchStudyObjectiveList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchStudyObjective read GetCurrent;
  end;

  TFhirResearchStudyObjectiveList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirResearchStudyObjective;
    procedure SetItemN(index : Integer; value : TFhirResearchStudyObjective);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirResearchStudyObjectiveList; Overload;
    function Clone : TFhirResearchStudyObjectiveList; Overload;
    function GetEnumerator : TFhirResearchStudyObjectiveListEnumerator;
    

    //  Add a FhirResearchStudyObjective to the end of the list.
    function Append : TFhirResearchStudyObjective;

    
    // Add an already existing FhirResearchStudyObjective to the end of the list.
    procedure AddItem(value : TFhirResearchStudyObjective); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchStudyObjective) : Integer;
    

    // Insert FhirResearchStudyObjective before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchStudyObjective;
    

    // Insert an existing FhirResearchStudyObjective before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchStudyObjective);
    
    // Get the iIndexth FhirResearchStudyObjective. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchStudyObjective);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchStudyObjective;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirResearchStudyObjectives[index : Integer] : TFhirResearchStudyObjective read GetItemN write SetItemN; default;
  End;

  // A process where a researcher or organization plans and then executes a series of steps intended to increase the field of healthcare-related knowledge.  This includes studies of safety, efficacy, comparative effectiveness and other information about medications, devices, therapies and other interventional and investigative techniques.  A ResearchStudy involves the gathering of information about human or animal subjects.
  TFhirResearchStudy = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FTitle : TFhirString;
    FprotocolList : TFhirReferenceList{TFhirPlanDefinition};
    FpartOfList : TFhirReferenceList{TFhirResearchStudy};
    FStatus : TFhirEnum;
    FPrimaryPurposeType : TFhirCodeableConcept;
    FPhase : TFhirCodeableConcept;
    FcategoryList : TFhirCodeableConceptList;
    FfocusList : TFhirCodeableConceptList;
    FconditionList : TFhirCodeableConceptList;
    FcontactList : TFhirContactDetailList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    FkeywordList : TFhirCodeableConceptList;
    FlocationList : TFhirCodeableConceptList;
    FDescription : TFhirMarkdown;
    FenrollmentList : TFhirReferenceList{TFhirGroup};
    FPeriod : TFhirPeriod;
    FSponsor : TFhirReference{TFhirOrganization};
    FPrincipalInvestigator : TFhirReference{TFhirPractitioner};
    FsiteList : TFhirReferenceList{TFhirLocation};
    FReasonStopped : TFhirCodeableConcept;
    FnoteList : TFhirAnnotationList;
    FarmList : TFhirResearchStudyArmList;
    FobjectiveList : TFhirResearchStudyObjectiveList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    function GetProtocolList : TFhirReferenceList{TFhirPlanDefinition};
    function GetHasProtocolList : Boolean;
    function GetPartOfList : TFhirReferenceList{TFhirResearchStudy};
    function GetHasPartOfList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirResearchStudyStatusEnum;
    Procedure SetStatusST(value : TFhirResearchStudyStatusEnum);
    Procedure SetPrimaryPurposeType(value : TFhirCodeableConcept);
    Procedure SetPhase(value : TFhirCodeableConcept);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    function GetFocusList : TFhirCodeableConceptList;
    function GetHasFocusList : Boolean;
    function GetConditionList : TFhirCodeableConceptList;
    function GetHasConditionList : Boolean;
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetKeywordList : TFhirCodeableConceptList;
    function GetHasKeywordList : Boolean;
    function GetLocationList : TFhirCodeableConceptList;
    function GetHasLocationList : Boolean;
    Procedure SetDescription(value : TFhirMarkdown);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetEnrollmentList : TFhirReferenceList{TFhirGroup};
    function GetHasEnrollmentList : Boolean;
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetSponsor(value : TFhirReference{TFhirOrganization});
    Procedure SetPrincipalInvestigator(value : TFhirReference{TFhirPractitioner});
    function GetSiteList : TFhirReferenceList{TFhirLocation};
    function GetHasSiteList : Boolean;
    Procedure SetReasonStopped(value : TFhirCodeableConcept);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetArmList : TFhirResearchStudyArmList;
    function GetHasArmList : Boolean;
    function GetObjectiveList : TFhirResearchStudyObjectiveList;
    function GetHasObjectiveList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchStudy; overload;
    function Clone : TFhirResearchStudy; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifiers assigned to this research study by the sponsor or other systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A short, descriptive user-friendly label for the study.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive user-friendly label for the study.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The set of steps expected to be performed as part of the execution of the study.
    property protocolList : TFhirReferenceList{TFhirPlanDefinition} read GetProtocolList;
    property hasProtocolList : boolean read GetHasProtocolList;

    // A larger research study of which this particular study is a component or step.
    property partOfList : TFhirReferenceList{TFhirResearchStudy} read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // The current state of the study.
    property status : TFhirResearchStudyStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The type of study based upon the intent of the study's activities. A classification of the intent of the study. (defined for API consistency)
    property primaryPurposeType : TFhirCodeableConcept read FPrimaryPurposeType write SetPrimaryPurposeType;
    // The type of study based upon the intent of the study's activities. A classification of the intent of the study.
    property primaryPurposeTypeElement : TFhirCodeableConcept read FPrimaryPurposeType write SetPrimaryPurposeType;

    // Typed access to The stage in the progression of a therapy from initial experimental use in humans in clinical trials to post-market evaluation. (defined for API consistency)
    property phase : TFhirCodeableConcept read FPhase write SetPhase;
    // The stage in the progression of a therapy from initial experimental use in humans in clinical trials to post-market evaluation.
    property phaseElement : TFhirCodeableConcept read FPhase write SetPhase;

    // Codes categorizing the type of study such as investigational vs. observational, type of blinding, type of randomization, safety vs. efficacy, etc.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // The medication(s), food(s), therapy(ies), device(s) or other concerns or interventions that the study is seeking to gain more information about.
    property focusList : TFhirCodeableConceptList read GetFocusList;
    property hasFocusList : boolean read GetHasFocusList;

    // The condition that is the focus of the study.  For example, In a study to examine risk factors for Lupus, might have as an inclusion criterion "healthy volunteer", but the target condition code would be a Lupus SNOMED code.
    property conditionList : TFhirCodeableConceptList read GetConditionList;
    property hasConditionList : boolean read GetHasConditionList;

    // Contact details to assist a user in learning more about or engaging with the study.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Citations, references and other related documents.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // Key terms to aid in searching for or filtering the study.
    property keywordList : TFhirCodeableConceptList read GetKeywordList;
    property hasKeywordList : boolean read GetHasKeywordList;

    // Indicates a country, state or other region where the study is taking place.
    property locationList : TFhirCodeableConceptList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // Typed access to A full description of how the study is being conducted.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A full description of how the study is being conducted.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Reference to a Group that defines the criteria for and quantity of subjects participating in the study.  E.g. " 200 female Europeans between the ages of 20 and 45 with early onset diabetes".
    property enrollmentList : TFhirReferenceList{TFhirGroup} read GetEnrollmentList;
    property hasEnrollmentList : boolean read GetHasEnrollmentList;

    // Typed access to Identifies the start date and the expected (or actual, depending on status) end date for the study. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Identifies the start date and the expected (or actual, depending on status) end date for the study.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to An organization that initiates the investigation and is legally responsible for the study. (defined for API consistency)
    property sponsor : TFhirReference{TFhirOrganization} read FSponsor write SetSponsor;
    // An organization that initiates the investigation and is legally responsible for the study.
    property sponsorElement : TFhirReference{TFhirOrganization} read FSponsor write SetSponsor;

    // Typed access to A researcher in a study who oversees multiple aspects of the study, such as concept development, protocol writing, protocol submission for IRB approval, participant recruitment, informed consent, data collection, analysis, interpretation and presentation. (defined for API consistency)
    property principalInvestigator : TFhirReference{TFhirPractitioner} read FPrincipalInvestigator write SetPrincipalInvestigator;
    // A researcher in a study who oversees multiple aspects of the study, such as concept development, protocol writing, protocol submission for IRB approval, participant recruitment, informed consent, data collection, analysis, interpretation and presentation.
    property principalInvestigatorElement : TFhirReference{TFhirPractitioner} read FPrincipalInvestigator write SetPrincipalInvestigator;

    // A facility in which study activities are conducted.
    property siteList : TFhirReferenceList{TFhirLocation} read GetSiteList;
    property hasSiteList : boolean read GetHasSiteList;

    // Typed access to A description and/or code explaining the premature termination of the study. (defined for API consistency)
    property reasonStopped : TFhirCodeableConcept read FReasonStopped write SetReasonStopped;
    // A description and/or code explaining the premature termination of the study.
    property reasonStoppedElement : TFhirCodeableConcept read FReasonStopped write SetReasonStopped;

    // Comments made about the study by the performer, subject or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Describes an expected sequence of events for one of the participants of a study.  E.g. Exposure to drug A, wash-out, exposure to drug B, wash-out, follow-up.
    property armList : TFhirResearchStudyArmList read GetArmList;
    property hasArmList : boolean read GetHasArmList;

    // A goal that the study is aiming to achieve in terms of a scientific question to be answered by the analysis of data collected during the study.
    property objectiveList : TFhirResearchStudyObjectiveList read GetObjectiveList;
    property hasObjectiveList : boolean read GetHasObjectiveList;

  end;

  TFhirResearchStudyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchStudyList;
    function GetCurrent : TFhirResearchStudy;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirResearchStudyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchStudy read GetCurrent;
  end;

  TFhirResearchStudyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirResearchStudy;
    procedure SetItemN(index : Integer; value : TFhirResearchStudy);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirResearchStudyList; Overload;
    function Clone : TFhirResearchStudyList; Overload;
    function GetEnumerator : TFhirResearchStudyListEnumerator;
    

    //  Add a FhirResearchStudy to the end of the list.
    function Append : TFhirResearchStudy;

    
    // Add an already existing FhirResearchStudy to the end of the list.
    procedure AddItem(value : TFhirResearchStudy); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchStudy) : Integer;
    

    // Insert FhirResearchStudy before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchStudy;
    

    // Insert an existing FhirResearchStudy before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchStudy);
    
    // Get the iIndexth FhirResearchStudy. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchStudy);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchStudy;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirResearchStudies[index : Integer] : TFhirResearchStudy read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RESEARCHSTUDY}

{$IFDEF FHIR_RESEARCHSUBJECT}

  // A physical entity which is the primary unit of operational and/or administrative interest in a study.
  TFhirResearchSubject = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FPeriod : TFhirPeriod;
    FStudy : TFhirReference{TFhirResearchStudy};
    FIndividual : TFhirReference{TFhirPatient};
    FAssignedArm : TFhirString;
    FActualArm : TFhirString;
    FConsent : TFhirReference{TFhirConsent};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirResearchSubjectStatusEnum;
    Procedure SetStatusST(value : TFhirResearchSubjectStatusEnum);
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetStudy(value : TFhirReference{TFhirResearchStudy});
    Procedure SetIndividual(value : TFhirReference{TFhirPatient});
    Procedure SetAssignedArm(value : TFhirString);
    Function GetAssignedArmST : String;
    Procedure SetAssignedArmST(value : String);
    Procedure SetActualArm(value : TFhirString);
    Function GetActualArmST : String;
    Procedure SetActualArmST(value : String);
    Procedure SetConsent(value : TFhirReference{TFhirConsent});
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchSubject; overload;
    function Clone : TFhirResearchSubject; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifiers assigned to this research subject for a study.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The current state of the subject.
    property status : TFhirResearchSubjectStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The dates the subject began and ended their participation in the study. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The dates the subject began and ended their participation in the study.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Reference to the study the subject is participating in. (defined for API consistency)
    property study : TFhirReference{TFhirResearchStudy} read FStudy write SetStudy;
    // Reference to the study the subject is participating in.
    property studyElement : TFhirReference{TFhirResearchStudy} read FStudy write SetStudy;

    // Typed access to The record of the person or animal who is involved in the study. (defined for API consistency)
    property individual : TFhirReference{TFhirPatient} read FIndividual write SetIndividual;
    // The record of the person or animal who is involved in the study.
    property individualElement : TFhirReference{TFhirPatient} read FIndividual write SetIndividual;

    // Typed access to The name of the arm in the study the subject is expected to follow as part of this study.
    property assignedArm : String read GetAssignedArmST write SetAssignedArmST;
    // The name of the arm in the study the subject is expected to follow as part of this study.
    property assignedArmElement : TFhirString read FAssignedArm write SetAssignedArm;

    // Typed access to The name of the arm in the study the subject actually followed as part of this study.
    property actualArm : String read GetActualArmST write SetActualArmST;
    // The name of the arm in the study the subject actually followed as part of this study.
    property actualArmElement : TFhirString read FActualArm write SetActualArm;

    // Typed access to A record of the patient's informed agreement to participate in the study. (defined for API consistency)
    property consent : TFhirReference{TFhirConsent} read FConsent write SetConsent;
    // A record of the patient's informed agreement to participate in the study.
    property consentElement : TFhirReference{TFhirConsent} read FConsent write SetConsent;

  end;

  TFhirResearchSubjectListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchSubjectList;
    function GetCurrent : TFhirResearchSubject;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirResearchSubjectList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchSubject read GetCurrent;
  end;

  TFhirResearchSubjectList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirResearchSubject;
    procedure SetItemN(index : Integer; value : TFhirResearchSubject);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirResearchSubjectList; Overload;
    function Clone : TFhirResearchSubjectList; Overload;
    function GetEnumerator : TFhirResearchSubjectListEnumerator;
    

    //  Add a FhirResearchSubject to the end of the list.
    function Append : TFhirResearchSubject;

    
    // Add an already existing FhirResearchSubject to the end of the list.
    procedure AddItem(value : TFhirResearchSubject); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchSubject) : Integer;
    

    // Insert FhirResearchSubject before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchSubject;
    

    // Insert an existing FhirResearchSubject before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchSubject);
    
    // Get the iIndexth FhirResearchSubject. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchSubject);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchSubject;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirResearchSubjects[index : Integer] : TFhirResearchSubject read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RESEARCHSUBJECT}

{$IFDEF FHIR_RISKEVIDENCESYNTHESIS}

  // A description of the size of the sample involved in the synthesis.
  TFhirRiskEvidenceSynthesisSampleSize = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FNumberOfStudies : TFhirInteger;
    FNumberOfParticipants : TFhirInteger;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetNumberOfStudies(value : TFhirInteger);
    Function GetNumberOfStudiesST : String;
    Procedure SetNumberOfStudiesST(value : String);
    Procedure SetNumberOfParticipants(value : TFhirInteger);
    Function GetNumberOfParticipantsST : String;
    Procedure SetNumberOfParticipantsST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRiskEvidenceSynthesisSampleSize; overload;
    function Clone : TFhirRiskEvidenceSynthesisSampleSize; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Human-readable summary of sample size.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human-readable summary of sample size.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Number of studies included in this evidence synthesis.
    property numberOfStudies : String read GetNumberOfStudiesST write SetNumberOfStudiesST;
    // Number of studies included in this evidence synthesis.
    property numberOfStudiesElement : TFhirInteger read FNumberOfStudies write SetNumberOfStudies;

    // Typed access to Number of participants included in this evidence synthesis.
    property numberOfParticipants : String read GetNumberOfParticipantsST write SetNumberOfParticipantsST;
    // Number of participants included in this evidence synthesis.
    property numberOfParticipantsElement : TFhirInteger read FNumberOfParticipants write SetNumberOfParticipants;

  end;

  TFhirRiskEvidenceSynthesisSampleSizeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRiskEvidenceSynthesisSampleSizeList;
    function GetCurrent : TFhirRiskEvidenceSynthesisSampleSize;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRiskEvidenceSynthesisSampleSizeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRiskEvidenceSynthesisSampleSize read GetCurrent;
  end;

  TFhirRiskEvidenceSynthesisSampleSizeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRiskEvidenceSynthesisSampleSize;
    procedure SetItemN(index : Integer; value : TFhirRiskEvidenceSynthesisSampleSize);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRiskEvidenceSynthesisSampleSizeList; Overload;
    function Clone : TFhirRiskEvidenceSynthesisSampleSizeList; Overload;
    function GetEnumerator : TFhirRiskEvidenceSynthesisSampleSizeListEnumerator;
    

    //  Add a FhirRiskEvidenceSynthesisSampleSize to the end of the list.
    function Append : TFhirRiskEvidenceSynthesisSampleSize;

    
    // Add an already existing FhirRiskEvidenceSynthesisSampleSize to the end of the list.
    procedure AddItem(value : TFhirRiskEvidenceSynthesisSampleSize); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRiskEvidenceSynthesisSampleSize) : Integer;
    

    // Insert FhirRiskEvidenceSynthesisSampleSize before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRiskEvidenceSynthesisSampleSize;
    

    // Insert an existing FhirRiskEvidenceSynthesisSampleSize before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRiskEvidenceSynthesisSampleSize);
    
    // Get the iIndexth FhirRiskEvidenceSynthesisSampleSize. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRiskEvidenceSynthesisSampleSize);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRiskEvidenceSynthesisSampleSize;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirRiskEvidenceSynthesisSampleSizes[index : Integer] : TFhirRiskEvidenceSynthesisSampleSize read GetItemN write SetItemN; default;
  End;

  // The estimated risk of the outcome.
  TFhirRiskEvidenceSynthesisRiskEstimate = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDecimal;
    FUnitOfMeasure : TFhirCodeableConcept;
    FDenominatorCount : TFhirInteger;
    FNumeratorCount : TFhirInteger;
    FprecisionEstimateList : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirDecimal);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
    Procedure SetUnitOfMeasure(value : TFhirCodeableConcept);
    Procedure SetDenominatorCount(value : TFhirInteger);
    Function GetDenominatorCountST : String;
    Procedure SetDenominatorCountST(value : String);
    Procedure SetNumeratorCount(value : TFhirInteger);
    Function GetNumeratorCountST : String;
    Procedure SetNumeratorCountST(value : String);
    function GetPrecisionEstimateList : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList;
    function GetHasPrecisionEstimateList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRiskEvidenceSynthesisRiskEstimate; overload;
    function Clone : TFhirRiskEvidenceSynthesisRiskEstimate; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Human-readable summary of risk estimate.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human-readable summary of risk estimate.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Examples include proportion and mean. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Examples include proportion and mean.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The point estimate of the risk estimate.
    property value : String read GetValueST write SetValueST;
    // The point estimate of the risk estimate.
    property valueElement : TFhirDecimal read FValue write SetValue;

    // Typed access to Specifies the UCUM unit for the outcome. (defined for API consistency)
    property unitOfMeasure : TFhirCodeableConcept read FUnitOfMeasure write SetUnitOfMeasure;
    // Specifies the UCUM unit for the outcome.
    property unitOfMeasureElement : TFhirCodeableConcept read FUnitOfMeasure write SetUnitOfMeasure;

    // Typed access to The sample size for the group that was measured for this risk estimate.
    property denominatorCount : String read GetDenominatorCountST write SetDenominatorCountST;
    // The sample size for the group that was measured for this risk estimate.
    property denominatorCountElement : TFhirInteger read FDenominatorCount write SetDenominatorCount;

    // Typed access to The number of group members with the outcome of interest.
    property numeratorCount : String read GetNumeratorCountST write SetNumeratorCountST;
    // The number of group members with the outcome of interest.
    property numeratorCountElement : TFhirInteger read FNumeratorCount write SetNumeratorCount;

    // A description of the precision of the estimate for the effect.
    property precisionEstimateList : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList read GetPrecisionEstimateList;
    property hasPrecisionEstimateList : boolean read GetHasPrecisionEstimateList;

  end;

  TFhirRiskEvidenceSynthesisRiskEstimateListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRiskEvidenceSynthesisRiskEstimateList;
    function GetCurrent : TFhirRiskEvidenceSynthesisRiskEstimate;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRiskEvidenceSynthesisRiskEstimateList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRiskEvidenceSynthesisRiskEstimate read GetCurrent;
  end;

  TFhirRiskEvidenceSynthesisRiskEstimateList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRiskEvidenceSynthesisRiskEstimate;
    procedure SetItemN(index : Integer; value : TFhirRiskEvidenceSynthesisRiskEstimate);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRiskEvidenceSynthesisRiskEstimateList; Overload;
    function Clone : TFhirRiskEvidenceSynthesisRiskEstimateList; Overload;
    function GetEnumerator : TFhirRiskEvidenceSynthesisRiskEstimateListEnumerator;
    

    //  Add a FhirRiskEvidenceSynthesisRiskEstimate to the end of the list.
    function Append : TFhirRiskEvidenceSynthesisRiskEstimate;

    
    // Add an already existing FhirRiskEvidenceSynthesisRiskEstimate to the end of the list.
    procedure AddItem(value : TFhirRiskEvidenceSynthesisRiskEstimate); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRiskEvidenceSynthesisRiskEstimate) : Integer;
    

    // Insert FhirRiskEvidenceSynthesisRiskEstimate before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRiskEvidenceSynthesisRiskEstimate;
    

    // Insert an existing FhirRiskEvidenceSynthesisRiskEstimate before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRiskEvidenceSynthesisRiskEstimate);
    
    // Get the iIndexth FhirRiskEvidenceSynthesisRiskEstimate. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRiskEvidenceSynthesisRiskEstimate);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRiskEvidenceSynthesisRiskEstimate;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirRiskEvidenceSynthesisRiskEstimates[index : Integer] : TFhirRiskEvidenceSynthesisRiskEstimate read GetItemN write SetItemN; default;
  End;

  // A description of the precision of the estimate for the effect.
  TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FLevel : TFhirDecimal;
    FFrom : TFhirDecimal;
    FTo_ : TFhirDecimal;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetLevel(value : TFhirDecimal);
    Function GetLevelST : String;
    Procedure SetLevelST(value : String);
    Procedure SetFrom(value : TFhirDecimal);
    Function GetFromST : String;
    Procedure SetFromST(value : String);
    Procedure SetTo_(value : TFhirDecimal);
    Function GetTo_ST : String;
    Procedure SetTo_ST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate; overload;
    function Clone : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Examples include confidence interval and interquartile range. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Examples include confidence interval and interquartile range.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Use 95 for a 95% confidence interval.
    property level : String read GetLevelST write SetLevelST;
    // Use 95 for a 95% confidence interval.
    property levelElement : TFhirDecimal read FLevel write SetLevel;

    // Typed access to Lower bound of confidence interval.
    property from : String read GetFromST write SetFromST;
    // Lower bound of confidence interval.
    property fromElement : TFhirDecimal read FFrom write SetFrom;

    // Typed access to Upper bound of confidence interval.
    property to_ : String read GetTo_ST write SetTo_ST;
    // Upper bound of confidence interval.
    property to_Element : TFhirDecimal read FTo_ write SetTo_;

  end;

  TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList;
    function GetCurrent : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate read GetCurrent;
  end;

  TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate;
    procedure SetItemN(index : Integer; value : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList; Overload;
    function Clone : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList; Overload;
    function GetEnumerator : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateListEnumerator;
    

    //  Add a FhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate to the end of the list.
    function Append : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate;

    
    // Add an already existing FhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate to the end of the list.
    procedure AddItem(value : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate) : Integer;
    

    // Insert FhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate;
    

    // Insert an existing FhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate);
    
    // Get the iIndexth FhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimates[index : Integer] : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate read GetItemN write SetItemN; default;
  End;

  // A description of the certainty of the risk estimate.
  TFhirRiskEvidenceSynthesisCertainty = class (TFhirBackboneElement)
  protected
    FratingList : TFhirCodeableConceptList;
    FnoteList : TFhirAnnotationList;
    FcertaintySubcomponentList : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList;
    function GetRatingList : TFhirCodeableConceptList;
    function GetHasRatingList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetCertaintySubcomponentList : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList;
    function GetHasCertaintySubcomponentList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRiskEvidenceSynthesisCertainty; overload;
    function Clone : TFhirRiskEvidenceSynthesisCertainty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A rating of the certainty of the effect estimate.
    property ratingList : TFhirCodeableConceptList read GetRatingList;
    property hasRatingList : boolean read GetHasRatingList;

    // A human-readable string to clarify or explain concepts about the resource.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // A description of a component of the overall certainty.
    property certaintySubcomponentList : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList read GetCertaintySubcomponentList;
    property hasCertaintySubcomponentList : boolean read GetHasCertaintySubcomponentList;

  end;

  TFhirRiskEvidenceSynthesisCertaintyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRiskEvidenceSynthesisCertaintyList;
    function GetCurrent : TFhirRiskEvidenceSynthesisCertainty;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRiskEvidenceSynthesisCertaintyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRiskEvidenceSynthesisCertainty read GetCurrent;
  end;

  TFhirRiskEvidenceSynthesisCertaintyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRiskEvidenceSynthesisCertainty;
    procedure SetItemN(index : Integer; value : TFhirRiskEvidenceSynthesisCertainty);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRiskEvidenceSynthesisCertaintyList; Overload;
    function Clone : TFhirRiskEvidenceSynthesisCertaintyList; Overload;
    function GetEnumerator : TFhirRiskEvidenceSynthesisCertaintyListEnumerator;
    

    //  Add a FhirRiskEvidenceSynthesisCertainty to the end of the list.
    function Append : TFhirRiskEvidenceSynthesisCertainty;

    
    // Add an already existing FhirRiskEvidenceSynthesisCertainty to the end of the list.
    procedure AddItem(value : TFhirRiskEvidenceSynthesisCertainty); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRiskEvidenceSynthesisCertainty) : Integer;
    

    // Insert FhirRiskEvidenceSynthesisCertainty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRiskEvidenceSynthesisCertainty;
    

    // Insert an existing FhirRiskEvidenceSynthesisCertainty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRiskEvidenceSynthesisCertainty);
    
    // Get the iIndexth FhirRiskEvidenceSynthesisCertainty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRiskEvidenceSynthesisCertainty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRiskEvidenceSynthesisCertainty;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirRiskEvidenceSynthesisCertainties[index : Integer] : TFhirRiskEvidenceSynthesisCertainty read GetItemN write SetItemN; default;
  End;

  // A description of a component of the overall certainty.
  TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FratingList : TFhirCodeableConceptList;
    FnoteList : TFhirAnnotationList;
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetRatingList : TFhirCodeableConceptList;
    function GetHasRatingList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent; overload;
    function Clone : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Type of subcomponent of certainty rating. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of subcomponent of certainty rating.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // A rating of a subcomponent of rating certainty.
    property ratingList : TFhirCodeableConceptList read GetRatingList;
    property hasRatingList : boolean read GetHasRatingList;

    // A human-readable string to clarify or explain concepts about the resource.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList;
    function GetCurrent : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent read GetCurrent;
  end;

  TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent;
    procedure SetItemN(index : Integer; value : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList; Overload;
    function Clone : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList; Overload;
    function GetEnumerator : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentListEnumerator;
    

    //  Add a FhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent to the end of the list.
    function Append : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent;

    
    // Add an already existing FhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent to the end of the list.
    procedure AddItem(value : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent) : Integer;
    

    // Insert FhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent;
    

    // Insert an existing FhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent);
    
    // Get the iIndexth FhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirRiskEvidenceSynthesisCertaintyCertaintySubcomponents[index : Integer] : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent read GetItemN write SetItemN; default;
  End;

  // The RiskEvidenceSynthesis resource describes the likelihood of an outcome in a population plus exposure state where the risk estimate is derived from a combination of research studies.
  TFhirRiskEvidenceSynthesis = class (TFhirMetadataResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FnoteList : TFhirAnnotationList;
    FCopyright : TFhirMarkdown;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FtopicList : TFhirCodeableConceptList;
    FauthorList : TFhirContactDetailList;
    FeditorList : TFhirContactDetailList;
    FreviewerList : TFhirContactDetailList;
    FendorserList : TFhirContactDetailList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    FSynthesisType : TFhirCodeableConcept;
    FStudyType : TFhirCodeableConcept;
    FPopulation : TFhirReference{TFhirEvidenceVariable};
    FExposure : TFhirReference{TFhirEvidenceVariable};
    FOutcome : TFhirReference{TFhirEvidenceVariable};
    FSampleSize : TFhirRiskEvidenceSynthesisSampleSize;
    FRiskEstimate : TFhirRiskEvidenceSynthesisRiskEstimate;
    FcertaintyList : TFhirRiskEvidenceSynthesisCertaintyList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    Procedure SetApprovalDate(value : TFhirDate);
    Function GetApprovalDateST : TFslDateTime;
    Procedure SetApprovalDateST(value : TFslDateTime);
    Procedure SetLastReviewDate(value : TFhirDate);
    Function GetLastReviewDateST : TFslDateTime;
    Procedure SetLastReviewDateST(value : TFslDateTime);
    Procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetTopicList : TFhirCodeableConceptList;
    function GetHasTopicList : Boolean;
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    Procedure SetSynthesisType(value : TFhirCodeableConcept);
    Procedure SetStudyType(value : TFhirCodeableConcept);
    Procedure SetPopulation(value : TFhirReference{TFhirEvidenceVariable});
    Procedure SetExposure(value : TFhirReference{TFhirEvidenceVariable});
    Procedure SetOutcome(value : TFhirReference{TFhirEvidenceVariable});
    Procedure SetSampleSize(value : TFhirRiskEvidenceSynthesisSampleSize);
    Procedure SetRiskEstimate(value : TFhirRiskEvidenceSynthesisRiskEstimate);
    function GetCertaintyList : TFhirRiskEvidenceSynthesisCertaintyList;
    function GetHasCertaintyList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRiskEvidenceSynthesis; overload;
    function Clone : TFhirRiskEvidenceSynthesis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this risk evidence synthesis when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this risk evidence synthesis is (or will be) {$IFNDEF FPC}Published{$ENDIF}. This URL can be the target of a canonical reference. It SHALL remain the same when the risk evidence synthesis is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this risk evidence synthesis when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this risk evidence synthesis is (or will be) {$IFNDEF FPC}Published{$ENDIF}. This URL can be the target of a canonical reference. It SHALL remain the same when the risk evidence synthesis is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this risk evidence synthesis when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the risk evidence synthesis when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the risk evidence synthesis author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the risk evidence synthesis when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the risk evidence synthesis author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the risk evidence synthesis. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the risk evidence synthesis. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the risk evidence synthesis.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the risk evidence synthesis.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this risk evidence synthesis. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The date  (and optionally time) when the risk evidence synthesis was {$IFNDEF FPC}Published{$ENDIF}. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the risk evidence synthesis changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the risk evidence synthesis was {$IFNDEF FPC}Published{$ENDIF}. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the risk evidence synthesis changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that {$IFNDEF FPC}Published{$ENDIF} the risk evidence synthesis.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that {$IFNDEF FPC}Published{$ENDIF} the risk evidence synthesis.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the risk evidence synthesis from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the risk evidence synthesis from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // A human-readable string to clarify or explain concepts about the resource.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate risk evidence synthesis instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the risk evidence synthesis is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to A copyright statement relating to the risk evidence synthesis and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the risk evidence synthesis.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the risk evidence synthesis and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the risk evidence synthesis.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the risk evidence synthesis content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the risk evidence synthesis content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // Descriptive topics related to the content of the RiskEvidenceSynthesis. Topics provide a high-level categorization grouping types of EffectEvidenceSynthesiss that can be useful for filtering and searching.
    property topicList : TFhirCodeableConceptList read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // An individiual or organization primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individual or organization primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individual or organization primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individual or organization responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Related artifacts such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // Typed access to Type of synthesis eg meta-analysis. (defined for API consistency)
    property synthesisType : TFhirCodeableConcept read FSynthesisType write SetSynthesisType;
    // Type of synthesis eg meta-analysis.
    property synthesisTypeElement : TFhirCodeableConcept read FSynthesisType write SetSynthesisType;

    // Typed access to Type of study eg randomized trial. (defined for API consistency)
    property studyType : TFhirCodeableConcept read FStudyType write SetStudyType;
    // Type of study eg randomized trial.
    property studyTypeElement : TFhirCodeableConcept read FStudyType write SetStudyType;

    // Typed access to A reference to a EvidenceVariable resource that defines the population for the research. (defined for API consistency)
    property population : TFhirReference{TFhirEvidenceVariable} read FPopulation write SetPopulation;
    // A reference to a EvidenceVariable resource that defines the population for the research.
    property populationElement : TFhirReference{TFhirEvidenceVariable} read FPopulation write SetPopulation;

    // Typed access to A reference to a EvidenceVariable resource that defines the exposure for the research. (defined for API consistency)
    property exposure : TFhirReference{TFhirEvidenceVariable} read FExposure write SetExposure;
    // A reference to a EvidenceVariable resource that defines the exposure for the research.
    property exposureElement : TFhirReference{TFhirEvidenceVariable} read FExposure write SetExposure;

    // Typed access to A reference to a EvidenceVariable resomece that defines the outcome for the research. (defined for API consistency)
    property outcome : TFhirReference{TFhirEvidenceVariable} read FOutcome write SetOutcome;
    // A reference to a EvidenceVariable resomece that defines the outcome for the research.
    property outcomeElement : TFhirReference{TFhirEvidenceVariable} read FOutcome write SetOutcome;

    // Typed access to A description of the size of the sample involved in the synthesis. (defined for API consistency)
    property sampleSize : TFhirRiskEvidenceSynthesisSampleSize read FSampleSize write SetSampleSize;
    // A description of the size of the sample involved in the synthesis.
    property sampleSizeElement : TFhirRiskEvidenceSynthesisSampleSize read FSampleSize write SetSampleSize;

    // Typed access to The estimated risk of the outcome. (defined for API consistency)
    property riskEstimate : TFhirRiskEvidenceSynthesisRiskEstimate read FRiskEstimate write SetRiskEstimate;
    // The estimated risk of the outcome.
    property riskEstimateElement : TFhirRiskEvidenceSynthesisRiskEstimate read FRiskEstimate write SetRiskEstimate;

    // A description of the certainty of the risk estimate.
    property certaintyList : TFhirRiskEvidenceSynthesisCertaintyList read GetCertaintyList;
    property hasCertaintyList : boolean read GetHasCertaintyList;

  end;

  TFhirRiskEvidenceSynthesisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRiskEvidenceSynthesisList;
    function GetCurrent : TFhirRiskEvidenceSynthesis;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRiskEvidenceSynthesisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRiskEvidenceSynthesis read GetCurrent;
  end;

  TFhirRiskEvidenceSynthesisList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRiskEvidenceSynthesis;
    procedure SetItemN(index : Integer; value : TFhirRiskEvidenceSynthesis);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRiskEvidenceSynthesisList; Overload;
    function Clone : TFhirRiskEvidenceSynthesisList; Overload;
    function GetEnumerator : TFhirRiskEvidenceSynthesisListEnumerator;
    

    //  Add a FhirRiskEvidenceSynthesis to the end of the list.
    function Append : TFhirRiskEvidenceSynthesis;

    
    // Add an already existing FhirRiskEvidenceSynthesis to the end of the list.
    procedure AddItem(value : TFhirRiskEvidenceSynthesis); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRiskEvidenceSynthesis) : Integer;
    

    // Insert FhirRiskEvidenceSynthesis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRiskEvidenceSynthesis;
    

    // Insert an existing FhirRiskEvidenceSynthesis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRiskEvidenceSynthesis);
    
    // Get the iIndexth FhirRiskEvidenceSynthesis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRiskEvidenceSynthesis);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRiskEvidenceSynthesis;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirRiskEvidenceSyntheses[index : Integer] : TFhirRiskEvidenceSynthesis read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RISKEVIDENCESYNTHESIS}

{$IFDEF FHIR_SUBSCRIPTION}

  // Details where to send notifications when resources are received that meet the criteria.
  TFhirSubscriptionChannel = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FEndpoint : TFhirUrl;
    FPayload : TFhirCode;
    FheaderList : TFhirStringList;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirSubscriptionChannelTypeEnum;
    Procedure SetType_ST(value : TFhirSubscriptionChannelTypeEnum);
    Procedure SetEndpoint(value : TFhirUrl);
    Function GetEndpointST : String;
    Procedure SetEndpointST(value : String);
    Procedure SetPayload(value : TFhirCode);
    Function GetPayloadST : String;
    Procedure SetPayloadST(value : String);
    function GetHeaderList : TFhirStringList;
    function GetHasHeaderList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionChannel; overload;
    function Clone : TFhirSubscriptionChannel; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The type of channel to send notifications on.
    property type_ : TFhirSubscriptionChannelTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The url that describes the actual end-point to send messages to.
    property endpoint : String read GetEndpointST write SetEndpointST;
    // The url that describes the actual end-point to send messages to.
    property endpointElement : TFhirUrl read FEndpoint write SetEndpoint;

    // Typed access to The mime type to send the payload in - either application/fhir+xml, or application/fhir+json. If the payload is not present, then there is no payload in the notification, just a notification. The mime type "text/plain" may also be used for Email and SMS subscriptions.
    property payload : String read GetPayloadST write SetPayloadST;
    // The mime type to send the payload in - either application/fhir+xml, or application/fhir+json. If the payload is not present, then there is no payload in the notification, just a notification. The mime type "text/plain" may also be used for Email and SMS subscriptions.
    property payloadElement : TFhirCode read FPayload write SetPayload;

    // Additional headers / information to send as part of the notification.
    property headerList : TFhirStringList read GetHeaderList;
    property hasHeaderList : boolean read GetHasHeaderList;

  end;

  TFhirSubscriptionChannelListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionChannelList;
    function GetCurrent : TFhirSubscriptionChannel;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionChannelList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionChannel read GetCurrent;
  end;

  TFhirSubscriptionChannelList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubscriptionChannel;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionChannel);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubscriptionChannelList; Overload;
    function Clone : TFhirSubscriptionChannelList; Overload;
    function GetEnumerator : TFhirSubscriptionChannelListEnumerator;
    

    //  Add a FhirSubscriptionChannel to the end of the list.
    function Append : TFhirSubscriptionChannel;

    
    // Add an already existing FhirSubscriptionChannel to the end of the list.
    procedure AddItem(value : TFhirSubscriptionChannel); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionChannel) : Integer;
    

    // Insert FhirSubscriptionChannel before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionChannel;
    

    // Insert an existing FhirSubscriptionChannel before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionChannel);
    
    // Get the iIndexth FhirSubscriptionChannel. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionChannel);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionChannel;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubscriptionChannels[index : Integer] : TFhirSubscriptionChannel read GetItemN write SetItemN; default;
  End;

  // The subscription resource is used to define a push-based subscription from a server to another system. Once a subscription is registered with the server, the server checks every resource that is created or updated, and if the resource matches the given criteria, it sends a message on the defined "channel" so that another system can take an appropriate action.
  TFhirSubscription = class (TFhirDomainResource)
  protected
    FStatus : TFhirEnum;
    FcontactList : TFhirContactPointList;
    FEnd_ : TFhirInstant;
    FReason : TFhirString;
    FCriteria : TFhirString;
    FError : TFhirString;
    FChannel : TFhirSubscriptionChannel;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirSubscriptionStatusEnum;
    Procedure SetStatusST(value : TFhirSubscriptionStatusEnum);
    function GetContactList : TFhirContactPointList;
    function GetHasContactList : Boolean;
    Procedure SetEnd_(value : TFhirInstant);
    Function GetEnd_ST : TFslDateTime;
    Procedure SetEnd_ST(value : TFslDateTime);
    Procedure SetReason(value : TFhirString);
    Function GetReasonST : String;
    Procedure SetReasonST(value : String);
    Procedure SetCriteria(value : TFhirString);
    Function GetCriteriaST : String;
    Procedure SetCriteriaST(value : String);
    Procedure SetError(value : TFhirString);
    Function GetErrorST : String;
    Procedure SetErrorST(value : String);
    Procedure SetChannel(value : TFhirSubscriptionChannel);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscription; overload;
    function Clone : TFhirSubscription; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The status of the subscription, which marks the server state for managing the subscription.
    property status : TFhirSubscriptionStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Contact details for a human to contact about the subscription. The primary use of this for system administrator troubleshooting.
    property contactList : TFhirContactPointList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The time for the server to turn the subscription off.
    property end_ : TFslDateTime read GetEnd_ST write SetEnd_ST;
    // The time for the server to turn the subscription off.
    property end_Element : TFhirInstant read FEnd_ write SetEnd_;

    // Typed access to A description of why this subscription is defined.
    property reason : String read GetReasonST write SetReasonST;
    // A description of why this subscription is defined.
    property reasonElement : TFhirString read FReason write SetReason;

    // Typed access to The rules that the server should use to determine when to generate notifications for this subscription.
    property criteria : String read GetCriteriaST write SetCriteriaST;
    // The rules that the server should use to determine when to generate notifications for this subscription.
    property criteriaElement : TFhirString read FCriteria write SetCriteria;

    // Typed access to A record of the last error that occurred when the server processed a notification.
    property error : String read GetErrorST write SetErrorST;
    // A record of the last error that occurred when the server processed a notification.
    property errorElement : TFhirString read FError write SetError;

    // Typed access to Details where to send notifications when resources are received that meet the criteria. (defined for API consistency)
    property channel : TFhirSubscriptionChannel read FChannel write SetChannel;
    // Details where to send notifications when resources are received that meet the criteria.
    property channelElement : TFhirSubscriptionChannel read FChannel write SetChannel;

  end;

  TFhirSubscriptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionList;
    function GetCurrent : TFhirSubscription;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscription read GetCurrent;
  end;

  TFhirSubscriptionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubscription;
    procedure SetItemN(index : Integer; value : TFhirSubscription);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubscriptionList; Overload;
    function Clone : TFhirSubscriptionList; Overload;
    function GetEnumerator : TFhirSubscriptionListEnumerator;
    

    //  Add a FhirSubscription to the end of the list.
    function Append : TFhirSubscription;

    
    // Add an already existing FhirSubscription to the end of the list.
    procedure AddItem(value : TFhirSubscription); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscription) : Integer;
    

    // Insert FhirSubscription before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscription;
    

    // Insert an existing FhirSubscription before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscription);
    
    // Get the iIndexth FhirSubscription. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscription);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscription;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubscriptions[index : Integer] : TFhirSubscription read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSCRIPTION}

{$IFDEF FHIR_TASK}

  // If the Task.focus is a request resource and the task is seeking fulfillment (i.e. is asking for the request to be actioned), this element identifies any limitations on what parts of the referenced request should be actioned.
  TFhirTaskRestriction = class (TFhirBackboneElement)
  protected
    FRepetitions : TFhirPositiveInt;
    FPeriod : TFhirPeriod;
    FrecipientList : TFhirReferenceList{TFhirPatient};
    Procedure SetRepetitions(value : TFhirPositiveInt);
    Function GetRepetitionsST : String;
    Procedure SetRepetitionsST(value : String);
    Procedure SetPeriod(value : TFhirPeriod);
    function GetRecipientList : TFhirReferenceList{TFhirPatient};
    function GetHasRecipientList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTaskRestriction; overload;
    function Clone : TFhirTaskRestriction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Indicates the number of times the requested action should occur.
    property repetitions : String read GetRepetitionsST write SetRepetitionsST;
    // Indicates the number of times the requested action should occur.
    property repetitionsElement : TFhirPositiveInt read FRepetitions write SetRepetitions;

    // Typed access to Over what time-period is fulfillment sought. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Over what time-period is fulfillment sought.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // For requests that are targeted to more than on potential recipient/target, for whom is fulfillment sought?
    property recipientList : TFhirReferenceList{TFhirPatient} read GetRecipientList;
    property hasRecipientList : boolean read GetHasRecipientList;

  end;

  TFhirTaskRestrictionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTaskRestrictionList;
    function GetCurrent : TFhirTaskRestriction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTaskRestrictionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTaskRestriction read GetCurrent;
  end;

  TFhirTaskRestrictionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTaskRestriction;
    procedure SetItemN(index : Integer; value : TFhirTaskRestriction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTaskRestrictionList; Overload;
    function Clone : TFhirTaskRestrictionList; Overload;
    function GetEnumerator : TFhirTaskRestrictionListEnumerator;
    

    //  Add a FhirTaskRestriction to the end of the list.
    function Append : TFhirTaskRestriction;

    
    // Add an already existing FhirTaskRestriction to the end of the list.
    procedure AddItem(value : TFhirTaskRestriction); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTaskRestriction) : Integer;
    

    // Insert FhirTaskRestriction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTaskRestriction;
    

    // Insert an existing FhirTaskRestriction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTaskRestriction);
    
    // Get the iIndexth FhirTaskRestriction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTaskRestriction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTaskRestriction;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTaskRestrictions[index : Integer] : TFhirTaskRestriction read GetItemN write SetItemN; default;
  End;

  // Additional information that may be needed in the execution of the task.
  TFhirTaskInput = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirType;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTaskInput; overload;
    function Clone : TFhirTaskInput; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A code or description indicating how the input is intended to be used as part of the task execution. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code or description indicating how the input is intended to be used as part of the task execution.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The value of the input parameter as a basic type. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // The value of the input parameter as a basic type.
    property valueElement : TFhirType read FValue write SetValue;

  end;

  TFhirTaskInputListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTaskInputList;
    function GetCurrent : TFhirTaskInput;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTaskInputList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTaskInput read GetCurrent;
  end;

  TFhirTaskInputList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTaskInput;
    procedure SetItemN(index : Integer; value : TFhirTaskInput);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTaskInputList; Overload;
    function Clone : TFhirTaskInputList; Overload;
    function GetEnumerator : TFhirTaskInputListEnumerator;
    

    //  Add a FhirTaskInput to the end of the list.
    function Append : TFhirTaskInput;

    
    // Add an already existing FhirTaskInput to the end of the list.
    procedure AddItem(value : TFhirTaskInput); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTaskInput) : Integer;
    

    // Insert FhirTaskInput before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTaskInput;
    

    // Insert an existing FhirTaskInput before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTaskInput);
    
    // Get the iIndexth FhirTaskInput. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTaskInput);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTaskInput;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTaskInputs[index : Integer] : TFhirTaskInput read GetItemN write SetItemN; default;
  End;

  // Outputs produced by the Task.
  TFhirTaskOutput = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirType;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTaskOutput; overload;
    function Clone : TFhirTaskOutput; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The name of the Output parameter. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The name of the Output parameter.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The value of the Output parameter as a basic type. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // The value of the Output parameter as a basic type.
    property valueElement : TFhirType read FValue write SetValue;

  end;

  TFhirTaskOutputListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTaskOutputList;
    function GetCurrent : TFhirTaskOutput;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTaskOutputList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTaskOutput read GetCurrent;
  end;

  TFhirTaskOutputList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTaskOutput;
    procedure SetItemN(index : Integer; value : TFhirTaskOutput);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTaskOutputList; Overload;
    function Clone : TFhirTaskOutputList; Overload;
    function GetEnumerator : TFhirTaskOutputListEnumerator;
    

    //  Add a FhirTaskOutput to the end of the list.
    function Append : TFhirTaskOutput;

    
    // Add an already existing FhirTaskOutput to the end of the list.
    procedure AddItem(value : TFhirTaskOutput); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTaskOutput) : Integer;
    

    // Insert FhirTaskOutput before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTaskOutput;
    

    // Insert an existing FhirTaskOutput before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTaskOutput);
    
    // Get the iIndexth FhirTaskOutput. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTaskOutput);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTaskOutput;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTaskOutputs[index : Integer] : TFhirTaskOutput read GetItemN write SetItemN; default;
  End;

  // A task to be performed.
  TFhirTask = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FInstantiatesCanonical : TFhirCanonical;
    FInstantiatesUri : TFhirUri;
    FbasedOnList : TFhirReferenceList{TFhirReference};
    FGroupIdentifier : TFhirIdentifier;
    FpartOfList : TFhirReferenceList{TFhirTask};
    FStatus : TFhirEnum;
    FStatusReason : TFhirCodeableConcept;
    FBusinessStatus : TFhirCodeableConcept;
    FIntent : TFhirEnum;
    FPriority : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FDescription : TFhirString;
    FFocus : TFhirReference{TFhirReference};
    FFor_ : TFhirReference{TFhirReference};
    FEncounter : TFhirReference{TFhirEncounter};
    FExecutionPeriod : TFhirPeriod;
    FAuthoredOn : TFhirDateTime;
    FLastModified : TFhirDateTime;
    FRequester : TFhirReference{TFhirDevice};
    FperformerTypeList : TFhirCodeableConceptList;
    FOwner : TFhirReference{TFhirPractitioner};
    FLocation : TFhirReference{TFhirLocation};
    FReasonCode : TFhirCodeableConcept;
    FReasonReference : TFhirReference{TFhirReference};
    FinsuranceList : TFhirReferenceList{TFhirCoverage};
    FnoteList : TFhirAnnotationList;
    FrelevantHistoryList : TFhirReferenceList{TFhirProvenance};
    FRestriction : TFhirTaskRestriction;
    FinputList : TFhirTaskInputList;
    FoutputList : TFhirTaskOutputList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetInstantiatesCanonical(value : TFhirCanonical);
    Function GetInstantiatesCanonicalST : String;
    Procedure SetInstantiatesCanonicalST(value : String);
    Procedure SetInstantiatesUri(value : TFhirUri);
    Function GetInstantiatesUriST : String;
    Procedure SetInstantiatesUriST(value : String);
    function GetBasedOnList : TFhirReferenceList{TFhirReference};
    function GetHasBasedOnList : Boolean;
    Procedure SetGroupIdentifier(value : TFhirIdentifier);
    function GetPartOfList : TFhirReferenceList{TFhirTask};
    function GetHasPartOfList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirTaskStatusEnum;
    Procedure SetStatusST(value : TFhirTaskStatusEnum);
    Procedure SetStatusReason(value : TFhirCodeableConcept);
    Procedure SetBusinessStatus(value : TFhirCodeableConcept);
    Procedure SetIntent(value : TFhirEnum);
    Function GetIntentST : TFhirTaskIntentEnum;
    Procedure SetIntentST(value : TFhirTaskIntentEnum);
    Procedure SetPriority(value : TFhirEnum);
    Function GetPriorityST : TFhirRequestPriorityEnum;
    Procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetFocus(value : TFhirReference{TFhirReference});
    Procedure SetFor_(value : TFhirReference{TFhirReference});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetExecutionPeriod(value : TFhirPeriod);
    Procedure SetAuthoredOn(value : TFhirDateTime);
    Function GetAuthoredOnST : TFslDateTime;
    Procedure SetAuthoredOnST(value : TFslDateTime);
    Procedure SetLastModified(value : TFhirDateTime);
    Function GetLastModifiedST : TFslDateTime;
    Procedure SetLastModifiedST(value : TFslDateTime);
    Procedure SetRequester(value : TFhirReference{TFhirDevice});
    function GetPerformerTypeList : TFhirCodeableConceptList;
    function GetHasPerformerTypeList : Boolean;
    Procedure SetOwner(value : TFhirReference{TFhirPractitioner});
    Procedure SetLocation(value : TFhirReference{TFhirLocation});
    Procedure SetReasonCode(value : TFhirCodeableConcept);
    Procedure SetReasonReference(value : TFhirReference{TFhirReference});
    function GetInsuranceList : TFhirReferenceList{TFhirCoverage};
    function GetHasInsuranceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetRelevantHistoryList : TFhirReferenceList{TFhirProvenance};
    function GetHasRelevantHistoryList : Boolean;
    Procedure SetRestriction(value : TFhirTaskRestriction);
    function GetInputList : TFhirTaskInputList;
    function GetHasInputList : Boolean;
    function GetOutputList : TFhirTaskOutputList;
    function GetHasOutputList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTask; overload;
    function Clone : TFhirTask; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The business identifier for this task.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The URL pointing to a *FHIR*-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Task.
    property instantiatesCanonical : String read GetInstantiatesCanonicalST write SetInstantiatesCanonicalST;
    // The URL pointing to a *FHIR*-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Task.
    property instantiatesCanonicalElement : TFhirCanonical read FInstantiatesCanonical write SetInstantiatesCanonical;

    // Typed access to The URL pointing to an *externally* maintained  protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Task.
    property instantiatesUri : String read GetInstantiatesUriST write SetInstantiatesUriST;
    // The URL pointing to an *externally* maintained  protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Task.
    property instantiatesUriElement : TFhirUri read FInstantiatesUri write SetInstantiatesUri;

    // BasedOn refers to a higher-level authorization that triggered the creation of the task.  It references a "request" resource such as a ServiceRequest, MedicationRequest, ServiceRequest, CarePlan, etc. which is distinct from the "request" resource the task is seeking to fulfill.  This latter resource is referenced by FocusOn.  For example, based on a ServiceRequest (= BasedOn), a task is created to fulfill a procedureRequest ( = FocusOn ) to collect a specimen from a patient.
    property basedOnList : TFhirReferenceList{TFhirReference} read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Typed access to An identifier that links together multiple tasks and other requests that were created in the same context. (defined for API consistency)
    property groupIdentifier : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;
    // An identifier that links together multiple tasks and other requests that were created in the same context.
    property groupIdentifierElement : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;

    // Task that this particular task is part of.
    property partOfList : TFhirReferenceList{TFhirTask} read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // The current status of the task.
    property status : TFhirTaskStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to An explanation as to why this task is held, failed, was refused, etc. (defined for API consistency)
    property statusReason : TFhirCodeableConcept read FStatusReason write SetStatusReason;
    // An explanation as to why this task is held, failed, was refused, etc.
    property statusReasonElement : TFhirCodeableConcept read FStatusReason write SetStatusReason;

    // Typed access to Contains business-specific nuances of the business state. (defined for API consistency)
    property businessStatus : TFhirCodeableConcept read FBusinessStatus write SetBusinessStatus;
    // Contains business-specific nuances of the business state.
    property businessStatusElement : TFhirCodeableConcept read FBusinessStatus write SetBusinessStatus;

    // Indicates the "level" of actionability associated with the Task, i.e. i+R[9]Cs this a proposed task, a planned task, an actionable task, etc.
    property intent : TFhirTaskIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Indicates how quickly the Task should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to A name or code (or both) briefly describing what the task involves. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A name or code (or both) briefly describing what the task involves.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to A free-text description of what is to be performed.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free-text description of what is to be performed.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The request being actioned or the resource being manipulated by this task. (defined for API consistency)
    property focus : TFhirReference{TFhirReference} read FFocus write SetFocus;
    // The request being actioned or the resource being manipulated by this task.
    property focusElement : TFhirReference{TFhirReference} read FFocus write SetFocus;

    // Typed access to The entity who benefits from the performance of the service specified in the task (e.g., the patient). (defined for API consistency)
    property for_ : TFhirReference{TFhirReference} read FFor_ write SetFor_;
    // The entity who benefits from the performance of the service specified in the task (e.g., the patient).
    property for_Element : TFhirReference{TFhirReference} read FFor_ write SetFor_;

    // Typed access to The healthcare event  (e.g. a patient and healthcare provider interaction) during which this task was created. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // The healthcare event  (e.g. a patient and healthcare provider interaction) during which this task was created.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to Identifies the time action was first taken against the task (start) and/or the time final action was taken against the task prior to marking it as completed (end). (defined for API consistency)
    property executionPeriod : TFhirPeriod read FExecutionPeriod write SetExecutionPeriod;
    // Identifies the time action was first taken against the task (start) and/or the time final action was taken against the task prior to marking it as completed (end).
    property executionPeriodElement : TFhirPeriod read FExecutionPeriod write SetExecutionPeriod;

    // Typed access to The date and time this task was created.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // The date and time this task was created.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to The date and time of last modification to this task.
    property lastModified : TFslDateTime read GetLastModifiedST write SetLastModifiedST;
    // The date and time of last modification to this task.
    property lastModifiedElement : TFhirDateTime read FLastModified write SetLastModified;

    // Typed access to The creator of the task. (defined for API consistency)
    property requester : TFhirReference{TFhirDevice} read FRequester write SetRequester;
    // The creator of the task.
    property requesterElement : TFhirReference{TFhirDevice} read FRequester write SetRequester;

    // The kind of participant that should perform the task.
    property performerTypeList : TFhirCodeableConceptList read GetPerformerTypeList;
    property hasPerformerTypeList : boolean read GetHasPerformerTypeList;

    // Typed access to Individual organization or Device currently responsible for task execution. (defined for API consistency)
    property owner : TFhirReference{TFhirPractitioner} read FOwner write SetOwner;
    // Individual organization or Device currently responsible for task execution.
    property ownerElement : TFhirReference{TFhirPractitioner} read FOwner write SetOwner;

    // Typed access to Principal physical location where the this task is performed. (defined for API consistency)
    property location : TFhirReference{TFhirLocation} read FLocation write SetLocation;
    // Principal physical location where the this task is performed.
    property locationElement : TFhirReference{TFhirLocation} read FLocation write SetLocation;

    // Typed access to A description or code indicating why this task needs to be performed. (defined for API consistency)
    property reasonCode : TFhirCodeableConcept read FReasonCode write SetReasonCode;
    // A description or code indicating why this task needs to be performed.
    property reasonCodeElement : TFhirCodeableConcept read FReasonCode write SetReasonCode;

    // Typed access to A resource reference indicating why this task needs to be performed. (defined for API consistency)
    property reasonReference : TFhirReference{TFhirReference} read FReasonReference write SetReasonReference;
    // A resource reference indicating why this task needs to be performed.
    property reasonReferenceElement : TFhirReference{TFhirReference} read FReasonReference write SetReasonReference;

    // Insurance plans, coverage extensions, pre-authorizations and/or pre-determinations that may be relevant to the Task.
    property insuranceList : TFhirReferenceList{TFhirCoverage} read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Free-text information captured about the task as it progresses.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Links to Provenance records for past versions of this Task that identify key state transitions or updates that are likely to be relevant to a user looking at the current version of the task.
    property relevantHistoryList : TFhirReferenceList{TFhirProvenance} read GetRelevantHistoryList;
    property hasRelevantHistoryList : boolean read GetHasRelevantHistoryList;

    // Typed access to If the Task.focus is a request resource and the task is seeking fulfillment (i.e. is asking for the request to be actioned), this element identifies any limitations on what parts of the referenced request should be actioned. (defined for API consistency)
    property restriction : TFhirTaskRestriction read FRestriction write SetRestriction;
    // If the Task.focus is a request resource and the task is seeking fulfillment (i.e. is asking for the request to be actioned), this element identifies any limitations on what parts of the referenced request should be actioned.
    property restrictionElement : TFhirTaskRestriction read FRestriction write SetRestriction;

    // Additional information that may be needed in the execution of the task.
    property inputList : TFhirTaskInputList read GetInputList;
    property hasInputList : boolean read GetHasInputList;

    // Outputs produced by the Task.
    property outputList : TFhirTaskOutputList read GetOutputList;
    property hasOutputList : boolean read GetHasOutputList;

  end;

  TFhirTaskListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTaskList;
    function GetCurrent : TFhirTask;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTaskList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTask read GetCurrent;
  end;

  TFhirTaskList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTask;
    procedure SetItemN(index : Integer; value : TFhirTask);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTaskList; Overload;
    function Clone : TFhirTaskList; Overload;
    function GetEnumerator : TFhirTaskListEnumerator;
    

    //  Add a FhirTask to the end of the list.
    function Append : TFhirTask;

    
    // Add an already existing FhirTask to the end of the list.
    procedure AddItem(value : TFhirTask); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTask) : Integer;
    

    // Insert FhirTask before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTask;
    

    // Insert an existing FhirTask before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTask);
    
    // Get the iIndexth FhirTask. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTask);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTask;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTasks[index : Integer] : TFhirTask read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_TASK}

{$IFDEF FHIR_TESTREPORT}

  // A participant in the test execution, either the execution engine, a client, or a server.
  TFhirTestReportParticipant = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FUri : TFhirUri;
    FDisplay : TFhirString;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirReportParticipantTypeEnum;
    Procedure SetType_ST(value : TFhirReportParticipantTypeEnum);
    Procedure SetUri(value : TFhirUri);
    Function GetUriST : String;
    Procedure SetUriST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportParticipant; overload;
    function Clone : TFhirTestReportParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The type of participant.
    property type_ : TFhirReportParticipantTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The uri of the participant. An absolute URL is preferred.
    property uri : String read GetUriST write SetUriST;
    // The uri of the participant. An absolute URL is preferred.
    property uriElement : TFhirUri read FUri write SetUri;

    // Typed access to The display name of the participant.
    property display : String read GetDisplayST write SetDisplayST;
    // The display name of the participant.
    property displayElement : TFhirString read FDisplay write SetDisplay;

  end;

  TFhirTestReportParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportParticipantList;
    function GetCurrent : TFhirTestReportParticipant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestReportParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportParticipant read GetCurrent;
  end;

  TFhirTestReportParticipantList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestReportParticipant;
    procedure SetItemN(index : Integer; value : TFhirTestReportParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestReportParticipantList; Overload;
    function Clone : TFhirTestReportParticipantList; Overload;
    function GetEnumerator : TFhirTestReportParticipantListEnumerator;
    

    //  Add a FhirTestReportParticipant to the end of the list.
    function Append : TFhirTestReportParticipant;

    
    // Add an already existing FhirTestReportParticipant to the end of the list.
    procedure AddItem(value : TFhirTestReportParticipant); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportParticipant) : Integer;
    

    // Insert FhirTestReportParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportParticipant;
    

    // Insert an existing FhirTestReportParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportParticipant);
    
    // Get the iIndexth FhirTestReportParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportParticipant;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestReportParticipants[index : Integer] : TFhirTestReportParticipant read GetItemN write SetItemN; default;
  End;

  // The results of the series of required setup operations before the tests were executed.
  TFhirTestReportSetup = class (TFhirBackboneElement)
  protected
    FactionList : TFhirTestReportSetupActionList;
    function GetActionList : TFhirTestReportSetupActionList;
    function GetHasActionList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportSetup; overload;
    function Clone : TFhirTestReportSetup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Action would contain either an operation or an assertion.
    property actionList : TFhirTestReportSetupActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestReportSetupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportSetupList;
    function GetCurrent : TFhirTestReportSetup;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestReportSetupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportSetup read GetCurrent;
  end;

  TFhirTestReportSetupList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestReportSetup;
    procedure SetItemN(index : Integer; value : TFhirTestReportSetup);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestReportSetupList; Overload;
    function Clone : TFhirTestReportSetupList; Overload;
    function GetEnumerator : TFhirTestReportSetupListEnumerator;
    

    //  Add a FhirTestReportSetup to the end of the list.
    function Append : TFhirTestReportSetup;

    
    // Add an already existing FhirTestReportSetup to the end of the list.
    procedure AddItem(value : TFhirTestReportSetup); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportSetup) : Integer;
    

    // Insert FhirTestReportSetup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportSetup;
    

    // Insert an existing FhirTestReportSetup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportSetup);
    
    // Get the iIndexth FhirTestReportSetup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportSetup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportSetup;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestReportSetups[index : Integer] : TFhirTestReportSetup read GetItemN write SetItemN; default;
  End;

  // Action would contain either an operation or an assertion.
  TFhirTestReportSetupAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestReportSetupActionOperation;
    FAssert : TFhirTestReportSetupActionAssert;
    Procedure SetOperation(value : TFhirTestReportSetupActionOperation);
    Procedure SetAssert(value : TFhirTestReportSetupActionAssert);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportSetupAction; overload;
    function Clone : TFhirTestReportSetupAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The operation performed. (defined for API consistency)
    property operation : TFhirTestReportSetupActionOperation read FOperation write SetOperation;
    // The operation performed.
    property operationElement : TFhirTestReportSetupActionOperation read FOperation write SetOperation;

    // Typed access to The results of the assertion performed on the previous operations. (defined for API consistency)
    property assert : TFhirTestReportSetupActionAssert read FAssert write SetAssert;
    // The results of the assertion performed on the previous operations.
    property assertElement : TFhirTestReportSetupActionAssert read FAssert write SetAssert;

  end;

  TFhirTestReportSetupActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportSetupActionList;
    function GetCurrent : TFhirTestReportSetupAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestReportSetupActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportSetupAction read GetCurrent;
  end;

  TFhirTestReportSetupActionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestReportSetupAction;
    procedure SetItemN(index : Integer; value : TFhirTestReportSetupAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestReportSetupActionList; Overload;
    function Clone : TFhirTestReportSetupActionList; Overload;
    function GetEnumerator : TFhirTestReportSetupActionListEnumerator;
    

    //  Add a FhirTestReportSetupAction to the end of the list.
    function Append : TFhirTestReportSetupAction;

    
    // Add an already existing FhirTestReportSetupAction to the end of the list.
    procedure AddItem(value : TFhirTestReportSetupAction); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportSetupAction) : Integer;
    

    // Insert FhirTestReportSetupAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportSetupAction;
    

    // Insert an existing FhirTestReportSetupAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportSetupAction);
    
    // Get the iIndexth FhirTestReportSetupAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportSetupAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportSetupAction;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestReportSetupActions[index : Integer] : TFhirTestReportSetupAction read GetItemN write SetItemN; default;
  End;

  // The operation performed.
  TFhirTestReportSetupActionOperation = class (TFhirBackboneElement)
  protected
    FResult : TFhirEnum;
    FMessage : TFhirMarkdown;
    FDetail : TFhirUri;
    Procedure SetResult(value : TFhirEnum);
    Function GetResultST : TFhirReportActionResultCodesEnum;
    Procedure SetResultST(value : TFhirReportActionResultCodesEnum);
    Procedure SetMessage(value : TFhirMarkdown);
    Function GetMessageST : String;
    Procedure SetMessageST(value : String);
    Procedure SetDetail(value : TFhirUri);
    Function GetDetailST : String;
    Procedure SetDetailST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportSetupActionOperation; overload;
    function Clone : TFhirTestReportSetupActionOperation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The result of this operation.
    property result : TFhirReportActionResultCodesEnum read GetResultST write SetResultST;
    property resultElement : TFhirEnum read FResult write SetResult;

    // Typed access to An explanatory message associated with the result.
    property message : String read GetMessageST write SetMessageST;
    // An explanatory message associated with the result.
    property messageElement : TFhirMarkdown read FMessage write SetMessage;

    // Typed access to A link to further details on the result.
    property detail : String read GetDetailST write SetDetailST;
    // A link to further details on the result.
    property detailElement : TFhirUri read FDetail write SetDetail;

  end;

  TFhirTestReportSetupActionOperationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportSetupActionOperationList;
    function GetCurrent : TFhirTestReportSetupActionOperation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestReportSetupActionOperationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportSetupActionOperation read GetCurrent;
  end;

  TFhirTestReportSetupActionOperationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestReportSetupActionOperation;
    procedure SetItemN(index : Integer; value : TFhirTestReportSetupActionOperation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestReportSetupActionOperationList; Overload;
    function Clone : TFhirTestReportSetupActionOperationList; Overload;
    function GetEnumerator : TFhirTestReportSetupActionOperationListEnumerator;
    

    //  Add a FhirTestReportSetupActionOperation to the end of the list.
    function Append : TFhirTestReportSetupActionOperation;

    
    // Add an already existing FhirTestReportSetupActionOperation to the end of the list.
    procedure AddItem(value : TFhirTestReportSetupActionOperation); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportSetupActionOperation) : Integer;
    

    // Insert FhirTestReportSetupActionOperation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportSetupActionOperation;
    

    // Insert an existing FhirTestReportSetupActionOperation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportSetupActionOperation);
    
    // Get the iIndexth FhirTestReportSetupActionOperation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportSetupActionOperation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportSetupActionOperation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestReportSetupActionOperations[index : Integer] : TFhirTestReportSetupActionOperation read GetItemN write SetItemN; default;
  End;

  // The results of the assertion performed on the previous operations.
  TFhirTestReportSetupActionAssert = class (TFhirBackboneElement)
  protected
    FResult : TFhirEnum;
    FMessage : TFhirMarkdown;
    FDetail : TFhirString;
    Procedure SetResult(value : TFhirEnum);
    Function GetResultST : TFhirReportActionResultCodesEnum;
    Procedure SetResultST(value : TFhirReportActionResultCodesEnum);
    Procedure SetMessage(value : TFhirMarkdown);
    Function GetMessageST : String;
    Procedure SetMessageST(value : String);
    Procedure SetDetail(value : TFhirString);
    Function GetDetailST : String;
    Procedure SetDetailST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportSetupActionAssert; overload;
    function Clone : TFhirTestReportSetupActionAssert; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The result of this assertion.
    property result : TFhirReportActionResultCodesEnum read GetResultST write SetResultST;
    property resultElement : TFhirEnum read FResult write SetResult;

    // Typed access to An explanatory message associated with the result.
    property message : String read GetMessageST write SetMessageST;
    // An explanatory message associated with the result.
    property messageElement : TFhirMarkdown read FMessage write SetMessage;

    // Typed access to A link to further details on the result.
    property detail : String read GetDetailST write SetDetailST;
    // A link to further details on the result.
    property detailElement : TFhirString read FDetail write SetDetail;

  end;

  TFhirTestReportSetupActionAssertListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportSetupActionAssertList;
    function GetCurrent : TFhirTestReportSetupActionAssert;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestReportSetupActionAssertList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportSetupActionAssert read GetCurrent;
  end;

  TFhirTestReportSetupActionAssertList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestReportSetupActionAssert;
    procedure SetItemN(index : Integer; value : TFhirTestReportSetupActionAssert);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestReportSetupActionAssertList; Overload;
    function Clone : TFhirTestReportSetupActionAssertList; Overload;
    function GetEnumerator : TFhirTestReportSetupActionAssertListEnumerator;
    

    //  Add a FhirTestReportSetupActionAssert to the end of the list.
    function Append : TFhirTestReportSetupActionAssert;

    
    // Add an already existing FhirTestReportSetupActionAssert to the end of the list.
    procedure AddItem(value : TFhirTestReportSetupActionAssert); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportSetupActionAssert) : Integer;
    

    // Insert FhirTestReportSetupActionAssert before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportSetupActionAssert;
    

    // Insert an existing FhirTestReportSetupActionAssert before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportSetupActionAssert);
    
    // Get the iIndexth FhirTestReportSetupActionAssert. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportSetupActionAssert);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportSetupActionAssert;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestReportSetupActionAsserts[index : Integer] : TFhirTestReportSetupActionAssert read GetItemN write SetItemN; default;
  End;

  // A test executed from the test script.
  TFhirTestReportTest = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FDescription : TFhirString;
    FactionList : TFhirTestReportTestActionList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetActionList : TFhirTestReportTestActionList;
    function GetHasActionList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportTest; overload;
    function Clone : TFhirTestReportTest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The name of this test used for tracking/logging purposes by test engines.
    property name : String read GetNameST write SetNameST;
    // The name of this test used for tracking/logging purposes by test engines.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short description of the test used by test engines for tracking and reporting purposes.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A short description of the test used by test engines for tracking and reporting purposes.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Action would contain either an operation or an assertion.
    property actionList : TFhirTestReportTestActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestReportTestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportTestList;
    function GetCurrent : TFhirTestReportTest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestReportTestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportTest read GetCurrent;
  end;

  TFhirTestReportTestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestReportTest;
    procedure SetItemN(index : Integer; value : TFhirTestReportTest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestReportTestList; Overload;
    function Clone : TFhirTestReportTestList; Overload;
    function GetEnumerator : TFhirTestReportTestListEnumerator;
    

    //  Add a FhirTestReportTest to the end of the list.
    function Append : TFhirTestReportTest;

    
    // Add an already existing FhirTestReportTest to the end of the list.
    procedure AddItem(value : TFhirTestReportTest); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportTest) : Integer;
    

    // Insert FhirTestReportTest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportTest;
    

    // Insert an existing FhirTestReportTest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportTest);
    
    // Get the iIndexth FhirTestReportTest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportTest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportTest;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestReportTests[index : Integer] : TFhirTestReportTest read GetItemN write SetItemN; default;
  End;

  // Action would contain either an operation or an assertion.
  TFhirTestReportTestAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestReportSetupActionOperation;
    FAssert : TFhirTestReportSetupActionAssert;
    Procedure SetOperation(value : TFhirTestReportSetupActionOperation);
    Procedure SetAssert(value : TFhirTestReportSetupActionAssert);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportTestAction; overload;
    function Clone : TFhirTestReportTestAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An operation would involve a REST request to a server. (defined for API consistency)
    property operation : TFhirTestReportSetupActionOperation read FOperation write SetOperation;
    // An operation would involve a REST request to a server.
    property operationElement : TFhirTestReportSetupActionOperation read FOperation write SetOperation;

    // Typed access to The results of the assertion performed on the previous operations. (defined for API consistency)
    property assert : TFhirTestReportSetupActionAssert read FAssert write SetAssert;
    // The results of the assertion performed on the previous operations.
    property assertElement : TFhirTestReportSetupActionAssert read FAssert write SetAssert;

  end;

  TFhirTestReportTestActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportTestActionList;
    function GetCurrent : TFhirTestReportTestAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestReportTestActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportTestAction read GetCurrent;
  end;

  TFhirTestReportTestActionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestReportTestAction;
    procedure SetItemN(index : Integer; value : TFhirTestReportTestAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestReportTestActionList; Overload;
    function Clone : TFhirTestReportTestActionList; Overload;
    function GetEnumerator : TFhirTestReportTestActionListEnumerator;
    

    //  Add a FhirTestReportTestAction to the end of the list.
    function Append : TFhirTestReportTestAction;

    
    // Add an already existing FhirTestReportTestAction to the end of the list.
    procedure AddItem(value : TFhirTestReportTestAction); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportTestAction) : Integer;
    

    // Insert FhirTestReportTestAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportTestAction;
    

    // Insert an existing FhirTestReportTestAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportTestAction);
    
    // Get the iIndexth FhirTestReportTestAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportTestAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportTestAction;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestReportTestActions[index : Integer] : TFhirTestReportTestAction read GetItemN write SetItemN; default;
  End;

  // The results of the series of operations required to clean up after all the tests were executed (successfully or otherwise).
  TFhirTestReportTeardown = class (TFhirBackboneElement)
  protected
    FactionList : TFhirTestReportTeardownActionList;
    function GetActionList : TFhirTestReportTeardownActionList;
    function GetHasActionList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportTeardown; overload;
    function Clone : TFhirTestReportTeardown; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The teardown action will only contain an operation.
    property actionList : TFhirTestReportTeardownActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestReportTeardownListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportTeardownList;
    function GetCurrent : TFhirTestReportTeardown;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestReportTeardownList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportTeardown read GetCurrent;
  end;

  TFhirTestReportTeardownList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestReportTeardown;
    procedure SetItemN(index : Integer; value : TFhirTestReportTeardown);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestReportTeardownList; Overload;
    function Clone : TFhirTestReportTeardownList; Overload;
    function GetEnumerator : TFhirTestReportTeardownListEnumerator;
    

    //  Add a FhirTestReportTeardown to the end of the list.
    function Append : TFhirTestReportTeardown;

    
    // Add an already existing FhirTestReportTeardown to the end of the list.
    procedure AddItem(value : TFhirTestReportTeardown); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportTeardown) : Integer;
    

    // Insert FhirTestReportTeardown before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportTeardown;
    

    // Insert an existing FhirTestReportTeardown before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportTeardown);
    
    // Get the iIndexth FhirTestReportTeardown. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportTeardown);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportTeardown;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestReportTeardowns[index : Integer] : TFhirTestReportTeardown read GetItemN write SetItemN; default;
  End;

  // The teardown action will only contain an operation.
  TFhirTestReportTeardownAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestReportSetupActionOperation;
    Procedure SetOperation(value : TFhirTestReportSetupActionOperation);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportTeardownAction; overload;
    function Clone : TFhirTestReportTeardownAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An operation would involve a REST request to a server. (defined for API consistency)
    property operation : TFhirTestReportSetupActionOperation read FOperation write SetOperation;
    // An operation would involve a REST request to a server.
    property operationElement : TFhirTestReportSetupActionOperation read FOperation write SetOperation;

  end;

  TFhirTestReportTeardownActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportTeardownActionList;
    function GetCurrent : TFhirTestReportTeardownAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestReportTeardownActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportTeardownAction read GetCurrent;
  end;

  TFhirTestReportTeardownActionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestReportTeardownAction;
    procedure SetItemN(index : Integer; value : TFhirTestReportTeardownAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestReportTeardownActionList; Overload;
    function Clone : TFhirTestReportTeardownActionList; Overload;
    function GetEnumerator : TFhirTestReportTeardownActionListEnumerator;
    

    //  Add a FhirTestReportTeardownAction to the end of the list.
    function Append : TFhirTestReportTeardownAction;

    
    // Add an already existing FhirTestReportTeardownAction to the end of the list.
    procedure AddItem(value : TFhirTestReportTeardownAction); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportTeardownAction) : Integer;
    

    // Insert FhirTestReportTeardownAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportTeardownAction;
    

    // Insert an existing FhirTestReportTeardownAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportTeardownAction);
    
    // Get the iIndexth FhirTestReportTeardownAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportTeardownAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportTeardownAction;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestReportTeardownActions[index : Integer] : TFhirTestReportTeardownAction read GetItemN write SetItemN; default;
  End;

  // A summary of information based on the results of executing a TestScript.
  TFhirTestReport = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FName : TFhirString;
    FStatus : TFhirEnum;
    FTestScript : TFhirReference{TFhirTestScript};
    FResult : TFhirEnum;
    FScore : TFhirDecimal;
    FTester : TFhirString;
    FIssued : TFhirDateTime;
    FparticipantList : TFhirTestReportParticipantList;
    FSetup : TFhirTestReportSetup;
    FtestList : TFhirTestReportTestList;
    FTeardown : TFhirTestReportTeardown;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirReportStatusCodesEnum;
    Procedure SetStatusST(value : TFhirReportStatusCodesEnum);
    Procedure SetTestScript(value : TFhirReference{TFhirTestScript});
    Procedure SetResult(value : TFhirEnum);
    Function GetResultST : TFhirReportResultCodesEnum;
    Procedure SetResultST(value : TFhirReportResultCodesEnum);
    Procedure SetScore(value : TFhirDecimal);
    Function GetScoreST : String;
    Procedure SetScoreST(value : String);
    Procedure SetTester(value : TFhirString);
    Function GetTesterST : String;
    Procedure SetTesterST(value : String);
    Procedure SetIssued(value : TFhirDateTime);
    Function GetIssuedST : TFslDateTime;
    Procedure SetIssuedST(value : TFslDateTime);
    function GetParticipantList : TFhirTestReportParticipantList;
    function GetHasParticipantList : Boolean;
    Procedure SetSetup(value : TFhirTestReportSetup);
    function GetTestList : TFhirTestReportTestList;
    function GetHasTestList : Boolean;
    Procedure SetTeardown(value : TFhirTestReportTeardown);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReport; overload;
    function Clone : TFhirTestReport; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Identifier for the TestScript assigned for external purposes outside the context of FHIR. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier for the TestScript assigned for external purposes outside the context of FHIR.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to A free text natural language name identifying the executed TestScript.
    property name : String read GetNameST write SetNameST;
    // A free text natural language name identifying the executed TestScript.
    property nameElement : TFhirString read FName write SetName;

    // The current state of this test report.
    property status : TFhirReportStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Ideally this is an absolute URL that is used to identify the version-specific TestScript that was executed, matching the `TestScript.url`. (defined for API consistency)
    property testScript : TFhirReference{TFhirTestScript} read FTestScript write SetTestScript;
    // Ideally this is an absolute URL that is used to identify the version-specific TestScript that was executed, matching the `TestScript.url`.
    property testScriptElement : TFhirReference{TFhirTestScript} read FTestScript write SetTestScript;

    // The overall result from the execution of the TestScript.
    property result : TFhirReportResultCodesEnum read GetResultST write SetResultST;
    property resultElement : TFhirEnum read FResult write SetResult;

    // Typed access to The final score (percentage of tests passed) resulting from the execution of the TestScript.
    property score : String read GetScoreST write SetScoreST;
    // The final score (percentage of tests passed) resulting from the execution of the TestScript.
    property scoreElement : TFhirDecimal read FScore write SetScore;

    // Typed access to Name of the tester producing this report (Organization or individual).
    property tester : String read GetTesterST write SetTesterST;
    // Name of the tester producing this report (Organization or individual).
    property testerElement : TFhirString read FTester write SetTester;

    // Typed access to When the TestScript was executed and this TestReport was generated.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // When the TestScript was executed and this TestReport was generated.
    property issuedElement : TFhirDateTime read FIssued write SetIssued;

    // A participant in the test execution, either the execution engine, a client, or a server.
    property participantList : TFhirTestReportParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Typed access to The results of the series of required setup operations before the tests were executed. (defined for API consistency)
    property setup : TFhirTestReportSetup read FSetup write SetSetup;
    // The results of the series of required setup operations before the tests were executed.
    property setupElement : TFhirTestReportSetup read FSetup write SetSetup;

    // A test executed from the test script.
    property testList : TFhirTestReportTestList read GetTestList;
    property hasTestList : boolean read GetHasTestList;

    // Typed access to The results of the series of operations required to clean up after all the tests were executed (successfully or otherwise). (defined for API consistency)
    property teardown : TFhirTestReportTeardown read FTeardown write SetTeardown;
    // The results of the series of operations required to clean up after all the tests were executed (successfully or otherwise).
    property teardownElement : TFhirTestReportTeardown read FTeardown write SetTeardown;

  end;

  TFhirTestReportListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportList;
    function GetCurrent : TFhirTestReport;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestReportList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReport read GetCurrent;
  end;

  TFhirTestReportList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestReport;
    procedure SetItemN(index : Integer; value : TFhirTestReport);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestReportList; Overload;
    function Clone : TFhirTestReportList; Overload;
    function GetEnumerator : TFhirTestReportListEnumerator;
    

    //  Add a FhirTestReport to the end of the list.
    function Append : TFhirTestReport;

    
    // Add an already existing FhirTestReport to the end of the list.
    procedure AddItem(value : TFhirTestReport); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReport) : Integer;
    

    // Insert FhirTestReport before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReport;
    

    // Insert an existing FhirTestReport before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReport);
    
    // Get the iIndexth FhirTestReport. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReport);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReport;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTestReports[index : Integer] : TFhirTestReport read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_TESTREPORT}

{$IFDEF FHIR_VERIFICATIONRESULT}

  // Information about the primary source(s) involved in validation.
  TFhirVerificationResultPrimarySource = class (TFhirBackboneElement)
  protected
    FWho : TFhirReference{TFhirOrganization};
    Ftype_List : TFhirCodeableConceptList;
    FcommunicationMethodList : TFhirCodeableConceptList;
    FValidationStatus : TFhirCodeableConcept;
    FValidationDate : TFhirDateTime;
    FCanPushUpdates : TFhirCodeableConcept;
    FpushTypeAvailableList : TFhirCodeableConceptList;
    Procedure SetWho(value : TFhirReference{TFhirOrganization});
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetCommunicationMethodList : TFhirCodeableConceptList;
    function GetHasCommunicationMethodList : Boolean;
    Procedure SetValidationStatus(value : TFhirCodeableConcept);
    Procedure SetValidationDate(value : TFhirDateTime);
    Function GetValidationDateST : TFslDateTime;
    Procedure SetValidationDateST(value : TFslDateTime);
    Procedure SetCanPushUpdates(value : TFhirCodeableConcept);
    function GetPushTypeAvailableList : TFhirCodeableConceptList;
    function GetHasPushTypeAvailableList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVerificationResultPrimarySource; overload;
    function Clone : TFhirVerificationResultPrimarySource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Reference to the primary source. (defined for API consistency)
    property who : TFhirReference{TFhirOrganization} read FWho write SetWho;
    // Reference to the primary source.
    property whoElement : TFhirReference{TFhirOrganization} read FWho write SetWho;

    // Type of primary source (License Board; Primary Education; Continuing Education; Postal Service; Relationship owner; Registration Authority; legal source; issuing source; authoritative source).
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Method for communicating with the primary source (manual; API; Push).
    property communicationMethodList : TFhirCodeableConceptList read GetCommunicationMethodList;
    property hasCommunicationMethodList : boolean read GetHasCommunicationMethodList;

    // Typed access to Status of the validation of the target against the primary source (successful; failed; unknown). (defined for API consistency)
    property validationStatus : TFhirCodeableConcept read FValidationStatus write SetValidationStatus;
    // Status of the validation of the target against the primary source (successful; failed; unknown).
    property validationStatusElement : TFhirCodeableConcept read FValidationStatus write SetValidationStatus;

    // Typed access to When the target was validated against the primary source.
    property validationDate : TFslDateTime read GetValidationDateST write SetValidationDateST;
    // When the target was validated against the primary source.
    property validationDateElement : TFhirDateTime read FValidationDate write SetValidationDate;

    // Typed access to Ability of the primary source to push updates/alerts (yes; no; undetermined). (defined for API consistency)
    property canPushUpdates : TFhirCodeableConcept read FCanPushUpdates write SetCanPushUpdates;
    // Ability of the primary source to push updates/alerts (yes; no; undetermined).
    property canPushUpdatesElement : TFhirCodeableConcept read FCanPushUpdates write SetCanPushUpdates;

    // Type of alerts/updates the primary source can send (specific requested changes; any changes; as defined by source).
    property pushTypeAvailableList : TFhirCodeableConceptList read GetPushTypeAvailableList;
    property hasPushTypeAvailableList : boolean read GetHasPushTypeAvailableList;

  end;

  TFhirVerificationResultPrimarySourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVerificationResultPrimarySourceList;
    function GetCurrent : TFhirVerificationResultPrimarySource;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirVerificationResultPrimarySourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVerificationResultPrimarySource read GetCurrent;
  end;

  TFhirVerificationResultPrimarySourceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirVerificationResultPrimarySource;
    procedure SetItemN(index : Integer; value : TFhirVerificationResultPrimarySource);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirVerificationResultPrimarySourceList; Overload;
    function Clone : TFhirVerificationResultPrimarySourceList; Overload;
    function GetEnumerator : TFhirVerificationResultPrimarySourceListEnumerator;
    

    //  Add a FhirVerificationResultPrimarySource to the end of the list.
    function Append : TFhirVerificationResultPrimarySource;

    
    // Add an already existing FhirVerificationResultPrimarySource to the end of the list.
    procedure AddItem(value : TFhirVerificationResultPrimarySource); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVerificationResultPrimarySource) : Integer;
    

    // Insert FhirVerificationResultPrimarySource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVerificationResultPrimarySource;
    

    // Insert an existing FhirVerificationResultPrimarySource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVerificationResultPrimarySource);
    
    // Get the iIndexth FhirVerificationResultPrimarySource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVerificationResultPrimarySource);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirVerificationResultPrimarySource;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirVerificationResultPrimarySources[index : Integer] : TFhirVerificationResultPrimarySource read GetItemN write SetItemN; default;
  End;

  // Information about the entity attesting to information.
  TFhirVerificationResultAttestation = class (TFhirBackboneElement)
  protected
    FWho : TFhirReference{TFhirPractitioner};
    FOnBehalfOf : TFhirReference{TFhirOrganization};
    FCommunicationMethod : TFhirCodeableConcept;
    FDate : TFhirDate;
    FSourceIdentityCertificate : TFhirString;
    FProxyIdentityCertificate : TFhirString;
    FProxySignature : TFhirSignature;
    FSourceSignature : TFhirSignature;
    Procedure SetWho(value : TFhirReference{TFhirPractitioner});
    Procedure SetOnBehalfOf(value : TFhirReference{TFhirOrganization});
    Procedure SetCommunicationMethod(value : TFhirCodeableConcept);
    Procedure SetDate(value : TFhirDate);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetSourceIdentityCertificate(value : TFhirString);
    Function GetSourceIdentityCertificateST : String;
    Procedure SetSourceIdentityCertificateST(value : String);
    Procedure SetProxyIdentityCertificate(value : TFhirString);
    Function GetProxyIdentityCertificateST : String;
    Procedure SetProxyIdentityCertificateST(value : String);
    Procedure SetProxySignature(value : TFhirSignature);
    Procedure SetSourceSignature(value : TFhirSignature);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVerificationResultAttestation; overload;
    function Clone : TFhirVerificationResultAttestation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The individual or organization attesting to information. (defined for API consistency)
    property who : TFhirReference{TFhirPractitioner} read FWho write SetWho;
    // The individual or organization attesting to information.
    property whoElement : TFhirReference{TFhirPractitioner} read FWho write SetWho;

    // Typed access to When the who is asserting on behalf of another (organization or individual). (defined for API consistency)
    property onBehalfOf : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;
    // When the who is asserting on behalf of another (organization or individual).
    property onBehalfOfElement : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;

    // Typed access to The method by which attested information was submitted/retrieved (manual; API; Push). (defined for API consistency)
    property communicationMethod : TFhirCodeableConcept read FCommunicationMethod write SetCommunicationMethod;
    // The method by which attested information was submitted/retrieved (manual; API; Push).
    property communicationMethodElement : TFhirCodeableConcept read FCommunicationMethod write SetCommunicationMethod;

    // Typed access to The date the information was attested to.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date the information was attested to.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to A digital identity certificate associated with the attestation source.
    property sourceIdentityCertificate : String read GetSourceIdentityCertificateST write SetSourceIdentityCertificateST;
    // A digital identity certificate associated with the attestation source.
    property sourceIdentityCertificateElement : TFhirString read FSourceIdentityCertificate write SetSourceIdentityCertificate;

    // Typed access to A digital identity certificate associated with the proxy entity submitting attested information on behalf of the attestation source.
    property proxyIdentityCertificate : String read GetProxyIdentityCertificateST write SetProxyIdentityCertificateST;
    // A digital identity certificate associated with the proxy entity submitting attested information on behalf of the attestation source.
    property proxyIdentityCertificateElement : TFhirString read FProxyIdentityCertificate write SetProxyIdentityCertificate;

    // Typed access to Signed assertion by the proxy entity indicating that they have the right to submit attested information on behalf of the attestation source. (defined for API consistency)
    property proxySignature : TFhirSignature read FProxySignature write SetProxySignature;
    // Signed assertion by the proxy entity indicating that they have the right to submit attested information on behalf of the attestation source.
    property proxySignatureElement : TFhirSignature read FProxySignature write SetProxySignature;

    // Typed access to Signed assertion by the attestation source that they have attested to the information. (defined for API consistency)
    property sourceSignature : TFhirSignature read FSourceSignature write SetSourceSignature;
    // Signed assertion by the attestation source that they have attested to the information.
    property sourceSignatureElement : TFhirSignature read FSourceSignature write SetSourceSignature;

  end;

  TFhirVerificationResultAttestationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVerificationResultAttestationList;
    function GetCurrent : TFhirVerificationResultAttestation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirVerificationResultAttestationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVerificationResultAttestation read GetCurrent;
  end;

  TFhirVerificationResultAttestationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirVerificationResultAttestation;
    procedure SetItemN(index : Integer; value : TFhirVerificationResultAttestation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirVerificationResultAttestationList; Overload;
    function Clone : TFhirVerificationResultAttestationList; Overload;
    function GetEnumerator : TFhirVerificationResultAttestationListEnumerator;
    

    //  Add a FhirVerificationResultAttestation to the end of the list.
    function Append : TFhirVerificationResultAttestation;

    
    // Add an already existing FhirVerificationResultAttestation to the end of the list.
    procedure AddItem(value : TFhirVerificationResultAttestation); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVerificationResultAttestation) : Integer;
    

    // Insert FhirVerificationResultAttestation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVerificationResultAttestation;
    

    // Insert an existing FhirVerificationResultAttestation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVerificationResultAttestation);
    
    // Get the iIndexth FhirVerificationResultAttestation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVerificationResultAttestation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirVerificationResultAttestation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirVerificationResultAttestations[index : Integer] : TFhirVerificationResultAttestation read GetItemN write SetItemN; default;
  End;

  // Information about the entity validating information.
  TFhirVerificationResultValidator = class (TFhirBackboneElement)
  protected
    FOrganization : TFhirReference{TFhirOrganization};
    FIdentityCertificate : TFhirString;
    FAttestationSignature : TFhirSignature;
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetIdentityCertificate(value : TFhirString);
    Function GetIdentityCertificateST : String;
    Procedure SetIdentityCertificateST(value : String);
    Procedure SetAttestationSignature(value : TFhirSignature);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVerificationResultValidator; overload;
    function Clone : TFhirVerificationResultValidator; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Reference to the organization validating information. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // Reference to the organization validating information.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to A digital identity certificate associated with the validator.
    property identityCertificate : String read GetIdentityCertificateST write SetIdentityCertificateST;
    // A digital identity certificate associated with the validator.
    property identityCertificateElement : TFhirString read FIdentityCertificate write SetIdentityCertificate;

    // Typed access to Signed assertion by the validator that they have validated the information. (defined for API consistency)
    property attestationSignature : TFhirSignature read FAttestationSignature write SetAttestationSignature;
    // Signed assertion by the validator that they have validated the information.
    property attestationSignatureElement : TFhirSignature read FAttestationSignature write SetAttestationSignature;

  end;

  TFhirVerificationResultValidatorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVerificationResultValidatorList;
    function GetCurrent : TFhirVerificationResultValidator;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirVerificationResultValidatorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVerificationResultValidator read GetCurrent;
  end;

  TFhirVerificationResultValidatorList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirVerificationResultValidator;
    procedure SetItemN(index : Integer; value : TFhirVerificationResultValidator);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirVerificationResultValidatorList; Overload;
    function Clone : TFhirVerificationResultValidatorList; Overload;
    function GetEnumerator : TFhirVerificationResultValidatorListEnumerator;
    

    //  Add a FhirVerificationResultValidator to the end of the list.
    function Append : TFhirVerificationResultValidator;

    
    // Add an already existing FhirVerificationResultValidator to the end of the list.
    procedure AddItem(value : TFhirVerificationResultValidator); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVerificationResultValidator) : Integer;
    

    // Insert FhirVerificationResultValidator before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVerificationResultValidator;
    

    // Insert an existing FhirVerificationResultValidator before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVerificationResultValidator);
    
    // Get the iIndexth FhirVerificationResultValidator. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVerificationResultValidator);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirVerificationResultValidator;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirVerificationResultValidators[index : Integer] : TFhirVerificationResultValidator read GetItemN write SetItemN; default;
  End;

  // Describes validation requirements, source(s), status and dates for one or more elements.
  TFhirVerificationResult = class (TFhirDomainResource)
  protected
    FtargetList : TFhirReferenceList{TFhirReference};
    FtargetLocationList : TFhirStringList;
    FNeed : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FStatusDate : TFhirDateTime;
    FValidationType : TFhirCodeableConcept;
    FvalidationProcessList : TFhirCodeableConceptList;
    FFrequency : TFhirTiming;
    FLastPerformed : TFhirDateTime;
    FNextScheduled : TFhirDate;
    FFailureAction : TFhirCodeableConcept;
    FprimarySourceList : TFhirVerificationResultPrimarySourceList;
    FAttestation : TFhirVerificationResultAttestation;
    FvalidatorList : TFhirVerificationResultValidatorList;
    function GetTargetList : TFhirReferenceList{TFhirReference};
    function GetHasTargetList : Boolean;
    function GetTargetLocationList : TFhirStringList;
    function GetHasTargetLocationList : Boolean;
    Procedure SetNeed(value : TFhirCodeableConcept);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirVerificationresultStatusEnum;
    Procedure SetStatusST(value : TFhirVerificationresultStatusEnum);
    Procedure SetStatusDate(value : TFhirDateTime);
    Function GetStatusDateST : TFslDateTime;
    Procedure SetStatusDateST(value : TFslDateTime);
    Procedure SetValidationType(value : TFhirCodeableConcept);
    function GetValidationProcessList : TFhirCodeableConceptList;
    function GetHasValidationProcessList : Boolean;
    Procedure SetFrequency(value : TFhirTiming);
    Procedure SetLastPerformed(value : TFhirDateTime);
    Function GetLastPerformedST : TFslDateTime;
    Procedure SetLastPerformedST(value : TFslDateTime);
    Procedure SetNextScheduled(value : TFhirDate);
    Function GetNextScheduledST : TFslDateTime;
    Procedure SetNextScheduledST(value : TFslDateTime);
    Procedure SetFailureAction(value : TFhirCodeableConcept);
    function GetPrimarySourceList : TFhirVerificationResultPrimarySourceList;
    function GetHasPrimarySourceList : Boolean;
    Procedure SetAttestation(value : TFhirVerificationResultAttestation);
    function GetValidatorList : TFhirVerificationResultValidatorList;
    function GetHasValidatorList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVerificationResult; overload;
    function Clone : TFhirVerificationResult; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A resource that was validated.
    property targetList : TFhirReferenceList{TFhirReference} read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

    // The fhirpath location(s) within the resource that was validated.
    property targetLocationList : TFhirStringList read GetTargetLocationList;
    property hasTargetLocationList : boolean read GetHasTargetLocationList;

    // Typed access to The frequency with which the target must be validated (none; initial; periodic). (defined for API consistency)
    property need : TFhirCodeableConcept read FNeed write SetNeed;
    // The frequency with which the target must be validated (none; initial; periodic).
    property needElement : TFhirCodeableConcept read FNeed write SetNeed;

    // The validation status of the target (attested; validated; in process; requires revalidation; validation failed; revalidation failed).
    property status : TFhirVerificationresultStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to When the validation status was updated.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // When the validation status was updated.
    property statusDateElement : TFhirDateTime read FStatusDate write SetStatusDate;

    // Typed access to What the target is validated against (nothing; primary source; multiple sources). (defined for API consistency)
    property validationType : TFhirCodeableConcept read FValidationType write SetValidationType;
    // What the target is validated against (nothing; primary source; multiple sources).
    property validationTypeElement : TFhirCodeableConcept read FValidationType write SetValidationType;

    // The primary process by which the target is validated (edit check; value set; primary source; multiple sources; standalone; in context).
    property validationProcessList : TFhirCodeableConceptList read GetValidationProcessList;
    property hasValidationProcessList : boolean read GetHasValidationProcessList;

    // Typed access to Frequency of revalidation. (defined for API consistency)
    property frequency : TFhirTiming read FFrequency write SetFrequency;
    // Frequency of revalidation.
    property frequencyElement : TFhirTiming read FFrequency write SetFrequency;

    // Typed access to The date/time validation was last completed (including failed validations).
    property lastPerformed : TFslDateTime read GetLastPerformedST write SetLastPerformedST;
    // The date/time validation was last completed (including failed validations).
    property lastPerformedElement : TFhirDateTime read FLastPerformed write SetLastPerformed;

    // Typed access to The date when target is next validated, if appropriate.
    property nextScheduled : TFslDateTime read GetNextScheduledST write SetNextScheduledST;
    // The date when target is next validated, if appropriate.
    property nextScheduledElement : TFhirDate read FNextScheduled write SetNextScheduled;

    // Typed access to The result if validation fails (fatal; warning; record only; none). (defined for API consistency)
    property failureAction : TFhirCodeableConcept read FFailureAction write SetFailureAction;
    // The result if validation fails (fatal; warning; record only; none).
    property failureActionElement : TFhirCodeableConcept read FFailureAction write SetFailureAction;

    // Information about the primary source(s) involved in validation.
    property primarySourceList : TFhirVerificationResultPrimarySourceList read GetPrimarySourceList;
    property hasPrimarySourceList : boolean read GetHasPrimarySourceList;

    // Typed access to Information about the entity attesting to information. (defined for API consistency)
    property attestation : TFhirVerificationResultAttestation read FAttestation write SetAttestation;
    // Information about the entity attesting to information.
    property attestationElement : TFhirVerificationResultAttestation read FAttestation write SetAttestation;

    // Information about the entity validating information.
    property validatorList : TFhirVerificationResultValidatorList read GetValidatorList;
    property hasValidatorList : boolean read GetHasValidatorList;

  end;

  TFhirVerificationResultListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVerificationResultList;
    function GetCurrent : TFhirVerificationResult;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirVerificationResultList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVerificationResult read GetCurrent;
  end;

  TFhirVerificationResultList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirVerificationResult;
    procedure SetItemN(index : Integer; value : TFhirVerificationResult);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirVerificationResultList; Overload;
    function Clone : TFhirVerificationResultList; Overload;
    function GetEnumerator : TFhirVerificationResultListEnumerator;
    

    //  Add a FhirVerificationResult to the end of the list.
    function Append : TFhirVerificationResult;

    
    // Add an already existing FhirVerificationResult to the end of the list.
    procedure AddItem(value : TFhirVerificationResult); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVerificationResult) : Integer;
    

    // Insert FhirVerificationResult before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVerificationResult;
    

    // Insert an existing FhirVerificationResult before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVerificationResult);
    
    // Get the iIndexth FhirVerificationResult. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVerificationResult);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirVerificationResult;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirVerificationResults[index : Integer] : TFhirVerificationResult read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_VERIFICATIONRESULT}

implementation

uses
  fhir4_utilities;

{$IFDEF FHIR_PARAMETERS}

{ TFhirParametersParameter }

constructor TFhirParametersParameter.Create;
begin
  inherited;
end;

destructor TFhirParametersParameter.Destroy;
begin
  FName.free;
  FValue.free;
  FResource.free;
  FPartList.Free;
  inherited;
end;

procedure TFhirParametersParameter.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirParametersParameter(oSource).nameElement.Clone;
  value := TFhirParametersParameter(oSource).value.Clone;
  resource := TFhirParametersParameter(oSource).resource.Clone;
  if (TFhirParametersParameter(oSource).FPartList = nil) then
  begin
    FPartList.free;
    FPartList := nil;
  end
  else
  begin
    if FPartList = nil then
      FPartList := TFhirParametersParameterList.Create;
    FPartList.Assign(TFhirParametersParameter(oSource).FPartList);
  end;
end;

procedure TFhirParametersParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'part') Then
    list.addAll(self, 'part', FPartList);
end;

procedure TFhirParametersParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage', false, TFhirType, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', 'Resource', false, TFhirResource, FResource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'part', '@Parameters.parameter', true, TFhirParametersParameter, FPartList.Link)){3};
end;

function TFhirParametersParameter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirResource{4b};
    result := propValue;
  end
  else if (propName = 'part') then
  begin
    PartList.add(propValue as TFhirParametersParameter){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirParametersParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'part') then PartList.insertItem(index, propValue as TFhirParametersParameter){2a}
  else inherited;
end;

function TFhirParametersParameter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else if (propName = 'resource') then raise EFHIRException.create('Cannot make property Resource')
  else if (propName = 'part') then result := PartList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirParametersParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'value[x]') then result := 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage'
  else if (propName = 'resource') then result := 'Resource'
  else if (propName = 'part') then result := '@Parameters.parameter'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirParametersParameter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then ValueElement := nil{4x}
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'part') then deletePropertyValue('part', PartList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirParametersParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then ValueElement := new as TFhirType{4x}
  else if (propName = 'resource') then ResourceElement := new as TFhirResource{4}
  else if (propName = 'part') then replacePropertyValue('part', PartList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirParametersParameter.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'part') then PartList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirParametersParameter.fhirType : string;
begin
  result := 'parameter';
end;

function TFhirParametersParameter.Link : TFhirParametersParameter;
begin
  result := TFhirParametersParameter(inherited Link);
end;

function TFhirParametersParameter.Clone : TFhirParametersParameter;
begin
  result := TFhirParametersParameter(inherited Clone);
end;

function TFhirParametersParameter.equals(other : TObject) : boolean; 
var
  o : TFhirParametersParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirParametersParameter)) then
    result := false
  else
  begin
    o := TFhirParametersParameter(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(resourceElement, o.resourceElement, true) and compareDeep(partList, o.partList, true);
  end;
end;

function TFhirParametersParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FValue) and isEmptyProp(FResource) and isEmptyProp(FpartList);
end;

procedure TFhirParametersParameter.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('value[x]');
  fields.add('resource');
  fields.add('part');
end;

{ TFhirParametersParameter }

Procedure TFhirParametersParameter.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirParametersParameter.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirParametersParameter.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirParametersParameter.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Procedure TFhirParametersParameter.SetResource(value : TFhirResource);
begin
  FResource.free;
  FResource := value;
end;

Function TFhirParametersParameter.GetPartList : TFhirParametersParameterList;
begin
  if FPartList = nil then
    FPartList := TFhirParametersParameterList.Create;
  result := FPartList;
end;

Function TFhirParametersParameter.GetHasPartList : boolean;
begin
  result := (FPartList <> nil) and (FPartList.count > 0);
end;

function TFhirParametersParameter.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FResource.sizeInBytes);
  inc(result, FpartList.sizeInBytes);
end;

{ TFhirParametersParameterListEnumerator }

Constructor TFhirParametersParameterListEnumerator.Create(list : TFhirParametersParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirParametersParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirParametersParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirParametersParameterListEnumerator.GetCurrent : TFhirParametersParameter;
begin
  Result := FList[FIndex];
end;

function TFhirParametersParameterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirParametersParameterList }
procedure TFhirParametersParameterList.AddItem(value: TFhirParametersParameter);
begin
  assert(value.ClassName = 'TFhirParametersParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirParametersParameter');
  add(value);
end;

function TFhirParametersParameterList.Append: TFhirParametersParameter;
begin
  result := TFhirParametersParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParametersParameterList.ClearItems;
begin
  Clear;
end;

function TFhirParametersParameterList.GetEnumerator : TFhirParametersParameterListEnumerator;
begin
  result := TFhirParametersParameterListEnumerator.Create(self.link);
end;

function TFhirParametersParameterList.Clone: TFhirParametersParameterList;
begin
  result := TFhirParametersParameterList(inherited Clone);
end;

function TFhirParametersParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirParametersParameterList.GetItemN(index: Integer): TFhirParametersParameter;
begin
  result := TFhirParametersParameter(ObjectByIndex[index]);
end;

function TFhirParametersParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirParametersParameter;
end;
function TFhirParametersParameterList.IndexOf(value: TFhirParametersParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirParametersParameterList.Insert(index: Integer): TFhirParametersParameter;
begin
  result := TFhirParametersParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParametersParameterList.InsertItem(index: Integer; value: TFhirParametersParameter);
begin
  assert(value is TFhirParametersParameter);
  Inherited Insert(index, value);
end;

function TFhirParametersParameterList.Item(index: Integer): TFhirParametersParameter;
begin
  result := TFhirParametersParameter(ObjectByIndex[index]);
end;

function TFhirParametersParameterList.Link: TFhirParametersParameterList;
begin
  result := TFhirParametersParameterList(inherited Link);
end;

procedure TFhirParametersParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirParametersParameterList.SetItemByIndex(index: Integer; value: TFhirParametersParameter);
begin
  assert(value is TFhirParametersParameter);
  FhirParametersParameters[index] := value;
end;

procedure TFhirParametersParameterList.SetItemN(index: Integer; value: TFhirParametersParameter);
begin
  assert(value is TFhirParametersParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirParameters }

constructor TFhirParameters.Create;
begin
  inherited;
end;

destructor TFhirParameters.Destroy;
begin
  FParameterList.Free;
  inherited;
end;

function TFhirParameters.GetResourceType : TFhirResourceType;
begin
  result := frtParameters;
end;

procedure TFhirParameters.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirParameters(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirParametersParameterList.Create;
    FParameterList.Assign(TFhirParameters(oSource).FParameterList);
  end;
end;

procedure TFhirParameters.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
end;

procedure TFhirParameters.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'parameter', '', true, TFhirParametersParameter, FParameterList.Link)){3};
end;

function TFhirParameters.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirParametersParameter){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirParameters.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirParametersParameter){2a}
  else inherited;
end;

function TFhirParameters.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'parameter') then result := ParameterList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirParameters.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'parameter') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirParameters.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirParameters.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirParameters.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'parameter') then ParameterList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirParameters.fhirType : string;
begin
  result := 'Parameters';
end;

function TFhirParameters.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FparameterList);
end;

function TFhirParameters.equals(other : TObject) : boolean;
var
  o : TFhirParameters;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirParameters)) then
    result := false
  else
  begin
    o := TFhirParameters(other);
    result := compareDeep(parameterList, o.parameterList, true);
  end;
end;

function TFhirParameters.Link : TFhirParameters;
begin
  result := TFhirParameters(inherited Link);
end;

function TFhirParameters.Clone : TFhirParameters;
begin
  result := TFhirParameters(inherited Clone);
end;

procedure TFhirParameters.listFieldsInOrder(fields : TStringList);
begin
  listResourceFieldsInOrder(fields);
  fields.add('parameter');
end;

{ TFhirParameters }

Function TFhirParameters.GetParameterList : TFhirParametersParameterList;
begin
  if FParameterList = nil then
    FParameterList := TFhirParametersParameterList.Create;
  result := FParameterList;
end;

Function TFhirParameters.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

function TFhirParameters.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FparameterList.sizeInBytes);
end;

{ TFhirParametersListEnumerator }

Constructor TFhirParametersListEnumerator.Create(list : TFhirParametersList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirParametersListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirParametersListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirParametersListEnumerator.GetCurrent : TFhirParameters;
begin
  Result := FList[FIndex];
end;

function TFhirParametersListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirParametersList }
procedure TFhirParametersList.AddItem(value: TFhirParameters);
begin
  assert(value.ClassName = 'TFhirParameters', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirParameters');
  add(value);
end;

function TFhirParametersList.Append: TFhirParameters;
begin
  result := TFhirParameters.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParametersList.ClearItems;
begin
  Clear;
end;

function TFhirParametersList.GetEnumerator : TFhirParametersListEnumerator;
begin
  result := TFhirParametersListEnumerator.Create(self.link);
end;

function TFhirParametersList.Clone: TFhirParametersList;
begin
  result := TFhirParametersList(inherited Clone);
end;

function TFhirParametersList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirParametersList.GetItemN(index: Integer): TFhirParameters;
begin
  result := TFhirParameters(ObjectByIndex[index]);
end;

function TFhirParametersList.ItemClass: TFslObjectClass;
begin
  result := TFhirParameters;
end;
function TFhirParametersList.IndexOf(value: TFhirParameters): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirParametersList.Insert(index: Integer): TFhirParameters;
begin
  result := TFhirParameters.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParametersList.InsertItem(index: Integer; value: TFhirParameters);
begin
  assert(value is TFhirParameters);
  Inherited Insert(index, value);
end;

function TFhirParametersList.Item(index: Integer): TFhirParameters;
begin
  result := TFhirParameters(ObjectByIndex[index]);
end;

function TFhirParametersList.Link: TFhirParametersList;
begin
  result := TFhirParametersList(inherited Link);
end;

procedure TFhirParametersList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirParametersList.SetItemByIndex(index: Integer; value: TFhirParameters);
begin
  assert(value is TFhirParameters);
  FhirParameters[index] := value;
end;

procedure TFhirParametersList.SetItemN(index: Integer; value: TFhirParameters);
begin
  assert(value is TFhirParameters);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PARAMETERS}

{$IFDEF FHIR_AUDITEVENT}

{ TFhirAuditEventAgent }

constructor TFhirAuditEventAgent.Create;
begin
  inherited;
end;

destructor TFhirAuditEventAgent.Destroy;
begin
  FType_.free;
  FRoleList.Free;
  FWho.free;
  FAltId.free;
  FName.free;
  FRequestor.free;
  FLocation.free;
  FPolicyList.Free;
  FMedia.free;
  FNetwork.free;
  FPurposeOfUseList.Free;
  inherited;
end;

procedure TFhirAuditEventAgent.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirAuditEventAgent(oSource).type_.Clone;
  if (TFhirAuditEventAgent(oSource).FRoleList = nil) then
  begin
    FRoleList.free;
    FRoleList := nil;
  end
  else
  begin
    if FRoleList = nil then
      FRoleList := TFhirCodeableConceptList.Create;
    FRoleList.Assign(TFhirAuditEventAgent(oSource).FRoleList);
  end;
  who := TFhirAuditEventAgent(oSource).who.Clone;
  altIdElement := TFhirAuditEventAgent(oSource).altIdElement.Clone;
  nameElement := TFhirAuditEventAgent(oSource).nameElement.Clone;
  requestorElement := TFhirAuditEventAgent(oSource).requestorElement.Clone;
  location := TFhirAuditEventAgent(oSource).location.Clone;
  if (TFhirAuditEventAgent(oSource).FPolicyList = nil) then
  begin
    FPolicyList.free;
    FPolicyList := nil;
  end
  else
  begin
    if FPolicyList = nil then
      FPolicyList := TFhirUriList.Create;
    FPolicyList.Assign(TFhirAuditEventAgent(oSource).FPolicyList);
  end;
  media := TFhirAuditEventAgent(oSource).media.Clone;
  network := TFhirAuditEventAgent(oSource).network.Clone;
  if (TFhirAuditEventAgent(oSource).FPurposeOfUseList = nil) then
  begin
    FPurposeOfUseList.free;
    FPurposeOfUseList := nil;
  end
  else
  begin
    if FPurposeOfUseList = nil then
      FPurposeOfUseList := TFhirCodeableConceptList.Create;
    FPurposeOfUseList.Assign(TFhirAuditEventAgent(oSource).FPurposeOfUseList);
  end;
end;

procedure TFhirAuditEventAgent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'role') Then
    list.addAll(self, 'role', FRoleList);
  if (child_name = 'who') Then
     list.add(self.link, 'who', FWho.Link);
  if (child_name = 'altId') Then
     list.add(self.link, 'altId', FAltId.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'requestor') Then
     list.add(self.link, 'requestor', FRequestor.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'policy') Then
    list.addAll(self, 'policy', FPolicyList);
  if (child_name = 'media') Then
     list.add(self.link, 'media', FMedia.Link);
  if (child_name = 'network') Then
     list.add(self.link, 'network', FNetwork.Link);
  if (child_name = 'purposeOfUse') Then
    list.addAll(self, 'purposeOfUse', FPurposeOfUseList);
end;

procedure TFhirAuditEventAgent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', true, TFhirCodeableConcept, FRoleList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'who', 'Reference(PractitionerRole)', false, TFhirReference{TFhirPractitionerRole}, FWho.Link));{2}
  oList.add(TFHIRProperty.create(self, 'altId', 'string', false, TFhirString, FAltId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestor', 'boolean', false, TFhirBoolean, FRequestor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'policy', 'uri', true, TFhirUri, FPolicyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'media', 'Coding', false, TFhirCoding, FMedia.Link));{2}
  oList.add(TFHIRProperty.create(self, 'network', '', false, TFhirAuditEventAgentNetwork, FNetwork.Link));{2}
  oList.add(TFHIRProperty.create(self, 'purposeOfUse', 'CodeableConcept', true, TFhirCodeableConcept, FPurposeOfUseList.Link)){3};
end;

function TFhirAuditEventAgent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    RoleList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'who') then
  begin
    Who := propValue as TFhirReference{TFhirPractitionerRole}{4b};
    result := propValue;
  end
  else if (propName = 'altId') then
  begin
    AltIdElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requestor') then
  begin
    RequestorElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'policy') then
  begin
    PolicyList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'media') then
  begin
    Media := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    Network := propValue as TFhirAuditEventAgentNetwork{4b};
    result := propValue;
  end
  else if (propName = 'purposeOfUse') then
  begin
    PurposeOfUseList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventAgent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'role') then RoleList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'policy') then PolicyList.insertItem(index, asUri(propValue)){2}
  else if (propName = 'purposeOfUse') then PurposeOfUseList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirAuditEventAgent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'role') then result := RoleList.new(){2}
  else if (propName = 'who') then result := TFhirReference{TFhirPractitionerRole}.create(){4b}
  else if (propName = 'altId') then result := TFhirString.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'requestor') then result := TFhirBoolean.create() {5b}
  else if (propName = 'location') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'policy') then result := PolicyList.new(){2}
  else if (propName = 'media') then result := TFhirCoding.create(){4b}
  else if (propName = 'network') then result := TFhirAuditEventAgentNetwork.create(){4b}
  else if (propName = 'purposeOfUse') then result := PurposeOfUseList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventAgent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'who') then result := 'Reference'
  else if (propName = 'altId') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'requestor') then result := 'boolean'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'policy') then result := 'uri'
  else if (propName = 'media') then result := 'Coding'
  else if (propName = 'network') then result := ''
  else if (propName = 'purposeOfUse') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventAgent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'role') then deletePropertyValue('role', RoleList, value) {2}
  else if (propName = 'who') then WhoElement := nil
  else if (propName = 'altId') then AltIdElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'requestor') then RequestorElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'policy') then deletePropertyValue('policy', PolicyList, value) {2}
  else if (propName = 'media') then MediaElement := nil
  else if (propName = 'network') then NetworkElement := nil
  else if (propName = 'purposeOfUse') then deletePropertyValue('purposeOfUse', PurposeOfUseList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventAgent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'role') then replacePropertyValue('role', RoleList, existing, new) {2}
  else if (propName = 'who') then WhoElement := new as TFhirReference{TFhirPractitionerRole}{4}
  else if (propName = 'altId') then AltIdElement := asString(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'requestor') then RequestorElement := asBoolean(new){5b}
  else if (propName = 'location') then LocationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'policy') then replacePropertyValue('policy', PolicyList, existing, new) {2}
  else if (propName = 'media') then MediaElement := new as TFhirCoding{4}
  else if (propName = 'network') then NetworkElement := new as TFhirAuditEventAgentNetwork{4}
  else if (propName = 'purposeOfUse') then replacePropertyValue('purposeOfUse', PurposeOfUseList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventAgent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'role') then RoleList.move(source, destination){2a}
  else if (propName = 'policy') then PolicyList.move(source, destination){2}
  else if (propName = 'purposeOfUse') then PurposeOfUseList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventAgent.fhirType : string;
begin
  result := 'agent';
end;

function TFhirAuditEventAgent.Link : TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent(inherited Link);
end;

function TFhirAuditEventAgent.Clone : TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent(inherited Clone);
end;

function TFhirAuditEventAgent.equals(other : TObject) : boolean; 
var
  o : TFhirAuditEventAgent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventAgent)) then
    result := false
  else
  begin
    o := TFhirAuditEventAgent(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(roleList, o.roleList, true) and 
      compareDeep(whoElement, o.whoElement, true) and compareDeep(altIdElement, o.altIdElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(requestorElement, o.requestorElement, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(policyList, o.policyList, true) and 
      compareDeep(mediaElement, o.mediaElement, true) and compareDeep(networkElement, o.networkElement, true) and 
      compareDeep(purposeOfUseList, o.purposeOfUseList, true);
  end;
end;

function TFhirAuditEventAgent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FroleList) and isEmptyProp(FWho) and isEmptyProp(FAltId) and isEmptyProp(FName) and isEmptyProp(FRequestor) and isEmptyProp(FLocation) and isEmptyProp(FpolicyList) and isEmptyProp(FMedia) and isEmptyProp(FNetwork) and isEmptyProp(FpurposeOfUseList);
end;

procedure TFhirAuditEventAgent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('role');
  fields.add('who');
  fields.add('altId');
  fields.add('name');
  fields.add('requestor');
  fields.add('location');
  fields.add('policy');
  fields.add('media');
  fields.add('network');
  fields.add('purposeOfUse');
end;

{ TFhirAuditEventAgent }

Procedure TFhirAuditEventAgent.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirAuditEventAgent.GetRoleList : TFhirCodeableConceptList;
begin
  if FRoleList = nil then
    FRoleList := TFhirCodeableConceptList.Create;
  result := FRoleList;
end;

Function TFhirAuditEventAgent.GetHasRoleList : boolean;
begin
  result := (FRoleList <> nil) and (FRoleList.count > 0);
end;

Procedure TFhirAuditEventAgent.SetWho(value : TFhirReference{TFhirPractitionerRole});
begin
  FWho.free;
  FWho := value;
end;

Procedure TFhirAuditEventAgent.SetAltId(value : TFhirString);
begin
  FAltId.free;
  FAltId := value;
end;

Function TFhirAuditEventAgent.GetAltIdST : String;
begin
  if FAltId = nil then
    result := ''
  else
    result := FAltId.value;
end;

Procedure TFhirAuditEventAgent.SetAltIdST(value : String);
begin
  if value <> '' then
  begin
    if FAltId = nil then
      FAltId := TFhirString.create;
    FAltId.value := value
  end
  else if FAltId <> nil then
    FAltId.value := '';
end;

Procedure TFhirAuditEventAgent.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirAuditEventAgent.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirAuditEventAgent.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirAuditEventAgent.SetRequestor(value : TFhirBoolean);
begin
  FRequestor.free;
  FRequestor := value;
end;

Function TFhirAuditEventAgent.GetRequestorST : Boolean;
begin
  if FRequestor = nil then
    result := false
  else
    result := FRequestor.value;
end;

Procedure TFhirAuditEventAgent.SetRequestorST(value : Boolean);
begin
  if FRequestor = nil then
    FRequestor := TFhirBoolean.create;
  FRequestor.value := value
end;

Procedure TFhirAuditEventAgent.SetLocation(value : TFhirReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Function TFhirAuditEventAgent.GetPolicyList : TFhirUriList;
begin
  if FPolicyList = nil then
    FPolicyList := TFhirUriList.Create;
  result := FPolicyList;
end;

Function TFhirAuditEventAgent.GetHasPolicyList : boolean;
begin
  result := (FPolicyList <> nil) and (FPolicyList.count > 0);
end;

Procedure TFhirAuditEventAgent.SetMedia(value : TFhirCoding);
begin
  FMedia.free;
  FMedia := value;
end;

Procedure TFhirAuditEventAgent.SetNetwork(value : TFhirAuditEventAgentNetwork);
begin
  FNetwork.free;
  FNetwork := value;
end;

Function TFhirAuditEventAgent.GetPurposeOfUseList : TFhirCodeableConceptList;
begin
  if FPurposeOfUseList = nil then
    FPurposeOfUseList := TFhirCodeableConceptList.Create;
  result := FPurposeOfUseList;
end;

Function TFhirAuditEventAgent.GetHasPurposeOfUseList : boolean;
begin
  result := (FPurposeOfUseList <> nil) and (FPurposeOfUseList.count > 0);
end;

function TFhirAuditEventAgent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FroleList.sizeInBytes);
  inc(result, FWho.sizeInBytes);
  inc(result, FAltId.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FRequestor.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FpolicyList.sizeInBytes);
  inc(result, FMedia.sizeInBytes);
  inc(result, FNetwork.sizeInBytes);
  inc(result, FpurposeOfUseList.sizeInBytes);
end;

{ TFhirAuditEventAgentListEnumerator }

Constructor TFhirAuditEventAgentListEnumerator.Create(list : TFhirAuditEventAgentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventAgentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventAgentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventAgentListEnumerator.GetCurrent : TFhirAuditEventAgent;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventAgentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAuditEventAgentList }
procedure TFhirAuditEventAgentList.AddItem(value: TFhirAuditEventAgent);
begin
  assert(value.ClassName = 'TFhirAuditEventAgent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventAgent');
  add(value);
end;

function TFhirAuditEventAgentList.Append: TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventAgentList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventAgentList.GetEnumerator : TFhirAuditEventAgentListEnumerator;
begin
  result := TFhirAuditEventAgentListEnumerator.Create(self.link);
end;

function TFhirAuditEventAgentList.Clone: TFhirAuditEventAgentList;
begin
  result := TFhirAuditEventAgentList(inherited Clone);
end;

function TFhirAuditEventAgentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventAgentList.GetItemN(index: Integer): TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent(ObjectByIndex[index]);
end;

function TFhirAuditEventAgentList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventAgent;
end;
function TFhirAuditEventAgentList.IndexOf(value: TFhirAuditEventAgent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventAgentList.Insert(index: Integer): TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventAgentList.InsertItem(index: Integer; value: TFhirAuditEventAgent);
begin
  assert(value is TFhirAuditEventAgent);
  Inherited Insert(index, value);
end;

function TFhirAuditEventAgentList.Item(index: Integer): TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent(ObjectByIndex[index]);
end;

function TFhirAuditEventAgentList.Link: TFhirAuditEventAgentList;
begin
  result := TFhirAuditEventAgentList(inherited Link);
end;

procedure TFhirAuditEventAgentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventAgentList.SetItemByIndex(index: Integer; value: TFhirAuditEventAgent);
begin
  assert(value is TFhirAuditEventAgent);
  FhirAuditEventAgents[index] := value;
end;

procedure TFhirAuditEventAgentList.SetItemN(index: Integer; value: TFhirAuditEventAgent);
begin
  assert(value is TFhirAuditEventAgent);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventAgentNetwork }

constructor TFhirAuditEventAgentNetwork.Create;
begin
  inherited;
end;

destructor TFhirAuditEventAgentNetwork.Destroy;
begin
  FAddress.free;
  FType_.free;
  inherited;
end;

procedure TFhirAuditEventAgentNetwork.Assign(oSource : TFslObject);
begin
  inherited;
  addressElement := TFhirAuditEventAgentNetwork(oSource).addressElement.Clone;
  FType_ := TFhirAuditEventAgentNetwork(oSource).FType_.Link;
end;

procedure TFhirAuditEventAgentNetwork.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirAuditEventAgentNetwork.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'address', 'string', false, TFhirString, FAddress.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
end;

function TFhirAuditEventAgentNetwork.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'address') then
  begin
    AddressElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirNetworkTypeEnum, CODES_TFhirNetworkTypeEnum, propValue);
    result := propValue
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventAgentNetwork.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAuditEventAgentNetwork.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'address') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventAgentNetwork.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'address') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventAgentNetwork.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'address') then AddressElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventAgentNetwork.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'address') then AddressElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirNetworkTypeEnum, CODES_TFhirNetworkTypeEnum, new){4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventAgentNetwork.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventAgentNetwork.fhirType : string;
begin
  result := 'network';
end;

function TFhirAuditEventAgentNetwork.Link : TFhirAuditEventAgentNetwork;
begin
  result := TFhirAuditEventAgentNetwork(inherited Link);
end;

function TFhirAuditEventAgentNetwork.Clone : TFhirAuditEventAgentNetwork;
begin
  result := TFhirAuditEventAgentNetwork(inherited Clone);
end;

function TFhirAuditEventAgentNetwork.equals(other : TObject) : boolean; 
var
  o : TFhirAuditEventAgentNetwork;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventAgentNetwork)) then
    result := false
  else
  begin
    o := TFhirAuditEventAgentNetwork(other);
    result := compareDeep(addressElement, o.addressElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirAuditEventAgentNetwork.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAddress) and isEmptyProp(FType_);
end;

procedure TFhirAuditEventAgentNetwork.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('address');
  fields.add('type');
end;

{ TFhirAuditEventAgentNetwork }

Procedure TFhirAuditEventAgentNetwork.SetAddress(value : TFhirString);
begin
  FAddress.free;
  FAddress := value;
end;

Function TFhirAuditEventAgentNetwork.GetAddressST : String;
begin
  if FAddress = nil then
    result := ''
  else
    result := FAddress.value;
end;

Procedure TFhirAuditEventAgentNetwork.SetAddressST(value : String);
begin
  if value <> '' then
  begin
    if FAddress = nil then
      FAddress := TFhirString.create;
    FAddress.value := value
  end
  else if FAddress <> nil then
    FAddress.value := '';
end;

Procedure TFhirAuditEventAgentNetwork.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirAuditEventAgentNetwork.GetType_ST : TFhirNetworkTypeEnum;
begin
  if FType_ = nil then
    result := TFhirNetworkTypeEnum(0)
  else
    result := TFhirNetworkTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirNetworkTypeEnum, FType_.value));
end;

Procedure TFhirAuditEventAgentNetwork.SetType_ST(value : TFhirNetworkTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirNetworkTypeEnum[value], CODES_TFhirNetworkTypeEnum[value]);
end;

function TFhirAuditEventAgentNetwork.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAddress.sizeInBytes);
  inc(result, FType_.sizeInBytes);
end;

{ TFhirAuditEventAgentNetworkListEnumerator }

Constructor TFhirAuditEventAgentNetworkListEnumerator.Create(list : TFhirAuditEventAgentNetworkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventAgentNetworkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventAgentNetworkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventAgentNetworkListEnumerator.GetCurrent : TFhirAuditEventAgentNetwork;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventAgentNetworkListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAuditEventAgentNetworkList }
procedure TFhirAuditEventAgentNetworkList.AddItem(value: TFhirAuditEventAgentNetwork);
begin
  assert(value.ClassName = 'TFhirAuditEventAgentNetwork', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventAgentNetwork');
  add(value);
end;

function TFhirAuditEventAgentNetworkList.Append: TFhirAuditEventAgentNetwork;
begin
  result := TFhirAuditEventAgentNetwork.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventAgentNetworkList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventAgentNetworkList.GetEnumerator : TFhirAuditEventAgentNetworkListEnumerator;
begin
  result := TFhirAuditEventAgentNetworkListEnumerator.Create(self.link);
end;

function TFhirAuditEventAgentNetworkList.Clone: TFhirAuditEventAgentNetworkList;
begin
  result := TFhirAuditEventAgentNetworkList(inherited Clone);
end;

function TFhirAuditEventAgentNetworkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventAgentNetworkList.GetItemN(index: Integer): TFhirAuditEventAgentNetwork;
begin
  result := TFhirAuditEventAgentNetwork(ObjectByIndex[index]);
end;

function TFhirAuditEventAgentNetworkList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventAgentNetwork;
end;
function TFhirAuditEventAgentNetworkList.IndexOf(value: TFhirAuditEventAgentNetwork): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventAgentNetworkList.Insert(index: Integer): TFhirAuditEventAgentNetwork;
begin
  result := TFhirAuditEventAgentNetwork.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventAgentNetworkList.InsertItem(index: Integer; value: TFhirAuditEventAgentNetwork);
begin
  assert(value is TFhirAuditEventAgentNetwork);
  Inherited Insert(index, value);
end;

function TFhirAuditEventAgentNetworkList.Item(index: Integer): TFhirAuditEventAgentNetwork;
begin
  result := TFhirAuditEventAgentNetwork(ObjectByIndex[index]);
end;

function TFhirAuditEventAgentNetworkList.Link: TFhirAuditEventAgentNetworkList;
begin
  result := TFhirAuditEventAgentNetworkList(inherited Link);
end;

procedure TFhirAuditEventAgentNetworkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventAgentNetworkList.SetItemByIndex(index: Integer; value: TFhirAuditEventAgentNetwork);
begin
  assert(value is TFhirAuditEventAgentNetwork);
  FhirAuditEventAgentNetworks[index] := value;
end;

procedure TFhirAuditEventAgentNetworkList.SetItemN(index: Integer; value: TFhirAuditEventAgentNetwork);
begin
  assert(value is TFhirAuditEventAgentNetwork);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventSource }

constructor TFhirAuditEventSource.Create;
begin
  inherited;
end;

destructor TFhirAuditEventSource.Destroy;
begin
  FSite.free;
  FObserver.free;
  FType_List.Free;
  inherited;
end;

procedure TFhirAuditEventSource.Assign(oSource : TFslObject);
begin
  inherited;
  siteElement := TFhirAuditEventSource(oSource).siteElement.Clone;
  observer := TFhirAuditEventSource(oSource).observer.Clone;
  if (TFhirAuditEventSource(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodingList.Create;
    FType_List.Assign(TFhirAuditEventSource(oSource).FType_List);
  end;
end;

procedure TFhirAuditEventSource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'site') Then
     list.add(self.link, 'site', FSite.Link);
  if (child_name = 'observer') Then
     list.add(self.link, 'observer', FObserver.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
end;

procedure TFhirAuditEventSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'site', 'string', false, TFhirString, FSite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'observer', 'Reference(PractitionerRole)', false, TFhirReference{TFhirPractitionerRole}, FObserver.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', true, TFhirCoding, FType_List.Link)){3};
end;

function TFhirAuditEventSource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'site') then
  begin
    SiteElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'observer') then
  begin
    Observer := propValue as TFhirReference{TFhirPractitionerRole}{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventSource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCoding){2a}
  else inherited;
end;

function TFhirAuditEventSource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'site') then result := TFhirString.create() {5b}
  else if (propName = 'observer') then result := TFhirReference{TFhirPractitionerRole}.create(){4b}
  else if (propName = 'type') then result := Type_List.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventSource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'site') then result := 'string'
  else if (propName = 'observer') then result := 'Reference'
  else if (propName = 'type') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventSource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'site') then SiteElement := nil
  else if (propName = 'observer') then ObserverElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventSource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'site') then SiteElement := asString(new){5b}
  else if (propName = 'observer') then ObserverElement := new as TFhirReference{TFhirPractitionerRole}{4}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventSource.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventSource.fhirType : string;
begin
  result := 'source';
end;

function TFhirAuditEventSource.Link : TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource(inherited Link);
end;

function TFhirAuditEventSource.Clone : TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource(inherited Clone);
end;

function TFhirAuditEventSource.equals(other : TObject) : boolean; 
var
  o : TFhirAuditEventSource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventSource)) then
    result := false
  else
  begin
    o := TFhirAuditEventSource(other);
    result := compareDeep(siteElement, o.siteElement, true) and compareDeep(observerElement, o.observerElement, true) and 
      compareDeep(type_List, o.type_List, true);
  end;
end;

function TFhirAuditEventSource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSite) and isEmptyProp(FObserver) and isEmptyProp(Ftype_List);
end;

procedure TFhirAuditEventSource.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('site');
  fields.add('observer');
  fields.add('type');
end;

{ TFhirAuditEventSource }

Procedure TFhirAuditEventSource.SetSite(value : TFhirString);
begin
  FSite.free;
  FSite := value;
end;

Function TFhirAuditEventSource.GetSiteST : String;
begin
  if FSite = nil then
    result := ''
  else
    result := FSite.value;
end;

Procedure TFhirAuditEventSource.SetSiteST(value : String);
begin
  if value <> '' then
  begin
    if FSite = nil then
      FSite := TFhirString.create;
    FSite.value := value
  end
  else if FSite <> nil then
    FSite.value := '';
end;

Procedure TFhirAuditEventSource.SetObserver(value : TFhirReference{TFhirPractitionerRole});
begin
  FObserver.free;
  FObserver := value;
end;

Function TFhirAuditEventSource.GetType_List : TFhirCodingList;
begin
  if FType_List = nil then
    FType_List := TFhirCodingList.Create;
  result := FType_List;
end;

Function TFhirAuditEventSource.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

function TFhirAuditEventSource.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSite.sizeInBytes);
  inc(result, FObserver.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
end;

{ TFhirAuditEventSourceListEnumerator }

Constructor TFhirAuditEventSourceListEnumerator.Create(list : TFhirAuditEventSourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventSourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventSourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventSourceListEnumerator.GetCurrent : TFhirAuditEventSource;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventSourceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAuditEventSourceList }
procedure TFhirAuditEventSourceList.AddItem(value: TFhirAuditEventSource);
begin
  assert(value.ClassName = 'TFhirAuditEventSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventSource');
  add(value);
end;

function TFhirAuditEventSourceList.Append: TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventSourceList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventSourceList.GetEnumerator : TFhirAuditEventSourceListEnumerator;
begin
  result := TFhirAuditEventSourceListEnumerator.Create(self.link);
end;

function TFhirAuditEventSourceList.Clone: TFhirAuditEventSourceList;
begin
  result := TFhirAuditEventSourceList(inherited Clone);
end;

function TFhirAuditEventSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventSourceList.GetItemN(index: Integer): TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource(ObjectByIndex[index]);
end;

function TFhirAuditEventSourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventSource;
end;
function TFhirAuditEventSourceList.IndexOf(value: TFhirAuditEventSource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventSourceList.Insert(index: Integer): TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventSourceList.InsertItem(index: Integer; value: TFhirAuditEventSource);
begin
  assert(value is TFhirAuditEventSource);
  Inherited Insert(index, value);
end;

function TFhirAuditEventSourceList.Item(index: Integer): TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource(ObjectByIndex[index]);
end;

function TFhirAuditEventSourceList.Link: TFhirAuditEventSourceList;
begin
  result := TFhirAuditEventSourceList(inherited Link);
end;

procedure TFhirAuditEventSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventSourceList.SetItemByIndex(index: Integer; value: TFhirAuditEventSource);
begin
  assert(value is TFhirAuditEventSource);
  FhirAuditEventSources[index] := value;
end;

procedure TFhirAuditEventSourceList.SetItemN(index: Integer; value: TFhirAuditEventSource);
begin
  assert(value is TFhirAuditEventSource);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventEntity }

constructor TFhirAuditEventEntity.Create;
begin
  inherited;
end;

destructor TFhirAuditEventEntity.Destroy;
begin
  FWhat.free;
  FType_.free;
  FRole.free;
  FLifecycle.free;
  FSecurityLabelList.Free;
  FName.free;
  FDescription.free;
  FQuery.free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirAuditEventEntity.Assign(oSource : TFslObject);
begin
  inherited;
  what := TFhirAuditEventEntity(oSource).what.Clone;
  type_ := TFhirAuditEventEntity(oSource).type_.Clone;
  role := TFhirAuditEventEntity(oSource).role.Clone;
  lifecycle := TFhirAuditEventEntity(oSource).lifecycle.Clone;
  if (TFhirAuditEventEntity(oSource).FSecurityLabelList = nil) then
  begin
    FSecurityLabelList.free;
    FSecurityLabelList := nil;
  end
  else
  begin
    if FSecurityLabelList = nil then
      FSecurityLabelList := TFhirCodingList.Create;
    FSecurityLabelList.Assign(TFhirAuditEventEntity(oSource).FSecurityLabelList);
  end;
  nameElement := TFhirAuditEventEntity(oSource).nameElement.Clone;
  descriptionElement := TFhirAuditEventEntity(oSource).descriptionElement.Clone;
  queryElement := TFhirAuditEventEntity(oSource).queryElement.Clone;
  if (TFhirAuditEventEntity(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirAuditEventEntityDetailList.Create;
    FDetailList.Assign(TFhirAuditEventEntity(oSource).FDetailList);
  end;
end;

procedure TFhirAuditEventEntity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'what') Then
     list.add(self.link, 'what', FWhat.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'lifecycle') Then
     list.add(self.link, 'lifecycle', FLifecycle.Link);
  if (child_name = 'securityLabel') Then
    list.addAll(self, 'securityLabel', FSecurityLabelList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'query') Then
     list.add(self.link, 'query', FQuery.Link);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirAuditEventEntity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'what', 'Reference(Any)', false, TFhirReference{TFhirReference}, FWhat.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'role', 'Coding', false, TFhirCoding, FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lifecycle', 'Coding', false, TFhirCoding, FLifecycle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'securityLabel', 'Coding', true, TFhirCoding, FSecurityLabelList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'query', 'base64Binary', false, TFhirBase64Binary, FQuery.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', '', true, TFhirAuditEventEntityDetail, FDetailList.Link)){3};
end;

function TFhirAuditEventEntity.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'what') then
  begin
    What := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'lifecycle') then
  begin
    Lifecycle := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'securityLabel') then
  begin
    SecurityLabelList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'query') then
  begin
    QueryElement := asBase64Binary(propValue){5a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirAuditEventEntityDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventEntity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'securityLabel') then SecurityLabelList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirAuditEventEntityDetail){2a}
  else inherited;
end;

function TFhirAuditEventEntity.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'what') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'role') then result := TFhirCoding.create(){4b}
  else if (propName = 'lifecycle') then result := TFhirCoding.create(){4b}
  else if (propName = 'securityLabel') then result := SecurityLabelList.new(){2}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'query') then result := TFhirBase64Binary.create() {5b}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventEntity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'what') then result := 'Reference'
  else if (propName = 'type') then result := 'Coding'
  else if (propName = 'role') then result := 'Coding'
  else if (propName = 'lifecycle') then result := 'Coding'
  else if (propName = 'securityLabel') then result := 'Coding'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'query') then result := 'base64Binary'
  else if (propName = 'detail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventEntity.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'what') then WhatElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'lifecycle') then LifecycleElement := nil
  else if (propName = 'securityLabel') then deletePropertyValue('securityLabel', SecurityLabelList, value) {2}
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'query') then QueryElement := nil
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventEntity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'what') then WhatElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'role') then RoleElement := new as TFhirCoding{4}
  else if (propName = 'lifecycle') then LifecycleElement := new as TFhirCoding{4}
  else if (propName = 'securityLabel') then replacePropertyValue('securityLabel', SecurityLabelList, existing, new) {2}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'query') then QueryElement := asBase64Binary(new){5b}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventEntity.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'securityLabel') then SecurityLabelList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventEntity.fhirType : string;
begin
  result := 'entity';
end;

function TFhirAuditEventEntity.Link : TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity(inherited Link);
end;

function TFhirAuditEventEntity.Clone : TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity(inherited Clone);
end;

function TFhirAuditEventEntity.equals(other : TObject) : boolean; 
var
  o : TFhirAuditEventEntity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventEntity)) then
    result := false
  else
  begin
    o := TFhirAuditEventEntity(other);
    result := compareDeep(whatElement, o.whatElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(roleElement, o.roleElement, true) and compareDeep(lifecycleElement, o.lifecycleElement, true) and 
      compareDeep(securityLabelList, o.securityLabelList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(queryElement, o.queryElement, true) and 
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirAuditEventEntity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FWhat) and isEmptyProp(FType_) and isEmptyProp(FRole) and isEmptyProp(FLifecycle) and isEmptyProp(FsecurityLabelList) and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FQuery) and isEmptyProp(FdetailList);
end;

procedure TFhirAuditEventEntity.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('what');
  fields.add('type');
  fields.add('role');
  fields.add('lifecycle');
  fields.add('securityLabel');
  fields.add('name');
  fields.add('description');
  fields.add('query');
  fields.add('detail');
end;

{ TFhirAuditEventEntity }

Procedure TFhirAuditEventEntity.SetWhat(value : TFhirReference{TFhirReference});
begin
  FWhat.free;
  FWhat := value;
end;

Procedure TFhirAuditEventEntity.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirAuditEventEntity.SetRole(value : TFhirCoding);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirAuditEventEntity.SetLifecycle(value : TFhirCoding);
begin
  FLifecycle.free;
  FLifecycle := value;
end;

Function TFhirAuditEventEntity.GetSecurityLabelList : TFhirCodingList;
begin
  if FSecurityLabelList = nil then
    FSecurityLabelList := TFhirCodingList.Create;
  result := FSecurityLabelList;
end;

Function TFhirAuditEventEntity.GetHasSecurityLabelList : boolean;
begin
  result := (FSecurityLabelList <> nil) and (FSecurityLabelList.count > 0);
end;

Procedure TFhirAuditEventEntity.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirAuditEventEntity.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirAuditEventEntity.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirAuditEventEntity.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirAuditEventEntity.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirAuditEventEntity.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirAuditEventEntity.SetQuery(value : TFhirBase64Binary);
begin
  FQuery.free;
  FQuery := value;
end;

Function TFhirAuditEventEntity.GetQueryST : TBytes;
begin
  if FQuery = nil then
    result := nil
  else
    result := FQuery.value;
end;

Procedure TFhirAuditEventEntity.SetQueryST(value : TBytes);
begin
  if value <> nil then
  begin
    if FQuery = nil then
      FQuery := TFhirBase64Binary.create;
    FQuery.value := value
  end
  else if FQuery <> nil then
    FQuery.value := nil;
end;

Function TFhirAuditEventEntity.GetDetailList : TFhirAuditEventEntityDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirAuditEventEntityDetailList.Create;
  result := FDetailList;
end;

Function TFhirAuditEventEntity.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirAuditEventEntity.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FWhat.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FRole.sizeInBytes);
  inc(result, FLifecycle.sizeInBytes);
  inc(result, FsecurityLabelList.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FQuery.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirAuditEventEntityListEnumerator }

Constructor TFhirAuditEventEntityListEnumerator.Create(list : TFhirAuditEventEntityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventEntityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventEntityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventEntityListEnumerator.GetCurrent : TFhirAuditEventEntity;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventEntityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAuditEventEntityList }
procedure TFhirAuditEventEntityList.AddItem(value: TFhirAuditEventEntity);
begin
  assert(value.ClassName = 'TFhirAuditEventEntity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventEntity');
  add(value);
end;

function TFhirAuditEventEntityList.Append: TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventEntityList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventEntityList.GetEnumerator : TFhirAuditEventEntityListEnumerator;
begin
  result := TFhirAuditEventEntityListEnumerator.Create(self.link);
end;

function TFhirAuditEventEntityList.Clone: TFhirAuditEventEntityList;
begin
  result := TFhirAuditEventEntityList(inherited Clone);
end;

function TFhirAuditEventEntityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventEntityList.GetItemN(index: Integer): TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity(ObjectByIndex[index]);
end;

function TFhirAuditEventEntityList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventEntity;
end;
function TFhirAuditEventEntityList.IndexOf(value: TFhirAuditEventEntity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventEntityList.Insert(index: Integer): TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventEntityList.InsertItem(index: Integer; value: TFhirAuditEventEntity);
begin
  assert(value is TFhirAuditEventEntity);
  Inherited Insert(index, value);
end;

function TFhirAuditEventEntityList.Item(index: Integer): TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity(ObjectByIndex[index]);
end;

function TFhirAuditEventEntityList.Link: TFhirAuditEventEntityList;
begin
  result := TFhirAuditEventEntityList(inherited Link);
end;

procedure TFhirAuditEventEntityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventEntityList.SetItemByIndex(index: Integer; value: TFhirAuditEventEntity);
begin
  assert(value is TFhirAuditEventEntity);
  FhirAuditEventEntities[index] := value;
end;

procedure TFhirAuditEventEntityList.SetItemN(index: Integer; value: TFhirAuditEventEntity);
begin
  assert(value is TFhirAuditEventEntity);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventEntityDetail }

constructor TFhirAuditEventEntityDetail.Create;
begin
  inherited;
end;

destructor TFhirAuditEventEntityDetail.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirAuditEventEntityDetail.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirAuditEventEntityDetail(oSource).type_Element.Clone;
  value := TFhirAuditEventEntityDetail(oSource).value.Clone;
end;

procedure TFhirAuditEventEntityDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirAuditEventEntityDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'string', false, TFhirString, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'string|base64Binary', false, TFhirType, FValue.Link));{2}
end;

function TFhirAuditEventEntityDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['String', 'Base64Binary'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventEntityDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAuditEventEntityDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'value', ['String', 'Base64Binary'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventEntityDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'string'
  else if (propName = 'value[x]') then result := 'string|base64Binary'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventEntityDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['String', 'Base64Binary'])) then ValueElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventEntityDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asString(new){5b}
  else if (isMatchingName(propName, 'value', ['String', 'Base64Binary'])) then ValueElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventEntityDetail.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventEntityDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirAuditEventEntityDetail.Link : TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail(inherited Link);
end;

function TFhirAuditEventEntityDetail.Clone : TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail(inherited Clone);
end;

function TFhirAuditEventEntityDetail.equals(other : TObject) : boolean; 
var
  o : TFhirAuditEventEntityDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventEntityDetail)) then
    result := false
  else
  begin
    o := TFhirAuditEventEntityDetail(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirAuditEventEntityDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirAuditEventEntityDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

{ TFhirAuditEventEntityDetail }

Procedure TFhirAuditEventEntityDetail.SetType_(value : TFhirString);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirAuditEventEntityDetail.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

Procedure TFhirAuditEventEntityDetail.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirString.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirAuditEventEntityDetail.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

function TFhirAuditEventEntityDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirAuditEventEntityDetailListEnumerator }

Constructor TFhirAuditEventEntityDetailListEnumerator.Create(list : TFhirAuditEventEntityDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventEntityDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventEntityDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventEntityDetailListEnumerator.GetCurrent : TFhirAuditEventEntityDetail;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventEntityDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAuditEventEntityDetailList }
procedure TFhirAuditEventEntityDetailList.AddItem(value: TFhirAuditEventEntityDetail);
begin
  assert(value.ClassName = 'TFhirAuditEventEntityDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventEntityDetail');
  add(value);
end;

function TFhirAuditEventEntityDetailList.Append: TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventEntityDetailList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventEntityDetailList.GetEnumerator : TFhirAuditEventEntityDetailListEnumerator;
begin
  result := TFhirAuditEventEntityDetailListEnumerator.Create(self.link);
end;

function TFhirAuditEventEntityDetailList.Clone: TFhirAuditEventEntityDetailList;
begin
  result := TFhirAuditEventEntityDetailList(inherited Clone);
end;

function TFhirAuditEventEntityDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventEntityDetailList.GetItemN(index: Integer): TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail(ObjectByIndex[index]);
end;

function TFhirAuditEventEntityDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventEntityDetail;
end;
function TFhirAuditEventEntityDetailList.IndexOf(value: TFhirAuditEventEntityDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventEntityDetailList.Insert(index: Integer): TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventEntityDetailList.InsertItem(index: Integer; value: TFhirAuditEventEntityDetail);
begin
  assert(value is TFhirAuditEventEntityDetail);
  Inherited Insert(index, value);
end;

function TFhirAuditEventEntityDetailList.Item(index: Integer): TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail(ObjectByIndex[index]);
end;

function TFhirAuditEventEntityDetailList.Link: TFhirAuditEventEntityDetailList;
begin
  result := TFhirAuditEventEntityDetailList(inherited Link);
end;

procedure TFhirAuditEventEntityDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventEntityDetailList.SetItemByIndex(index: Integer; value: TFhirAuditEventEntityDetail);
begin
  assert(value is TFhirAuditEventEntityDetail);
  FhirAuditEventEntityDetails[index] := value;
end;

procedure TFhirAuditEventEntityDetailList.SetItemN(index: Integer; value: TFhirAuditEventEntityDetail);
begin
  assert(value is TFhirAuditEventEntityDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEvent }

constructor TFhirAuditEvent.Create;
begin
  inherited;
end;

destructor TFhirAuditEvent.Destroy;
begin
  FType_.free;
  FSubtypeList.Free;
  FAction.free;
  FPeriod.free;
  FRecorded.free;
  FOutcome.free;
  FOutcomeDesc.free;
  FPurposeOfEventList.Free;
  FAgentList.Free;
  FSource.free;
  FEntityList.Free;
  inherited;
end;

function TFhirAuditEvent.GetResourceType : TFhirResourceType;
begin
  result := frtAuditEvent;
end;

procedure TFhirAuditEvent.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirAuditEvent(oSource).type_.Clone;
  if (TFhirAuditEvent(oSource).FSubtypeList = nil) then
  begin
    FSubtypeList.free;
    FSubtypeList := nil;
  end
  else
  begin
    if FSubtypeList = nil then
      FSubtypeList := TFhirCodingList.Create;
    FSubtypeList.Assign(TFhirAuditEvent(oSource).FSubtypeList);
  end;
  FAction := TFhirAuditEvent(oSource).FAction.Link;
  period := TFhirAuditEvent(oSource).period.Clone;
  recordedElement := TFhirAuditEvent(oSource).recordedElement.Clone;
  FOutcome := TFhirAuditEvent(oSource).FOutcome.Link;
  outcomeDescElement := TFhirAuditEvent(oSource).outcomeDescElement.Clone;
  if (TFhirAuditEvent(oSource).FPurposeOfEventList = nil) then
  begin
    FPurposeOfEventList.free;
    FPurposeOfEventList := nil;
  end
  else
  begin
    if FPurposeOfEventList = nil then
      FPurposeOfEventList := TFhirCodeableConceptList.Create;
    FPurposeOfEventList.Assign(TFhirAuditEvent(oSource).FPurposeOfEventList);
  end;
  if (TFhirAuditEvent(oSource).FAgentList = nil) then
  begin
    FAgentList.free;
    FAgentList := nil;
  end
  else
  begin
    if FAgentList = nil then
      FAgentList := TFhirAuditEventAgentList.Create;
    FAgentList.Assign(TFhirAuditEvent(oSource).FAgentList);
  end;
  source := TFhirAuditEvent(oSource).source.Clone;
  if (TFhirAuditEvent(oSource).FEntityList = nil) then
  begin
    FEntityList.free;
    FEntityList := nil;
  end
  else
  begin
    if FEntityList = nil then
      FEntityList := TFhirAuditEventEntityList.Create;
    FEntityList.Assign(TFhirAuditEvent(oSource).FEntityList);
  end;
end;

procedure TFhirAuditEvent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subtype') Then
    list.addAll(self, 'subtype', FSubtypeList);
  if (child_name = 'action') Then
     list.add(self.link, 'action', FAction.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'recorded') Then
     list.add(self.link, 'recorded', FRecorded.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'outcomeDesc') Then
     list.add(self.link, 'outcomeDesc', FOutcomeDesc.Link);
  if (child_name = 'purposeOfEvent') Then
    list.addAll(self, 'purposeOfEvent', FPurposeOfEventList);
  if (child_name = 'agent') Then
    list.addAll(self, 'agent', FAgentList);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'entity') Then
    list.addAll(self, 'entity', FEntityList);
end;

procedure TFhirAuditEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subtype', 'Coding', true, TFhirCoding, FSubtypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'action', 'code', false, TFHIREnum, FAction.Link));{1}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recorded', 'instant', false, TFhirInstant, FRecorded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFHIREnum, FOutcome.Link));{1}
  oList.add(TFHIRProperty.create(self, 'outcomeDesc', 'string', false, TFhirString, FOutcomeDesc.Link));{2}
  oList.add(TFHIRProperty.create(self, 'purposeOfEvent', 'CodeableConcept', true, TFhirCodeableConcept, FPurposeOfEventList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'agent', '', true, TFhirAuditEventAgent, FAgentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'source', '', false, TFhirAuditEventSource, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'entity', '', true, TFhirAuditEventEntity, FEntityList.Link)){3};
end;

function TFhirAuditEvent.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'subtype') then
  begin
    SubtypeList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionElement := asEnum(SYSTEMS_TFhirAuditEventActionEnum, CODES_TFhirAuditEventActionEnum, propValue);
    result := propValue
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'recorded') then
  begin
    RecordedElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirAuditEventOutcomeEnum, CODES_TFhirAuditEventOutcomeEnum, propValue);
    result := propValue
  end
  else if (propName = 'outcomeDesc') then
  begin
    OutcomeDescElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'purposeOfEvent') then
  begin
    PurposeOfEventList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'agent') then
  begin
    AgentList.add(propValue as TFhirAuditEventAgent){2a};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirAuditEventSource{4b};
    result := propValue;
  end
  else if (propName = 'entity') then
  begin
    EntityList.add(propValue as TFhirAuditEventEntity){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirAuditEvent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'subtype') then SubtypeList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'purposeOfEvent') then PurposeOfEventList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'agent') then AgentList.insertItem(index, propValue as TFhirAuditEventAgent){2a}
  else if (propName = 'entity') then EntityList.insertItem(index, propValue as TFhirAuditEventEntity){2a}
  else inherited;
end;

function TFhirAuditEvent.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'subtype') then result := SubtypeList.new(){2}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'recorded') then result := TFhirInstant.create() {5b}
  else if (propName = 'outcomeDesc') then result := TFhirString.create() {5b}
  else if (propName = 'purposeOfEvent') then result := PurposeOfEventList.new(){2}
  else if (propName = 'agent') then result := AgentList.new(){2}
  else if (propName = 'source') then result := TFhirAuditEventSource.create(){4b}
  else if (propName = 'entity') then result := EntityList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEvent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'Coding'
  else if (propName = 'subtype') then result := 'Coding'
  else if (propName = 'action') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'recorded') then result := 'instant'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'outcomeDesc') then result := 'string'
  else if (propName = 'purposeOfEvent') then result := 'CodeableConcept'
  else if (propName = 'agent') then result := ''
  else if (propName = 'source') then result := ''
  else if (propName = 'entity') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEvent.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'subtype') then deletePropertyValue('subtype', SubtypeList, value) {2}
  else if (propName = 'action') then ActionElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'recorded') then RecordedElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'outcomeDesc') then OutcomeDescElement := nil
  else if (propName = 'purposeOfEvent') then deletePropertyValue('purposeOfEvent', PurposeOfEventList, value) {2}
  else if (propName = 'agent') then deletePropertyValue('agent', AgentList, value) {2}
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'entity') then deletePropertyValue('entity', EntityList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEvent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'subtype') then replacePropertyValue('subtype', SubtypeList, existing, new) {2}
  else if (propName = 'action') then ActionElement := asEnum(SYSTEMS_TFhirAuditEventActionEnum, CODES_TFhirAuditEventActionEnum, new){4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'recorded') then RecordedElement := asInstant(new){5b}
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirAuditEventOutcomeEnum, CODES_TFhirAuditEventOutcomeEnum, new){4}
  else if (propName = 'outcomeDesc') then OutcomeDescElement := asString(new){5b}
  else if (propName = 'purposeOfEvent') then replacePropertyValue('purposeOfEvent', PurposeOfEventList, existing, new) {2}
  else if (propName = 'agent') then replacePropertyValue('agent', AgentList, existing, new) {2}
  else if (propName = 'source') then SourceElement := new as TFhirAuditEventSource{4}
  else if (propName = 'entity') then replacePropertyValue('entity', EntityList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEvent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'subtype') then SubtypeList.move(source, destination){2a}
  else if (propName = 'purposeOfEvent') then PurposeOfEventList.move(source, destination){2a}
  else if (propName = 'agent') then AgentList.move(source, destination){2a}
  else if (propName = 'entity') then EntityList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEvent.fhirType : string;
begin
  result := 'AuditEvent';
end;

function TFhirAuditEvent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FsubtypeList) and isEmptyProp(FAction) and isEmptyProp(FPeriod) and isEmptyProp(FRecorded) and isEmptyProp(FOutcome) and isEmptyProp(FOutcomeDesc) and isEmptyProp(FpurposeOfEventList) and isEmptyProp(FagentList) and isEmptyProp(FSource) and isEmptyProp(FentityList);
end;

function TFhirAuditEvent.equals(other : TObject) : boolean; 
var
  o : TFhirAuditEvent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEvent)) then
    result := false
  else
  begin
    o := TFhirAuditEvent(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(subtypeList, o.subtypeList, true) and 
      compareDeep(actionElement, o.actionElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(recordedElement, o.recordedElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and 
      compareDeep(outcomeDescElement, o.outcomeDescElement, true) and compareDeep(purposeOfEventList, o.purposeOfEventList, true) and 
      compareDeep(agentList, o.agentList, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(entityList, o.entityList, true);
  end;
end;

function TFhirAuditEvent.Link : TFhirAuditEvent;
begin
  result := TFhirAuditEvent(inherited Link);
end;

function TFhirAuditEvent.Clone : TFhirAuditEvent;
begin
  result := TFhirAuditEvent(inherited Clone);
end;

procedure TFhirAuditEvent.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('type');
  fields.add('subtype');
  fields.add('action');
  fields.add('period');
  fields.add('recorded');
  fields.add('outcome');
  fields.add('outcomeDesc');
  fields.add('purposeOfEvent');
  fields.add('agent');
  fields.add('source');
  fields.add('entity');
end;

{ TFhirAuditEvent }

Procedure TFhirAuditEvent.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirAuditEvent.GetSubtypeList : TFhirCodingList;
begin
  if FSubtypeList = nil then
    FSubtypeList := TFhirCodingList.Create;
  result := FSubtypeList;
end;

Function TFhirAuditEvent.GetHasSubtypeList : boolean;
begin
  result := (FSubtypeList <> nil) and (FSubtypeList.count > 0);
end;

Procedure TFhirAuditEvent.SetAction(value : TFhirEnum);
begin
  FAction.free;
  FAction := value;
end;

Function TFhirAuditEvent.GetActionST : TFhirAuditEventActionEnum;
begin
  if FAction = nil then
    result := TFhirAuditEventActionEnum(0)
  else
    result := TFhirAuditEventActionEnum(StringArrayIndexOfSensitive(CODES_TFhirAuditEventActionEnum, FAction.value));
end;

Procedure TFhirAuditEvent.SetActionST(value : TFhirAuditEventActionEnum);
begin
  if ord(value) = 0 then
    ActionElement := nil
  else
    ActionElement := TFhirEnum.create(SYSTEMS_TFhirAuditEventActionEnum[value], CODES_TFhirAuditEventActionEnum[value]);
end;

Procedure TFhirAuditEvent.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirAuditEvent.SetRecorded(value : TFhirInstant);
begin
  FRecorded.free;
  FRecorded := value;
end;

Function TFhirAuditEvent.GetRecordedST : TFslDateTime;
begin
  if FRecorded = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecorded.value;
end;

Procedure TFhirAuditEvent.SetRecordedST(value : TFslDateTime);
begin
  if FRecorded = nil then
    FRecorded := TFhirInstant.create;
  FRecorded.value := value
end;

Procedure TFhirAuditEvent.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirAuditEvent.GetOutcomeST : TFhirAuditEventOutcomeEnum;
begin
  if FOutcome = nil then
    result := TFhirAuditEventOutcomeEnum(0)
  else
    result := TFhirAuditEventOutcomeEnum(StringArrayIndexOfSensitive(CODES_TFhirAuditEventOutcomeEnum, FOutcome.value));
end;

Procedure TFhirAuditEvent.SetOutcomeST(value : TFhirAuditEventOutcomeEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirAuditEventOutcomeEnum[value], CODES_TFhirAuditEventOutcomeEnum[value]);
end;

Procedure TFhirAuditEvent.SetOutcomeDesc(value : TFhirString);
begin
  FOutcomeDesc.free;
  FOutcomeDesc := value;
end;

Function TFhirAuditEvent.GetOutcomeDescST : String;
begin
  if FOutcomeDesc = nil then
    result := ''
  else
    result := FOutcomeDesc.value;
end;

Procedure TFhirAuditEvent.SetOutcomeDescST(value : String);
begin
  if value <> '' then
  begin
    if FOutcomeDesc = nil then
      FOutcomeDesc := TFhirString.create;
    FOutcomeDesc.value := value
  end
  else if FOutcomeDesc <> nil then
    FOutcomeDesc.value := '';
end;

Function TFhirAuditEvent.GetPurposeOfEventList : TFhirCodeableConceptList;
begin
  if FPurposeOfEventList = nil then
    FPurposeOfEventList := TFhirCodeableConceptList.Create;
  result := FPurposeOfEventList;
end;

Function TFhirAuditEvent.GetHasPurposeOfEventList : boolean;
begin
  result := (FPurposeOfEventList <> nil) and (FPurposeOfEventList.count > 0);
end;

Function TFhirAuditEvent.GetAgentList : TFhirAuditEventAgentList;
begin
  if FAgentList = nil then
    FAgentList := TFhirAuditEventAgentList.Create;
  result := FAgentList;
end;

Function TFhirAuditEvent.GetHasAgentList : boolean;
begin
  result := (FAgentList <> nil) and (FAgentList.count > 0);
end;

Procedure TFhirAuditEvent.SetSource(value : TFhirAuditEventSource);
begin
  FSource.free;
  FSource := value;
end;

Function TFhirAuditEvent.GetEntityList : TFhirAuditEventEntityList;
begin
  if FEntityList = nil then
    FEntityList := TFhirAuditEventEntityList.Create;
  result := FEntityList;
end;

Function TFhirAuditEvent.GetHasEntityList : boolean;
begin
  result := (FEntityList <> nil) and (FEntityList.count > 0);
end;

function TFhirAuditEvent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FsubtypeList.sizeInBytes);
  inc(result, FAction.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FRecorded.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FOutcomeDesc.sizeInBytes);
  inc(result, FpurposeOfEventList.sizeInBytes);
  inc(result, FagentList.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FentityList.sizeInBytes);
end;

{ TFhirAuditEventListEnumerator }

Constructor TFhirAuditEventListEnumerator.Create(list : TFhirAuditEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventListEnumerator.GetCurrent : TFhirAuditEvent;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAuditEventList }
procedure TFhirAuditEventList.AddItem(value: TFhirAuditEvent);
begin
  assert(value.ClassName = 'TFhirAuditEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEvent');
  add(value);
end;

function TFhirAuditEventList.Append: TFhirAuditEvent;
begin
  result := TFhirAuditEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventList.GetEnumerator : TFhirAuditEventListEnumerator;
begin
  result := TFhirAuditEventListEnumerator.Create(self.link);
end;

function TFhirAuditEventList.Clone: TFhirAuditEventList;
begin
  result := TFhirAuditEventList(inherited Clone);
end;

function TFhirAuditEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventList.GetItemN(index: Integer): TFhirAuditEvent;
begin
  result := TFhirAuditEvent(ObjectByIndex[index]);
end;

function TFhirAuditEventList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEvent;
end;
function TFhirAuditEventList.IndexOf(value: TFhirAuditEvent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventList.Insert(index: Integer): TFhirAuditEvent;
begin
  result := TFhirAuditEvent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventList.InsertItem(index: Integer; value: TFhirAuditEvent);
begin
  assert(value is TFhirAuditEvent);
  Inherited Insert(index, value);
end;

function TFhirAuditEventList.Item(index: Integer): TFhirAuditEvent;
begin
  result := TFhirAuditEvent(ObjectByIndex[index]);
end;

function TFhirAuditEventList.Link: TFhirAuditEventList;
begin
  result := TFhirAuditEventList(inherited Link);
end;

procedure TFhirAuditEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventList.SetItemByIndex(index: Integer; value: TFhirAuditEvent);
begin
  assert(value is TFhirAuditEvent);
  FhirAuditEvents[index] := value;
end;

procedure TFhirAuditEventList.SetItemN(index: Integer; value: TFhirAuditEvent);
begin
  assert(value is TFhirAuditEvent);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_AUDITEVENT}

{$IFDEF FHIR_BINARY}

{ TFhirBinary }

constructor TFhirBinary.Create;
begin
  inherited;
end;

destructor TFhirBinary.Destroy;
begin
  FContentType.free;
  FSecurityContext.free;
  FData.free;
  inherited;
end;

function TFhirBinary.GetResourceType : TFhirResourceType;
begin
  result := frtBinary;
end;

procedure TFhirBinary.Assign(oSource : TFslObject);
begin
  inherited;
  contentTypeElement := TFhirBinary(oSource).contentTypeElement.Clone;
  securityContext := TFhirBinary(oSource).securityContext.Clone;
  dataElement := TFhirBinary(oSource).dataElement.Clone;
end;

procedure TFhirBinary.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'contentType') Then
     list.add(self.link, 'contentType', FContentType.Link);
  if (child_name = 'securityContext') Then
     list.add(self.link, 'securityContext', FSecurityContext.Link);
  if (child_name = 'data') Then
     list.add(self.link, 'data', FData.Link);
end;

procedure TFhirBinary.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'contentType', 'code', false, TFhirCode, FContentType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'securityContext', 'Reference(Any)', false, TFhirReference{TFhirReference}, FSecurityContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'data', 'base64Binary', false, TFhirBase64Binary, FData.Link));{2}
end;

function TFhirBinary.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'contentType') then
  begin
    ContentTypeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'securityContext') then
  begin
    SecurityContext := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'data') then
  begin
    DataElement := asBase64Binary(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirBinary.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBinary.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'contentType') then result := TFhirCode.create() {5b}
  else if (propName = 'securityContext') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'data') then result := TFhirBase64Binary.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBinary.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'contentType') then result := 'code'
  else if (propName = 'securityContext') then result := 'Reference'
  else if (propName = 'data') then result := 'base64Binary'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBinary.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'contentType') then ContentTypeElement := nil
  else if (propName = 'securityContext') then SecurityContextElement := nil
  else if (propName = 'data') then DataElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBinary.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'contentType') then ContentTypeElement := asCode(new){5b}
  else if (propName = 'securityContext') then SecurityContextElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'data') then DataElement := asBase64Binary(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBinary.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBinary.fhirType : string;
begin
  result := 'Binary';
end;

function TFhirBinary.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContentType) and isEmptyProp(FSecurityContext) and isEmptyProp(FData);
end;

function TFhirBinary.equals(other : TObject) : boolean; 
var
  o : TFhirBinary;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBinary)) then
    result := false
  else
  begin
    o := TFhirBinary(other);
    result := compareDeep(contentTypeElement, o.contentTypeElement, true) and compareDeep(securityContextElement, o.securityContextElement, true) and 
      compareDeep(dataElement, o.dataElement, true);
  end;
end;

function TFhirBinary.Link : TFhirBinary;
begin
  result := TFhirBinary(inherited Link);
end;

function TFhirBinary.Clone : TFhirBinary;
begin
  result := TFhirBinary(inherited Clone);
end;

procedure TFhirBinary.listFieldsInOrder(fields : TStringList);
begin
  listResourceFieldsInOrder(fields);
  fields.add('contentType');
  fields.add('securityContext');
  fields.add('data');
end;

{ TFhirBinary }

Procedure TFhirBinary.SetContentType(value : TFhirCode);
begin
  FContentType.free;
  FContentType := value;
end;

Function TFhirBinary.GetContentTypeST : String;
begin
  if FContentType = nil then
    result := ''
  else
    result := FContentType.value;
end;

Procedure TFhirBinary.SetContentTypeST(value : String);
begin
  if value <> '' then
  begin
    if FContentType = nil then
      FContentType := TFhirCode.create;
    FContentType.value := value
  end
  else if FContentType <> nil then
    FContentType.value := '';
end;

Procedure TFhirBinary.SetSecurityContext(value : TFhirReference{TFhirReference});
begin
  FSecurityContext.free;
  FSecurityContext := value;
end;

Procedure TFhirBinary.SetData(value : TFhirBase64Binary);
begin
  FData.free;
  FData := value;
end;

Function TFhirBinary.GetDataST : TBytes;
begin
  if FData = nil then
    result := nil
  else
    result := FData.value;
end;

Procedure TFhirBinary.SetDataST(value : TBytes);
begin
  if value <> nil then
  begin
    if FData = nil then
      FData := TFhirBase64Binary.create;
    FData.value := value
  end
  else if FData <> nil then
    FData.value := nil;
end;

function TFhirBinary.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContentType.sizeInBytes);
  inc(result, FSecurityContext.sizeInBytes);
  inc(result, FData.sizeInBytes);
end;

{ TFhirBinaryListEnumerator }

Constructor TFhirBinaryListEnumerator.Create(list : TFhirBinaryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBinaryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBinaryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBinaryListEnumerator.GetCurrent : TFhirBinary;
begin
  Result := FList[FIndex];
end;

function TFhirBinaryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBinaryList }
procedure TFhirBinaryList.AddItem(value: TFhirBinary);
begin
  assert(value.ClassName = 'TFhirBinary', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBinary');
  add(value);
end;

function TFhirBinaryList.Append: TFhirBinary;
begin
  result := TFhirBinary.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBinaryList.ClearItems;
begin
  Clear;
end;

function TFhirBinaryList.GetEnumerator : TFhirBinaryListEnumerator;
begin
  result := TFhirBinaryListEnumerator.Create(self.link);
end;

function TFhirBinaryList.Clone: TFhirBinaryList;
begin
  result := TFhirBinaryList(inherited Clone);
end;

function TFhirBinaryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBinaryList.GetItemN(index: Integer): TFhirBinary;
begin
  result := TFhirBinary(ObjectByIndex[index]);
end;

function TFhirBinaryList.ItemClass: TFslObjectClass;
begin
  result := TFhirBinary;
end;
function TFhirBinaryList.IndexOf(value: TFhirBinary): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBinaryList.Insert(index: Integer): TFhirBinary;
begin
  result := TFhirBinary.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBinaryList.InsertItem(index: Integer; value: TFhirBinary);
begin
  assert(value is TFhirBinary);
  Inherited Insert(index, value);
end;

function TFhirBinaryList.Item(index: Integer): TFhirBinary;
begin
  result := TFhirBinary(ObjectByIndex[index]);
end;

function TFhirBinaryList.Link: TFhirBinaryList;
begin
  result := TFhirBinaryList(inherited Link);
end;

procedure TFhirBinaryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBinaryList.SetItemByIndex(index: Integer; value: TFhirBinary);
begin
  assert(value is TFhirBinary);
  FhirBinaries[index] := value;
end;

procedure TFhirBinaryList.SetItemN(index: Integer; value: TFhirBinary);
begin
  assert(value is TFhirBinary);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BINARY}

{$IFDEF FHIR_BUNDLE}

{ TFhirBundleLink }

constructor TFhirBundleLink.Create;
begin
  inherited;
end;

destructor TFhirBundleLink.Destroy;
begin
  FRelation.free;
  FUrl.free;
  inherited;
end;

procedure TFhirBundleLink.Assign(oSource : TFslObject);
begin
  inherited;
  relationElement := TFhirBundleLink(oSource).relationElement.Clone;
  urlElement := TFhirBundleLink(oSource).urlElement.Clone;
end;

procedure TFhirBundleLink.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'relation') Then
     list.add(self.link, 'relation', FRelation.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
end;

procedure TFhirBundleLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'relation', 'string', false, TFhirString, FRelation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
end;

function TFhirBundleLink.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'relation') then
  begin
    RelationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleLink.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBundleLink.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'relation') then result := TFhirString.create() {5b}
  else if (propName = 'url') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleLink.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'relation') then result := 'string'
  else if (propName = 'url') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleLink.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'relation') then RelationElement := nil
  else if (propName = 'url') then UrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleLink.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'relation') then RelationElement := asString(new){5b}
  else if (propName = 'url') then UrlElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleLink.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleLink.fhirType : string;
begin
  result := 'link';
end;

function TFhirBundleLink.Link : TFhirBundleLink;
begin
  result := TFhirBundleLink(inherited Link);
end;

function TFhirBundleLink.Clone : TFhirBundleLink;
begin
  result := TFhirBundleLink(inherited Clone);
end;

function TFhirBundleLink.equals(other : TObject) : boolean; 
var
  o : TFhirBundleLink;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleLink)) then
    result := false
  else
  begin
    o := TFhirBundleLink(other);
    result := compareDeep(relationElement, o.relationElement, true) and compareDeep(urlElement, o.urlElement, true);
  end;
end;

function TFhirBundleLink.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRelation) and isEmptyProp(FUrl);
end;

procedure TFhirBundleLink.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('relation');
  fields.add('url');
end;

{ TFhirBundleLink }

Procedure TFhirBundleLink.SetRelation(value : TFhirString);
begin
  FRelation.free;
  FRelation := value;
end;

Function TFhirBundleLink.GetRelationST : String;
begin
  if FRelation = nil then
    result := ''
  else
    result := FRelation.value;
end;

Procedure TFhirBundleLink.SetRelationST(value : String);
begin
  if value <> '' then
  begin
    if FRelation = nil then
      FRelation := TFhirString.create;
    FRelation.value := value
  end
  else if FRelation <> nil then
    FRelation.value := '';
end;

Procedure TFhirBundleLink.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirBundleLink.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirBundleLink.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirBundleLink.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRelation.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
end;

{ TFhirBundleLinkListEnumerator }

Constructor TFhirBundleLinkListEnumerator.Create(list : TFhirBundleLinkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleLinkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleLinkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleLinkListEnumerator.GetCurrent : TFhirBundleLink;
begin
  Result := FList[FIndex];
end;

function TFhirBundleLinkListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBundleLinkList }
procedure TFhirBundleLinkList.AddItem(value: TFhirBundleLink);
begin
  assert(value.ClassName = 'TFhirBundleLink', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleLink');
  add(value);
end;

function TFhirBundleLinkList.Append: TFhirBundleLink;
begin
  result := TFhirBundleLink.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleLinkList.ClearItems;
begin
  Clear;
end;

function TFhirBundleLinkList.GetEnumerator : TFhirBundleLinkListEnumerator;
begin
  result := TFhirBundleLinkListEnumerator.Create(self.link);
end;

function TFhirBundleLinkList.Clone: TFhirBundleLinkList;
begin
  result := TFhirBundleLinkList(inherited Clone);
end;

function TFhirBundleLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleLinkList.GetItemN(index: Integer): TFhirBundleLink;
begin
  result := TFhirBundleLink(ObjectByIndex[index]);
end;

function TFhirBundleLinkList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleLink;
end;
function TFhirBundleLinkList.IndexOf(value: TFhirBundleLink): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleLinkList.Insert(index: Integer): TFhirBundleLink;
begin
  result := TFhirBundleLink.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleLinkList.InsertItem(index: Integer; value: TFhirBundleLink);
begin
  assert(value is TFhirBundleLink);
  Inherited Insert(index, value);
end;

function TFhirBundleLinkList.Item(index: Integer): TFhirBundleLink;
begin
  result := TFhirBundleLink(ObjectByIndex[index]);
end;

function TFhirBundleLinkList.Link: TFhirBundleLinkList;
begin
  result := TFhirBundleLinkList(inherited Link);
end;

procedure TFhirBundleLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleLinkList.SetItemByIndex(index: Integer; value: TFhirBundleLink);
begin
  assert(value is TFhirBundleLink);
  FhirBundleLinks[index] := value;
end;

procedure TFhirBundleLinkList.SetItemN(index: Integer; value: TFhirBundleLink);
begin
  assert(value is TFhirBundleLink);
  ObjectByIndex[index] := value;
end;

{ TFhirBundleEntry }

constructor TFhirBundleEntry.Create;
begin
  inherited;
end;

destructor TFhirBundleEntry.Destroy;
begin
  FLink_List.Free;
  FFullUrl.free;
  FResource.free;
  FSearch.free;
  FRequest.free;
  FResponse.free;
  inherited;
end;

procedure TFhirBundleEntry.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirBundleEntry(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirBundleLinkList.Create;
    FLink_List.Assign(TFhirBundleEntry(oSource).FLink_List);
  end;
  fullUrlElement := TFhirBundleEntry(oSource).fullUrlElement.Clone;
  resource := TFhirBundleEntry(oSource).resource.Clone;
  search := TFhirBundleEntry(oSource).search.Clone;
  request := TFhirBundleEntry(oSource).request.Clone;
  response := TFhirBundleEntry(oSource).response.Clone;
end;

procedure TFhirBundleEntry.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
  if (child_name = 'fullUrl') Then
     list.add(self.link, 'fullUrl', FFullUrl.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'search') Then
     list.add(self.link, 'search', FSearch.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
end;

procedure TFhirBundleEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'link', '@Bundle.link', true, TFhirBundleLink, FLink_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'fullUrl', 'uri', false, TFhirUri, FFullUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', 'Resource', false, TFhirResource, FResource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'search', '', false, TFhirBundleEntrySearch, FSearch.Link));{2}
  oList.add(TFHIRProperty.create(self, 'request', '', false, TFhirBundleEntryRequest, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'response', '', false, TFhirBundleEntryResponse, FResponse.Link));{2}
end;

function TFhirBundleEntry.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirBundleLink){2a};
    result := propValue;
  end
  else if (propName = 'fullUrl') then
  begin
    FullUrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirResource{4b};
    result := propValue;
  end
  else if (propName = 'search') then
  begin
    Search := propValue as TFhirBundleEntrySearch{4b};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirBundleEntryRequest{4b};
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirBundleEntryResponse{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleEntry.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirBundleLink){2a}
  else inherited;
end;

function TFhirBundleEntry.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'link') then result := Link_List.new(){2}
  else if (propName = 'fullUrl') then result := TFhirUri.create() {5b}
  else if (propName = 'resource') then raise EFHIRException.create('Cannot make property Resource')
  else if (propName = 'search') then result := TFhirBundleEntrySearch.create(){4b}
  else if (propName = 'request') then result := TFhirBundleEntryRequest.create(){4b}
  else if (propName = 'response') then result := TFhirBundleEntryResponse.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleEntry.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'link') then result := '@Bundle.link'
  else if (propName = 'fullUrl') then result := 'uri'
  else if (propName = 'resource') then result := 'Resource'
  else if (propName = 'search') then result := ''
  else if (propName = 'request') then result := ''
  else if (propName = 'response') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleEntry.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'link') then deletePropertyValue('link', Link_List, value) {2}
  else if (propName = 'fullUrl') then FullUrlElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'search') then SearchElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleEntry.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new) {2}
  else if (propName = 'fullUrl') then FullUrlElement := asUri(new){5b}
  else if (propName = 'resource') then ResourceElement := new as TFhirResource{4}
  else if (propName = 'search') then SearchElement := new as TFhirBundleEntrySearch{4}
  else if (propName = 'request') then RequestElement := new as TFhirBundleEntryRequest{4}
  else if (propName = 'response') then ResponseElement := new as TFhirBundleEntryResponse{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleEntry.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'link') then Link_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleEntry.fhirType : string;
begin
  result := 'entry';
end;

function TFhirBundleEntry.Link : TFhirBundleEntry;
begin
  result := TFhirBundleEntry(inherited Link);
end;

function TFhirBundleEntry.Clone : TFhirBundleEntry;
begin
  result := TFhirBundleEntry(inherited Clone);
end;

function TFhirBundleEntry.equals(other : TObject) : boolean; 
var
  o : TFhirBundleEntry;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleEntry)) then
    result := false
  else
  begin
    o := TFhirBundleEntry(other);
    result := compareDeep(link_List, o.link_List, true) and compareDeep(fullUrlElement, o.fullUrlElement, true) and 
      compareDeep(resourceElement, o.resourceElement, true) and compareDeep(searchElement, o.searchElement, true) and 
      compareDeep(requestElement, o.requestElement, true) and compareDeep(responseElement, o.responseElement, true);
  end;
end;

function TFhirBundleEntry.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Flink_List) and isEmptyProp(FFullUrl) and isEmptyProp(FResource) and isEmptyProp(FSearch) and isEmptyProp(FRequest) and isEmptyProp(FResponse);
end;

procedure TFhirBundleEntry.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('link');
  fields.add('fullUrl');
  fields.add('resource');
  fields.add('search');
  fields.add('request');
  fields.add('response');
end;

{ TFhirBundleEntry }

Function TFhirBundleEntry.GetLink_List : TFhirBundleLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirBundleLinkList.Create;
  result := FLink_List;
end;

Function TFhirBundleEntry.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

Procedure TFhirBundleEntry.SetFullUrl(value : TFhirUri);
begin
  FFullUrl.free;
  FFullUrl := value;
end;

Function TFhirBundleEntry.GetFullUrlST : String;
begin
  if FFullUrl = nil then
    result := ''
  else
    result := FFullUrl.value;
end;

Procedure TFhirBundleEntry.SetFullUrlST(value : String);
begin
  if value <> '' then
  begin
    if FFullUrl = nil then
      FFullUrl := TFhirUri.create;
    FFullUrl.value := value
  end
  else if FFullUrl <> nil then
    FFullUrl.value := '';
end;

Procedure TFhirBundleEntry.SetResource(value : TFhirResource);
begin
  FResource.free;
  FResource := value;
end;

Procedure TFhirBundleEntry.SetSearch(value : TFhirBundleEntrySearch);
begin
  FSearch.free;
  FSearch := value;
end;

Procedure TFhirBundleEntry.SetRequest(value : TFhirBundleEntryRequest);
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirBundleEntry.SetResponse(value : TFhirBundleEntryResponse);
begin
  FResponse.free;
  FResponse := value;
end;

function TFhirBundleEntry.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, Flink_List.sizeInBytes);
  inc(result, FFullUrl.sizeInBytes);
  inc(result, FResource.sizeInBytes);
  inc(result, FSearch.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FResponse.sizeInBytes);
end;

{ TFhirBundleEntryListEnumerator }

Constructor TFhirBundleEntryListEnumerator.Create(list : TFhirBundleEntryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleEntryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleEntryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleEntryListEnumerator.GetCurrent : TFhirBundleEntry;
begin
  Result := FList[FIndex];
end;

function TFhirBundleEntryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBundleEntryList }
procedure TFhirBundleEntryList.AddItem(value: TFhirBundleEntry);
begin
  assert(value.ClassName = 'TFhirBundleEntry', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleEntry');
  add(value);
end;

function TFhirBundleEntryList.Append: TFhirBundleEntry;
begin
  result := TFhirBundleEntry.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryList.ClearItems;
begin
  Clear;
end;

function TFhirBundleEntryList.GetEnumerator : TFhirBundleEntryListEnumerator;
begin
  result := TFhirBundleEntryListEnumerator.Create(self.link);
end;

function TFhirBundleEntryList.Clone: TFhirBundleEntryList;
begin
  result := TFhirBundleEntryList(inherited Clone);
end;

function TFhirBundleEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleEntryList.GetItemN(index: Integer): TFhirBundleEntry;
begin
  result := TFhirBundleEntry(ObjectByIndex[index]);
end;

function TFhirBundleEntryList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleEntry;
end;
function TFhirBundleEntryList.IndexOf(value: TFhirBundleEntry): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleEntryList.Insert(index: Integer): TFhirBundleEntry;
begin
  result := TFhirBundleEntry.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryList.InsertItem(index: Integer; value: TFhirBundleEntry);
begin
  assert(value is TFhirBundleEntry);
  Inherited Insert(index, value);
end;

function TFhirBundleEntryList.Item(index: Integer): TFhirBundleEntry;
begin
  result := TFhirBundleEntry(ObjectByIndex[index]);
end;

function TFhirBundleEntryList.Link: TFhirBundleEntryList;
begin
  result := TFhirBundleEntryList(inherited Link);
end;

procedure TFhirBundleEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleEntryList.SetItemByIndex(index: Integer; value: TFhirBundleEntry);
begin
  assert(value is TFhirBundleEntry);
  FhirBundleEntries[index] := value;
end;

procedure TFhirBundleEntryList.SetItemN(index: Integer; value: TFhirBundleEntry);
begin
  assert(value is TFhirBundleEntry);
  ObjectByIndex[index] := value;
end;

{ TFhirBundleEntrySearch }

constructor TFhirBundleEntrySearch.Create;
begin
  inherited;
end;

destructor TFhirBundleEntrySearch.Destroy;
begin
  FMode.free;
  FScore.free;
  inherited;
end;

procedure TFhirBundleEntrySearch.Assign(oSource : TFslObject);
begin
  inherited;
  FMode := TFhirBundleEntrySearch(oSource).FMode.Link;
  scoreElement := TFhirBundleEntrySearch(oSource).scoreElement.Clone;
end;

procedure TFhirBundleEntrySearch.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'score') Then
     list.add(self.link, 'score', FScore.Link);
end;

procedure TFhirBundleEntrySearch.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFHIREnum, FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'score', 'decimal', false, TFhirDecimal, FScore.Link));{2}
end;

function TFhirBundleEntrySearch.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirSearchEntryModeEnum, CODES_TFhirSearchEntryModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'score') then
  begin
    ScoreElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleEntrySearch.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBundleEntrySearch.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'score') then result := TFhirDecimal.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleEntrySearch.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'mode') then result := 'code'
  else if (propName = 'score') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleEntrySearch.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := nil
  else if (propName = 'score') then ScoreElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleEntrySearch.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirSearchEntryModeEnum, CODES_TFhirSearchEntryModeEnum, new){4}
  else if (propName = 'score') then ScoreElement := asDecimal(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleEntrySearch.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleEntrySearch.fhirType : string;
begin
  result := 'search';
end;

function TFhirBundleEntrySearch.Link : TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch(inherited Link);
end;

function TFhirBundleEntrySearch.Clone : TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch(inherited Clone);
end;

function TFhirBundleEntrySearch.equals(other : TObject) : boolean; 
var
  o : TFhirBundleEntrySearch;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleEntrySearch)) then
    result := false
  else
  begin
    o := TFhirBundleEntrySearch(other);
    result := compareDeep(modeElement, o.modeElement, true) and compareDeep(scoreElement, o.scoreElement, true);
  end;
end;

function TFhirBundleEntrySearch.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMode) and isEmptyProp(FScore);
end;

procedure TFhirBundleEntrySearch.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('mode');
  fields.add('score');
end;

{ TFhirBundleEntrySearch }

Procedure TFhirBundleEntrySearch.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirBundleEntrySearch.GetModeST : TFhirSearchEntryModeEnum;
begin
  if FMode = nil then
    result := TFhirSearchEntryModeEnum(0)
  else
    result := TFhirSearchEntryModeEnum(StringArrayIndexOfSensitive(CODES_TFhirSearchEntryModeEnum, FMode.value));
end;

Procedure TFhirBundleEntrySearch.SetModeST(value : TFhirSearchEntryModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirSearchEntryModeEnum[value], CODES_TFhirSearchEntryModeEnum[value]);
end;

Procedure TFhirBundleEntrySearch.SetScore(value : TFhirDecimal);
begin
  FScore.free;
  FScore := value;
end;

Function TFhirBundleEntrySearch.GetScoreST : String;
begin
  if FScore = nil then
    result := ''
  else
    result := FScore.value;
end;

Procedure TFhirBundleEntrySearch.SetScoreST(value : String);
begin
  if value <> '' then
  begin
    if FScore = nil then
      FScore := TFhirDecimal.create;
    FScore.value := value
  end
  else if FScore <> nil then
    FScore.value := '';
end;

function TFhirBundleEntrySearch.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMode.sizeInBytes);
  inc(result, FScore.sizeInBytes);
end;

{ TFhirBundleEntrySearchListEnumerator }

Constructor TFhirBundleEntrySearchListEnumerator.Create(list : TFhirBundleEntrySearchList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleEntrySearchListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleEntrySearchListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleEntrySearchListEnumerator.GetCurrent : TFhirBundleEntrySearch;
begin
  Result := FList[FIndex];
end;

function TFhirBundleEntrySearchListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBundleEntrySearchList }
procedure TFhirBundleEntrySearchList.AddItem(value: TFhirBundleEntrySearch);
begin
  assert(value.ClassName = 'TFhirBundleEntrySearch', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleEntrySearch');
  add(value);
end;

function TFhirBundleEntrySearchList.Append: TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntrySearchList.ClearItems;
begin
  Clear;
end;

function TFhirBundleEntrySearchList.GetEnumerator : TFhirBundleEntrySearchListEnumerator;
begin
  result := TFhirBundleEntrySearchListEnumerator.Create(self.link);
end;

function TFhirBundleEntrySearchList.Clone: TFhirBundleEntrySearchList;
begin
  result := TFhirBundleEntrySearchList(inherited Clone);
end;

function TFhirBundleEntrySearchList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleEntrySearchList.GetItemN(index: Integer): TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch(ObjectByIndex[index]);
end;

function TFhirBundleEntrySearchList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleEntrySearch;
end;
function TFhirBundleEntrySearchList.IndexOf(value: TFhirBundleEntrySearch): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleEntrySearchList.Insert(index: Integer): TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntrySearchList.InsertItem(index: Integer; value: TFhirBundleEntrySearch);
begin
  assert(value is TFhirBundleEntrySearch);
  Inherited Insert(index, value);
end;

function TFhirBundleEntrySearchList.Item(index: Integer): TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch(ObjectByIndex[index]);
end;

function TFhirBundleEntrySearchList.Link: TFhirBundleEntrySearchList;
begin
  result := TFhirBundleEntrySearchList(inherited Link);
end;

procedure TFhirBundleEntrySearchList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleEntrySearchList.SetItemByIndex(index: Integer; value: TFhirBundleEntrySearch);
begin
  assert(value is TFhirBundleEntrySearch);
  FhirBundleEntrySearches[index] := value;
end;

procedure TFhirBundleEntrySearchList.SetItemN(index: Integer; value: TFhirBundleEntrySearch);
begin
  assert(value is TFhirBundleEntrySearch);
  ObjectByIndex[index] := value;
end;

{ TFhirBundleEntryRequest }

constructor TFhirBundleEntryRequest.Create;
begin
  inherited;
end;

destructor TFhirBundleEntryRequest.Destroy;
begin
  FMethod.free;
  FUrl.free;
  FIfNoneMatch.free;
  FIfModifiedSince.free;
  FIfMatch.free;
  FIfNoneExist.free;
  inherited;
end;

procedure TFhirBundleEntryRequest.Assign(oSource : TFslObject);
begin
  inherited;
  FMethod := TFhirBundleEntryRequest(oSource).FMethod.Link;
  urlElement := TFhirBundleEntryRequest(oSource).urlElement.Clone;
  ifNoneMatchElement := TFhirBundleEntryRequest(oSource).ifNoneMatchElement.Clone;
  ifModifiedSinceElement := TFhirBundleEntryRequest(oSource).ifModifiedSinceElement.Clone;
  ifMatchElement := TFhirBundleEntryRequest(oSource).ifMatchElement.Clone;
  ifNoneExistElement := TFhirBundleEntryRequest(oSource).ifNoneExistElement.Clone;
end;

procedure TFhirBundleEntryRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'ifNoneMatch') Then
     list.add(self.link, 'ifNoneMatch', FIfNoneMatch.Link);
  if (child_name = 'ifModifiedSince') Then
     list.add(self.link, 'ifModifiedSince', FIfModifiedSince.Link);
  if (child_name = 'ifMatch') Then
     list.add(self.link, 'ifMatch', FIfMatch.Link);
  if (child_name = 'ifNoneExist') Then
     list.add(self.link, 'ifNoneExist', FIfNoneExist.Link);
end;

procedure TFhirBundleEntryRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'method', 'code', false, TFHIREnum, FMethod.Link));{1}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ifNoneMatch', 'string', false, TFhirString, FIfNoneMatch.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ifModifiedSince', 'instant', false, TFhirInstant, FIfModifiedSince.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ifMatch', 'string', false, TFhirString, FIfMatch.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ifNoneExist', 'string', false, TFhirString, FIfNoneExist.Link));{2}
end;

function TFhirBundleEntryRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'method') then
  begin
    MethodElement := asEnum(SYSTEMS_TFhirHttpVerbEnum, CODES_TFhirHttpVerbEnum, propValue);
    result := propValue
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'ifNoneMatch') then
  begin
    IfNoneMatchElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'ifModifiedSince') then
  begin
    IfModifiedSinceElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'ifMatch') then
  begin
    IfMatchElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'ifNoneExist') then
  begin
    IfNoneExistElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleEntryRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBundleEntryRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'ifNoneMatch') then result := TFhirString.create() {5b}
  else if (propName = 'ifModifiedSince') then result := TFhirInstant.create() {5b}
  else if (propName = 'ifMatch') then result := TFhirString.create() {5b}
  else if (propName = 'ifNoneExist') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleEntryRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'method') then result := 'code'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'ifNoneMatch') then result := 'string'
  else if (propName = 'ifModifiedSince') then result := 'instant'
  else if (propName = 'ifMatch') then result := 'string'
  else if (propName = 'ifNoneExist') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleEntryRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'method') then MethodElement := nil
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'ifNoneMatch') then IfNoneMatchElement := nil
  else if (propName = 'ifModifiedSince') then IfModifiedSinceElement := nil
  else if (propName = 'ifMatch') then IfMatchElement := nil
  else if (propName = 'ifNoneExist') then IfNoneExistElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleEntryRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'method') then MethodElement := asEnum(SYSTEMS_TFhirHttpVerbEnum, CODES_TFhirHttpVerbEnum, new){4}
  else if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'ifNoneMatch') then IfNoneMatchElement := asString(new){5b}
  else if (propName = 'ifModifiedSince') then IfModifiedSinceElement := asInstant(new){5b}
  else if (propName = 'ifMatch') then IfMatchElement := asString(new){5b}
  else if (propName = 'ifNoneExist') then IfNoneExistElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleEntryRequest.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleEntryRequest.fhirType : string;
begin
  result := 'request';
end;

function TFhirBundleEntryRequest.Link : TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest(inherited Link);
end;

function TFhirBundleEntryRequest.Clone : TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest(inherited Clone);
end;

function TFhirBundleEntryRequest.equals(other : TObject) : boolean; 
var
  o : TFhirBundleEntryRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleEntryRequest)) then
    result := false
  else
  begin
    o := TFhirBundleEntryRequest(other);
    result := compareDeep(methodElement, o.methodElement, true) and compareDeep(urlElement, o.urlElement, true) and 
      compareDeep(ifNoneMatchElement, o.ifNoneMatchElement, true) and compareDeep(ifModifiedSinceElement, o.ifModifiedSinceElement, true) and 
      compareDeep(ifMatchElement, o.ifMatchElement, true) and compareDeep(ifNoneExistElement, o.ifNoneExistElement, true);
  end;
end;

function TFhirBundleEntryRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMethod) and isEmptyProp(FUrl) and isEmptyProp(FIfNoneMatch) and isEmptyProp(FIfModifiedSince) and isEmptyProp(FIfMatch) and isEmptyProp(FIfNoneExist);
end;

procedure TFhirBundleEntryRequest.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('method');
  fields.add('url');
  fields.add('ifNoneMatch');
  fields.add('ifModifiedSince');
  fields.add('ifMatch');
  fields.add('ifNoneExist');
end;

{ TFhirBundleEntryRequest }

Procedure TFhirBundleEntryRequest.SetMethod(value : TFhirEnum);
begin
  FMethod.free;
  FMethod := value;
end;

Function TFhirBundleEntryRequest.GetMethodST : TFhirHttpVerbEnum;
begin
  if FMethod = nil then
    result := TFhirHttpVerbEnum(0)
  else
    result := TFhirHttpVerbEnum(StringArrayIndexOfSensitive(CODES_TFhirHttpVerbEnum, FMethod.value));
end;

Procedure TFhirBundleEntryRequest.SetMethodST(value : TFhirHttpVerbEnum);
begin
  if ord(value) = 0 then
    MethodElement := nil
  else
    MethodElement := TFhirEnum.create(SYSTEMS_TFhirHttpVerbEnum[value], CODES_TFhirHttpVerbEnum[value]);
end;

Procedure TFhirBundleEntryRequest.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirBundleEntryRequest.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirBundleEntryRequest.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirBundleEntryRequest.SetIfNoneMatch(value : TFhirString);
begin
  FIfNoneMatch.free;
  FIfNoneMatch := value;
end;

Function TFhirBundleEntryRequest.GetIfNoneMatchST : String;
begin
  if FIfNoneMatch = nil then
    result := ''
  else
    result := FIfNoneMatch.value;
end;

Procedure TFhirBundleEntryRequest.SetIfNoneMatchST(value : String);
begin
  if value <> '' then
  begin
    if FIfNoneMatch = nil then
      FIfNoneMatch := TFhirString.create;
    FIfNoneMatch.value := value
  end
  else if FIfNoneMatch <> nil then
    FIfNoneMatch.value := '';
end;

Procedure TFhirBundleEntryRequest.SetIfModifiedSince(value : TFhirInstant);
begin
  FIfModifiedSince.free;
  FIfModifiedSince := value;
end;

Function TFhirBundleEntryRequest.GetIfModifiedSinceST : TFslDateTime;
begin
  if FIfModifiedSince = nil then
    result := TFslDateTime.makeNull
  else
    result := FIfModifiedSince.value;
end;

Procedure TFhirBundleEntryRequest.SetIfModifiedSinceST(value : TFslDateTime);
begin
  if FIfModifiedSince = nil then
    FIfModifiedSince := TFhirInstant.create;
  FIfModifiedSince.value := value
end;

Procedure TFhirBundleEntryRequest.SetIfMatch(value : TFhirString);
begin
  FIfMatch.free;
  FIfMatch := value;
end;

Function TFhirBundleEntryRequest.GetIfMatchST : String;
begin
  if FIfMatch = nil then
    result := ''
  else
    result := FIfMatch.value;
end;

Procedure TFhirBundleEntryRequest.SetIfMatchST(value : String);
begin
  if value <> '' then
  begin
    if FIfMatch = nil then
      FIfMatch := TFhirString.create;
    FIfMatch.value := value
  end
  else if FIfMatch <> nil then
    FIfMatch.value := '';
end;

Procedure TFhirBundleEntryRequest.SetIfNoneExist(value : TFhirString);
begin
  FIfNoneExist.free;
  FIfNoneExist := value;
end;

Function TFhirBundleEntryRequest.GetIfNoneExistST : String;
begin
  if FIfNoneExist = nil then
    result := ''
  else
    result := FIfNoneExist.value;
end;

Procedure TFhirBundleEntryRequest.SetIfNoneExistST(value : String);
begin
  if value <> '' then
  begin
    if FIfNoneExist = nil then
      FIfNoneExist := TFhirString.create;
    FIfNoneExist.value := value
  end
  else if FIfNoneExist <> nil then
    FIfNoneExist.value := '';
end;

function TFhirBundleEntryRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMethod.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
  inc(result, FIfNoneMatch.sizeInBytes);
  inc(result, FIfModifiedSince.sizeInBytes);
  inc(result, FIfMatch.sizeInBytes);
  inc(result, FIfNoneExist.sizeInBytes);
end;

{ TFhirBundleEntryRequestListEnumerator }

Constructor TFhirBundleEntryRequestListEnumerator.Create(list : TFhirBundleEntryRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleEntryRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleEntryRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleEntryRequestListEnumerator.GetCurrent : TFhirBundleEntryRequest;
begin
  Result := FList[FIndex];
end;

function TFhirBundleEntryRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBundleEntryRequestList }
procedure TFhirBundleEntryRequestList.AddItem(value: TFhirBundleEntryRequest);
begin
  assert(value.ClassName = 'TFhirBundleEntryRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleEntryRequest');
  add(value);
end;

function TFhirBundleEntryRequestList.Append: TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryRequestList.ClearItems;
begin
  Clear;
end;

function TFhirBundleEntryRequestList.GetEnumerator : TFhirBundleEntryRequestListEnumerator;
begin
  result := TFhirBundleEntryRequestListEnumerator.Create(self.link);
end;

function TFhirBundleEntryRequestList.Clone: TFhirBundleEntryRequestList;
begin
  result := TFhirBundleEntryRequestList(inherited Clone);
end;

function TFhirBundleEntryRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleEntryRequestList.GetItemN(index: Integer): TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest(ObjectByIndex[index]);
end;

function TFhirBundleEntryRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleEntryRequest;
end;
function TFhirBundleEntryRequestList.IndexOf(value: TFhirBundleEntryRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleEntryRequestList.Insert(index: Integer): TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryRequestList.InsertItem(index: Integer; value: TFhirBundleEntryRequest);
begin
  assert(value is TFhirBundleEntryRequest);
  Inherited Insert(index, value);
end;

function TFhirBundleEntryRequestList.Item(index: Integer): TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest(ObjectByIndex[index]);
end;

function TFhirBundleEntryRequestList.Link: TFhirBundleEntryRequestList;
begin
  result := TFhirBundleEntryRequestList(inherited Link);
end;

procedure TFhirBundleEntryRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleEntryRequestList.SetItemByIndex(index: Integer; value: TFhirBundleEntryRequest);
begin
  assert(value is TFhirBundleEntryRequest);
  FhirBundleEntryRequests[index] := value;
end;

procedure TFhirBundleEntryRequestList.SetItemN(index: Integer; value: TFhirBundleEntryRequest);
begin
  assert(value is TFhirBundleEntryRequest);
  ObjectByIndex[index] := value;
end;

{ TFhirBundleEntryResponse }

constructor TFhirBundleEntryResponse.Create;
begin
  inherited;
end;

destructor TFhirBundleEntryResponse.Destroy;
begin
  FStatus.free;
  FLocation.free;
  FEtag.free;
  FLastModified.free;
  FOutcome.free;
  inherited;
end;

procedure TFhirBundleEntryResponse.Assign(oSource : TFslObject);
begin
  inherited;
  statusElement := TFhirBundleEntryResponse(oSource).statusElement.Clone;
  locationElement := TFhirBundleEntryResponse(oSource).locationElement.Clone;
  etagElement := TFhirBundleEntryResponse(oSource).etagElement.Clone;
  lastModifiedElement := TFhirBundleEntryResponse(oSource).lastModifiedElement.Clone;
  outcome := TFhirBundleEntryResponse(oSource).outcome.Clone;
end;

procedure TFhirBundleEntryResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'etag') Then
     list.add(self.link, 'etag', FEtag.Link);
  if (child_name = 'lastModified') Then
     list.add(self.link, 'lastModified', FLastModified.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
end;

procedure TFhirBundleEntryResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'string', false, TFhirString, FStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'uri', false, TFhirUri, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'etag', 'string', false, TFhirString, FEtag.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lastModified', 'instant', false, TFhirInstant, FLastModified.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'Resource', false, TFhirResource, FOutcome.Link));{2}
end;

function TFhirBundleEntryResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'etag') then
  begin
    EtagElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lastModified') then
  begin
    LastModifiedElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirResource{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleEntryResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBundleEntryResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'status') then result := TFhirString.create() {5b}
  else if (propName = 'location') then result := TFhirUri.create() {5b}
  else if (propName = 'etag') then result := TFhirString.create() {5b}
  else if (propName = 'lastModified') then result := TFhirInstant.create() {5b}
  else if (propName = 'outcome') then raise EFHIRException.create('Cannot make property Outcome')
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleEntryResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'string'
  else if (propName = 'location') then result := 'uri'
  else if (propName = 'etag') then result := 'string'
  else if (propName = 'lastModified') then result := 'instant'
  else if (propName = 'outcome') then result := 'Resource'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleEntryResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'etag') then EtagElement := nil
  else if (propName = 'lastModified') then LastModifiedElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleEntryResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asString(new){5b}
  else if (propName = 'location') then LocationElement := asUri(new){5b}
  else if (propName = 'etag') then EtagElement := asString(new){5b}
  else if (propName = 'lastModified') then LastModifiedElement := asInstant(new){5b}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirResource{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleEntryResponse.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleEntryResponse.fhirType : string;
begin
  result := 'response';
end;

function TFhirBundleEntryResponse.Link : TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse(inherited Link);
end;

function TFhirBundleEntryResponse.Clone : TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse(inherited Clone);
end;

function TFhirBundleEntryResponse.equals(other : TObject) : boolean; 
var
  o : TFhirBundleEntryResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleEntryResponse)) then
    result := false
  else
  begin
    o := TFhirBundleEntryResponse(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(etagElement, o.etagElement, true) and compareDeep(lastModifiedElement, o.lastModifiedElement, true) and 
      compareDeep(outcomeElement, o.outcomeElement, true);
  end;
end;

function TFhirBundleEntryResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FLocation) and isEmptyProp(FEtag) and isEmptyProp(FLastModified) and isEmptyProp(FOutcome);
end;

procedure TFhirBundleEntryResponse.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('status');
  fields.add('location');
  fields.add('etag');
  fields.add('lastModified');
  fields.add('outcome');
end;

{ TFhirBundleEntryResponse }

Procedure TFhirBundleEntryResponse.SetStatus(value : TFhirString);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirBundleEntryResponse.GetStatusST : String;
begin
  if FStatus = nil then
    result := ''
  else
    result := FStatus.value;
end;

Procedure TFhirBundleEntryResponse.SetStatusST(value : String);
begin
  if value <> '' then
  begin
    if FStatus = nil then
      FStatus := TFhirString.create;
    FStatus.value := value
  end
  else if FStatus <> nil then
    FStatus.value := '';
end;

Procedure TFhirBundleEntryResponse.SetLocation(value : TFhirUri);
begin
  FLocation.free;
  FLocation := value;
end;

Function TFhirBundleEntryResponse.GetLocationST : String;
begin
  if FLocation = nil then
    result := ''
  else
    result := FLocation.value;
end;

Procedure TFhirBundleEntryResponse.SetLocationST(value : String);
begin
  if value <> '' then
  begin
    if FLocation = nil then
      FLocation := TFhirUri.create;
    FLocation.value := value
  end
  else if FLocation <> nil then
    FLocation.value := '';
end;

Procedure TFhirBundleEntryResponse.SetEtag(value : TFhirString);
begin
  FEtag.free;
  FEtag := value;
end;

Function TFhirBundleEntryResponse.GetEtagST : String;
begin
  if FEtag = nil then
    result := ''
  else
    result := FEtag.value;
end;

Procedure TFhirBundleEntryResponse.SetEtagST(value : String);
begin
  if value <> '' then
  begin
    if FEtag = nil then
      FEtag := TFhirString.create;
    FEtag.value := value
  end
  else if FEtag <> nil then
    FEtag.value := '';
end;

Procedure TFhirBundleEntryResponse.SetLastModified(value : TFhirInstant);
begin
  FLastModified.free;
  FLastModified := value;
end;

Function TFhirBundleEntryResponse.GetLastModifiedST : TFslDateTime;
begin
  if FLastModified = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastModified.value;
end;

Procedure TFhirBundleEntryResponse.SetLastModifiedST(value : TFslDateTime);
begin
  if FLastModified = nil then
    FLastModified := TFhirInstant.create;
  FLastModified.value := value
end;

Procedure TFhirBundleEntryResponse.SetOutcome(value : TFhirResource);
begin
  FOutcome.free;
  FOutcome := value;
end;

function TFhirBundleEntryResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStatus.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FEtag.sizeInBytes);
  inc(result, FLastModified.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
end;

{ TFhirBundleEntryResponseListEnumerator }

Constructor TFhirBundleEntryResponseListEnumerator.Create(list : TFhirBundleEntryResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleEntryResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleEntryResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleEntryResponseListEnumerator.GetCurrent : TFhirBundleEntryResponse;
begin
  Result := FList[FIndex];
end;

function TFhirBundleEntryResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBundleEntryResponseList }
procedure TFhirBundleEntryResponseList.AddItem(value: TFhirBundleEntryResponse);
begin
  assert(value.ClassName = 'TFhirBundleEntryResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleEntryResponse');
  add(value);
end;

function TFhirBundleEntryResponseList.Append: TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryResponseList.ClearItems;
begin
  Clear;
end;

function TFhirBundleEntryResponseList.GetEnumerator : TFhirBundleEntryResponseListEnumerator;
begin
  result := TFhirBundleEntryResponseListEnumerator.Create(self.link);
end;

function TFhirBundleEntryResponseList.Clone: TFhirBundleEntryResponseList;
begin
  result := TFhirBundleEntryResponseList(inherited Clone);
end;

function TFhirBundleEntryResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleEntryResponseList.GetItemN(index: Integer): TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse(ObjectByIndex[index]);
end;

function TFhirBundleEntryResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleEntryResponse;
end;
function TFhirBundleEntryResponseList.IndexOf(value: TFhirBundleEntryResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleEntryResponseList.Insert(index: Integer): TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryResponseList.InsertItem(index: Integer; value: TFhirBundleEntryResponse);
begin
  assert(value is TFhirBundleEntryResponse);
  Inherited Insert(index, value);
end;

function TFhirBundleEntryResponseList.Item(index: Integer): TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse(ObjectByIndex[index]);
end;

function TFhirBundleEntryResponseList.Link: TFhirBundleEntryResponseList;
begin
  result := TFhirBundleEntryResponseList(inherited Link);
end;

procedure TFhirBundleEntryResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleEntryResponseList.SetItemByIndex(index: Integer; value: TFhirBundleEntryResponse);
begin
  assert(value is TFhirBundleEntryResponse);
  FhirBundleEntryResponses[index] := value;
end;

procedure TFhirBundleEntryResponseList.SetItemN(index: Integer; value: TFhirBundleEntryResponse);
begin
  assert(value is TFhirBundleEntryResponse);
  ObjectByIndex[index] := value;
end;

{ TFhirBundle }

constructor TFhirBundle.Create;
begin
  inherited;
end;

destructor TFhirBundle.Destroy;
begin
  FIdentifier.free;
  FType_.free;
  FTimestamp.free;
  FTotal.free;
  FLink_List.Free;
  FEntryList.Free;
  FSignature.free;
  inherited;
end;

function TFhirBundle.GetResourceType : TFhirResourceType;
begin
  result := frtBundle;
end;

procedure TFhirBundle.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirBundle(oSource).identifier.Clone;
  FType_ := TFhirBundle(oSource).FType_.Link;
  timestampElement := TFhirBundle(oSource).timestampElement.Clone;
  totalElement := TFhirBundle(oSource).totalElement.Clone;
  if (TFhirBundle(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirBundleLinkList.Create;
    FLink_List.Assign(TFhirBundle(oSource).FLink_List);
  end;
  if (TFhirBundle(oSource).FEntryList = nil) then
  begin
    FEntryList.free;
    FEntryList := nil;
  end
  else
  begin
    if FEntryList = nil then
      FEntryList := TFhirBundleEntryList.Create;
    FEntryList.Assign(TFhirBundle(oSource).FEntryList);
  end;
  signature := TFhirBundle(oSource).signature.Clone;
end;

procedure TFhirBundle.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'timestamp') Then
     list.add(self.link, 'timestamp', FTimestamp.Link);
  if (child_name = 'total') Then
     list.add(self.link, 'total', FTotal.Link);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
  if (child_name = 'entry') Then
    list.addAll(self, 'entry', FEntryList);
  if (child_name = 'signature') Then
     list.add(self.link, 'signature', FSignature.Link);
end;

procedure TFhirBundle.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'timestamp', 'instant', false, TFhirInstant, FTimestamp.Link));{2}
  oList.add(TFHIRProperty.create(self, 'total', 'unsignedInt', false, TFhirUnsignedInt, FTotal.Link));{2}
  oList.add(TFHIRProperty.create(self, 'link', '', true, TFhirBundleLink, FLink_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'entry', '', true, TFhirBundleEntry, FEntryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'signature', 'Signature', false, TFhirSignature, FSignature.Link));{2}
end;

function TFhirBundle.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirBundleTypeEnum, CODES_TFhirBundleTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'timestamp') then
  begin
    TimestampElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'total') then
  begin
    TotalElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirBundleLink){2a};
    result := propValue;
  end
  else if (propName = 'entry') then
  begin
    EntryList.add(propValue as TFhirBundleEntry){2a};
    result := propValue;
  end
  else if (propName = 'signature') then
  begin
    Signature := propValue as TFhirSignature{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirBundle.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirBundleLink){2a}
  else if (propName = 'entry') then EntryList.insertItem(index, propValue as TFhirBundleEntry){2a}
  else inherited;
end;

function TFhirBundle.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'timestamp') then result := TFhirInstant.create() {5b}
  else if (propName = 'total') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'link') then result := Link_List.new(){2}
  else if (propName = 'entry') then result := EntryList.new(){2}
  else if (propName = 'signature') then result := TFhirSignature.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundle.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'timestamp') then result := 'instant'
  else if (propName = 'total') then result := 'unsignedInt'
  else if (propName = 'link') then result := ''
  else if (propName = 'entry') then result := ''
  else if (propName = 'signature') then result := 'Signature'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundle.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'timestamp') then TimestampElement := nil
  else if (propName = 'total') then TotalElement := nil
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value) {2}
  else if (propName = 'entry') then deletePropertyValue('entry', EntryList, value) {2}
  else if (propName = 'signature') then SignatureElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundle.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirBundleTypeEnum, CODES_TFhirBundleTypeEnum, new){4}
  else if (propName = 'timestamp') then TimestampElement := asInstant(new){5b}
  else if (propName = 'total') then TotalElement := asUnsignedInt(new){5b}
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new) {2}
  else if (propName = 'entry') then replacePropertyValue('entry', EntryList, existing, new) {2}
  else if (propName = 'signature') then SignatureElement := new as TFhirSignature{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundle.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'link') then Link_List.move(source, destination){2a}
  else if (propName = 'entry') then EntryList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBundle.fhirType : string;
begin
  result := 'Bundle';
end;

function TFhirBundle.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FType_) and isEmptyProp(FTimestamp) and isEmptyProp(FTotal) and isEmptyProp(Flink_List) and isEmptyProp(FentryList) and isEmptyProp(FSignature);
end;

function TFhirBundle.equals(other : TObject) : boolean; 
var
  o : TFhirBundle;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundle)) then
    result := false
  else
  begin
    o := TFhirBundle(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(timestampElement, o.timestampElement, true) and compareDeep(totalElement, o.totalElement, true) and 
      compareDeep(link_List, o.link_List, true) and compareDeep(entryList, o.entryList, true) and 
      compareDeep(signatureElement, o.signatureElement, true);
  end;
end;

function TFhirBundle.Link : TFhirBundle;
begin
  result := TFhirBundle(inherited Link);
end;

function TFhirBundle.Clone : TFhirBundle;
begin
  result := TFhirBundle(inherited Clone);
end;

procedure TFhirBundle.listFieldsInOrder(fields : TStringList);
begin
  listResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('timestamp');
  fields.add('total');
  fields.add('link');
  fields.add('entry');
  fields.add('signature');
end;

{ TFhirBundle }

Procedure TFhirBundle.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirBundle.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirBundle.GetType_ST : TFhirBundleTypeEnum;
begin
  if FType_ = nil then
    result := TFhirBundleTypeEnum(0)
  else
    result := TFhirBundleTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirBundleTypeEnum, FType_.value));
end;

Procedure TFhirBundle.SetType_ST(value : TFhirBundleTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirBundleTypeEnum[value], CODES_TFhirBundleTypeEnum[value]);
end;

Procedure TFhirBundle.SetTimestamp(value : TFhirInstant);
begin
  FTimestamp.free;
  FTimestamp := value;
end;

Function TFhirBundle.GetTimestampST : TFslDateTime;
begin
  if FTimestamp = nil then
    result := TFslDateTime.makeNull
  else
    result := FTimestamp.value;
end;

Procedure TFhirBundle.SetTimestampST(value : TFslDateTime);
begin
  if FTimestamp = nil then
    FTimestamp := TFhirInstant.create;
  FTimestamp.value := value
end;

Procedure TFhirBundle.SetTotal(value : TFhirUnsignedInt);
begin
  FTotal.free;
  FTotal := value;
end;

Function TFhirBundle.GetTotalST : String;
begin
  if FTotal = nil then
    result := ''
  else
    result := FTotal.value;
end;

Procedure TFhirBundle.SetTotalST(value : String);
begin
  if value <> '' then
  begin
    if FTotal = nil then
      FTotal := TFhirUnsignedInt.create;
    FTotal.value := value
  end
  else if FTotal <> nil then
    FTotal.value := '';
end;

Function TFhirBundle.GetLink_List : TFhirBundleLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirBundleLinkList.Create;
  result := FLink_List;
end;

Function TFhirBundle.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

Function TFhirBundle.GetEntryList : TFhirBundleEntryList;
begin
  if FEntryList = nil then
    FEntryList := TFhirBundleEntryList.Create;
  result := FEntryList;
end;

Function TFhirBundle.GetHasEntryList : boolean;
begin
  result := (FEntryList <> nil) and (FEntryList.count > 0);
end;

Procedure TFhirBundle.SetSignature(value : TFhirSignature);
begin
  FSignature.free;
  FSignature := value;
end;

function TFhirBundle.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FTimestamp.sizeInBytes);
  inc(result, FTotal.sizeInBytes);
  inc(result, Flink_List.sizeInBytes);
  inc(result, FentryList.sizeInBytes);
  inc(result, FSignature.sizeInBytes);
end;

{ TFhirBundleListEnumerator }

Constructor TFhirBundleListEnumerator.Create(list : TFhirBundleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleListEnumerator.GetCurrent : TFhirBundle;
begin
  Result := FList[FIndex];
end;

function TFhirBundleListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBundleList }
procedure TFhirBundleList.AddItem(value: TFhirBundle);
begin
  assert(value.ClassName = 'TFhirBundle', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundle');
  add(value);
end;

function TFhirBundleList.Append: TFhirBundle;
begin
  result := TFhirBundle.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleList.ClearItems;
begin
  Clear;
end;

function TFhirBundleList.GetEnumerator : TFhirBundleListEnumerator;
begin
  result := TFhirBundleListEnumerator.Create(self.link);
end;

function TFhirBundleList.Clone: TFhirBundleList;
begin
  result := TFhirBundleList(inherited Clone);
end;

function TFhirBundleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleList.GetItemN(index: Integer): TFhirBundle;
begin
  result := TFhirBundle(ObjectByIndex[index]);
end;

function TFhirBundleList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundle;
end;
function TFhirBundleList.IndexOf(value: TFhirBundle): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleList.Insert(index: Integer): TFhirBundle;
begin
  result := TFhirBundle.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleList.InsertItem(index: Integer; value: TFhirBundle);
begin
  assert(value is TFhirBundle);
  Inherited Insert(index, value);
end;

function TFhirBundleList.Item(index: Integer): TFhirBundle;
begin
  result := TFhirBundle(ObjectByIndex[index]);
end;

function TFhirBundleList.Link: TFhirBundleList;
begin
  result := TFhirBundleList(inherited Link);
end;

procedure TFhirBundleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleList.SetItemByIndex(index: Integer; value: TFhirBundle);
begin
  assert(value is TFhirBundle);
  FhirBundles[index] := value;
end;

procedure TFhirBundleList.SetItemN(index: Integer; value: TFhirBundle);
begin
  assert(value is TFhirBundle);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BUNDLE}

{$IFDEF FHIR_CONSENT}

{ TFhirConsentPolicy }

constructor TFhirConsentPolicy.Create;
begin
  inherited;
end;

destructor TFhirConsentPolicy.Destroy;
begin
  FAuthority.free;
  FUri.free;
  inherited;
end;

procedure TFhirConsentPolicy.Assign(oSource : TFslObject);
begin
  inherited;
  authorityElement := TFhirConsentPolicy(oSource).authorityElement.Clone;
  uriElement := TFhirConsentPolicy(oSource).uriElement.Clone;
end;

procedure TFhirConsentPolicy.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'authority') Then
     list.add(self.link, 'authority', FAuthority.Link);
  if (child_name = 'uri') Then
     list.add(self.link, 'uri', FUri.Link);
end;

procedure TFhirConsentPolicy.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'authority', 'uri', false, TFhirUri, FAuthority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'uri', 'uri', false, TFhirUri, FUri.Link));{2}
end;

function TFhirConsentPolicy.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'authority') then
  begin
    AuthorityElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'uri') then
  begin
    UriElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentPolicy.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConsentPolicy.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'authority') then result := TFhirUri.create() {5b}
  else if (propName = 'uri') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentPolicy.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'authority') then result := 'uri'
  else if (propName = 'uri') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentPolicy.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'authority') then AuthorityElement := nil
  else if (propName = 'uri') then UriElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentPolicy.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'authority') then AuthorityElement := asUri(new){5b}
  else if (propName = 'uri') then UriElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentPolicy.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentPolicy.fhirType : string;
begin
  result := 'policy';
end;

function TFhirConsentPolicy.Link : TFhirConsentPolicy;
begin
  result := TFhirConsentPolicy(inherited Link);
end;

function TFhirConsentPolicy.Clone : TFhirConsentPolicy;
begin
  result := TFhirConsentPolicy(inherited Clone);
end;

function TFhirConsentPolicy.equals(other : TObject) : boolean; 
var
  o : TFhirConsentPolicy;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentPolicy)) then
    result := false
  else
  begin
    o := TFhirConsentPolicy(other);
    result := compareDeep(authorityElement, o.authorityElement, true) and compareDeep(uriElement, o.uriElement, true);
  end;
end;

function TFhirConsentPolicy.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAuthority) and isEmptyProp(FUri);
end;

procedure TFhirConsentPolicy.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('authority');
  fields.add('uri');
end;

{ TFhirConsentPolicy }

Procedure TFhirConsentPolicy.SetAuthority(value : TFhirUri);
begin
  FAuthority.free;
  FAuthority := value;
end;

Function TFhirConsentPolicy.GetAuthorityST : String;
begin
  if FAuthority = nil then
    result := ''
  else
    result := FAuthority.value;
end;

Procedure TFhirConsentPolicy.SetAuthorityST(value : String);
begin
  if value <> '' then
  begin
    if FAuthority = nil then
      FAuthority := TFhirUri.create;
    FAuthority.value := value
  end
  else if FAuthority <> nil then
    FAuthority.value := '';
end;

Procedure TFhirConsentPolicy.SetUri(value : TFhirUri);
begin
  FUri.free;
  FUri := value;
end;

Function TFhirConsentPolicy.GetUriST : String;
begin
  if FUri = nil then
    result := ''
  else
    result := FUri.value;
end;

Procedure TFhirConsentPolicy.SetUriST(value : String);
begin
  if value <> '' then
  begin
    if FUri = nil then
      FUri := TFhirUri.create;
    FUri.value := value
  end
  else if FUri <> nil then
    FUri.value := '';
end;

function TFhirConsentPolicy.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAuthority.sizeInBytes);
  inc(result, FUri.sizeInBytes);
end;

{ TFhirConsentPolicyListEnumerator }

Constructor TFhirConsentPolicyListEnumerator.Create(list : TFhirConsentPolicyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentPolicyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentPolicyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentPolicyListEnumerator.GetCurrent : TFhirConsentPolicy;
begin
  Result := FList[FIndex];
end;

function TFhirConsentPolicyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConsentPolicyList }
procedure TFhirConsentPolicyList.AddItem(value: TFhirConsentPolicy);
begin
  assert(value.ClassName = 'TFhirConsentPolicy', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentPolicy');
  add(value);
end;

function TFhirConsentPolicyList.Append: TFhirConsentPolicy;
begin
  result := TFhirConsentPolicy.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentPolicyList.ClearItems;
begin
  Clear;
end;

function TFhirConsentPolicyList.GetEnumerator : TFhirConsentPolicyListEnumerator;
begin
  result := TFhirConsentPolicyListEnumerator.Create(self.link);
end;

function TFhirConsentPolicyList.Clone: TFhirConsentPolicyList;
begin
  result := TFhirConsentPolicyList(inherited Clone);
end;

function TFhirConsentPolicyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentPolicyList.GetItemN(index: Integer): TFhirConsentPolicy;
begin
  result := TFhirConsentPolicy(ObjectByIndex[index]);
end;

function TFhirConsentPolicyList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentPolicy;
end;
function TFhirConsentPolicyList.IndexOf(value: TFhirConsentPolicy): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentPolicyList.Insert(index: Integer): TFhirConsentPolicy;
begin
  result := TFhirConsentPolicy.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentPolicyList.InsertItem(index: Integer; value: TFhirConsentPolicy);
begin
  assert(value is TFhirConsentPolicy);
  Inherited Insert(index, value);
end;

function TFhirConsentPolicyList.Item(index: Integer): TFhirConsentPolicy;
begin
  result := TFhirConsentPolicy(ObjectByIndex[index]);
end;

function TFhirConsentPolicyList.Link: TFhirConsentPolicyList;
begin
  result := TFhirConsentPolicyList(inherited Link);
end;

procedure TFhirConsentPolicyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentPolicyList.SetItemByIndex(index: Integer; value: TFhirConsentPolicy);
begin
  assert(value is TFhirConsentPolicy);
  FhirConsentPolicies[index] := value;
end;

procedure TFhirConsentPolicyList.SetItemN(index: Integer; value: TFhirConsentPolicy);
begin
  assert(value is TFhirConsentPolicy);
  ObjectByIndex[index] := value;
end;

{ TFhirConsentVerification }

constructor TFhirConsentVerification.Create;
begin
  inherited;
end;

destructor TFhirConsentVerification.Destroy;
begin
  FVerified.free;
  FVerifiedWith.free;
  FVerificationDate.free;
  inherited;
end;

procedure TFhirConsentVerification.Assign(oSource : TFslObject);
begin
  inherited;
  verifiedElement := TFhirConsentVerification(oSource).verifiedElement.Clone;
  verifiedWith := TFhirConsentVerification(oSource).verifiedWith.Clone;
  verificationDateElement := TFhirConsentVerification(oSource).verificationDateElement.Clone;
end;

procedure TFhirConsentVerification.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'verified') Then
     list.add(self.link, 'verified', FVerified.Link);
  if (child_name = 'verifiedWith') Then
     list.add(self.link, 'verifiedWith', FVerifiedWith.Link);
  if (child_name = 'verificationDate') Then
     list.add(self.link, 'verificationDate', FVerificationDate.Link);
end;

procedure TFhirConsentVerification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'verified', 'boolean', false, TFhirBoolean, FVerified.Link));{2}
  oList.add(TFHIRProperty.create(self, 'verifiedWith', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FVerifiedWith.Link));{2}
  oList.add(TFHIRProperty.create(self, 'verificationDate', 'dateTime', false, TFhirDateTime, FVerificationDate.Link));{2}
end;

function TFhirConsentVerification.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'verified') then
  begin
    VerifiedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'verifiedWith') then
  begin
    VerifiedWith := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'verificationDate') then
  begin
    VerificationDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentVerification.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConsentVerification.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'verified') then result := TFhirBoolean.create() {5b}
  else if (propName = 'verifiedWith') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'verificationDate') then result := TFhirDateTime.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentVerification.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'verified') then result := 'boolean'
  else if (propName = 'verifiedWith') then result := 'Reference'
  else if (propName = 'verificationDate') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentVerification.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'verified') then VerifiedElement := nil
  else if (propName = 'verifiedWith') then VerifiedWithElement := nil
  else if (propName = 'verificationDate') then VerificationDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentVerification.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'verified') then VerifiedElement := asBoolean(new){5b}
  else if (propName = 'verifiedWith') then VerifiedWithElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'verificationDate') then VerificationDateElement := asDateTime(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentVerification.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentVerification.fhirType : string;
begin
  result := 'verification';
end;

function TFhirConsentVerification.Link : TFhirConsentVerification;
begin
  result := TFhirConsentVerification(inherited Link);
end;

function TFhirConsentVerification.Clone : TFhirConsentVerification;
begin
  result := TFhirConsentVerification(inherited Clone);
end;

function TFhirConsentVerification.equals(other : TObject) : boolean; 
var
  o : TFhirConsentVerification;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentVerification)) then
    result := false
  else
  begin
    o := TFhirConsentVerification(other);
    result := compareDeep(verifiedElement, o.verifiedElement, true) and compareDeep(verifiedWithElement, o.verifiedWithElement, true) and 
      compareDeep(verificationDateElement, o.verificationDateElement, true);
  end;
end;

function TFhirConsentVerification.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FVerified) and isEmptyProp(FVerifiedWith) and isEmptyProp(FVerificationDate);
end;

procedure TFhirConsentVerification.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('verified');
  fields.add('verifiedWith');
  fields.add('verificationDate');
end;

{ TFhirConsentVerification }

Procedure TFhirConsentVerification.SetVerified(value : TFhirBoolean);
begin
  FVerified.free;
  FVerified := value;
end;

Function TFhirConsentVerification.GetVerifiedST : Boolean;
begin
  if FVerified = nil then
    result := false
  else
    result := FVerified.value;
end;

Procedure TFhirConsentVerification.SetVerifiedST(value : Boolean);
begin
  if FVerified = nil then
    FVerified := TFhirBoolean.create;
  FVerified.value := value
end;

Procedure TFhirConsentVerification.SetVerifiedWith(value : TFhirReference{TFhirPatient});
begin
  FVerifiedWith.free;
  FVerifiedWith := value;
end;

Procedure TFhirConsentVerification.SetVerificationDate(value : TFhirDateTime);
begin
  FVerificationDate.free;
  FVerificationDate := value;
end;

Function TFhirConsentVerification.GetVerificationDateST : TFslDateTime;
begin
  if FVerificationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FVerificationDate.value;
end;

Procedure TFhirConsentVerification.SetVerificationDateST(value : TFslDateTime);
begin
  if FVerificationDate = nil then
    FVerificationDate := TFhirDateTime.create;
  FVerificationDate.value := value
end;

function TFhirConsentVerification.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FVerified.sizeInBytes);
  inc(result, FVerifiedWith.sizeInBytes);
  inc(result, FVerificationDate.sizeInBytes);
end;

{ TFhirConsentVerificationListEnumerator }

Constructor TFhirConsentVerificationListEnumerator.Create(list : TFhirConsentVerificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentVerificationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentVerificationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentVerificationListEnumerator.GetCurrent : TFhirConsentVerification;
begin
  Result := FList[FIndex];
end;

function TFhirConsentVerificationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConsentVerificationList }
procedure TFhirConsentVerificationList.AddItem(value: TFhirConsentVerification);
begin
  assert(value.ClassName = 'TFhirConsentVerification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentVerification');
  add(value);
end;

function TFhirConsentVerificationList.Append: TFhirConsentVerification;
begin
  result := TFhirConsentVerification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentVerificationList.ClearItems;
begin
  Clear;
end;

function TFhirConsentVerificationList.GetEnumerator : TFhirConsentVerificationListEnumerator;
begin
  result := TFhirConsentVerificationListEnumerator.Create(self.link);
end;

function TFhirConsentVerificationList.Clone: TFhirConsentVerificationList;
begin
  result := TFhirConsentVerificationList(inherited Clone);
end;

function TFhirConsentVerificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentVerificationList.GetItemN(index: Integer): TFhirConsentVerification;
begin
  result := TFhirConsentVerification(ObjectByIndex[index]);
end;

function TFhirConsentVerificationList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentVerification;
end;
function TFhirConsentVerificationList.IndexOf(value: TFhirConsentVerification): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentVerificationList.Insert(index: Integer): TFhirConsentVerification;
begin
  result := TFhirConsentVerification.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentVerificationList.InsertItem(index: Integer; value: TFhirConsentVerification);
begin
  assert(value is TFhirConsentVerification);
  Inherited Insert(index, value);
end;

function TFhirConsentVerificationList.Item(index: Integer): TFhirConsentVerification;
begin
  result := TFhirConsentVerification(ObjectByIndex[index]);
end;

function TFhirConsentVerificationList.Link: TFhirConsentVerificationList;
begin
  result := TFhirConsentVerificationList(inherited Link);
end;

procedure TFhirConsentVerificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentVerificationList.SetItemByIndex(index: Integer; value: TFhirConsentVerification);
begin
  assert(value is TFhirConsentVerification);
  FhirConsentVerifications[index] := value;
end;

procedure TFhirConsentVerificationList.SetItemN(index: Integer; value: TFhirConsentVerification);
begin
  assert(value is TFhirConsentVerification);
  ObjectByIndex[index] := value;
end;

{ TFhirConsentProvision }

constructor TFhirConsentProvision.Create;
begin
  inherited;
end;

destructor TFhirConsentProvision.Destroy;
begin
  FType_.free;
  FPeriod.free;
  FActorList.Free;
  FActionList.Free;
  FSecurityLabelList.Free;
  FPurposeList.Free;
  FClass_List.Free;
  FCodeList.Free;
  FDataPeriod.free;
  FDataList.Free;
  FProvisionList.Free;
  inherited;
end;

procedure TFhirConsentProvision.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirConsentProvision(oSource).FType_.Link;
  period := TFhirConsentProvision(oSource).period.Clone;
  if (TFhirConsentProvision(oSource).FActorList = nil) then
  begin
    FActorList.free;
    FActorList := nil;
  end
  else
  begin
    if FActorList = nil then
      FActorList := TFhirConsentProvisionActorList.Create;
    FActorList.Assign(TFhirConsentProvision(oSource).FActorList);
  end;
  if (TFhirConsentProvision(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirCodeableConceptList.Create;
    FActionList.Assign(TFhirConsentProvision(oSource).FActionList);
  end;
  if (TFhirConsentProvision(oSource).FSecurityLabelList = nil) then
  begin
    FSecurityLabelList.free;
    FSecurityLabelList := nil;
  end
  else
  begin
    if FSecurityLabelList = nil then
      FSecurityLabelList := TFhirCodingList.Create;
    FSecurityLabelList.Assign(TFhirConsentProvision(oSource).FSecurityLabelList);
  end;
  if (TFhirConsentProvision(oSource).FPurposeList = nil) then
  begin
    FPurposeList.free;
    FPurposeList := nil;
  end
  else
  begin
    if FPurposeList = nil then
      FPurposeList := TFhirCodingList.Create;
    FPurposeList.Assign(TFhirConsentProvision(oSource).FPurposeList);
  end;
  if (TFhirConsentProvision(oSource).FClass_List = nil) then
  begin
    FClass_List.free;
    FClass_List := nil;
  end
  else
  begin
    if FClass_List = nil then
      FClass_List := TFhirCodingList.Create;
    FClass_List.Assign(TFhirConsentProvision(oSource).FClass_List);
  end;
  if (TFhirConsentProvision(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirConsentProvision(oSource).FCodeList);
  end;
  dataPeriod := TFhirConsentProvision(oSource).dataPeriod.Clone;
  if (TFhirConsentProvision(oSource).FDataList = nil) then
  begin
    FDataList.free;
    FDataList := nil;
  end
  else
  begin
    if FDataList = nil then
      FDataList := TFhirConsentProvisionDataList.Create;
    FDataList.Assign(TFhirConsentProvision(oSource).FDataList);
  end;
  if (TFhirConsentProvision(oSource).FProvisionList = nil) then
  begin
    FProvisionList.free;
    FProvisionList := nil;
  end
  else
  begin
    if FProvisionList = nil then
      FProvisionList := TFhirConsentProvisionList.Create;
    FProvisionList.Assign(TFhirConsentProvision(oSource).FProvisionList);
  end;
end;

procedure TFhirConsentProvision.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'actor') Then
    list.addAll(self, 'actor', FActorList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
  if (child_name = 'securityLabel') Then
    list.addAll(self, 'securityLabel', FSecurityLabelList);
  if (child_name = 'purpose') Then
    list.addAll(self, 'purpose', FPurposeList);
  if (child_name = 'class') Then
    list.addAll(self, 'class', FClass_List);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'dataPeriod') Then
     list.add(self.link, 'dataPeriod', FDataPeriod.Link);
  if (child_name = 'data') Then
    list.addAll(self, 'data', FDataList);
  if (child_name = 'provision') Then
    list.addAll(self, 'provision', FProvisionList);
end;

procedure TFhirConsentProvision.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'actor', '', true, TFhirConsentProvisionActor, FActorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'action', 'CodeableConcept', true, TFhirCodeableConcept, FActionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'securityLabel', 'Coding', true, TFhirCoding, FSecurityLabelList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'purpose', 'Coding', true, TFhirCoding, FPurposeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'class', 'Coding', true, TFhirCoding, FClass_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'dataPeriod', 'Period', false, TFhirPeriod, FDataPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'data', '', true, TFhirConsentProvisionData, FDataList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'provision', '@Consent.provision', true, TFhirConsentProvision, FProvisionList.Link)){3};
end;

function TFhirConsentProvision.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirConsentProvisionTypeEnum, CODES_TFhirConsentProvisionTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    ActorList.add(propValue as TFhirConsentProvisionActor){2a};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'securityLabel') then
  begin
    SecurityLabelList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_List.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'dataPeriod') then
  begin
    DataPeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'data') then
  begin
    DataList.add(propValue as TFhirConsentProvisionData){2a};
    result := propValue;
  end
  else if (propName = 'provision') then
  begin
    ProvisionList.add(propValue as TFhirConsentProvision){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentProvision.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'actor') then ActorList.insertItem(index, propValue as TFhirConsentProvisionActor){2a}
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'securityLabel') then SecurityLabelList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'purpose') then PurposeList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'class') then Class_List.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'data') then DataList.insertItem(index, propValue as TFhirConsentProvisionData){2a}
  else if (propName = 'provision') then ProvisionList.insertItem(index, propValue as TFhirConsentProvision){2a}
  else inherited;
end;

function TFhirConsentProvision.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'actor') then result := ActorList.new(){2}
  else if (propName = 'action') then result := ActionList.new(){2}
  else if (propName = 'securityLabel') then result := SecurityLabelList.new(){2}
  else if (propName = 'purpose') then result := PurposeList.new(){2}
  else if (propName = 'class') then result := Class_List.new(){2}
  else if (propName = 'code') then result := CodeList.new(){2}
  else if (propName = 'dataPeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'data') then result := DataList.new(){2}
  else if (propName = 'provision') then result := ProvisionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentProvision.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'actor') then result := ''
  else if (propName = 'action') then result := 'CodeableConcept'
  else if (propName = 'securityLabel') then result := 'Coding'
  else if (propName = 'purpose') then result := 'Coding'
  else if (propName = 'class') then result := 'Coding'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'dataPeriod') then result := 'Period'
  else if (propName = 'data') then result := ''
  else if (propName = 'provision') then result := '@Consent.provision'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentProvision.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'actor') then deletePropertyValue('actor', ActorList, value) {2}
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else if (propName = 'securityLabel') then deletePropertyValue('securityLabel', SecurityLabelList, value) {2}
  else if (propName = 'purpose') then deletePropertyValue('purpose', PurposeList, value) {2}
  else if (propName = 'class') then deletePropertyValue('class', Class_List, value) {2}
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value) {2}
  else if (propName = 'dataPeriod') then DataPeriodElement := nil
  else if (propName = 'data') then deletePropertyValue('data', DataList, value) {2}
  else if (propName = 'provision') then deletePropertyValue('provision', ProvisionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentProvision.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirConsentProvisionTypeEnum, CODES_TFhirConsentProvisionTypeEnum, new){4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'actor') then replacePropertyValue('actor', ActorList, existing, new) {2}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else if (propName = 'securityLabel') then replacePropertyValue('securityLabel', SecurityLabelList, existing, new) {2}
  else if (propName = 'purpose') then replacePropertyValue('purpose', PurposeList, existing, new) {2}
  else if (propName = 'class') then replacePropertyValue('class', Class_List, existing, new) {2}
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {2}
  else if (propName = 'dataPeriod') then DataPeriodElement := new as TFhirPeriod{4}
  else if (propName = 'data') then replacePropertyValue('data', DataList, existing, new) {2}
  else if (propName = 'provision') then replacePropertyValue('provision', ProvisionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentProvision.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'actor') then ActorList.move(source, destination){2a}
  else if (propName = 'action') then ActionList.move(source, destination){2a}
  else if (propName = 'securityLabel') then SecurityLabelList.move(source, destination){2a}
  else if (propName = 'purpose') then PurposeList.move(source, destination){2a}
  else if (propName = 'class') then Class_List.move(source, destination){2a}
  else if (propName = 'code') then CodeList.move(source, destination){2a}
  else if (propName = 'data') then DataList.move(source, destination){2a}
  else if (propName = 'provision') then ProvisionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentProvision.fhirType : string;
begin
  result := 'provision';
end;

function TFhirConsentProvision.Link : TFhirConsentProvision;
begin
  result := TFhirConsentProvision(inherited Link);
end;

function TFhirConsentProvision.Clone : TFhirConsentProvision;
begin
  result := TFhirConsentProvision(inherited Clone);
end;

function TFhirConsentProvision.equals(other : TObject) : boolean; 
var
  o : TFhirConsentProvision;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentProvision)) then
    result := false
  else
  begin
    o := TFhirConsentProvision(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(actorList, o.actorList, true) and compareDeep(actionList, o.actionList, true) and 
      compareDeep(securityLabelList, o.securityLabelList, true) and compareDeep(purposeList, o.purposeList, true) and 
      compareDeep(class_List, o.class_List, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(dataPeriodElement, o.dataPeriodElement, true) and compareDeep(dataList, o.dataList, true) and 
      compareDeep(provisionList, o.provisionList, true);
  end;
end;

function TFhirConsentProvision.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FPeriod) and isEmptyProp(FactorList) and isEmptyProp(FactionList) and isEmptyProp(FsecurityLabelList) and isEmptyProp(FpurposeList) and isEmptyProp(Fclass_List) and isEmptyProp(FcodeList) and isEmptyProp(FDataPeriod) and isEmptyProp(FdataList) and isEmptyProp(FprovisionList);
end;

procedure TFhirConsentProvision.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('period');
  fields.add('actor');
  fields.add('action');
  fields.add('securityLabel');
  fields.add('purpose');
  fields.add('class');
  fields.add('code');
  fields.add('dataPeriod');
  fields.add('data');
  fields.add('provision');
end;

{ TFhirConsentProvision }

Procedure TFhirConsentProvision.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirConsentProvision.GetType_ST : TFhirConsentProvisionTypeEnum;
begin
  if FType_ = nil then
    result := TFhirConsentProvisionTypeEnum(0)
  else
    result := TFhirConsentProvisionTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirConsentProvisionTypeEnum, FType_.value));
end;

Procedure TFhirConsentProvision.SetType_ST(value : TFhirConsentProvisionTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirConsentProvisionTypeEnum[value], CODES_TFhirConsentProvisionTypeEnum[value]);
end;

Procedure TFhirConsentProvision.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Function TFhirConsentProvision.GetActorList : TFhirConsentProvisionActorList;
begin
  if FActorList = nil then
    FActorList := TFhirConsentProvisionActorList.Create;
  result := FActorList;
end;

Function TFhirConsentProvision.GetHasActorList : boolean;
begin
  result := (FActorList <> nil) and (FActorList.count > 0);
end;

Function TFhirConsentProvision.GetActionList : TFhirCodeableConceptList;
begin
  if FActionList = nil then
    FActionList := TFhirCodeableConceptList.Create;
  result := FActionList;
end;

Function TFhirConsentProvision.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

Function TFhirConsentProvision.GetSecurityLabelList : TFhirCodingList;
begin
  if FSecurityLabelList = nil then
    FSecurityLabelList := TFhirCodingList.Create;
  result := FSecurityLabelList;
end;

Function TFhirConsentProvision.GetHasSecurityLabelList : boolean;
begin
  result := (FSecurityLabelList <> nil) and (FSecurityLabelList.count > 0);
end;

Function TFhirConsentProvision.GetPurposeList : TFhirCodingList;
begin
  if FPurposeList = nil then
    FPurposeList := TFhirCodingList.Create;
  result := FPurposeList;
end;

Function TFhirConsentProvision.GetHasPurposeList : boolean;
begin
  result := (FPurposeList <> nil) and (FPurposeList.count > 0);
end;

Function TFhirConsentProvision.GetClass_List : TFhirCodingList;
begin
  if FClass_List = nil then
    FClass_List := TFhirCodingList.Create;
  result := FClass_List;
end;

Function TFhirConsentProvision.GetHasClass_List : boolean;
begin
  result := (FClass_List <> nil) and (FClass_List.count > 0);
end;

Function TFhirConsentProvision.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

Function TFhirConsentProvision.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

Procedure TFhirConsentProvision.SetDataPeriod(value : TFhirPeriod);
begin
  FDataPeriod.free;
  FDataPeriod := value;
end;

Function TFhirConsentProvision.GetDataList : TFhirConsentProvisionDataList;
begin
  if FDataList = nil then
    FDataList := TFhirConsentProvisionDataList.Create;
  result := FDataList;
end;

Function TFhirConsentProvision.GetHasDataList : boolean;
begin
  result := (FDataList <> nil) and (FDataList.count > 0);
end;

Function TFhirConsentProvision.GetProvisionList : TFhirConsentProvisionList;
begin
  if FProvisionList = nil then
    FProvisionList := TFhirConsentProvisionList.Create;
  result := FProvisionList;
end;

Function TFhirConsentProvision.GetHasProvisionList : boolean;
begin
  result := (FProvisionList <> nil) and (FProvisionList.count > 0);
end;

function TFhirConsentProvision.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FactorList.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
  inc(result, FsecurityLabelList.sizeInBytes);
  inc(result, FpurposeList.sizeInBytes);
  inc(result, Fclass_List.sizeInBytes);
  inc(result, FcodeList.sizeInBytes);
  inc(result, FDataPeriod.sizeInBytes);
  inc(result, FdataList.sizeInBytes);
  inc(result, FprovisionList.sizeInBytes);
end;

{ TFhirConsentProvisionListEnumerator }

Constructor TFhirConsentProvisionListEnumerator.Create(list : TFhirConsentProvisionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentProvisionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentProvisionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentProvisionListEnumerator.GetCurrent : TFhirConsentProvision;
begin
  Result := FList[FIndex];
end;

function TFhirConsentProvisionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConsentProvisionList }
procedure TFhirConsentProvisionList.AddItem(value: TFhirConsentProvision);
begin
  assert(value.ClassName = 'TFhirConsentProvision', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentProvision');
  add(value);
end;

function TFhirConsentProvisionList.Append: TFhirConsentProvision;
begin
  result := TFhirConsentProvision.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentProvisionList.ClearItems;
begin
  Clear;
end;

function TFhirConsentProvisionList.GetEnumerator : TFhirConsentProvisionListEnumerator;
begin
  result := TFhirConsentProvisionListEnumerator.Create(self.link);
end;

function TFhirConsentProvisionList.Clone: TFhirConsentProvisionList;
begin
  result := TFhirConsentProvisionList(inherited Clone);
end;

function TFhirConsentProvisionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentProvisionList.GetItemN(index: Integer): TFhirConsentProvision;
begin
  result := TFhirConsentProvision(ObjectByIndex[index]);
end;

function TFhirConsentProvisionList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentProvision;
end;
function TFhirConsentProvisionList.IndexOf(value: TFhirConsentProvision): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentProvisionList.Insert(index: Integer): TFhirConsentProvision;
begin
  result := TFhirConsentProvision.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentProvisionList.InsertItem(index: Integer; value: TFhirConsentProvision);
begin
  assert(value is TFhirConsentProvision);
  Inherited Insert(index, value);
end;

function TFhirConsentProvisionList.Item(index: Integer): TFhirConsentProvision;
begin
  result := TFhirConsentProvision(ObjectByIndex[index]);
end;

function TFhirConsentProvisionList.Link: TFhirConsentProvisionList;
begin
  result := TFhirConsentProvisionList(inherited Link);
end;

procedure TFhirConsentProvisionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentProvisionList.SetItemByIndex(index: Integer; value: TFhirConsentProvision);
begin
  assert(value is TFhirConsentProvision);
  FhirConsentProvisions[index] := value;
end;

procedure TFhirConsentProvisionList.SetItemN(index: Integer; value: TFhirConsentProvision);
begin
  assert(value is TFhirConsentProvision);
  ObjectByIndex[index] := value;
end;

{ TFhirConsentProvisionActor }

constructor TFhirConsentProvisionActor.Create;
begin
  inherited;
end;

destructor TFhirConsentProvisionActor.Destroy;
begin
  FRole.free;
  FReference.free;
  inherited;
end;

procedure TFhirConsentProvisionActor.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirConsentProvisionActor(oSource).role.Clone;
  reference := TFhirConsentProvisionActor(oSource).reference.Clone;
end;

procedure TFhirConsentProvisionActor.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirConsentProvisionActor.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference(Device)', false, TFhirReference{TFhirDevice}, FReference.Link));{2}
end;

function TFhirConsentProvisionActor.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference{TFhirDevice}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentProvisionActor.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConsentProvisionActor.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reference') then result := TFhirReference{TFhirDevice}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentProvisionActor.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'reference') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentProvisionActor.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentProvisionActor.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else if (propName = 'reference') then ReferenceElement := new as TFhirReference{TFhirDevice}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentProvisionActor.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentProvisionActor.fhirType : string;
begin
  result := 'actor';
end;

function TFhirConsentProvisionActor.Link : TFhirConsentProvisionActor;
begin
  result := TFhirConsentProvisionActor(inherited Link);
end;

function TFhirConsentProvisionActor.Clone : TFhirConsentProvisionActor;
begin
  result := TFhirConsentProvisionActor(inherited Clone);
end;

function TFhirConsentProvisionActor.equals(other : TObject) : boolean; 
var
  o : TFhirConsentProvisionActor;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentProvisionActor)) then
    result := false
  else
  begin
    o := TFhirConsentProvisionActor(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirConsentProvisionActor.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FReference);
end;

procedure TFhirConsentProvisionActor.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('reference');
end;

{ TFhirConsentProvisionActor }

Procedure TFhirConsentProvisionActor.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirConsentProvisionActor.SetReference(value : TFhirReference{TFhirDevice});
begin
  FReference.free;
  FReference := value;
end;

function TFhirConsentProvisionActor.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRole.sizeInBytes);
  inc(result, FReference.sizeInBytes);
end;

{ TFhirConsentProvisionActorListEnumerator }

Constructor TFhirConsentProvisionActorListEnumerator.Create(list : TFhirConsentProvisionActorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentProvisionActorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentProvisionActorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentProvisionActorListEnumerator.GetCurrent : TFhirConsentProvisionActor;
begin
  Result := FList[FIndex];
end;

function TFhirConsentProvisionActorListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConsentProvisionActorList }
procedure TFhirConsentProvisionActorList.AddItem(value: TFhirConsentProvisionActor);
begin
  assert(value.ClassName = 'TFhirConsentProvisionActor', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentProvisionActor');
  add(value);
end;

function TFhirConsentProvisionActorList.Append: TFhirConsentProvisionActor;
begin
  result := TFhirConsentProvisionActor.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentProvisionActorList.ClearItems;
begin
  Clear;
end;

function TFhirConsentProvisionActorList.GetEnumerator : TFhirConsentProvisionActorListEnumerator;
begin
  result := TFhirConsentProvisionActorListEnumerator.Create(self.link);
end;

function TFhirConsentProvisionActorList.Clone: TFhirConsentProvisionActorList;
begin
  result := TFhirConsentProvisionActorList(inherited Clone);
end;

function TFhirConsentProvisionActorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentProvisionActorList.GetItemN(index: Integer): TFhirConsentProvisionActor;
begin
  result := TFhirConsentProvisionActor(ObjectByIndex[index]);
end;

function TFhirConsentProvisionActorList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentProvisionActor;
end;
function TFhirConsentProvisionActorList.IndexOf(value: TFhirConsentProvisionActor): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentProvisionActorList.Insert(index: Integer): TFhirConsentProvisionActor;
begin
  result := TFhirConsentProvisionActor.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentProvisionActorList.InsertItem(index: Integer; value: TFhirConsentProvisionActor);
begin
  assert(value is TFhirConsentProvisionActor);
  Inherited Insert(index, value);
end;

function TFhirConsentProvisionActorList.Item(index: Integer): TFhirConsentProvisionActor;
begin
  result := TFhirConsentProvisionActor(ObjectByIndex[index]);
end;

function TFhirConsentProvisionActorList.Link: TFhirConsentProvisionActorList;
begin
  result := TFhirConsentProvisionActorList(inherited Link);
end;

procedure TFhirConsentProvisionActorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentProvisionActorList.SetItemByIndex(index: Integer; value: TFhirConsentProvisionActor);
begin
  assert(value is TFhirConsentProvisionActor);
  FhirConsentProvisionActors[index] := value;
end;

procedure TFhirConsentProvisionActorList.SetItemN(index: Integer; value: TFhirConsentProvisionActor);
begin
  assert(value is TFhirConsentProvisionActor);
  ObjectByIndex[index] := value;
end;

{ TFhirConsentProvisionData }

constructor TFhirConsentProvisionData.Create;
begin
  inherited;
end;

destructor TFhirConsentProvisionData.Destroy;
begin
  FMeaning.free;
  FReference.free;
  inherited;
end;

procedure TFhirConsentProvisionData.Assign(oSource : TFslObject);
begin
  inherited;
  FMeaning := TFhirConsentProvisionData(oSource).FMeaning.Link;
  reference := TFhirConsentProvisionData(oSource).reference.Clone;
end;

procedure TFhirConsentProvisionData.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'meaning') Then
     list.add(self.link, 'meaning', FMeaning.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirConsentProvisionData.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'meaning', 'code', false, TFHIREnum, FMeaning.Link));{1}
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference(Any)', false, TFhirReference{TFhirReference}, FReference.Link));{2}
end;

function TFhirConsentProvisionData.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'meaning') then
  begin
    MeaningElement := asEnum(SYSTEMS_TFhirConsentDataMeaningEnum, CODES_TFhirConsentDataMeaningEnum, propValue);
    result := propValue
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentProvisionData.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConsentProvisionData.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'reference') then result := TFhirReference{TFhirReference}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentProvisionData.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'meaning') then result := 'code'
  else if (propName = 'reference') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentProvisionData.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'meaning') then MeaningElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentProvisionData.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'meaning') then MeaningElement := asEnum(SYSTEMS_TFhirConsentDataMeaningEnum, CODES_TFhirConsentDataMeaningEnum, new){4}
  else if (propName = 'reference') then ReferenceElement := new as TFhirReference{TFhirReference}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentProvisionData.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentProvisionData.fhirType : string;
begin
  result := 'data';
end;

function TFhirConsentProvisionData.Link : TFhirConsentProvisionData;
begin
  result := TFhirConsentProvisionData(inherited Link);
end;

function TFhirConsentProvisionData.Clone : TFhirConsentProvisionData;
begin
  result := TFhirConsentProvisionData(inherited Clone);
end;

function TFhirConsentProvisionData.equals(other : TObject) : boolean; 
var
  o : TFhirConsentProvisionData;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentProvisionData)) then
    result := false
  else
  begin
    o := TFhirConsentProvisionData(other);
    result := compareDeep(meaningElement, o.meaningElement, true) and compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirConsentProvisionData.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMeaning) and isEmptyProp(FReference);
end;

procedure TFhirConsentProvisionData.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('meaning');
  fields.add('reference');
end;

{ TFhirConsentProvisionData }

Procedure TFhirConsentProvisionData.SetMeaning(value : TFhirEnum);
begin
  FMeaning.free;
  FMeaning := value;
end;

Function TFhirConsentProvisionData.GetMeaningST : TFhirConsentDataMeaningEnum;
begin
  if FMeaning = nil then
    result := TFhirConsentDataMeaningEnum(0)
  else
    result := TFhirConsentDataMeaningEnum(StringArrayIndexOfSensitive(CODES_TFhirConsentDataMeaningEnum, FMeaning.value));
end;

Procedure TFhirConsentProvisionData.SetMeaningST(value : TFhirConsentDataMeaningEnum);
begin
  if ord(value) = 0 then
    MeaningElement := nil
  else
    MeaningElement := TFhirEnum.create(SYSTEMS_TFhirConsentDataMeaningEnum[value], CODES_TFhirConsentDataMeaningEnum[value]);
end;

Procedure TFhirConsentProvisionData.SetReference(value : TFhirReference{TFhirReference});
begin
  FReference.free;
  FReference := value;
end;

function TFhirConsentProvisionData.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMeaning.sizeInBytes);
  inc(result, FReference.sizeInBytes);
end;

{ TFhirConsentProvisionDataListEnumerator }

Constructor TFhirConsentProvisionDataListEnumerator.Create(list : TFhirConsentProvisionDataList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentProvisionDataListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentProvisionDataListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentProvisionDataListEnumerator.GetCurrent : TFhirConsentProvisionData;
begin
  Result := FList[FIndex];
end;

function TFhirConsentProvisionDataListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConsentProvisionDataList }
procedure TFhirConsentProvisionDataList.AddItem(value: TFhirConsentProvisionData);
begin
  assert(value.ClassName = 'TFhirConsentProvisionData', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentProvisionData');
  add(value);
end;

function TFhirConsentProvisionDataList.Append: TFhirConsentProvisionData;
begin
  result := TFhirConsentProvisionData.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentProvisionDataList.ClearItems;
begin
  Clear;
end;

function TFhirConsentProvisionDataList.GetEnumerator : TFhirConsentProvisionDataListEnumerator;
begin
  result := TFhirConsentProvisionDataListEnumerator.Create(self.link);
end;

function TFhirConsentProvisionDataList.Clone: TFhirConsentProvisionDataList;
begin
  result := TFhirConsentProvisionDataList(inherited Clone);
end;

function TFhirConsentProvisionDataList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentProvisionDataList.GetItemN(index: Integer): TFhirConsentProvisionData;
begin
  result := TFhirConsentProvisionData(ObjectByIndex[index]);
end;

function TFhirConsentProvisionDataList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentProvisionData;
end;
function TFhirConsentProvisionDataList.IndexOf(value: TFhirConsentProvisionData): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentProvisionDataList.Insert(index: Integer): TFhirConsentProvisionData;
begin
  result := TFhirConsentProvisionData.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentProvisionDataList.InsertItem(index: Integer; value: TFhirConsentProvisionData);
begin
  assert(value is TFhirConsentProvisionData);
  Inherited Insert(index, value);
end;

function TFhirConsentProvisionDataList.Item(index: Integer): TFhirConsentProvisionData;
begin
  result := TFhirConsentProvisionData(ObjectByIndex[index]);
end;

function TFhirConsentProvisionDataList.Link: TFhirConsentProvisionDataList;
begin
  result := TFhirConsentProvisionDataList(inherited Link);
end;

procedure TFhirConsentProvisionDataList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentProvisionDataList.SetItemByIndex(index: Integer; value: TFhirConsentProvisionData);
begin
  assert(value is TFhirConsentProvisionData);
  FhirConsentProvisionData[index] := value;
end;

procedure TFhirConsentProvisionDataList.SetItemN(index: Integer; value: TFhirConsentProvisionData);
begin
  assert(value is TFhirConsentProvisionData);
  ObjectByIndex[index] := value;
end;

{ TFhirConsent }

constructor TFhirConsent.Create;
begin
  inherited;
end;

destructor TFhirConsent.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FScope.free;
  FCategoryList.Free;
  FPatient.free;
  FDateTime.free;
  FPerformerList.Free;
  FOrganizationList.Free;
  FSource.free;
  FPolicyList.Free;
  FPolicyRule.free;
  FVerificationList.Free;
  FProvision.free;
  inherited;
end;

function TFhirConsent.GetResourceType : TFhirResourceType;
begin
  result := frtConsent;
end;

procedure TFhirConsent.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirConsent(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirConsent(oSource).FIdentifierList);
  end;
  FStatus := TFhirConsent(oSource).FStatus.Link;
  scope := TFhirConsent(oSource).scope.Clone;
  if (TFhirConsent(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirConsent(oSource).FCategoryList);
  end;
  patient := TFhirConsent(oSource).patient.Clone;
  dateTimeElement := TFhirConsent(oSource).dateTimeElement.Clone;
  if (TFhirConsent(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirReferenceList{TFhirOrganization}.Create;
    FPerformerList.Assign(TFhirConsent(oSource).FPerformerList);
  end;
  if (TFhirConsent(oSource).FOrganizationList = nil) then
  begin
    FOrganizationList.free;
    FOrganizationList := nil;
  end
  else
  begin
    if FOrganizationList = nil then
      FOrganizationList := TFhirReferenceList{TFhirOrganization}.Create;
    FOrganizationList.Assign(TFhirConsent(oSource).FOrganizationList);
  end;
  source := TFhirConsent(oSource).source.Clone;
  if (TFhirConsent(oSource).FPolicyList = nil) then
  begin
    FPolicyList.free;
    FPolicyList := nil;
  end
  else
  begin
    if FPolicyList = nil then
      FPolicyList := TFhirConsentPolicyList.Create;
    FPolicyList.Assign(TFhirConsent(oSource).FPolicyList);
  end;
  policyRule := TFhirConsent(oSource).policyRule.Clone;
  if (TFhirConsent(oSource).FVerificationList = nil) then
  begin
    FVerificationList.free;
    FVerificationList := nil;
  end
  else
  begin
    if FVerificationList = nil then
      FVerificationList := TFhirConsentVerificationList.Create;
    FVerificationList.Assign(TFhirConsent(oSource).FVerificationList);
  end;
  provision := TFhirConsent(oSource).provision.Clone;
end;

procedure TFhirConsent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'scope') Then
     list.add(self.link, 'scope', FScope.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'dateTime') Then
     list.add(self.link, 'dateTime', FDateTime.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'organization') Then
    list.addAll(self, 'organization', FOrganizationList);
  if (child_name = 'source[x]') or (child_name = 'source') Then
     list.add(self.link, 'source[x]', FSource.Link);
  if (child_name = 'policy') Then
    list.addAll(self, 'policy', FPolicyList);
  if (child_name = 'policyRule') Then
     list.add(self.link, 'policyRule', FPolicyRule.Link);
  if (child_name = 'verification') Then
    list.addAll(self, 'verification', FVerificationList);
  if (child_name = 'provision') Then
     list.add(self.link, 'provision', FProvision.Link);
end;

procedure TFhirConsent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'scope', 'CodeableConcept', false, TFhirCodeableConcept, FScope.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateTime', 'dateTime', false, TFhirDateTime, FDateTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FPerformerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FOrganizationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'source[x]', 'Attachment|Reference(Consent)', false, TFhirType, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'policy', '', true, TFhirConsentPolicy, FPolicyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'policyRule', 'CodeableConcept', false, TFhirCodeableConcept, FPolicyRule.Link));{2}
  oList.add(TFHIRProperty.create(self, 'verification', '', true, TFhirConsentVerification, FVerificationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'provision', '', false, TFhirConsentProvision, FProvision.Link));{2}
end;

function TFhirConsent.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirConsentStateCodesEnum, CODES_TFhirConsentStateCodesEnum, propValue);
    result := propValue
  end
  else if (propName = 'scope') then
  begin
    Scope := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'dateTime') then
  begin
    DateTimeElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    OrganizationList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'source', ['Attachment', 'Reference'])) then
  begin
    Source := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'policy') then
  begin
    PolicyList.add(propValue as TFhirConsentPolicy){2a};
    result := propValue;
  end
  else if (propName = 'policyRule') then
  begin
    PolicyRule := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'verification') then
  begin
    VerificationList.add(propValue as TFhirConsentVerification){2a};
    result := propValue;
  end
  else if (propName = 'provision') then
  begin
    Provision := propValue as TFhirConsentProvision{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirConsent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else if (propName = 'organization') then OrganizationList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else if (propName = 'policy') then PolicyList.insertItem(index, propValue as TFhirConsentPolicy){2a}
  else if (propName = 'verification') then VerificationList.insertItem(index, propValue as TFhirConsentVerification){2a}
  else inherited;
end;

function TFhirConsent.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'scope') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := CategoryList.new(){2}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'dateTime') then result := TFhirDateTime.create() {5b}
  else if (propName = 'performer') then result := PerformerList.new(){2}
  else if (propName = 'organization') then result := OrganizationList.new(){2}
  else if (isMatchingName(propName, 'source', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Source'){4x}
  else if (propName = 'policy') then result := PolicyList.new(){2}
  else if (propName = 'policyRule') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'verification') then result := VerificationList.new(){2}
  else if (propName = 'provision') then result := TFhirConsentProvision.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'scope') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'dateTime') then result := 'dateTime'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'source[x]') then result := 'Attachment|Reference'
  else if (propName = 'policy') then result := ''
  else if (propName = 'policyRule') then result := 'CodeableConcept'
  else if (propName = 'verification') then result := ''
  else if (propName = 'provision') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsent.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'scope') then ScopeElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {2}
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'dateTime') then DateTimeElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {2}
  else if (propName = 'organization') then deletePropertyValue('organization', OrganizationList, value) {2}
  else if (isMatchingName(propName, 'source', ['Attachment', 'Reference'])) then SourceElement := nil{4x}
  else if (propName = 'policy') then deletePropertyValue('policy', PolicyList, value) {2}
  else if (propName = 'policyRule') then PolicyRuleElement := nil
  else if (propName = 'verification') then deletePropertyValue('verification', VerificationList, value) {2}
  else if (propName = 'provision') then ProvisionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirConsentStateCodesEnum, CODES_TFhirConsentStateCodesEnum, new){4}
  else if (propName = 'scope') then ScopeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {2}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'dateTime') then DateTimeElement := asDateTime(new){5b}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {2}
  else if (propName = 'organization') then replacePropertyValue('organization', OrganizationList, existing, new) {2}
  else if (isMatchingName(propName, 'source', ['Attachment', 'Reference'])) then SourceElement := new as TFhirType{4x}
  else if (propName = 'policy') then replacePropertyValue('policy', PolicyList, existing, new) {2}
  else if (propName = 'policyRule') then PolicyRuleElement := new as TFhirCodeableConcept{4}
  else if (propName = 'verification') then replacePropertyValue('verification', VerificationList, existing, new) {2}
  else if (propName = 'provision') then ProvisionElement := new as TFhirConsentProvision{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'category') then CategoryList.move(source, destination){2a}
  else if (propName = 'performer') then PerformerList.move(source, destination){2a}
  else if (propName = 'organization') then OrganizationList.move(source, destination){2a}
  else if (propName = 'policy') then PolicyList.move(source, destination){2a}
  else if (propName = 'verification') then VerificationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConsent.fhirType : string;
begin
  result := 'Consent';
end;

function TFhirConsent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FScope) and isEmptyProp(FcategoryList) and isEmptyProp(FPatient) and isEmptyProp(FDateTime) and isEmptyProp(FperformerList) and isEmptyProp(ForganizationList) and isEmptyProp(FSource) and isEmptyProp(FpolicyList) and isEmptyProp(FPolicyRule) and isEmptyProp(FverificationList) and isEmptyProp(FProvision);
end;

function TFhirConsent.equals(other : TObject) : boolean; 
var
  o : TFhirConsent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsent)) then
    result := false
  else
  begin
    o := TFhirConsent(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(scopeElement, o.scopeElement, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(dateTimeElement, o.dateTimeElement, true) and 
      compareDeep(performerList, o.performerList, true) and compareDeep(organizationList, o.organizationList, true) and 
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(policyList, o.policyList, true) and 
      compareDeep(policyRuleElement, o.policyRuleElement, true) and compareDeep(verificationList, o.verificationList, true) and 
      compareDeep(provisionElement, o.provisionElement, true);
  end;
end;

function TFhirConsent.Link : TFhirConsent;
begin
  result := TFhirConsent(inherited Link);
end;

function TFhirConsent.Clone : TFhirConsent;
begin
  result := TFhirConsent(inherited Clone);
end;

procedure TFhirConsent.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('scope');
  fields.add('category');
  fields.add('patient');
  fields.add('dateTime');
  fields.add('performer');
  fields.add('organization');
  fields.add('source[x]');
  fields.add('policy');
  fields.add('policyRule');
  fields.add('verification');
  fields.add('provision');
end;

{ TFhirConsent }

Function TFhirConsent.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirConsent.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirConsent.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirConsent.GetStatusST : TFhirConsentStateCodesEnum;
begin
  if FStatus = nil then
    result := TFhirConsentStateCodesEnum(0)
  else
    result := TFhirConsentStateCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirConsentStateCodesEnum, FStatus.value));
end;

Procedure TFhirConsent.SetStatusST(value : TFhirConsentStateCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirConsentStateCodesEnum[value], CODES_TFhirConsentStateCodesEnum[value]);
end;

Procedure TFhirConsent.SetScope(value : TFhirCodeableConcept);
begin
  FScope.free;
  FScope := value;
end;

Function TFhirConsent.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

Function TFhirConsent.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

Procedure TFhirConsent.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirConsent.SetDateTime(value : TFhirDateTime);
begin
  FDateTime.free;
  FDateTime := value;
end;

Function TFhirConsent.GetDateTimeST : TFslDateTime;
begin
  if FDateTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateTime.value;
end;

Procedure TFhirConsent.SetDateTimeST(value : TFslDateTime);
begin
  if FDateTime = nil then
    FDateTime := TFhirDateTime.create;
  FDateTime.value := value
end;

Function TFhirConsent.GetPerformerList : TFhirReferenceList{TFhirOrganization};
begin
  if FPerformerList = nil then
    FPerformerList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FPerformerList;
end;

Function TFhirConsent.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

Function TFhirConsent.GetOrganizationList : TFhirReferenceList{TFhirOrganization};
begin
  if FOrganizationList = nil then
    FOrganizationList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FOrganizationList;
end;

Function TFhirConsent.GetHasOrganizationList : boolean;
begin
  result := (FOrganizationList <> nil) and (FOrganizationList.count > 0);
end;

Procedure TFhirConsent.SetSource(value : TFhirType);
begin
  FSource.free;
  FSource := value;
end;

Function TFhirConsent.GetPolicyList : TFhirConsentPolicyList;
begin
  if FPolicyList = nil then
    FPolicyList := TFhirConsentPolicyList.Create;
  result := FPolicyList;
end;

Function TFhirConsent.GetHasPolicyList : boolean;
begin
  result := (FPolicyList <> nil) and (FPolicyList.count > 0);
end;

Procedure TFhirConsent.SetPolicyRule(value : TFhirCodeableConcept);
begin
  FPolicyRule.free;
  FPolicyRule := value;
end;

Function TFhirConsent.GetVerificationList : TFhirConsentVerificationList;
begin
  if FVerificationList = nil then
    FVerificationList := TFhirConsentVerificationList.Create;
  result := FVerificationList;
end;

Function TFhirConsent.GetHasVerificationList : boolean;
begin
  result := (FVerificationList <> nil) and (FVerificationList.count > 0);
end;

Procedure TFhirConsent.SetProvision(value : TFhirConsentProvision);
begin
  FProvision.free;
  FProvision := value;
end;

function TFhirConsent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FScope.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FDateTime.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, ForganizationList.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FpolicyList.sizeInBytes);
  inc(result, FPolicyRule.sizeInBytes);
  inc(result, FverificationList.sizeInBytes);
  inc(result, FProvision.sizeInBytes);
end;

{ TFhirConsentListEnumerator }

Constructor TFhirConsentListEnumerator.Create(list : TFhirConsentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentListEnumerator.GetCurrent : TFhirConsent;
begin
  Result := FList[FIndex];
end;

function TFhirConsentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConsentList }
procedure TFhirConsentList.AddItem(value: TFhirConsent);
begin
  assert(value.ClassName = 'TFhirConsent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsent');
  add(value);
end;

function TFhirConsentList.Append: TFhirConsent;
begin
  result := TFhirConsent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentList.ClearItems;
begin
  Clear;
end;

function TFhirConsentList.GetEnumerator : TFhirConsentListEnumerator;
begin
  result := TFhirConsentListEnumerator.Create(self.link);
end;

function TFhirConsentList.Clone: TFhirConsentList;
begin
  result := TFhirConsentList(inherited Clone);
end;

function TFhirConsentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentList.GetItemN(index: Integer): TFhirConsent;
begin
  result := TFhirConsent(ObjectByIndex[index]);
end;

function TFhirConsentList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsent;
end;
function TFhirConsentList.IndexOf(value: TFhirConsent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentList.Insert(index: Integer): TFhirConsent;
begin
  result := TFhirConsent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentList.InsertItem(index: Integer; value: TFhirConsent);
begin
  assert(value is TFhirConsent);
  Inherited Insert(index, value);
end;

function TFhirConsentList.Item(index: Integer): TFhirConsent;
begin
  result := TFhirConsent(ObjectByIndex[index]);
end;

function TFhirConsentList.Link: TFhirConsentList;
begin
  result := TFhirConsentList(inherited Link);
end;

procedure TFhirConsentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentList.SetItemByIndex(index: Integer; value: TFhirConsent);
begin
  assert(value is TFhirConsent);
  FhirConsents[index] := value;
end;

procedure TFhirConsentList.SetItemN(index: Integer; value: TFhirConsent);
begin
  assert(value is TFhirConsent);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CONSENT}

{$IFDEF FHIR_CONTRACT}

{ TFhirContractContentDefinition }

constructor TFhirContractContentDefinition.Create;
begin
  inherited;
end;

destructor TFhirContractContentDefinition.Destroy;
begin
  FType_.free;
  FSubType.free;
  FPublisher.free;
  FPublicationDate.free;
  FPublicationStatus.free;
  FCopyright.free;
  inherited;
end;

procedure TFhirContractContentDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirContractContentDefinition(oSource).type_.Clone;
  subType := TFhirContractContentDefinition(oSource).subType.Clone;
  publisher := TFhirContractContentDefinition(oSource).publisher.Clone;
  publicationDateElement := TFhirContractContentDefinition(oSource).publicationDateElement.Clone;
  FPublicationStatus := TFhirContractContentDefinition(oSource).FPublicationStatus.Link;
  copyrightElement := TFhirContractContentDefinition(oSource).copyrightElement.Clone;
end;

procedure TFhirContractContentDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
     list.add(self.link, 'subType', FSubType.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'publicationDate') Then
     list.add(self.link, 'publicationDate', FPublicationDate.Link);
  if (child_name = 'publicationStatus') Then
     list.add(self.link, 'publicationStatus', FPublicationStatus.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
end;

procedure TFhirContractContentDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', false, TFhirCodeableConcept, FSubType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'publisher', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FPublisher.Link));{2}
  oList.add(TFHIRProperty.create(self, 'publicationDate', 'dateTime', false, TFhirDateTime, FPublicationDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'publicationStatus', 'code', false, TFHIREnum, FPublicationStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
end;

function TFhirContractContentDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    Publisher := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'publicationDate') then
  begin
    PublicationDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'publicationStatus') then
  begin
    PublicationStatusElement := asEnum(SYSTEMS_TFhirContractPublicationstatusEnum, CODES_TFhirContractPublicationstatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractContentDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractContentDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'publisher') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'publicationDate') then result := TFhirDateTime.create() {5b}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractContentDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'publisher') then result := 'Reference'
  else if (propName = 'publicationDate') then result := 'dateTime'
  else if (propName = 'publicationStatus') then result := 'code'
  else if (propName = 'copyright') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractContentDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then SubTypeElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'publicationDate') then PublicationDateElement := nil
  else if (propName = 'publicationStatus') then PublicationStatusElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractContentDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'subType') then SubTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'publisher') then PublisherElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'publicationDate') then PublicationDateElement := asDateTime(new){5b}
  else if (propName = 'publicationStatus') then PublicationStatusElement := asEnum(SYSTEMS_TFhirContractPublicationstatusEnum, CODES_TFhirContractPublicationstatusEnum, new){4}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractContentDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractContentDefinition.fhirType : string;
begin
  result := 'contentDefinition';
end;

function TFhirContractContentDefinition.Link : TFhirContractContentDefinition;
begin
  result := TFhirContractContentDefinition(inherited Link);
end;

function TFhirContractContentDefinition.Clone : TFhirContractContentDefinition;
begin
  result := TFhirContractContentDefinition(inherited Clone);
end;

function TFhirContractContentDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirContractContentDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractContentDefinition)) then
    result := false
  else
  begin
    o := TFhirContractContentDefinition(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeElement, o.subTypeElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(publicationDateElement, o.publicationDateElement, true) and 
      compareDeep(publicationStatusElement, o.publicationStatusElement, true) and compareDeep(copyrightElement, o.copyrightElement, true);
  end;
end;

function TFhirContractContentDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FSubType) and isEmptyProp(FPublisher) and isEmptyProp(FPublicationDate) and isEmptyProp(FPublicationStatus) and isEmptyProp(FCopyright);
end;

procedure TFhirContractContentDefinition.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('subType');
  fields.add('publisher');
  fields.add('publicationDate');
  fields.add('publicationStatus');
  fields.add('copyright');
end;

{ TFhirContractContentDefinition }

Procedure TFhirContractContentDefinition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirContractContentDefinition.SetSubType(value : TFhirCodeableConcept);
begin
  FSubType.free;
  FSubType := value;
end;

Procedure TFhirContractContentDefinition.SetPublisher(value : TFhirReference{TFhirPractitioner});
begin
  FPublisher.free;
  FPublisher := value;
end;

Procedure TFhirContractContentDefinition.SetPublicationDate(value : TFhirDateTime);
begin
  FPublicationDate.free;
  FPublicationDate := value;
end;

Function TFhirContractContentDefinition.GetPublicationDateST : TFslDateTime;
begin
  if FPublicationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FPublicationDate.value;
end;

Procedure TFhirContractContentDefinition.SetPublicationDateST(value : TFslDateTime);
begin
  if FPublicationDate = nil then
    FPublicationDate := TFhirDateTime.create;
  FPublicationDate.value := value
end;

Procedure TFhirContractContentDefinition.SetPublicationStatus(value : TFhirEnum);
begin
  FPublicationStatus.free;
  FPublicationStatus := value;
end;

Function TFhirContractContentDefinition.GetPublicationStatusST : TFhirContractPublicationstatusEnum;
begin
  if FPublicationStatus = nil then
    result := TFhirContractPublicationstatusEnum(0)
  else
    result := TFhirContractPublicationstatusEnum(StringArrayIndexOfSensitive(CODES_TFhirContractPublicationstatusEnum, FPublicationStatus.value));
end;

Procedure TFhirContractContentDefinition.SetPublicationStatusST(value : TFhirContractPublicationstatusEnum);
begin
  if ord(value) = 0 then
    PublicationStatusElement := nil
  else
    PublicationStatusElement := TFhirEnum.create(SYSTEMS_TFhirContractPublicationstatusEnum[value], CODES_TFhirContractPublicationstatusEnum[value]);
end;

Procedure TFhirContractContentDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirContractContentDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirContractContentDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

function TFhirContractContentDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FSubType.sizeInBytes);
  inc(result, FPublisher.sizeInBytes);
  inc(result, FPublicationDate.sizeInBytes);
  inc(result, FPublicationStatus.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
end;

{ TFhirContractContentDefinitionListEnumerator }

Constructor TFhirContractContentDefinitionListEnumerator.Create(list : TFhirContractContentDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractContentDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractContentDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractContentDefinitionListEnumerator.GetCurrent : TFhirContractContentDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirContractContentDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractContentDefinitionList }
procedure TFhirContractContentDefinitionList.AddItem(value: TFhirContractContentDefinition);
begin
  assert(value.ClassName = 'TFhirContractContentDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractContentDefinition');
  add(value);
end;

function TFhirContractContentDefinitionList.Append: TFhirContractContentDefinition;
begin
  result := TFhirContractContentDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractContentDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirContractContentDefinitionList.GetEnumerator : TFhirContractContentDefinitionListEnumerator;
begin
  result := TFhirContractContentDefinitionListEnumerator.Create(self.link);
end;

function TFhirContractContentDefinitionList.Clone: TFhirContractContentDefinitionList;
begin
  result := TFhirContractContentDefinitionList(inherited Clone);
end;

function TFhirContractContentDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractContentDefinitionList.GetItemN(index: Integer): TFhirContractContentDefinition;
begin
  result := TFhirContractContentDefinition(ObjectByIndex[index]);
end;

function TFhirContractContentDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractContentDefinition;
end;
function TFhirContractContentDefinitionList.IndexOf(value: TFhirContractContentDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractContentDefinitionList.Insert(index: Integer): TFhirContractContentDefinition;
begin
  result := TFhirContractContentDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractContentDefinitionList.InsertItem(index: Integer; value: TFhirContractContentDefinition);
begin
  assert(value is TFhirContractContentDefinition);
  Inherited Insert(index, value);
end;

function TFhirContractContentDefinitionList.Item(index: Integer): TFhirContractContentDefinition;
begin
  result := TFhirContractContentDefinition(ObjectByIndex[index]);
end;

function TFhirContractContentDefinitionList.Link: TFhirContractContentDefinitionList;
begin
  result := TFhirContractContentDefinitionList(inherited Link);
end;

procedure TFhirContractContentDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractContentDefinitionList.SetItemByIndex(index: Integer; value: TFhirContractContentDefinition);
begin
  assert(value is TFhirContractContentDefinition);
  FhirContractContentDefinitions[index] := value;
end;

procedure TFhirContractContentDefinitionList.SetItemN(index: Integer; value: TFhirContractContentDefinition);
begin
  assert(value is TFhirContractContentDefinition);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTerm }

constructor TFhirContractTerm.Create;
begin
  inherited;
end;

destructor TFhirContractTerm.Destroy;
begin
  FIdentifier.free;
  FIssued.free;
  FApplies.free;
  FTopic.free;
  FType_.free;
  FSubType.free;
  FText.free;
  FSecurityLabelList.Free;
  FOffer.free;
  FAssetList.Free;
  FActionList.Free;
  FGroupList.Free;
  inherited;
end;

procedure TFhirContractTerm.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirContractTerm(oSource).identifier.Clone;
  issuedElement := TFhirContractTerm(oSource).issuedElement.Clone;
  applies := TFhirContractTerm(oSource).applies.Clone;
  topic := TFhirContractTerm(oSource).topic.Clone;
  type_ := TFhirContractTerm(oSource).type_.Clone;
  subType := TFhirContractTerm(oSource).subType.Clone;
  textElement := TFhirContractTerm(oSource).textElement.Clone;
  if (TFhirContractTerm(oSource).FSecurityLabelList = nil) then
  begin
    FSecurityLabelList.free;
    FSecurityLabelList := nil;
  end
  else
  begin
    if FSecurityLabelList = nil then
      FSecurityLabelList := TFhirContractTermSecurityLabelList.Create;
    FSecurityLabelList.Assign(TFhirContractTerm(oSource).FSecurityLabelList);
  end;
  offer := TFhirContractTerm(oSource).offer.Clone;
  if (TFhirContractTerm(oSource).FAssetList = nil) then
  begin
    FAssetList.free;
    FAssetList := nil;
  end
  else
  begin
    if FAssetList = nil then
      FAssetList := TFhirContractTermAssetList.Create;
    FAssetList.Assign(TFhirContractTerm(oSource).FAssetList);
  end;
  if (TFhirContractTerm(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirContractTermActionList.Create;
    FActionList.Assign(TFhirContractTerm(oSource).FActionList);
  end;
  if (TFhirContractTerm(oSource).FGroupList = nil) then
  begin
    FGroupList.free;
    FGroupList := nil;
  end
  else
  begin
    if FGroupList = nil then
      FGroupList := TFhirContractTermList.Create;
    FGroupList.Assign(TFhirContractTerm(oSource).FGroupList);
  end;
end;

procedure TFhirContractTerm.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'applies') Then
     list.add(self.link, 'applies', FApplies.Link);
  if (child_name = 'topic[x]') or (child_name = 'topic') Then
     list.add(self.link, 'topic[x]', FTopic.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
     list.add(self.link, 'subType', FSubType.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'securityLabel') Then
    list.addAll(self, 'securityLabel', FSecurityLabelList);
  if (child_name = 'offer') Then
     list.add(self.link, 'offer', FOffer.Link);
  if (child_name = 'asset') Then
    list.addAll(self, 'asset', FAssetList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
  if (child_name = 'group') Then
    list.addAll(self, 'group', FGroupList);
end;

procedure TFhirContractTerm.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'issued', 'dateTime', false, TFhirDateTime, FIssued.Link));{2}
  oList.add(TFHIRProperty.create(self, 'applies', 'Period', false, TFhirPeriod, FApplies.Link));{2}
  oList.add(TFHIRProperty.create(self, 'topic[x]', 'CodeableConcept|Reference(Any)', false, TFhirType, FTopic.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', false, TFhirCodeableConcept, FSubType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'securityLabel', '', true, TFhirContractTermSecurityLabel, FSecurityLabelList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'offer', '', false, TFhirContractTermOffer, FOffer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'asset', '', true, TFhirContractTermAsset, FAssetList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirContractTermAction, FActionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'group', '@Contract.term', true, TFhirContractTerm, FGroupList.Link)){3};
end;

function TFhirContractTerm.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'applies') then
  begin
    Applies := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then
  begin
    Topic := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'securityLabel') then
  begin
    SecurityLabelList.add(propValue as TFhirContractTermSecurityLabel){2a};
    result := propValue;
  end
  else if (propName = 'offer') then
  begin
    Offer := propValue as TFhirContractTermOffer{4b};
    result := propValue;
  end
  else if (propName = 'asset') then
  begin
    AssetList.add(propValue as TFhirContractTermAsset){2a};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirContractTermAction){2a};
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    GroupList.add(propValue as TFhirContractTerm){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTerm.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'securityLabel') then SecurityLabelList.insertItem(index, propValue as TFhirContractTermSecurityLabel){2a}
  else if (propName = 'asset') then AssetList.insertItem(index, propValue as TFhirContractTermAsset){2a}
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirContractTermAction){2a}
  else if (propName = 'group') then GroupList.insertItem(index, propValue as TFhirContractTerm){2a}
  else inherited;
end;

function TFhirContractTerm.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'issued') then result := TFhirDateTime.create() {5b}
  else if (propName = 'applies') then result := TFhirPeriod.create(){4b}
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Topic'){4x}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'securityLabel') then result := SecurityLabelList.new(){2}
  else if (propName = 'offer') then result := TFhirContractTermOffer.create(){4b}
  else if (propName = 'asset') then result := AssetList.new(){2}
  else if (propName = 'action') then result := ActionList.new(){2}
  else if (propName = 'group') then result := GroupList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTerm.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'issued') then result := 'dateTime'
  else if (propName = 'applies') then result := 'Period'
  else if (propName = 'topic[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'securityLabel') then result := ''
  else if (propName = 'offer') then result := ''
  else if (propName = 'asset') then result := ''
  else if (propName = 'action') then result := ''
  else if (propName = 'group') then result := '@Contract.term'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTerm.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'applies') then AppliesElement := nil
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then TopicElement := nil{4x}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then SubTypeElement := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'securityLabel') then deletePropertyValue('securityLabel', SecurityLabelList, value) {2}
  else if (propName = 'offer') then OfferElement := nil
  else if (propName = 'asset') then deletePropertyValue('asset', AssetList, value) {2}
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else if (propName = 'group') then deletePropertyValue('group', GroupList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTerm.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'issued') then IssuedElement := asDateTime(new){5b}
  else if (propName = 'applies') then AppliesElement := new as TFhirPeriod{4}
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then TopicElement := new as TFhirType{4x}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'subType') then SubTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'securityLabel') then replacePropertyValue('securityLabel', SecurityLabelList, existing, new) {2}
  else if (propName = 'offer') then OfferElement := new as TFhirContractTermOffer{4}
  else if (propName = 'asset') then replacePropertyValue('asset', AssetList, existing, new) {2}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else if (propName = 'group') then replacePropertyValue('group', GroupList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTerm.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'securityLabel') then SecurityLabelList.move(source, destination){2a}
  else if (propName = 'asset') then AssetList.move(source, destination){2a}
  else if (propName = 'action') then ActionList.move(source, destination){2a}
  else if (propName = 'group') then GroupList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTerm.fhirType : string;
begin
  result := 'term';
end;

function TFhirContractTerm.Link : TFhirContractTerm;
begin
  result := TFhirContractTerm(inherited Link);
end;

function TFhirContractTerm.Clone : TFhirContractTerm;
begin
  result := TFhirContractTerm(inherited Clone);
end;

function TFhirContractTerm.equals(other : TObject) : boolean; 
var
  o : TFhirContractTerm;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTerm)) then
    result := false
  else
  begin
    o := TFhirContractTerm(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(issuedElement, o.issuedElement, true) and 
      compareDeep(appliesElement, o.appliesElement, true) and compareDeep(topicElement, o.topicElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeElement, o.subTypeElement, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(securityLabelList, o.securityLabelList, true) and 
      compareDeep(offerElement, o.offerElement, true) and compareDeep(assetList, o.assetList, true) and 
      compareDeep(actionList, o.actionList, true) and compareDeep(groupList, o.groupList, true);
  end;
end;

function TFhirContractTerm.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FIssued) and isEmptyProp(FApplies) and isEmptyProp(FTopic) and isEmptyProp(FType_) and isEmptyProp(FSubType) and isEmptyProp(FText) and isEmptyProp(FsecurityLabelList) and isEmptyProp(FOffer) and isEmptyProp(FassetList) and isEmptyProp(FactionList) and isEmptyProp(FgroupList);
end;

procedure TFhirContractTerm.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('issued');
  fields.add('applies');
  fields.add('topic[x]');
  fields.add('type');
  fields.add('subType');
  fields.add('text');
  fields.add('securityLabel');
  fields.add('offer');
  fields.add('asset');
  fields.add('action');
  fields.add('group');
end;

{ TFhirContractTerm }

Procedure TFhirContractTerm.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirContractTerm.SetIssued(value : TFhirDateTime);
begin
  FIssued.free;
  FIssued := value;
end;

Function TFhirContractTerm.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

Procedure TFhirContractTerm.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirDateTime.create;
  FIssued.value := value
end;

Procedure TFhirContractTerm.SetApplies(value : TFhirPeriod);
begin
  FApplies.free;
  FApplies := value;
end;

Procedure TFhirContractTerm.SetTopic(value : TFhirType);
begin
  FTopic.free;
  FTopic := value;
end;

Procedure TFhirContractTerm.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirContractTerm.SetSubType(value : TFhirCodeableConcept);
begin
  FSubType.free;
  FSubType := value;
end;

Procedure TFhirContractTerm.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirContractTerm.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirContractTerm.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Function TFhirContractTerm.GetSecurityLabelList : TFhirContractTermSecurityLabelList;
begin
  if FSecurityLabelList = nil then
    FSecurityLabelList := TFhirContractTermSecurityLabelList.Create;
  result := FSecurityLabelList;
end;

Function TFhirContractTerm.GetHasSecurityLabelList : boolean;
begin
  result := (FSecurityLabelList <> nil) and (FSecurityLabelList.count > 0);
end;

Procedure TFhirContractTerm.SetOffer(value : TFhirContractTermOffer);
begin
  FOffer.free;
  FOffer := value;
end;

Function TFhirContractTerm.GetAssetList : TFhirContractTermAssetList;
begin
  if FAssetList = nil then
    FAssetList := TFhirContractTermAssetList.Create;
  result := FAssetList;
end;

Function TFhirContractTerm.GetHasAssetList : boolean;
begin
  result := (FAssetList <> nil) and (FAssetList.count > 0);
end;

Function TFhirContractTerm.GetActionList : TFhirContractTermActionList;
begin
  if FActionList = nil then
    FActionList := TFhirContractTermActionList.Create;
  result := FActionList;
end;

Function TFhirContractTerm.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

Function TFhirContractTerm.GetGroupList : TFhirContractTermList;
begin
  if FGroupList = nil then
    FGroupList := TFhirContractTermList.Create;
  result := FGroupList;
end;

Function TFhirContractTerm.GetHasGroupList : boolean;
begin
  result := (FGroupList <> nil) and (FGroupList.count > 0);
end;

function TFhirContractTerm.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FIssued.sizeInBytes);
  inc(result, FApplies.sizeInBytes);
  inc(result, FTopic.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSubType.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FsecurityLabelList.sizeInBytes);
  inc(result, FOffer.sizeInBytes);
  inc(result, FassetList.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
  inc(result, FgroupList.sizeInBytes);
end;

{ TFhirContractTermListEnumerator }

Constructor TFhirContractTermListEnumerator.Create(list : TFhirContractTermList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermListEnumerator.GetCurrent : TFhirContractTerm;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractTermList }
procedure TFhirContractTermList.AddItem(value: TFhirContractTerm);
begin
  assert(value.ClassName = 'TFhirContractTerm', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTerm');
  add(value);
end;

function TFhirContractTermList.Append: TFhirContractTerm;
begin
  result := TFhirContractTerm.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermList.GetEnumerator : TFhirContractTermListEnumerator;
begin
  result := TFhirContractTermListEnumerator.Create(self.link);
end;

function TFhirContractTermList.Clone: TFhirContractTermList;
begin
  result := TFhirContractTermList(inherited Clone);
end;

function TFhirContractTermList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermList.GetItemN(index: Integer): TFhirContractTerm;
begin
  result := TFhirContractTerm(ObjectByIndex[index]);
end;

function TFhirContractTermList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTerm;
end;
function TFhirContractTermList.IndexOf(value: TFhirContractTerm): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermList.Insert(index: Integer): TFhirContractTerm;
begin
  result := TFhirContractTerm.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermList.InsertItem(index: Integer; value: TFhirContractTerm);
begin
  assert(value is TFhirContractTerm);
  Inherited Insert(index, value);
end;

function TFhirContractTermList.Item(index: Integer): TFhirContractTerm;
begin
  result := TFhirContractTerm(ObjectByIndex[index]);
end;

function TFhirContractTermList.Link: TFhirContractTermList;
begin
  result := TFhirContractTermList(inherited Link);
end;

procedure TFhirContractTermList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermList.SetItemByIndex(index: Integer; value: TFhirContractTerm);
begin
  assert(value is TFhirContractTerm);
  FhirContractTerms[index] := value;
end;

procedure TFhirContractTermList.SetItemN(index: Integer; value: TFhirContractTerm);
begin
  assert(value is TFhirContractTerm);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermSecurityLabel }

constructor TFhirContractTermSecurityLabel.Create;
begin
  inherited;
end;

destructor TFhirContractTermSecurityLabel.Destroy;
begin
  FNumberList.Free;
  FClassification.free;
  FCategoryList.Free;
  FControlList.Free;
  inherited;
end;

procedure TFhirContractTermSecurityLabel.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirContractTermSecurityLabel(oSource).FNumberList = nil) then
  begin
    FNumberList.free;
    FNumberList := nil;
  end
  else
  begin
    if FNumberList = nil then
      FNumberList := TFhirUnsignedIntList.Create;
    FNumberList.Assign(TFhirContractTermSecurityLabel(oSource).FNumberList);
  end;
  classification := TFhirContractTermSecurityLabel(oSource).classification.Clone;
  if (TFhirContractTermSecurityLabel(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodingList.Create;
    FCategoryList.Assign(TFhirContractTermSecurityLabel(oSource).FCategoryList);
  end;
  if (TFhirContractTermSecurityLabel(oSource).FControlList = nil) then
  begin
    FControlList.free;
    FControlList := nil;
  end
  else
  begin
    if FControlList = nil then
      FControlList := TFhirCodingList.Create;
    FControlList.Assign(TFhirContractTermSecurityLabel(oSource).FControlList);
  end;
end;

procedure TFhirContractTermSecurityLabel.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'number') Then
    list.addAll(self, 'number', FNumberList);
  if (child_name = 'classification') Then
     list.add(self.link, 'classification', FClassification.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'control') Then
    list.addAll(self, 'control', FControlList);
end;

procedure TFhirContractTermSecurityLabel.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'unsignedInt', true, TFhirUnsignedInt, FNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'classification', 'Coding', false, TFhirCoding, FClassification.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'Coding', true, TFhirCoding, FCategoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'control', 'Coding', true, TFhirCoding, FControlList.Link)){3};
end;

function TFhirContractTermSecurityLabel.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'number') then
  begin
    NumberList.add(asUnsignedInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'classification') then
  begin
    Classification := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'control') then
  begin
    ControlList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermSecurityLabel.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'number') then NumberList.insertItem(index, asUnsignedInt(propValue)){2}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'control') then ControlList.insertItem(index, propValue as TFhirCoding){2a}
  else inherited;
end;

function TFhirContractTermSecurityLabel.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'number') then result := NumberList.new(){2}
  else if (propName = 'classification') then result := TFhirCoding.create(){4b}
  else if (propName = 'category') then result := CategoryList.new(){2}
  else if (propName = 'control') then result := ControlList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermSecurityLabel.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'number') then result := 'unsignedInt'
  else if (propName = 'classification') then result := 'Coding'
  else if (propName = 'category') then result := 'Coding'
  else if (propName = 'control') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermSecurityLabel.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'number') then deletePropertyValue('number', NumberList, value) {2}
  else if (propName = 'classification') then ClassificationElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {2}
  else if (propName = 'control') then deletePropertyValue('control', ControlList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermSecurityLabel.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'number') then replacePropertyValue('number', NumberList, existing, new) {2}
  else if (propName = 'classification') then ClassificationElement := new as TFhirCoding{4}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {2}
  else if (propName = 'control') then replacePropertyValue('control', ControlList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermSecurityLabel.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'number') then NumberList.move(source, destination){2}
  else if (propName = 'category') then CategoryList.move(source, destination){2a}
  else if (propName = 'control') then ControlList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermSecurityLabel.fhirType : string;
begin
  result := 'securityLabel';
end;

function TFhirContractTermSecurityLabel.Link : TFhirContractTermSecurityLabel;
begin
  result := TFhirContractTermSecurityLabel(inherited Link);
end;

function TFhirContractTermSecurityLabel.Clone : TFhirContractTermSecurityLabel;
begin
  result := TFhirContractTermSecurityLabel(inherited Clone);
end;

function TFhirContractTermSecurityLabel.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermSecurityLabel;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermSecurityLabel)) then
    result := false
  else
  begin
    o := TFhirContractTermSecurityLabel(other);
    result := compareDeep(numberList, o.numberList, true) and compareDeep(classificationElement, o.classificationElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(controlList, o.controlList, true);
  end;
end;

function TFhirContractTermSecurityLabel.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FnumberList) and isEmptyProp(FClassification) and isEmptyProp(FcategoryList) and isEmptyProp(FcontrolList);
end;

procedure TFhirContractTermSecurityLabel.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('number');
  fields.add('classification');
  fields.add('category');
  fields.add('control');
end;

{ TFhirContractTermSecurityLabel }

Function TFhirContractTermSecurityLabel.GetNumberList : TFhirUnsignedIntList;
begin
  if FNumberList = nil then
    FNumberList := TFhirUnsignedIntList.Create;
  result := FNumberList;
end;

Function TFhirContractTermSecurityLabel.GetHasNumberList : boolean;
begin
  result := (FNumberList <> nil) and (FNumberList.count > 0);
end;

Procedure TFhirContractTermSecurityLabel.SetClassification(value : TFhirCoding);
begin
  FClassification.free;
  FClassification := value;
end;

Function TFhirContractTermSecurityLabel.GetCategoryList : TFhirCodingList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodingList.Create;
  result := FCategoryList;
end;

Function TFhirContractTermSecurityLabel.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

Function TFhirContractTermSecurityLabel.GetControlList : TFhirCodingList;
begin
  if FControlList = nil then
    FControlList := TFhirCodingList.Create;
  result := FControlList;
end;

Function TFhirContractTermSecurityLabel.GetHasControlList : boolean;
begin
  result := (FControlList <> nil) and (FControlList.count > 0);
end;

function TFhirContractTermSecurityLabel.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FnumberList.sizeInBytes);
  inc(result, FClassification.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FcontrolList.sizeInBytes);
end;

{ TFhirContractTermSecurityLabelListEnumerator }

Constructor TFhirContractTermSecurityLabelListEnumerator.Create(list : TFhirContractTermSecurityLabelList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermSecurityLabelListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermSecurityLabelListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermSecurityLabelListEnumerator.GetCurrent : TFhirContractTermSecurityLabel;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermSecurityLabelListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractTermSecurityLabelList }
procedure TFhirContractTermSecurityLabelList.AddItem(value: TFhirContractTermSecurityLabel);
begin
  assert(value.ClassName = 'TFhirContractTermSecurityLabel', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermSecurityLabel');
  add(value);
end;

function TFhirContractTermSecurityLabelList.Append: TFhirContractTermSecurityLabel;
begin
  result := TFhirContractTermSecurityLabel.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermSecurityLabelList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermSecurityLabelList.GetEnumerator : TFhirContractTermSecurityLabelListEnumerator;
begin
  result := TFhirContractTermSecurityLabelListEnumerator.Create(self.link);
end;

function TFhirContractTermSecurityLabelList.Clone: TFhirContractTermSecurityLabelList;
begin
  result := TFhirContractTermSecurityLabelList(inherited Clone);
end;

function TFhirContractTermSecurityLabelList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermSecurityLabelList.GetItemN(index: Integer): TFhirContractTermSecurityLabel;
begin
  result := TFhirContractTermSecurityLabel(ObjectByIndex[index]);
end;

function TFhirContractTermSecurityLabelList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermSecurityLabel;
end;
function TFhirContractTermSecurityLabelList.IndexOf(value: TFhirContractTermSecurityLabel): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermSecurityLabelList.Insert(index: Integer): TFhirContractTermSecurityLabel;
begin
  result := TFhirContractTermSecurityLabel.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermSecurityLabelList.InsertItem(index: Integer; value: TFhirContractTermSecurityLabel);
begin
  assert(value is TFhirContractTermSecurityLabel);
  Inherited Insert(index, value);
end;

function TFhirContractTermSecurityLabelList.Item(index: Integer): TFhirContractTermSecurityLabel;
begin
  result := TFhirContractTermSecurityLabel(ObjectByIndex[index]);
end;

function TFhirContractTermSecurityLabelList.Link: TFhirContractTermSecurityLabelList;
begin
  result := TFhirContractTermSecurityLabelList(inherited Link);
end;

procedure TFhirContractTermSecurityLabelList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermSecurityLabelList.SetItemByIndex(index: Integer; value: TFhirContractTermSecurityLabel);
begin
  assert(value is TFhirContractTermSecurityLabel);
  FhirContractTermSecurityLabels[index] := value;
end;

procedure TFhirContractTermSecurityLabelList.SetItemN(index: Integer; value: TFhirContractTermSecurityLabel);
begin
  assert(value is TFhirContractTermSecurityLabel);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermOffer }

constructor TFhirContractTermOffer.Create;
begin
  inherited;
end;

destructor TFhirContractTermOffer.Destroy;
begin
  FIdentifierList.Free;
  FPartyList.Free;
  FTopic.free;
  FType_.free;
  FDecision.free;
  FDecisionModeList.Free;
  FAnswerList.Free;
  FText.free;
  FLinkIdList.Free;
  FSecurityLabelNumberList.Free;
  inherited;
end;

procedure TFhirContractTermOffer.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirContractTermOffer(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirContractTermOffer(oSource).FIdentifierList);
  end;
  if (TFhirContractTermOffer(oSource).FPartyList = nil) then
  begin
    FPartyList.free;
    FPartyList := nil;
  end
  else
  begin
    if FPartyList = nil then
      FPartyList := TFhirContractTermOfferPartyList.Create;
    FPartyList.Assign(TFhirContractTermOffer(oSource).FPartyList);
  end;
  topic := TFhirContractTermOffer(oSource).topic.Clone;
  type_ := TFhirContractTermOffer(oSource).type_.Clone;
  decision := TFhirContractTermOffer(oSource).decision.Clone;
  if (TFhirContractTermOffer(oSource).FDecisionModeList = nil) then
  begin
    FDecisionModeList.free;
    FDecisionModeList := nil;
  end
  else
  begin
    if FDecisionModeList = nil then
      FDecisionModeList := TFhirCodeableConceptList.Create;
    FDecisionModeList.Assign(TFhirContractTermOffer(oSource).FDecisionModeList);
  end;
  if (TFhirContractTermOffer(oSource).FAnswerList = nil) then
  begin
    FAnswerList.free;
    FAnswerList := nil;
  end
  else
  begin
    if FAnswerList = nil then
      FAnswerList := TFhirContractTermOfferAnswerList.Create;
    FAnswerList.Assign(TFhirContractTermOffer(oSource).FAnswerList);
  end;
  textElement := TFhirContractTermOffer(oSource).textElement.Clone;
  if (TFhirContractTermOffer(oSource).FLinkIdList = nil) then
  begin
    FLinkIdList.free;
    FLinkIdList := nil;
  end
  else
  begin
    if FLinkIdList = nil then
      FLinkIdList := TFhirStringList.Create;
    FLinkIdList.Assign(TFhirContractTermOffer(oSource).FLinkIdList);
  end;
  if (TFhirContractTermOffer(oSource).FSecurityLabelNumberList = nil) then
  begin
    FSecurityLabelNumberList.free;
    FSecurityLabelNumberList := nil;
  end
  else
  begin
    if FSecurityLabelNumberList = nil then
      FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
    FSecurityLabelNumberList.Assign(TFhirContractTermOffer(oSource).FSecurityLabelNumberList);
  end;
end;

procedure TFhirContractTermOffer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'party') Then
    list.addAll(self, 'party', FPartyList);
  if (child_name = 'topic') Then
     list.add(self.link, 'topic', FTopic.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'decision') Then
     list.add(self.link, 'decision', FDecision.Link);
  if (child_name = 'decisionMode') Then
    list.addAll(self, 'decisionMode', FDecisionModeList);
  if (child_name = 'answer') Then
    list.addAll(self, 'answer', FAnswerList);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'linkId') Then
    list.addAll(self, 'linkId', FLinkIdList);
  if (child_name = 'securityLabelNumber') Then
    list.addAll(self, 'securityLabelNumber', FSecurityLabelNumberList);
end;

procedure TFhirContractTermOffer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'party', '', true, TFhirContractTermOfferParty, FPartyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'topic', 'Reference(Any)', false, TFhirReference{TFhirReference}, FTopic.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'decision', 'CodeableConcept', false, TFhirCodeableConcept, FDecision.Link));{2}
  oList.add(TFHIRProperty.create(self, 'decisionMode', 'CodeableConcept', true, TFhirCodeableConcept, FDecisionModeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'answer', '', true, TFhirContractTermOfferAnswer, FAnswerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', true, TFhirString, FLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'securityLabelNumber', 'unsignedInt', true, TFhirUnsignedInt, FSecurityLabelNumberList.Link)){3};
end;

function TFhirContractTermOffer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    PartyList.add(propValue as TFhirContractTermOfferParty){2a};
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    Topic := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'decision') then
  begin
    Decision := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'decisionMode') then
  begin
    DecisionModeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'answer') then
  begin
    AnswerList.add(propValue as TFhirContractTermOfferAnswer){2a};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'linkId') then
  begin
    LinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'securityLabelNumber') then
  begin
    SecurityLabelNumberList.add(asUnsignedInt(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermOffer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'party') then PartyList.insertItem(index, propValue as TFhirContractTermOfferParty){2a}
  else if (propName = 'decisionMode') then DecisionModeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'answer') then AnswerList.insertItem(index, propValue as TFhirContractTermOfferAnswer){2a}
  else if (propName = 'linkId') then LinkIdList.insertItem(index, asString(propValue)){2}
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.insertItem(index, asUnsignedInt(propValue)){2}
  else inherited;
end;

function TFhirContractTermOffer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'party') then result := PartyList.new(){2}
  else if (propName = 'topic') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'decision') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'decisionMode') then result := DecisionModeList.new(){2}
  else if (propName = 'answer') then result := AnswerList.new(){2}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'linkId') then result := LinkIdList.new(){2}
  else if (propName = 'securityLabelNumber') then result := SecurityLabelNumberList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermOffer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'party') then result := ''
  else if (propName = 'topic') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'decision') then result := 'CodeableConcept'
  else if (propName = 'decisionMode') then result := 'CodeableConcept'
  else if (propName = 'answer') then result := ''
  else if (propName = 'text') then result := 'string'
  else if (propName = 'linkId') then result := 'string'
  else if (propName = 'securityLabelNumber') then result := 'unsignedInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermOffer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'party') then deletePropertyValue('party', PartyList, value) {2}
  else if (propName = 'topic') then TopicElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'decision') then DecisionElement := nil
  else if (propName = 'decisionMode') then deletePropertyValue('decisionMode', DecisionModeList, value) {2}
  else if (propName = 'answer') then deletePropertyValue('answer', AnswerList, value) {2}
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'linkId') then deletePropertyValue('linkId', LinkIdList, value) {2}
  else if (propName = 'securityLabelNumber') then deletePropertyValue('securityLabelNumber', SecurityLabelNumberList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermOffer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'party') then replacePropertyValue('party', PartyList, existing, new) {2}
  else if (propName = 'topic') then TopicElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'decision') then DecisionElement := new as TFhirCodeableConcept{4}
  else if (propName = 'decisionMode') then replacePropertyValue('decisionMode', DecisionModeList, existing, new) {2}
  else if (propName = 'answer') then replacePropertyValue('answer', AnswerList, existing, new) {2}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'linkId') then replacePropertyValue('linkId', LinkIdList, existing, new) {2}
  else if (propName = 'securityLabelNumber') then replacePropertyValue('securityLabelNumber', SecurityLabelNumberList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermOffer.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'party') then PartyList.move(source, destination){2a}
  else if (propName = 'decisionMode') then DecisionModeList.move(source, destination){2a}
  else if (propName = 'answer') then AnswerList.move(source, destination){2a}
  else if (propName = 'linkId') then LinkIdList.move(source, destination){2}
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermOffer.fhirType : string;
begin
  result := 'offer';
end;

function TFhirContractTermOffer.Link : TFhirContractTermOffer;
begin
  result := TFhirContractTermOffer(inherited Link);
end;

function TFhirContractTermOffer.Clone : TFhirContractTermOffer;
begin
  result := TFhirContractTermOffer(inherited Clone);
end;

function TFhirContractTermOffer.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermOffer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermOffer)) then
    result := false
  else
  begin
    o := TFhirContractTermOffer(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(partyList, o.partyList, true) and 
      compareDeep(topicElement, o.topicElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(decisionElement, o.decisionElement, true) and compareDeep(decisionModeList, o.decisionModeList, true) and 
      compareDeep(answerList, o.answerList, true) and compareDeep(textElement, o.textElement, true) and 
      compareDeep(linkIdList, o.linkIdList, true) and compareDeep(securityLabelNumberList, o.securityLabelNumberList, true);
  end;
end;

function TFhirContractTermOffer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FpartyList) and isEmptyProp(FTopic) and isEmptyProp(FType_) and isEmptyProp(FDecision) and isEmptyProp(FdecisionModeList) and isEmptyProp(FanswerList) and isEmptyProp(FText) and isEmptyProp(FlinkIdList) and isEmptyProp(FsecurityLabelNumberList);
end;

procedure TFhirContractTermOffer.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('party');
  fields.add('topic');
  fields.add('type');
  fields.add('decision');
  fields.add('decisionMode');
  fields.add('answer');
  fields.add('text');
  fields.add('linkId');
  fields.add('securityLabelNumber');
end;

{ TFhirContractTermOffer }

Function TFhirContractTermOffer.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirContractTermOffer.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirContractTermOffer.GetPartyList : TFhirContractTermOfferPartyList;
begin
  if FPartyList = nil then
    FPartyList := TFhirContractTermOfferPartyList.Create;
  result := FPartyList;
end;

Function TFhirContractTermOffer.GetHasPartyList : boolean;
begin
  result := (FPartyList <> nil) and (FPartyList.count > 0);
end;

Procedure TFhirContractTermOffer.SetTopic(value : TFhirReference{TFhirReference});
begin
  FTopic.free;
  FTopic := value;
end;

Procedure TFhirContractTermOffer.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirContractTermOffer.SetDecision(value : TFhirCodeableConcept);
begin
  FDecision.free;
  FDecision := value;
end;

Function TFhirContractTermOffer.GetDecisionModeList : TFhirCodeableConceptList;
begin
  if FDecisionModeList = nil then
    FDecisionModeList := TFhirCodeableConceptList.Create;
  result := FDecisionModeList;
end;

Function TFhirContractTermOffer.GetHasDecisionModeList : boolean;
begin
  result := (FDecisionModeList <> nil) and (FDecisionModeList.count > 0);
end;

Function TFhirContractTermOffer.GetAnswerList : TFhirContractTermOfferAnswerList;
begin
  if FAnswerList = nil then
    FAnswerList := TFhirContractTermOfferAnswerList.Create;
  result := FAnswerList;
end;

Function TFhirContractTermOffer.GetHasAnswerList : boolean;
begin
  result := (FAnswerList <> nil) and (FAnswerList.count > 0);
end;

Procedure TFhirContractTermOffer.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirContractTermOffer.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirContractTermOffer.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Function TFhirContractTermOffer.GetLinkIdList : TFhirStringList;
begin
  if FLinkIdList = nil then
    FLinkIdList := TFhirStringList.Create;
  result := FLinkIdList;
end;

Function TFhirContractTermOffer.GetHasLinkIdList : boolean;
begin
  result := (FLinkIdList <> nil) and (FLinkIdList.count > 0);
end;

Function TFhirContractTermOffer.GetSecurityLabelNumberList : TFhirUnsignedIntList;
begin
  if FSecurityLabelNumberList = nil then
    FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
  result := FSecurityLabelNumberList;
end;

Function TFhirContractTermOffer.GetHasSecurityLabelNumberList : boolean;
begin
  result := (FSecurityLabelNumberList <> nil) and (FSecurityLabelNumberList.count > 0);
end;

function TFhirContractTermOffer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FpartyList.sizeInBytes);
  inc(result, FTopic.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FDecision.sizeInBytes);
  inc(result, FdecisionModeList.sizeInBytes);
  inc(result, FanswerList.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FlinkIdList.sizeInBytes);
  inc(result, FsecurityLabelNumberList.sizeInBytes);
end;

{ TFhirContractTermOfferListEnumerator }

Constructor TFhirContractTermOfferListEnumerator.Create(list : TFhirContractTermOfferList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermOfferListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermOfferListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermOfferListEnumerator.GetCurrent : TFhirContractTermOffer;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermOfferListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractTermOfferList }
procedure TFhirContractTermOfferList.AddItem(value: TFhirContractTermOffer);
begin
  assert(value.ClassName = 'TFhirContractTermOffer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermOffer');
  add(value);
end;

function TFhirContractTermOfferList.Append: TFhirContractTermOffer;
begin
  result := TFhirContractTermOffer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermOfferList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermOfferList.GetEnumerator : TFhirContractTermOfferListEnumerator;
begin
  result := TFhirContractTermOfferListEnumerator.Create(self.link);
end;

function TFhirContractTermOfferList.Clone: TFhirContractTermOfferList;
begin
  result := TFhirContractTermOfferList(inherited Clone);
end;

function TFhirContractTermOfferList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermOfferList.GetItemN(index: Integer): TFhirContractTermOffer;
begin
  result := TFhirContractTermOffer(ObjectByIndex[index]);
end;

function TFhirContractTermOfferList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermOffer;
end;
function TFhirContractTermOfferList.IndexOf(value: TFhirContractTermOffer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermOfferList.Insert(index: Integer): TFhirContractTermOffer;
begin
  result := TFhirContractTermOffer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermOfferList.InsertItem(index: Integer; value: TFhirContractTermOffer);
begin
  assert(value is TFhirContractTermOffer);
  Inherited Insert(index, value);
end;

function TFhirContractTermOfferList.Item(index: Integer): TFhirContractTermOffer;
begin
  result := TFhirContractTermOffer(ObjectByIndex[index]);
end;

function TFhirContractTermOfferList.Link: TFhirContractTermOfferList;
begin
  result := TFhirContractTermOfferList(inherited Link);
end;

procedure TFhirContractTermOfferList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermOfferList.SetItemByIndex(index: Integer; value: TFhirContractTermOffer);
begin
  assert(value is TFhirContractTermOffer);
  FhirContractTermOffers[index] := value;
end;

procedure TFhirContractTermOfferList.SetItemN(index: Integer; value: TFhirContractTermOffer);
begin
  assert(value is TFhirContractTermOffer);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermOfferParty }

constructor TFhirContractTermOfferParty.Create;
begin
  inherited;
end;

destructor TFhirContractTermOfferParty.Destroy;
begin
  FReferenceList.Free;
  FRole.free;
  inherited;
end;

procedure TFhirContractTermOfferParty.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirContractTermOfferParty(oSource).FReferenceList = nil) then
  begin
    FReferenceList.free;
    FReferenceList := nil;
  end
  else
  begin
    if FReferenceList = nil then
      FReferenceList := TFhirReferenceList{TFhirPatient}.Create;
    FReferenceList.Assign(TFhirContractTermOfferParty(oSource).FReferenceList);
  end;
  role := TFhirContractTermOfferParty(oSource).role.Clone;
end;

procedure TFhirContractTermOfferParty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'reference') Then
    list.addAll(self, 'reference', FReferenceList);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
end;

procedure TFhirContractTermOfferParty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference(Patient)', true, TFhirReference{TFhirPatient}, FReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
end;

function TFhirContractTermOfferParty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'reference') then
  begin
    ReferenceList.add(propValue as TFhirReference{TFhirPatient}){2a};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermOfferParty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reference') then ReferenceList.insertItem(index, propValue as TFhirReference{TFhirPatient}){2a}
  else inherited;
end;

function TFhirContractTermOfferParty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'reference') then result := ReferenceList.new(){2}
  else if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermOfferParty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'reference') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermOfferParty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'reference') then deletePropertyValue('reference', ReferenceList, value) {2}
  else if (propName = 'role') then RoleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermOfferParty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'reference') then replacePropertyValue('reference', ReferenceList, existing, new) {2}
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermOfferParty.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reference') then ReferenceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermOfferParty.fhirType : string;
begin
  result := 'party';
end;

function TFhirContractTermOfferParty.Link : TFhirContractTermOfferParty;
begin
  result := TFhirContractTermOfferParty(inherited Link);
end;

function TFhirContractTermOfferParty.Clone : TFhirContractTermOfferParty;
begin
  result := TFhirContractTermOfferParty(inherited Clone);
end;

function TFhirContractTermOfferParty.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermOfferParty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermOfferParty)) then
    result := false
  else
  begin
    o := TFhirContractTermOfferParty(other);
    result := compareDeep(referenceList, o.referenceList, true) and compareDeep(roleElement, o.roleElement, true);
  end;
end;

function TFhirContractTermOfferParty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FreferenceList) and isEmptyProp(FRole);
end;

procedure TFhirContractTermOfferParty.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('reference');
  fields.add('role');
end;

{ TFhirContractTermOfferParty }

Function TFhirContractTermOfferParty.GetReferenceList : TFhirReferenceList{TFhirPatient};
begin
  if FReferenceList = nil then
    FReferenceList := TFhirReferenceList{TFhirPatient}.Create;
  result := FReferenceList;
end;

Function TFhirContractTermOfferParty.GetHasReferenceList : boolean;
begin
  result := (FReferenceList <> nil) and (FReferenceList.count > 0);
end;

Procedure TFhirContractTermOfferParty.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

function TFhirContractTermOfferParty.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FreferenceList.sizeInBytes);
  inc(result, FRole.sizeInBytes);
end;

{ TFhirContractTermOfferPartyListEnumerator }

Constructor TFhirContractTermOfferPartyListEnumerator.Create(list : TFhirContractTermOfferPartyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermOfferPartyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermOfferPartyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermOfferPartyListEnumerator.GetCurrent : TFhirContractTermOfferParty;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermOfferPartyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractTermOfferPartyList }
procedure TFhirContractTermOfferPartyList.AddItem(value: TFhirContractTermOfferParty);
begin
  assert(value.ClassName = 'TFhirContractTermOfferParty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermOfferParty');
  add(value);
end;

function TFhirContractTermOfferPartyList.Append: TFhirContractTermOfferParty;
begin
  result := TFhirContractTermOfferParty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermOfferPartyList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermOfferPartyList.GetEnumerator : TFhirContractTermOfferPartyListEnumerator;
begin
  result := TFhirContractTermOfferPartyListEnumerator.Create(self.link);
end;

function TFhirContractTermOfferPartyList.Clone: TFhirContractTermOfferPartyList;
begin
  result := TFhirContractTermOfferPartyList(inherited Clone);
end;

function TFhirContractTermOfferPartyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermOfferPartyList.GetItemN(index: Integer): TFhirContractTermOfferParty;
begin
  result := TFhirContractTermOfferParty(ObjectByIndex[index]);
end;

function TFhirContractTermOfferPartyList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermOfferParty;
end;
function TFhirContractTermOfferPartyList.IndexOf(value: TFhirContractTermOfferParty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermOfferPartyList.Insert(index: Integer): TFhirContractTermOfferParty;
begin
  result := TFhirContractTermOfferParty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermOfferPartyList.InsertItem(index: Integer; value: TFhirContractTermOfferParty);
begin
  assert(value is TFhirContractTermOfferParty);
  Inherited Insert(index, value);
end;

function TFhirContractTermOfferPartyList.Item(index: Integer): TFhirContractTermOfferParty;
begin
  result := TFhirContractTermOfferParty(ObjectByIndex[index]);
end;

function TFhirContractTermOfferPartyList.Link: TFhirContractTermOfferPartyList;
begin
  result := TFhirContractTermOfferPartyList(inherited Link);
end;

procedure TFhirContractTermOfferPartyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermOfferPartyList.SetItemByIndex(index: Integer; value: TFhirContractTermOfferParty);
begin
  assert(value is TFhirContractTermOfferParty);
  FhirContractTermOfferParties[index] := value;
end;

procedure TFhirContractTermOfferPartyList.SetItemN(index: Integer; value: TFhirContractTermOfferParty);
begin
  assert(value is TFhirContractTermOfferParty);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermOfferAnswer }

constructor TFhirContractTermOfferAnswer.Create;
begin
  inherited;
end;

destructor TFhirContractTermOfferAnswer.Destroy;
begin
  FValue.free;
  inherited;
end;

procedure TFhirContractTermOfferAnswer.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirContractTermOfferAnswer(oSource).value.Clone;
end;

procedure TFhirContractTermOfferAnswer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirContractTermOfferAnswer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value[x]', 'boolean|decimal|integer|date|dateTime|time|string|uri|Attachment|Coding|Quantity|Reference(Any)', false, TFhirType, FValue.Link));{2}
end;

function TFhirContractTermOfferAnswer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermOfferAnswer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractTermOfferAnswer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermOfferAnswer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value[x]') then result := 'boolean|decimal|integer|date|dateTime|time|string|uri|Attachment|Coding|Quantity|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermOfferAnswer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then ValueElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermOfferAnswer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then ValueElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermOfferAnswer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermOfferAnswer.fhirType : string;
begin
  result := 'answer';
end;

function TFhirContractTermOfferAnswer.Link : TFhirContractTermOfferAnswer;
begin
  result := TFhirContractTermOfferAnswer(inherited Link);
end;

function TFhirContractTermOfferAnswer.Clone : TFhirContractTermOfferAnswer;
begin
  result := TFhirContractTermOfferAnswer(inherited Clone);
end;

function TFhirContractTermOfferAnswer.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermOfferAnswer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermOfferAnswer)) then
    result := false
  else
  begin
    o := TFhirContractTermOfferAnswer(other);
    result := compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirContractTermOfferAnswer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue);
end;

procedure TFhirContractTermOfferAnswer.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('value[x]');
end;

{ TFhirContractTermOfferAnswer }

Procedure TFhirContractTermOfferAnswer.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

function TFhirContractTermOfferAnswer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FValue.sizeInBytes);
end;

{ TFhirContractTermOfferAnswerListEnumerator }

Constructor TFhirContractTermOfferAnswerListEnumerator.Create(list : TFhirContractTermOfferAnswerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermOfferAnswerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermOfferAnswerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermOfferAnswerListEnumerator.GetCurrent : TFhirContractTermOfferAnswer;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermOfferAnswerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractTermOfferAnswerList }
procedure TFhirContractTermOfferAnswerList.AddItem(value: TFhirContractTermOfferAnswer);
begin
  assert(value.ClassName = 'TFhirContractTermOfferAnswer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermOfferAnswer');
  add(value);
end;

function TFhirContractTermOfferAnswerList.Append: TFhirContractTermOfferAnswer;
begin
  result := TFhirContractTermOfferAnswer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermOfferAnswerList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermOfferAnswerList.GetEnumerator : TFhirContractTermOfferAnswerListEnumerator;
begin
  result := TFhirContractTermOfferAnswerListEnumerator.Create(self.link);
end;

function TFhirContractTermOfferAnswerList.Clone: TFhirContractTermOfferAnswerList;
begin
  result := TFhirContractTermOfferAnswerList(inherited Clone);
end;

function TFhirContractTermOfferAnswerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermOfferAnswerList.GetItemN(index: Integer): TFhirContractTermOfferAnswer;
begin
  result := TFhirContractTermOfferAnswer(ObjectByIndex[index]);
end;

function TFhirContractTermOfferAnswerList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermOfferAnswer;
end;
function TFhirContractTermOfferAnswerList.IndexOf(value: TFhirContractTermOfferAnswer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermOfferAnswerList.Insert(index: Integer): TFhirContractTermOfferAnswer;
begin
  result := TFhirContractTermOfferAnswer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermOfferAnswerList.InsertItem(index: Integer; value: TFhirContractTermOfferAnswer);
begin
  assert(value is TFhirContractTermOfferAnswer);
  Inherited Insert(index, value);
end;

function TFhirContractTermOfferAnswerList.Item(index: Integer): TFhirContractTermOfferAnswer;
begin
  result := TFhirContractTermOfferAnswer(ObjectByIndex[index]);
end;

function TFhirContractTermOfferAnswerList.Link: TFhirContractTermOfferAnswerList;
begin
  result := TFhirContractTermOfferAnswerList(inherited Link);
end;

procedure TFhirContractTermOfferAnswerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermOfferAnswerList.SetItemByIndex(index: Integer; value: TFhirContractTermOfferAnswer);
begin
  assert(value is TFhirContractTermOfferAnswer);
  FhirContractTermOfferAnswers[index] := value;
end;

procedure TFhirContractTermOfferAnswerList.SetItemN(index: Integer; value: TFhirContractTermOfferAnswer);
begin
  assert(value is TFhirContractTermOfferAnswer);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermAsset }

constructor TFhirContractTermAsset.Create;
begin
  inherited;
end;

destructor TFhirContractTermAsset.Destroy;
begin
  FScope.free;
  FType_List.Free;
  FTypeReferenceList.Free;
  FSubtypeList.Free;
  FRelationship.free;
  FContextList.Free;
  FCondition.free;
  FPeriodTypeList.Free;
  FPeriodList.Free;
  FUsePeriodList.Free;
  FText.free;
  FLinkIdList.Free;
  FAnswerList.Free;
  FSecurityLabelNumberList.Free;
  FValuedItemList.Free;
  inherited;
end;

procedure TFhirContractTermAsset.Assign(oSource : TFslObject);
begin
  inherited;
  scope := TFhirContractTermAsset(oSource).scope.Clone;
  if (TFhirContractTermAsset(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirContractTermAsset(oSource).FType_List);
  end;
  if (TFhirContractTermAsset(oSource).FTypeReferenceList = nil) then
  begin
    FTypeReferenceList.free;
    FTypeReferenceList := nil;
  end
  else
  begin
    if FTypeReferenceList = nil then
      FTypeReferenceList := TFhirReferenceList{TFhirReference}.Create;
    FTypeReferenceList.Assign(TFhirContractTermAsset(oSource).FTypeReferenceList);
  end;
  if (TFhirContractTermAsset(oSource).FSubtypeList = nil) then
  begin
    FSubtypeList.free;
    FSubtypeList := nil;
  end
  else
  begin
    if FSubtypeList = nil then
      FSubtypeList := TFhirCodeableConceptList.Create;
    FSubtypeList.Assign(TFhirContractTermAsset(oSource).FSubtypeList);
  end;
  relationship := TFhirContractTermAsset(oSource).relationship.Clone;
  if (TFhirContractTermAsset(oSource).FContextList = nil) then
  begin
    FContextList.free;
    FContextList := nil;
  end
  else
  begin
    if FContextList = nil then
      FContextList := TFhirContractTermAssetContextList.Create;
    FContextList.Assign(TFhirContractTermAsset(oSource).FContextList);
  end;
  conditionElement := TFhirContractTermAsset(oSource).conditionElement.Clone;
  if (TFhirContractTermAsset(oSource).FPeriodTypeList = nil) then
  begin
    FPeriodTypeList.free;
    FPeriodTypeList := nil;
  end
  else
  begin
    if FPeriodTypeList = nil then
      FPeriodTypeList := TFhirCodeableConceptList.Create;
    FPeriodTypeList.Assign(TFhirContractTermAsset(oSource).FPeriodTypeList);
  end;
  if (TFhirContractTermAsset(oSource).FPeriodList = nil) then
  begin
    FPeriodList.free;
    FPeriodList := nil;
  end
  else
  begin
    if FPeriodList = nil then
      FPeriodList := TFhirPeriodList.Create;
    FPeriodList.Assign(TFhirContractTermAsset(oSource).FPeriodList);
  end;
  if (TFhirContractTermAsset(oSource).FUsePeriodList = nil) then
  begin
    FUsePeriodList.free;
    FUsePeriodList := nil;
  end
  else
  begin
    if FUsePeriodList = nil then
      FUsePeriodList := TFhirPeriodList.Create;
    FUsePeriodList.Assign(TFhirContractTermAsset(oSource).FUsePeriodList);
  end;
  textElement := TFhirContractTermAsset(oSource).textElement.Clone;
  if (TFhirContractTermAsset(oSource).FLinkIdList = nil) then
  begin
    FLinkIdList.free;
    FLinkIdList := nil;
  end
  else
  begin
    if FLinkIdList = nil then
      FLinkIdList := TFhirStringList.Create;
    FLinkIdList.Assign(TFhirContractTermAsset(oSource).FLinkIdList);
  end;
  if (TFhirContractTermAsset(oSource).FAnswerList = nil) then
  begin
    FAnswerList.free;
    FAnswerList := nil;
  end
  else
  begin
    if FAnswerList = nil then
      FAnswerList := TFhirContractTermOfferAnswerList.Create;
    FAnswerList.Assign(TFhirContractTermAsset(oSource).FAnswerList);
  end;
  if (TFhirContractTermAsset(oSource).FSecurityLabelNumberList = nil) then
  begin
    FSecurityLabelNumberList.free;
    FSecurityLabelNumberList := nil;
  end
  else
  begin
    if FSecurityLabelNumberList = nil then
      FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
    FSecurityLabelNumberList.Assign(TFhirContractTermAsset(oSource).FSecurityLabelNumberList);
  end;
  if (TFhirContractTermAsset(oSource).FValuedItemList = nil) then
  begin
    FValuedItemList.free;
    FValuedItemList := nil;
  end
  else
  begin
    if FValuedItemList = nil then
      FValuedItemList := TFhirContractTermAssetValuedItemList.Create;
    FValuedItemList.Assign(TFhirContractTermAsset(oSource).FValuedItemList);
  end;
end;

procedure TFhirContractTermAsset.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'scope') Then
     list.add(self.link, 'scope', FScope.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'typeReference') Then
    list.addAll(self, 'typeReference', FTypeReferenceList);
  if (child_name = 'subtype') Then
    list.addAll(self, 'subtype', FSubtypeList);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'context') Then
    list.addAll(self, 'context', FContextList);
  if (child_name = 'condition') Then
     list.add(self.link, 'condition', FCondition.Link);
  if (child_name = 'periodType') Then
    list.addAll(self, 'periodType', FPeriodTypeList);
  if (child_name = 'period') Then
    list.addAll(self, 'period', FPeriodList);
  if (child_name = 'usePeriod') Then
    list.addAll(self, 'usePeriod', FUsePeriodList);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'linkId') Then
    list.addAll(self, 'linkId', FLinkIdList);
  if (child_name = 'answer') Then
    list.addAll(self, 'answer', FAnswerList);
  if (child_name = 'securityLabelNumber') Then
    list.addAll(self, 'securityLabelNumber', FSecurityLabelNumberList);
  if (child_name = 'valuedItem') Then
    list.addAll(self, 'valuedItem', FValuedItemList);
end;

procedure TFhirContractTermAsset.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'scope', 'CodeableConcept', false, TFhirCodeableConcept, FScope.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'typeReference', 'Reference(Any)', true, TFhirReference{TFhirReference}, FTypeReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subtype', 'CodeableConcept', true, TFhirCodeableConcept, FSubtypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relationship', 'Coding', false, TFhirCoding, FRelationship.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', '', true, TFhirContractTermAssetContext, FContextList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'condition', 'string', false, TFhirString, FCondition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'periodType', 'CodeableConcept', true, TFhirCodeableConcept, FPeriodTypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', true, TFhirPeriod, FPeriodList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'usePeriod', 'Period', true, TFhirPeriod, FUsePeriodList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', true, TFhirString, FLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'answer', '@Contract.term.offer.answer', true, TFhirContractTermOfferAnswer, FAnswerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'securityLabelNumber', 'unsignedInt', true, TFhirUnsignedInt, FSecurityLabelNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'valuedItem', '', true, TFhirContractTermAssetValuedItem, FValuedItemList.Link)){3};
end;

function TFhirContractTermAsset.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'scope') then
  begin
    Scope := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'typeReference') then
  begin
    TypeReferenceList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'subtype') then
  begin
    SubtypeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    ContextList.add(propValue as TFhirContractTermAssetContext){2a};
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'periodType') then
  begin
    PeriodTypeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    PeriodList.add(propValue as TFhirPeriod){2a};
    result := propValue;
  end
  else if (propName = 'usePeriod') then
  begin
    UsePeriodList.add(propValue as TFhirPeriod){2a};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'linkId') then
  begin
    LinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'answer') then
  begin
    AnswerList.add(propValue as TFhirContractTermOfferAnswer){2a};
    result := propValue;
  end
  else if (propName = 'securityLabelNumber') then
  begin
    SecurityLabelNumberList.add(asUnsignedInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'valuedItem') then
  begin
    ValuedItemList.add(propValue as TFhirContractTermAssetValuedItem){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermAsset.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'typeReference') then TypeReferenceList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'subtype') then SubtypeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'context') then ContextList.insertItem(index, propValue as TFhirContractTermAssetContext){2a}
  else if (propName = 'periodType') then PeriodTypeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'period') then PeriodList.insertItem(index, propValue as TFhirPeriod){2a}
  else if (propName = 'usePeriod') then UsePeriodList.insertItem(index, propValue as TFhirPeriod){2a}
  else if (propName = 'linkId') then LinkIdList.insertItem(index, asString(propValue)){2}
  else if (propName = 'answer') then AnswerList.insertItem(index, propValue as TFhirContractTermOfferAnswer){2a}
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.insertItem(index, asUnsignedInt(propValue)){2}
  else if (propName = 'valuedItem') then ValuedItemList.insertItem(index, propValue as TFhirContractTermAssetValuedItem){2a}
  else inherited;
end;

function TFhirContractTermAsset.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'scope') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'typeReference') then result := TypeReferenceList.new(){2}
  else if (propName = 'subtype') then result := SubtypeList.new(){2}
  else if (propName = 'relationship') then result := TFhirCoding.create(){4b}
  else if (propName = 'context') then result := ContextList.new(){2}
  else if (propName = 'condition') then result := TFhirString.create() {5b}
  else if (propName = 'periodType') then result := PeriodTypeList.new(){2}
  else if (propName = 'period') then result := PeriodList.new(){2}
  else if (propName = 'usePeriod') then result := UsePeriodList.new(){2}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'linkId') then result := LinkIdList.new(){2}
  else if (propName = 'answer') then result := AnswerList.new(){2}
  else if (propName = 'securityLabelNumber') then result := SecurityLabelNumberList.new(){2}
  else if (propName = 'valuedItem') then result := ValuedItemList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermAsset.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'scope') then result := 'CodeableConcept'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'typeReference') then result := 'Reference'
  else if (propName = 'subtype') then result := 'CodeableConcept'
  else if (propName = 'relationship') then result := 'Coding'
  else if (propName = 'context') then result := ''
  else if (propName = 'condition') then result := 'string'
  else if (propName = 'periodType') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'usePeriod') then result := 'Period'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'linkId') then result := 'string'
  else if (propName = 'answer') then result := '@Contract.term.offer.answer'
  else if (propName = 'securityLabelNumber') then result := 'unsignedInt'
  else if (propName = 'valuedItem') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermAsset.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'scope') then ScopeElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'typeReference') then deletePropertyValue('typeReference', TypeReferenceList, value) {2}
  else if (propName = 'subtype') then deletePropertyValue('subtype', SubtypeList, value) {2}
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'context') then deletePropertyValue('context', ContextList, value) {2}
  else if (propName = 'condition') then ConditionElement := nil
  else if (propName = 'periodType') then deletePropertyValue('periodType', PeriodTypeList, value) {2}
  else if (propName = 'period') then deletePropertyValue('period', PeriodList, value) {2}
  else if (propName = 'usePeriod') then deletePropertyValue('usePeriod', UsePeriodList, value) {2}
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'linkId') then deletePropertyValue('linkId', LinkIdList, value) {2}
  else if (propName = 'answer') then deletePropertyValue('answer', AnswerList, value) {2}
  else if (propName = 'securityLabelNumber') then deletePropertyValue('securityLabelNumber', SecurityLabelNumberList, value) {2}
  else if (propName = 'valuedItem') then deletePropertyValue('valuedItem', ValuedItemList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermAsset.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'scope') then ScopeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'typeReference') then replacePropertyValue('typeReference', TypeReferenceList, existing, new) {2}
  else if (propName = 'subtype') then replacePropertyValue('subtype', SubtypeList, existing, new) {2}
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCoding{4}
  else if (propName = 'context') then replacePropertyValue('context', ContextList, existing, new) {2}
  else if (propName = 'condition') then ConditionElement := asString(new){5b}
  else if (propName = 'periodType') then replacePropertyValue('periodType', PeriodTypeList, existing, new) {2}
  else if (propName = 'period') then replacePropertyValue('period', PeriodList, existing, new) {2}
  else if (propName = 'usePeriod') then replacePropertyValue('usePeriod', UsePeriodList, existing, new) {2}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'linkId') then replacePropertyValue('linkId', LinkIdList, existing, new) {2}
  else if (propName = 'answer') then replacePropertyValue('answer', AnswerList, existing, new) {2}
  else if (propName = 'securityLabelNumber') then replacePropertyValue('securityLabelNumber', SecurityLabelNumberList, existing, new) {2}
  else if (propName = 'valuedItem') then replacePropertyValue('valuedItem', ValuedItemList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermAsset.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination){2a}
  else if (propName = 'typeReference') then TypeReferenceList.move(source, destination){2a}
  else if (propName = 'subtype') then SubtypeList.move(source, destination){2a}
  else if (propName = 'context') then ContextList.move(source, destination){2a}
  else if (propName = 'periodType') then PeriodTypeList.move(source, destination){2a}
  else if (propName = 'period') then PeriodList.move(source, destination){2a}
  else if (propName = 'usePeriod') then UsePeriodList.move(source, destination){2a}
  else if (propName = 'linkId') then LinkIdList.move(source, destination){2}
  else if (propName = 'answer') then AnswerList.move(source, destination){2a}
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.move(source, destination){2}
  else if (propName = 'valuedItem') then ValuedItemList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermAsset.fhirType : string;
begin
  result := 'asset';
end;

function TFhirContractTermAsset.Link : TFhirContractTermAsset;
begin
  result := TFhirContractTermAsset(inherited Link);
end;

function TFhirContractTermAsset.Clone : TFhirContractTermAsset;
begin
  result := TFhirContractTermAsset(inherited Clone);
end;

function TFhirContractTermAsset.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermAsset;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermAsset)) then
    result := false
  else
  begin
    o := TFhirContractTermAsset(other);
    result := compareDeep(scopeElement, o.scopeElement, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(typeReferenceList, o.typeReferenceList, true) and compareDeep(subtypeList, o.subtypeList, true) and 
      compareDeep(relationshipElement, o.relationshipElement, true) and compareDeep(contextList, o.contextList, true) and 
      compareDeep(conditionElement, o.conditionElement, true) and compareDeep(periodTypeList, o.periodTypeList, true) and 
      compareDeep(periodList, o.periodList, true) and compareDeep(usePeriodList, o.usePeriodList, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(linkIdList, o.linkIdList, true) and 
      compareDeep(answerList, o.answerList, true) and compareDeep(securityLabelNumberList, o.securityLabelNumberList, true) and 
      compareDeep(valuedItemList, o.valuedItemList, true);
  end;
end;

function TFhirContractTermAsset.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FScope) and isEmptyProp(Ftype_List) and isEmptyProp(FtypeReferenceList) and isEmptyProp(FsubtypeList) and isEmptyProp(FRelationship) and isEmptyProp(FcontextList) and isEmptyProp(FCondition) and isEmptyProp(FperiodTypeList) and isEmptyProp(FperiodList) and isEmptyProp(FusePeriodList) and isEmptyProp(FText) and isEmptyProp(FlinkIdList) and isEmptyProp(FanswerList) and isEmptyProp(FsecurityLabelNumberList) and isEmptyProp(FvaluedItemList);
end;

procedure TFhirContractTermAsset.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('scope');
  fields.add('type');
  fields.add('typeReference');
  fields.add('subtype');
  fields.add('relationship');
  fields.add('context');
  fields.add('condition');
  fields.add('periodType');
  fields.add('period');
  fields.add('usePeriod');
  fields.add('text');
  fields.add('linkId');
  fields.add('answer');
  fields.add('securityLabelNumber');
  fields.add('valuedItem');
end;

{ TFhirContractTermAsset }

Procedure TFhirContractTermAsset.SetScope(value : TFhirCodeableConcept);
begin
  FScope.free;
  FScope := value;
end;

Function TFhirContractTermAsset.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

Function TFhirContractTermAsset.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Function TFhirContractTermAsset.GetTypeReferenceList : TFhirReferenceList{TFhirReference};
begin
  if FTypeReferenceList = nil then
    FTypeReferenceList := TFhirReferenceList{TFhirReference}.Create;
  result := FTypeReferenceList;
end;

Function TFhirContractTermAsset.GetHasTypeReferenceList : boolean;
begin
  result := (FTypeReferenceList <> nil) and (FTypeReferenceList.count > 0);
end;

Function TFhirContractTermAsset.GetSubtypeList : TFhirCodeableConceptList;
begin
  if FSubtypeList = nil then
    FSubtypeList := TFhirCodeableConceptList.Create;
  result := FSubtypeList;
end;

Function TFhirContractTermAsset.GetHasSubtypeList : boolean;
begin
  result := (FSubtypeList <> nil) and (FSubtypeList.count > 0);
end;

Procedure TFhirContractTermAsset.SetRelationship(value : TFhirCoding);
begin
  FRelationship.free;
  FRelationship := value;
end;

Function TFhirContractTermAsset.GetContextList : TFhirContractTermAssetContextList;
begin
  if FContextList = nil then
    FContextList := TFhirContractTermAssetContextList.Create;
  result := FContextList;
end;

Function TFhirContractTermAsset.GetHasContextList : boolean;
begin
  result := (FContextList <> nil) and (FContextList.count > 0);
end;

Procedure TFhirContractTermAsset.SetCondition(value : TFhirString);
begin
  FCondition.free;
  FCondition := value;
end;

Function TFhirContractTermAsset.GetConditionST : String;
begin
  if FCondition = nil then
    result := ''
  else
    result := FCondition.value;
end;

Procedure TFhirContractTermAsset.SetConditionST(value : String);
begin
  if value <> '' then
  begin
    if FCondition = nil then
      FCondition := TFhirString.create;
    FCondition.value := value
  end
  else if FCondition <> nil then
    FCondition.value := '';
end;

Function TFhirContractTermAsset.GetPeriodTypeList : TFhirCodeableConceptList;
begin
  if FPeriodTypeList = nil then
    FPeriodTypeList := TFhirCodeableConceptList.Create;
  result := FPeriodTypeList;
end;

Function TFhirContractTermAsset.GetHasPeriodTypeList : boolean;
begin
  result := (FPeriodTypeList <> nil) and (FPeriodTypeList.count > 0);
end;

Function TFhirContractTermAsset.GetPeriodList : TFhirPeriodList;
begin
  if FPeriodList = nil then
    FPeriodList := TFhirPeriodList.Create;
  result := FPeriodList;
end;

Function TFhirContractTermAsset.GetHasPeriodList : boolean;
begin
  result := (FPeriodList <> nil) and (FPeriodList.count > 0);
end;

Function TFhirContractTermAsset.GetUsePeriodList : TFhirPeriodList;
begin
  if FUsePeriodList = nil then
    FUsePeriodList := TFhirPeriodList.Create;
  result := FUsePeriodList;
end;

Function TFhirContractTermAsset.GetHasUsePeriodList : boolean;
begin
  result := (FUsePeriodList <> nil) and (FUsePeriodList.count > 0);
end;

Procedure TFhirContractTermAsset.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirContractTermAsset.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirContractTermAsset.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Function TFhirContractTermAsset.GetLinkIdList : TFhirStringList;
begin
  if FLinkIdList = nil then
    FLinkIdList := TFhirStringList.Create;
  result := FLinkIdList;
end;

Function TFhirContractTermAsset.GetHasLinkIdList : boolean;
begin
  result := (FLinkIdList <> nil) and (FLinkIdList.count > 0);
end;

Function TFhirContractTermAsset.GetAnswerList : TFhirContractTermOfferAnswerList;
begin
  if FAnswerList = nil then
    FAnswerList := TFhirContractTermOfferAnswerList.Create;
  result := FAnswerList;
end;

Function TFhirContractTermAsset.GetHasAnswerList : boolean;
begin
  result := (FAnswerList <> nil) and (FAnswerList.count > 0);
end;

Function TFhirContractTermAsset.GetSecurityLabelNumberList : TFhirUnsignedIntList;
begin
  if FSecurityLabelNumberList = nil then
    FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
  result := FSecurityLabelNumberList;
end;

Function TFhirContractTermAsset.GetHasSecurityLabelNumberList : boolean;
begin
  result := (FSecurityLabelNumberList <> nil) and (FSecurityLabelNumberList.count > 0);
end;

Function TFhirContractTermAsset.GetValuedItemList : TFhirContractTermAssetValuedItemList;
begin
  if FValuedItemList = nil then
    FValuedItemList := TFhirContractTermAssetValuedItemList.Create;
  result := FValuedItemList;
end;

Function TFhirContractTermAsset.GetHasValuedItemList : boolean;
begin
  result := (FValuedItemList <> nil) and (FValuedItemList.count > 0);
end;

function TFhirContractTermAsset.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FScope.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FtypeReferenceList.sizeInBytes);
  inc(result, FsubtypeList.sizeInBytes);
  inc(result, FRelationship.sizeInBytes);
  inc(result, FcontextList.sizeInBytes);
  inc(result, FCondition.sizeInBytes);
  inc(result, FperiodTypeList.sizeInBytes);
  inc(result, FperiodList.sizeInBytes);
  inc(result, FusePeriodList.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FlinkIdList.sizeInBytes);
  inc(result, FanswerList.sizeInBytes);
  inc(result, FsecurityLabelNumberList.sizeInBytes);
  inc(result, FvaluedItemList.sizeInBytes);
end;

{ TFhirContractTermAssetListEnumerator }

Constructor TFhirContractTermAssetListEnumerator.Create(list : TFhirContractTermAssetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermAssetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermAssetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermAssetListEnumerator.GetCurrent : TFhirContractTermAsset;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermAssetListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractTermAssetList }
procedure TFhirContractTermAssetList.AddItem(value: TFhirContractTermAsset);
begin
  assert(value.ClassName = 'TFhirContractTermAsset', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermAsset');
  add(value);
end;

function TFhirContractTermAssetList.Append: TFhirContractTermAsset;
begin
  result := TFhirContractTermAsset.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermAssetList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermAssetList.GetEnumerator : TFhirContractTermAssetListEnumerator;
begin
  result := TFhirContractTermAssetListEnumerator.Create(self.link);
end;

function TFhirContractTermAssetList.Clone: TFhirContractTermAssetList;
begin
  result := TFhirContractTermAssetList(inherited Clone);
end;

function TFhirContractTermAssetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermAssetList.GetItemN(index: Integer): TFhirContractTermAsset;
begin
  result := TFhirContractTermAsset(ObjectByIndex[index]);
end;

function TFhirContractTermAssetList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermAsset;
end;
function TFhirContractTermAssetList.IndexOf(value: TFhirContractTermAsset): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermAssetList.Insert(index: Integer): TFhirContractTermAsset;
begin
  result := TFhirContractTermAsset.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermAssetList.InsertItem(index: Integer; value: TFhirContractTermAsset);
begin
  assert(value is TFhirContractTermAsset);
  Inherited Insert(index, value);
end;

function TFhirContractTermAssetList.Item(index: Integer): TFhirContractTermAsset;
begin
  result := TFhirContractTermAsset(ObjectByIndex[index]);
end;

function TFhirContractTermAssetList.Link: TFhirContractTermAssetList;
begin
  result := TFhirContractTermAssetList(inherited Link);
end;

procedure TFhirContractTermAssetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermAssetList.SetItemByIndex(index: Integer; value: TFhirContractTermAsset);
begin
  assert(value is TFhirContractTermAsset);
  FhirContractTermAssets[index] := value;
end;

procedure TFhirContractTermAssetList.SetItemN(index: Integer; value: TFhirContractTermAsset);
begin
  assert(value is TFhirContractTermAsset);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermAssetContext }

constructor TFhirContractTermAssetContext.Create;
begin
  inherited;
end;

destructor TFhirContractTermAssetContext.Destroy;
begin
  FReference.free;
  FCodeList.Free;
  FText.free;
  inherited;
end;

procedure TFhirContractTermAssetContext.Assign(oSource : TFslObject);
begin
  inherited;
  reference := TFhirContractTermAssetContext(oSource).reference.Clone;
  if (TFhirContractTermAssetContext(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirContractTermAssetContext(oSource).FCodeList);
  end;
  textElement := TFhirContractTermAssetContext(oSource).textElement.Clone;
end;

procedure TFhirContractTermAssetContext.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirContractTermAssetContext.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference(Any)', false, TFhirReference{TFhirReference}, FReference.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
end;

function TFhirContractTermAssetContext.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermAssetContext.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirContractTermAssetContext.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'reference') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'code') then result := CodeList.new(){2}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermAssetContext.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'reference') then result := 'Reference'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'text') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermAssetContext.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value) {2}
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermAssetContext.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'reference') then ReferenceElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {2}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermAssetContext.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermAssetContext.fhirType : string;
begin
  result := 'context';
end;

function TFhirContractTermAssetContext.Link : TFhirContractTermAssetContext;
begin
  result := TFhirContractTermAssetContext(inherited Link);
end;

function TFhirContractTermAssetContext.Clone : TFhirContractTermAssetContext;
begin
  result := TFhirContractTermAssetContext(inherited Clone);
end;

function TFhirContractTermAssetContext.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermAssetContext;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermAssetContext)) then
    result := false
  else
  begin
    o := TFhirContractTermAssetContext(other);
    result := compareDeep(referenceElement, o.referenceElement, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirContractTermAssetContext.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FReference) and isEmptyProp(FcodeList) and isEmptyProp(FText);
end;

procedure TFhirContractTermAssetContext.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('reference');
  fields.add('code');
  fields.add('text');
end;

{ TFhirContractTermAssetContext }

Procedure TFhirContractTermAssetContext.SetReference(value : TFhirReference{TFhirReference});
begin
  FReference.free;
  FReference := value;
end;

Function TFhirContractTermAssetContext.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

Function TFhirContractTermAssetContext.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

Procedure TFhirContractTermAssetContext.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirContractTermAssetContext.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirContractTermAssetContext.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

function TFhirContractTermAssetContext.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FReference.sizeInBytes);
  inc(result, FcodeList.sizeInBytes);
  inc(result, FText.sizeInBytes);
end;

{ TFhirContractTermAssetContextListEnumerator }

Constructor TFhirContractTermAssetContextListEnumerator.Create(list : TFhirContractTermAssetContextList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermAssetContextListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermAssetContextListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermAssetContextListEnumerator.GetCurrent : TFhirContractTermAssetContext;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermAssetContextListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractTermAssetContextList }
procedure TFhirContractTermAssetContextList.AddItem(value: TFhirContractTermAssetContext);
begin
  assert(value.ClassName = 'TFhirContractTermAssetContext', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermAssetContext');
  add(value);
end;

function TFhirContractTermAssetContextList.Append: TFhirContractTermAssetContext;
begin
  result := TFhirContractTermAssetContext.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermAssetContextList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermAssetContextList.GetEnumerator : TFhirContractTermAssetContextListEnumerator;
begin
  result := TFhirContractTermAssetContextListEnumerator.Create(self.link);
end;

function TFhirContractTermAssetContextList.Clone: TFhirContractTermAssetContextList;
begin
  result := TFhirContractTermAssetContextList(inherited Clone);
end;

function TFhirContractTermAssetContextList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermAssetContextList.GetItemN(index: Integer): TFhirContractTermAssetContext;
begin
  result := TFhirContractTermAssetContext(ObjectByIndex[index]);
end;

function TFhirContractTermAssetContextList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermAssetContext;
end;
function TFhirContractTermAssetContextList.IndexOf(value: TFhirContractTermAssetContext): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermAssetContextList.Insert(index: Integer): TFhirContractTermAssetContext;
begin
  result := TFhirContractTermAssetContext.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermAssetContextList.InsertItem(index: Integer; value: TFhirContractTermAssetContext);
begin
  assert(value is TFhirContractTermAssetContext);
  Inherited Insert(index, value);
end;

function TFhirContractTermAssetContextList.Item(index: Integer): TFhirContractTermAssetContext;
begin
  result := TFhirContractTermAssetContext(ObjectByIndex[index]);
end;

function TFhirContractTermAssetContextList.Link: TFhirContractTermAssetContextList;
begin
  result := TFhirContractTermAssetContextList(inherited Link);
end;

procedure TFhirContractTermAssetContextList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermAssetContextList.SetItemByIndex(index: Integer; value: TFhirContractTermAssetContext);
begin
  assert(value is TFhirContractTermAssetContext);
  FhirContractTermAssetContexts[index] := value;
end;

procedure TFhirContractTermAssetContextList.SetItemN(index: Integer; value: TFhirContractTermAssetContext);
begin
  assert(value is TFhirContractTermAssetContext);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermAssetValuedItem }

constructor TFhirContractTermAssetValuedItem.Create;
begin
  inherited;
end;

destructor TFhirContractTermAssetValuedItem.Destroy;
begin
  FEntity.free;
  FIdentifier.free;
  FEffectiveTime.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FPoints.free;
  FNet.free;
  FPayment.free;
  FPaymentDate.free;
  FResponsible.free;
  FRecipient.free;
  FLinkIdList.Free;
  FSecurityLabelNumberList.Free;
  inherited;
end;

procedure TFhirContractTermAssetValuedItem.Assign(oSource : TFslObject);
begin
  inherited;
  entity := TFhirContractTermAssetValuedItem(oSource).entity.Clone;
  identifier := TFhirContractTermAssetValuedItem(oSource).identifier.Clone;
  effectiveTimeElement := TFhirContractTermAssetValuedItem(oSource).effectiveTimeElement.Clone;
  quantity := TFhirContractTermAssetValuedItem(oSource).quantity.Clone;
  unitPrice := TFhirContractTermAssetValuedItem(oSource).unitPrice.Clone;
  factorElement := TFhirContractTermAssetValuedItem(oSource).factorElement.Clone;
  pointsElement := TFhirContractTermAssetValuedItem(oSource).pointsElement.Clone;
  net := TFhirContractTermAssetValuedItem(oSource).net.Clone;
  paymentElement := TFhirContractTermAssetValuedItem(oSource).paymentElement.Clone;
  paymentDateElement := TFhirContractTermAssetValuedItem(oSource).paymentDateElement.Clone;
  responsible := TFhirContractTermAssetValuedItem(oSource).responsible.Clone;
  recipient := TFhirContractTermAssetValuedItem(oSource).recipient.Clone;
  if (TFhirContractTermAssetValuedItem(oSource).FLinkIdList = nil) then
  begin
    FLinkIdList.free;
    FLinkIdList := nil;
  end
  else
  begin
    if FLinkIdList = nil then
      FLinkIdList := TFhirStringList.Create;
    FLinkIdList.Assign(TFhirContractTermAssetValuedItem(oSource).FLinkIdList);
  end;
  if (TFhirContractTermAssetValuedItem(oSource).FSecurityLabelNumberList = nil) then
  begin
    FSecurityLabelNumberList.free;
    FSecurityLabelNumberList := nil;
  end
  else
  begin
    if FSecurityLabelNumberList = nil then
      FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
    FSecurityLabelNumberList.Assign(TFhirContractTermAssetValuedItem(oSource).FSecurityLabelNumberList);
  end;
end;

procedure TFhirContractTermAssetValuedItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'entity[x]') or (child_name = 'entity') Then
     list.add(self.link, 'entity[x]', FEntity.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'effectiveTime') Then
     list.add(self.link, 'effectiveTime', FEffectiveTime.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'points') Then
     list.add(self.link, 'points', FPoints.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'payment') Then
     list.add(self.link, 'payment', FPayment.Link);
  if (child_name = 'paymentDate') Then
     list.add(self.link, 'paymentDate', FPaymentDate.Link);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'recipient') Then
     list.add(self.link, 'recipient', FRecipient.Link);
  if (child_name = 'linkId') Then
    list.addAll(self, 'linkId', FLinkIdList);
  if (child_name = 'securityLabelNumber') Then
    list.addAll(self, 'securityLabelNumber', FSecurityLabelNumberList);
end;

procedure TFhirContractTermAssetValuedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'entity[x]', 'CodeableConcept|Reference(Any)', false, TFhirType, FEntity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effectiveTime', 'dateTime', false, TFhirDateTime, FEffectiveTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'points', 'decimal', false, TFhirDecimal, FPoints.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payment', 'string', false, TFhirString, FPayment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'paymentDate', 'dateTime', false, TFhirDateTime, FPaymentDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'responsible', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FResponsible.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FRecipient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', true, TFhirString, FLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'securityLabelNumber', 'unsignedInt', true, TFhirUnsignedInt, FSecurityLabelNumberList.Link)){3};
end;

function TFhirContractTermAssetValuedItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then
  begin
    Entity := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'effectiveTime') then
  begin
    EffectiveTimeElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'points') then
  begin
    PointsElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'payment') then
  begin
    PaymentElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'paymentDate') then
  begin
    PaymentDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    Responsible := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    Recipient := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'linkId') then
  begin
    LinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'securityLabelNumber') then
  begin
    SecurityLabelNumberList.add(asUnsignedInt(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermAssetValuedItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'linkId') then LinkIdList.insertItem(index, asString(propValue)){2}
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.insertItem(index, asUnsignedInt(propValue)){2}
  else inherited;
end;

function TFhirContractTermAssetValuedItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Entity'){4x}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'effectiveTime') then result := TFhirDateTime.create() {5b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'points') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else if (propName = 'payment') then result := TFhirString.create() {5b}
  else if (propName = 'paymentDate') then result := TFhirDateTime.create() {5b}
  else if (propName = 'responsible') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'recipient') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'linkId') then result := LinkIdList.new(){2}
  else if (propName = 'securityLabelNumber') then result := SecurityLabelNumberList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermAssetValuedItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'entity[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'effectiveTime') then result := 'dateTime'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'points') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'payment') then result := 'string'
  else if (propName = 'paymentDate') then result := 'dateTime'
  else if (propName = 'responsible') then result := 'Reference'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'linkId') then result := 'string'
  else if (propName = 'securityLabelNumber') then result := 'unsignedInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermAssetValuedItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then EntityElement := nil{4x}
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'effectiveTime') then EffectiveTimeElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'points') then PointsElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'payment') then PaymentElement := nil
  else if (propName = 'paymentDate') then PaymentDateElement := nil
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'recipient') then RecipientElement := nil
  else if (propName = 'linkId') then deletePropertyValue('linkId', LinkIdList, value) {2}
  else if (propName = 'securityLabelNumber') then deletePropertyValue('securityLabelNumber', SecurityLabelNumberList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermAssetValuedItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then EntityElement := new as TFhirType{4x}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'effectiveTime') then EffectiveTimeElement := asDateTime(new){5b}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'points') then PointsElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else if (propName = 'payment') then PaymentElement := asString(new){5b}
  else if (propName = 'paymentDate') then PaymentDateElement := asDateTime(new){5b}
  else if (propName = 'responsible') then ResponsibleElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'recipient') then RecipientElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'linkId') then replacePropertyValue('linkId', LinkIdList, existing, new) {2}
  else if (propName = 'securityLabelNumber') then replacePropertyValue('securityLabelNumber', SecurityLabelNumberList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermAssetValuedItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'linkId') then LinkIdList.move(source, destination){2}
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermAssetValuedItem.fhirType : string;
begin
  result := 'valuedItem';
end;

function TFhirContractTermAssetValuedItem.Link : TFhirContractTermAssetValuedItem;
begin
  result := TFhirContractTermAssetValuedItem(inherited Link);
end;

function TFhirContractTermAssetValuedItem.Clone : TFhirContractTermAssetValuedItem;
begin
  result := TFhirContractTermAssetValuedItem(inherited Clone);
end;

function TFhirContractTermAssetValuedItem.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermAssetValuedItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermAssetValuedItem)) then
    result := false
  else
  begin
    o := TFhirContractTermAssetValuedItem(other);
    result := compareDeep(entityElement, o.entityElement, true) and compareDeep(identifierElement, o.identifierElement, true) and 
      compareDeep(effectiveTimeElement, o.effectiveTimeElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(pointsElement, o.pointsElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(paymentElement, o.paymentElement, true) and compareDeep(paymentDateElement, o.paymentDateElement, true) and 
      compareDeep(responsibleElement, o.responsibleElement, true) and compareDeep(recipientElement, o.recipientElement, true) and 
      compareDeep(linkIdList, o.linkIdList, true) and compareDeep(securityLabelNumberList, o.securityLabelNumberList, true);
  end;
end;

function TFhirContractTermAssetValuedItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEntity) and isEmptyProp(FIdentifier) and isEmptyProp(FEffectiveTime) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FPoints) and isEmptyProp(FNet) and isEmptyProp(FPayment) and isEmptyProp(FPaymentDate) and isEmptyProp(FResponsible) and isEmptyProp(FRecipient) and isEmptyProp(FlinkIdList) and isEmptyProp(FsecurityLabelNumberList);
end;

procedure TFhirContractTermAssetValuedItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('entity[x]');
  fields.add('identifier');
  fields.add('effectiveTime');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('points');
  fields.add('net');
  fields.add('payment');
  fields.add('paymentDate');
  fields.add('responsible');
  fields.add('recipient');
  fields.add('linkId');
  fields.add('securityLabelNumber');
end;

{ TFhirContractTermAssetValuedItem }

Procedure TFhirContractTermAssetValuedItem.SetEntity(value : TFhirType);
begin
  FEntity.free;
  FEntity := value;
end;

Procedure TFhirContractTermAssetValuedItem.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirContractTermAssetValuedItem.SetEffectiveTime(value : TFhirDateTime);
begin
  FEffectiveTime.free;
  FEffectiveTime := value;
end;

Function TFhirContractTermAssetValuedItem.GetEffectiveTimeST : TFslDateTime;
begin
  if FEffectiveTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FEffectiveTime.value;
end;

Procedure TFhirContractTermAssetValuedItem.SetEffectiveTimeST(value : TFslDateTime);
begin
  if FEffectiveTime = nil then
    FEffectiveTime := TFhirDateTime.create;
  FEffectiveTime.value := value
end;

Procedure TFhirContractTermAssetValuedItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirContractTermAssetValuedItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirContractTermAssetValuedItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirContractTermAssetValuedItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirContractTermAssetValuedItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirContractTermAssetValuedItem.SetPoints(value : TFhirDecimal);
begin
  FPoints.free;
  FPoints := value;
end;

Function TFhirContractTermAssetValuedItem.GetPointsST : String;
begin
  if FPoints = nil then
    result := ''
  else
    result := FPoints.value;
end;

Procedure TFhirContractTermAssetValuedItem.SetPointsST(value : String);
begin
  if value <> '' then
  begin
    if FPoints = nil then
      FPoints := TFhirDecimal.create;
    FPoints.value := value
  end
  else if FPoints <> nil then
    FPoints.value := '';
end;

Procedure TFhirContractTermAssetValuedItem.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

Procedure TFhirContractTermAssetValuedItem.SetPayment(value : TFhirString);
begin
  FPayment.free;
  FPayment := value;
end;

Function TFhirContractTermAssetValuedItem.GetPaymentST : String;
begin
  if FPayment = nil then
    result := ''
  else
    result := FPayment.value;
end;

Procedure TFhirContractTermAssetValuedItem.SetPaymentST(value : String);
begin
  if value <> '' then
  begin
    if FPayment = nil then
      FPayment := TFhirString.create;
    FPayment.value := value
  end
  else if FPayment <> nil then
    FPayment.value := '';
end;

Procedure TFhirContractTermAssetValuedItem.SetPaymentDate(value : TFhirDateTime);
begin
  FPaymentDate.free;
  FPaymentDate := value;
end;

Function TFhirContractTermAssetValuedItem.GetPaymentDateST : TFslDateTime;
begin
  if FPaymentDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FPaymentDate.value;
end;

Procedure TFhirContractTermAssetValuedItem.SetPaymentDateST(value : TFslDateTime);
begin
  if FPaymentDate = nil then
    FPaymentDate := TFhirDateTime.create;
  FPaymentDate.value := value
end;

Procedure TFhirContractTermAssetValuedItem.SetResponsible(value : TFhirReference{TFhirOrganization});
begin
  FResponsible.free;
  FResponsible := value;
end;

Procedure TFhirContractTermAssetValuedItem.SetRecipient(value : TFhirReference{TFhirOrganization});
begin
  FRecipient.free;
  FRecipient := value;
end;

Function TFhirContractTermAssetValuedItem.GetLinkIdList : TFhirStringList;
begin
  if FLinkIdList = nil then
    FLinkIdList := TFhirStringList.Create;
  result := FLinkIdList;
end;

Function TFhirContractTermAssetValuedItem.GetHasLinkIdList : boolean;
begin
  result := (FLinkIdList <> nil) and (FLinkIdList.count > 0);
end;

Function TFhirContractTermAssetValuedItem.GetSecurityLabelNumberList : TFhirUnsignedIntList;
begin
  if FSecurityLabelNumberList = nil then
    FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
  result := FSecurityLabelNumberList;
end;

Function TFhirContractTermAssetValuedItem.GetHasSecurityLabelNumberList : boolean;
begin
  result := (FSecurityLabelNumberList <> nil) and (FSecurityLabelNumberList.count > 0);
end;

function TFhirContractTermAssetValuedItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FEntity.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FEffectiveTime.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FPoints.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FPayment.sizeInBytes);
  inc(result, FPaymentDate.sizeInBytes);
  inc(result, FResponsible.sizeInBytes);
  inc(result, FRecipient.sizeInBytes);
  inc(result, FlinkIdList.sizeInBytes);
  inc(result, FsecurityLabelNumberList.sizeInBytes);
end;

{ TFhirContractTermAssetValuedItemListEnumerator }

Constructor TFhirContractTermAssetValuedItemListEnumerator.Create(list : TFhirContractTermAssetValuedItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermAssetValuedItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermAssetValuedItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermAssetValuedItemListEnumerator.GetCurrent : TFhirContractTermAssetValuedItem;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermAssetValuedItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractTermAssetValuedItemList }
procedure TFhirContractTermAssetValuedItemList.AddItem(value: TFhirContractTermAssetValuedItem);
begin
  assert(value.ClassName = 'TFhirContractTermAssetValuedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermAssetValuedItem');
  add(value);
end;

function TFhirContractTermAssetValuedItemList.Append: TFhirContractTermAssetValuedItem;
begin
  result := TFhirContractTermAssetValuedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermAssetValuedItemList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermAssetValuedItemList.GetEnumerator : TFhirContractTermAssetValuedItemListEnumerator;
begin
  result := TFhirContractTermAssetValuedItemListEnumerator.Create(self.link);
end;

function TFhirContractTermAssetValuedItemList.Clone: TFhirContractTermAssetValuedItemList;
begin
  result := TFhirContractTermAssetValuedItemList(inherited Clone);
end;

function TFhirContractTermAssetValuedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermAssetValuedItemList.GetItemN(index: Integer): TFhirContractTermAssetValuedItem;
begin
  result := TFhirContractTermAssetValuedItem(ObjectByIndex[index]);
end;

function TFhirContractTermAssetValuedItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermAssetValuedItem;
end;
function TFhirContractTermAssetValuedItemList.IndexOf(value: TFhirContractTermAssetValuedItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermAssetValuedItemList.Insert(index: Integer): TFhirContractTermAssetValuedItem;
begin
  result := TFhirContractTermAssetValuedItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermAssetValuedItemList.InsertItem(index: Integer; value: TFhirContractTermAssetValuedItem);
begin
  assert(value is TFhirContractTermAssetValuedItem);
  Inherited Insert(index, value);
end;

function TFhirContractTermAssetValuedItemList.Item(index: Integer): TFhirContractTermAssetValuedItem;
begin
  result := TFhirContractTermAssetValuedItem(ObjectByIndex[index]);
end;

function TFhirContractTermAssetValuedItemList.Link: TFhirContractTermAssetValuedItemList;
begin
  result := TFhirContractTermAssetValuedItemList(inherited Link);
end;

procedure TFhirContractTermAssetValuedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermAssetValuedItemList.SetItemByIndex(index: Integer; value: TFhirContractTermAssetValuedItem);
begin
  assert(value is TFhirContractTermAssetValuedItem);
  FhirContractTermAssetValuedItems[index] := value;
end;

procedure TFhirContractTermAssetValuedItemList.SetItemN(index: Integer; value: TFhirContractTermAssetValuedItem);
begin
  assert(value is TFhirContractTermAssetValuedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermAction }

constructor TFhirContractTermAction.Create;
begin
  inherited;
end;

destructor TFhirContractTermAction.Destroy;
begin
  FDoNotPerform.free;
  FType_.free;
  FSubjectList.Free;
  FIntent.free;
  FLinkIdList.Free;
  FStatus.free;
  FContext.free;
  FContextLinkIdList.Free;
  FOccurrence.free;
  FRequesterList.Free;
  FRequesterLinkIdList.Free;
  FPerformerTypeList.Free;
  FPerformerRole.free;
  FPerformer.free;
  FPerformerLinkIdList.Free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FReasonList.Free;
  FReasonLinkIdList.Free;
  FNoteList.Free;
  FSecurityLabelNumberList.Free;
  inherited;
end;

procedure TFhirContractTermAction.Assign(oSource : TFslObject);
begin
  inherited;
  doNotPerformElement := TFhirContractTermAction(oSource).doNotPerformElement.Clone;
  type_ := TFhirContractTermAction(oSource).type_.Clone;
  if (TFhirContractTermAction(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirContractTermActionSubjectList.Create;
    FSubjectList.Assign(TFhirContractTermAction(oSource).FSubjectList);
  end;
  intent := TFhirContractTermAction(oSource).intent.Clone;
  if (TFhirContractTermAction(oSource).FLinkIdList = nil) then
  begin
    FLinkIdList.free;
    FLinkIdList := nil;
  end
  else
  begin
    if FLinkIdList = nil then
      FLinkIdList := TFhirStringList.Create;
    FLinkIdList.Assign(TFhirContractTermAction(oSource).FLinkIdList);
  end;
  status := TFhirContractTermAction(oSource).status.Clone;
  context := TFhirContractTermAction(oSource).context.Clone;
  if (TFhirContractTermAction(oSource).FContextLinkIdList = nil) then
  begin
    FContextLinkIdList.free;
    FContextLinkIdList := nil;
  end
  else
  begin
    if FContextLinkIdList = nil then
      FContextLinkIdList := TFhirStringList.Create;
    FContextLinkIdList.Assign(TFhirContractTermAction(oSource).FContextLinkIdList);
  end;
  occurrence := TFhirContractTermAction(oSource).occurrence.Clone;
  if (TFhirContractTermAction(oSource).FRequesterList = nil) then
  begin
    FRequesterList.free;
    FRequesterList := nil;
  end
  else
  begin
    if FRequesterList = nil then
      FRequesterList := TFhirReferenceList{TFhirPatient}.Create;
    FRequesterList.Assign(TFhirContractTermAction(oSource).FRequesterList);
  end;
  if (TFhirContractTermAction(oSource).FRequesterLinkIdList = nil) then
  begin
    FRequesterLinkIdList.free;
    FRequesterLinkIdList := nil;
  end
  else
  begin
    if FRequesterLinkIdList = nil then
      FRequesterLinkIdList := TFhirStringList.Create;
    FRequesterLinkIdList.Assign(TFhirContractTermAction(oSource).FRequesterLinkIdList);
  end;
  if (TFhirContractTermAction(oSource).FPerformerTypeList = nil) then
  begin
    FPerformerTypeList.free;
    FPerformerTypeList := nil;
  end
  else
  begin
    if FPerformerTypeList = nil then
      FPerformerTypeList := TFhirCodeableConceptList.Create;
    FPerformerTypeList.Assign(TFhirContractTermAction(oSource).FPerformerTypeList);
  end;
  performerRole := TFhirContractTermAction(oSource).performerRole.Clone;
  performer := TFhirContractTermAction(oSource).performer.Clone;
  if (TFhirContractTermAction(oSource).FPerformerLinkIdList = nil) then
  begin
    FPerformerLinkIdList.free;
    FPerformerLinkIdList := nil;
  end
  else
  begin
    if FPerformerLinkIdList = nil then
      FPerformerLinkIdList := TFhirStringList.Create;
    FPerformerLinkIdList.Assign(TFhirContractTermAction(oSource).FPerformerLinkIdList);
  end;
  if (TFhirContractTermAction(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirContractTermAction(oSource).FReasonCodeList);
  end;
  if (TFhirContractTermAction(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList{TFhirCondition}.Create;
    FReasonReferenceList.Assign(TFhirContractTermAction(oSource).FReasonReferenceList);
  end;
  if (TFhirContractTermAction(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirStringList.Create;
    FReasonList.Assign(TFhirContractTermAction(oSource).FReasonList);
  end;
  if (TFhirContractTermAction(oSource).FReasonLinkIdList = nil) then
  begin
    FReasonLinkIdList.free;
    FReasonLinkIdList := nil;
  end
  else
  begin
    if FReasonLinkIdList = nil then
      FReasonLinkIdList := TFhirStringList.Create;
    FReasonLinkIdList.Assign(TFhirContractTermAction(oSource).FReasonLinkIdList);
  end;
  if (TFhirContractTermAction(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirContractTermAction(oSource).FNoteList);
  end;
  if (TFhirContractTermAction(oSource).FSecurityLabelNumberList = nil) then
  begin
    FSecurityLabelNumberList.free;
    FSecurityLabelNumberList := nil;
  end
  else
  begin
    if FSecurityLabelNumberList = nil then
      FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
    FSecurityLabelNumberList.Assign(TFhirContractTermAction(oSource).FSecurityLabelNumberList);
  end;
end;

procedure TFhirContractTermAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'doNotPerform') Then
     list.add(self.link, 'doNotPerform', FDoNotPerform.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'linkId') Then
    list.addAll(self, 'linkId', FLinkIdList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'contextLinkId') Then
    list.addAll(self, 'contextLinkId', FContextLinkIdList);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'requester') Then
    list.addAll(self, 'requester', FRequesterList);
  if (child_name = 'requesterLinkId') Then
    list.addAll(self, 'requesterLinkId', FRequesterLinkIdList);
  if (child_name = 'performerType') Then
    list.addAll(self, 'performerType', FPerformerTypeList);
  if (child_name = 'performerRole') Then
     list.add(self.link, 'performerRole', FPerformerRole.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'performerLinkId') Then
    list.addAll(self, 'performerLinkId', FPerformerLinkIdList);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'reasonLinkId') Then
    list.addAll(self, 'reasonLinkId', FReasonLinkIdList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'securityLabelNumber') Then
    list.addAll(self, 'securityLabelNumber', FSecurityLabelNumberList);
end;

procedure TFhirContractTermAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'doNotPerform', 'boolean', false, TFhirBoolean, FDoNotPerform.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', '', true, TFhirContractTermActionSubject, FSubjectList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'intent', 'CodeableConcept', false, TFhirCodeableConcept, FIntent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', true, TFhirString, FLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contextLinkId', 'string', true, TFhirString, FContextLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|Timing', false, TFhirType, FOccurrence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requester', 'Reference(Patient)', true, TFhirReference{TFhirPatient}, FRequesterList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'requesterLinkId', 'string', true, TFhirString, FRequesterLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'performerType', 'CodeableConcept', true, TFhirCodeableConcept, FPerformerTypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'performerRole', 'CodeableConcept', false, TFhirCodeableConcept, FPerformerRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference(RelatedPerson)', false, TFhirReference{TFhirRelatedPerson}, FPerformer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performerLinkId', 'string', true, TFhirString, FPerformerLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference(Condition)', true, TFhirReference{TFhirCondition}, FReasonReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reason', 'string', true, TFhirString, FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonLinkId', 'string', true, TFhirString, FReasonLinkIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'securityLabelNumber', 'unsignedInt', true, TFhirUnsignedInt, FSecurityLabelNumberList.Link)){3};
end;

function TFhirContractTermAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'doNotPerform') then
  begin
    DoNotPerformElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirContractTermActionSubject){2a};
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    Intent := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'linkId') then
  begin
    LinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'contextLinkId') then
  begin
    ContextLinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    RequesterList.add(propValue as TFhirReference{TFhirPatient}){2a};
    result := propValue;
  end
  else if (propName = 'requesterLinkId') then
  begin
    RequesterLinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'performerType') then
  begin
    PerformerTypeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'performerRole') then
  begin
    PerformerRole := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference{TFhirRelatedPerson}{4b};
    result := propValue;
  end
  else if (propName = 'performerLinkId') then
  begin
    PerformerLinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference{TFhirCondition}){2a};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'reasonLinkId') then
  begin
    ReasonLinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'securityLabelNumber') then
  begin
    SecurityLabelNumberList.add(asUnsignedInt(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirContractTermActionSubject){2a}
  else if (propName = 'linkId') then LinkIdList.insertItem(index, asString(propValue)){2}
  else if (propName = 'contextLinkId') then ContextLinkIdList.insertItem(index, asString(propValue)){2}
  else if (propName = 'requester') then RequesterList.insertItem(index, propValue as TFhirReference{TFhirPatient}){2a}
  else if (propName = 'requesterLinkId') then RequesterLinkIdList.insertItem(index, asString(propValue)){2}
  else if (propName = 'performerType') then PerformerTypeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'performerLinkId') then PerformerLinkIdList.insertItem(index, asString(propValue)){2}
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference{TFhirCondition}){2a}
  else if (propName = 'reason') then ReasonList.insertItem(index, asString(propValue)){2}
  else if (propName = 'reasonLinkId') then ReasonLinkIdList.insertItem(index, asString(propValue)){2}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.insertItem(index, asUnsignedInt(propValue)){2}
  else inherited;
end;

function TFhirContractTermAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'doNotPerform') then result := TFhirBoolean.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := SubjectList.new(){2}
  else if (propName = 'intent') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'linkId') then result := LinkIdList.new(){2}
  else if (propName = 'status') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'context') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'contextLinkId') then result := ContextLinkIdList.new(){2}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence'){4x}
  else if (propName = 'requester') then result := RequesterList.new(){2}
  else if (propName = 'requesterLinkId') then result := RequesterLinkIdList.new(){2}
  else if (propName = 'performerType') then result := PerformerTypeList.new(){2}
  else if (propName = 'performerRole') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'performer') then result := TFhirReference{TFhirRelatedPerson}.create(){4b}
  else if (propName = 'performerLinkId') then result := PerformerLinkIdList.new(){2}
  else if (propName = 'reasonCode') then result := ReasonCodeList.new(){2}
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new(){2}
  else if (propName = 'reason') then result := ReasonList.new(){2}
  else if (propName = 'reasonLinkId') then result := ReasonLinkIdList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'securityLabelNumber') then result := SecurityLabelNumberList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'doNotPerform') then result := 'boolean'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := ''
  else if (propName = 'intent') then result := 'CodeableConcept'
  else if (propName = 'linkId') then result := 'string'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'contextLinkId') then result := 'string'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'requester') then result := 'Reference'
  else if (propName = 'requesterLinkId') then result := 'string'
  else if (propName = 'performerType') then result := 'CodeableConcept'
  else if (propName = 'performerRole') then result := 'CodeableConcept'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'performerLinkId') then result := 'string'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'reason') then result := 'string'
  else if (propName = 'reasonLinkId') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'securityLabelNumber') then result := 'unsignedInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'doNotPerform') then DoNotPerformElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value) {2}
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'linkId') then deletePropertyValue('linkId', LinkIdList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (propName = 'contextLinkId') then deletePropertyValue('contextLinkId', ContextLinkIdList, value) {2}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := nil{4x}
  else if (propName = 'requester') then deletePropertyValue('requester', RequesterList, value) {2}
  else if (propName = 'requesterLinkId') then deletePropertyValue('requesterLinkId', RequesterLinkIdList, value) {2}
  else if (propName = 'performerType') then deletePropertyValue('performerType', PerformerTypeList, value) {2}
  else if (propName = 'performerRole') then PerformerRoleElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'performerLinkId') then deletePropertyValue('performerLinkId', PerformerLinkIdList, value) {2}
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value) {2}
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value) {2}
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {2}
  else if (propName = 'reasonLinkId') then deletePropertyValue('reasonLinkId', ReasonLinkIdList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'securityLabelNumber') then deletePropertyValue('securityLabelNumber', SecurityLabelNumberList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'doNotPerform') then DoNotPerformElement := asBoolean(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new) {2}
  else if (propName = 'intent') then IntentElement := new as TFhirCodeableConcept{4}
  else if (propName = 'linkId') then replacePropertyValue('linkId', LinkIdList, existing, new) {2}
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'contextLinkId') then replacePropertyValue('contextLinkId', ContextLinkIdList, existing, new) {2}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := new as TFhirType{4x}
  else if (propName = 'requester') then replacePropertyValue('requester', RequesterList, existing, new) {2}
  else if (propName = 'requesterLinkId') then replacePropertyValue('requesterLinkId', RequesterLinkIdList, existing, new) {2}
  else if (propName = 'performerType') then replacePropertyValue('performerType', PerformerTypeList, existing, new) {2}
  else if (propName = 'performerRole') then PerformerRoleElement := new as TFhirCodeableConcept{4}
  else if (propName = 'performer') then PerformerElement := new as TFhirReference{TFhirRelatedPerson}{4}
  else if (propName = 'performerLinkId') then replacePropertyValue('performerLinkId', PerformerLinkIdList, existing, new) {2}
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new) {2}
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new) {2}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {2}
  else if (propName = 'reasonLinkId') then replacePropertyValue('reasonLinkId', ReasonLinkIdList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'securityLabelNumber') then replacePropertyValue('securityLabelNumber', SecurityLabelNumberList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermAction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'subject') then SubjectList.move(source, destination){2a}
  else if (propName = 'linkId') then LinkIdList.move(source, destination){2}
  else if (propName = 'contextLinkId') then ContextLinkIdList.move(source, destination){2}
  else if (propName = 'requester') then RequesterList.move(source, destination){2a}
  else if (propName = 'requesterLinkId') then RequesterLinkIdList.move(source, destination){2}
  else if (propName = 'performerType') then PerformerTypeList.move(source, destination){2a}
  else if (propName = 'performerLinkId') then PerformerLinkIdList.move(source, destination){2}
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination){2a}
  else if (propName = 'reason') then ReasonList.move(source, destination){2}
  else if (propName = 'reasonLinkId') then ReasonLinkIdList.move(source, destination){2}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermAction.fhirType : string;
begin
  result := 'action';
end;

function TFhirContractTermAction.Link : TFhirContractTermAction;
begin
  result := TFhirContractTermAction(inherited Link);
end;

function TFhirContractTermAction.Clone : TFhirContractTermAction;
begin
  result := TFhirContractTermAction(inherited Clone);
end;

function TFhirContractTermAction.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermAction)) then
    result := false
  else
  begin
    o := TFhirContractTermAction(other);
    result := compareDeep(doNotPerformElement, o.doNotPerformElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subjectList, o.subjectList, true) and 
      compareDeep(intentElement, o.intentElement, true) and compareDeep(linkIdList, o.linkIdList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(contextElement, o.contextElement, true) and 
      compareDeep(contextLinkIdList, o.contextLinkIdList, true) and compareDeep(occurrenceElement, o.occurrenceElement, true) and 
      compareDeep(requesterList, o.requesterList, true) and compareDeep(requesterLinkIdList, o.requesterLinkIdList, true) and 
      compareDeep(performerTypeList, o.performerTypeList, true) and compareDeep(performerRoleElement, o.performerRoleElement, true) and 
      compareDeep(performerElement, o.performerElement, true) and compareDeep(performerLinkIdList, o.performerLinkIdList, true) and 
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(reasonReferenceList, o.reasonReferenceList, true) and 
      compareDeep(reasonList, o.reasonList, true) and compareDeep(reasonLinkIdList, o.reasonLinkIdList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(securityLabelNumberList, o.securityLabelNumberList, true);
  end;
end;

function TFhirContractTermAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDoNotPerform) and isEmptyProp(FType_) and isEmptyProp(FsubjectList) and isEmptyProp(FIntent) and isEmptyProp(FlinkIdList) and isEmptyProp(FStatus) and isEmptyProp(FContext) and isEmptyProp(FcontextLinkIdList) and isEmptyProp(FOccurrence) and isEmptyProp(FrequesterList) and isEmptyProp(FrequesterLinkIdList) and isEmptyProp(FperformerTypeList) and isEmptyProp(FPerformerRole) and isEmptyProp(FPerformer) and isEmptyProp(FperformerLinkIdList) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FreasonList) and isEmptyProp(FreasonLinkIdList) and isEmptyProp(FnoteList) and isEmptyProp(FsecurityLabelNumberList);
end;

procedure TFhirContractTermAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('doNotPerform');
  fields.add('type');
  fields.add('subject');
  fields.add('intent');
  fields.add('linkId');
  fields.add('status');
  fields.add('context');
  fields.add('contextLinkId');
  fields.add('occurrence[x]');
  fields.add('requester');
  fields.add('requesterLinkId');
  fields.add('performerType');
  fields.add('performerRole');
  fields.add('performer');
  fields.add('performerLinkId');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('reason');
  fields.add('reasonLinkId');
  fields.add('note');
  fields.add('securityLabelNumber');
end;

{ TFhirContractTermAction }

Procedure TFhirContractTermAction.SetDoNotPerform(value : TFhirBoolean);
begin
  FDoNotPerform.free;
  FDoNotPerform := value;
end;

Function TFhirContractTermAction.GetDoNotPerformST : Boolean;
begin
  if FDoNotPerform = nil then
    result := false
  else
    result := FDoNotPerform.value;
end;

Procedure TFhirContractTermAction.SetDoNotPerformST(value : Boolean);
begin
  if FDoNotPerform = nil then
    FDoNotPerform := TFhirBoolean.create;
  FDoNotPerform.value := value
end;

Procedure TFhirContractTermAction.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirContractTermAction.GetSubjectList : TFhirContractTermActionSubjectList;
begin
  if FSubjectList = nil then
    FSubjectList := TFhirContractTermActionSubjectList.Create;
  result := FSubjectList;
end;

Function TFhirContractTermAction.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

Procedure TFhirContractTermAction.SetIntent(value : TFhirCodeableConcept);
begin
  FIntent.free;
  FIntent := value;
end;

Function TFhirContractTermAction.GetLinkIdList : TFhirStringList;
begin
  if FLinkIdList = nil then
    FLinkIdList := TFhirStringList.Create;
  result := FLinkIdList;
end;

Function TFhirContractTermAction.GetHasLinkIdList : boolean;
begin
  result := (FLinkIdList <> nil) and (FLinkIdList.count > 0);
end;

Procedure TFhirContractTermAction.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

Procedure TFhirContractTermAction.SetContext(value : TFhirReference{TFhirEncounter});
begin
  FContext.free;
  FContext := value;
end;

Function TFhirContractTermAction.GetContextLinkIdList : TFhirStringList;
begin
  if FContextLinkIdList = nil then
    FContextLinkIdList := TFhirStringList.Create;
  result := FContextLinkIdList;
end;

Function TFhirContractTermAction.GetHasContextLinkIdList : boolean;
begin
  result := (FContextLinkIdList <> nil) and (FContextLinkIdList.count > 0);
end;

Procedure TFhirContractTermAction.SetOccurrence(value : TFhirType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

Function TFhirContractTermAction.GetRequesterList : TFhirReferenceList{TFhirPatient};
begin
  if FRequesterList = nil then
    FRequesterList := TFhirReferenceList{TFhirPatient}.Create;
  result := FRequesterList;
end;

Function TFhirContractTermAction.GetHasRequesterList : boolean;
begin
  result := (FRequesterList <> nil) and (FRequesterList.count > 0);
end;

Function TFhirContractTermAction.GetRequesterLinkIdList : TFhirStringList;
begin
  if FRequesterLinkIdList = nil then
    FRequesterLinkIdList := TFhirStringList.Create;
  result := FRequesterLinkIdList;
end;

Function TFhirContractTermAction.GetHasRequesterLinkIdList : boolean;
begin
  result := (FRequesterLinkIdList <> nil) and (FRequesterLinkIdList.count > 0);
end;

Function TFhirContractTermAction.GetPerformerTypeList : TFhirCodeableConceptList;
begin
  if FPerformerTypeList = nil then
    FPerformerTypeList := TFhirCodeableConceptList.Create;
  result := FPerformerTypeList;
end;

Function TFhirContractTermAction.GetHasPerformerTypeList : boolean;
begin
  result := (FPerformerTypeList <> nil) and (FPerformerTypeList.count > 0);
end;

Procedure TFhirContractTermAction.SetPerformerRole(value : TFhirCodeableConcept);
begin
  FPerformerRole.free;
  FPerformerRole := value;
end;

Procedure TFhirContractTermAction.SetPerformer(value : TFhirReference{TFhirRelatedPerson});
begin
  FPerformer.free;
  FPerformer := value;
end;

Function TFhirContractTermAction.GetPerformerLinkIdList : TFhirStringList;
begin
  if FPerformerLinkIdList = nil then
    FPerformerLinkIdList := TFhirStringList.Create;
  result := FPerformerLinkIdList;
end;

Function TFhirContractTermAction.GetHasPerformerLinkIdList : boolean;
begin
  result := (FPerformerLinkIdList <> nil) and (FPerformerLinkIdList.count > 0);
end;

Function TFhirContractTermAction.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

Function TFhirContractTermAction.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

Function TFhirContractTermAction.GetReasonReferenceList : TFhirReferenceList{TFhirCondition};
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList{TFhirCondition}.Create;
  result := FReasonReferenceList;
end;

Function TFhirContractTermAction.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

Function TFhirContractTermAction.GetReasonList : TFhirStringList;
begin
  if FReasonList = nil then
    FReasonList := TFhirStringList.Create;
  result := FReasonList;
end;

Function TFhirContractTermAction.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

Function TFhirContractTermAction.GetReasonLinkIdList : TFhirStringList;
begin
  if FReasonLinkIdList = nil then
    FReasonLinkIdList := TFhirStringList.Create;
  result := FReasonLinkIdList;
end;

Function TFhirContractTermAction.GetHasReasonLinkIdList : boolean;
begin
  result := (FReasonLinkIdList <> nil) and (FReasonLinkIdList.count > 0);
end;

Function TFhirContractTermAction.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirContractTermAction.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirContractTermAction.GetSecurityLabelNumberList : TFhirUnsignedIntList;
begin
  if FSecurityLabelNumberList = nil then
    FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
  result := FSecurityLabelNumberList;
end;

Function TFhirContractTermAction.GetHasSecurityLabelNumberList : boolean;
begin
  result := (FSecurityLabelNumberList <> nil) and (FSecurityLabelNumberList.count > 0);
end;

function TFhirContractTermAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDoNotPerform.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FsubjectList.sizeInBytes);
  inc(result, FIntent.sizeInBytes);
  inc(result, FlinkIdList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FcontextLinkIdList.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FrequesterList.sizeInBytes);
  inc(result, FrequesterLinkIdList.sizeInBytes);
  inc(result, FperformerTypeList.sizeInBytes);
  inc(result, FPerformerRole.sizeInBytes);
  inc(result, FPerformer.sizeInBytes);
  inc(result, FperformerLinkIdList.sizeInBytes);
  inc(result, FreasonCodeList.sizeInBytes);
  inc(result, FreasonReferenceList.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FreasonLinkIdList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FsecurityLabelNumberList.sizeInBytes);
end;

{ TFhirContractTermActionListEnumerator }

Constructor TFhirContractTermActionListEnumerator.Create(list : TFhirContractTermActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermActionListEnumerator.GetCurrent : TFhirContractTermAction;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractTermActionList }
procedure TFhirContractTermActionList.AddItem(value: TFhirContractTermAction);
begin
  assert(value.ClassName = 'TFhirContractTermAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermAction');
  add(value);
end;

function TFhirContractTermActionList.Append: TFhirContractTermAction;
begin
  result := TFhirContractTermAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermActionList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermActionList.GetEnumerator : TFhirContractTermActionListEnumerator;
begin
  result := TFhirContractTermActionListEnumerator.Create(self.link);
end;

function TFhirContractTermActionList.Clone: TFhirContractTermActionList;
begin
  result := TFhirContractTermActionList(inherited Clone);
end;

function TFhirContractTermActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermActionList.GetItemN(index: Integer): TFhirContractTermAction;
begin
  result := TFhirContractTermAction(ObjectByIndex[index]);
end;

function TFhirContractTermActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermAction;
end;
function TFhirContractTermActionList.IndexOf(value: TFhirContractTermAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermActionList.Insert(index: Integer): TFhirContractTermAction;
begin
  result := TFhirContractTermAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermActionList.InsertItem(index: Integer; value: TFhirContractTermAction);
begin
  assert(value is TFhirContractTermAction);
  Inherited Insert(index, value);
end;

function TFhirContractTermActionList.Item(index: Integer): TFhirContractTermAction;
begin
  result := TFhirContractTermAction(ObjectByIndex[index]);
end;

function TFhirContractTermActionList.Link: TFhirContractTermActionList;
begin
  result := TFhirContractTermActionList(inherited Link);
end;

procedure TFhirContractTermActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermActionList.SetItemByIndex(index: Integer; value: TFhirContractTermAction);
begin
  assert(value is TFhirContractTermAction);
  FhirContractTermActions[index] := value;
end;

procedure TFhirContractTermActionList.SetItemN(index: Integer; value: TFhirContractTermAction);
begin
  assert(value is TFhirContractTermAction);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermActionSubject }

constructor TFhirContractTermActionSubject.Create;
begin
  inherited;
end;

destructor TFhirContractTermActionSubject.Destroy;
begin
  FReferenceList.Free;
  FRole.free;
  inherited;
end;

procedure TFhirContractTermActionSubject.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirContractTermActionSubject(oSource).FReferenceList = nil) then
  begin
    FReferenceList.free;
    FReferenceList := nil;
  end
  else
  begin
    if FReferenceList = nil then
      FReferenceList := TFhirReferenceList{TFhirPatient}.Create;
    FReferenceList.Assign(TFhirContractTermActionSubject(oSource).FReferenceList);
  end;
  role := TFhirContractTermActionSubject(oSource).role.Clone;
end;

procedure TFhirContractTermActionSubject.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'reference') Then
    list.addAll(self, 'reference', FReferenceList);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
end;

procedure TFhirContractTermActionSubject.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference(Patient)', true, TFhirReference{TFhirPatient}, FReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
end;

function TFhirContractTermActionSubject.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'reference') then
  begin
    ReferenceList.add(propValue as TFhirReference{TFhirPatient}){2a};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermActionSubject.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reference') then ReferenceList.insertItem(index, propValue as TFhirReference{TFhirPatient}){2a}
  else inherited;
end;

function TFhirContractTermActionSubject.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'reference') then result := ReferenceList.new(){2}
  else if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermActionSubject.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'reference') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermActionSubject.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'reference') then deletePropertyValue('reference', ReferenceList, value) {2}
  else if (propName = 'role') then RoleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermActionSubject.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'reference') then replacePropertyValue('reference', ReferenceList, existing, new) {2}
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermActionSubject.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reference') then ReferenceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermActionSubject.fhirType : string;
begin
  result := 'subject';
end;

function TFhirContractTermActionSubject.Link : TFhirContractTermActionSubject;
begin
  result := TFhirContractTermActionSubject(inherited Link);
end;

function TFhirContractTermActionSubject.Clone : TFhirContractTermActionSubject;
begin
  result := TFhirContractTermActionSubject(inherited Clone);
end;

function TFhirContractTermActionSubject.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermActionSubject;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermActionSubject)) then
    result := false
  else
  begin
    o := TFhirContractTermActionSubject(other);
    result := compareDeep(referenceList, o.referenceList, true) and compareDeep(roleElement, o.roleElement, true);
  end;
end;

function TFhirContractTermActionSubject.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FreferenceList) and isEmptyProp(FRole);
end;

procedure TFhirContractTermActionSubject.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('reference');
  fields.add('role');
end;

{ TFhirContractTermActionSubject }

Function TFhirContractTermActionSubject.GetReferenceList : TFhirReferenceList{TFhirPatient};
begin
  if FReferenceList = nil then
    FReferenceList := TFhirReferenceList{TFhirPatient}.Create;
  result := FReferenceList;
end;

Function TFhirContractTermActionSubject.GetHasReferenceList : boolean;
begin
  result := (FReferenceList <> nil) and (FReferenceList.count > 0);
end;

Procedure TFhirContractTermActionSubject.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

function TFhirContractTermActionSubject.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FreferenceList.sizeInBytes);
  inc(result, FRole.sizeInBytes);
end;

{ TFhirContractTermActionSubjectListEnumerator }

Constructor TFhirContractTermActionSubjectListEnumerator.Create(list : TFhirContractTermActionSubjectList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermActionSubjectListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermActionSubjectListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermActionSubjectListEnumerator.GetCurrent : TFhirContractTermActionSubject;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermActionSubjectListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractTermActionSubjectList }
procedure TFhirContractTermActionSubjectList.AddItem(value: TFhirContractTermActionSubject);
begin
  assert(value.ClassName = 'TFhirContractTermActionSubject', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermActionSubject');
  add(value);
end;

function TFhirContractTermActionSubjectList.Append: TFhirContractTermActionSubject;
begin
  result := TFhirContractTermActionSubject.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermActionSubjectList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermActionSubjectList.GetEnumerator : TFhirContractTermActionSubjectListEnumerator;
begin
  result := TFhirContractTermActionSubjectListEnumerator.Create(self.link);
end;

function TFhirContractTermActionSubjectList.Clone: TFhirContractTermActionSubjectList;
begin
  result := TFhirContractTermActionSubjectList(inherited Clone);
end;

function TFhirContractTermActionSubjectList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermActionSubjectList.GetItemN(index: Integer): TFhirContractTermActionSubject;
begin
  result := TFhirContractTermActionSubject(ObjectByIndex[index]);
end;

function TFhirContractTermActionSubjectList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermActionSubject;
end;
function TFhirContractTermActionSubjectList.IndexOf(value: TFhirContractTermActionSubject): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermActionSubjectList.Insert(index: Integer): TFhirContractTermActionSubject;
begin
  result := TFhirContractTermActionSubject.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermActionSubjectList.InsertItem(index: Integer; value: TFhirContractTermActionSubject);
begin
  assert(value is TFhirContractTermActionSubject);
  Inherited Insert(index, value);
end;

function TFhirContractTermActionSubjectList.Item(index: Integer): TFhirContractTermActionSubject;
begin
  result := TFhirContractTermActionSubject(ObjectByIndex[index]);
end;

function TFhirContractTermActionSubjectList.Link: TFhirContractTermActionSubjectList;
begin
  result := TFhirContractTermActionSubjectList(inherited Link);
end;

procedure TFhirContractTermActionSubjectList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermActionSubjectList.SetItemByIndex(index: Integer; value: TFhirContractTermActionSubject);
begin
  assert(value is TFhirContractTermActionSubject);
  FhirContractTermActionSubjects[index] := value;
end;

procedure TFhirContractTermActionSubjectList.SetItemN(index: Integer; value: TFhirContractTermActionSubject);
begin
  assert(value is TFhirContractTermActionSubject);
  ObjectByIndex[index] := value;
end;

{ TFhirContractSigner }

constructor TFhirContractSigner.Create;
begin
  inherited;
end;

destructor TFhirContractSigner.Destroy;
begin
  FType_.free;
  FParty.free;
  FSignatureList.Free;
  inherited;
end;

procedure TFhirContractSigner.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirContractSigner(oSource).type_.Clone;
  party := TFhirContractSigner(oSource).party.Clone;
  if (TFhirContractSigner(oSource).FSignatureList = nil) then
  begin
    FSignatureList.free;
    FSignatureList := nil;
  end
  else
  begin
    if FSignatureList = nil then
      FSignatureList := TFhirSignatureList.Create;
    FSignatureList.Assign(TFhirContractSigner(oSource).FSignatureList);
  end;
end;

procedure TFhirContractSigner.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
  if (child_name = 'signature') Then
    list.addAll(self, 'signature', FSignatureList);
end;

procedure TFhirContractSigner.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'party', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FParty.Link));{2}
  oList.add(TFHIRProperty.create(self, 'signature', 'Signature', true, TFhirSignature, FSignatureList.Link)){3};
end;

function TFhirContractSigner.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    Party := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'signature') then
  begin
    SignatureList.add(propValue as TFhirSignature){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractSigner.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'signature') then SignatureList.insertItem(index, propValue as TFhirSignature){2a}
  else inherited;
end;

function TFhirContractSigner.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'party') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'signature') then result := SignatureList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractSigner.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'Coding'
  else if (propName = 'party') then result := 'Reference'
  else if (propName = 'signature') then result := 'Signature'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractSigner.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'party') then PartyElement := nil
  else if (propName = 'signature') then deletePropertyValue('signature', SignatureList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractSigner.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'party') then PartyElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'signature') then replacePropertyValue('signature', SignatureList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractSigner.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'signature') then SignatureList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractSigner.fhirType : string;
begin
  result := 'signer';
end;

function TFhirContractSigner.Link : TFhirContractSigner;
begin
  result := TFhirContractSigner(inherited Link);
end;

function TFhirContractSigner.Clone : TFhirContractSigner;
begin
  result := TFhirContractSigner(inherited Clone);
end;

function TFhirContractSigner.equals(other : TObject) : boolean; 
var
  o : TFhirContractSigner;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractSigner)) then
    result := false
  else
  begin
    o := TFhirContractSigner(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(partyElement, o.partyElement, true) and 
      compareDeep(signatureList, o.signatureList, true);
  end;
end;

function TFhirContractSigner.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FParty) and isEmptyProp(FsignatureList);
end;

procedure TFhirContractSigner.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('party');
  fields.add('signature');
end;

{ TFhirContractSigner }

Procedure TFhirContractSigner.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirContractSigner.SetParty(value : TFhirReference{TFhirOrganization});
begin
  FParty.free;
  FParty := value;
end;

Function TFhirContractSigner.GetSignatureList : TFhirSignatureList;
begin
  if FSignatureList = nil then
    FSignatureList := TFhirSignatureList.Create;
  result := FSignatureList;
end;

Function TFhirContractSigner.GetHasSignatureList : boolean;
begin
  result := (FSignatureList <> nil) and (FSignatureList.count > 0);
end;

function TFhirContractSigner.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FParty.sizeInBytes);
  inc(result, FsignatureList.sizeInBytes);
end;

{ TFhirContractSignerListEnumerator }

Constructor TFhirContractSignerListEnumerator.Create(list : TFhirContractSignerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractSignerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractSignerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractSignerListEnumerator.GetCurrent : TFhirContractSigner;
begin
  Result := FList[FIndex];
end;

function TFhirContractSignerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractSignerList }
procedure TFhirContractSignerList.AddItem(value: TFhirContractSigner);
begin
  assert(value.ClassName = 'TFhirContractSigner', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractSigner');
  add(value);
end;

function TFhirContractSignerList.Append: TFhirContractSigner;
begin
  result := TFhirContractSigner.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractSignerList.ClearItems;
begin
  Clear;
end;

function TFhirContractSignerList.GetEnumerator : TFhirContractSignerListEnumerator;
begin
  result := TFhirContractSignerListEnumerator.Create(self.link);
end;

function TFhirContractSignerList.Clone: TFhirContractSignerList;
begin
  result := TFhirContractSignerList(inherited Clone);
end;

function TFhirContractSignerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractSignerList.GetItemN(index: Integer): TFhirContractSigner;
begin
  result := TFhirContractSigner(ObjectByIndex[index]);
end;

function TFhirContractSignerList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractSigner;
end;
function TFhirContractSignerList.IndexOf(value: TFhirContractSigner): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractSignerList.Insert(index: Integer): TFhirContractSigner;
begin
  result := TFhirContractSigner.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractSignerList.InsertItem(index: Integer; value: TFhirContractSigner);
begin
  assert(value is TFhirContractSigner);
  Inherited Insert(index, value);
end;

function TFhirContractSignerList.Item(index: Integer): TFhirContractSigner;
begin
  result := TFhirContractSigner(ObjectByIndex[index]);
end;

function TFhirContractSignerList.Link: TFhirContractSignerList;
begin
  result := TFhirContractSignerList(inherited Link);
end;

procedure TFhirContractSignerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractSignerList.SetItemByIndex(index: Integer; value: TFhirContractSigner);
begin
  assert(value is TFhirContractSigner);
  FhirContractSigners[index] := value;
end;

procedure TFhirContractSignerList.SetItemN(index: Integer; value: TFhirContractSigner);
begin
  assert(value is TFhirContractSigner);
  ObjectByIndex[index] := value;
end;

{ TFhirContractFriendly }

constructor TFhirContractFriendly.Create;
begin
  inherited;
end;

destructor TFhirContractFriendly.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirContractFriendly.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirContractFriendly(oSource).content.Clone;
end;

procedure TFhirContractFriendly.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirContractFriendly.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'Attachment|Reference(Composition)', false, TFhirType, FContent.Link));{2}
end;

function TFhirContractFriendly.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractFriendly.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractFriendly.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractFriendly.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractFriendly.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirContractFriendly.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractFriendly.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractFriendly.fhirType : string;
begin
  result := 'friendly';
end;

function TFhirContractFriendly.Link : TFhirContractFriendly;
begin
  result := TFhirContractFriendly(inherited Link);
end;

function TFhirContractFriendly.Clone : TFhirContractFriendly;
begin
  result := TFhirContractFriendly(inherited Clone);
end;

function TFhirContractFriendly.equals(other : TObject) : boolean; 
var
  o : TFhirContractFriendly;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractFriendly)) then
    result := false
  else
  begin
    o := TFhirContractFriendly(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirContractFriendly.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirContractFriendly.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('content[x]');
end;

{ TFhirContractFriendly }

Procedure TFhirContractFriendly.SetContent(value : TFhirType);
begin
  FContent.free;
  FContent := value;
end;

function TFhirContractFriendly.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContent.sizeInBytes);
end;

{ TFhirContractFriendlyListEnumerator }

Constructor TFhirContractFriendlyListEnumerator.Create(list : TFhirContractFriendlyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractFriendlyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractFriendlyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractFriendlyListEnumerator.GetCurrent : TFhirContractFriendly;
begin
  Result := FList[FIndex];
end;

function TFhirContractFriendlyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractFriendlyList }
procedure TFhirContractFriendlyList.AddItem(value: TFhirContractFriendly);
begin
  assert(value.ClassName = 'TFhirContractFriendly', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractFriendly');
  add(value);
end;

function TFhirContractFriendlyList.Append: TFhirContractFriendly;
begin
  result := TFhirContractFriendly.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractFriendlyList.ClearItems;
begin
  Clear;
end;

function TFhirContractFriendlyList.GetEnumerator : TFhirContractFriendlyListEnumerator;
begin
  result := TFhirContractFriendlyListEnumerator.Create(self.link);
end;

function TFhirContractFriendlyList.Clone: TFhirContractFriendlyList;
begin
  result := TFhirContractFriendlyList(inherited Clone);
end;

function TFhirContractFriendlyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractFriendlyList.GetItemN(index: Integer): TFhirContractFriendly;
begin
  result := TFhirContractFriendly(ObjectByIndex[index]);
end;

function TFhirContractFriendlyList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractFriendly;
end;
function TFhirContractFriendlyList.IndexOf(value: TFhirContractFriendly): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractFriendlyList.Insert(index: Integer): TFhirContractFriendly;
begin
  result := TFhirContractFriendly.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractFriendlyList.InsertItem(index: Integer; value: TFhirContractFriendly);
begin
  assert(value is TFhirContractFriendly);
  Inherited Insert(index, value);
end;

function TFhirContractFriendlyList.Item(index: Integer): TFhirContractFriendly;
begin
  result := TFhirContractFriendly(ObjectByIndex[index]);
end;

function TFhirContractFriendlyList.Link: TFhirContractFriendlyList;
begin
  result := TFhirContractFriendlyList(inherited Link);
end;

procedure TFhirContractFriendlyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractFriendlyList.SetItemByIndex(index: Integer; value: TFhirContractFriendly);
begin
  assert(value is TFhirContractFriendly);
  FhirContractFriendlies[index] := value;
end;

procedure TFhirContractFriendlyList.SetItemN(index: Integer; value: TFhirContractFriendly);
begin
  assert(value is TFhirContractFriendly);
  ObjectByIndex[index] := value;
end;

{ TFhirContractLegal }

constructor TFhirContractLegal.Create;
begin
  inherited;
end;

destructor TFhirContractLegal.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirContractLegal.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirContractLegal(oSource).content.Clone;
end;

procedure TFhirContractLegal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirContractLegal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'Attachment|Reference(Composition)', false, TFhirType, FContent.Link));{2}
end;

function TFhirContractLegal.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractLegal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractLegal.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractLegal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractLegal.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirContractLegal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractLegal.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractLegal.fhirType : string;
begin
  result := 'legal';
end;

function TFhirContractLegal.Link : TFhirContractLegal;
begin
  result := TFhirContractLegal(inherited Link);
end;

function TFhirContractLegal.Clone : TFhirContractLegal;
begin
  result := TFhirContractLegal(inherited Clone);
end;

function TFhirContractLegal.equals(other : TObject) : boolean; 
var
  o : TFhirContractLegal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractLegal)) then
    result := false
  else
  begin
    o := TFhirContractLegal(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirContractLegal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirContractLegal.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('content[x]');
end;

{ TFhirContractLegal }

Procedure TFhirContractLegal.SetContent(value : TFhirType);
begin
  FContent.free;
  FContent := value;
end;

function TFhirContractLegal.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContent.sizeInBytes);
end;

{ TFhirContractLegalListEnumerator }

Constructor TFhirContractLegalListEnumerator.Create(list : TFhirContractLegalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractLegalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractLegalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractLegalListEnumerator.GetCurrent : TFhirContractLegal;
begin
  Result := FList[FIndex];
end;

function TFhirContractLegalListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractLegalList }
procedure TFhirContractLegalList.AddItem(value: TFhirContractLegal);
begin
  assert(value.ClassName = 'TFhirContractLegal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractLegal');
  add(value);
end;

function TFhirContractLegalList.Append: TFhirContractLegal;
begin
  result := TFhirContractLegal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractLegalList.ClearItems;
begin
  Clear;
end;

function TFhirContractLegalList.GetEnumerator : TFhirContractLegalListEnumerator;
begin
  result := TFhirContractLegalListEnumerator.Create(self.link);
end;

function TFhirContractLegalList.Clone: TFhirContractLegalList;
begin
  result := TFhirContractLegalList(inherited Clone);
end;

function TFhirContractLegalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractLegalList.GetItemN(index: Integer): TFhirContractLegal;
begin
  result := TFhirContractLegal(ObjectByIndex[index]);
end;

function TFhirContractLegalList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractLegal;
end;
function TFhirContractLegalList.IndexOf(value: TFhirContractLegal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractLegalList.Insert(index: Integer): TFhirContractLegal;
begin
  result := TFhirContractLegal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractLegalList.InsertItem(index: Integer; value: TFhirContractLegal);
begin
  assert(value is TFhirContractLegal);
  Inherited Insert(index, value);
end;

function TFhirContractLegalList.Item(index: Integer): TFhirContractLegal;
begin
  result := TFhirContractLegal(ObjectByIndex[index]);
end;

function TFhirContractLegalList.Link: TFhirContractLegalList;
begin
  result := TFhirContractLegalList(inherited Link);
end;

procedure TFhirContractLegalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractLegalList.SetItemByIndex(index: Integer; value: TFhirContractLegal);
begin
  assert(value is TFhirContractLegal);
  FhirContractLegals[index] := value;
end;

procedure TFhirContractLegalList.SetItemN(index: Integer; value: TFhirContractLegal);
begin
  assert(value is TFhirContractLegal);
  ObjectByIndex[index] := value;
end;

{ TFhirContractRule }

constructor TFhirContractRule.Create;
begin
  inherited;
end;

destructor TFhirContractRule.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirContractRule.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirContractRule(oSource).content.Clone;
end;

procedure TFhirContractRule.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirContractRule.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'Attachment|Reference(DocumentReference)', false, TFhirType, FContent.Link));{2}
end;

function TFhirContractRule.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractRule.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractRule.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractRule.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractRule.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirContractRule.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractRule.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractRule.fhirType : string;
begin
  result := 'rule';
end;

function TFhirContractRule.Link : TFhirContractRule;
begin
  result := TFhirContractRule(inherited Link);
end;

function TFhirContractRule.Clone : TFhirContractRule;
begin
  result := TFhirContractRule(inherited Clone);
end;

function TFhirContractRule.equals(other : TObject) : boolean; 
var
  o : TFhirContractRule;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractRule)) then
    result := false
  else
  begin
    o := TFhirContractRule(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirContractRule.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirContractRule.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('content[x]');
end;

{ TFhirContractRule }

Procedure TFhirContractRule.SetContent(value : TFhirType);
begin
  FContent.free;
  FContent := value;
end;

function TFhirContractRule.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContent.sizeInBytes);
end;

{ TFhirContractRuleListEnumerator }

Constructor TFhirContractRuleListEnumerator.Create(list : TFhirContractRuleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractRuleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractRuleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractRuleListEnumerator.GetCurrent : TFhirContractRule;
begin
  Result := FList[FIndex];
end;

function TFhirContractRuleListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractRuleList }
procedure TFhirContractRuleList.AddItem(value: TFhirContractRule);
begin
  assert(value.ClassName = 'TFhirContractRule', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractRule');
  add(value);
end;

function TFhirContractRuleList.Append: TFhirContractRule;
begin
  result := TFhirContractRule.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractRuleList.ClearItems;
begin
  Clear;
end;

function TFhirContractRuleList.GetEnumerator : TFhirContractRuleListEnumerator;
begin
  result := TFhirContractRuleListEnumerator.Create(self.link);
end;

function TFhirContractRuleList.Clone: TFhirContractRuleList;
begin
  result := TFhirContractRuleList(inherited Clone);
end;

function TFhirContractRuleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractRuleList.GetItemN(index: Integer): TFhirContractRule;
begin
  result := TFhirContractRule(ObjectByIndex[index]);
end;

function TFhirContractRuleList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractRule;
end;
function TFhirContractRuleList.IndexOf(value: TFhirContractRule): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractRuleList.Insert(index: Integer): TFhirContractRule;
begin
  result := TFhirContractRule.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractRuleList.InsertItem(index: Integer; value: TFhirContractRule);
begin
  assert(value is TFhirContractRule);
  Inherited Insert(index, value);
end;

function TFhirContractRuleList.Item(index: Integer): TFhirContractRule;
begin
  result := TFhirContractRule(ObjectByIndex[index]);
end;

function TFhirContractRuleList.Link: TFhirContractRuleList;
begin
  result := TFhirContractRuleList(inherited Link);
end;

procedure TFhirContractRuleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractRuleList.SetItemByIndex(index: Integer; value: TFhirContractRule);
begin
  assert(value is TFhirContractRule);
  FhirContractRules[index] := value;
end;

procedure TFhirContractRuleList.SetItemN(index: Integer; value: TFhirContractRule);
begin
  assert(value is TFhirContractRule);
  ObjectByIndex[index] := value;
end;

{ TFhirContract }

constructor TFhirContract.Create;
begin
  inherited;
end;

destructor TFhirContract.Destroy;
begin
  FIdentifierList.Free;
  FUrl.free;
  FVersion.free;
  FStatus.free;
  FLegalState.free;
  FInstantiatesCanonical.free;
  FInstantiatesUri.free;
  FContentDerivative.free;
  FIssued.free;
  FApplies.free;
  FExpirationType.free;
  FSubjectList.Free;
  FAuthorityList.Free;
  FDomainList.Free;
  FSiteList.Free;
  FName.free;
  FTitle.free;
  FSubtitle.free;
  FAliasList.Free;
  FAuthor.free;
  FScope.free;
  FTopic.free;
  FType_.free;
  FSubTypeList.Free;
  FContentDefinition.free;
  FTermList.Free;
  FSupportingInfoList.Free;
  FRelevantHistoryList.Free;
  FSignerList.Free;
  FFriendlyList.Free;
  FLegalList.Free;
  FRuleList.Free;
  FLegallyBinding.free;
  inherited;
end;

function TFhirContract.GetResourceType : TFhirResourceType;
begin
  result := frtContract;
end;

procedure TFhirContract.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirContract(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirContract(oSource).FIdentifierList);
  end;
  urlElement := TFhirContract(oSource).urlElement.Clone;
  versionElement := TFhirContract(oSource).versionElement.Clone;
  FStatus := TFhirContract(oSource).FStatus.Link;
  legalState := TFhirContract(oSource).legalState.Clone;
  instantiatesCanonical := TFhirContract(oSource).instantiatesCanonical.Clone;
  instantiatesUriElement := TFhirContract(oSource).instantiatesUriElement.Clone;
  contentDerivative := TFhirContract(oSource).contentDerivative.Clone;
  issuedElement := TFhirContract(oSource).issuedElement.Clone;
  applies := TFhirContract(oSource).applies.Clone;
  expirationType := TFhirContract(oSource).expirationType.Clone;
  if (TFhirContract(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirReferenceList{TFhirReference}.Create;
    FSubjectList.Assign(TFhirContract(oSource).FSubjectList);
  end;
  if (TFhirContract(oSource).FAuthorityList = nil) then
  begin
    FAuthorityList.free;
    FAuthorityList := nil;
  end
  else
  begin
    if FAuthorityList = nil then
      FAuthorityList := TFhirReferenceList{TFhirOrganization}.Create;
    FAuthorityList.Assign(TFhirContract(oSource).FAuthorityList);
  end;
  if (TFhirContract(oSource).FDomainList = nil) then
  begin
    FDomainList.free;
    FDomainList := nil;
  end
  else
  begin
    if FDomainList = nil then
      FDomainList := TFhirReferenceList{TFhirLocation}.Create;
    FDomainList.Assign(TFhirContract(oSource).FDomainList);
  end;
  if (TFhirContract(oSource).FSiteList = nil) then
  begin
    FSiteList.free;
    FSiteList := nil;
  end
  else
  begin
    if FSiteList = nil then
      FSiteList := TFhirReferenceList{TFhirLocation}.Create;
    FSiteList.Assign(TFhirContract(oSource).FSiteList);
  end;
  nameElement := TFhirContract(oSource).nameElement.Clone;
  titleElement := TFhirContract(oSource).titleElement.Clone;
  subtitleElement := TFhirContract(oSource).subtitleElement.Clone;
  if (TFhirContract(oSource).FAliasList = nil) then
  begin
    FAliasList.free;
    FAliasList := nil;
  end
  else
  begin
    if FAliasList = nil then
      FAliasList := TFhirStringList.Create;
    FAliasList.Assign(TFhirContract(oSource).FAliasList);
  end;
  author := TFhirContract(oSource).author.Clone;
  scope := TFhirContract(oSource).scope.Clone;
  topic := TFhirContract(oSource).topic.Clone;
  type_ := TFhirContract(oSource).type_.Clone;
  if (TFhirContract(oSource).FSubTypeList = nil) then
  begin
    FSubTypeList.free;
    FSubTypeList := nil;
  end
  else
  begin
    if FSubTypeList = nil then
      FSubTypeList := TFhirCodeableConceptList.Create;
    FSubTypeList.Assign(TFhirContract(oSource).FSubTypeList);
  end;
  contentDefinition := TFhirContract(oSource).contentDefinition.Clone;
  if (TFhirContract(oSource).FTermList = nil) then
  begin
    FTermList.free;
    FTermList := nil;
  end
  else
  begin
    if FTermList = nil then
      FTermList := TFhirContractTermList.Create;
    FTermList.Assign(TFhirContract(oSource).FTermList);
  end;
  if (TFhirContract(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirReferenceList{TFhirReference}.Create;
    FSupportingInfoList.Assign(TFhirContract(oSource).FSupportingInfoList);
  end;
  if (TFhirContract(oSource).FRelevantHistoryList = nil) then
  begin
    FRelevantHistoryList.free;
    FRelevantHistoryList := nil;
  end
  else
  begin
    if FRelevantHistoryList = nil then
      FRelevantHistoryList := TFhirReferenceList{TFhirProvenance}.Create;
    FRelevantHistoryList.Assign(TFhirContract(oSource).FRelevantHistoryList);
  end;
  if (TFhirContract(oSource).FSignerList = nil) then
  begin
    FSignerList.free;
    FSignerList := nil;
  end
  else
  begin
    if FSignerList = nil then
      FSignerList := TFhirContractSignerList.Create;
    FSignerList.Assign(TFhirContract(oSource).FSignerList);
  end;
  if (TFhirContract(oSource).FFriendlyList = nil) then
  begin
    FFriendlyList.free;
    FFriendlyList := nil;
  end
  else
  begin
    if FFriendlyList = nil then
      FFriendlyList := TFhirContractFriendlyList.Create;
    FFriendlyList.Assign(TFhirContract(oSource).FFriendlyList);
  end;
  if (TFhirContract(oSource).FLegalList = nil) then
  begin
    FLegalList.free;
    FLegalList := nil;
  end
  else
  begin
    if FLegalList = nil then
      FLegalList := TFhirContractLegalList.Create;
    FLegalList.Assign(TFhirContract(oSource).FLegalList);
  end;
  if (TFhirContract(oSource).FRuleList = nil) then
  begin
    FRuleList.free;
    FRuleList := nil;
  end
  else
  begin
    if FRuleList = nil then
      FRuleList := TFhirContractRuleList.Create;
    FRuleList.Assign(TFhirContract(oSource).FRuleList);
  end;
  legallyBinding := TFhirContract(oSource).legallyBinding.Clone;
end;

procedure TFhirContract.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'legalState') Then
     list.add(self.link, 'legalState', FLegalState.Link);
  if (child_name = 'instantiatesCanonical') Then
     list.add(self.link, 'instantiatesCanonical', FInstantiatesCanonical.Link);
  if (child_name = 'instantiatesUri') Then
     list.add(self.link, 'instantiatesUri', FInstantiatesUri.Link);
  if (child_name = 'contentDerivative') Then
     list.add(self.link, 'contentDerivative', FContentDerivative.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'applies') Then
     list.add(self.link, 'applies', FApplies.Link);
  if (child_name = 'expirationType') Then
     list.add(self.link, 'expirationType', FExpirationType.Link);
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'authority') Then
    list.addAll(self, 'authority', FAuthorityList);
  if (child_name = 'domain') Then
    list.addAll(self, 'domain', FDomainList);
  if (child_name = 'site') Then
    list.addAll(self, 'site', FSiteList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'subtitle') Then
     list.add(self.link, 'subtitle', FSubtitle.Link);
  if (child_name = 'alias') Then
    list.addAll(self, 'alias', FAliasList);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'scope') Then
     list.add(self.link, 'scope', FScope.Link);
  if (child_name = 'topic[x]') or (child_name = 'topic') Then
     list.add(self.link, 'topic[x]', FTopic.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
    list.addAll(self, 'subType', FSubTypeList);
  if (child_name = 'contentDefinition') Then
     list.add(self.link, 'contentDefinition', FContentDefinition.Link);
  if (child_name = 'term') Then
    list.addAll(self, 'term', FTermList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'relevantHistory') Then
    list.addAll(self, 'relevantHistory', FRelevantHistoryList);
  if (child_name = 'signer') Then
    list.addAll(self, 'signer', FSignerList);
  if (child_name = 'friendly') Then
    list.addAll(self, 'friendly', FFriendlyList);
  if (child_name = 'legal') Then
    list.addAll(self, 'legal', FLegalList);
  if (child_name = 'rule') Then
    list.addAll(self, 'rule', FRuleList);
  if (child_name = 'legallyBinding[x]') or (child_name = 'legallyBinding') Then
     list.add(self.link, 'legallyBinding[x]', FLegallyBinding.Link);
end;

procedure TFhirContract.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'legalState', 'CodeableConcept', false, TFhirCodeableConcept, FLegalState.Link));{2}
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'Reference(Contract)', false, TFhirReference{TFhirContract}, FInstantiatesCanonical.Link));{2}
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', false, TFhirUri, FInstantiatesUri.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contentDerivative', 'CodeableConcept', false, TFhirCodeableConcept, FContentDerivative.Link));{2}
  oList.add(TFHIRProperty.create(self, 'issued', 'dateTime', false, TFhirDateTime, FIssued.Link));{2}
  oList.add(TFHIRProperty.create(self, 'applies', 'Period', false, TFhirPeriod, FApplies.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expirationType', 'CodeableConcept', false, TFhirCodeableConcept, FExpirationType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Any)', true, TFhirReference{TFhirReference}, FSubjectList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'authority', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FAuthorityList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'domain', 'Reference(Location)', true, TFhirReference{TFhirLocation}, FDomainList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'site', 'Reference(Location)', true, TFhirReference{TFhirLocation}, FSiteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subtitle', 'string', false, TFhirString, FSubtitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'alias', 'string', true, TFhirString, FAliasList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FAuthor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'scope', 'CodeableConcept', false, TFhirCodeableConcept, FScope.Link));{2}
  oList.add(TFHIRProperty.create(self, 'topic[x]', 'CodeableConcept|Reference(Any)', false, TFhirType, FTopic.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', true, TFhirCodeableConcept, FSubTypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'contentDefinition', '', false, TFhirContractContentDefinition, FContentDefinition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'term', '', true, TFhirContractTerm, FTermList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'Reference(Any)', true, TFhirReference{TFhirReference}, FSupportingInfoList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relevantHistory', 'Reference(Provenance)', true, TFhirReference{TFhirProvenance}, FRelevantHistoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'signer', '', true, TFhirContractSigner, FSignerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'friendly', '', true, TFhirContractFriendly, FFriendlyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'legal', '', true, TFhirContractLegal, FLegalList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'rule', '', true, TFhirContractRule, FRuleList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'legallyBinding[x]', 'Attachment|Reference(Composition)', false, TFhirType, FLegallyBinding.Link));{2}
end;

function TFhirContract.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirContractStatusEnum, CODES_TFhirContractStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'legalState') then
  begin
    LegalState := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonical := propValue as TFhirReference{TFhirContract}{4b};
    result := propValue;
  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contentDerivative') then
  begin
    ContentDerivative := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'applies') then
  begin
    Applies := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'expirationType') then
  begin
    ExpirationType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'authority') then
  begin
    AuthorityList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else if (propName = 'domain') then
  begin
    DomainList.add(propValue as TFhirReference{TFhirLocation}){2a};
    result := propValue;
  end
  else if (propName = 'site') then
  begin
    SiteList.add(propValue as TFhirReference{TFhirLocation}){2a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subtitle') then
  begin
    SubtitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'alias') then
  begin
    AliasList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'scope') then
  begin
    Scope := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then
  begin
    Topic := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubTypeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'contentDefinition') then
  begin
    ContentDefinition := propValue as TFhirContractContentDefinition{4b};
    result := propValue;
  end
  else if (propName = 'term') then
  begin
    TermList.add(propValue as TFhirContractTerm){2a};
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'relevantHistory') then
  begin
    RelevantHistoryList.add(propValue as TFhirReference{TFhirProvenance}){2a};
    result := propValue;
  end
  else if (propName = 'signer') then
  begin
    SignerList.add(propValue as TFhirContractSigner){2a};
    result := propValue;
  end
  else if (propName = 'friendly') then
  begin
    FriendlyList.add(propValue as TFhirContractFriendly){2a};
    result := propValue;
  end
  else if (propName = 'legal') then
  begin
    LegalList.add(propValue as TFhirContractLegal){2a};
    result := propValue;
  end
  else if (propName = 'rule') then
  begin
    RuleList.add(propValue as TFhirContractRule){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'legallyBinding', ['Attachment', 'Reference'])) then
  begin
    LegallyBinding := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirContract.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'authority') then AuthorityList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else if (propName = 'domain') then DomainList.insertItem(index, propValue as TFhirReference{TFhirLocation}){2a}
  else if (propName = 'site') then SiteList.insertItem(index, propValue as TFhirReference{TFhirLocation}){2a}
  else if (propName = 'alias') then AliasList.insertItem(index, asString(propValue)){2}
  else if (propName = 'subType') then SubTypeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'term') then TermList.insertItem(index, propValue as TFhirContractTerm){2a}
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'relevantHistory') then RelevantHistoryList.insertItem(index, propValue as TFhirReference{TFhirProvenance}){2a}
  else if (propName = 'signer') then SignerList.insertItem(index, propValue as TFhirContractSigner){2a}
  else if (propName = 'friendly') then FriendlyList.insertItem(index, propValue as TFhirContractFriendly){2a}
  else if (propName = 'legal') then LegalList.insertItem(index, propValue as TFhirContractLegal){2a}
  else if (propName = 'rule') then RuleList.insertItem(index, propValue as TFhirContractRule){2a}
  else inherited;
end;

function TFhirContract.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'legalState') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'instantiatesCanonical') then result := TFhirReference{TFhirContract}.create(){4b}
  else if (propName = 'instantiatesUri') then result := TFhirUri.create() {5b}
  else if (propName = 'contentDerivative') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'issued') then result := TFhirDateTime.create() {5b}
  else if (propName = 'applies') then result := TFhirPeriod.create(){4b}
  else if (propName = 'expirationType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := SubjectList.new(){2}
  else if (propName = 'authority') then result := AuthorityList.new(){2}
  else if (propName = 'domain') then result := DomainList.new(){2}
  else if (propName = 'site') then result := SiteList.new(){2}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'title') then result := TFhirString.create() {5b}
  else if (propName = 'subtitle') then result := TFhirString.create() {5b}
  else if (propName = 'alias') then result := AliasList.new(){2}
  else if (propName = 'author') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'scope') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Topic'){4x}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subType') then result := SubTypeList.new(){2}
  else if (propName = 'contentDefinition') then result := TFhirContractContentDefinition.create(){4b}
  else if (propName = 'term') then result := TermList.new(){2}
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new(){2}
  else if (propName = 'relevantHistory') then result := RelevantHistoryList.new(){2}
  else if (propName = 'signer') then result := SignerList.new(){2}
  else if (propName = 'friendly') then result := FriendlyList.new(){2}
  else if (propName = 'legal') then result := LegalList.new(){2}
  else if (propName = 'rule') then result := RuleList.new(){2}
  else if (isMatchingName(propName, 'legallyBinding', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property LegallyBinding'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContract.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'legalState') then result := 'CodeableConcept'
  else if (propName = 'instantiatesCanonical') then result := 'Reference'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'contentDerivative') then result := 'CodeableConcept'
  else if (propName = 'issued') then result := 'dateTime'
  else if (propName = 'applies') then result := 'Period'
  else if (propName = 'expirationType') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'authority') then result := 'Reference'
  else if (propName = 'domain') then result := 'Reference'
  else if (propName = 'site') then result := 'Reference'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'subtitle') then result := 'string'
  else if (propName = 'alias') then result := 'string'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'scope') then result := 'CodeableConcept'
  else if (propName = 'topic[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'contentDefinition') then result := ''
  else if (propName = 'term') then result := ''
  else if (propName = 'supportingInfo') then result := 'Reference'
  else if (propName = 'relevantHistory') then result := 'Reference'
  else if (propName = 'signer') then result := ''
  else if (propName = 'friendly') then result := ''
  else if (propName = 'legal') then result := ''
  else if (propName = 'rule') then result := ''
  else if (propName = 'legallyBinding[x]') then result := 'Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContract.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'legalState') then LegalStateElement := nil
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalElement := nil
  else if (propName = 'instantiatesUri') then InstantiatesUriElement := nil
  else if (propName = 'contentDerivative') then ContentDerivativeElement := nil
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'applies') then AppliesElement := nil
  else if (propName = 'expirationType') then ExpirationTypeElement := nil
  else if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value) {2}
  else if (propName = 'authority') then deletePropertyValue('authority', AuthorityList, value) {2}
  else if (propName = 'domain') then deletePropertyValue('domain', DomainList, value) {2}
  else if (propName = 'site') then deletePropertyValue('site', SiteList, value) {2}
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'subtitle') then SubtitleElement := nil
  else if (propName = 'alias') then deletePropertyValue('alias', AliasList, value) {2}
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'scope') then ScopeElement := nil
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then TopicElement := nil{4x}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then deletePropertyValue('subType', SubTypeList, value) {2}
  else if (propName = 'contentDefinition') then ContentDefinitionElement := nil
  else if (propName = 'term') then deletePropertyValue('term', TermList, value) {2}
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value) {2}
  else if (propName = 'relevantHistory') then deletePropertyValue('relevantHistory', RelevantHistoryList, value) {2}
  else if (propName = 'signer') then deletePropertyValue('signer', SignerList, value) {2}
  else if (propName = 'friendly') then deletePropertyValue('friendly', FriendlyList, value) {2}
  else if (propName = 'legal') then deletePropertyValue('legal', LegalList, value) {2}
  else if (propName = 'rule') then deletePropertyValue('rule', RuleList, value) {2}
  else if (isMatchingName(propName, 'legallyBinding', ['Attachment', 'Reference'])) then LegallyBindingElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContract.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirContractStatusEnum, CODES_TFhirContractStatusEnum, new){4}
  else if (propName = 'legalState') then LegalStateElement := new as TFhirCodeableConcept{4}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalElement := new as TFhirReference{TFhirContract}{4}
  else if (propName = 'instantiatesUri') then InstantiatesUriElement := asUri(new){5b}
  else if (propName = 'contentDerivative') then ContentDerivativeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'issued') then IssuedElement := asDateTime(new){5b}
  else if (propName = 'applies') then AppliesElement := new as TFhirPeriod{4}
  else if (propName = 'expirationType') then ExpirationTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new) {2}
  else if (propName = 'authority') then replacePropertyValue('authority', AuthorityList, existing, new) {2}
  else if (propName = 'domain') then replacePropertyValue('domain', DomainList, existing, new) {2}
  else if (propName = 'site') then replacePropertyValue('site', SiteList, existing, new) {2}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'title') then TitleElement := asString(new){5b}
  else if (propName = 'subtitle') then SubtitleElement := asString(new){5b}
  else if (propName = 'alias') then replacePropertyValue('alias', AliasList, existing, new) {2}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'scope') then ScopeElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then TopicElement := new as TFhirType{4x}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'subType') then replacePropertyValue('subType', SubTypeList, existing, new) {2}
  else if (propName = 'contentDefinition') then ContentDefinitionElement := new as TFhirContractContentDefinition{4}
  else if (propName = 'term') then replacePropertyValue('term', TermList, existing, new) {2}
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new) {2}
  else if (propName = 'relevantHistory') then replacePropertyValue('relevantHistory', RelevantHistoryList, existing, new) {2}
  else if (propName = 'signer') then replacePropertyValue('signer', SignerList, existing, new) {2}
  else if (propName = 'friendly') then replacePropertyValue('friendly', FriendlyList, existing, new) {2}
  else if (propName = 'legal') then replacePropertyValue('legal', LegalList, existing, new) {2}
  else if (propName = 'rule') then replacePropertyValue('rule', RuleList, existing, new) {2}
  else if (isMatchingName(propName, 'legallyBinding', ['Attachment', 'Reference'])) then LegallyBindingElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContract.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'subject') then SubjectList.move(source, destination){2a}
  else if (propName = 'authority') then AuthorityList.move(source, destination){2a}
  else if (propName = 'domain') then DomainList.move(source, destination){2a}
  else if (propName = 'site') then SiteList.move(source, destination){2a}
  else if (propName = 'alias') then AliasList.move(source, destination){2}
  else if (propName = 'subType') then SubTypeList.move(source, destination){2a}
  else if (propName = 'term') then TermList.move(source, destination){2a}
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination){2a}
  else if (propName = 'relevantHistory') then RelevantHistoryList.move(source, destination){2a}
  else if (propName = 'signer') then SignerList.move(source, destination){2a}
  else if (propName = 'friendly') then FriendlyList.move(source, destination){2a}
  else if (propName = 'legal') then LegalList.move(source, destination){2a}
  else if (propName = 'rule') then RuleList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContract.fhirType : string;
begin
  result := 'Contract';
end;

function TFhirContract.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FUrl) and isEmptyProp(FVersion) and isEmptyProp(FStatus) and isEmptyProp(FLegalState) and isEmptyProp(FInstantiatesCanonical) and isEmptyProp(FInstantiatesUri) and isEmptyProp(FContentDerivative) and isEmptyProp(FIssued) and isEmptyProp(FApplies) and isEmptyProp(FExpirationType) and isEmptyProp(FsubjectList) and isEmptyProp(FauthorityList) and isEmptyProp(FdomainList) and isEmptyProp(FsiteList) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FSubtitle) and isEmptyProp(FaliasList) and isEmptyProp(FAuthor) and isEmptyProp(FScope) and isEmptyProp(FTopic) and isEmptyProp(FType_) and isEmptyProp(FsubTypeList) and isEmptyProp(FContentDefinition) and isEmptyProp(FtermList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FrelevantHistoryList) and isEmptyProp(FsignerList) and isEmptyProp(FfriendlyList) and isEmptyProp(FlegalList) and isEmptyProp(FruleList) and isEmptyProp(FLegallyBinding);
end;

function TFhirContract.equals(other : TObject) : boolean; 
var
  o : TFhirContract;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContract)) then
    result := false
  else
  begin
    o := TFhirContract(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(urlElement, o.urlElement, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(legalStateElement, o.legalStateElement, true) and compareDeep(instantiatesCanonicalElement, o.instantiatesCanonicalElement, true) and 
      compareDeep(instantiatesUriElement, o.instantiatesUriElement, true) and compareDeep(contentDerivativeElement, o.contentDerivativeElement, true) and 
      compareDeep(issuedElement, o.issuedElement, true) and compareDeep(appliesElement, o.appliesElement, true) and 
      compareDeep(expirationTypeElement, o.expirationTypeElement, true) and compareDeep(subjectList, o.subjectList, true) and 
      compareDeep(authorityList, o.authorityList, true) and compareDeep(domainList, o.domainList, true) and 
      compareDeep(siteList, o.siteList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(subtitleElement, o.subtitleElement, true) and 
      compareDeep(aliasList, o.aliasList, true) and compareDeep(authorElement, o.authorElement, true) and 
      compareDeep(scopeElement, o.scopeElement, true) and compareDeep(topicElement, o.topicElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeList, o.subTypeList, true) and 
      compareDeep(contentDefinitionElement, o.contentDefinitionElement, true) and compareDeep(termList, o.termList, true) and 
      compareDeep(supportingInfoList, o.supportingInfoList, true) and compareDeep(relevantHistoryList, o.relevantHistoryList, true) and 
      compareDeep(signerList, o.signerList, true) and compareDeep(friendlyList, o.friendlyList, true) and 
      compareDeep(legalList, o.legalList, true) and compareDeep(ruleList, o.ruleList, true) and 
      compareDeep(legallyBindingElement, o.legallyBindingElement, true);
  end;
end;

function TFhirContract.Link : TFhirContract;
begin
  result := TFhirContract(inherited Link);
end;

function TFhirContract.Clone : TFhirContract;
begin
  result := TFhirContract(inherited Clone);
end;

procedure TFhirContract.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('url');
  fields.add('version');
  fields.add('status');
  fields.add('legalState');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('contentDerivative');
  fields.add('issued');
  fields.add('applies');
  fields.add('expirationType');
  fields.add('subject');
  fields.add('authority');
  fields.add('domain');
  fields.add('site');
  fields.add('name');
  fields.add('title');
  fields.add('subtitle');
  fields.add('alias');
  fields.add('author');
  fields.add('scope');
  fields.add('topic[x]');
  fields.add('type');
  fields.add('subType');
  fields.add('contentDefinition');
  fields.add('term');
  fields.add('supportingInfo');
  fields.add('relevantHistory');
  fields.add('signer');
  fields.add('friendly');
  fields.add('legal');
  fields.add('rule');
  fields.add('legallyBinding[x]');
end;

{ TFhirContract }

Function TFhirContract.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirContract.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirContract.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirContract.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirContract.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirContract.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirContract.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirContract.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirContract.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirContract.GetStatusST : TFhirContractStatusEnum;
begin
  if FStatus = nil then
    result := TFhirContractStatusEnum(0)
  else
    result := TFhirContractStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirContractStatusEnum, FStatus.value));
end;

Procedure TFhirContract.SetStatusST(value : TFhirContractStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirContractStatusEnum[value], CODES_TFhirContractStatusEnum[value]);
end;

Procedure TFhirContract.SetLegalState(value : TFhirCodeableConcept);
begin
  FLegalState.free;
  FLegalState := value;
end;

Procedure TFhirContract.SetInstantiatesCanonical(value : TFhirReference{TFhirContract});
begin
  FInstantiatesCanonical.free;
  FInstantiatesCanonical := value;
end;

Procedure TFhirContract.SetInstantiatesUri(value : TFhirUri);
begin
  FInstantiatesUri.free;
  FInstantiatesUri := value;
end;

Function TFhirContract.GetInstantiatesUriST : String;
begin
  if FInstantiatesUri = nil then
    result := ''
  else
    result := FInstantiatesUri.value;
end;

Procedure TFhirContract.SetInstantiatesUriST(value : String);
begin
  if value <> '' then
  begin
    if FInstantiatesUri = nil then
      FInstantiatesUri := TFhirUri.create;
    FInstantiatesUri.value := value
  end
  else if FInstantiatesUri <> nil then
    FInstantiatesUri.value := '';
end;

Procedure TFhirContract.SetContentDerivative(value : TFhirCodeableConcept);
begin
  FContentDerivative.free;
  FContentDerivative := value;
end;

Procedure TFhirContract.SetIssued(value : TFhirDateTime);
begin
  FIssued.free;
  FIssued := value;
end;

Function TFhirContract.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

Procedure TFhirContract.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirDateTime.create;
  FIssued.value := value
end;

Procedure TFhirContract.SetApplies(value : TFhirPeriod);
begin
  FApplies.free;
  FApplies := value;
end;

Procedure TFhirContract.SetExpirationType(value : TFhirCodeableConcept);
begin
  FExpirationType.free;
  FExpirationType := value;
end;

Function TFhirContract.GetSubjectList : TFhirReferenceList{TFhirReference};
begin
  if FSubjectList = nil then
    FSubjectList := TFhirReferenceList{TFhirReference}.Create;
  result := FSubjectList;
end;

Function TFhirContract.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

Function TFhirContract.GetAuthorityList : TFhirReferenceList{TFhirOrganization};
begin
  if FAuthorityList = nil then
    FAuthorityList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FAuthorityList;
end;

Function TFhirContract.GetHasAuthorityList : boolean;
begin
  result := (FAuthorityList <> nil) and (FAuthorityList.count > 0);
end;

Function TFhirContract.GetDomainList : TFhirReferenceList{TFhirLocation};
begin
  if FDomainList = nil then
    FDomainList := TFhirReferenceList{TFhirLocation}.Create;
  result := FDomainList;
end;

Function TFhirContract.GetHasDomainList : boolean;
begin
  result := (FDomainList <> nil) and (FDomainList.count > 0);
end;

Function TFhirContract.GetSiteList : TFhirReferenceList{TFhirLocation};
begin
  if FSiteList = nil then
    FSiteList := TFhirReferenceList{TFhirLocation}.Create;
  result := FSiteList;
end;

Function TFhirContract.GetHasSiteList : boolean;
begin
  result := (FSiteList <> nil) and (FSiteList.count > 0);
end;

Procedure TFhirContract.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirContract.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirContract.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirContract.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirContract.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirContract.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirContract.SetSubtitle(value : TFhirString);
begin
  FSubtitle.free;
  FSubtitle := value;
end;

Function TFhirContract.GetSubtitleST : String;
begin
  if FSubtitle = nil then
    result := ''
  else
    result := FSubtitle.value;
end;

Procedure TFhirContract.SetSubtitleST(value : String);
begin
  if value <> '' then
  begin
    if FSubtitle = nil then
      FSubtitle := TFhirString.create;
    FSubtitle.value := value
  end
  else if FSubtitle <> nil then
    FSubtitle.value := '';
end;

Function TFhirContract.GetAliasList : TFhirStringList;
begin
  if FAliasList = nil then
    FAliasList := TFhirStringList.Create;
  result := FAliasList;
end;

Function TFhirContract.GetHasAliasList : boolean;
begin
  result := (FAliasList <> nil) and (FAliasList.count > 0);
end;

Procedure TFhirContract.SetAuthor(value : TFhirReference{TFhirPatient});
begin
  FAuthor.free;
  FAuthor := value;
end;

Procedure TFhirContract.SetScope(value : TFhirCodeableConcept);
begin
  FScope.free;
  FScope := value;
end;

Procedure TFhirContract.SetTopic(value : TFhirType);
begin
  FTopic.free;
  FTopic := value;
end;

Procedure TFhirContract.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirContract.GetSubTypeList : TFhirCodeableConceptList;
begin
  if FSubTypeList = nil then
    FSubTypeList := TFhirCodeableConceptList.Create;
  result := FSubTypeList;
end;

Function TFhirContract.GetHasSubTypeList : boolean;
begin
  result := (FSubTypeList <> nil) and (FSubTypeList.count > 0);
end;

Procedure TFhirContract.SetContentDefinition(value : TFhirContractContentDefinition);
begin
  FContentDefinition.free;
  FContentDefinition := value;
end;

Function TFhirContract.GetTermList : TFhirContractTermList;
begin
  if FTermList = nil then
    FTermList := TFhirContractTermList.Create;
  result := FTermList;
end;

Function TFhirContract.GetHasTermList : boolean;
begin
  result := (FTermList <> nil) and (FTermList.count > 0);
end;

Function TFhirContract.GetSupportingInfoList : TFhirReferenceList{TFhirReference};
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirReferenceList{TFhirReference}.Create;
  result := FSupportingInfoList;
end;

Function TFhirContract.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

Function TFhirContract.GetRelevantHistoryList : TFhirReferenceList{TFhirProvenance};
begin
  if FRelevantHistoryList = nil then
    FRelevantHistoryList := TFhirReferenceList{TFhirProvenance}.Create;
  result := FRelevantHistoryList;
end;

Function TFhirContract.GetHasRelevantHistoryList : boolean;
begin
  result := (FRelevantHistoryList <> nil) and (FRelevantHistoryList.count > 0);
end;

Function TFhirContract.GetSignerList : TFhirContractSignerList;
begin
  if FSignerList = nil then
    FSignerList := TFhirContractSignerList.Create;
  result := FSignerList;
end;

Function TFhirContract.GetHasSignerList : boolean;
begin
  result := (FSignerList <> nil) and (FSignerList.count > 0);
end;

Function TFhirContract.GetFriendlyList : TFhirContractFriendlyList;
begin
  if FFriendlyList = nil then
    FFriendlyList := TFhirContractFriendlyList.Create;
  result := FFriendlyList;
end;

Function TFhirContract.GetHasFriendlyList : boolean;
begin
  result := (FFriendlyList <> nil) and (FFriendlyList.count > 0);
end;

Function TFhirContract.GetLegalList : TFhirContractLegalList;
begin
  if FLegalList = nil then
    FLegalList := TFhirContractLegalList.Create;
  result := FLegalList;
end;

Function TFhirContract.GetHasLegalList : boolean;
begin
  result := (FLegalList <> nil) and (FLegalList.count > 0);
end;

Function TFhirContract.GetRuleList : TFhirContractRuleList;
begin
  if FRuleList = nil then
    FRuleList := TFhirContractRuleList.Create;
  result := FRuleList;
end;

Function TFhirContract.GetHasRuleList : boolean;
begin
  result := (FRuleList <> nil) and (FRuleList.count > 0);
end;

Procedure TFhirContract.SetLegallyBinding(value : TFhirType);
begin
  FLegallyBinding.free;
  FLegallyBinding := value;
end;

function TFhirContract.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FLegalState.sizeInBytes);
  inc(result, FInstantiatesCanonical.sizeInBytes);
  inc(result, FInstantiatesUri.sizeInBytes);
  inc(result, FContentDerivative.sizeInBytes);
  inc(result, FIssued.sizeInBytes);
  inc(result, FApplies.sizeInBytes);
  inc(result, FExpirationType.sizeInBytes);
  inc(result, FsubjectList.sizeInBytes);
  inc(result, FauthorityList.sizeInBytes);
  inc(result, FdomainList.sizeInBytes);
  inc(result, FsiteList.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
  inc(result, FSubtitle.sizeInBytes);
  inc(result, FaliasList.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
  inc(result, FScope.sizeInBytes);
  inc(result, FTopic.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FsubTypeList.sizeInBytes);
  inc(result, FContentDefinition.sizeInBytes);
  inc(result, FtermList.sizeInBytes);
  inc(result, FsupportingInfoList.sizeInBytes);
  inc(result, FrelevantHistoryList.sizeInBytes);
  inc(result, FsignerList.sizeInBytes);
  inc(result, FfriendlyList.sizeInBytes);
  inc(result, FlegalList.sizeInBytes);
  inc(result, FruleList.sizeInBytes);
  inc(result, FLegallyBinding.sizeInBytes);
end;

{ TFhirContractListEnumerator }

Constructor TFhirContractListEnumerator.Create(list : TFhirContractList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractListEnumerator.GetCurrent : TFhirContract;
begin
  Result := FList[FIndex];
end;

function TFhirContractListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContractList }
procedure TFhirContractList.AddItem(value: TFhirContract);
begin
  assert(value.ClassName = 'TFhirContract', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContract');
  add(value);
end;

function TFhirContractList.Append: TFhirContract;
begin
  result := TFhirContract.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractList.ClearItems;
begin
  Clear;
end;

function TFhirContractList.GetEnumerator : TFhirContractListEnumerator;
begin
  result := TFhirContractListEnumerator.Create(self.link);
end;

function TFhirContractList.Clone: TFhirContractList;
begin
  result := TFhirContractList(inherited Clone);
end;

function TFhirContractList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractList.GetItemN(index: Integer): TFhirContract;
begin
  result := TFhirContract(ObjectByIndex[index]);
end;

function TFhirContractList.ItemClass: TFslObjectClass;
begin
  result := TFhirContract;
end;
function TFhirContractList.IndexOf(value: TFhirContract): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractList.Insert(index: Integer): TFhirContract;
begin
  result := TFhirContract.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractList.InsertItem(index: Integer; value: TFhirContract);
begin
  assert(value is TFhirContract);
  Inherited Insert(index, value);
end;

function TFhirContractList.Item(index: Integer): TFhirContract;
begin
  result := TFhirContract(ObjectByIndex[index]);
end;

function TFhirContractList.Link: TFhirContractList;
begin
  result := TFhirContractList(inherited Link);
end;

procedure TFhirContractList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractList.SetItemByIndex(index: Integer; value: TFhirContract);
begin
  assert(value is TFhirContract);
  FhirContracts[index] := value;
end;

procedure TFhirContractList.SetItemN(index: Integer; value: TFhirContract);
begin
  assert(value is TFhirContract);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CONTRACT}

{$IFDEF FHIR_EFFECTEVIDENCESYNTHESIS}

{ TFhirEffectEvidenceSynthesisSampleSize }

constructor TFhirEffectEvidenceSynthesisSampleSize.Create;
begin
  inherited;
end;

destructor TFhirEffectEvidenceSynthesisSampleSize.Destroy;
begin
  FDescription.free;
  FNumberOfStudies.free;
  FNumberOfParticipants.free;
  inherited;
end;

procedure TFhirEffectEvidenceSynthesisSampleSize.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirEffectEvidenceSynthesisSampleSize(oSource).descriptionElement.Clone;
  numberOfStudiesElement := TFhirEffectEvidenceSynthesisSampleSize(oSource).numberOfStudiesElement.Clone;
  numberOfParticipantsElement := TFhirEffectEvidenceSynthesisSampleSize(oSource).numberOfParticipantsElement.Clone;
end;

procedure TFhirEffectEvidenceSynthesisSampleSize.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'numberOfStudies') Then
     list.add(self.link, 'numberOfStudies', FNumberOfStudies.Link);
  if (child_name = 'numberOfParticipants') Then
     list.add(self.link, 'numberOfParticipants', FNumberOfParticipants.Link);
end;

procedure TFhirEffectEvidenceSynthesisSampleSize.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'numberOfStudies', 'integer', false, TFhirInteger, FNumberOfStudies.Link));{2}
  oList.add(TFHIRProperty.create(self, 'numberOfParticipants', 'integer', false, TFhirInteger, FNumberOfParticipants.Link));{2}
end;

function TFhirEffectEvidenceSynthesisSampleSize.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'numberOfStudies') then
  begin
    NumberOfStudiesElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'numberOfParticipants') then
  begin
    NumberOfParticipantsElement := asInteger(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEffectEvidenceSynthesisSampleSize.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEffectEvidenceSynthesisSampleSize.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'numberOfStudies') then result := TFhirInteger.create() {5b}
  else if (propName = 'numberOfParticipants') then result := TFhirInteger.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEffectEvidenceSynthesisSampleSize.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'numberOfStudies') then result := 'integer'
  else if (propName = 'numberOfParticipants') then result := 'integer'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEffectEvidenceSynthesisSampleSize.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'numberOfStudies') then NumberOfStudiesElement := nil
  else if (propName = 'numberOfParticipants') then NumberOfParticipantsElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEffectEvidenceSynthesisSampleSize.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'numberOfStudies') then NumberOfStudiesElement := asInteger(new){5b}
  else if (propName = 'numberOfParticipants') then NumberOfParticipantsElement := asInteger(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEffectEvidenceSynthesisSampleSize.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEffectEvidenceSynthesisSampleSize.fhirType : string;
begin
  result := 'sampleSize';
end;

function TFhirEffectEvidenceSynthesisSampleSize.Link : TFhirEffectEvidenceSynthesisSampleSize;
begin
  result := TFhirEffectEvidenceSynthesisSampleSize(inherited Link);
end;

function TFhirEffectEvidenceSynthesisSampleSize.Clone : TFhirEffectEvidenceSynthesisSampleSize;
begin
  result := TFhirEffectEvidenceSynthesisSampleSize(inherited Clone);
end;

function TFhirEffectEvidenceSynthesisSampleSize.equals(other : TObject) : boolean; 
var
  o : TFhirEffectEvidenceSynthesisSampleSize;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEffectEvidenceSynthesisSampleSize)) then
    result := false
  else
  begin
    o := TFhirEffectEvidenceSynthesisSampleSize(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(numberOfStudiesElement, o.numberOfStudiesElement, true) and 
      compareDeep(numberOfParticipantsElement, o.numberOfParticipantsElement, true);
  end;
end;

function TFhirEffectEvidenceSynthesisSampleSize.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FNumberOfStudies) and isEmptyProp(FNumberOfParticipants);
end;

procedure TFhirEffectEvidenceSynthesisSampleSize.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('numberOfStudies');
  fields.add('numberOfParticipants');
end;

{ TFhirEffectEvidenceSynthesisSampleSize }

Procedure TFhirEffectEvidenceSynthesisSampleSize.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirEffectEvidenceSynthesisSampleSize.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirEffectEvidenceSynthesisSampleSize.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirEffectEvidenceSynthesisSampleSize.SetNumberOfStudies(value : TFhirInteger);
begin
  FNumberOfStudies.free;
  FNumberOfStudies := value;
end;

Function TFhirEffectEvidenceSynthesisSampleSize.GetNumberOfStudiesST : String;
begin
  if FNumberOfStudies = nil then
    result := ''
  else
    result := FNumberOfStudies.value;
end;

Procedure TFhirEffectEvidenceSynthesisSampleSize.SetNumberOfStudiesST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfStudies = nil then
      FNumberOfStudies := TFhirInteger.create;
    FNumberOfStudies.value := value
  end
  else if FNumberOfStudies <> nil then
    FNumberOfStudies.value := '';
end;

Procedure TFhirEffectEvidenceSynthesisSampleSize.SetNumberOfParticipants(value : TFhirInteger);
begin
  FNumberOfParticipants.free;
  FNumberOfParticipants := value;
end;

Function TFhirEffectEvidenceSynthesisSampleSize.GetNumberOfParticipantsST : String;
begin
  if FNumberOfParticipants = nil then
    result := ''
  else
    result := FNumberOfParticipants.value;
end;

Procedure TFhirEffectEvidenceSynthesisSampleSize.SetNumberOfParticipantsST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfParticipants = nil then
      FNumberOfParticipants := TFhirInteger.create;
    FNumberOfParticipants.value := value
  end
  else if FNumberOfParticipants <> nil then
    FNumberOfParticipants.value := '';
end;

function TFhirEffectEvidenceSynthesisSampleSize.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDescription.sizeInBytes);
  inc(result, FNumberOfStudies.sizeInBytes);
  inc(result, FNumberOfParticipants.sizeInBytes);
end;

{ TFhirEffectEvidenceSynthesisSampleSizeListEnumerator }

Constructor TFhirEffectEvidenceSynthesisSampleSizeListEnumerator.Create(list : TFhirEffectEvidenceSynthesisSampleSizeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEffectEvidenceSynthesisSampleSizeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEffectEvidenceSynthesisSampleSizeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEffectEvidenceSynthesisSampleSizeListEnumerator.GetCurrent : TFhirEffectEvidenceSynthesisSampleSize;
begin
  Result := FList[FIndex];
end;

function TFhirEffectEvidenceSynthesisSampleSizeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEffectEvidenceSynthesisSampleSizeList }
procedure TFhirEffectEvidenceSynthesisSampleSizeList.AddItem(value: TFhirEffectEvidenceSynthesisSampleSize);
begin
  assert(value.ClassName = 'TFhirEffectEvidenceSynthesisSampleSize', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEffectEvidenceSynthesisSampleSize');
  add(value);
end;

function TFhirEffectEvidenceSynthesisSampleSizeList.Append: TFhirEffectEvidenceSynthesisSampleSize;
begin
  result := TFhirEffectEvidenceSynthesisSampleSize.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEffectEvidenceSynthesisSampleSizeList.ClearItems;
begin
  Clear;
end;

function TFhirEffectEvidenceSynthesisSampleSizeList.GetEnumerator : TFhirEffectEvidenceSynthesisSampleSizeListEnumerator;
begin
  result := TFhirEffectEvidenceSynthesisSampleSizeListEnumerator.Create(self.link);
end;

function TFhirEffectEvidenceSynthesisSampleSizeList.Clone: TFhirEffectEvidenceSynthesisSampleSizeList;
begin
  result := TFhirEffectEvidenceSynthesisSampleSizeList(inherited Clone);
end;

function TFhirEffectEvidenceSynthesisSampleSizeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEffectEvidenceSynthesisSampleSizeList.GetItemN(index: Integer): TFhirEffectEvidenceSynthesisSampleSize;
begin
  result := TFhirEffectEvidenceSynthesisSampleSize(ObjectByIndex[index]);
end;

function TFhirEffectEvidenceSynthesisSampleSizeList.ItemClass: TFslObjectClass;
begin
  result := TFhirEffectEvidenceSynthesisSampleSize;
end;
function TFhirEffectEvidenceSynthesisSampleSizeList.IndexOf(value: TFhirEffectEvidenceSynthesisSampleSize): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEffectEvidenceSynthesisSampleSizeList.Insert(index: Integer): TFhirEffectEvidenceSynthesisSampleSize;
begin
  result := TFhirEffectEvidenceSynthesisSampleSize.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEffectEvidenceSynthesisSampleSizeList.InsertItem(index: Integer; value: TFhirEffectEvidenceSynthesisSampleSize);
begin
  assert(value is TFhirEffectEvidenceSynthesisSampleSize);
  Inherited Insert(index, value);
end;

function TFhirEffectEvidenceSynthesisSampleSizeList.Item(index: Integer): TFhirEffectEvidenceSynthesisSampleSize;
begin
  result := TFhirEffectEvidenceSynthesisSampleSize(ObjectByIndex[index]);
end;

function TFhirEffectEvidenceSynthesisSampleSizeList.Link: TFhirEffectEvidenceSynthesisSampleSizeList;
begin
  result := TFhirEffectEvidenceSynthesisSampleSizeList(inherited Link);
end;

procedure TFhirEffectEvidenceSynthesisSampleSizeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEffectEvidenceSynthesisSampleSizeList.SetItemByIndex(index: Integer; value: TFhirEffectEvidenceSynthesisSampleSize);
begin
  assert(value is TFhirEffectEvidenceSynthesisSampleSize);
  FhirEffectEvidenceSynthesisSampleSizes[index] := value;
end;

procedure TFhirEffectEvidenceSynthesisSampleSizeList.SetItemN(index: Integer; value: TFhirEffectEvidenceSynthesisSampleSize);
begin
  assert(value is TFhirEffectEvidenceSynthesisSampleSize);
  ObjectByIndex[index] := value;
end;

{ TFhirEffectEvidenceSynthesisResultsByExposure }

constructor TFhirEffectEvidenceSynthesisResultsByExposure.Create;
begin
  inherited;
end;

destructor TFhirEffectEvidenceSynthesisResultsByExposure.Destroy;
begin
  FDescription.free;
  FExposureState.free;
  FVariantState.free;
  FRiskEvidenceSynthesis.free;
  inherited;
end;

procedure TFhirEffectEvidenceSynthesisResultsByExposure.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirEffectEvidenceSynthesisResultsByExposure(oSource).descriptionElement.Clone;
  FExposureState := TFhirEffectEvidenceSynthesisResultsByExposure(oSource).FExposureState.Link;
  variantState := TFhirEffectEvidenceSynthesisResultsByExposure(oSource).variantState.Clone;
  riskEvidenceSynthesis := TFhirEffectEvidenceSynthesisResultsByExposure(oSource).riskEvidenceSynthesis.Clone;
end;

procedure TFhirEffectEvidenceSynthesisResultsByExposure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'exposureState') Then
     list.add(self.link, 'exposureState', FExposureState.Link);
  if (child_name = 'variantState') Then
     list.add(self.link, 'variantState', FVariantState.Link);
  if (child_name = 'riskEvidenceSynthesis') Then
     list.add(self.link, 'riskEvidenceSynthesis', FRiskEvidenceSynthesis.Link);
end;

procedure TFhirEffectEvidenceSynthesisResultsByExposure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'exposureState', 'code', false, TFHIREnum, FExposureState.Link));{1}
  oList.add(TFHIRProperty.create(self, 'variantState', 'CodeableConcept', false, TFhirCodeableConcept, FVariantState.Link));{2}
  oList.add(TFHIRProperty.create(self, 'riskEvidenceSynthesis', 'Reference(RiskEvidenceSynthesis)', false, TFhirReference{TFhirRiskEvidenceSynthesis}, FRiskEvidenceSynthesis.Link));{2}
end;

function TFhirEffectEvidenceSynthesisResultsByExposure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'exposureState') then
  begin
    ExposureStateElement := asEnum(SYSTEMS_TFhirExposureStateEnum, CODES_TFhirExposureStateEnum, propValue);
    result := propValue
  end
  else if (propName = 'variantState') then
  begin
    VariantState := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'riskEvidenceSynthesis') then
  begin
    RiskEvidenceSynthesis := propValue as TFhirReference{TFhirRiskEvidenceSynthesis}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEffectEvidenceSynthesisResultsByExposure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEffectEvidenceSynthesisResultsByExposure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'variantState') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'riskEvidenceSynthesis') then result := TFhirReference{TFhirRiskEvidenceSynthesis}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEffectEvidenceSynthesisResultsByExposure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'exposureState') then result := 'code'
  else if (propName = 'variantState') then result := 'CodeableConcept'
  else if (propName = 'riskEvidenceSynthesis') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEffectEvidenceSynthesisResultsByExposure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'exposureState') then ExposureStateElement := nil
  else if (propName = 'variantState') then VariantStateElement := nil
  else if (propName = 'riskEvidenceSynthesis') then RiskEvidenceSynthesisElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEffectEvidenceSynthesisResultsByExposure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'exposureState') then ExposureStateElement := asEnum(SYSTEMS_TFhirExposureStateEnum, CODES_TFhirExposureStateEnum, new){4}
  else if (propName = 'variantState') then VariantStateElement := new as TFhirCodeableConcept{4}
  else if (propName = 'riskEvidenceSynthesis') then RiskEvidenceSynthesisElement := new as TFhirReference{TFhirRiskEvidenceSynthesis}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEffectEvidenceSynthesisResultsByExposure.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEffectEvidenceSynthesisResultsByExposure.fhirType : string;
begin
  result := 'resultsByExposure';
end;

function TFhirEffectEvidenceSynthesisResultsByExposure.Link : TFhirEffectEvidenceSynthesisResultsByExposure;
begin
  result := TFhirEffectEvidenceSynthesisResultsByExposure(inherited Link);
end;

function TFhirEffectEvidenceSynthesisResultsByExposure.Clone : TFhirEffectEvidenceSynthesisResultsByExposure;
begin
  result := TFhirEffectEvidenceSynthesisResultsByExposure(inherited Clone);
end;

function TFhirEffectEvidenceSynthesisResultsByExposure.equals(other : TObject) : boolean; 
var
  o : TFhirEffectEvidenceSynthesisResultsByExposure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEffectEvidenceSynthesisResultsByExposure)) then
    result := false
  else
  begin
    o := TFhirEffectEvidenceSynthesisResultsByExposure(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(exposureStateElement, o.exposureStateElement, true) and 
      compareDeep(variantStateElement, o.variantStateElement, true) and compareDeep(riskEvidenceSynthesisElement, o.riskEvidenceSynthesisElement, true);
  end;
end;

function TFhirEffectEvidenceSynthesisResultsByExposure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FExposureState) and isEmptyProp(FVariantState) and isEmptyProp(FRiskEvidenceSynthesis);
end;

procedure TFhirEffectEvidenceSynthesisResultsByExposure.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('exposureState');
  fields.add('variantState');
  fields.add('riskEvidenceSynthesis');
end;

{ TFhirEffectEvidenceSynthesisResultsByExposure }

Procedure TFhirEffectEvidenceSynthesisResultsByExposure.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirEffectEvidenceSynthesisResultsByExposure.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirEffectEvidenceSynthesisResultsByExposure.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirEffectEvidenceSynthesisResultsByExposure.SetExposureState(value : TFhirEnum);
begin
  FExposureState.free;
  FExposureState := value;
end;

Function TFhirEffectEvidenceSynthesisResultsByExposure.GetExposureStateST : TFhirExposureStateEnum;
begin
  if FExposureState = nil then
    result := TFhirExposureStateEnum(0)
  else
    result := TFhirExposureStateEnum(StringArrayIndexOfSensitive(CODES_TFhirExposureStateEnum, FExposureState.value));
end;

Procedure TFhirEffectEvidenceSynthesisResultsByExposure.SetExposureStateST(value : TFhirExposureStateEnum);
begin
  if ord(value) = 0 then
    ExposureStateElement := nil
  else
    ExposureStateElement := TFhirEnum.create(SYSTEMS_TFhirExposureStateEnum[value], CODES_TFhirExposureStateEnum[value]);
end;

Procedure TFhirEffectEvidenceSynthesisResultsByExposure.SetVariantState(value : TFhirCodeableConcept);
begin
  FVariantState.free;
  FVariantState := value;
end;

Procedure TFhirEffectEvidenceSynthesisResultsByExposure.SetRiskEvidenceSynthesis(value : TFhirReference{TFhirRiskEvidenceSynthesis});
begin
  FRiskEvidenceSynthesis.free;
  FRiskEvidenceSynthesis := value;
end;

function TFhirEffectEvidenceSynthesisResultsByExposure.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDescription.sizeInBytes);
  inc(result, FExposureState.sizeInBytes);
  inc(result, FVariantState.sizeInBytes);
  inc(result, FRiskEvidenceSynthesis.sizeInBytes);
end;

{ TFhirEffectEvidenceSynthesisResultsByExposureListEnumerator }

Constructor TFhirEffectEvidenceSynthesisResultsByExposureListEnumerator.Create(list : TFhirEffectEvidenceSynthesisResultsByExposureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEffectEvidenceSynthesisResultsByExposureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEffectEvidenceSynthesisResultsByExposureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEffectEvidenceSynthesisResultsByExposureListEnumerator.GetCurrent : TFhirEffectEvidenceSynthesisResultsByExposure;
begin
  Result := FList[FIndex];
end;

function TFhirEffectEvidenceSynthesisResultsByExposureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEffectEvidenceSynthesisResultsByExposureList }
procedure TFhirEffectEvidenceSynthesisResultsByExposureList.AddItem(value: TFhirEffectEvidenceSynthesisResultsByExposure);
begin
  assert(value.ClassName = 'TFhirEffectEvidenceSynthesisResultsByExposure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEffectEvidenceSynthesisResultsByExposure');
  add(value);
end;

function TFhirEffectEvidenceSynthesisResultsByExposureList.Append: TFhirEffectEvidenceSynthesisResultsByExposure;
begin
  result := TFhirEffectEvidenceSynthesisResultsByExposure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEffectEvidenceSynthesisResultsByExposureList.ClearItems;
begin
  Clear;
end;

function TFhirEffectEvidenceSynthesisResultsByExposureList.GetEnumerator : TFhirEffectEvidenceSynthesisResultsByExposureListEnumerator;
begin
  result := TFhirEffectEvidenceSynthesisResultsByExposureListEnumerator.Create(self.link);
end;

function TFhirEffectEvidenceSynthesisResultsByExposureList.Clone: TFhirEffectEvidenceSynthesisResultsByExposureList;
begin
  result := TFhirEffectEvidenceSynthesisResultsByExposureList(inherited Clone);
end;

function TFhirEffectEvidenceSynthesisResultsByExposureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEffectEvidenceSynthesisResultsByExposureList.GetItemN(index: Integer): TFhirEffectEvidenceSynthesisResultsByExposure;
begin
  result := TFhirEffectEvidenceSynthesisResultsByExposure(ObjectByIndex[index]);
end;

function TFhirEffectEvidenceSynthesisResultsByExposureList.ItemClass: TFslObjectClass;
begin
  result := TFhirEffectEvidenceSynthesisResultsByExposure;
end;
function TFhirEffectEvidenceSynthesisResultsByExposureList.IndexOf(value: TFhirEffectEvidenceSynthesisResultsByExposure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEffectEvidenceSynthesisResultsByExposureList.Insert(index: Integer): TFhirEffectEvidenceSynthesisResultsByExposure;
begin
  result := TFhirEffectEvidenceSynthesisResultsByExposure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEffectEvidenceSynthesisResultsByExposureList.InsertItem(index: Integer; value: TFhirEffectEvidenceSynthesisResultsByExposure);
begin
  assert(value is TFhirEffectEvidenceSynthesisResultsByExposure);
  Inherited Insert(index, value);
end;

function TFhirEffectEvidenceSynthesisResultsByExposureList.Item(index: Integer): TFhirEffectEvidenceSynthesisResultsByExposure;
begin
  result := TFhirEffectEvidenceSynthesisResultsByExposure(ObjectByIndex[index]);
end;

function TFhirEffectEvidenceSynthesisResultsByExposureList.Link: TFhirEffectEvidenceSynthesisResultsByExposureList;
begin
  result := TFhirEffectEvidenceSynthesisResultsByExposureList(inherited Link);
end;

procedure TFhirEffectEvidenceSynthesisResultsByExposureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEffectEvidenceSynthesisResultsByExposureList.SetItemByIndex(index: Integer; value: TFhirEffectEvidenceSynthesisResultsByExposure);
begin
  assert(value is TFhirEffectEvidenceSynthesisResultsByExposure);
  FhirEffectEvidenceSynthesisResultsByExposures[index] := value;
end;

procedure TFhirEffectEvidenceSynthesisResultsByExposureList.SetItemN(index: Integer; value: TFhirEffectEvidenceSynthesisResultsByExposure);
begin
  assert(value is TFhirEffectEvidenceSynthesisResultsByExposure);
  ObjectByIndex[index] := value;
end;

{ TFhirEffectEvidenceSynthesisEffectEstimate }

constructor TFhirEffectEvidenceSynthesisEffectEstimate.Create;
begin
  inherited;
end;

destructor TFhirEffectEvidenceSynthesisEffectEstimate.Destroy;
begin
  FDescription.free;
  FType_.free;
  FVariantState.free;
  FValue.free;
  FUnitOfMeasure.free;
  FPrecisionEstimateList.Free;
  inherited;
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimate.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirEffectEvidenceSynthesisEffectEstimate(oSource).descriptionElement.Clone;
  type_ := TFhirEffectEvidenceSynthesisEffectEstimate(oSource).type_.Clone;
  variantState := TFhirEffectEvidenceSynthesisEffectEstimate(oSource).variantState.Clone;
  valueElement := TFhirEffectEvidenceSynthesisEffectEstimate(oSource).valueElement.Clone;
  unitOfMeasure := TFhirEffectEvidenceSynthesisEffectEstimate(oSource).unitOfMeasure.Clone;
  if (TFhirEffectEvidenceSynthesisEffectEstimate(oSource).FPrecisionEstimateList = nil) then
  begin
    FPrecisionEstimateList.free;
    FPrecisionEstimateList := nil;
  end
  else
  begin
    if FPrecisionEstimateList = nil then
      FPrecisionEstimateList := TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList.Create;
    FPrecisionEstimateList.Assign(TFhirEffectEvidenceSynthesisEffectEstimate(oSource).FPrecisionEstimateList);
  end;
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimate.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'variantState') Then
     list.add(self.link, 'variantState', FVariantState.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'unitOfMeasure') Then
     list.add(self.link, 'unitOfMeasure', FUnitOfMeasure.Link);
  if (child_name = 'precisionEstimate') Then
    list.addAll(self, 'precisionEstimate', FPrecisionEstimateList);
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimate.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'variantState', 'CodeableConcept', false, TFhirCodeableConcept, FVariantState.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'decimal', false, TFhirDecimal, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitOfMeasure', 'CodeableConcept', false, TFhirCodeableConcept, FUnitOfMeasure.Link));{2}
  oList.add(TFHIRProperty.create(self, 'precisionEstimate', '', true, TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate, FPrecisionEstimateList.Link)){3};
end;

function TFhirEffectEvidenceSynthesisEffectEstimate.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'variantState') then
  begin
    VariantState := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'unitOfMeasure') then
  begin
    UnitOfMeasure := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'precisionEstimate') then
  begin
    PrecisionEstimateList.add(propValue as TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimate.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'precisionEstimate') then PrecisionEstimateList.insertItem(index, propValue as TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate){2a}
  else inherited;
end;

function TFhirEffectEvidenceSynthesisEffectEstimate.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'variantState') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'value') then result := TFhirDecimal.create() {5b}
  else if (propName = 'unitOfMeasure') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'precisionEstimate') then result := PrecisionEstimateList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEffectEvidenceSynthesisEffectEstimate.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'variantState') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'decimal'
  else if (propName = 'unitOfMeasure') then result := 'CodeableConcept'
  else if (propName = 'precisionEstimate') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimate.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'variantState') then VariantStateElement := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'unitOfMeasure') then UnitOfMeasureElement := nil
  else if (propName = 'precisionEstimate') then deletePropertyValue('precisionEstimate', PrecisionEstimateList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimate.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'variantState') then VariantStateElement := new as TFhirCodeableConcept{4}
  else if (propName = 'value') then ValueElement := asDecimal(new){5b}
  else if (propName = 'unitOfMeasure') then UnitOfMeasureElement := new as TFhirCodeableConcept{4}
  else if (propName = 'precisionEstimate') then replacePropertyValue('precisionEstimate', PrecisionEstimateList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimate.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'precisionEstimate') then PrecisionEstimateList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEffectEvidenceSynthesisEffectEstimate.fhirType : string;
begin
  result := 'effectEstimate';
end;

function TFhirEffectEvidenceSynthesisEffectEstimate.Link : TFhirEffectEvidenceSynthesisEffectEstimate;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimate(inherited Link);
end;

function TFhirEffectEvidenceSynthesisEffectEstimate.Clone : TFhirEffectEvidenceSynthesisEffectEstimate;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimate(inherited Clone);
end;

function TFhirEffectEvidenceSynthesisEffectEstimate.equals(other : TObject) : boolean; 
var
  o : TFhirEffectEvidenceSynthesisEffectEstimate;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEffectEvidenceSynthesisEffectEstimate)) then
    result := false
  else
  begin
    o := TFhirEffectEvidenceSynthesisEffectEstimate(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(variantStateElement, o.variantStateElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(unitOfMeasureElement, o.unitOfMeasureElement, true) and compareDeep(precisionEstimateList, o.precisionEstimateList, true);
  end;
end;

function TFhirEffectEvidenceSynthesisEffectEstimate.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FType_) and isEmptyProp(FVariantState) and isEmptyProp(FValue) and isEmptyProp(FUnitOfMeasure) and isEmptyProp(FprecisionEstimateList);
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimate.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('type');
  fields.add('variantState');
  fields.add('value');
  fields.add('unitOfMeasure');
  fields.add('precisionEstimate');
end;

{ TFhirEffectEvidenceSynthesisEffectEstimate }

Procedure TFhirEffectEvidenceSynthesisEffectEstimate.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirEffectEvidenceSynthesisEffectEstimate.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirEffectEvidenceSynthesisEffectEstimate.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirEffectEvidenceSynthesisEffectEstimate.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirEffectEvidenceSynthesisEffectEstimate.SetVariantState(value : TFhirCodeableConcept);
begin
  FVariantState.free;
  FVariantState := value;
end;

Procedure TFhirEffectEvidenceSynthesisEffectEstimate.SetValue(value : TFhirDecimal);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirEffectEvidenceSynthesisEffectEstimate.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirEffectEvidenceSynthesisEffectEstimate.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirDecimal.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

Procedure TFhirEffectEvidenceSynthesisEffectEstimate.SetUnitOfMeasure(value : TFhirCodeableConcept);
begin
  FUnitOfMeasure.free;
  FUnitOfMeasure := value;
end;

Function TFhirEffectEvidenceSynthesisEffectEstimate.GetPrecisionEstimateList : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList;
begin
  if FPrecisionEstimateList = nil then
    FPrecisionEstimateList := TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList.Create;
  result := FPrecisionEstimateList;
end;

Function TFhirEffectEvidenceSynthesisEffectEstimate.GetHasPrecisionEstimateList : boolean;
begin
  result := (FPrecisionEstimateList <> nil) and (FPrecisionEstimateList.count > 0);
end;

function TFhirEffectEvidenceSynthesisEffectEstimate.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDescription.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FVariantState.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FUnitOfMeasure.sizeInBytes);
  inc(result, FprecisionEstimateList.sizeInBytes);
end;

{ TFhirEffectEvidenceSynthesisEffectEstimateListEnumerator }

Constructor TFhirEffectEvidenceSynthesisEffectEstimateListEnumerator.Create(list : TFhirEffectEvidenceSynthesisEffectEstimateList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEffectEvidenceSynthesisEffectEstimateListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEffectEvidenceSynthesisEffectEstimateListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEffectEvidenceSynthesisEffectEstimateListEnumerator.GetCurrent : TFhirEffectEvidenceSynthesisEffectEstimate;
begin
  Result := FList[FIndex];
end;

function TFhirEffectEvidenceSynthesisEffectEstimateListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEffectEvidenceSynthesisEffectEstimateList }
procedure TFhirEffectEvidenceSynthesisEffectEstimateList.AddItem(value: TFhirEffectEvidenceSynthesisEffectEstimate);
begin
  assert(value.ClassName = 'TFhirEffectEvidenceSynthesisEffectEstimate', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEffectEvidenceSynthesisEffectEstimate');
  add(value);
end;

function TFhirEffectEvidenceSynthesisEffectEstimateList.Append: TFhirEffectEvidenceSynthesisEffectEstimate;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimate.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimateList.ClearItems;
begin
  Clear;
end;

function TFhirEffectEvidenceSynthesisEffectEstimateList.GetEnumerator : TFhirEffectEvidenceSynthesisEffectEstimateListEnumerator;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimateListEnumerator.Create(self.link);
end;

function TFhirEffectEvidenceSynthesisEffectEstimateList.Clone: TFhirEffectEvidenceSynthesisEffectEstimateList;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimateList(inherited Clone);
end;

function TFhirEffectEvidenceSynthesisEffectEstimateList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEffectEvidenceSynthesisEffectEstimateList.GetItemN(index: Integer): TFhirEffectEvidenceSynthesisEffectEstimate;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimate(ObjectByIndex[index]);
end;

function TFhirEffectEvidenceSynthesisEffectEstimateList.ItemClass: TFslObjectClass;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimate;
end;
function TFhirEffectEvidenceSynthesisEffectEstimateList.IndexOf(value: TFhirEffectEvidenceSynthesisEffectEstimate): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEffectEvidenceSynthesisEffectEstimateList.Insert(index: Integer): TFhirEffectEvidenceSynthesisEffectEstimate;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimate.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimateList.InsertItem(index: Integer; value: TFhirEffectEvidenceSynthesisEffectEstimate);
begin
  assert(value is TFhirEffectEvidenceSynthesisEffectEstimate);
  Inherited Insert(index, value);
end;

function TFhirEffectEvidenceSynthesisEffectEstimateList.Item(index: Integer): TFhirEffectEvidenceSynthesisEffectEstimate;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimate(ObjectByIndex[index]);
end;

function TFhirEffectEvidenceSynthesisEffectEstimateList.Link: TFhirEffectEvidenceSynthesisEffectEstimateList;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimateList(inherited Link);
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimateList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimateList.SetItemByIndex(index: Integer; value: TFhirEffectEvidenceSynthesisEffectEstimate);
begin
  assert(value is TFhirEffectEvidenceSynthesisEffectEstimate);
  FhirEffectEvidenceSynthesisEffectEstimates[index] := value;
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimateList.SetItemN(index: Integer; value: TFhirEffectEvidenceSynthesisEffectEstimate);
begin
  assert(value is TFhirEffectEvidenceSynthesisEffectEstimate);
  ObjectByIndex[index] := value;
end;

{ TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate }

constructor TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.Create;
begin
  inherited;
end;

destructor TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.Destroy;
begin
  FType_.free;
  FLevel.free;
  FFrom.free;
  FTo_.free;
  inherited;
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(oSource).type_.Clone;
  levelElement := TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(oSource).levelElement.Clone;
  fromElement := TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(oSource).fromElement.Clone;
  to_Element := TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(oSource).to_Element.Clone;
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'level') Then
     list.add(self.link, 'level', FLevel.Link);
  if (child_name = 'from') Then
     list.add(self.link, 'from', FFrom.Link);
  if (child_name = 'to') Then
     list.add(self.link, 'to', FTo_.Link);
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'level', 'decimal', false, TFhirDecimal, FLevel.Link));{2}
  oList.add(TFHIRProperty.create(self, 'from', 'decimal', false, TFhirDecimal, FFrom.Link));{2}
  oList.add(TFHIRProperty.create(self, 'to', 'decimal', false, TFhirDecimal, FTo_.Link));{2}
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'level') then
  begin
    LevelElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'from') then
  begin
    FromElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'to') then
  begin
    To_Element := asDecimal(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'level') then result := TFhirDecimal.create() {5b}
  else if (propName = 'from') then result := TFhirDecimal.create() {5b}
  else if (propName = 'to') then result := TFhirDecimal.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'level') then result := 'decimal'
  else if (propName = 'from') then result := 'decimal'
  else if (propName = 'to') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'level') then LevelElement := nil
  else if (propName = 'from') then FromElement := nil
  else if (propName = 'to') then To_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'level') then LevelElement := asDecimal(new){5b}
  else if (propName = 'from') then FromElement := asDecimal(new){5b}
  else if (propName = 'to') then To_Element := asDecimal(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.fhirType : string;
begin
  result := 'precisionEstimate';
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.Link : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(inherited Link);
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.Clone : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(inherited Clone);
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.equals(other : TObject) : boolean; 
var
  o : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate)) then
    result := false
  else
  begin
    o := TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(levelElement, o.levelElement, true) and 
      compareDeep(fromElement, o.fromElement, true) and compareDeep(to_Element, o.to_Element, true);
  end;
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FLevel) and isEmptyProp(FFrom) and isEmptyProp(FTo_);
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('level');
  fields.add('from');
  fields.add('to');
end;

{ TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate }

Procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.SetLevel(value : TFhirDecimal);
begin
  FLevel.free;
  FLevel := value;
end;

Function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.GetLevelST : String;
begin
  if FLevel = nil then
    result := ''
  else
    result := FLevel.value;
end;

Procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.SetLevelST(value : String);
begin
  if value <> '' then
  begin
    if FLevel = nil then
      FLevel := TFhirDecimal.create;
    FLevel.value := value
  end
  else if FLevel <> nil then
    FLevel.value := '';
end;

Procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.SetFrom(value : TFhirDecimal);
begin
  FFrom.free;
  FFrom := value;
end;

Function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.GetFromST : String;
begin
  if FFrom = nil then
    result := ''
  else
    result := FFrom.value;
end;

Procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.SetFromST(value : String);
begin
  if value <> '' then
  begin
    if FFrom = nil then
      FFrom := TFhirDecimal.create;
    FFrom.value := value
  end
  else if FFrom <> nil then
    FFrom.value := '';
end;

Procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.SetTo_(value : TFhirDecimal);
begin
  FTo_.free;
  FTo_ := value;
end;

Function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.GetTo_ST : String;
begin
  if FTo_ = nil then
    result := ''
  else
    result := FTo_.value;
end;

Procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.SetTo_ST(value : String);
begin
  if value <> '' then
  begin
    if FTo_ = nil then
      FTo_ := TFhirDecimal.create;
    FTo_.value := value
  end
  else if FTo_ <> nil then
    FTo_.value := '';
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FLevel.sizeInBytes);
  inc(result, FFrom.sizeInBytes);
  inc(result, FTo_.sizeInBytes);
end;

{ TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateListEnumerator }

Constructor TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateListEnumerator.Create(list : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateListEnumerator.GetCurrent : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate;
begin
  Result := FList[FIndex];
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList }
procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList.AddItem(value: TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate);
begin
  assert(value.ClassName = 'TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate');
  add(value);
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList.Append: TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList.ClearItems;
begin
  Clear;
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList.GetEnumerator : TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateListEnumerator;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateListEnumerator.Create(self.link);
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList.Clone: TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList(inherited Clone);
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList.GetItemN(index: Integer): TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(ObjectByIndex[index]);
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList.ItemClass: TFslObjectClass;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate;
end;
function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList.IndexOf(value: TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList.Insert(index: Integer): TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList.InsertItem(index: Integer; value: TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate);
begin
  assert(value is TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate);
  Inherited Insert(index, value);
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList.Item(index: Integer): TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate(ObjectByIndex[index]);
end;

function TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList.Link: TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList;
begin
  result := TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList(inherited Link);
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList.SetItemByIndex(index: Integer; value: TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate);
begin
  assert(value is TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate);
  FhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimates[index] := value;
end;

procedure TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimateList.SetItemN(index: Integer; value: TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate);
begin
  assert(value is TFhirEffectEvidenceSynthesisEffectEstimatePrecisionEstimate);
  ObjectByIndex[index] := value;
end;

{ TFhirEffectEvidenceSynthesisCertainty }

constructor TFhirEffectEvidenceSynthesisCertainty.Create;
begin
  inherited;
end;

destructor TFhirEffectEvidenceSynthesisCertainty.Destroy;
begin
  FRatingList.Free;
  FNoteList.Free;
  FCertaintySubcomponentList.Free;
  inherited;
end;

procedure TFhirEffectEvidenceSynthesisCertainty.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEffectEvidenceSynthesisCertainty(oSource).FRatingList = nil) then
  begin
    FRatingList.free;
    FRatingList := nil;
  end
  else
  begin
    if FRatingList = nil then
      FRatingList := TFhirCodeableConceptList.Create;
    FRatingList.Assign(TFhirEffectEvidenceSynthesisCertainty(oSource).FRatingList);
  end;
  if (TFhirEffectEvidenceSynthesisCertainty(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEffectEvidenceSynthesisCertainty(oSource).FNoteList);
  end;
  if (TFhirEffectEvidenceSynthesisCertainty(oSource).FCertaintySubcomponentList = nil) then
  begin
    FCertaintySubcomponentList.free;
    FCertaintySubcomponentList := nil;
  end
  else
  begin
    if FCertaintySubcomponentList = nil then
      FCertaintySubcomponentList := TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList.Create;
    FCertaintySubcomponentList.Assign(TFhirEffectEvidenceSynthesisCertainty(oSource).FCertaintySubcomponentList);
  end;
end;

procedure TFhirEffectEvidenceSynthesisCertainty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'rating') Then
    list.addAll(self, 'rating', FRatingList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'certaintySubcomponent') Then
    list.addAll(self, 'certaintySubcomponent', FCertaintySubcomponentList);
end;

procedure TFhirEffectEvidenceSynthesisCertainty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'rating', 'CodeableConcept', true, TFhirCodeableConcept, FRatingList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'certaintySubcomponent', '', true, TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent, FCertaintySubcomponentList.Link)){3};
end;

function TFhirEffectEvidenceSynthesisCertainty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'rating') then
  begin
    RatingList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'certaintySubcomponent') then
  begin
    CertaintySubcomponentList.add(propValue as TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEffectEvidenceSynthesisCertainty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'rating') then RatingList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'certaintySubcomponent') then CertaintySubcomponentList.insertItem(index, propValue as TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent){2a}
  else inherited;
end;

function TFhirEffectEvidenceSynthesisCertainty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'rating') then result := RatingList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'certaintySubcomponent') then result := CertaintySubcomponentList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEffectEvidenceSynthesisCertainty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'rating') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'certaintySubcomponent') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEffectEvidenceSynthesisCertainty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'rating') then deletePropertyValue('rating', RatingList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'certaintySubcomponent') then deletePropertyValue('certaintySubcomponent', CertaintySubcomponentList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEffectEvidenceSynthesisCertainty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'rating') then replacePropertyValue('rating', RatingList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'certaintySubcomponent') then replacePropertyValue('certaintySubcomponent', CertaintySubcomponentList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEffectEvidenceSynthesisCertainty.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'rating') then RatingList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'certaintySubcomponent') then CertaintySubcomponentList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEffectEvidenceSynthesisCertainty.fhirType : string;
begin
  result := 'certainty';
end;

function TFhirEffectEvidenceSynthesisCertainty.Link : TFhirEffectEvidenceSynthesisCertainty;
begin
  result := TFhirEffectEvidenceSynthesisCertainty(inherited Link);
end;

function TFhirEffectEvidenceSynthesisCertainty.Clone : TFhirEffectEvidenceSynthesisCertainty;
begin
  result := TFhirEffectEvidenceSynthesisCertainty(inherited Clone);
end;

function TFhirEffectEvidenceSynthesisCertainty.equals(other : TObject) : boolean; 
var
  o : TFhirEffectEvidenceSynthesisCertainty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEffectEvidenceSynthesisCertainty)) then
    result := false
  else
  begin
    o := TFhirEffectEvidenceSynthesisCertainty(other);
    result := compareDeep(ratingList, o.ratingList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(certaintySubcomponentList, o.certaintySubcomponentList, true);
  end;
end;

function TFhirEffectEvidenceSynthesisCertainty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FratingList) and isEmptyProp(FnoteList) and isEmptyProp(FcertaintySubcomponentList);
end;

procedure TFhirEffectEvidenceSynthesisCertainty.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('rating');
  fields.add('note');
  fields.add('certaintySubcomponent');
end;

{ TFhirEffectEvidenceSynthesisCertainty }

Function TFhirEffectEvidenceSynthesisCertainty.GetRatingList : TFhirCodeableConceptList;
begin
  if FRatingList = nil then
    FRatingList := TFhirCodeableConceptList.Create;
  result := FRatingList;
end;

Function TFhirEffectEvidenceSynthesisCertainty.GetHasRatingList : boolean;
begin
  result := (FRatingList <> nil) and (FRatingList.count > 0);
end;

Function TFhirEffectEvidenceSynthesisCertainty.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirEffectEvidenceSynthesisCertainty.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirEffectEvidenceSynthesisCertainty.GetCertaintySubcomponentList : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList;
begin
  if FCertaintySubcomponentList = nil then
    FCertaintySubcomponentList := TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList.Create;
  result := FCertaintySubcomponentList;
end;

Function TFhirEffectEvidenceSynthesisCertainty.GetHasCertaintySubcomponentList : boolean;
begin
  result := (FCertaintySubcomponentList <> nil) and (FCertaintySubcomponentList.count > 0);
end;

function TFhirEffectEvidenceSynthesisCertainty.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FratingList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FcertaintySubcomponentList.sizeInBytes);
end;

{ TFhirEffectEvidenceSynthesisCertaintyListEnumerator }

Constructor TFhirEffectEvidenceSynthesisCertaintyListEnumerator.Create(list : TFhirEffectEvidenceSynthesisCertaintyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEffectEvidenceSynthesisCertaintyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEffectEvidenceSynthesisCertaintyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEffectEvidenceSynthesisCertaintyListEnumerator.GetCurrent : TFhirEffectEvidenceSynthesisCertainty;
begin
  Result := FList[FIndex];
end;

function TFhirEffectEvidenceSynthesisCertaintyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEffectEvidenceSynthesisCertaintyList }
procedure TFhirEffectEvidenceSynthesisCertaintyList.AddItem(value: TFhirEffectEvidenceSynthesisCertainty);
begin
  assert(value.ClassName = 'TFhirEffectEvidenceSynthesisCertainty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEffectEvidenceSynthesisCertainty');
  add(value);
end;

function TFhirEffectEvidenceSynthesisCertaintyList.Append: TFhirEffectEvidenceSynthesisCertainty;
begin
  result := TFhirEffectEvidenceSynthesisCertainty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEffectEvidenceSynthesisCertaintyList.ClearItems;
begin
  Clear;
end;

function TFhirEffectEvidenceSynthesisCertaintyList.GetEnumerator : TFhirEffectEvidenceSynthesisCertaintyListEnumerator;
begin
  result := TFhirEffectEvidenceSynthesisCertaintyListEnumerator.Create(self.link);
end;

function TFhirEffectEvidenceSynthesisCertaintyList.Clone: TFhirEffectEvidenceSynthesisCertaintyList;
begin
  result := TFhirEffectEvidenceSynthesisCertaintyList(inherited Clone);
end;

function TFhirEffectEvidenceSynthesisCertaintyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEffectEvidenceSynthesisCertaintyList.GetItemN(index: Integer): TFhirEffectEvidenceSynthesisCertainty;
begin
  result := TFhirEffectEvidenceSynthesisCertainty(ObjectByIndex[index]);
end;

function TFhirEffectEvidenceSynthesisCertaintyList.ItemClass: TFslObjectClass;
begin
  result := TFhirEffectEvidenceSynthesisCertainty;
end;
function TFhirEffectEvidenceSynthesisCertaintyList.IndexOf(value: TFhirEffectEvidenceSynthesisCertainty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEffectEvidenceSynthesisCertaintyList.Insert(index: Integer): TFhirEffectEvidenceSynthesisCertainty;
begin
  result := TFhirEffectEvidenceSynthesisCertainty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEffectEvidenceSynthesisCertaintyList.InsertItem(index: Integer; value: TFhirEffectEvidenceSynthesisCertainty);
begin
  assert(value is TFhirEffectEvidenceSynthesisCertainty);
  Inherited Insert(index, value);
end;

function TFhirEffectEvidenceSynthesisCertaintyList.Item(index: Integer): TFhirEffectEvidenceSynthesisCertainty;
begin
  result := TFhirEffectEvidenceSynthesisCertainty(ObjectByIndex[index]);
end;

function TFhirEffectEvidenceSynthesisCertaintyList.Link: TFhirEffectEvidenceSynthesisCertaintyList;
begin
  result := TFhirEffectEvidenceSynthesisCertaintyList(inherited Link);
end;

procedure TFhirEffectEvidenceSynthesisCertaintyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEffectEvidenceSynthesisCertaintyList.SetItemByIndex(index: Integer; value: TFhirEffectEvidenceSynthesisCertainty);
begin
  assert(value is TFhirEffectEvidenceSynthesisCertainty);
  FhirEffectEvidenceSynthesisCertainties[index] := value;
end;

procedure TFhirEffectEvidenceSynthesisCertaintyList.SetItemN(index: Integer; value: TFhirEffectEvidenceSynthesisCertainty);
begin
  assert(value is TFhirEffectEvidenceSynthesisCertainty);
  ObjectByIndex[index] := value;
end;

{ TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent }

constructor TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.Create;
begin
  inherited;
end;

destructor TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.Destroy;
begin
  FType_.free;
  FRatingList.Free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent(oSource).type_.Clone;
  if (TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent(oSource).FRatingList = nil) then
  begin
    FRatingList.free;
    FRatingList := nil;
  end
  else
  begin
    if FRatingList = nil then
      FRatingList := TFhirCodeableConceptList.Create;
    FRatingList.Assign(TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent(oSource).FRatingList);
  end;
  if (TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent(oSource).FNoteList);
  end;
end;

procedure TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'rating') Then
    list.addAll(self, 'rating', FRatingList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rating', 'CodeableConcept', true, TFhirCodeableConcept, FRatingList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'rating') then
  begin
    RatingList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'rating') then RatingList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else inherited;
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'rating') then result := RatingList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'rating') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'rating') then deletePropertyValue('rating', RatingList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'rating') then replacePropertyValue('rating', RatingList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'rating') then RatingList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.fhirType : string;
begin
  result := 'certaintySubcomponent';
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.Link : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent;
begin
  result := TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent(inherited Link);
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.Clone : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent;
begin
  result := TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent(inherited Clone);
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.equals(other : TObject) : boolean; 
var
  o : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent)) then
    result := false
  else
  begin
    o := TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(ratingList, o.ratingList, true) and 
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FratingList) and isEmptyProp(FnoteList);
end;

procedure TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('rating');
  fields.add('note');
end;

{ TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent }

Procedure TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.GetRatingList : TFhirCodeableConceptList;
begin
  if FRatingList = nil then
    FRatingList := TFhirCodeableConceptList.Create;
  result := FRatingList;
end;

Function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.GetHasRatingList : boolean;
begin
  result := (FRatingList <> nil) and (FRatingList.count > 0);
end;

Function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FratingList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentListEnumerator }

Constructor TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentListEnumerator.Create(list : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentListEnumerator.GetCurrent : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent;
begin
  Result := FList[FIndex];
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList }
procedure TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList.AddItem(value: TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent);
begin
  assert(value.ClassName = 'TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent');
  add(value);
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList.Append: TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent;
begin
  result := TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList.ClearItems;
begin
  Clear;
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList.GetEnumerator : TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentListEnumerator;
begin
  result := TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentListEnumerator.Create(self.link);
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList.Clone: TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList;
begin
  result := TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList(inherited Clone);
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList.GetItemN(index: Integer): TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent;
begin
  result := TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent(ObjectByIndex[index]);
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList.ItemClass: TFslObjectClass;
begin
  result := TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent;
end;
function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList.IndexOf(value: TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList.Insert(index: Integer): TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent;
begin
  result := TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList.InsertItem(index: Integer; value: TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent);
begin
  assert(value is TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent);
  Inherited Insert(index, value);
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList.Item(index: Integer): TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent;
begin
  result := TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent(ObjectByIndex[index]);
end;

function TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList.Link: TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList;
begin
  result := TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList(inherited Link);
end;

procedure TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList.SetItemByIndex(index: Integer; value: TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent);
begin
  assert(value is TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent);
  FhirEffectEvidenceSynthesisCertaintyCertaintySubcomponents[index] := value;
end;

procedure TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponentList.SetItemN(index: Integer; value: TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent);
begin
  assert(value is TFhirEffectEvidenceSynthesisCertaintyCertaintySubcomponent);
  ObjectByIndex[index] := value;
end;

{ TFhirEffectEvidenceSynthesis }

constructor TFhirEffectEvidenceSynthesis.Create;
begin
  inherited;
end;

destructor TFhirEffectEvidenceSynthesis.Destroy;
begin
  FIdentifierList.Free;
  FNoteList.Free;
  FCopyright.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FTopicList.Free;
  FAuthorList.Free;
  FEditorList.Free;
  FReviewerList.Free;
  FEndorserList.Free;
  FRelatedArtifactList.Free;
  FSynthesisType.free;
  FStudyType.free;
  FPopulation.free;
  FExposure.free;
  FExposureAlternative.free;
  FOutcome.free;
  FSampleSize.free;
  FResultsByExposureList.Free;
  FEffectEstimateList.Free;
  FCertaintyList.Free;
  inherited;
end;

function TFhirEffectEvidenceSynthesis.GetResourceType : TFhirResourceType;
begin
  result := frtEffectEvidenceSynthesis;
end;

procedure TFhirEffectEvidenceSynthesis.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEffectEvidenceSynthesis(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEffectEvidenceSynthesis(oSource).FIdentifierList);
  end;
  if (TFhirEffectEvidenceSynthesis(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEffectEvidenceSynthesis(oSource).FNoteList);
  end;
  copyrightElement := TFhirEffectEvidenceSynthesis(oSource).copyrightElement.Clone;
  approvalDateElement := TFhirEffectEvidenceSynthesis(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirEffectEvidenceSynthesis(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirEffectEvidenceSynthesis(oSource).effectivePeriod.Clone;
  if (TFhirEffectEvidenceSynthesis(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirCodeableConceptList.Create;
    FTopicList.Assign(TFhirEffectEvidenceSynthesis(oSource).FTopicList);
  end;
  if (TFhirEffectEvidenceSynthesis(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirContactDetailList.Create;
    FAuthorList.Assign(TFhirEffectEvidenceSynthesis(oSource).FAuthorList);
  end;
  if (TFhirEffectEvidenceSynthesis(oSource).FEditorList = nil) then
  begin
    FEditorList.free;
    FEditorList := nil;
  end
  else
  begin
    if FEditorList = nil then
      FEditorList := TFhirContactDetailList.Create;
    FEditorList.Assign(TFhirEffectEvidenceSynthesis(oSource).FEditorList);
  end;
  if (TFhirEffectEvidenceSynthesis(oSource).FReviewerList = nil) then
  begin
    FReviewerList.free;
    FReviewerList := nil;
  end
  else
  begin
    if FReviewerList = nil then
      FReviewerList := TFhirContactDetailList.Create;
    FReviewerList.Assign(TFhirEffectEvidenceSynthesis(oSource).FReviewerList);
  end;
  if (TFhirEffectEvidenceSynthesis(oSource).FEndorserList = nil) then
  begin
    FEndorserList.free;
    FEndorserList := nil;
  end
  else
  begin
    if FEndorserList = nil then
      FEndorserList := TFhirContactDetailList.Create;
    FEndorserList.Assign(TFhirEffectEvidenceSynthesis(oSource).FEndorserList);
  end;
  if (TFhirEffectEvidenceSynthesis(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirEffectEvidenceSynthesis(oSource).FRelatedArtifactList);
  end;
  synthesisType := TFhirEffectEvidenceSynthesis(oSource).synthesisType.Clone;
  studyType := TFhirEffectEvidenceSynthesis(oSource).studyType.Clone;
  population := TFhirEffectEvidenceSynthesis(oSource).population.Clone;
  exposure := TFhirEffectEvidenceSynthesis(oSource).exposure.Clone;
  exposureAlternative := TFhirEffectEvidenceSynthesis(oSource).exposureAlternative.Clone;
  outcome := TFhirEffectEvidenceSynthesis(oSource).outcome.Clone;
  sampleSize := TFhirEffectEvidenceSynthesis(oSource).sampleSize.Clone;
  if (TFhirEffectEvidenceSynthesis(oSource).FResultsByExposureList = nil) then
  begin
    FResultsByExposureList.free;
    FResultsByExposureList := nil;
  end
  else
  begin
    if FResultsByExposureList = nil then
      FResultsByExposureList := TFhirEffectEvidenceSynthesisResultsByExposureList.Create;
    FResultsByExposureList.Assign(TFhirEffectEvidenceSynthesis(oSource).FResultsByExposureList);
  end;
  if (TFhirEffectEvidenceSynthesis(oSource).FEffectEstimateList = nil) then
  begin
    FEffectEstimateList.free;
    FEffectEstimateList := nil;
  end
  else
  begin
    if FEffectEstimateList = nil then
      FEffectEstimateList := TFhirEffectEvidenceSynthesisEffectEstimateList.Create;
    FEffectEstimateList.Assign(TFhirEffectEvidenceSynthesis(oSource).FEffectEstimateList);
  end;
  if (TFhirEffectEvidenceSynthesis(oSource).FCertaintyList = nil) then
  begin
    FCertaintyList.free;
    FCertaintyList := nil;
  end
  else
  begin
    if FCertaintyList = nil then
      FCertaintyList := TFhirEffectEvidenceSynthesisCertaintyList.Create;
    FCertaintyList.Assign(TFhirEffectEvidenceSynthesis(oSource).FCertaintyList);
  end;
end;

procedure TFhirEffectEvidenceSynthesis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'editor') Then
    list.addAll(self, 'editor', FEditorList);
  if (child_name = 'reviewer') Then
    list.addAll(self, 'reviewer', FReviewerList);
  if (child_name = 'endorser') Then
    list.addAll(self, 'endorser', FEndorserList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'synthesisType') Then
     list.add(self.link, 'synthesisType', FSynthesisType.Link);
  if (child_name = 'studyType') Then
     list.add(self.link, 'studyType', FStudyType.Link);
  if (child_name = 'population') Then
     list.add(self.link, 'population', FPopulation.Link);
  if (child_name = 'exposure') Then
     list.add(self.link, 'exposure', FExposure.Link);
  if (child_name = 'exposureAlternative') Then
     list.add(self.link, 'exposureAlternative', FExposureAlternative.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'sampleSize') Then
     list.add(self.link, 'sampleSize', FSampleSize.Link);
  if (child_name = 'resultsByExposure') Then
    list.addAll(self, 'resultsByExposure', FResultsByExposureList);
  if (child_name = 'effectEstimate') Then
    list.addAll(self, 'effectEstimate', FEffectEstimateList);
  if (child_name = 'certainty') Then
    list.addAll(self, 'certainty', FCertaintyList);
end;

procedure TFhirEffectEvidenceSynthesis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'topic', 'CodeableConcept', true, TFhirCodeableConcept, FTopicList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'author', 'ContactDetail', true, TFhirContactDetail, FAuthorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'editor', 'ContactDetail', true, TFhirContactDetail, FEditorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reviewer', 'ContactDetail', true, TFhirContactDetail, FReviewerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'endorser', 'ContactDetail', true, TFhirContactDetail, FEndorserList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'synthesisType', 'CodeableConcept', false, TFhirCodeableConcept, FSynthesisType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'studyType', 'CodeableConcept', false, TFhirCodeableConcept, FStudyType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'population', 'Reference(EvidenceVariable)', false, TFhirReference{TFhirEvidenceVariable}, FPopulation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'exposure', 'Reference(EvidenceVariable)', false, TFhirReference{TFhirEvidenceVariable}, FExposure.Link));{2}
  oList.add(TFHIRProperty.create(self, 'exposureAlternative', 'Reference(EvidenceVariable)', false, TFhirReference{TFhirEvidenceVariable}, FExposureAlternative.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'Reference(EvidenceVariable)', false, TFhirReference{TFhirEvidenceVariable}, FOutcome.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sampleSize', '', false, TFhirEffectEvidenceSynthesisSampleSize, FSampleSize.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resultsByExposure', '', true, TFhirEffectEvidenceSynthesisResultsByExposure, FResultsByExposureList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'effectEstimate', '', true, TFhirEffectEvidenceSynthesisEffectEstimate, FEffectEstimateList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'certainty', '', true, TFhirEffectEvidenceSynthesisCertainty, FCertaintyList.Link)){3};
end;

function TFhirEffectEvidenceSynthesis.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'editor') then
  begin
    EditorList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'reviewer') then
  begin
    ReviewerList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'endorser') then
  begin
    EndorserList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact){2a};
    result := propValue;
  end
  else if (propName = 'synthesisType') then
  begin
    SynthesisType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'studyType') then
  begin
    StudyType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'population') then
  begin
    Population := propValue as TFhirReference{TFhirEvidenceVariable}{4b};
    result := propValue;
  end
  else if (propName = 'exposure') then
  begin
    Exposure := propValue as TFhirReference{TFhirEvidenceVariable}{4b};
    result := propValue;
  end
  else if (propName = 'exposureAlternative') then
  begin
    ExposureAlternative := propValue as TFhirReference{TFhirEvidenceVariable}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirReference{TFhirEvidenceVariable}{4b};
    result := propValue;
  end
  else if (propName = 'sampleSize') then
  begin
    SampleSize := propValue as TFhirEffectEvidenceSynthesisSampleSize{4b};
    result := propValue;
  end
  else if (propName = 'resultsByExposure') then
  begin
    ResultsByExposureList.add(propValue as TFhirEffectEvidenceSynthesisResultsByExposure){2a};
    result := propValue;
  end
  else if (propName = 'effectEstimate') then
  begin
    EffectEstimateList.add(propValue as TFhirEffectEvidenceSynthesisEffectEstimate){2a};
    result := propValue;
  end
  else if (propName = 'certainty') then
  begin
    CertaintyList.add(propValue as TFhirEffectEvidenceSynthesisCertainty){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirEffectEvidenceSynthesis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'editor') then EditorList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'reviewer') then ReviewerList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'endorser') then EndorserList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact){2a}
  else if (propName = 'resultsByExposure') then ResultsByExposureList.insertItem(index, propValue as TFhirEffectEvidenceSynthesisResultsByExposure){2a}
  else if (propName = 'effectEstimate') then EffectEstimateList.insertItem(index, propValue as TFhirEffectEvidenceSynthesisEffectEstimate){2a}
  else if (propName = 'certainty') then CertaintyList.insertItem(index, propValue as TFhirEffectEvidenceSynthesisCertainty){2a}
  else inherited;
end;

function TFhirEffectEvidenceSynthesis.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'approvalDate') then result := TFhirDate.create() {5b}
  else if (propName = 'lastReviewDate') then result := TFhirDate.create() {5b}
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'topic') then result := TopicList.new(){2}
  else if (propName = 'author') then result := AuthorList.new(){2}
  else if (propName = 'editor') then result := EditorList.new(){2}
  else if (propName = 'reviewer') then result := ReviewerList.new(){2}
  else if (propName = 'endorser') then result := EndorserList.new(){2}
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new(){2}
  else if (propName = 'synthesisType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'studyType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'population') then result := TFhirReference{TFhirEvidenceVariable}.create(){4b}
  else if (propName = 'exposure') then result := TFhirReference{TFhirEvidenceVariable}.create(){4b}
  else if (propName = 'exposureAlternative') then result := TFhirReference{TFhirEvidenceVariable}.create(){4b}
  else if (propName = 'outcome') then result := TFhirReference{TFhirEvidenceVariable}.create(){4b}
  else if (propName = 'sampleSize') then result := TFhirEffectEvidenceSynthesisSampleSize.create(){4b}
  else if (propName = 'resultsByExposure') then result := ResultsByExposureList.new(){2}
  else if (propName = 'effectEstimate') then result := EffectEstimateList.new(){2}
  else if (propName = 'certainty') then result := CertaintyList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEffectEvidenceSynthesis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'topic') then result := 'CodeableConcept'
  else if (propName = 'author') then result := 'ContactDetail'
  else if (propName = 'editor') then result := 'ContactDetail'
  else if (propName = 'reviewer') then result := 'ContactDetail'
  else if (propName = 'endorser') then result := 'ContactDetail'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'synthesisType') then result := 'CodeableConcept'
  else if (propName = 'studyType') then result := 'CodeableConcept'
  else if (propName = 'population') then result := 'Reference'
  else if (propName = 'exposure') then result := 'Reference'
  else if (propName = 'exposureAlternative') then result := 'Reference'
  else if (propName = 'outcome') then result := 'Reference'
  else if (propName = 'sampleSize') then result := ''
  else if (propName = 'resultsByExposure') then result := ''
  else if (propName = 'effectEstimate') then result := ''
  else if (propName = 'certainty') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEffectEvidenceSynthesis.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value) {2}
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value) {2}
  else if (propName = 'editor') then deletePropertyValue('editor', EditorList, value) {2}
  else if (propName = 'reviewer') then deletePropertyValue('reviewer', ReviewerList, value) {2}
  else if (propName = 'endorser') then deletePropertyValue('endorser', EndorserList, value) {2}
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value) {2}
  else if (propName = 'synthesisType') then SynthesisTypeElement := nil
  else if (propName = 'studyType') then StudyTypeElement := nil
  else if (propName = 'population') then PopulationElement := nil
  else if (propName = 'exposure') then ExposureElement := nil
  else if (propName = 'exposureAlternative') then ExposureAlternativeElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'sampleSize') then SampleSizeElement := nil
  else if (propName = 'resultsByExposure') then deletePropertyValue('resultsByExposure', ResultsByExposureList, value) {2}
  else if (propName = 'effectEstimate') then deletePropertyValue('effectEstimate', EffectEstimateList, value) {2}
  else if (propName = 'certainty') then deletePropertyValue('certainty', CertaintyList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEffectEvidenceSynthesis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new){5b}
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new){5b}
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod{4}
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new) {2}
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new) {2}
  else if (propName = 'editor') then replacePropertyValue('editor', EditorList, existing, new) {2}
  else if (propName = 'reviewer') then replacePropertyValue('reviewer', ReviewerList, existing, new) {2}
  else if (propName = 'endorser') then replacePropertyValue('endorser', EndorserList, existing, new) {2}
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new) {2}
  else if (propName = 'synthesisType') then SynthesisTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'studyType') then StudyTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'population') then PopulationElement := new as TFhirReference{TFhirEvidenceVariable}{4}
  else if (propName = 'exposure') then ExposureElement := new as TFhirReference{TFhirEvidenceVariable}{4}
  else if (propName = 'exposureAlternative') then ExposureAlternativeElement := new as TFhirReference{TFhirEvidenceVariable}{4}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirReference{TFhirEvidenceVariable}{4}
  else if (propName = 'sampleSize') then SampleSizeElement := new as TFhirEffectEvidenceSynthesisSampleSize{4}
  else if (propName = 'resultsByExposure') then replacePropertyValue('resultsByExposure', ResultsByExposureList, existing, new) {2}
  else if (propName = 'effectEstimate') then replacePropertyValue('effectEstimate', EffectEstimateList, existing, new) {2}
  else if (propName = 'certainty') then replacePropertyValue('certainty', CertaintyList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEffectEvidenceSynthesis.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'topic') then TopicList.move(source, destination){2a}
  else if (propName = 'author') then AuthorList.move(source, destination){2a}
  else if (propName = 'editor') then EditorList.move(source, destination){2a}
  else if (propName = 'reviewer') then ReviewerList.move(source, destination){2a}
  else if (propName = 'endorser') then EndorserList.move(source, destination){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination){2a}
  else if (propName = 'resultsByExposure') then ResultsByExposureList.move(source, destination){2a}
  else if (propName = 'effectEstimate') then EffectEstimateList.move(source, destination){2a}
  else if (propName = 'certainty') then CertaintyList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEffectEvidenceSynthesis.fhirType : string;
begin
  result := 'EffectEvidenceSynthesis';
end;

function TFhirEffectEvidenceSynthesis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FnoteList) and isEmptyProp(FCopyright) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FtopicList) and isEmptyProp(FauthorList) and isEmptyProp(FeditorList) and isEmptyProp(FreviewerList) and isEmptyProp(FendorserList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(FSynthesisType) and isEmptyProp(FStudyType) and isEmptyProp(FPopulation) and isEmptyProp(FExposure) and isEmptyProp(FExposureAlternative) and isEmptyProp(FOutcome) and isEmptyProp(FSampleSize) and isEmptyProp(FresultsByExposureList) and isEmptyProp(FeffectEstimateList) and isEmptyProp(FcertaintyList);
end;

function TFhirEffectEvidenceSynthesis.equals(other : TObject) : boolean; 
var
  o : TFhirEffectEvidenceSynthesis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEffectEvidenceSynthesis)) then
    result := false
  else
  begin
    o := TFhirEffectEvidenceSynthesis(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(approvalDateElement, o.approvalDateElement, true) and 
      compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and 
      compareDeep(topicList, o.topicList, true) and compareDeep(authorList, o.authorList, true) and 
      compareDeep(editorList, o.editorList, true) and compareDeep(reviewerList, o.reviewerList, true) and 
      compareDeep(endorserList, o.endorserList, true) and compareDeep(relatedArtifactList, o.relatedArtifactList, true) and 
      compareDeep(synthesisTypeElement, o.synthesisTypeElement, true) and compareDeep(studyTypeElement, o.studyTypeElement, true) and 
      compareDeep(populationElement, o.populationElement, true) and compareDeep(exposureElement, o.exposureElement, true) and 
      compareDeep(exposureAlternativeElement, o.exposureAlternativeElement, true) and 
      compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(sampleSizeElement, o.sampleSizeElement, true) and 
      compareDeep(resultsByExposureList, o.resultsByExposureList, true) and compareDeep(effectEstimateList, o.effectEstimateList, true) and 
      compareDeep(certaintyList, o.certaintyList, true);
  end;
end;

function TFhirEffectEvidenceSynthesis.Link : TFhirEffectEvidenceSynthesis;
begin
  result := TFhirEffectEvidenceSynthesis(inherited Link);
end;

function TFhirEffectEvidenceSynthesis.Clone : TFhirEffectEvidenceSynthesis;
begin
  result := TFhirEffectEvidenceSynthesis(inherited Clone);
end;

procedure TFhirEffectEvidenceSynthesis.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('note');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('topic');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatedArtifact');
  fields.add('synthesisType');
  fields.add('studyType');
  fields.add('population');
  fields.add('exposure');
  fields.add('exposureAlternative');
  fields.add('outcome');
  fields.add('sampleSize');
  fields.add('resultsByExposure');
  fields.add('effectEstimate');
  fields.add('certainty');
end;

{ TFhirEffectEvidenceSynthesis }

Function TFhirEffectEvidenceSynthesis.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirEffectEvidenceSynthesis.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirEffectEvidenceSynthesis.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirEffectEvidenceSynthesis.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Procedure TFhirEffectEvidenceSynthesis.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirEffectEvidenceSynthesis.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirEffectEvidenceSynthesis.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Procedure TFhirEffectEvidenceSynthesis.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

Function TFhirEffectEvidenceSynthesis.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

Procedure TFhirEffectEvidenceSynthesis.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

Procedure TFhirEffectEvidenceSynthesis.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

Function TFhirEffectEvidenceSynthesis.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

Procedure TFhirEffectEvidenceSynthesis.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

Procedure TFhirEffectEvidenceSynthesis.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

Function TFhirEffectEvidenceSynthesis.GetTopicList : TFhirCodeableConceptList;
begin
  if FTopicList = nil then
    FTopicList := TFhirCodeableConceptList.Create;
  result := FTopicList;
end;

Function TFhirEffectEvidenceSynthesis.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

Function TFhirEffectEvidenceSynthesis.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

Function TFhirEffectEvidenceSynthesis.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

Function TFhirEffectEvidenceSynthesis.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

Function TFhirEffectEvidenceSynthesis.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

Function TFhirEffectEvidenceSynthesis.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

Function TFhirEffectEvidenceSynthesis.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

Function TFhirEffectEvidenceSynthesis.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

Function TFhirEffectEvidenceSynthesis.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

Function TFhirEffectEvidenceSynthesis.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

Function TFhirEffectEvidenceSynthesis.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

Procedure TFhirEffectEvidenceSynthesis.SetSynthesisType(value : TFhirCodeableConcept);
begin
  FSynthesisType.free;
  FSynthesisType := value;
end;

Procedure TFhirEffectEvidenceSynthesis.SetStudyType(value : TFhirCodeableConcept);
begin
  FStudyType.free;
  FStudyType := value;
end;

Procedure TFhirEffectEvidenceSynthesis.SetPopulation(value : TFhirReference{TFhirEvidenceVariable});
begin
  FPopulation.free;
  FPopulation := value;
end;

Procedure TFhirEffectEvidenceSynthesis.SetExposure(value : TFhirReference{TFhirEvidenceVariable});
begin
  FExposure.free;
  FExposure := value;
end;

Procedure TFhirEffectEvidenceSynthesis.SetExposureAlternative(value : TFhirReference{TFhirEvidenceVariable});
begin
  FExposureAlternative.free;
  FExposureAlternative := value;
end;

Procedure TFhirEffectEvidenceSynthesis.SetOutcome(value : TFhirReference{TFhirEvidenceVariable});
begin
  FOutcome.free;
  FOutcome := value;
end;

Procedure TFhirEffectEvidenceSynthesis.SetSampleSize(value : TFhirEffectEvidenceSynthesisSampleSize);
begin
  FSampleSize.free;
  FSampleSize := value;
end;

Function TFhirEffectEvidenceSynthesis.GetResultsByExposureList : TFhirEffectEvidenceSynthesisResultsByExposureList;
begin
  if FResultsByExposureList = nil then
    FResultsByExposureList := TFhirEffectEvidenceSynthesisResultsByExposureList.Create;
  result := FResultsByExposureList;
end;

Function TFhirEffectEvidenceSynthesis.GetHasResultsByExposureList : boolean;
begin
  result := (FResultsByExposureList <> nil) and (FResultsByExposureList.count > 0);
end;

Function TFhirEffectEvidenceSynthesis.GetEffectEstimateList : TFhirEffectEvidenceSynthesisEffectEstimateList;
begin
  if FEffectEstimateList = nil then
    FEffectEstimateList := TFhirEffectEvidenceSynthesisEffectEstimateList.Create;
  result := FEffectEstimateList;
end;

Function TFhirEffectEvidenceSynthesis.GetHasEffectEstimateList : boolean;
begin
  result := (FEffectEstimateList <> nil) and (FEffectEstimateList.count > 0);
end;

Function TFhirEffectEvidenceSynthesis.GetCertaintyList : TFhirEffectEvidenceSynthesisCertaintyList;
begin
  if FCertaintyList = nil then
    FCertaintyList := TFhirEffectEvidenceSynthesisCertaintyList.Create;
  result := FCertaintyList;
end;

Function TFhirEffectEvidenceSynthesis.GetHasCertaintyList : boolean;
begin
  result := (FCertaintyList <> nil) and (FCertaintyList.count > 0);
end;

function TFhirEffectEvidenceSynthesis.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FApprovalDate.sizeInBytes);
  inc(result, FLastReviewDate.sizeInBytes);
  inc(result, FEffectivePeriod.sizeInBytes);
  inc(result, FtopicList.sizeInBytes);
  inc(result, FauthorList.sizeInBytes);
  inc(result, FeditorList.sizeInBytes);
  inc(result, FreviewerList.sizeInBytes);
  inc(result, FendorserList.sizeInBytes);
  inc(result, FrelatedArtifactList.sizeInBytes);
  inc(result, FSynthesisType.sizeInBytes);
  inc(result, FStudyType.sizeInBytes);
  inc(result, FPopulation.sizeInBytes);
  inc(result, FExposure.sizeInBytes);
  inc(result, FExposureAlternative.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FSampleSize.sizeInBytes);
  inc(result, FresultsByExposureList.sizeInBytes);
  inc(result, FeffectEstimateList.sizeInBytes);
  inc(result, FcertaintyList.sizeInBytes);
end;

{ TFhirEffectEvidenceSynthesisListEnumerator }

Constructor TFhirEffectEvidenceSynthesisListEnumerator.Create(list : TFhirEffectEvidenceSynthesisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEffectEvidenceSynthesisListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEffectEvidenceSynthesisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEffectEvidenceSynthesisListEnumerator.GetCurrent : TFhirEffectEvidenceSynthesis;
begin
  Result := FList[FIndex];
end;

function TFhirEffectEvidenceSynthesisListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEffectEvidenceSynthesisList }
procedure TFhirEffectEvidenceSynthesisList.AddItem(value: TFhirEffectEvidenceSynthesis);
begin
  assert(value.ClassName = 'TFhirEffectEvidenceSynthesis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEffectEvidenceSynthesis');
  add(value);
end;

function TFhirEffectEvidenceSynthesisList.Append: TFhirEffectEvidenceSynthesis;
begin
  result := TFhirEffectEvidenceSynthesis.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEffectEvidenceSynthesisList.ClearItems;
begin
  Clear;
end;

function TFhirEffectEvidenceSynthesisList.GetEnumerator : TFhirEffectEvidenceSynthesisListEnumerator;
begin
  result := TFhirEffectEvidenceSynthesisListEnumerator.Create(self.link);
end;

function TFhirEffectEvidenceSynthesisList.Clone: TFhirEffectEvidenceSynthesisList;
begin
  result := TFhirEffectEvidenceSynthesisList(inherited Clone);
end;

function TFhirEffectEvidenceSynthesisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEffectEvidenceSynthesisList.GetItemN(index: Integer): TFhirEffectEvidenceSynthesis;
begin
  result := TFhirEffectEvidenceSynthesis(ObjectByIndex[index]);
end;

function TFhirEffectEvidenceSynthesisList.ItemClass: TFslObjectClass;
begin
  result := TFhirEffectEvidenceSynthesis;
end;
function TFhirEffectEvidenceSynthesisList.IndexOf(value: TFhirEffectEvidenceSynthesis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEffectEvidenceSynthesisList.Insert(index: Integer): TFhirEffectEvidenceSynthesis;
begin
  result := TFhirEffectEvidenceSynthesis.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEffectEvidenceSynthesisList.InsertItem(index: Integer; value: TFhirEffectEvidenceSynthesis);
begin
  assert(value is TFhirEffectEvidenceSynthesis);
  Inherited Insert(index, value);
end;

function TFhirEffectEvidenceSynthesisList.Item(index: Integer): TFhirEffectEvidenceSynthesis;
begin
  result := TFhirEffectEvidenceSynthesis(ObjectByIndex[index]);
end;

function TFhirEffectEvidenceSynthesisList.Link: TFhirEffectEvidenceSynthesisList;
begin
  result := TFhirEffectEvidenceSynthesisList(inherited Link);
end;

procedure TFhirEffectEvidenceSynthesisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEffectEvidenceSynthesisList.SetItemByIndex(index: Integer; value: TFhirEffectEvidenceSynthesis);
begin
  assert(value is TFhirEffectEvidenceSynthesis);
  FhirEffectEvidenceSyntheses[index] := value;
end;

procedure TFhirEffectEvidenceSynthesisList.SetItemN(index: Integer; value: TFhirEffectEvidenceSynthesis);
begin
  assert(value is TFhirEffectEvidenceSynthesis);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_EFFECTEVIDENCESYNTHESIS}

{$IFDEF FHIR_EVIDENCE}

{ TFhirEvidence }

constructor TFhirEvidence.Create;
begin
  inherited;
end;

destructor TFhirEvidence.Destroy;
begin
  FIdentifierList.Free;
  FShortTitle.free;
  FSubtitle.free;
  FNoteList.Free;
  FCopyright.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FTopicList.Free;
  FAuthorList.Free;
  FEditorList.Free;
  FReviewerList.Free;
  FEndorserList.Free;
  FRelatedArtifactList.Free;
  FExposureBackground.free;
  FExposureVariantList.Free;
  FOutcomeList.Free;
  inherited;
end;

function TFhirEvidence.GetResourceType : TFhirResourceType;
begin
  result := frtEvidence;
end;

procedure TFhirEvidence.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEvidence(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEvidence(oSource).FIdentifierList);
  end;
  shortTitleElement := TFhirEvidence(oSource).shortTitleElement.Clone;
  subtitleElement := TFhirEvidence(oSource).subtitleElement.Clone;
  if (TFhirEvidence(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidence(oSource).FNoteList);
  end;
  copyrightElement := TFhirEvidence(oSource).copyrightElement.Clone;
  approvalDateElement := TFhirEvidence(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirEvidence(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirEvidence(oSource).effectivePeriod.Clone;
  if (TFhirEvidence(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirCodeableConceptList.Create;
    FTopicList.Assign(TFhirEvidence(oSource).FTopicList);
  end;
  if (TFhirEvidence(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirContactDetailList.Create;
    FAuthorList.Assign(TFhirEvidence(oSource).FAuthorList);
  end;
  if (TFhirEvidence(oSource).FEditorList = nil) then
  begin
    FEditorList.free;
    FEditorList := nil;
  end
  else
  begin
    if FEditorList = nil then
      FEditorList := TFhirContactDetailList.Create;
    FEditorList.Assign(TFhirEvidence(oSource).FEditorList);
  end;
  if (TFhirEvidence(oSource).FReviewerList = nil) then
  begin
    FReviewerList.free;
    FReviewerList := nil;
  end
  else
  begin
    if FReviewerList = nil then
      FReviewerList := TFhirContactDetailList.Create;
    FReviewerList.Assign(TFhirEvidence(oSource).FReviewerList);
  end;
  if (TFhirEvidence(oSource).FEndorserList = nil) then
  begin
    FEndorserList.free;
    FEndorserList := nil;
  end
  else
  begin
    if FEndorserList = nil then
      FEndorserList := TFhirContactDetailList.Create;
    FEndorserList.Assign(TFhirEvidence(oSource).FEndorserList);
  end;
  if (TFhirEvidence(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirEvidence(oSource).FRelatedArtifactList);
  end;
  exposureBackground := TFhirEvidence(oSource).exposureBackground.Clone;
  if (TFhirEvidence(oSource).FExposureVariantList = nil) then
  begin
    FExposureVariantList.free;
    FExposureVariantList := nil;
  end
  else
  begin
    if FExposureVariantList = nil then
      FExposureVariantList := TFhirReferenceList{TFhirEvidenceVariable}.Create;
    FExposureVariantList.Assign(TFhirEvidence(oSource).FExposureVariantList);
  end;
  if (TFhirEvidence(oSource).FOutcomeList = nil) then
  begin
    FOutcomeList.free;
    FOutcomeList := nil;
  end
  else
  begin
    if FOutcomeList = nil then
      FOutcomeList := TFhirReferenceList{TFhirEvidenceVariable}.Create;
    FOutcomeList.Assign(TFhirEvidence(oSource).FOutcomeList);
  end;
end;

procedure TFhirEvidence.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'shortTitle') Then
     list.add(self.link, 'shortTitle', FShortTitle.Link);
  if (child_name = 'subtitle') Then
     list.add(self.link, 'subtitle', FSubtitle.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'editor') Then
    list.addAll(self, 'editor', FEditorList);
  if (child_name = 'reviewer') Then
    list.addAll(self, 'reviewer', FReviewerList);
  if (child_name = 'endorser') Then
    list.addAll(self, 'endorser', FEndorserList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'exposureBackground') Then
     list.add(self.link, 'exposureBackground', FExposureBackground.Link);
  if (child_name = 'exposureVariant') Then
    list.addAll(self, 'exposureVariant', FExposureVariantList);
  if (child_name = 'outcome') Then
    list.addAll(self, 'outcome', FOutcomeList);
end;

procedure TFhirEvidence.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'shortTitle', 'string', false, TFhirString, FShortTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subtitle', 'string', false, TFhirString, FSubtitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'topic', 'CodeableConcept', true, TFhirCodeableConcept, FTopicList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'author', 'ContactDetail', true, TFhirContactDetail, FAuthorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'editor', 'ContactDetail', true, TFhirContactDetail, FEditorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reviewer', 'ContactDetail', true, TFhirContactDetail, FReviewerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'endorser', 'ContactDetail', true, TFhirContactDetail, FEndorserList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'exposureBackground', 'Reference(EvidenceVariable)', false, TFhirReference{TFhirEvidenceVariable}, FExposureBackground.Link));{2}
  oList.add(TFHIRProperty.create(self, 'exposureVariant', 'Reference(EvidenceVariable)', true, TFhirReference{TFhirEvidenceVariable}, FExposureVariantList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'outcome', 'Reference(EvidenceVariable)', true, TFhirReference{TFhirEvidenceVariable}, FOutcomeList.Link)){3};
end;

function TFhirEvidence.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'shortTitle') then
  begin
    ShortTitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subtitle') then
  begin
    SubtitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'editor') then
  begin
    EditorList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'reviewer') then
  begin
    ReviewerList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'endorser') then
  begin
    EndorserList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact){2a};
    result := propValue;
  end
  else if (propName = 'exposureBackground') then
  begin
    ExposureBackground := propValue as TFhirReference{TFhirEvidenceVariable}{4b};
    result := propValue;
  end
  else if (propName = 'exposureVariant') then
  begin
    ExposureVariantList.add(propValue as TFhirReference{TFhirEvidenceVariable}){2a};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeList.add(propValue as TFhirReference{TFhirEvidenceVariable}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirEvidence.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'editor') then EditorList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'reviewer') then ReviewerList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'endorser') then EndorserList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact){2a}
  else if (propName = 'exposureVariant') then ExposureVariantList.insertItem(index, propValue as TFhirReference{TFhirEvidenceVariable}){2a}
  else if (propName = 'outcome') then OutcomeList.insertItem(index, propValue as TFhirReference{TFhirEvidenceVariable}){2a}
  else inherited;
end;

function TFhirEvidence.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'shortTitle') then result := TFhirString.create() {5b}
  else if (propName = 'subtitle') then result := TFhirString.create() {5b}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'approvalDate') then result := TFhirDate.create() {5b}
  else if (propName = 'lastReviewDate') then result := TFhirDate.create() {5b}
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'topic') then result := TopicList.new(){2}
  else if (propName = 'author') then result := AuthorList.new(){2}
  else if (propName = 'editor') then result := EditorList.new(){2}
  else if (propName = 'reviewer') then result := ReviewerList.new(){2}
  else if (propName = 'endorser') then result := EndorserList.new(){2}
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new(){2}
  else if (propName = 'exposureBackground') then result := TFhirReference{TFhirEvidenceVariable}.create(){4b}
  else if (propName = 'exposureVariant') then result := ExposureVariantList.new(){2}
  else if (propName = 'outcome') then result := OutcomeList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidence.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'shortTitle') then result := 'string'
  else if (propName = 'subtitle') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'topic') then result := 'CodeableConcept'
  else if (propName = 'author') then result := 'ContactDetail'
  else if (propName = 'editor') then result := 'ContactDetail'
  else if (propName = 'reviewer') then result := 'ContactDetail'
  else if (propName = 'endorser') then result := 'ContactDetail'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'exposureBackground') then result := 'Reference'
  else if (propName = 'exposureVariant') then result := 'Reference'
  else if (propName = 'outcome') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidence.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'shortTitle') then ShortTitleElement := nil
  else if (propName = 'subtitle') then SubtitleElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value) {2}
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value) {2}
  else if (propName = 'editor') then deletePropertyValue('editor', EditorList, value) {2}
  else if (propName = 'reviewer') then deletePropertyValue('reviewer', ReviewerList, value) {2}
  else if (propName = 'endorser') then deletePropertyValue('endorser', EndorserList, value) {2}
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value) {2}
  else if (propName = 'exposureBackground') then ExposureBackgroundElement := nil
  else if (propName = 'exposureVariant') then deletePropertyValue('exposureVariant', ExposureVariantList, value) {2}
  else if (propName = 'outcome') then deletePropertyValue('outcome', OutcomeList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidence.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'shortTitle') then ShortTitleElement := asString(new){5b}
  else if (propName = 'subtitle') then SubtitleElement := asString(new){5b}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new){5b}
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new){5b}
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod{4}
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new) {2}
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new) {2}
  else if (propName = 'editor') then replacePropertyValue('editor', EditorList, existing, new) {2}
  else if (propName = 'reviewer') then replacePropertyValue('reviewer', ReviewerList, existing, new) {2}
  else if (propName = 'endorser') then replacePropertyValue('endorser', EndorserList, existing, new) {2}
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new) {2}
  else if (propName = 'exposureBackground') then ExposureBackgroundElement := new as TFhirReference{TFhirEvidenceVariable}{4}
  else if (propName = 'exposureVariant') then replacePropertyValue('exposureVariant', ExposureVariantList, existing, new) {2}
  else if (propName = 'outcome') then replacePropertyValue('outcome', OutcomeList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidence.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'topic') then TopicList.move(source, destination){2a}
  else if (propName = 'author') then AuthorList.move(source, destination){2a}
  else if (propName = 'editor') then EditorList.move(source, destination){2a}
  else if (propName = 'reviewer') then ReviewerList.move(source, destination){2a}
  else if (propName = 'endorser') then EndorserList.move(source, destination){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination){2a}
  else if (propName = 'exposureVariant') then ExposureVariantList.move(source, destination){2a}
  else if (propName = 'outcome') then OutcomeList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidence.fhirType : string;
begin
  result := 'Evidence';
end;

function TFhirEvidence.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FShortTitle) and isEmptyProp(FSubtitle) and isEmptyProp(FnoteList) and isEmptyProp(FCopyright) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FtopicList) and isEmptyProp(FauthorList) and isEmptyProp(FeditorList) and isEmptyProp(FreviewerList) and isEmptyProp(FendorserList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(FExposureBackground) and isEmptyProp(FexposureVariantList) and isEmptyProp(FoutcomeList);
end;

function TFhirEvidence.equals(other : TObject) : boolean; 
var
  o : TFhirEvidence;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidence)) then
    result := false
  else
  begin
    o := TFhirEvidence(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(shortTitleElement, o.shortTitleElement, true) and 
      compareDeep(subtitleElement, o.subtitleElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(approvalDateElement, o.approvalDateElement, true) and 
      compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and 
      compareDeep(topicList, o.topicList, true) and compareDeep(authorList, o.authorList, true) and 
      compareDeep(editorList, o.editorList, true) and compareDeep(reviewerList, o.reviewerList, true) and 
      compareDeep(endorserList, o.endorserList, true) and compareDeep(relatedArtifactList, o.relatedArtifactList, true) and 
      compareDeep(exposureBackgroundElement, o.exposureBackgroundElement, true) and 
      compareDeep(exposureVariantList, o.exposureVariantList, true) and compareDeep(outcomeList, o.outcomeList, true);
  end;
end;

function TFhirEvidence.Link : TFhirEvidence;
begin
  result := TFhirEvidence(inherited Link);
end;

function TFhirEvidence.Clone : TFhirEvidence;
begin
  result := TFhirEvidence(inherited Clone);
end;

procedure TFhirEvidence.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('shortTitle');
  fields.add('subtitle');
  fields.add('status');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('note');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('topic');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatedArtifact');
  fields.add('exposureBackground');
  fields.add('exposureVariant');
  fields.add('outcome');
end;

{ TFhirEvidence }

Function TFhirEvidence.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirEvidence.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirEvidence.SetShortTitle(value : TFhirString);
begin
  FShortTitle.free;
  FShortTitle := value;
end;

Function TFhirEvidence.GetShortTitleST : String;
begin
  if FShortTitle = nil then
    result := ''
  else
    result := FShortTitle.value;
end;

Procedure TFhirEvidence.SetShortTitleST(value : String);
begin
  if value <> '' then
  begin
    if FShortTitle = nil then
      FShortTitle := TFhirString.create;
    FShortTitle.value := value
  end
  else if FShortTitle <> nil then
    FShortTitle.value := '';
end;

Procedure TFhirEvidence.SetSubtitle(value : TFhirString);
begin
  FSubtitle.free;
  FSubtitle := value;
end;

Function TFhirEvidence.GetSubtitleST : String;
begin
  if FSubtitle = nil then
    result := ''
  else
    result := FSubtitle.value;
end;

Procedure TFhirEvidence.SetSubtitleST(value : String);
begin
  if value <> '' then
  begin
    if FSubtitle = nil then
      FSubtitle := TFhirString.create;
    FSubtitle.value := value
  end
  else if FSubtitle <> nil then
    FSubtitle.value := '';
end;

Function TFhirEvidence.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirEvidence.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Procedure TFhirEvidence.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirEvidence.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirEvidence.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Procedure TFhirEvidence.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

Function TFhirEvidence.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

Procedure TFhirEvidence.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

Procedure TFhirEvidence.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

Function TFhirEvidence.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

Procedure TFhirEvidence.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

Procedure TFhirEvidence.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

Function TFhirEvidence.GetTopicList : TFhirCodeableConceptList;
begin
  if FTopicList = nil then
    FTopicList := TFhirCodeableConceptList.Create;
  result := FTopicList;
end;

Function TFhirEvidence.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

Function TFhirEvidence.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

Function TFhirEvidence.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

Function TFhirEvidence.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

Function TFhirEvidence.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

Function TFhirEvidence.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

Function TFhirEvidence.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

Function TFhirEvidence.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

Function TFhirEvidence.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

Function TFhirEvidence.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

Function TFhirEvidence.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

Procedure TFhirEvidence.SetExposureBackground(value : TFhirReference{TFhirEvidenceVariable});
begin
  FExposureBackground.free;
  FExposureBackground := value;
end;

Function TFhirEvidence.GetExposureVariantList : TFhirReferenceList{TFhirEvidenceVariable};
begin
  if FExposureVariantList = nil then
    FExposureVariantList := TFhirReferenceList{TFhirEvidenceVariable}.Create;
  result := FExposureVariantList;
end;

Function TFhirEvidence.GetHasExposureVariantList : boolean;
begin
  result := (FExposureVariantList <> nil) and (FExposureVariantList.count > 0);
end;

Function TFhirEvidence.GetOutcomeList : TFhirReferenceList{TFhirEvidenceVariable};
begin
  if FOutcomeList = nil then
    FOutcomeList := TFhirReferenceList{TFhirEvidenceVariable}.Create;
  result := FOutcomeList;
end;

Function TFhirEvidence.GetHasOutcomeList : boolean;
begin
  result := (FOutcomeList <> nil) and (FOutcomeList.count > 0);
end;

function TFhirEvidence.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FShortTitle.sizeInBytes);
  inc(result, FSubtitle.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FApprovalDate.sizeInBytes);
  inc(result, FLastReviewDate.sizeInBytes);
  inc(result, FEffectivePeriod.sizeInBytes);
  inc(result, FtopicList.sizeInBytes);
  inc(result, FauthorList.sizeInBytes);
  inc(result, FeditorList.sizeInBytes);
  inc(result, FreviewerList.sizeInBytes);
  inc(result, FendorserList.sizeInBytes);
  inc(result, FrelatedArtifactList.sizeInBytes);
  inc(result, FExposureBackground.sizeInBytes);
  inc(result, FexposureVariantList.sizeInBytes);
  inc(result, FoutcomeList.sizeInBytes);
end;

{ TFhirEvidenceListEnumerator }

Constructor TFhirEvidenceListEnumerator.Create(list : TFhirEvidenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceListEnumerator.GetCurrent : TFhirEvidence;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEvidenceList }
procedure TFhirEvidenceList.AddItem(value: TFhirEvidence);
begin
  assert(value.ClassName = 'TFhirEvidence', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidence');
  add(value);
end;

function TFhirEvidenceList.Append: TFhirEvidence;
begin
  result := TFhirEvidence.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceList.GetEnumerator : TFhirEvidenceListEnumerator;
begin
  result := TFhirEvidenceListEnumerator.Create(self.link);
end;

function TFhirEvidenceList.Clone: TFhirEvidenceList;
begin
  result := TFhirEvidenceList(inherited Clone);
end;

function TFhirEvidenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceList.GetItemN(index: Integer): TFhirEvidence;
begin
  result := TFhirEvidence(ObjectByIndex[index]);
end;

function TFhirEvidenceList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidence;
end;
function TFhirEvidenceList.IndexOf(value: TFhirEvidence): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceList.Insert(index: Integer): TFhirEvidence;
begin
  result := TFhirEvidence.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceList.InsertItem(index: Integer; value: TFhirEvidence);
begin
  assert(value is TFhirEvidence);
  Inherited Insert(index, value);
end;

function TFhirEvidenceList.Item(index: Integer): TFhirEvidence;
begin
  result := TFhirEvidence(ObjectByIndex[index]);
end;

function TFhirEvidenceList.Link: TFhirEvidenceList;
begin
  result := TFhirEvidenceList(inherited Link);
end;

procedure TFhirEvidenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceList.SetItemByIndex(index: Integer; value: TFhirEvidence);
begin
  assert(value is TFhirEvidence);
  FhirEvidences[index] := value;
end;

procedure TFhirEvidenceList.SetItemN(index: Integer; value: TFhirEvidence);
begin
  assert(value is TFhirEvidence);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_EVIDENCE}

{$IFDEF FHIR_EVIDENCEVARIABLE}

{ TFhirEvidenceVariableCharacteristic }

constructor TFhirEvidenceVariableCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirEvidenceVariableCharacteristic.Destroy;
begin
  FDescription.free;
  FDefinition.free;
  FUsageContextList.Free;
  FExclude.free;
  FParticipantEffective.free;
  FTimeFromStart.free;
  FGroupMeasure.free;
  inherited;
end;

procedure TFhirEvidenceVariableCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirEvidenceVariableCharacteristic(oSource).descriptionElement.Clone;
  definition := TFhirEvidenceVariableCharacteristic(oSource).definition.Clone;
  if (TFhirEvidenceVariableCharacteristic(oSource).FUsageContextList = nil) then
  begin
    FUsageContextList.free;
    FUsageContextList := nil;
  end
  else
  begin
    if FUsageContextList = nil then
      FUsageContextList := TFhirUsageContextList.Create;
    FUsageContextList.Assign(TFhirEvidenceVariableCharacteristic(oSource).FUsageContextList);
  end;
  excludeElement := TFhirEvidenceVariableCharacteristic(oSource).excludeElement.Clone;
  participantEffective := TFhirEvidenceVariableCharacteristic(oSource).participantEffective.Clone;
  timeFromStart := TFhirEvidenceVariableCharacteristic(oSource).timeFromStart.Clone;
  FGroupMeasure := TFhirEvidenceVariableCharacteristic(oSource).FGroupMeasure.Link;
end;

procedure TFhirEvidenceVariableCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'definition[x]') or (child_name = 'definition') Then
     list.add(self.link, 'definition[x]', FDefinition.Link);
  if (child_name = 'usageContext') Then
    list.addAll(self, 'usageContext', FUsageContextList);
  if (child_name = 'exclude') Then
     list.add(self.link, 'exclude', FExclude.Link);
  if (child_name = 'participantEffective[x]') or (child_name = 'participantEffective') Then
     list.add(self.link, 'participantEffective[x]', FParticipantEffective.Link);
  if (child_name = 'timeFromStart') Then
     list.add(self.link, 'timeFromStart', FTimeFromStart.Link);
  if (child_name = 'groupMeasure') Then
     list.add(self.link, 'groupMeasure', FGroupMeasure.Link);
end;

procedure TFhirEvidenceVariableCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition[x]', 'Reference(Group)|canonical|CodeableConcept|Expression|DataRequirement|TriggerDefinition', false, TFhirType, FDefinition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'usageContext', 'UsageContext', true, TFhirUsageContext, FUsageContextList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'exclude', 'boolean', false, TFhirBoolean, FExclude.Link));{2}
  oList.add(TFHIRProperty.create(self, 'participantEffective[x]', 'dateTime|Period|Duration|Timing', false, TFhirType, FParticipantEffective.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timeFromStart', 'Duration', false, TFhirDuration, FTimeFromStart.Link));{2}
  oList.add(TFHIRProperty.create(self, 'groupMeasure', 'code', false, TFHIREnum, FGroupMeasure.Link));{1}
end;

function TFhirEvidenceVariableCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'definition', ['Reference', 'Canonical', 'CodeableConcept', 'Expression', 'DataRequirement', 'TriggerDefinition'])) then
  begin
    Definition := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'usageContext') then
  begin
    UsageContextList.add(propValue as TFhirUsageContext){2a};
    result := propValue;
  end
  else if (propName = 'exclude') then
  begin
    ExcludeElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'participantEffective', ['DateTime', 'Period', 'Duration', 'Timing'])) then
  begin
    ParticipantEffective := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'timeFromStart') then
  begin
    TimeFromStart := propValue as TFhirDuration{4b};
    result := propValue;
  end
  else if (propName = 'groupMeasure') then
  begin
    GroupMeasureElement := asEnum(SYSTEMS_TFhirGroupMeasureEnum, CODES_TFhirGroupMeasureEnum, propValue);
    result := propValue
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceVariableCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'usageContext') then UsageContextList.insertItem(index, propValue as TFhirUsageContext){2a}
  else inherited;
end;

function TFhirEvidenceVariableCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'definition', ['Reference', 'Canonical', 'CodeableConcept', 'Expression', 'DataRequirement', 'TriggerDefinition'])) then raise EFHIRException.create('Cannot make property Definition'){4x}
  else if (propName = 'usageContext') then result := UsageContextList.new(){2}
  else if (propName = 'exclude') then result := TFhirBoolean.create() {5b}
  else if (isMatchingName(propName, 'participantEffective', ['DateTime', 'Period', 'Duration', 'Timing'])) then raise EFHIRException.create('Cannot make property ParticipantEffective'){4x}
  else if (propName = 'timeFromStart') then result := TFhirDuration.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceVariableCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'definition[x]') then result := 'Reference|canonical|CodeableConcept|Expression|DataRequirement|TriggerDefinition'
  else if (propName = 'usageContext') then result := 'UsageContext'
  else if (propName = 'exclude') then result := 'boolean'
  else if (propName = 'participantEffective[x]') then result := 'dateTime|Period|Duration|Timing'
  else if (propName = 'timeFromStart') then result := 'Duration'
  else if (propName = 'groupMeasure') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceVariableCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (isMatchingName(propName, 'definition', ['Reference', 'Canonical', 'CodeableConcept', 'Expression', 'DataRequirement', 'TriggerDefinition'])) then DefinitionElement := nil{4x}
  else if (propName = 'usageContext') then deletePropertyValue('usageContext', UsageContextList, value) {2}
  else if (propName = 'exclude') then ExcludeElement := nil
  else if (isMatchingName(propName, 'participantEffective', ['DateTime', 'Period', 'Duration', 'Timing'])) then ParticipantEffectiveElement := nil{4x}
  else if (propName = 'timeFromStart') then TimeFromStartElement := nil
  else if (propName = 'groupMeasure') then GroupMeasureElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceVariableCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (isMatchingName(propName, 'definition', ['Reference', 'Canonical', 'CodeableConcept', 'Expression', 'DataRequirement', 'TriggerDefinition'])) then DefinitionElement := new as TFhirType{4x}
  else if (propName = 'usageContext') then replacePropertyValue('usageContext', UsageContextList, existing, new) {2}
  else if (propName = 'exclude') then ExcludeElement := asBoolean(new){5b}
  else if (isMatchingName(propName, 'participantEffective', ['DateTime', 'Period', 'Duration', 'Timing'])) then ParticipantEffectiveElement := new as TFhirType{4x}
  else if (propName = 'timeFromStart') then TimeFromStartElement := new as TFhirDuration{4}
  else if (propName = 'groupMeasure') then GroupMeasureElement := asEnum(SYSTEMS_TFhirGroupMeasureEnum, CODES_TFhirGroupMeasureEnum, new){4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceVariableCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'usageContext') then UsageContextList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceVariableCharacteristic.fhirType : string;
begin
  result := 'characteristic';
end;

function TFhirEvidenceVariableCharacteristic.Link : TFhirEvidenceVariableCharacteristic;
begin
  result := TFhirEvidenceVariableCharacteristic(inherited Link);
end;

function TFhirEvidenceVariableCharacteristic.Clone : TFhirEvidenceVariableCharacteristic;
begin
  result := TFhirEvidenceVariableCharacteristic(inherited Clone);
end;

function TFhirEvidenceVariableCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceVariableCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceVariableCharacteristic)) then
    result := false
  else
  begin
    o := TFhirEvidenceVariableCharacteristic(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(definitionElement, o.definitionElement, true) and 
      compareDeep(usageContextList, o.usageContextList, true) and compareDeep(excludeElement, o.excludeElement, true) and 
      compareDeep(participantEffectiveElement, o.participantEffectiveElement, true) and 
      compareDeep(timeFromStartElement, o.timeFromStartElement, true) and compareDeep(groupMeasureElement, o.groupMeasureElement, true);
  end;
end;

function TFhirEvidenceVariableCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FDefinition) and isEmptyProp(FusageContextList) and isEmptyProp(FExclude) and isEmptyProp(FParticipantEffective) and isEmptyProp(FTimeFromStart) and isEmptyProp(FGroupMeasure);
end;

procedure TFhirEvidenceVariableCharacteristic.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('definition[x]');
  fields.add('usageContext');
  fields.add('exclude');
  fields.add('participantEffective[x]');
  fields.add('timeFromStart');
  fields.add('groupMeasure');
end;

{ TFhirEvidenceVariableCharacteristic }

Procedure TFhirEvidenceVariableCharacteristic.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirEvidenceVariableCharacteristic.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirEvidenceVariableCharacteristic.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirEvidenceVariableCharacteristic.SetDefinition(value : TFhirType);
begin
  FDefinition.free;
  FDefinition := value;
end;

Function TFhirEvidenceVariableCharacteristic.GetUsageContextList : TFhirUsageContextList;
begin
  if FUsageContextList = nil then
    FUsageContextList := TFhirUsageContextList.Create;
  result := FUsageContextList;
end;

Function TFhirEvidenceVariableCharacteristic.GetHasUsageContextList : boolean;
begin
  result := (FUsageContextList <> nil) and (FUsageContextList.count > 0);
end;

Procedure TFhirEvidenceVariableCharacteristic.SetExclude(value : TFhirBoolean);
begin
  FExclude.free;
  FExclude := value;
end;

Function TFhirEvidenceVariableCharacteristic.GetExcludeST : Boolean;
begin
  if FExclude = nil then
    result := false
  else
    result := FExclude.value;
end;

Procedure TFhirEvidenceVariableCharacteristic.SetExcludeST(value : Boolean);
begin
  if FExclude = nil then
    FExclude := TFhirBoolean.create;
  FExclude.value := value
end;

Procedure TFhirEvidenceVariableCharacteristic.SetParticipantEffective(value : TFhirType);
begin
  FParticipantEffective.free;
  FParticipantEffective := value;
end;

Procedure TFhirEvidenceVariableCharacteristic.SetTimeFromStart(value : TFhirDuration);
begin
  FTimeFromStart.free;
  FTimeFromStart := value;
end;

Procedure TFhirEvidenceVariableCharacteristic.SetGroupMeasure(value : TFhirEnum);
begin
  FGroupMeasure.free;
  FGroupMeasure := value;
end;

Function TFhirEvidenceVariableCharacteristic.GetGroupMeasureST : TFhirGroupMeasureEnum;
begin
  if FGroupMeasure = nil then
    result := TFhirGroupMeasureEnum(0)
  else
    result := TFhirGroupMeasureEnum(StringArrayIndexOfSensitive(CODES_TFhirGroupMeasureEnum, FGroupMeasure.value));
end;

Procedure TFhirEvidenceVariableCharacteristic.SetGroupMeasureST(value : TFhirGroupMeasureEnum);
begin
  if ord(value) = 0 then
    GroupMeasureElement := nil
  else
    GroupMeasureElement := TFhirEnum.create(SYSTEMS_TFhirGroupMeasureEnum[value], CODES_TFhirGroupMeasureEnum[value]);
end;

function TFhirEvidenceVariableCharacteristic.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDescription.sizeInBytes);
  inc(result, FDefinition.sizeInBytes);
  inc(result, FusageContextList.sizeInBytes);
  inc(result, FExclude.sizeInBytes);
  inc(result, FParticipantEffective.sizeInBytes);
  inc(result, FTimeFromStart.sizeInBytes);
  inc(result, FGroupMeasure.sizeInBytes);
end;

{ TFhirEvidenceVariableCharacteristicListEnumerator }

Constructor TFhirEvidenceVariableCharacteristicListEnumerator.Create(list : TFhirEvidenceVariableCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceVariableCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceVariableCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceVariableCharacteristicListEnumerator.GetCurrent : TFhirEvidenceVariableCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceVariableCharacteristicListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEvidenceVariableCharacteristicList }
procedure TFhirEvidenceVariableCharacteristicList.AddItem(value: TFhirEvidenceVariableCharacteristic);
begin
  assert(value.ClassName = 'TFhirEvidenceVariableCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceVariableCharacteristic');
  add(value);
end;

function TFhirEvidenceVariableCharacteristicList.Append: TFhirEvidenceVariableCharacteristic;
begin
  result := TFhirEvidenceVariableCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceVariableCharacteristicList.GetEnumerator : TFhirEvidenceVariableCharacteristicListEnumerator;
begin
  result := TFhirEvidenceVariableCharacteristicListEnumerator.Create(self.link);
end;

function TFhirEvidenceVariableCharacteristicList.Clone: TFhirEvidenceVariableCharacteristicList;
begin
  result := TFhirEvidenceVariableCharacteristicList(inherited Clone);
end;

function TFhirEvidenceVariableCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceVariableCharacteristicList.GetItemN(index: Integer): TFhirEvidenceVariableCharacteristic;
begin
  result := TFhirEvidenceVariableCharacteristic(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceVariableCharacteristic;
end;
function TFhirEvidenceVariableCharacteristicList.IndexOf(value: TFhirEvidenceVariableCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceVariableCharacteristicList.Insert(index: Integer): TFhirEvidenceVariableCharacteristic;
begin
  result := TFhirEvidenceVariableCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableCharacteristicList.InsertItem(index: Integer; value: TFhirEvidenceVariableCharacteristic);
begin
  assert(value is TFhirEvidenceVariableCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirEvidenceVariableCharacteristicList.Item(index: Integer): TFhirEvidenceVariableCharacteristic;
begin
  result := TFhirEvidenceVariableCharacteristic(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableCharacteristicList.Link: TFhirEvidenceVariableCharacteristicList;
begin
  result := TFhirEvidenceVariableCharacteristicList(inherited Link);
end;

procedure TFhirEvidenceVariableCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceVariableCharacteristicList.SetItemByIndex(index: Integer; value: TFhirEvidenceVariableCharacteristic);
begin
  assert(value is TFhirEvidenceVariableCharacteristic);
  FhirEvidenceVariableCharacteristics[index] := value;
end;

procedure TFhirEvidenceVariableCharacteristicList.SetItemN(index: Integer; value: TFhirEvidenceVariableCharacteristic);
begin
  assert(value is TFhirEvidenceVariableCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceVariable }

constructor TFhirEvidenceVariable.Create;
begin
  inherited;
end;

destructor TFhirEvidenceVariable.Destroy;
begin
  FIdentifierList.Free;
  FShortTitle.free;
  FSubtitle.free;
  FNoteList.Free;
  FCopyright.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FTopicList.Free;
  FAuthorList.Free;
  FEditorList.Free;
  FReviewerList.Free;
  FEndorserList.Free;
  FRelatedArtifactList.Free;
  FType_.free;
  FCharacteristicList.Free;
  inherited;
end;

function TFhirEvidenceVariable.GetResourceType : TFhirResourceType;
begin
  result := frtEvidenceVariable;
end;

procedure TFhirEvidenceVariable.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEvidenceVariable(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEvidenceVariable(oSource).FIdentifierList);
  end;
  shortTitleElement := TFhirEvidenceVariable(oSource).shortTitleElement.Clone;
  subtitleElement := TFhirEvidenceVariable(oSource).subtitleElement.Clone;
  if (TFhirEvidenceVariable(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidenceVariable(oSource).FNoteList);
  end;
  copyrightElement := TFhirEvidenceVariable(oSource).copyrightElement.Clone;
  approvalDateElement := TFhirEvidenceVariable(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirEvidenceVariable(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirEvidenceVariable(oSource).effectivePeriod.Clone;
  if (TFhirEvidenceVariable(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirCodeableConceptList.Create;
    FTopicList.Assign(TFhirEvidenceVariable(oSource).FTopicList);
  end;
  if (TFhirEvidenceVariable(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirContactDetailList.Create;
    FAuthorList.Assign(TFhirEvidenceVariable(oSource).FAuthorList);
  end;
  if (TFhirEvidenceVariable(oSource).FEditorList = nil) then
  begin
    FEditorList.free;
    FEditorList := nil;
  end
  else
  begin
    if FEditorList = nil then
      FEditorList := TFhirContactDetailList.Create;
    FEditorList.Assign(TFhirEvidenceVariable(oSource).FEditorList);
  end;
  if (TFhirEvidenceVariable(oSource).FReviewerList = nil) then
  begin
    FReviewerList.free;
    FReviewerList := nil;
  end
  else
  begin
    if FReviewerList = nil then
      FReviewerList := TFhirContactDetailList.Create;
    FReviewerList.Assign(TFhirEvidenceVariable(oSource).FReviewerList);
  end;
  if (TFhirEvidenceVariable(oSource).FEndorserList = nil) then
  begin
    FEndorserList.free;
    FEndorserList := nil;
  end
  else
  begin
    if FEndorserList = nil then
      FEndorserList := TFhirContactDetailList.Create;
    FEndorserList.Assign(TFhirEvidenceVariable(oSource).FEndorserList);
  end;
  if (TFhirEvidenceVariable(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirEvidenceVariable(oSource).FRelatedArtifactList);
  end;
  FType_ := TFhirEvidenceVariable(oSource).FType_.Link;
  if (TFhirEvidenceVariable(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirEvidenceVariableCharacteristicList.Create;
    FCharacteristicList.Assign(TFhirEvidenceVariable(oSource).FCharacteristicList);
  end;
end;

procedure TFhirEvidenceVariable.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'shortTitle') Then
     list.add(self.link, 'shortTitle', FShortTitle.Link);
  if (child_name = 'subtitle') Then
     list.add(self.link, 'subtitle', FSubtitle.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'editor') Then
    list.addAll(self, 'editor', FEditorList);
  if (child_name = 'reviewer') Then
    list.addAll(self, 'reviewer', FReviewerList);
  if (child_name = 'endorser') Then
    list.addAll(self, 'endorser', FEndorserList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
end;

procedure TFhirEvidenceVariable.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'shortTitle', 'string', false, TFhirString, FShortTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subtitle', 'string', false, TFhirString, FSubtitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'topic', 'CodeableConcept', true, TFhirCodeableConcept, FTopicList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'author', 'ContactDetail', true, TFhirContactDetail, FAuthorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'editor', 'ContactDetail', true, TFhirContactDetail, FEditorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reviewer', 'ContactDetail', true, TFhirContactDetail, FReviewerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'endorser', 'ContactDetail', true, TFhirContactDetail, FEndorserList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'characteristic', '', true, TFhirEvidenceVariableCharacteristic, FCharacteristicList.Link)){3};
end;

function TFhirEvidenceVariable.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'shortTitle') then
  begin
    ShortTitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subtitle') then
  begin
    SubtitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'editor') then
  begin
    EditorList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'reviewer') then
  begin
    ReviewerList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'endorser') then
  begin
    EndorserList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirVariableTypeEnum, CODES_TFhirVariableTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirEvidenceVariableCharacteristic){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirEvidenceVariable.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'editor') then EditorList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'reviewer') then ReviewerList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'endorser') then EndorserList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact){2a}
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirEvidenceVariableCharacteristic){2a}
  else inherited;
end;

function TFhirEvidenceVariable.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'shortTitle') then result := TFhirString.create() {5b}
  else if (propName = 'subtitle') then result := TFhirString.create() {5b}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'approvalDate') then result := TFhirDate.create() {5b}
  else if (propName = 'lastReviewDate') then result := TFhirDate.create() {5b}
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'topic') then result := TopicList.new(){2}
  else if (propName = 'author') then result := AuthorList.new(){2}
  else if (propName = 'editor') then result := EditorList.new(){2}
  else if (propName = 'reviewer') then result := ReviewerList.new(){2}
  else if (propName = 'endorser') then result := EndorserList.new(){2}
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new(){2}
  else if (propName = 'characteristic') then result := CharacteristicList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceVariable.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'shortTitle') then result := 'string'
  else if (propName = 'subtitle') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'topic') then result := 'CodeableConcept'
  else if (propName = 'author') then result := 'ContactDetail'
  else if (propName = 'editor') then result := 'ContactDetail'
  else if (propName = 'reviewer') then result := 'ContactDetail'
  else if (propName = 'endorser') then result := 'ContactDetail'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'characteristic') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceVariable.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'shortTitle') then ShortTitleElement := nil
  else if (propName = 'subtitle') then SubtitleElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value) {2}
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value) {2}
  else if (propName = 'editor') then deletePropertyValue('editor', EditorList, value) {2}
  else if (propName = 'reviewer') then deletePropertyValue('reviewer', ReviewerList, value) {2}
  else if (propName = 'endorser') then deletePropertyValue('endorser', EndorserList, value) {2}
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceVariable.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'shortTitle') then ShortTitleElement := asString(new){5b}
  else if (propName = 'subtitle') then SubtitleElement := asString(new){5b}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new){5b}
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new){5b}
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod{4}
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new) {2}
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new) {2}
  else if (propName = 'editor') then replacePropertyValue('editor', EditorList, existing, new) {2}
  else if (propName = 'reviewer') then replacePropertyValue('reviewer', ReviewerList, existing, new) {2}
  else if (propName = 'endorser') then replacePropertyValue('endorser', EndorserList, existing, new) {2}
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new) {2}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirVariableTypeEnum, CODES_TFhirVariableTypeEnum, new){4}
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceVariable.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'topic') then TopicList.move(source, destination){2a}
  else if (propName = 'author') then AuthorList.move(source, destination){2a}
  else if (propName = 'editor') then EditorList.move(source, destination){2a}
  else if (propName = 'reviewer') then ReviewerList.move(source, destination){2a}
  else if (propName = 'endorser') then EndorserList.move(source, destination){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination){2a}
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceVariable.fhirType : string;
begin
  result := 'EvidenceVariable';
end;

function TFhirEvidenceVariable.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FShortTitle) and isEmptyProp(FSubtitle) and isEmptyProp(FnoteList) and isEmptyProp(FCopyright) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FtopicList) and isEmptyProp(FauthorList) and isEmptyProp(FeditorList) and isEmptyProp(FreviewerList) and isEmptyProp(FendorserList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(FType_) and isEmptyProp(FcharacteristicList);
end;

function TFhirEvidenceVariable.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceVariable;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceVariable)) then
    result := false
  else
  begin
    o := TFhirEvidenceVariable(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(shortTitleElement, o.shortTitleElement, true) and 
      compareDeep(subtitleElement, o.subtitleElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(approvalDateElement, o.approvalDateElement, true) and 
      compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and 
      compareDeep(topicList, o.topicList, true) and compareDeep(authorList, o.authorList, true) and 
      compareDeep(editorList, o.editorList, true) and compareDeep(reviewerList, o.reviewerList, true) and 
      compareDeep(endorserList, o.endorserList, true) and compareDeep(relatedArtifactList, o.relatedArtifactList, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(characteristicList, o.characteristicList, true);
  end;
end;

function TFhirEvidenceVariable.Link : TFhirEvidenceVariable;
begin
  result := TFhirEvidenceVariable(inherited Link);
end;

function TFhirEvidenceVariable.Clone : TFhirEvidenceVariable;
begin
  result := TFhirEvidenceVariable(inherited Clone);
end;

procedure TFhirEvidenceVariable.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('shortTitle');
  fields.add('subtitle');
  fields.add('status');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('note');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('topic');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatedArtifact');
  fields.add('type');
  fields.add('characteristic');
end;

{ TFhirEvidenceVariable }

Function TFhirEvidenceVariable.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirEvidenceVariable.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirEvidenceVariable.SetShortTitle(value : TFhirString);
begin
  FShortTitle.free;
  FShortTitle := value;
end;

Function TFhirEvidenceVariable.GetShortTitleST : String;
begin
  if FShortTitle = nil then
    result := ''
  else
    result := FShortTitle.value;
end;

Procedure TFhirEvidenceVariable.SetShortTitleST(value : String);
begin
  if value <> '' then
  begin
    if FShortTitle = nil then
      FShortTitle := TFhirString.create;
    FShortTitle.value := value
  end
  else if FShortTitle <> nil then
    FShortTitle.value := '';
end;

Procedure TFhirEvidenceVariable.SetSubtitle(value : TFhirString);
begin
  FSubtitle.free;
  FSubtitle := value;
end;

Function TFhirEvidenceVariable.GetSubtitleST : String;
begin
  if FSubtitle = nil then
    result := ''
  else
    result := FSubtitle.value;
end;

Procedure TFhirEvidenceVariable.SetSubtitleST(value : String);
begin
  if value <> '' then
  begin
    if FSubtitle = nil then
      FSubtitle := TFhirString.create;
    FSubtitle.value := value
  end
  else if FSubtitle <> nil then
    FSubtitle.value := '';
end;

Function TFhirEvidenceVariable.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirEvidenceVariable.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Procedure TFhirEvidenceVariable.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirEvidenceVariable.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirEvidenceVariable.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Procedure TFhirEvidenceVariable.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

Function TFhirEvidenceVariable.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

Procedure TFhirEvidenceVariable.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

Procedure TFhirEvidenceVariable.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

Function TFhirEvidenceVariable.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

Procedure TFhirEvidenceVariable.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

Procedure TFhirEvidenceVariable.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

Function TFhirEvidenceVariable.GetTopicList : TFhirCodeableConceptList;
begin
  if FTopicList = nil then
    FTopicList := TFhirCodeableConceptList.Create;
  result := FTopicList;
end;

Function TFhirEvidenceVariable.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

Function TFhirEvidenceVariable.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

Function TFhirEvidenceVariable.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

Function TFhirEvidenceVariable.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

Function TFhirEvidenceVariable.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

Function TFhirEvidenceVariable.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

Function TFhirEvidenceVariable.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

Function TFhirEvidenceVariable.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

Function TFhirEvidenceVariable.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

Function TFhirEvidenceVariable.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

Function TFhirEvidenceVariable.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

Procedure TFhirEvidenceVariable.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirEvidenceVariable.GetType_ST : TFhirVariableTypeEnum;
begin
  if FType_ = nil then
    result := TFhirVariableTypeEnum(0)
  else
    result := TFhirVariableTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirVariableTypeEnum, FType_.value));
end;

Procedure TFhirEvidenceVariable.SetType_ST(value : TFhirVariableTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirVariableTypeEnum[value], CODES_TFhirVariableTypeEnum[value]);
end;

Function TFhirEvidenceVariable.GetCharacteristicList : TFhirEvidenceVariableCharacteristicList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirEvidenceVariableCharacteristicList.Create;
  result := FCharacteristicList;
end;

Function TFhirEvidenceVariable.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

function TFhirEvidenceVariable.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FShortTitle.sizeInBytes);
  inc(result, FSubtitle.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FApprovalDate.sizeInBytes);
  inc(result, FLastReviewDate.sizeInBytes);
  inc(result, FEffectivePeriod.sizeInBytes);
  inc(result, FtopicList.sizeInBytes);
  inc(result, FauthorList.sizeInBytes);
  inc(result, FeditorList.sizeInBytes);
  inc(result, FreviewerList.sizeInBytes);
  inc(result, FendorserList.sizeInBytes);
  inc(result, FrelatedArtifactList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FcharacteristicList.sizeInBytes);
end;

{ TFhirEvidenceVariableListEnumerator }

Constructor TFhirEvidenceVariableListEnumerator.Create(list : TFhirEvidenceVariableList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceVariableListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceVariableListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceVariableListEnumerator.GetCurrent : TFhirEvidenceVariable;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceVariableListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEvidenceVariableList }
procedure TFhirEvidenceVariableList.AddItem(value: TFhirEvidenceVariable);
begin
  assert(value.ClassName = 'TFhirEvidenceVariable', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceVariable');
  add(value);
end;

function TFhirEvidenceVariableList.Append: TFhirEvidenceVariable;
begin
  result := TFhirEvidenceVariable.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceVariableList.GetEnumerator : TFhirEvidenceVariableListEnumerator;
begin
  result := TFhirEvidenceVariableListEnumerator.Create(self.link);
end;

function TFhirEvidenceVariableList.Clone: TFhirEvidenceVariableList;
begin
  result := TFhirEvidenceVariableList(inherited Clone);
end;

function TFhirEvidenceVariableList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceVariableList.GetItemN(index: Integer): TFhirEvidenceVariable;
begin
  result := TFhirEvidenceVariable(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceVariable;
end;
function TFhirEvidenceVariableList.IndexOf(value: TFhirEvidenceVariable): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceVariableList.Insert(index: Integer): TFhirEvidenceVariable;
begin
  result := TFhirEvidenceVariable.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableList.InsertItem(index: Integer; value: TFhirEvidenceVariable);
begin
  assert(value is TFhirEvidenceVariable);
  Inherited Insert(index, value);
end;

function TFhirEvidenceVariableList.Item(index: Integer): TFhirEvidenceVariable;
begin
  result := TFhirEvidenceVariable(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableList.Link: TFhirEvidenceVariableList;
begin
  result := TFhirEvidenceVariableList(inherited Link);
end;

procedure TFhirEvidenceVariableList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceVariableList.SetItemByIndex(index: Integer; value: TFhirEvidenceVariable);
begin
  assert(value is TFhirEvidenceVariable);
  FhirEvidenceVariables[index] := value;
end;

procedure TFhirEvidenceVariableList.SetItemN(index: Integer; value: TFhirEvidenceVariable);
begin
  assert(value is TFhirEvidenceVariable);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_EVIDENCEVARIABLE}

{$IFDEF FHIR_GUIDANCERESPONSE}

{ TFhirGuidanceResponse }

constructor TFhirGuidanceResponse.Create;
begin
  inherited;
end;

destructor TFhirGuidanceResponse.Destroy;
begin
  FRequestIdentifier.free;
  FIdentifierList.Free;
  FModule.free;
  FStatus.free;
  FSubject.free;
  FEncounter.free;
  FOccurrenceDateTime.free;
  FPerformer.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FNoteList.Free;
  FEvaluationMessageList.Free;
  FOutputParameters.free;
  FResult.free;
  FDataRequirementList.Free;
  inherited;
end;

function TFhirGuidanceResponse.GetResourceType : TFhirResourceType;
begin
  result := frtGuidanceResponse;
end;

procedure TFhirGuidanceResponse.Assign(oSource : TFslObject);
begin
  inherited;
  requestIdentifier := TFhirGuidanceResponse(oSource).requestIdentifier.Clone;
  if (TFhirGuidanceResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirGuidanceResponse(oSource).FIdentifierList);
  end;
  module := TFhirGuidanceResponse(oSource).module.Clone;
  FStatus := TFhirGuidanceResponse(oSource).FStatus.Link;
  subject := TFhirGuidanceResponse(oSource).subject.Clone;
  encounter := TFhirGuidanceResponse(oSource).encounter.Clone;
  occurrenceDateTimeElement := TFhirGuidanceResponse(oSource).occurrenceDateTimeElement.Clone;
  performer := TFhirGuidanceResponse(oSource).performer.Clone;
  if (TFhirGuidanceResponse(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirGuidanceResponse(oSource).FReasonCodeList);
  end;
  if (TFhirGuidanceResponse(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList{TFhirCondition}.Create;
    FReasonReferenceList.Assign(TFhirGuidanceResponse(oSource).FReasonReferenceList);
  end;
  if (TFhirGuidanceResponse(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirGuidanceResponse(oSource).FNoteList);
  end;
  if (TFhirGuidanceResponse(oSource).FEvaluationMessageList = nil) then
  begin
    FEvaluationMessageList.free;
    FEvaluationMessageList := nil;
  end
  else
  begin
    if FEvaluationMessageList = nil then
      FEvaluationMessageList := TFhirReferenceList{TFhirOperationOutcome}.Create;
    FEvaluationMessageList.Assign(TFhirGuidanceResponse(oSource).FEvaluationMessageList);
  end;
  outputParameters := TFhirGuidanceResponse(oSource).outputParameters.Clone;
  result := TFhirGuidanceResponse(oSource).result.Clone;
  if (TFhirGuidanceResponse(oSource).FDataRequirementList = nil) then
  begin
    FDataRequirementList.free;
    FDataRequirementList := nil;
  end
  else
  begin
    if FDataRequirementList = nil then
      FDataRequirementList := TFhirDataRequirementList.Create;
    FDataRequirementList.Assign(TFhirGuidanceResponse(oSource).FDataRequirementList);
  end;
end;

procedure TFhirGuidanceResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'requestIdentifier') Then
     list.add(self.link, 'requestIdentifier', FRequestIdentifier.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'module[x]') or (child_name = 'module') Then
     list.add(self.link, 'module[x]', FModule.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'occurrenceDateTime') Then
     list.add(self.link, 'occurrenceDateTime', FOccurrenceDateTime.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'evaluationMessage') Then
    list.addAll(self, 'evaluationMessage', FEvaluationMessageList);
  if (child_name = 'outputParameters') Then
     list.add(self.link, 'outputParameters', FOutputParameters.Link);
  if (child_name = 'result') Then
     list.add(self.link, 'result', FResult.Link);
  if (child_name = 'dataRequirement') Then
    list.addAll(self, 'dataRequirement', FDataRequirementList);
end;

procedure TFhirGuidanceResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'requestIdentifier', 'Identifier', false, TFhirIdentifier, FRequestIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'module[x]', 'uri|canonical|CodeableConcept', false, TFhirType, FModule.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'occurrenceDateTime', 'dateTime', false, TFhirDateTime, FOccurrenceDateTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference(Device)', false, TFhirReference{TFhirDevice}, FPerformer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference(Condition)', true, TFhirReference{TFhirCondition}, FReasonReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'evaluationMessage', 'Reference(OperationOutcome)', true, TFhirReference{TFhirOperationOutcome}, FEvaluationMessageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'outputParameters', 'Reference(Parameters)', false, TFhirReference{TFhirParameters}, FOutputParameters.Link));{2}
  oList.add(TFHIRProperty.create(self, 'result', 'Reference(CarePlan)', false, TFhirReference{TFhirCarePlan}, FResult.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dataRequirement', 'DataRequirement', true, TFhirDataRequirement, FDataRequirementList.Link)){3};
end;

function TFhirGuidanceResponse.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'requestIdentifier') then
  begin
    RequestIdentifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'module', ['Uri', 'Canonical', 'CodeableConcept'])) then
  begin
    Module := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirGuidanceResponseStatusEnum, CODES_TFhirGuidanceResponseStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'occurrenceDateTime') then
  begin
    OccurrenceDateTimeElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference{TFhirDevice}{4b};
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference{TFhirCondition}){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'evaluationMessage') then
  begin
    EvaluationMessageList.add(propValue as TFhirReference{TFhirOperationOutcome}){2a};
    result := propValue;
  end
  else if (propName = 'outputParameters') then
  begin
    OutputParameters := propValue as TFhirReference{TFhirParameters}{4b};
    result := propValue;
  end
  else if (propName = 'result') then
  begin
    Result := propValue as TFhirReference{TFhirCarePlan}{4b};
  end
  else if (propName = 'dataRequirement') then
  begin
    DataRequirementList.add(propValue as TFhirDataRequirement){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirGuidanceResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference{TFhirCondition}){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'evaluationMessage') then EvaluationMessageList.insertItem(index, propValue as TFhirReference{TFhirOperationOutcome}){2a}
  else if (propName = 'dataRequirement') then DataRequirementList.insertItem(index, propValue as TFhirDataRequirement){2a}
  else inherited;
end;

function TFhirGuidanceResponse.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'requestIdentifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (isMatchingName(propName, 'module', ['Uri', 'Canonical', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Module'){4x}
  else if (propName = 'subject') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'occurrenceDateTime') then result := TFhirDateTime.create() {5b}
  else if (propName = 'performer') then result := TFhirReference{TFhirDevice}.create(){4b}
  else if (propName = 'reasonCode') then result := ReasonCodeList.new(){2}
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'evaluationMessage') then result := EvaluationMessageList.new(){2}
  else if (propName = 'outputParameters') then result := TFhirReference{TFhirParameters}.create(){4b}
  else if (propName = 'result') then result := TFhirReference{TFhirCarePlan}.create(){4b}
  else if (propName = 'dataRequirement') then result := DataRequirementList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirGuidanceResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'requestIdentifier') then result := 'Identifier'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'module[x]') then result := 'uri|canonical|CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'occurrenceDateTime') then result := 'dateTime'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'evaluationMessage') then result := 'Reference'
  else if (propName = 'outputParameters') then result := 'Reference'
  else if (propName = 'result') then result := 'Reference'
  else if (propName = 'dataRequirement') then result := 'DataRequirement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGuidanceResponse.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'requestIdentifier') then RequestIdentifierElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (isMatchingName(propName, 'module', ['Uri', 'Canonical', 'CodeableConcept'])) then ModuleElement := nil{4x}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'occurrenceDateTime') then OccurrenceDateTimeElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value) {2}
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'evaluationMessage') then deletePropertyValue('evaluationMessage', EvaluationMessageList, value) {2}
  else if (propName = 'outputParameters') then OutputParametersElement := nil
  else if (propName = 'result') then ResultElement := nil
  else if (propName = 'dataRequirement') then deletePropertyValue('dataRequirement', DataRequirementList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGuidanceResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'requestIdentifier') then RequestIdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (isMatchingName(propName, 'module', ['Uri', 'Canonical', 'CodeableConcept'])) then ModuleElement := new as TFhirType{4x}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirGuidanceResponseStatusEnum, CODES_TFhirGuidanceResponseStatusEnum, new){4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'occurrenceDateTime') then OccurrenceDateTimeElement := asDateTime(new){5b}
  else if (propName = 'performer') then PerformerElement := new as TFhirReference{TFhirDevice}{4}
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new) {2}
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'evaluationMessage') then replacePropertyValue('evaluationMessage', EvaluationMessageList, existing, new) {2}
  else if (propName = 'outputParameters') then OutputParametersElement := new as TFhirReference{TFhirParameters}{4}
  else if (propName = 'result') then ResultElement := new as TFhirReference{TFhirCarePlan}{4}
  else if (propName = 'dataRequirement') then replacePropertyValue('dataRequirement', DataRequirementList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGuidanceResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'evaluationMessage') then EvaluationMessageList.move(source, destination){2a}
  else if (propName = 'dataRequirement') then DataRequirementList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirGuidanceResponse.fhirType : string;
begin
  result := 'GuidanceResponse';
end;

function TFhirGuidanceResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRequestIdentifier) and isEmptyProp(FidentifierList) and isEmptyProp(FModule) and isEmptyProp(FStatus) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FOccurrenceDateTime) and isEmptyProp(FPerformer) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FnoteList) and isEmptyProp(FevaluationMessageList) and isEmptyProp(FOutputParameters) and isEmptyProp(FResult) and isEmptyProp(FdataRequirementList);
end;

function TFhirGuidanceResponse.equals(other : TObject) : boolean; 
var
  o : TFhirGuidanceResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGuidanceResponse)) then
    result := false
  else
  begin
    o := TFhirGuidanceResponse(other);
    result := compareDeep(requestIdentifierElement, o.requestIdentifierElement, true) and 
      compareDeep(identifierList, o.identifierList, true) and compareDeep(moduleElement, o.moduleElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(occurrenceDateTimeElement, o.occurrenceDateTimeElement, true) and 
      compareDeep(performerElement, o.performerElement, true) and compareDeep(reasonCodeList, o.reasonCodeList, true) and 
      compareDeep(reasonReferenceList, o.reasonReferenceList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(evaluationMessageList, o.evaluationMessageList, true) and compareDeep(outputParametersElement, o.outputParametersElement, true) and 
      compareDeep(resultElement, o.resultElement, true) and compareDeep(dataRequirementList, o.dataRequirementList, true);
  end;
end;

function TFhirGuidanceResponse.Link : TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse(inherited Link);
end;

function TFhirGuidanceResponse.Clone : TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse(inherited Clone);
end;

procedure TFhirGuidanceResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('requestIdentifier');
  fields.add('identifier');
  fields.add('module[x]');
  fields.add('status');
  fields.add('subject');
  fields.add('encounter');
  fields.add('occurrenceDateTime');
  fields.add('performer');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('note');
  fields.add('evaluationMessage');
  fields.add('outputParameters');
  fields.add('result');
  fields.add('dataRequirement');
end;

{ TFhirGuidanceResponse }

Procedure TFhirGuidanceResponse.SetRequestIdentifier(value : TFhirIdentifier);
begin
  FRequestIdentifier.free;
  FRequestIdentifier := value;
end;

Function TFhirGuidanceResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirGuidanceResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirGuidanceResponse.SetModule(value : TFhirType);
begin
  FModule.free;
  FModule := value;
end;

Procedure TFhirGuidanceResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirGuidanceResponse.GetStatusST : TFhirGuidanceResponseStatusEnum;
begin
  if FStatus = nil then
    result := TFhirGuidanceResponseStatusEnum(0)
  else
    result := TFhirGuidanceResponseStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirGuidanceResponseStatusEnum, FStatus.value));
end;

Procedure TFhirGuidanceResponse.SetStatusST(value : TFhirGuidanceResponseStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirGuidanceResponseStatusEnum[value], CODES_TFhirGuidanceResponseStatusEnum[value]);
end;

Procedure TFhirGuidanceResponse.SetSubject(value : TFhirReference{TFhirPatient});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirGuidanceResponse.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirGuidanceResponse.SetOccurrenceDateTime(value : TFhirDateTime);
begin
  FOccurrenceDateTime.free;
  FOccurrenceDateTime := value;
end;

Function TFhirGuidanceResponse.GetOccurrenceDateTimeST : TFslDateTime;
begin
  if FOccurrenceDateTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FOccurrenceDateTime.value;
end;

Procedure TFhirGuidanceResponse.SetOccurrenceDateTimeST(value : TFslDateTime);
begin
  if FOccurrenceDateTime = nil then
    FOccurrenceDateTime := TFhirDateTime.create;
  FOccurrenceDateTime.value := value
end;

Procedure TFhirGuidanceResponse.SetPerformer(value : TFhirReference{TFhirDevice});
begin
  FPerformer.free;
  FPerformer := value;
end;

Function TFhirGuidanceResponse.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

Function TFhirGuidanceResponse.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

Function TFhirGuidanceResponse.GetReasonReferenceList : TFhirReferenceList{TFhirCondition};
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList{TFhirCondition}.Create;
  result := FReasonReferenceList;
end;

Function TFhirGuidanceResponse.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

Function TFhirGuidanceResponse.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirGuidanceResponse.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirGuidanceResponse.GetEvaluationMessageList : TFhirReferenceList{TFhirOperationOutcome};
begin
  if FEvaluationMessageList = nil then
    FEvaluationMessageList := TFhirReferenceList{TFhirOperationOutcome}.Create;
  result := FEvaluationMessageList;
end;

Function TFhirGuidanceResponse.GetHasEvaluationMessageList : boolean;
begin
  result := (FEvaluationMessageList <> nil) and (FEvaluationMessageList.count > 0);
end;

Procedure TFhirGuidanceResponse.SetOutputParameters(value : TFhirReference{TFhirParameters});
begin
  FOutputParameters.free;
  FOutputParameters := value;
end;

Procedure TFhirGuidanceResponse.SetResult(value : TFhirReference{TFhirCarePlan});
begin
  FResult.free;
  FResult := value;
end;

Function TFhirGuidanceResponse.GetDataRequirementList : TFhirDataRequirementList;
begin
  if FDataRequirementList = nil then
    FDataRequirementList := TFhirDataRequirementList.Create;
  result := FDataRequirementList;
end;

Function TFhirGuidanceResponse.GetHasDataRequirementList : boolean;
begin
  result := (FDataRequirementList <> nil) and (FDataRequirementList.count > 0);
end;

function TFhirGuidanceResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRequestIdentifier.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FModule.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FOccurrenceDateTime.sizeInBytes);
  inc(result, FPerformer.sizeInBytes);
  inc(result, FreasonCodeList.sizeInBytes);
  inc(result, FreasonReferenceList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FevaluationMessageList.sizeInBytes);
  inc(result, FOutputParameters.sizeInBytes);
  inc(result, FResult.sizeInBytes);
  inc(result, FdataRequirementList.sizeInBytes);
end;

{ TFhirGuidanceResponseListEnumerator }

Constructor TFhirGuidanceResponseListEnumerator.Create(list : TFhirGuidanceResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGuidanceResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGuidanceResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGuidanceResponseListEnumerator.GetCurrent : TFhirGuidanceResponse;
begin
  Result := FList[FIndex];
end;

function TFhirGuidanceResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirGuidanceResponseList }
procedure TFhirGuidanceResponseList.AddItem(value: TFhirGuidanceResponse);
begin
  assert(value.ClassName = 'TFhirGuidanceResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGuidanceResponse');
  add(value);
end;

function TFhirGuidanceResponseList.Append: TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGuidanceResponseList.ClearItems;
begin
  Clear;
end;

function TFhirGuidanceResponseList.GetEnumerator : TFhirGuidanceResponseListEnumerator;
begin
  result := TFhirGuidanceResponseListEnumerator.Create(self.link);
end;

function TFhirGuidanceResponseList.Clone: TFhirGuidanceResponseList;
begin
  result := TFhirGuidanceResponseList(inherited Clone);
end;

function TFhirGuidanceResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGuidanceResponseList.GetItemN(index: Integer): TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse(ObjectByIndex[index]);
end;

function TFhirGuidanceResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirGuidanceResponse;
end;
function TFhirGuidanceResponseList.IndexOf(value: TFhirGuidanceResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGuidanceResponseList.Insert(index: Integer): TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGuidanceResponseList.InsertItem(index: Integer; value: TFhirGuidanceResponse);
begin
  assert(value is TFhirGuidanceResponse);
  Inherited Insert(index, value);
end;

function TFhirGuidanceResponseList.Item(index: Integer): TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse(ObjectByIndex[index]);
end;

function TFhirGuidanceResponseList.Link: TFhirGuidanceResponseList;
begin
  result := TFhirGuidanceResponseList(inherited Link);
end;

procedure TFhirGuidanceResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGuidanceResponseList.SetItemByIndex(index: Integer; value: TFhirGuidanceResponse);
begin
  assert(value is TFhirGuidanceResponse);
  FhirGuidanceResponses[index] := value;
end;

procedure TFhirGuidanceResponseList.SetItemN(index: Integer; value: TFhirGuidanceResponse);
begin
  assert(value is TFhirGuidanceResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_GUIDANCERESPONSE}

{$IFDEF FHIR_LINKAGE}

{ TFhirLinkageItem }

constructor TFhirLinkageItem.Create;
begin
  inherited;
end;

destructor TFhirLinkageItem.Destroy;
begin
  FType_.free;
  FResource.free;
  inherited;
end;

procedure TFhirLinkageItem.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirLinkageItem(oSource).FType_.Link;
  resource := TFhirLinkageItem(oSource).resource.Clone;
end;

procedure TFhirLinkageItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
end;

procedure TFhirLinkageItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'resource', 'Reference(Any)', false, TFhirReference{TFhirReference}, FResource.Link));{2}
end;

function TFhirLinkageItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirLinkageTypeEnum, CODES_TFhirLinkageTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirLinkageItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirLinkageItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'resource') then result := TFhirReference{TFhirReference}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirLinkageItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'resource') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLinkageItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'resource') then ResourceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLinkageItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirLinkageTypeEnum, CODES_TFhirLinkageTypeEnum, new){4}
  else if (propName = 'resource') then ResourceElement := new as TFhirReference{TFhirReference}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLinkageItem.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirLinkageItem.fhirType : string;
begin
  result := 'item';
end;

function TFhirLinkageItem.Link : TFhirLinkageItem;
begin
  result := TFhirLinkageItem(inherited Link);
end;

function TFhirLinkageItem.Clone : TFhirLinkageItem;
begin
  result := TFhirLinkageItem(inherited Clone);
end;

function TFhirLinkageItem.equals(other : TObject) : boolean; 
var
  o : TFhirLinkageItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLinkageItem)) then
    result := false
  else
  begin
    o := TFhirLinkageItem(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(resourceElement, o.resourceElement, true);
  end;
end;

function TFhirLinkageItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FResource);
end;

procedure TFhirLinkageItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('resource');
end;

{ TFhirLinkageItem }

Procedure TFhirLinkageItem.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirLinkageItem.GetType_ST : TFhirLinkageTypeEnum;
begin
  if FType_ = nil then
    result := TFhirLinkageTypeEnum(0)
  else
    result := TFhirLinkageTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirLinkageTypeEnum, FType_.value));
end;

Procedure TFhirLinkageItem.SetType_ST(value : TFhirLinkageTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirLinkageTypeEnum[value], CODES_TFhirLinkageTypeEnum[value]);
end;

Procedure TFhirLinkageItem.SetResource(value : TFhirReference{TFhirReference});
begin
  FResource.free;
  FResource := value;
end;

function TFhirLinkageItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FResource.sizeInBytes);
end;

{ TFhirLinkageItemListEnumerator }

Constructor TFhirLinkageItemListEnumerator.Create(list : TFhirLinkageItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLinkageItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirLinkageItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLinkageItemListEnumerator.GetCurrent : TFhirLinkageItem;
begin
  Result := FList[FIndex];
end;

function TFhirLinkageItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirLinkageItemList }
procedure TFhirLinkageItemList.AddItem(value: TFhirLinkageItem);
begin
  assert(value.ClassName = 'TFhirLinkageItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLinkageItem');
  add(value);
end;

function TFhirLinkageItemList.Append: TFhirLinkageItem;
begin
  result := TFhirLinkageItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLinkageItemList.ClearItems;
begin
  Clear;
end;

function TFhirLinkageItemList.GetEnumerator : TFhirLinkageItemListEnumerator;
begin
  result := TFhirLinkageItemListEnumerator.Create(self.link);
end;

function TFhirLinkageItemList.Clone: TFhirLinkageItemList;
begin
  result := TFhirLinkageItemList(inherited Clone);
end;

function TFhirLinkageItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLinkageItemList.GetItemN(index: Integer): TFhirLinkageItem;
begin
  result := TFhirLinkageItem(ObjectByIndex[index]);
end;

function TFhirLinkageItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirLinkageItem;
end;
function TFhirLinkageItemList.IndexOf(value: TFhirLinkageItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLinkageItemList.Insert(index: Integer): TFhirLinkageItem;
begin
  result := TFhirLinkageItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLinkageItemList.InsertItem(index: Integer; value: TFhirLinkageItem);
begin
  assert(value is TFhirLinkageItem);
  Inherited Insert(index, value);
end;

function TFhirLinkageItemList.Item(index: Integer): TFhirLinkageItem;
begin
  result := TFhirLinkageItem(ObjectByIndex[index]);
end;

function TFhirLinkageItemList.Link: TFhirLinkageItemList;
begin
  result := TFhirLinkageItemList(inherited Link);
end;

procedure TFhirLinkageItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLinkageItemList.SetItemByIndex(index: Integer; value: TFhirLinkageItem);
begin
  assert(value is TFhirLinkageItem);
  FhirLinkageItems[index] := value;
end;

procedure TFhirLinkageItemList.SetItemN(index: Integer; value: TFhirLinkageItem);
begin
  assert(value is TFhirLinkageItem);
  ObjectByIndex[index] := value;
end;

{ TFhirLinkage }

constructor TFhirLinkage.Create;
begin
  inherited;
end;

destructor TFhirLinkage.Destroy;
begin
  FActive.free;
  FAuthor.free;
  FItemList.Free;
  inherited;
end;

function TFhirLinkage.GetResourceType : TFhirResourceType;
begin
  result := frtLinkage;
end;

procedure TFhirLinkage.Assign(oSource : TFslObject);
begin
  inherited;
  activeElement := TFhirLinkage(oSource).activeElement.Clone;
  author := TFhirLinkage(oSource).author.Clone;
  if (TFhirLinkage(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirLinkageItemList.Create;
    FItemList.Assign(TFhirLinkage(oSource).FItemList);
  end;
end;

procedure TFhirLinkage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirLinkage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FAuthor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirLinkageItem, FItemList.Link)){3};
end;

function TFhirLinkage.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirLinkageItem){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirLinkage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirLinkageItem){2a}
  else inherited;
end;

function TFhirLinkage.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'active') then result := TFhirBoolean.create() {5b}
  else if (propName = 'author') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'item') then result := ItemList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirLinkage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'active') then result := 'boolean'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'item') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLinkage.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'active') then ActiveElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLinkage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'active') then ActiveElement := asBoolean(new){5b}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLinkage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'item') then ItemList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirLinkage.fhirType : string;
begin
  result := 'Linkage';
end;

function TFhirLinkage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FActive) and isEmptyProp(FAuthor) and isEmptyProp(FitemList);
end;

function TFhirLinkage.equals(other : TObject) : boolean; 
var
  o : TFhirLinkage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLinkage)) then
    result := false
  else
  begin
    o := TFhirLinkage(other);
    result := compareDeep(activeElement, o.activeElement, true) and compareDeep(authorElement, o.authorElement, true) and 
      compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirLinkage.Link : TFhirLinkage;
begin
  result := TFhirLinkage(inherited Link);
end;

function TFhirLinkage.Clone : TFhirLinkage;
begin
  result := TFhirLinkage(inherited Clone);
end;

procedure TFhirLinkage.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('active');
  fields.add('author');
  fields.add('item');
end;

{ TFhirLinkage }

Procedure TFhirLinkage.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

Function TFhirLinkage.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

Procedure TFhirLinkage.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

Procedure TFhirLinkage.SetAuthor(value : TFhirReference{TFhirPractitioner});
begin
  FAuthor.free;
  FAuthor := value;
end;

Function TFhirLinkage.GetItemList : TFhirLinkageItemList;
begin
  if FItemList = nil then
    FItemList := TFhirLinkageItemList.Create;
  result := FItemList;
end;

Function TFhirLinkage.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

function TFhirLinkage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FActive.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
end;

{ TFhirLinkageListEnumerator }

Constructor TFhirLinkageListEnumerator.Create(list : TFhirLinkageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLinkageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirLinkageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLinkageListEnumerator.GetCurrent : TFhirLinkage;
begin
  Result := FList[FIndex];
end;

function TFhirLinkageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirLinkageList }
procedure TFhirLinkageList.AddItem(value: TFhirLinkage);
begin
  assert(value.ClassName = 'TFhirLinkage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLinkage');
  add(value);
end;

function TFhirLinkageList.Append: TFhirLinkage;
begin
  result := TFhirLinkage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLinkageList.ClearItems;
begin
  Clear;
end;

function TFhirLinkageList.GetEnumerator : TFhirLinkageListEnumerator;
begin
  result := TFhirLinkageListEnumerator.Create(self.link);
end;

function TFhirLinkageList.Clone: TFhirLinkageList;
begin
  result := TFhirLinkageList(inherited Clone);
end;

function TFhirLinkageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLinkageList.GetItemN(index: Integer): TFhirLinkage;
begin
  result := TFhirLinkage(ObjectByIndex[index]);
end;

function TFhirLinkageList.ItemClass: TFslObjectClass;
begin
  result := TFhirLinkage;
end;
function TFhirLinkageList.IndexOf(value: TFhirLinkage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLinkageList.Insert(index: Integer): TFhirLinkage;
begin
  result := TFhirLinkage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLinkageList.InsertItem(index: Integer; value: TFhirLinkage);
begin
  assert(value is TFhirLinkage);
  Inherited Insert(index, value);
end;

function TFhirLinkageList.Item(index: Integer): TFhirLinkage;
begin
  result := TFhirLinkage(ObjectByIndex[index]);
end;

function TFhirLinkageList.Link: TFhirLinkageList;
begin
  result := TFhirLinkageList(inherited Link);
end;

procedure TFhirLinkageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLinkageList.SetItemByIndex(index: Integer; value: TFhirLinkage);
begin
  assert(value is TFhirLinkage);
  FhirLinkages[index] := value;
end;

procedure TFhirLinkageList.SetItemN(index: Integer; value: TFhirLinkage);
begin
  assert(value is TFhirLinkage);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_LINKAGE}

{$IFDEF FHIR_LIST}

{ TFhirListEntry }

constructor TFhirListEntry.Create;
begin
  inherited;
end;

destructor TFhirListEntry.Destroy;
begin
  FFlag.free;
  FDeleted.free;
  FDate.free;
  FItem.free;
  inherited;
end;

procedure TFhirListEntry.Assign(oSource : TFslObject);
begin
  inherited;
  flag := TFhirListEntry(oSource).flag.Clone;
  deletedElement := TFhirListEntry(oSource).deletedElement.Clone;
  dateElement := TFhirListEntry(oSource).dateElement.Clone;
  item := TFhirListEntry(oSource).item.Clone;
end;

procedure TFhirListEntry.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'flag') Then
     list.add(self.link, 'flag', FFlag.Link);
  if (child_name = 'deleted') Then
     list.add(self.link, 'deleted', FDeleted.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
end;

procedure TFhirListEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'flag', 'CodeableConcept', false, TFhirCodeableConcept, FFlag.Link));{2}
  oList.add(TFHIRProperty.create(self, 'deleted', 'boolean', false, TFhirBoolean, FDeleted.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', 'Reference(Any)', false, TFhirReference{TFhirReference}, FItem.Link));{2}
end;

function TFhirListEntry.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'flag') then
  begin
    Flag := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'deleted') then
  begin
    DeletedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    Item := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirListEntry.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirListEntry.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'flag') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'deleted') then result := TFhirBoolean.create() {5b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'item') then result := TFhirReference{TFhirReference}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirListEntry.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'flag') then result := 'CodeableConcept'
  else if (propName = 'deleted') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'item') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirListEntry.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'flag') then FlagElement := nil
  else if (propName = 'deleted') then DeletedElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'item') then ItemElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirListEntry.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'flag') then FlagElement := new as TFhirCodeableConcept{4}
  else if (propName = 'deleted') then DeletedElement := asBoolean(new){5b}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'item') then ItemElement := new as TFhirReference{TFhirReference}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirListEntry.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirListEntry.fhirType : string;
begin
  result := 'entry';
end;

function TFhirListEntry.Link : TFhirListEntry;
begin
  result := TFhirListEntry(inherited Link);
end;

function TFhirListEntry.Clone : TFhirListEntry;
begin
  result := TFhirListEntry(inherited Clone);
end;

function TFhirListEntry.equals(other : TObject) : boolean; 
var
  o : TFhirListEntry;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirListEntry)) then
    result := false
  else
  begin
    o := TFhirListEntry(other);
    result := compareDeep(flagElement, o.flagElement, true) and compareDeep(deletedElement, o.deletedElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(itemElement, o.itemElement, true);
  end;
end;

function TFhirListEntry.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFlag) and isEmptyProp(FDeleted) and isEmptyProp(FDate) and isEmptyProp(FItem);
end;

procedure TFhirListEntry.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('flag');
  fields.add('deleted');
  fields.add('date');
  fields.add('item');
end;

{ TFhirListEntry }

Procedure TFhirListEntry.SetFlag(value : TFhirCodeableConcept);
begin
  FFlag.free;
  FFlag := value;
end;

Procedure TFhirListEntry.SetDeleted(value : TFhirBoolean);
begin
  FDeleted.free;
  FDeleted := value;
end;

Function TFhirListEntry.GetDeletedST : Boolean;
begin
  if FDeleted = nil then
    result := false
  else
    result := FDeleted.value;
end;

Procedure TFhirListEntry.SetDeletedST(value : Boolean);
begin
  if FDeleted = nil then
    FDeleted := TFhirBoolean.create;
  FDeleted.value := value
end;

Procedure TFhirListEntry.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirListEntry.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirListEntry.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirListEntry.SetItem(value : TFhirReference{TFhirReference});
begin
  FItem.free;
  FItem := value;
end;

function TFhirListEntry.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FFlag.sizeInBytes);
  inc(result, FDeleted.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FItem.sizeInBytes);
end;

{ TFhirListEntryListEnumerator }

Constructor TFhirListEntryListEnumerator.Create(list : TFhirListEntryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirListEntryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirListEntryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirListEntryListEnumerator.GetCurrent : TFhirListEntry;
begin
  Result := FList[FIndex];
end;

function TFhirListEntryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirListEntryList }
procedure TFhirListEntryList.AddItem(value: TFhirListEntry);
begin
  assert(value.ClassName = 'TFhirListEntry', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirListEntry');
  add(value);
end;

function TFhirListEntryList.Append: TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirListEntryList.ClearItems;
begin
  Clear;
end;

function TFhirListEntryList.GetEnumerator : TFhirListEntryListEnumerator;
begin
  result := TFhirListEntryListEnumerator.Create(self.link);
end;

function TFhirListEntryList.Clone: TFhirListEntryList;
begin
  result := TFhirListEntryList(inherited Clone);
end;

function TFhirListEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirListEntryList.GetItemN(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry(ObjectByIndex[index]);
end;

function TFhirListEntryList.ItemClass: TFslObjectClass;
begin
  result := TFhirListEntry;
end;
function TFhirListEntryList.IndexOf(value: TFhirListEntry): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirListEntryList.Insert(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirListEntryList.InsertItem(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  Inherited Insert(index, value);
end;

function TFhirListEntryList.Item(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry(ObjectByIndex[index]);
end;

function TFhirListEntryList.Link: TFhirListEntryList;
begin
  result := TFhirListEntryList(inherited Link);
end;

procedure TFhirListEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirListEntryList.SetItemByIndex(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  FhirListEntries[index] := value;
end;

procedure TFhirListEntryList.SetItemN(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  ObjectByIndex[index] := value;
end;

{ TFhirList }

constructor TFhirList.Create;
begin
  inherited;
end;

destructor TFhirList.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FMode.free;
  FTitle.free;
  FCode.free;
  FSubject.free;
  FEncounter.free;
  FDate.free;
  FSource.free;
  FOrderedBy.free;
  FNoteList.Free;
  FEntryList.Free;
  FEmptyReason.free;
  inherited;
end;

function TFhirList.GetResourceType : TFhirResourceType;
begin
  result := frtList;
end;

procedure TFhirList.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirList(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirList(oSource).FIdentifierList);
  end;
  FStatus := TFhirList(oSource).FStatus.Link;
  FMode := TFhirList(oSource).FMode.Link;
  titleElement := TFhirList(oSource).titleElement.Clone;
  code := TFhirList(oSource).code.Clone;
  subject := TFhirList(oSource).subject.Clone;
  encounter := TFhirList(oSource).encounter.Clone;
  dateElement := TFhirList(oSource).dateElement.Clone;
  source := TFhirList(oSource).source.Clone;
  orderedBy := TFhirList(oSource).orderedBy.Clone;
  if (TFhirList(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirList(oSource).FNoteList);
  end;
  if (TFhirList(oSource).FEntryList = nil) then
  begin
    FEntryList.free;
    FEntryList := nil;
  end
  else
  begin
    if FEntryList = nil then
      FEntryList := TFhirListEntryList.Create;
    FEntryList.Assign(TFhirList(oSource).FEntryList);
  end;
  emptyReason := TFhirList(oSource).emptyReason.Clone;
end;

procedure TFhirList.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'orderedBy') Then
     list.add(self.link, 'orderedBy', FOrderedBy.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'entry') Then
    list.addAll(self, 'entry', FEntryList);
  if (child_name = 'emptyReason') Then
     list.add(self.link, 'emptyReason', FEmptyReason.Link);
end;

procedure TFhirList.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFHIREnum, FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'orderedBy', 'CodeableConcept', false, TFhirCodeableConcept, FOrderedBy.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'entry', '', true, TFhirListEntry, FEntryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'emptyReason', 'CodeableConcept', false, TFhirCodeableConcept, FEmptyReason.Link));{2}
end;

function TFhirList.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirListStatusEnum, CODES_TFhirListStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'orderedBy') then
  begin
    OrderedBy := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'entry') then
  begin
    EntryList.add(propValue as TFhirListEntry){2a};
    result := propValue;
  end
  else if (propName = 'emptyReason') then
  begin
    EmptyReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirList.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'entry') then EntryList.insertItem(index, propValue as TFhirListEntry){2a}
  else inherited;
end;

function TFhirList.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'title') then result := TFhirString.create() {5b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'source') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'orderedBy') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'entry') then result := EntryList.new(){2}
  else if (propName = 'emptyReason') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirList.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'orderedBy') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'entry') then result := ''
  else if (propName = 'emptyReason') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirList.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'orderedBy') then OrderedByElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'entry') then deletePropertyValue('entry', EntryList, value) {2}
  else if (propName = 'emptyReason') then EmptyReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirList.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirListStatusEnum, CODES_TFhirListStatusEnum, new){4}
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, new){4}
  else if (propName = 'title') then TitleElement := asString(new){5b}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'source') then SourceElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'orderedBy') then OrderedByElement := new as TFhirCodeableConcept{4}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'entry') then replacePropertyValue('entry', EntryList, existing, new) {2}
  else if (propName = 'emptyReason') then EmptyReasonElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirList.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'entry') then EntryList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirList.fhirType : string;
begin
  result := 'List';
end;

function TFhirList.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FMode) and isEmptyProp(FTitle) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FDate) and isEmptyProp(FSource) and isEmptyProp(FOrderedBy) and isEmptyProp(FnoteList) and isEmptyProp(FentryList) and isEmptyProp(FEmptyReason);
end;

function TFhirList.equals(other : TObject) : boolean; 
var
  o : TFhirList;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirList)) then
    result := false
  else
  begin
    o := TFhirList(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(modeElement, o.modeElement, true) and compareDeep(titleElement, o.titleElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(orderedByElement, o.orderedByElement, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(entryList, o.entryList, true) and 
      compareDeep(emptyReasonElement, o.emptyReasonElement, true);
  end;
end;

function TFhirList.Link : TFhirList;
begin
  result := TFhirList(inherited Link);
end;

function TFhirList.Clone : TFhirList;
begin
  result := TFhirList(inherited Clone);
end;

procedure TFhirList.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('mode');
  fields.add('title');
  fields.add('code');
  fields.add('subject');
  fields.add('encounter');
  fields.add('date');
  fields.add('source');
  fields.add('orderedBy');
  fields.add('note');
  fields.add('entry');
  fields.add('emptyReason');
end;

{ TFhirList }

Function TFhirList.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirList.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirList.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirList.GetStatusST : TFhirListStatusEnum;
begin
  if FStatus = nil then
    result := TFhirListStatusEnum(0)
  else
    result := TFhirListStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirListStatusEnum, FStatus.value));
end;

Procedure TFhirList.SetStatusST(value : TFhirListStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirListStatusEnum[value], CODES_TFhirListStatusEnum[value]);
end;

Procedure TFhirList.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirList.GetModeST : TFhirListModeEnum;
begin
  if FMode = nil then
    result := TFhirListModeEnum(0)
  else
    result := TFhirListModeEnum(StringArrayIndexOfSensitive(CODES_TFhirListModeEnum, FMode.value));
end;

Procedure TFhirList.SetModeST(value : TFhirListModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirListModeEnum[value], CODES_TFhirListModeEnum[value]);
end;

Procedure TFhirList.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirList.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirList.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirList.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirList.SetSubject(value : TFhirReference{TFhirPatient});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirList.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirList.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirList.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirList.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirList.SetSource(value : TFhirReference{TFhirPractitioner});
begin
  FSource.free;
  FSource := value;
end;

Procedure TFhirList.SetOrderedBy(value : TFhirCodeableConcept);
begin
  FOrderedBy.free;
  FOrderedBy := value;
end;

Function TFhirList.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirList.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirList.GetEntryList : TFhirListEntryList;
begin
  if FEntryList = nil then
    FEntryList := TFhirListEntryList.Create;
  result := FEntryList;
end;

Function TFhirList.GetHasEntryList : boolean;
begin
  result := (FEntryList <> nil) and (FEntryList.count > 0);
end;

Procedure TFhirList.SetEmptyReason(value : TFhirCodeableConcept);
begin
  FEmptyReason.free;
  FEmptyReason := value;
end;

function TFhirList.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FMode.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FOrderedBy.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FentryList.sizeInBytes);
  inc(result, FEmptyReason.sizeInBytes);
end;

{ TFhirListListEnumerator }

Constructor TFhirListListEnumerator.Create(list : TFhirListList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirListListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirListListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirListListEnumerator.GetCurrent : TFhirList;
begin
  Result := FList[FIndex];
end;

function TFhirListListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirListList }
procedure TFhirListList.AddItem(value: TFhirList);
begin
  assert(value.ClassName = 'TFhirList', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirList');
  add(value);
end;

function TFhirListList.Append: TFhirList;
begin
  result := TFhirList.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirListList.ClearItems;
begin
  Clear;
end;

function TFhirListList.GetEnumerator : TFhirListListEnumerator;
begin
  result := TFhirListListEnumerator.Create(self.link);
end;

function TFhirListList.Clone: TFhirListList;
begin
  result := TFhirListList(inherited Clone);
end;

function TFhirListList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirListList.GetItemN(index: Integer): TFhirList;
begin
  result := TFhirList(ObjectByIndex[index]);
end;

function TFhirListList.ItemClass: TFslObjectClass;
begin
  result := TFhirList;
end;
function TFhirListList.IndexOf(value: TFhirList): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirListList.Insert(index: Integer): TFhirList;
begin
  result := TFhirList.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirListList.InsertItem(index: Integer; value: TFhirList);
begin
  assert(value is TFhirList);
  Inherited Insert(index, value);
end;

function TFhirListList.Item(index: Integer): TFhirList;
begin
  result := TFhirList(ObjectByIndex[index]);
end;

function TFhirListList.Link: TFhirListList;
begin
  result := TFhirListList(inherited Link);
end;

procedure TFhirListList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirListList.SetItemByIndex(index: Integer; value: TFhirList);
begin
  assert(value is TFhirList);
  FhirLists[index] := value;
end;

procedure TFhirListList.SetItemN(index: Integer; value: TFhirList);
begin
  assert(value is TFhirList);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_LIST}

{$IFDEF FHIR_MEASUREREPORT}

{ TFhirMeasureReportGroup }

constructor TFhirMeasureReportGroup.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroup.Destroy;
begin
  FCode.free;
  FPopulationList.Free;
  FMeasureScore.free;
  FStratifierList.Free;
  inherited;
end;

procedure TFhirMeasureReportGroup.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMeasureReportGroup(oSource).code.Clone;
  if (TFhirMeasureReportGroup(oSource).FPopulationList = nil) then
  begin
    FPopulationList.free;
    FPopulationList := nil;
  end
  else
  begin
    if FPopulationList = nil then
      FPopulationList := TFhirMeasureReportGroupPopulationList.Create;
    FPopulationList.Assign(TFhirMeasureReportGroup(oSource).FPopulationList);
  end;
  measureScore := TFhirMeasureReportGroup(oSource).measureScore.Clone;
  if (TFhirMeasureReportGroup(oSource).FStratifierList = nil) then
  begin
    FStratifierList.free;
    FStratifierList := nil;
  end
  else
  begin
    if FStratifierList = nil then
      FStratifierList := TFhirMeasureReportGroupStratifierList.Create;
    FStratifierList.Assign(TFhirMeasureReportGroup(oSource).FStratifierList);
  end;
end;

procedure TFhirMeasureReportGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'population') Then
    list.addAll(self, 'population', FPopulationList);
  if (child_name = 'measureScore') Then
     list.add(self.link, 'measureScore', FMeasureScore.Link);
  if (child_name = 'stratifier') Then
    list.addAll(self, 'stratifier', FStratifierList);
end;

procedure TFhirMeasureReportGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'population', '', true, TFhirMeasureReportGroupPopulation, FPopulationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'measureScore', 'Quantity', false, TFhirQuantity, FMeasureScore.Link));{2}
  oList.add(TFHIRProperty.create(self, 'stratifier', '', true, TFhirMeasureReportGroupStratifier, FStratifierList.Link)){3};
end;

function TFhirMeasureReportGroup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'population') then
  begin
    PopulationList.add(propValue as TFhirMeasureReportGroupPopulation){2a};
    result := propValue;
  end
  else if (propName = 'measureScore') then
  begin
    MeasureScore := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'stratifier') then
  begin
    StratifierList.add(propValue as TFhirMeasureReportGroupStratifier){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'population') then PopulationList.insertItem(index, propValue as TFhirMeasureReportGroupPopulation){2a}
  else if (propName = 'stratifier') then StratifierList.insertItem(index, propValue as TFhirMeasureReportGroupStratifier){2a}
  else inherited;
end;

function TFhirMeasureReportGroup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'population') then result := PopulationList.new(){2}
  else if (propName = 'measureScore') then result := TFhirQuantity.create(){4b}
  else if (propName = 'stratifier') then result := StratifierList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'population') then result := ''
  else if (propName = 'measureScore') then result := 'Quantity'
  else if (propName = 'stratifier') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'population') then deletePropertyValue('population', PopulationList, value) {2}
  else if (propName = 'measureScore') then MeasureScoreElement := nil
  else if (propName = 'stratifier') then deletePropertyValue('stratifier', StratifierList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'population') then replacePropertyValue('population', PopulationList, existing, new) {2}
  else if (propName = 'measureScore') then MeasureScoreElement := new as TFhirQuantity{4}
  else if (propName = 'stratifier') then replacePropertyValue('stratifier', StratifierList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'population') then PopulationList.move(source, destination){2a}
  else if (propName = 'stratifier') then StratifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroup.fhirType : string;
begin
  result := 'group';
end;

function TFhirMeasureReportGroup.Link : TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup(inherited Link);
end;

function TFhirMeasureReportGroup.Clone : TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup(inherited Clone);
end;

function TFhirMeasureReportGroup.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReportGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroup)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroup(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(populationList, o.populationList, true) and 
      compareDeep(measureScoreElement, o.measureScoreElement, true) and compareDeep(stratifierList, o.stratifierList, true);
  end;
end;

function TFhirMeasureReportGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FpopulationList) and isEmptyProp(FMeasureScore) and isEmptyProp(FstratifierList);
end;

procedure TFhirMeasureReportGroup.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('population');
  fields.add('measureScore');
  fields.add('stratifier');
end;

{ TFhirMeasureReportGroup }

Procedure TFhirMeasureReportGroup.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirMeasureReportGroup.GetPopulationList : TFhirMeasureReportGroupPopulationList;
begin
  if FPopulationList = nil then
    FPopulationList := TFhirMeasureReportGroupPopulationList.Create;
  result := FPopulationList;
end;

Function TFhirMeasureReportGroup.GetHasPopulationList : boolean;
begin
  result := (FPopulationList <> nil) and (FPopulationList.count > 0);
end;

Procedure TFhirMeasureReportGroup.SetMeasureScore(value : TFhirQuantity);
begin
  FMeasureScore.free;
  FMeasureScore := value;
end;

Function TFhirMeasureReportGroup.GetStratifierList : TFhirMeasureReportGroupStratifierList;
begin
  if FStratifierList = nil then
    FStratifierList := TFhirMeasureReportGroupStratifierList.Create;
  result := FStratifierList;
end;

Function TFhirMeasureReportGroup.GetHasStratifierList : boolean;
begin
  result := (FStratifierList <> nil) and (FStratifierList.count > 0);
end;

function TFhirMeasureReportGroup.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FpopulationList.sizeInBytes);
  inc(result, FMeasureScore.sizeInBytes);
  inc(result, FstratifierList.sizeInBytes);
end;

{ TFhirMeasureReportGroupListEnumerator }

Constructor TFhirMeasureReportGroupListEnumerator.Create(list : TFhirMeasureReportGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupListEnumerator.GetCurrent : TFhirMeasureReportGroup;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMeasureReportGroupList }
procedure TFhirMeasureReportGroupList.AddItem(value: TFhirMeasureReportGroup);
begin
  assert(value.ClassName = 'TFhirMeasureReportGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroup');
  add(value);
end;

function TFhirMeasureReportGroupList.Append: TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupList.GetEnumerator : TFhirMeasureReportGroupListEnumerator;
begin
  result := TFhirMeasureReportGroupListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupList.Clone: TFhirMeasureReportGroupList;
begin
  result := TFhirMeasureReportGroupList(inherited Clone);
end;

function TFhirMeasureReportGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupList.GetItemN(index: Integer): TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroup;
end;
function TFhirMeasureReportGroupList.IndexOf(value: TFhirMeasureReportGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupList.Insert(index: Integer): TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupList.InsertItem(index: Integer; value: TFhirMeasureReportGroup);
begin
  assert(value is TFhirMeasureReportGroup);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupList.Item(index: Integer): TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupList.Link: TFhirMeasureReportGroupList;
begin
  result := TFhirMeasureReportGroupList(inherited Link);
end;

procedure TFhirMeasureReportGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroup);
begin
  assert(value is TFhirMeasureReportGroup);
  FhirMeasureReportGroups[index] := value;
end;

procedure TFhirMeasureReportGroupList.SetItemN(index: Integer; value: TFhirMeasureReportGroup);
begin
  assert(value is TFhirMeasureReportGroup);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReportGroupPopulation }

constructor TFhirMeasureReportGroupPopulation.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroupPopulation.Destroy;
begin
  FCode.free;
  FCount.free;
  FSubjectResults.free;
  inherited;
end;

procedure TFhirMeasureReportGroupPopulation.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMeasureReportGroupPopulation(oSource).code.Clone;
  countElement := TFhirMeasureReportGroupPopulation(oSource).countElement.Clone;
  subjectResults := TFhirMeasureReportGroupPopulation(oSource).subjectResults.Clone;
end;

procedure TFhirMeasureReportGroupPopulation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'count') Then
     list.add(self.link, 'count', FCount.Link);
  if (child_name = 'subjectResults') Then
     list.add(self.link, 'subjectResults', FSubjectResults.Link);
end;

procedure TFhirMeasureReportGroupPopulation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'count', 'integer', false, TFhirInteger, FCount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subjectResults', 'Reference(List)', false, TFhirReference{TFhirList}, FSubjectResults.Link));{2}
end;

function TFhirMeasureReportGroupPopulation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'count') then
  begin
    CountElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subjectResults') then
  begin
    SubjectResults := propValue as TFhirReference{TFhirList}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroupPopulation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMeasureReportGroupPopulation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'count') then result := TFhirInteger.create() {5b}
  else if (propName = 'subjectResults') then result := TFhirReference{TFhirList}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroupPopulation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'count') then result := 'integer'
  else if (propName = 'subjectResults') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroupPopulation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'count') then CountElement := nil
  else if (propName = 'subjectResults') then SubjectResultsElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroupPopulation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'count') then CountElement := asInteger(new){5b}
  else if (propName = 'subjectResults') then SubjectResultsElement := new as TFhirReference{TFhirList}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroupPopulation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroupPopulation.fhirType : string;
begin
  result := 'population';
end;

function TFhirMeasureReportGroupPopulation.Link : TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation(inherited Link);
end;

function TFhirMeasureReportGroupPopulation.Clone : TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation(inherited Clone);
end;

function TFhirMeasureReportGroupPopulation.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReportGroupPopulation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroupPopulation)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroupPopulation(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(countElement, o.countElement, true) and 
      compareDeep(subjectResultsElement, o.subjectResultsElement, true);
  end;
end;

function TFhirMeasureReportGroupPopulation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FCount) and isEmptyProp(FSubjectResults);
end;

procedure TFhirMeasureReportGroupPopulation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('count');
  fields.add('subjectResults');
end;

{ TFhirMeasureReportGroupPopulation }

Procedure TFhirMeasureReportGroupPopulation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirMeasureReportGroupPopulation.SetCount(value : TFhirInteger);
begin
  FCount.free;
  FCount := value;
end;

Function TFhirMeasureReportGroupPopulation.GetCountST : String;
begin
  if FCount = nil then
    result := ''
  else
    result := FCount.value;
end;

Procedure TFhirMeasureReportGroupPopulation.SetCountST(value : String);
begin
  if value <> '' then
  begin
    if FCount = nil then
      FCount := TFhirInteger.create;
    FCount.value := value
  end
  else if FCount <> nil then
    FCount.value := '';
end;

Procedure TFhirMeasureReportGroupPopulation.SetSubjectResults(value : TFhirReference{TFhirList});
begin
  FSubjectResults.free;
  FSubjectResults := value;
end;

function TFhirMeasureReportGroupPopulation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FCount.sizeInBytes);
  inc(result, FSubjectResults.sizeInBytes);
end;

{ TFhirMeasureReportGroupPopulationListEnumerator }

Constructor TFhirMeasureReportGroupPopulationListEnumerator.Create(list : TFhirMeasureReportGroupPopulationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupPopulationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupPopulationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupPopulationListEnumerator.GetCurrent : TFhirMeasureReportGroupPopulation;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupPopulationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMeasureReportGroupPopulationList }
procedure TFhirMeasureReportGroupPopulationList.AddItem(value: TFhirMeasureReportGroupPopulation);
begin
  assert(value.ClassName = 'TFhirMeasureReportGroupPopulation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroupPopulation');
  add(value);
end;

function TFhirMeasureReportGroupPopulationList.Append: TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupPopulationList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupPopulationList.GetEnumerator : TFhirMeasureReportGroupPopulationListEnumerator;
begin
  result := TFhirMeasureReportGroupPopulationListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupPopulationList.Clone: TFhirMeasureReportGroupPopulationList;
begin
  result := TFhirMeasureReportGroupPopulationList(inherited Clone);
end;

function TFhirMeasureReportGroupPopulationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupPopulationList.GetItemN(index: Integer): TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupPopulationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroupPopulation;
end;
function TFhirMeasureReportGroupPopulationList.IndexOf(value: TFhirMeasureReportGroupPopulation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupPopulationList.Insert(index: Integer): TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupPopulationList.InsertItem(index: Integer; value: TFhirMeasureReportGroupPopulation);
begin
  assert(value is TFhirMeasureReportGroupPopulation);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupPopulationList.Item(index: Integer): TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupPopulationList.Link: TFhirMeasureReportGroupPopulationList;
begin
  result := TFhirMeasureReportGroupPopulationList(inherited Link);
end;

procedure TFhirMeasureReportGroupPopulationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupPopulationList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroupPopulation);
begin
  assert(value is TFhirMeasureReportGroupPopulation);
  FhirMeasureReportGroupPopulations[index] := value;
end;

procedure TFhirMeasureReportGroupPopulationList.SetItemN(index: Integer; value: TFhirMeasureReportGroupPopulation);
begin
  assert(value is TFhirMeasureReportGroupPopulation);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReportGroupStratifier }

constructor TFhirMeasureReportGroupStratifier.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroupStratifier.Destroy;
begin
  FCodeList.Free;
  FStratumList.Free;
  inherited;
end;

procedure TFhirMeasureReportGroupStratifier.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMeasureReportGroupStratifier(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirMeasureReportGroupStratifier(oSource).FCodeList);
  end;
  if (TFhirMeasureReportGroupStratifier(oSource).FStratumList = nil) then
  begin
    FStratumList.free;
    FStratumList := nil;
  end
  else
  begin
    if FStratumList = nil then
      FStratumList := TFhirMeasureReportGroupStratifierStratumList.Create;
    FStratumList.Assign(TFhirMeasureReportGroupStratifier(oSource).FStratumList);
  end;
end;

procedure TFhirMeasureReportGroupStratifier.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'stratum') Then
    list.addAll(self, 'stratum', FStratumList);
end;

procedure TFhirMeasureReportGroupStratifier.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'stratum', '', true, TFhirMeasureReportGroupStratifierStratum, FStratumList.Link)){3};
end;

function TFhirMeasureReportGroupStratifier.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'stratum') then
  begin
    StratumList.add(propValue as TFhirMeasureReportGroupStratifierStratum){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroupStratifier.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'stratum') then StratumList.insertItem(index, propValue as TFhirMeasureReportGroupStratifierStratum){2a}
  else inherited;
end;

function TFhirMeasureReportGroupStratifier.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := CodeList.new(){2}
  else if (propName = 'stratum') then result := StratumList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroupStratifier.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'stratum') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroupStratifier.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then deletePropertyValue('code', CodeList, value) {2}
  else if (propName = 'stratum') then deletePropertyValue('stratum', StratumList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroupStratifier.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {2}
  else if (propName = 'stratum') then replacePropertyValue('stratum', StratumList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroupStratifier.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination){2a}
  else if (propName = 'stratum') then StratumList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroupStratifier.fhirType : string;
begin
  result := 'stratifier';
end;

function TFhirMeasureReportGroupStratifier.Link : TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier(inherited Link);
end;

function TFhirMeasureReportGroupStratifier.Clone : TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier(inherited Clone);
end;

function TFhirMeasureReportGroupStratifier.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReportGroupStratifier;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroupStratifier)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroupStratifier(other);
    result := compareDeep(codeList, o.codeList, true) and compareDeep(stratumList, o.stratumList, true);
  end;
end;

function TFhirMeasureReportGroupStratifier.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FcodeList) and isEmptyProp(FstratumList);
end;

procedure TFhirMeasureReportGroupStratifier.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('stratum');
end;

{ TFhirMeasureReportGroupStratifier }

Function TFhirMeasureReportGroupStratifier.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

Function TFhirMeasureReportGroupStratifier.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

Function TFhirMeasureReportGroupStratifier.GetStratumList : TFhirMeasureReportGroupStratifierStratumList;
begin
  if FStratumList = nil then
    FStratumList := TFhirMeasureReportGroupStratifierStratumList.Create;
  result := FStratumList;
end;

Function TFhirMeasureReportGroupStratifier.GetHasStratumList : boolean;
begin
  result := (FStratumList <> nil) and (FStratumList.count > 0);
end;

function TFhirMeasureReportGroupStratifier.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FcodeList.sizeInBytes);
  inc(result, FstratumList.sizeInBytes);
end;

{ TFhirMeasureReportGroupStratifierListEnumerator }

Constructor TFhirMeasureReportGroupStratifierListEnumerator.Create(list : TFhirMeasureReportGroupStratifierList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupStratifierListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupStratifierListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupStratifierListEnumerator.GetCurrent : TFhirMeasureReportGroupStratifier;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupStratifierListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMeasureReportGroupStratifierList }
procedure TFhirMeasureReportGroupStratifierList.AddItem(value: TFhirMeasureReportGroupStratifier);
begin
  assert(value.ClassName = 'TFhirMeasureReportGroupStratifier', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroupStratifier');
  add(value);
end;

function TFhirMeasureReportGroupStratifierList.Append: TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupStratifierList.GetEnumerator : TFhirMeasureReportGroupStratifierListEnumerator;
begin
  result := TFhirMeasureReportGroupStratifierListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupStratifierList.Clone: TFhirMeasureReportGroupStratifierList;
begin
  result := TFhirMeasureReportGroupStratifierList(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupStratifierList.GetItemN(index: Integer): TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroupStratifier;
end;
function TFhirMeasureReportGroupStratifierList.IndexOf(value: TFhirMeasureReportGroupStratifier): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupStratifierList.Insert(index: Integer): TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierList.InsertItem(index: Integer; value: TFhirMeasureReportGroupStratifier);
begin
  assert(value is TFhirMeasureReportGroupStratifier);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupStratifierList.Item(index: Integer): TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierList.Link: TFhirMeasureReportGroupStratifierList;
begin
  result := TFhirMeasureReportGroupStratifierList(inherited Link);
end;

procedure TFhirMeasureReportGroupStratifierList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupStratifierList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroupStratifier);
begin
  assert(value is TFhirMeasureReportGroupStratifier);
  FhirMeasureReportGroupStratifiers[index] := value;
end;

procedure TFhirMeasureReportGroupStratifierList.SetItemN(index: Integer; value: TFhirMeasureReportGroupStratifier);
begin
  assert(value is TFhirMeasureReportGroupStratifier);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReportGroupStratifierStratum }

constructor TFhirMeasureReportGroupStratifierStratum.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroupStratifierStratum.Destroy;
begin
  FValue.free;
  FComponentList.Free;
  FPopulationList.Free;
  FMeasureScore.free;
  inherited;
end;

procedure TFhirMeasureReportGroupStratifierStratum.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirMeasureReportGroupStratifierStratum(oSource).value.Clone;
  if (TFhirMeasureReportGroupStratifierStratum(oSource).FComponentList = nil) then
  begin
    FComponentList.free;
    FComponentList := nil;
  end
  else
  begin
    if FComponentList = nil then
      FComponentList := TFhirMeasureReportGroupStratifierStratumComponentList.Create;
    FComponentList.Assign(TFhirMeasureReportGroupStratifierStratum(oSource).FComponentList);
  end;
  if (TFhirMeasureReportGroupStratifierStratum(oSource).FPopulationList = nil) then
  begin
    FPopulationList.free;
    FPopulationList := nil;
  end
  else
  begin
    if FPopulationList = nil then
      FPopulationList := TFhirMeasureReportGroupStratifierStratumPopulationList.Create;
    FPopulationList.Assign(TFhirMeasureReportGroupStratifierStratum(oSource).FPopulationList);
  end;
  measureScore := TFhirMeasureReportGroupStratifierStratum(oSource).measureScore.Clone;
end;

procedure TFhirMeasureReportGroupStratifierStratum.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'component') Then
    list.addAll(self, 'component', FComponentList);
  if (child_name = 'population') Then
    list.addAll(self, 'population', FPopulationList);
  if (child_name = 'measureScore') Then
     list.add(self.link, 'measureScore', FMeasureScore.Link);
end;

procedure TFhirMeasureReportGroupStratifierStratum.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value', 'CodeableConcept', false, TFhirCodeableConcept, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'component', '', true, TFhirMeasureReportGroupStratifierStratumComponent, FComponentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'population', '', true, TFhirMeasureReportGroupStratifierStratumPopulation, FPopulationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'measureScore', 'Quantity', false, TFhirQuantity, FMeasureScore.Link));{2}
end;

function TFhirMeasureReportGroupStratifierStratum.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'value') then
  begin
    Value := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'component') then
  begin
    ComponentList.add(propValue as TFhirMeasureReportGroupStratifierStratumComponent){2a};
    result := propValue;
  end
  else if (propName = 'population') then
  begin
    PopulationList.add(propValue as TFhirMeasureReportGroupStratifierStratumPopulation){2a};
    result := propValue;
  end
  else if (propName = 'measureScore') then
  begin
    MeasureScore := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroupStratifierStratum.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'component') then ComponentList.insertItem(index, propValue as TFhirMeasureReportGroupStratifierStratumComponent){2a}
  else if (propName = 'population') then PopulationList.insertItem(index, propValue as TFhirMeasureReportGroupStratifierStratumPopulation){2a}
  else inherited;
end;

function TFhirMeasureReportGroupStratifierStratum.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'value') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'component') then result := ComponentList.new(){2}
  else if (propName = 'population') then result := PopulationList.new(){2}
  else if (propName = 'measureScore') then result := TFhirQuantity.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroupStratifierStratum.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value') then result := 'CodeableConcept'
  else if (propName = 'component') then result := ''
  else if (propName = 'population') then result := ''
  else if (propName = 'measureScore') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroupStratifierStratum.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := nil
  else if (propName = 'component') then deletePropertyValue('component', ComponentList, value) {2}
  else if (propName = 'population') then deletePropertyValue('population', PopulationList, value) {2}
  else if (propName = 'measureScore') then MeasureScoreElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroupStratifierStratum.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := new as TFhirCodeableConcept{4}
  else if (propName = 'component') then replacePropertyValue('component', ComponentList, existing, new) {2}
  else if (propName = 'population') then replacePropertyValue('population', PopulationList, existing, new) {2}
  else if (propName = 'measureScore') then MeasureScoreElement := new as TFhirQuantity{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroupStratifierStratum.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'component') then ComponentList.move(source, destination){2a}
  else if (propName = 'population') then PopulationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroupStratifierStratum.fhirType : string;
begin
  result := 'stratum';
end;

function TFhirMeasureReportGroupStratifierStratum.Link : TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum(inherited Link);
end;

function TFhirMeasureReportGroupStratifierStratum.Clone : TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratum.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReportGroupStratifierStratum;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroupStratifierStratum)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroupStratifierStratum(other);
    result := compareDeep(valueElement, o.valueElement, true) and compareDeep(componentList, o.componentList, true) and 
      compareDeep(populationList, o.populationList, true) and compareDeep(measureScoreElement, o.measureScoreElement, true);
  end;
end;

function TFhirMeasureReportGroupStratifierStratum.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue) and isEmptyProp(FcomponentList) and isEmptyProp(FpopulationList) and isEmptyProp(FMeasureScore);
end;

procedure TFhirMeasureReportGroupStratifierStratum.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('value');
  fields.add('component');
  fields.add('population');
  fields.add('measureScore');
end;

{ TFhirMeasureReportGroupStratifierStratum }

Procedure TFhirMeasureReportGroupStratifierStratum.SetValue(value : TFhirCodeableConcept);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirMeasureReportGroupStratifierStratum.GetComponentList : TFhirMeasureReportGroupStratifierStratumComponentList;
begin
  if FComponentList = nil then
    FComponentList := TFhirMeasureReportGroupStratifierStratumComponentList.Create;
  result := FComponentList;
end;

Function TFhirMeasureReportGroupStratifierStratum.GetHasComponentList : boolean;
begin
  result := (FComponentList <> nil) and (FComponentList.count > 0);
end;

Function TFhirMeasureReportGroupStratifierStratum.GetPopulationList : TFhirMeasureReportGroupStratifierStratumPopulationList;
begin
  if FPopulationList = nil then
    FPopulationList := TFhirMeasureReportGroupStratifierStratumPopulationList.Create;
  result := FPopulationList;
end;

Function TFhirMeasureReportGroupStratifierStratum.GetHasPopulationList : boolean;
begin
  result := (FPopulationList <> nil) and (FPopulationList.count > 0);
end;

Procedure TFhirMeasureReportGroupStratifierStratum.SetMeasureScore(value : TFhirQuantity);
begin
  FMeasureScore.free;
  FMeasureScore := value;
end;

function TFhirMeasureReportGroupStratifierStratum.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FValue.sizeInBytes);
  inc(result, FcomponentList.sizeInBytes);
  inc(result, FpopulationList.sizeInBytes);
  inc(result, FMeasureScore.sizeInBytes);
end;

{ TFhirMeasureReportGroupStratifierStratumListEnumerator }

Constructor TFhirMeasureReportGroupStratifierStratumListEnumerator.Create(list : TFhirMeasureReportGroupStratifierStratumList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupStratifierStratumListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupStratifierStratumListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupStratifierStratumListEnumerator.GetCurrent : TFhirMeasureReportGroupStratifierStratum;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupStratifierStratumListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMeasureReportGroupStratifierStratumList }
procedure TFhirMeasureReportGroupStratifierStratumList.AddItem(value: TFhirMeasureReportGroupStratifierStratum);
begin
  assert(value.ClassName = 'TFhirMeasureReportGroupStratifierStratum', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroupStratifierStratum');
  add(value);
end;

function TFhirMeasureReportGroupStratifierStratumList.Append: TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupStratifierStratumList.GetEnumerator : TFhirMeasureReportGroupStratifierStratumListEnumerator;
begin
  result := TFhirMeasureReportGroupStratifierStratumListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupStratifierStratumList.Clone: TFhirMeasureReportGroupStratifierStratumList;
begin
  result := TFhirMeasureReportGroupStratifierStratumList(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratumList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupStratifierStratumList.GetItemN(index: Integer): TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroupStratifierStratum;
end;
function TFhirMeasureReportGroupStratifierStratumList.IndexOf(value: TFhirMeasureReportGroupStratifierStratum): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupStratifierStratumList.Insert(index: Integer): TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumList.InsertItem(index: Integer; value: TFhirMeasureReportGroupStratifierStratum);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratum);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupStratifierStratumList.Item(index: Integer): TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumList.Link: TFhirMeasureReportGroupStratifierStratumList;
begin
  result := TFhirMeasureReportGroupStratifierStratumList(inherited Link);
end;

procedure TFhirMeasureReportGroupStratifierStratumList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupStratifierStratumList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroupStratifierStratum);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratum);
  FhirMeasureReportGroupStratifierStrata[index] := value;
end;

procedure TFhirMeasureReportGroupStratifierStratumList.SetItemN(index: Integer; value: TFhirMeasureReportGroupStratifierStratum);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratum);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReportGroupStratifierStratumComponent }

constructor TFhirMeasureReportGroupStratifierStratumComponent.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroupStratifierStratumComponent.Destroy;
begin
  FCode.free;
  FValue.free;
  inherited;
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMeasureReportGroupStratifierStratumComponent(oSource).code.Clone;
  value := TFhirMeasureReportGroupStratifierStratumComponent(oSource).value.Clone;
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'CodeableConcept', false, TFhirCodeableConcept, FValue.Link));{2}
end;

function TFhirMeasureReportGroupStratifierStratumComponent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    Value := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMeasureReportGroupStratifierStratumComponent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'value') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroupStratifierStratumComponent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'value') then ValueElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroupStratifierStratumComponent.fhirType : string;
begin
  result := 'component';
end;

function TFhirMeasureReportGroupStratifierStratumComponent.Link : TFhirMeasureReportGroupStratifierStratumComponent;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent(inherited Link);
end;

function TFhirMeasureReportGroupStratifierStratumComponent.Clone : TFhirMeasureReportGroupStratifierStratumComponent;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratumComponent.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReportGroupStratifierStratumComponent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroupStratifierStratumComponent)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroupStratifierStratumComponent(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirMeasureReportGroupStratifierStratumComponent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('value');
end;

{ TFhirMeasureReportGroupStratifierStratumComponent }

Procedure TFhirMeasureReportGroupStratifierStratumComponent.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirMeasureReportGroupStratifierStratumComponent.SetValue(value : TFhirCodeableConcept);
begin
  FValue.free;
  FValue := value;
end;

function TFhirMeasureReportGroupStratifierStratumComponent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirMeasureReportGroupStratifierStratumComponentListEnumerator }

Constructor TFhirMeasureReportGroupStratifierStratumComponentListEnumerator.Create(list : TFhirMeasureReportGroupStratifierStratumComponentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupStratifierStratumComponentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupStratifierStratumComponentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupStratifierStratumComponentListEnumerator.GetCurrent : TFhirMeasureReportGroupStratifierStratumComponent;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupStratifierStratumComponentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMeasureReportGroupStratifierStratumComponentList }
procedure TFhirMeasureReportGroupStratifierStratumComponentList.AddItem(value: TFhirMeasureReportGroupStratifierStratumComponent);
begin
  assert(value.ClassName = 'TFhirMeasureReportGroupStratifierStratumComponent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroupStratifierStratumComponent');
  add(value);
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.Append: TFhirMeasureReportGroupStratifierStratumComponent;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumComponentList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.GetEnumerator : TFhirMeasureReportGroupStratifierStratumComponentListEnumerator;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponentListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.Clone: TFhirMeasureReportGroupStratifierStratumComponentList;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponentList(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.GetItemN(index: Integer): TFhirMeasureReportGroupStratifierStratumComponent;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent;
end;
function TFhirMeasureReportGroupStratifierStratumComponentList.IndexOf(value: TFhirMeasureReportGroupStratifierStratumComponent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.Insert(index: Integer): TFhirMeasureReportGroupStratifierStratumComponent;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumComponentList.InsertItem(index: Integer; value: TFhirMeasureReportGroupStratifierStratumComponent);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumComponent);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.Item(index: Integer): TFhirMeasureReportGroupStratifierStratumComponent;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.Link: TFhirMeasureReportGroupStratifierStratumComponentList;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponentList(inherited Link);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponentList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroupStratifierStratumComponent);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumComponent);
  FhirMeasureReportGroupStratifierStratumComponents[index] := value;
end;

procedure TFhirMeasureReportGroupStratifierStratumComponentList.SetItemN(index: Integer; value: TFhirMeasureReportGroupStratifierStratumComponent);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumComponent);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReportGroupStratifierStratumPopulation }

constructor TFhirMeasureReportGroupStratifierStratumPopulation.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroupStratifierStratumPopulation.Destroy;
begin
  FCode.free;
  FCount.free;
  FSubjectResults.free;
  inherited;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMeasureReportGroupStratifierStratumPopulation(oSource).code.Clone;
  countElement := TFhirMeasureReportGroupStratifierStratumPopulation(oSource).countElement.Clone;
  subjectResults := TFhirMeasureReportGroupStratifierStratumPopulation(oSource).subjectResults.Clone;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'count') Then
     list.add(self.link, 'count', FCount.Link);
  if (child_name = 'subjectResults') Then
     list.add(self.link, 'subjectResults', FSubjectResults.Link);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'count', 'integer', false, TFhirInteger, FCount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subjectResults', 'Reference(List)', false, TFhirReference{TFhirList}, FSubjectResults.Link));{2}
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'count') then
  begin
    CountElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subjectResults') then
  begin
    SubjectResults := propValue as TFhirReference{TFhirList}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'count') then result := TFhirInteger.create() {5b}
  else if (propName = 'subjectResults') then result := TFhirReference{TFhirList}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'count') then result := 'integer'
  else if (propName = 'subjectResults') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'count') then CountElement := nil
  else if (propName = 'subjectResults') then SubjectResultsElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'count') then CountElement := asInteger(new){5b}
  else if (propName = 'subjectResults') then SubjectResultsElement := new as TFhirReference{TFhirList}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.fhirType : string;
begin
  result := 'population';
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.Link : TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation(inherited Link);
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.Clone : TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroupStratifierStratumPopulation)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroupStratifierStratumPopulation(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(countElement, o.countElement, true) and 
      compareDeep(subjectResultsElement, o.subjectResultsElement, true);
  end;
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FCount) and isEmptyProp(FSubjectResults);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('count');
  fields.add('subjectResults');
end;

{ TFhirMeasureReportGroupStratifierStratumPopulation }

Procedure TFhirMeasureReportGroupStratifierStratumPopulation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirMeasureReportGroupStratifierStratumPopulation.SetCount(value : TFhirInteger);
begin
  FCount.free;
  FCount := value;
end;

Function TFhirMeasureReportGroupStratifierStratumPopulation.GetCountST : String;
begin
  if FCount = nil then
    result := ''
  else
    result := FCount.value;
end;

Procedure TFhirMeasureReportGroupStratifierStratumPopulation.SetCountST(value : String);
begin
  if value <> '' then
  begin
    if FCount = nil then
      FCount := TFhirInteger.create;
    FCount.value := value
  end
  else if FCount <> nil then
    FCount.value := '';
end;

Procedure TFhirMeasureReportGroupStratifierStratumPopulation.SetSubjectResults(value : TFhirReference{TFhirList});
begin
  FSubjectResults.free;
  FSubjectResults := value;
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FCount.sizeInBytes);
  inc(result, FSubjectResults.sizeInBytes);
end;

{ TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator }

Constructor TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.Create(list : TFhirMeasureReportGroupStratifierStratumPopulationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.GetCurrent : TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMeasureReportGroupStratifierStratumPopulationList }
procedure TFhirMeasureReportGroupStratifierStratumPopulationList.AddItem(value: TFhirMeasureReportGroupStratifierStratumPopulation);
begin
  assert(value.ClassName = 'TFhirMeasureReportGroupStratifierStratumPopulation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroupStratifierStratumPopulation');
  add(value);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Append: TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulationList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.GetEnumerator : TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Clone: TFhirMeasureReportGroupStratifierStratumPopulationList;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulationList(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.GetItemN(index: Integer): TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation;
end;
function TFhirMeasureReportGroupStratifierStratumPopulationList.IndexOf(value: TFhirMeasureReportGroupStratifierStratumPopulation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Insert(index: Integer): TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulationList.InsertItem(index: Integer; value: TFhirMeasureReportGroupStratifierStratumPopulation);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumPopulation);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Item(index: Integer): TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Link: TFhirMeasureReportGroupStratifierStratumPopulationList;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulationList(inherited Link);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulationList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroupStratifierStratumPopulation);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumPopulation);
  FhirMeasureReportGroupStratifierStratumPopulations[index] := value;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulationList.SetItemN(index: Integer; value: TFhirMeasureReportGroupStratifierStratumPopulation);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumPopulation);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReport }

constructor TFhirMeasureReport.Create;
begin
  inherited;
end;

destructor TFhirMeasureReport.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FMeasure.free;
  FSubject.free;
  FDate.free;
  FReporter.free;
  FPeriod.free;
  FImprovementNotation.free;
  FGroupList.Free;
  FEvaluatedResourceList.Free;
  inherited;
end;

function TFhirMeasureReport.GetResourceType : TFhirResourceType;
begin
  result := frtMeasureReport;
end;

procedure TFhirMeasureReport.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMeasureReport(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMeasureReport(oSource).FIdentifierList);
  end;
  FStatus := TFhirMeasureReport(oSource).FStatus.Link;
  FType_ := TFhirMeasureReport(oSource).FType_.Link;
  measureElement := TFhirMeasureReport(oSource).measureElement.Clone;
  subject := TFhirMeasureReport(oSource).subject.Clone;
  dateElement := TFhirMeasureReport(oSource).dateElement.Clone;
  reporter := TFhirMeasureReport(oSource).reporter.Clone;
  period := TFhirMeasureReport(oSource).period.Clone;
  improvementNotation := TFhirMeasureReport(oSource).improvementNotation.Clone;
  if (TFhirMeasureReport(oSource).FGroupList = nil) then
  begin
    FGroupList.free;
    FGroupList := nil;
  end
  else
  begin
    if FGroupList = nil then
      FGroupList := TFhirMeasureReportGroupList.Create;
    FGroupList.Assign(TFhirMeasureReport(oSource).FGroupList);
  end;
  if (TFhirMeasureReport(oSource).FEvaluatedResourceList = nil) then
  begin
    FEvaluatedResourceList.free;
    FEvaluatedResourceList := nil;
  end
  else
  begin
    if FEvaluatedResourceList = nil then
      FEvaluatedResourceList := TFhirReferenceList{TFhirReference}.Create;
    FEvaluatedResourceList.Assign(TFhirMeasureReport(oSource).FEvaluatedResourceList);
  end;
end;

procedure TFhirMeasureReport.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'measure') Then
     list.add(self.link, 'measure', FMeasure.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'reporter') Then
     list.add(self.link, 'reporter', FReporter.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'improvementNotation') Then
     list.add(self.link, 'improvementNotation', FImprovementNotation.Link);
  if (child_name = 'group') Then
    list.addAll(self, 'group', FGroupList);
  if (child_name = 'evaluatedResource') Then
    list.addAll(self, 'evaluatedResource', FEvaluatedResourceList);
end;

procedure TFhirMeasureReport.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'measure', 'canonical', false, TFhirCanonical, FMeasure.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reporter', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FReporter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'improvementNotation', 'CodeableConcept', false, TFhirCodeableConcept, FImprovementNotation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'group', '', true, TFhirMeasureReportGroup, FGroupList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'evaluatedResource', 'Reference(Any)', true, TFhirReference{TFhirReference}, FEvaluatedResourceList.Link)){3};
end;

function TFhirMeasureReport.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMeasureReportStatusEnum, CODES_TFhirMeasureReportStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirMeasureReportTypeEnum, CODES_TFhirMeasureReportTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'measure') then
  begin
    MeasureElement := asCanonical(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reporter') then
  begin
    Reporter := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'improvementNotation') then
  begin
    ImprovementNotation := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    GroupList.add(propValue as TFhirMeasureReportGroup){2a};
    result := propValue;
  end
  else if (propName = 'evaluatedResource') then
  begin
    EvaluatedResourceList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMeasureReport.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'group') then GroupList.insertItem(index, propValue as TFhirMeasureReportGroup){2a}
  else if (propName = 'evaluatedResource') then EvaluatedResourceList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else inherited;
end;

function TFhirMeasureReport.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'measure') then result := TFhirCanonical.create() {5b}
  else if (propName = 'subject') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'reporter') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'improvementNotation') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'group') then result := GroupList.new(){2}
  else if (propName = 'evaluatedResource') then result := EvaluatedResourceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReport.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'measure') then result := 'canonical'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'reporter') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'improvementNotation') then result := 'CodeableConcept'
  else if (propName = 'group') then result := ''
  else if (propName = 'evaluatedResource') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReport.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'measure') then MeasureElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'reporter') then ReporterElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'improvementNotation') then ImprovementNotationElement := nil
  else if (propName = 'group') then deletePropertyValue('group', GroupList, value) {2}
  else if (propName = 'evaluatedResource') then deletePropertyValue('evaluatedResource', EvaluatedResourceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReport.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMeasureReportStatusEnum, CODES_TFhirMeasureReportStatusEnum, new){4}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirMeasureReportTypeEnum, CODES_TFhirMeasureReportTypeEnum, new){4}
  else if (propName = 'measure') then MeasureElement := asCanonical(new){5b}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'reporter') then ReporterElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'improvementNotation') then ImprovementNotationElement := new as TFhirCodeableConcept{4}
  else if (propName = 'group') then replacePropertyValue('group', GroupList, existing, new) {2}
  else if (propName = 'evaluatedResource') then replacePropertyValue('evaluatedResource', EvaluatedResourceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReport.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'group') then GroupList.move(source, destination){2a}
  else if (propName = 'evaluatedResource') then EvaluatedResourceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReport.fhirType : string;
begin
  result := 'MeasureReport';
end;

function TFhirMeasureReport.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FMeasure) and isEmptyProp(FSubject) and isEmptyProp(FDate) and isEmptyProp(FReporter) and isEmptyProp(FPeriod) and isEmptyProp(FImprovementNotation) and isEmptyProp(FgroupList) and isEmptyProp(FevaluatedResourceList);
end;

function TFhirMeasureReport.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReport;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReport)) then
    result := false
  else
  begin
    o := TFhirMeasureReport(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(measureElement, o.measureElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(reporterElement, o.reporterElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(improvementNotationElement, o.improvementNotationElement, true) and 
      compareDeep(groupList, o.groupList, true) and compareDeep(evaluatedResourceList, o.evaluatedResourceList, true);
  end;
end;

function TFhirMeasureReport.Link : TFhirMeasureReport;
begin
  result := TFhirMeasureReport(inherited Link);
end;

function TFhirMeasureReport.Clone : TFhirMeasureReport;
begin
  result := TFhirMeasureReport(inherited Clone);
end;

procedure TFhirMeasureReport.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('measure');
  fields.add('subject');
  fields.add('date');
  fields.add('reporter');
  fields.add('period');
  fields.add('improvementNotation');
  fields.add('group');
  fields.add('evaluatedResource');
end;

{ TFhirMeasureReport }

Function TFhirMeasureReport.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirMeasureReport.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirMeasureReport.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirMeasureReport.GetStatusST : TFhirMeasureReportStatusEnum;
begin
  if FStatus = nil then
    result := TFhirMeasureReportStatusEnum(0)
  else
    result := TFhirMeasureReportStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirMeasureReportStatusEnum, FStatus.value));
end;

Procedure TFhirMeasureReport.SetStatusST(value : TFhirMeasureReportStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMeasureReportStatusEnum[value], CODES_TFhirMeasureReportStatusEnum[value]);
end;

Procedure TFhirMeasureReport.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirMeasureReport.GetType_ST : TFhirMeasureReportTypeEnum;
begin
  if FType_ = nil then
    result := TFhirMeasureReportTypeEnum(0)
  else
    result := TFhirMeasureReportTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirMeasureReportTypeEnum, FType_.value));
end;

Procedure TFhirMeasureReport.SetType_ST(value : TFhirMeasureReportTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirMeasureReportTypeEnum[value], CODES_TFhirMeasureReportTypeEnum[value]);
end;

Procedure TFhirMeasureReport.SetMeasure(value : TFhirCanonical);
begin
  FMeasure.free;
  FMeasure := value;
end;

Function TFhirMeasureReport.GetMeasureST : String;
begin
  if FMeasure = nil then
    result := ''
  else
    result := FMeasure.value;
end;

Procedure TFhirMeasureReport.SetMeasureST(value : String);
begin
  if value <> '' then
  begin
    if FMeasure = nil then
      FMeasure := TFhirCanonical.create;
    FMeasure.value := value
  end
  else if FMeasure <> nil then
    FMeasure.value := '';
end;

Procedure TFhirMeasureReport.SetSubject(value : TFhirReference{TFhirPatient});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirMeasureReport.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirMeasureReport.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirMeasureReport.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirMeasureReport.SetReporter(value : TFhirReference{TFhirPractitioner});
begin
  FReporter.free;
  FReporter := value;
end;

Procedure TFhirMeasureReport.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirMeasureReport.SetImprovementNotation(value : TFhirCodeableConcept);
begin
  FImprovementNotation.free;
  FImprovementNotation := value;
end;

Function TFhirMeasureReport.GetGroupList : TFhirMeasureReportGroupList;
begin
  if FGroupList = nil then
    FGroupList := TFhirMeasureReportGroupList.Create;
  result := FGroupList;
end;

Function TFhirMeasureReport.GetHasGroupList : boolean;
begin
  result := (FGroupList <> nil) and (FGroupList.count > 0);
end;

Function TFhirMeasureReport.GetEvaluatedResourceList : TFhirReferenceList{TFhirReference};
begin
  if FEvaluatedResourceList = nil then
    FEvaluatedResourceList := TFhirReferenceList{TFhirReference}.Create;
  result := FEvaluatedResourceList;
end;

Function TFhirMeasureReport.GetHasEvaluatedResourceList : boolean;
begin
  result := (FEvaluatedResourceList <> nil) and (FEvaluatedResourceList.count > 0);
end;

function TFhirMeasureReport.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FMeasure.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FReporter.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FImprovementNotation.sizeInBytes);
  inc(result, FgroupList.sizeInBytes);
  inc(result, FevaluatedResourceList.sizeInBytes);
end;

{ TFhirMeasureReportListEnumerator }

Constructor TFhirMeasureReportListEnumerator.Create(list : TFhirMeasureReportList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportListEnumerator.GetCurrent : TFhirMeasureReport;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMeasureReportList }
procedure TFhirMeasureReportList.AddItem(value: TFhirMeasureReport);
begin
  assert(value.ClassName = 'TFhirMeasureReport', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReport');
  add(value);
end;

function TFhirMeasureReportList.Append: TFhirMeasureReport;
begin
  result := TFhirMeasureReport.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportList.GetEnumerator : TFhirMeasureReportListEnumerator;
begin
  result := TFhirMeasureReportListEnumerator.Create(self.link);
end;

function TFhirMeasureReportList.Clone: TFhirMeasureReportList;
begin
  result := TFhirMeasureReportList(inherited Clone);
end;

function TFhirMeasureReportList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportList.GetItemN(index: Integer): TFhirMeasureReport;
begin
  result := TFhirMeasureReport(ObjectByIndex[index]);
end;

function TFhirMeasureReportList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReport;
end;
function TFhirMeasureReportList.IndexOf(value: TFhirMeasureReport): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportList.Insert(index: Integer): TFhirMeasureReport;
begin
  result := TFhirMeasureReport.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportList.InsertItem(index: Integer; value: TFhirMeasureReport);
begin
  assert(value is TFhirMeasureReport);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportList.Item(index: Integer): TFhirMeasureReport;
begin
  result := TFhirMeasureReport(ObjectByIndex[index]);
end;

function TFhirMeasureReportList.Link: TFhirMeasureReportList;
begin
  result := TFhirMeasureReportList(inherited Link);
end;

procedure TFhirMeasureReportList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportList.SetItemByIndex(index: Integer; value: TFhirMeasureReport);
begin
  assert(value is TFhirMeasureReport);
  FhirMeasureReports[index] := value;
end;

procedure TFhirMeasureReportList.SetItemN(index: Integer; value: TFhirMeasureReport);
begin
  assert(value is TFhirMeasureReport);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEASUREREPORT}

{$IFDEF FHIR_MESSAGEHEADER}

{ TFhirMessageHeaderDestination }

constructor TFhirMessageHeaderDestination.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderDestination.Destroy;
begin
  FName.free;
  FTarget.free;
  FEndpoint.free;
  FReceiver.free;
  inherited;
end;

procedure TFhirMessageHeaderDestination.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirMessageHeaderDestination(oSource).nameElement.Clone;
  target := TFhirMessageHeaderDestination(oSource).target.Clone;
  endpointElement := TFhirMessageHeaderDestination(oSource).endpointElement.Clone;
  receiver := TFhirMessageHeaderDestination(oSource).receiver.Clone;
end;

procedure TFhirMessageHeaderDestination.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'endpoint') Then
     list.add(self.link, 'endpoint', FEndpoint.Link);
  if (child_name = 'receiver') Then
     list.add(self.link, 'receiver', FReceiver.Link);
end;

procedure TFhirMessageHeaderDestination.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'Reference(Device)', false, TFhirReference{TFhirDevice}, FTarget.Link));{2}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'url', false, TFhirUrl, FEndpoint.Link));{2}
  oList.add(TFHIRProperty.create(self, 'receiver', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FReceiver.Link));{2}
end;

function TFhirMessageHeaderDestination.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirReference{TFhirDevice}{4b};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointElement := asUrl(propValue){5a};
    result := propValue;
  end
  else if (propName = 'receiver') then
  begin
    Receiver := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageHeaderDestination.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMessageHeaderDestination.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'target') then result := TFhirReference{TFhirDevice}.create(){4b}
  else if (propName = 'endpoint') then result := TFhirUrl.create() {5b}
  else if (propName = 'receiver') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageHeaderDestination.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'target') then result := 'Reference'
  else if (propName = 'endpoint') then result := 'url'
  else if (propName = 'receiver') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageHeaderDestination.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'target') then TargetElement := nil
  else if (propName = 'endpoint') then EndpointElement := nil
  else if (propName = 'receiver') then ReceiverElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageHeaderDestination.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'target') then TargetElement := new as TFhirReference{TFhirDevice}{4}
  else if (propName = 'endpoint') then EndpointElement := asUrl(new){5b}
  else if (propName = 'receiver') then ReceiverElement := new as TFhirReference{TFhirPractitioner}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageHeaderDestination.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageHeaderDestination.fhirType : string;
begin
  result := 'destination';
end;

function TFhirMessageHeaderDestination.Link : TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(inherited Link);
end;

function TFhirMessageHeaderDestination.Clone : TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(inherited Clone);
end;

function TFhirMessageHeaderDestination.equals(other : TObject) : boolean; 
var
  o : TFhirMessageHeaderDestination;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageHeaderDestination)) then
    result := false
  else
  begin
    o := TFhirMessageHeaderDestination(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(targetElement, o.targetElement, true) and 
      compareDeep(endpointElement, o.endpointElement, true) and compareDeep(receiverElement, o.receiverElement, true);
  end;
end;

function TFhirMessageHeaderDestination.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FTarget) and isEmptyProp(FEndpoint) and isEmptyProp(FReceiver);
end;

procedure TFhirMessageHeaderDestination.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('target');
  fields.add('endpoint');
  fields.add('receiver');
end;

{ TFhirMessageHeaderDestination }

Procedure TFhirMessageHeaderDestination.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirMessageHeaderDestination.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirMessageHeaderDestination.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirMessageHeaderDestination.SetTarget(value : TFhirReference{TFhirDevice});
begin
  FTarget.free;
  FTarget := value;
end;

Procedure TFhirMessageHeaderDestination.SetEndpoint(value : TFhirUrl);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

Function TFhirMessageHeaderDestination.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := FEndpoint.value;
end;

Procedure TFhirMessageHeaderDestination.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUrl.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;

Procedure TFhirMessageHeaderDestination.SetReceiver(value : TFhirReference{TFhirPractitioner});
begin
  FReceiver.free;
  FReceiver := value;
end;

function TFhirMessageHeaderDestination.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
  inc(result, FEndpoint.sizeInBytes);
  inc(result, FReceiver.sizeInBytes);
end;

{ TFhirMessageHeaderDestinationListEnumerator }

Constructor TFhirMessageHeaderDestinationListEnumerator.Create(list : TFhirMessageHeaderDestinationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageHeaderDestinationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderDestinationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageHeaderDestinationListEnumerator.GetCurrent : TFhirMessageHeaderDestination;
begin
  Result := FList[FIndex];
end;

function TFhirMessageHeaderDestinationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMessageHeaderDestinationList }
procedure TFhirMessageHeaderDestinationList.AddItem(value: TFhirMessageHeaderDestination);
begin
  assert(value.ClassName = 'TFhirMessageHeaderDestination', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderDestination');
  add(value);
end;

function TFhirMessageHeaderDestinationList.Append: TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderDestinationList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderDestinationList.GetEnumerator : TFhirMessageHeaderDestinationListEnumerator;
begin
  result := TFhirMessageHeaderDestinationListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderDestinationList.Clone: TFhirMessageHeaderDestinationList;
begin
  result := TFhirMessageHeaderDestinationList(inherited Clone);
end;

function TFhirMessageHeaderDestinationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderDestinationList.GetItemN(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(ObjectByIndex[index]);
end;

function TFhirMessageHeaderDestinationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageHeaderDestination;
end;
function TFhirMessageHeaderDestinationList.IndexOf(value: TFhirMessageHeaderDestination): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageHeaderDestinationList.Insert(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderDestinationList.InsertItem(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderDestinationList.Item(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(ObjectByIndex[index]);
end;

function TFhirMessageHeaderDestinationList.Link: TFhirMessageHeaderDestinationList;
begin
  result := TFhirMessageHeaderDestinationList(inherited Link);
end;

procedure TFhirMessageHeaderDestinationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderDestinationList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  FhirMessageHeaderDestinations[index] := value;
end;

procedure TFhirMessageHeaderDestinationList.SetItemN(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeaderSource }

constructor TFhirMessageHeaderSource.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderSource.Destroy;
begin
  FName.free;
  FSoftware.free;
  FVersion.free;
  FContact.free;
  FEndpoint.free;
  inherited;
end;

procedure TFhirMessageHeaderSource.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirMessageHeaderSource(oSource).nameElement.Clone;
  softwareElement := TFhirMessageHeaderSource(oSource).softwareElement.Clone;
  versionElement := TFhirMessageHeaderSource(oSource).versionElement.Clone;
  contact := TFhirMessageHeaderSource(oSource).contact.Clone;
  endpointElement := TFhirMessageHeaderSource(oSource).endpointElement.Clone;
end;

procedure TFhirMessageHeaderSource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'software') Then
     list.add(self.link, 'software', FSoftware.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'contact') Then
     list.add(self.link, 'contact', FContact.Link);
  if (child_name = 'endpoint') Then
     list.add(self.link, 'endpoint', FEndpoint.Link);
end;

procedure TFhirMessageHeaderSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'software', 'string', false, TFhirString, FSoftware.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactPoint', false, TFhirContactPoint, FContact.Link));{2}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'url', false, TFhirUrl, FEndpoint.Link));{2}
end;

function TFhirMessageHeaderSource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'software') then
  begin
    SoftwareElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    Contact := propValue as TFhirContactPoint{4b};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointElement := asUrl(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageHeaderSource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMessageHeaderSource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'software') then result := TFhirString.create() {5b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'contact') then result := TFhirContactPoint.create(){4b}
  else if (propName = 'endpoint') then result := TFhirUrl.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageHeaderSource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'software') then result := 'string'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'endpoint') then result := 'url'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageHeaderSource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'software') then SoftwareElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'contact') then ContactElement := nil
  else if (propName = 'endpoint') then EndpointElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageHeaderSource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'software') then SoftwareElement := asString(new){5b}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'contact') then ContactElement := new as TFhirContactPoint{4}
  else if (propName = 'endpoint') then EndpointElement := asUrl(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageHeaderSource.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageHeaderSource.fhirType : string;
begin
  result := 'source';
end;

function TFhirMessageHeaderSource.Link : TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(inherited Link);
end;

function TFhirMessageHeaderSource.Clone : TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(inherited Clone);
end;

function TFhirMessageHeaderSource.equals(other : TObject) : boolean; 
var
  o : TFhirMessageHeaderSource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageHeaderSource)) then
    result := false
  else
  begin
    o := TFhirMessageHeaderSource(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(softwareElement, o.softwareElement, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(contactElement, o.contactElement, true) and 
      compareDeep(endpointElement, o.endpointElement, true);
  end;
end;

function TFhirMessageHeaderSource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FSoftware) and isEmptyProp(FVersion) and isEmptyProp(FContact) and isEmptyProp(FEndpoint);
end;

procedure TFhirMessageHeaderSource.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('software');
  fields.add('version');
  fields.add('contact');
  fields.add('endpoint');
end;

{ TFhirMessageHeaderSource }

Procedure TFhirMessageHeaderSource.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirMessageHeaderSource.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirMessageHeaderSource.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirMessageHeaderSource.SetSoftware(value : TFhirString);
begin
  FSoftware.free;
  FSoftware := value;
end;

Function TFhirMessageHeaderSource.GetSoftwareST : String;
begin
  if FSoftware = nil then
    result := ''
  else
    result := FSoftware.value;
end;

Procedure TFhirMessageHeaderSource.SetSoftwareST(value : String);
begin
  if value <> '' then
  begin
    if FSoftware = nil then
      FSoftware := TFhirString.create;
    FSoftware.value := value
  end
  else if FSoftware <> nil then
    FSoftware.value := '';
end;

Procedure TFhirMessageHeaderSource.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirMessageHeaderSource.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirMessageHeaderSource.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirMessageHeaderSource.SetContact(value : TFhirContactPoint);
begin
  FContact.free;
  FContact := value;
end;

Procedure TFhirMessageHeaderSource.SetEndpoint(value : TFhirUrl);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

Function TFhirMessageHeaderSource.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := FEndpoint.value;
end;

Procedure TFhirMessageHeaderSource.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUrl.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;

function TFhirMessageHeaderSource.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FSoftware.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FContact.sizeInBytes);
  inc(result, FEndpoint.sizeInBytes);
end;

{ TFhirMessageHeaderSourceListEnumerator }

Constructor TFhirMessageHeaderSourceListEnumerator.Create(list : TFhirMessageHeaderSourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageHeaderSourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderSourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageHeaderSourceListEnumerator.GetCurrent : TFhirMessageHeaderSource;
begin
  Result := FList[FIndex];
end;

function TFhirMessageHeaderSourceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMessageHeaderSourceList }
procedure TFhirMessageHeaderSourceList.AddItem(value: TFhirMessageHeaderSource);
begin
  assert(value.ClassName = 'TFhirMessageHeaderSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderSource');
  add(value);
end;

function TFhirMessageHeaderSourceList.Append: TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderSourceList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderSourceList.GetEnumerator : TFhirMessageHeaderSourceListEnumerator;
begin
  result := TFhirMessageHeaderSourceListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderSourceList.Clone: TFhirMessageHeaderSourceList;
begin
  result := TFhirMessageHeaderSourceList(inherited Clone);
end;

function TFhirMessageHeaderSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderSourceList.GetItemN(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(ObjectByIndex[index]);
end;

function TFhirMessageHeaderSourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageHeaderSource;
end;
function TFhirMessageHeaderSourceList.IndexOf(value: TFhirMessageHeaderSource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageHeaderSourceList.Insert(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderSourceList.InsertItem(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderSourceList.Item(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(ObjectByIndex[index]);
end;

function TFhirMessageHeaderSourceList.Link: TFhirMessageHeaderSourceList;
begin
  result := TFhirMessageHeaderSourceList(inherited Link);
end;

procedure TFhirMessageHeaderSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderSourceList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  FhirMessageHeaderSources[index] := value;
end;

procedure TFhirMessageHeaderSourceList.SetItemN(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeaderResponse }

constructor TFhirMessageHeaderResponse.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderResponse.Destroy;
begin
  FIdentifier.free;
  FCode.free;
  FDetails.free;
  inherited;
end;

procedure TFhirMessageHeaderResponse.Assign(oSource : TFslObject);
begin
  inherited;
  identifierElement := TFhirMessageHeaderResponse(oSource).identifierElement.Clone;
  FCode := TFhirMessageHeaderResponse(oSource).FCode.Link;
  details := TFhirMessageHeaderResponse(oSource).details.Clone;
end;

procedure TFhirMessageHeaderResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'details') Then
     list.add(self.link, 'details', FDetails.Link);
end;

procedure TFhirMessageHeaderResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'id', false, TFhirId, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFHIREnum, FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'details', 'Reference(OperationOutcome)', false, TFhirReference{TFhirOperationOutcome}, FDetails.Link));{2}
end;

function TFhirMessageHeaderResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirResponseCodeEnum, CODES_TFhirResponseCodeEnum, propValue);
    result := propValue
  end
  else if (propName = 'details') then
  begin
    Details := propValue as TFhirReference{TFhirOperationOutcome}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageHeaderResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMessageHeaderResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirId.create() {5b}
  else if (propName = 'details') then result := TFhirReference{TFhirOperationOutcome}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageHeaderResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'id'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'details') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageHeaderResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'details') then DetailsElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageHeaderResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := asId(new){5b}
  else if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirResponseCodeEnum, CODES_TFhirResponseCodeEnum, new){4}
  else if (propName = 'details') then DetailsElement := new as TFhirReference{TFhirOperationOutcome}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageHeaderResponse.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageHeaderResponse.fhirType : string;
begin
  result := 'response';
end;

function TFhirMessageHeaderResponse.Link : TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(inherited Link);
end;

function TFhirMessageHeaderResponse.Clone : TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(inherited Clone);
end;

function TFhirMessageHeaderResponse.equals(other : TObject) : boolean; 
var
  o : TFhirMessageHeaderResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageHeaderResponse)) then
    result := false
  else
  begin
    o := TFhirMessageHeaderResponse(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(detailsElement, o.detailsElement, true);
  end;
end;

function TFhirMessageHeaderResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FCode) and isEmptyProp(FDetails);
end;

procedure TFhirMessageHeaderResponse.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('details');
end;

{ TFhirMessageHeaderResponse }

Procedure TFhirMessageHeaderResponse.SetIdentifier(value : TFhirId);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirMessageHeaderResponse.GetIdentifierST : String;
begin
  if FIdentifier = nil then
    result := ''
  else
    result := FIdentifier.value;
end;

Procedure TFhirMessageHeaderResponse.SetIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FIdentifier = nil then
      FIdentifier := TFhirId.create;
    FIdentifier.value := value
  end
  else if FIdentifier <> nil then
    FIdentifier.value := '';
end;

Procedure TFhirMessageHeaderResponse.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirMessageHeaderResponse.GetCodeST : TFhirResponseCodeEnum;
begin
  if FCode = nil then
    result := TFhirResponseCodeEnum(0)
  else
    result := TFhirResponseCodeEnum(StringArrayIndexOfSensitive(CODES_TFhirResponseCodeEnum, FCode.value));
end;

Procedure TFhirMessageHeaderResponse.SetCodeST(value : TFhirResponseCodeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirResponseCodeEnum[value], CODES_TFhirResponseCodeEnum[value]);
end;

Procedure TFhirMessageHeaderResponse.SetDetails(value : TFhirReference{TFhirOperationOutcome});
begin
  FDetails.free;
  FDetails := value;
end;

function TFhirMessageHeaderResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FDetails.sizeInBytes);
end;

{ TFhirMessageHeaderResponseListEnumerator }

Constructor TFhirMessageHeaderResponseListEnumerator.Create(list : TFhirMessageHeaderResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageHeaderResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageHeaderResponseListEnumerator.GetCurrent : TFhirMessageHeaderResponse;
begin
  Result := FList[FIndex];
end;

function TFhirMessageHeaderResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMessageHeaderResponseList }
procedure TFhirMessageHeaderResponseList.AddItem(value: TFhirMessageHeaderResponse);
begin
  assert(value.ClassName = 'TFhirMessageHeaderResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderResponse');
  add(value);
end;

function TFhirMessageHeaderResponseList.Append: TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderResponseList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderResponseList.GetEnumerator : TFhirMessageHeaderResponseListEnumerator;
begin
  result := TFhirMessageHeaderResponseListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderResponseList.Clone: TFhirMessageHeaderResponseList;
begin
  result := TFhirMessageHeaderResponseList(inherited Clone);
end;

function TFhirMessageHeaderResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderResponseList.GetItemN(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(ObjectByIndex[index]);
end;

function TFhirMessageHeaderResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageHeaderResponse;
end;
function TFhirMessageHeaderResponseList.IndexOf(value: TFhirMessageHeaderResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageHeaderResponseList.Insert(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderResponseList.InsertItem(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderResponseList.Item(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(ObjectByIndex[index]);
end;

function TFhirMessageHeaderResponseList.Link: TFhirMessageHeaderResponseList;
begin
  result := TFhirMessageHeaderResponseList(inherited Link);
end;

procedure TFhirMessageHeaderResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderResponseList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  FhirMessageHeaderResponses[index] := value;
end;

procedure TFhirMessageHeaderResponseList.SetItemN(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeader }

constructor TFhirMessageHeader.Create;
begin
  inherited;
end;

destructor TFhirMessageHeader.Destroy;
begin
  FEvent.free;
  FDestinationList.Free;
  FSender.free;
  FEnterer.free;
  FAuthor.free;
  FSource.free;
  FResponsible.free;
  FReason.free;
  FResponse.free;
  FFocusList.Free;
  FDefinition.free;
  inherited;
end;

function TFhirMessageHeader.GetResourceType : TFhirResourceType;
begin
  result := frtMessageHeader;
end;

procedure TFhirMessageHeader.Assign(oSource : TFslObject);
begin
  inherited;
  event := TFhirMessageHeader(oSource).event.Clone;
  if (TFhirMessageHeader(oSource).FDestinationList = nil) then
  begin
    FDestinationList.free;
    FDestinationList := nil;
  end
  else
  begin
    if FDestinationList = nil then
      FDestinationList := TFhirMessageHeaderDestinationList.Create;
    FDestinationList.Assign(TFhirMessageHeader(oSource).FDestinationList);
  end;
  sender := TFhirMessageHeader(oSource).sender.Clone;
  enterer := TFhirMessageHeader(oSource).enterer.Clone;
  author := TFhirMessageHeader(oSource).author.Clone;
  source := TFhirMessageHeader(oSource).source.Clone;
  responsible := TFhirMessageHeader(oSource).responsible.Clone;
  reason := TFhirMessageHeader(oSource).reason.Clone;
  response := TFhirMessageHeader(oSource).response.Clone;
  if (TFhirMessageHeader(oSource).FFocusList = nil) then
  begin
    FFocusList.free;
    FFocusList := nil;
  end
  else
  begin
    if FFocusList = nil then
      FFocusList := TFhirReferenceList{TFhirReference}.Create;
    FFocusList.Assign(TFhirMessageHeader(oSource).FFocusList);
  end;
  definitionElement := TFhirMessageHeader(oSource).definitionElement.Clone;
end;

procedure TFhirMessageHeader.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'event[x]') or (child_name = 'event') Then
     list.add(self.link, 'event[x]', FEvent.Link);
  if (child_name = 'destination') Then
    list.addAll(self, 'destination', FDestinationList);
  if (child_name = 'sender') Then
     list.add(self.link, 'sender', FSender.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'focus') Then
    list.addAll(self, 'focus', FFocusList);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
end;

procedure TFhirMessageHeader.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'event[x]', 'Coding|uri', false, TFhirType, FEvent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'destination', '', true, TFhirMessageHeaderDestination, FDestinationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'sender', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FSender.Link));{2}
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FEnterer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FAuthor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', '', false, TFhirMessageHeaderSource, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'responsible', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FResponsible.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'response', '', false, TFhirMessageHeaderResponse, FResponse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'focus', 'Reference(Any)', true, TFhirReference{TFhirReference}, FFocusList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'definition', 'canonical', false, TFhirCanonical, FDefinition.Link));{2}
end;

function TFhirMessageHeader.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'event', ['Coding', 'Uri'])) then
  begin
    Event := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    DestinationList.add(propValue as TFhirMessageHeaderDestination){2a};
    result := propValue;
  end
  else if (propName = 'sender') then
  begin
    Sender := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirMessageHeaderSource{4b};
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    Responsible := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirMessageHeaderResponse{4b};
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    FocusList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionElement := asCanonical(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMessageHeader.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'destination') then DestinationList.insertItem(index, propValue as TFhirMessageHeaderDestination){2a}
  else if (propName = 'focus') then FocusList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else inherited;
end;

function TFhirMessageHeader.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'event', ['Coding', 'Uri'])) then raise EFHIRException.create('Cannot make property Event'){4x}
  else if (propName = 'destination') then result := DestinationList.new(){2}
  else if (propName = 'sender') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'enterer') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'author') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'source') then result := TFhirMessageHeaderSource.create(){4b}
  else if (propName = 'responsible') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'reason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'response') then result := TFhirMessageHeaderResponse.create(){4b}
  else if (propName = 'focus') then result := FocusList.new(){2}
  else if (propName = 'definition') then result := TFhirCanonical.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageHeader.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'event[x]') then result := 'Coding|uri'
  else if (propName = 'destination') then result := ''
  else if (propName = 'sender') then result := 'Reference'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'source') then result := ''
  else if (propName = 'responsible') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'response') then result := ''
  else if (propName = 'focus') then result := 'Reference'
  else if (propName = 'definition') then result := 'canonical'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageHeader.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'event', ['Coding', 'Uri'])) then EventElement := nil{4x}
  else if (propName = 'destination') then deletePropertyValue('destination', DestinationList, value) {2}
  else if (propName = 'sender') then SenderElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'focus') then deletePropertyValue('focus', FocusList, value) {2}
  else if (propName = 'definition') then DefinitionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageHeader.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'event', ['Coding', 'Uri'])) then EventElement := new as TFhirType{4x}
  else if (propName = 'destination') then replacePropertyValue('destination', DestinationList, existing, new) {2}
  else if (propName = 'sender') then SenderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'enterer') then EntererElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'source') then SourceElement := new as TFhirMessageHeaderSource{4}
  else if (propName = 'responsible') then ResponsibleElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'response') then ResponseElement := new as TFhirMessageHeaderResponse{4}
  else if (propName = 'focus') then replacePropertyValue('focus', FocusList, existing, new) {2}
  else if (propName = 'definition') then DefinitionElement := asCanonical(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageHeader.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'destination') then DestinationList.move(source, destination){2a}
  else if (propName = 'focus') then FocusList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageHeader.fhirType : string;
begin
  result := 'MessageHeader';
end;

function TFhirMessageHeader.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEvent) and isEmptyProp(FdestinationList) and isEmptyProp(FSender) and isEmptyProp(FEnterer) and isEmptyProp(FAuthor) and isEmptyProp(FSource) and isEmptyProp(FResponsible) and isEmptyProp(FReason) and isEmptyProp(FResponse) and isEmptyProp(FfocusList) and isEmptyProp(FDefinition);
end;

function TFhirMessageHeader.equals(other : TObject) : boolean; 
var
  o : TFhirMessageHeader;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageHeader)) then
    result := false
  else
  begin
    o := TFhirMessageHeader(other);
    result := compareDeep(eventElement, o.eventElement, true) and compareDeep(destinationList, o.destinationList, true) and 
      compareDeep(senderElement, o.senderElement, true) and compareDeep(entererElement, o.entererElement, true) and 
      compareDeep(authorElement, o.authorElement, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(responsibleElement, o.responsibleElement, true) and compareDeep(reasonElement, o.reasonElement, true) and 
      compareDeep(responseElement, o.responseElement, true) and compareDeep(focusList, o.focusList, true) and 
      compareDeep(definitionElement, o.definitionElement, true);
  end;
end;

function TFhirMessageHeader.Link : TFhirMessageHeader;
begin
  result := TFhirMessageHeader(inherited Link);
end;

function TFhirMessageHeader.Clone : TFhirMessageHeader;
begin
  result := TFhirMessageHeader(inherited Clone);
end;

procedure TFhirMessageHeader.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('event[x]');
  fields.add('destination');
  fields.add('sender');
  fields.add('enterer');
  fields.add('author');
  fields.add('source');
  fields.add('responsible');
  fields.add('reason');
  fields.add('response');
  fields.add('focus');
  fields.add('definition');
end;

{ TFhirMessageHeader }

Procedure TFhirMessageHeader.SetEvent(value : TFhirType);
begin
  FEvent.free;
  FEvent := value;
end;

Function TFhirMessageHeader.GetDestinationList : TFhirMessageHeaderDestinationList;
begin
  if FDestinationList = nil then
    FDestinationList := TFhirMessageHeaderDestinationList.Create;
  result := FDestinationList;
end;

Function TFhirMessageHeader.GetHasDestinationList : boolean;
begin
  result := (FDestinationList <> nil) and (FDestinationList.count > 0);
end;

Procedure TFhirMessageHeader.SetSender(value : TFhirReference{TFhirPractitioner});
begin
  FSender.free;
  FSender := value;
end;

Procedure TFhirMessageHeader.SetEnterer(value : TFhirReference{TFhirPractitioner});
begin
  FEnterer.free;
  FEnterer := value;
end;

Procedure TFhirMessageHeader.SetAuthor(value : TFhirReference{TFhirPractitioner});
begin
  FAuthor.free;
  FAuthor := value;
end;

Procedure TFhirMessageHeader.SetSource(value : TFhirMessageHeaderSource);
begin
  FSource.free;
  FSource := value;
end;

Procedure TFhirMessageHeader.SetResponsible(value : TFhirReference{TFhirPractitioner});
begin
  FResponsible.free;
  FResponsible := value;
end;

Procedure TFhirMessageHeader.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

Procedure TFhirMessageHeader.SetResponse(value : TFhirMessageHeaderResponse);
begin
  FResponse.free;
  FResponse := value;
end;

Function TFhirMessageHeader.GetFocusList : TFhirReferenceList{TFhirReference};
begin
  if FFocusList = nil then
    FFocusList := TFhirReferenceList{TFhirReference}.Create;
  result := FFocusList;
end;

Function TFhirMessageHeader.GetHasFocusList : boolean;
begin
  result := (FFocusList <> nil) and (FFocusList.count > 0);
end;

Procedure TFhirMessageHeader.SetDefinition(value : TFhirCanonical);
begin
  FDefinition.free;
  FDefinition := value;
end;

Function TFhirMessageHeader.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

Procedure TFhirMessageHeader.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirCanonical.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

function TFhirMessageHeader.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FEvent.sizeInBytes);
  inc(result, FdestinationList.sizeInBytes);
  inc(result, FSender.sizeInBytes);
  inc(result, FEnterer.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FResponsible.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FResponse.sizeInBytes);
  inc(result, FfocusList.sizeInBytes);
  inc(result, FDefinition.sizeInBytes);
end;

{ TFhirMessageHeaderListEnumerator }

Constructor TFhirMessageHeaderListEnumerator.Create(list : TFhirMessageHeaderList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageHeaderListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageHeaderListEnumerator.GetCurrent : TFhirMessageHeader;
begin
  Result := FList[FIndex];
end;

function TFhirMessageHeaderListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMessageHeaderList }
procedure TFhirMessageHeaderList.AddItem(value: TFhirMessageHeader);
begin
  assert(value.ClassName = 'TFhirMessageHeader', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeader');
  add(value);
end;

function TFhirMessageHeaderList.Append: TFhirMessageHeader;
begin
  result := TFhirMessageHeader.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderList.GetEnumerator : TFhirMessageHeaderListEnumerator;
begin
  result := TFhirMessageHeaderListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderList.Clone: TFhirMessageHeaderList;
begin
  result := TFhirMessageHeaderList(inherited Clone);
end;

function TFhirMessageHeaderList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderList.GetItemN(index: Integer): TFhirMessageHeader;
begin
  result := TFhirMessageHeader(ObjectByIndex[index]);
end;

function TFhirMessageHeaderList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageHeader;
end;
function TFhirMessageHeaderList.IndexOf(value: TFhirMessageHeader): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageHeaderList.Insert(index: Integer): TFhirMessageHeader;
begin
  result := TFhirMessageHeader.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderList.InsertItem(index: Integer; value: TFhirMessageHeader);
begin
  assert(value is TFhirMessageHeader);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderList.Item(index: Integer): TFhirMessageHeader;
begin
  result := TFhirMessageHeader(ObjectByIndex[index]);
end;

function TFhirMessageHeaderList.Link: TFhirMessageHeaderList;
begin
  result := TFhirMessageHeaderList(inherited Link);
end;

procedure TFhirMessageHeaderList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderList.SetItemByIndex(index: Integer; value: TFhirMessageHeader);
begin
  assert(value is TFhirMessageHeader);
  FhirMessageHeaders[index] := value;
end;

procedure TFhirMessageHeaderList.SetItemN(index: Integer; value: TFhirMessageHeader);
begin
  assert(value is TFhirMessageHeader);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MESSAGEHEADER}

{$IFDEF FHIR_OPERATIONOUTCOME}

{ TFhirOperationOutcomeIssue }

constructor TFhirOperationOutcomeIssue.Create;
begin
  inherited;
end;

destructor TFhirOperationOutcomeIssue.Destroy;
begin
  FSeverity.free;
  FCode.free;
  FDetails.free;
  FDiagnostics.free;
  FLocationList.Free;
  FExpressionList.Free;
  inherited;
end;

procedure TFhirOperationOutcomeIssue.Assign(oSource : TFslObject);
begin
  inherited;
  FSeverity := TFhirOperationOutcomeIssue(oSource).FSeverity.Link;
  FCode := TFhirOperationOutcomeIssue(oSource).FCode.Link;
  details := TFhirOperationOutcomeIssue(oSource).details.Clone;
  diagnosticsElement := TFhirOperationOutcomeIssue(oSource).diagnosticsElement.Clone;
  if (TFhirOperationOutcomeIssue(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirStringList.Create;
    FLocationList.Assign(TFhirOperationOutcomeIssue(oSource).FLocationList);
  end;
  if (TFhirOperationOutcomeIssue(oSource).FExpressionList = nil) then
  begin
    FExpressionList.free;
    FExpressionList := nil;
  end
  else
  begin
    if FExpressionList = nil then
      FExpressionList := TFhirStringList.Create;
    FExpressionList.Assign(TFhirOperationOutcomeIssue(oSource).FExpressionList);
  end;
end;

procedure TFhirOperationOutcomeIssue.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'severity') Then
     list.add(self.link, 'severity', FSeverity.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'details') Then
     list.add(self.link, 'details', FDetails.Link);
  if (child_name = 'diagnostics') Then
     list.add(self.link, 'diagnostics', FDiagnostics.Link);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'expression') Then
    list.addAll(self, 'expression', FExpressionList);
end;

procedure TFhirOperationOutcomeIssue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'severity', 'code', false, TFHIREnum, FSeverity.Link));{1}
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFHIREnum, FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'details', 'CodeableConcept', false, TFhirCodeableConcept, FDetails.Link));{2}
  oList.add(TFHIRProperty.create(self, 'diagnostics', 'string', false, TFhirString, FDiagnostics.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'string', true, TFhirString, FLocationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'expression', 'string', true, TFhirString, FExpressionList.Link)){3};
end;

function TFhirOperationOutcomeIssue.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'severity') then
  begin
    SeverityElement := asEnum(SYSTEMS_TFhirIssueSeverityEnum, CODES_TFhirIssueSeverityEnum, propValue);
    result := propValue
  end
  else if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirIssueTypeEnum, CODES_TFhirIssueTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'details') then
  begin
    Details := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'diagnostics') then
  begin
    DiagnosticsElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'expression') then
  begin
    ExpressionList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOperationOutcomeIssue.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'location') then LocationList.insertItem(index, asString(propValue)){2}
  else if (propName = 'expression') then ExpressionList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirOperationOutcomeIssue.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'details') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'diagnostics') then result := TFhirString.create() {5b}
  else if (propName = 'location') then result := LocationList.new(){2}
  else if (propName = 'expression') then result := ExpressionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationOutcomeIssue.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'severity') then result := 'code'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'details') then result := 'CodeableConcept'
  else if (propName = 'diagnostics') then result := 'string'
  else if (propName = 'location') then result := 'string'
  else if (propName = 'expression') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationOutcomeIssue.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'severity') then SeverityElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'details') then DetailsElement := nil
  else if (propName = 'diagnostics') then DiagnosticsElement := nil
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value) {2}
  else if (propName = 'expression') then deletePropertyValue('expression', ExpressionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationOutcomeIssue.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'severity') then SeverityElement := asEnum(SYSTEMS_TFhirIssueSeverityEnum, CODES_TFhirIssueSeverityEnum, new){4}
  else if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirIssueTypeEnum, CODES_TFhirIssueTypeEnum, new){4}
  else if (propName = 'details') then DetailsElement := new as TFhirCodeableConcept{4}
  else if (propName = 'diagnostics') then DiagnosticsElement := asString(new){5b}
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new) {2}
  else if (propName = 'expression') then replacePropertyValue('expression', ExpressionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationOutcomeIssue.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'location') then LocationList.move(source, destination){2}
  else if (propName = 'expression') then ExpressionList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationOutcomeIssue.fhirType : string;
begin
  result := 'issue';
end;

function TFhirOperationOutcomeIssue.Link : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(inherited Link);
end;

function TFhirOperationOutcomeIssue.Clone : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(inherited Clone);
end;

function TFhirOperationOutcomeIssue.equals(other : TObject) : boolean; 
var
  o : TFhirOperationOutcomeIssue;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationOutcomeIssue)) then
    result := false
  else
  begin
    o := TFhirOperationOutcomeIssue(other);
    result := compareDeep(severityElement, o.severityElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(detailsElement, o.detailsElement, true) and compareDeep(diagnosticsElement, o.diagnosticsElement, true) and 
      compareDeep(locationList, o.locationList, true) and compareDeep(expressionList, o.expressionList, true);
  end;
end;

function TFhirOperationOutcomeIssue.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSeverity) and isEmptyProp(FCode) and isEmptyProp(FDetails) and isEmptyProp(FDiagnostics) and isEmptyProp(FlocationList) and isEmptyProp(FexpressionList);
end;

procedure TFhirOperationOutcomeIssue.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('severity');
  fields.add('code');
  fields.add('details');
  fields.add('diagnostics');
  fields.add('location');
  fields.add('expression');
end;

{ TFhirOperationOutcomeIssue }

Procedure TFhirOperationOutcomeIssue.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

Function TFhirOperationOutcomeIssue.GetSeverityST : TFhirIssueSeverityEnum;
begin
  if FSeverity = nil then
    result := TFhirIssueSeverityEnum(0)
  else
    result := TFhirIssueSeverityEnum(StringArrayIndexOfSensitive(CODES_TFhirIssueSeverityEnum, FSeverity.value));
end;

Procedure TFhirOperationOutcomeIssue.SetSeverityST(value : TFhirIssueSeverityEnum);
begin
  if ord(value) = 0 then
    SeverityElement := nil
  else
    SeverityElement := TFhirEnum.create(SYSTEMS_TFhirIssueSeverityEnum[value], CODES_TFhirIssueSeverityEnum[value]);
end;

Procedure TFhirOperationOutcomeIssue.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirOperationOutcomeIssue.GetCodeST : TFhirIssueTypeEnum;
begin
  if FCode = nil then
    result := TFhirIssueTypeEnum(0)
  else
    result := TFhirIssueTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirIssueTypeEnum, FCode.value));
end;

Procedure TFhirOperationOutcomeIssue.SetCodeST(value : TFhirIssueTypeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirIssueTypeEnum[value], CODES_TFhirIssueTypeEnum[value]);
end;

Procedure TFhirOperationOutcomeIssue.SetDetails(value : TFhirCodeableConcept);
begin
  FDetails.free;
  FDetails := value;
end;

Procedure TFhirOperationOutcomeIssue.SetDiagnostics(value : TFhirString);
begin
  FDiagnostics.free;
  FDiagnostics := value;
end;

Function TFhirOperationOutcomeIssue.GetDiagnosticsST : String;
begin
  if FDiagnostics = nil then
    result := ''
  else
    result := FDiagnostics.value;
end;

Procedure TFhirOperationOutcomeIssue.SetDiagnosticsST(value : String);
begin
  if value <> '' then
  begin
    if FDiagnostics = nil then
      FDiagnostics := TFhirString.create;
    FDiagnostics.value := value
  end
  else if FDiagnostics <> nil then
    FDiagnostics.value := '';
end;

Function TFhirOperationOutcomeIssue.GetLocationList : TFhirStringList;
begin
  if FLocationList = nil then
    FLocationList := TFhirStringList.Create;
  result := FLocationList;
end;

Function TFhirOperationOutcomeIssue.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

Function TFhirOperationOutcomeIssue.GetExpressionList : TFhirStringList;
begin
  if FExpressionList = nil then
    FExpressionList := TFhirStringList.Create;
  result := FExpressionList;
end;

Function TFhirOperationOutcomeIssue.GetHasExpressionList : boolean;
begin
  result := (FExpressionList <> nil) and (FExpressionList.count > 0);
end;

function TFhirOperationOutcomeIssue.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSeverity.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FDetails.sizeInBytes);
  inc(result, FDiagnostics.sizeInBytes);
  inc(result, FlocationList.sizeInBytes);
  inc(result, FexpressionList.sizeInBytes);
end;

{ TFhirOperationOutcomeIssueListEnumerator }

Constructor TFhirOperationOutcomeIssueListEnumerator.Create(list : TFhirOperationOutcomeIssueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationOutcomeIssueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationOutcomeIssueListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationOutcomeIssueListEnumerator.GetCurrent : TFhirOperationOutcomeIssue;
begin
  Result := FList[FIndex];
end;

function TFhirOperationOutcomeIssueListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOperationOutcomeIssueList }
procedure TFhirOperationOutcomeIssueList.AddItem(value: TFhirOperationOutcomeIssue);
begin
  assert(value.ClassName = 'TFhirOperationOutcomeIssue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationOutcomeIssue');
  add(value);
end;

function TFhirOperationOutcomeIssueList.Append: TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationOutcomeIssueList.ClearItems;
begin
  Clear;
end;

function TFhirOperationOutcomeIssueList.GetEnumerator : TFhirOperationOutcomeIssueListEnumerator;
begin
  result := TFhirOperationOutcomeIssueListEnumerator.Create(self.link);
end;

function TFhirOperationOutcomeIssueList.Clone: TFhirOperationOutcomeIssueList;
begin
  result := TFhirOperationOutcomeIssueList(inherited Clone);
end;

function TFhirOperationOutcomeIssueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationOutcomeIssueList.GetItemN(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeIssueList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationOutcomeIssue;
end;
function TFhirOperationOutcomeIssueList.IndexOf(value: TFhirOperationOutcomeIssue): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationOutcomeIssueList.Insert(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationOutcomeIssueList.InsertItem(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  Inherited Insert(index, value);
end;

function TFhirOperationOutcomeIssueList.Item(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeIssueList.Link: TFhirOperationOutcomeIssueList;
begin
  result := TFhirOperationOutcomeIssueList(inherited Link);
end;

procedure TFhirOperationOutcomeIssueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationOutcomeIssueList.SetItemByIndex(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  FhirOperationOutcomeIssues[index] := value;
end;

procedure TFhirOperationOutcomeIssueList.SetItemN(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  ObjectByIndex[index] := value;
end;

{ TFhirOperationOutcome }

constructor TFhirOperationOutcome.Create;
begin
  inherited;
end;

destructor TFhirOperationOutcome.Destroy;
begin
  FIssueList.Free;
  inherited;
end;

function TFhirOperationOutcome.GetResourceType : TFhirResourceType;
begin
  result := frtOperationOutcome;
end;

procedure TFhirOperationOutcome.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirOperationOutcome(oSource).FIssueList = nil) then
  begin
    FIssueList.free;
    FIssueList := nil;
  end
  else
  begin
    if FIssueList = nil then
      FIssueList := TFhirOperationOutcomeIssueList.Create;
    FIssueList.Assign(TFhirOperationOutcome(oSource).FIssueList);
  end;
end;

procedure TFhirOperationOutcome.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'issue') Then
    list.addAll(self, 'issue', FIssueList);
end;

procedure TFhirOperationOutcome.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'issue', '', true, TFhirOperationOutcomeIssue, FIssueList.Link)){3};
end;

function TFhirOperationOutcome.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'issue') then
  begin
    IssueList.add(propValue as TFhirOperationOutcomeIssue){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirOperationOutcome.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'issue') then IssueList.insertItem(index, propValue as TFhirOperationOutcomeIssue){2a}
  else inherited;
end;

function TFhirOperationOutcome.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'issue') then result := IssueList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationOutcome.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'issue') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationOutcome.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'issue') then deletePropertyValue('issue', IssueList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationOutcome.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'issue') then replacePropertyValue('issue', IssueList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationOutcome.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'issue') then IssueList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationOutcome.fhirType : string;
begin
  result := 'OperationOutcome';
end;

function TFhirOperationOutcome.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FissueList);
end;

function TFhirOperationOutcome.equals(other : TObject) : boolean; 
var
  o : TFhirOperationOutcome;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationOutcome)) then
    result := false
  else
  begin
    o := TFhirOperationOutcome(other);
    result := compareDeep(issueList, o.issueList, true);
  end;
end;

function TFhirOperationOutcome.Link : TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome(inherited Link);
end;

function TFhirOperationOutcome.Clone : TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome(inherited Clone);
end;

procedure TFhirOperationOutcome.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('issue');
end;

{ TFhirOperationOutcome }

Function TFhirOperationOutcome.GetIssueList : TFhirOperationOutcomeIssueList;
begin
  if FIssueList = nil then
    FIssueList := TFhirOperationOutcomeIssueList.Create;
  result := FIssueList;
end;

Function TFhirOperationOutcome.GetHasIssueList : boolean;
begin
  result := (FIssueList <> nil) and (FIssueList.count > 0);
end;

function TFhirOperationOutcome.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FissueList.sizeInBytes);
end;

{ TFhirOperationOutcomeListEnumerator }

Constructor TFhirOperationOutcomeListEnumerator.Create(list : TFhirOperationOutcomeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationOutcomeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationOutcomeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationOutcomeListEnumerator.GetCurrent : TFhirOperationOutcome;
begin
  Result := FList[FIndex];
end;

function TFhirOperationOutcomeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOperationOutcomeList }
procedure TFhirOperationOutcomeList.AddItem(value: TFhirOperationOutcome);
begin
  assert(value.ClassName = 'TFhirOperationOutcome', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationOutcome');
  add(value);
end;

function TFhirOperationOutcomeList.Append: TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationOutcomeList.ClearItems;
begin
  Clear;
end;

function TFhirOperationOutcomeList.GetEnumerator : TFhirOperationOutcomeListEnumerator;
begin
  result := TFhirOperationOutcomeListEnumerator.Create(self.link);
end;

function TFhirOperationOutcomeList.Clone: TFhirOperationOutcomeList;
begin
  result := TFhirOperationOutcomeList(inherited Clone);
end;

function TFhirOperationOutcomeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationOutcomeList.GetItemN(index: Integer): TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationOutcome;
end;
function TFhirOperationOutcomeList.IndexOf(value: TFhirOperationOutcome): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationOutcomeList.Insert(index: Integer): TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationOutcomeList.InsertItem(index: Integer; value: TFhirOperationOutcome);
begin
  assert(value is TFhirOperationOutcome);
  Inherited Insert(index, value);
end;

function TFhirOperationOutcomeList.Item(index: Integer): TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeList.Link: TFhirOperationOutcomeList;
begin
  result := TFhirOperationOutcomeList(inherited Link);
end;

procedure TFhirOperationOutcomeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationOutcomeList.SetItemByIndex(index: Integer; value: TFhirOperationOutcome);
begin
  assert(value is TFhirOperationOutcome);
  FhirOperationOutcomes[index] := value;
end;

procedure TFhirOperationOutcomeList.SetItemN(index: Integer; value: TFhirOperationOutcome);
begin
  assert(value is TFhirOperationOutcome);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_OPERATIONOUTCOME}

{$IFDEF FHIR_PROVENANCE}

{ TFhirProvenanceAgent }

constructor TFhirProvenanceAgent.Create;
begin
  inherited;
end;

destructor TFhirProvenanceAgent.Destroy;
begin
  FType_.free;
  FRoleList.Free;
  FWho.free;
  FOnBehalfOf.free;
  inherited;
end;

procedure TFhirProvenanceAgent.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirProvenanceAgent(oSource).type_.Clone;
  if (TFhirProvenanceAgent(oSource).FRoleList = nil) then
  begin
    FRoleList.free;
    FRoleList := nil;
  end
  else
  begin
    if FRoleList = nil then
      FRoleList := TFhirCodeableConceptList.Create;
    FRoleList.Assign(TFhirProvenanceAgent(oSource).FRoleList);
  end;
  who := TFhirProvenanceAgent(oSource).who.Clone;
  onBehalfOf := TFhirProvenanceAgent(oSource).onBehalfOf.Clone;
end;

procedure TFhirProvenanceAgent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'role') Then
    list.addAll(self, 'role', FRoleList);
  if (child_name = 'who') Then
     list.add(self.link, 'who', FWho.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
end;

procedure TFhirProvenanceAgent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', true, TFhirCodeableConcept, FRoleList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'who', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FWho.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FOnBehalfOf.Link));{2}
end;

function TFhirProvenanceAgent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    RoleList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'who') then
  begin
    Who := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProvenanceAgent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'role') then RoleList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirProvenanceAgent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'role') then result := RoleList.new(){2}
  else if (propName = 'who') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'onBehalfOf') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProvenanceAgent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'who') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProvenanceAgent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'role') then deletePropertyValue('role', RoleList, value) {2}
  else if (propName = 'who') then WhoElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProvenanceAgent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'role') then replacePropertyValue('role', RoleList, existing, new) {2}
  else if (propName = 'who') then WhoElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference{TFhirPractitioner}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProvenanceAgent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'role') then RoleList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProvenanceAgent.fhirType : string;
begin
  result := 'agent';
end;

function TFhirProvenanceAgent.Link : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(inherited Link);
end;

function TFhirProvenanceAgent.Clone : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(inherited Clone);
end;

function TFhirProvenanceAgent.equals(other : TObject) : boolean; 
var
  o : TFhirProvenanceAgent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProvenanceAgent)) then
    result := false
  else
  begin
    o := TFhirProvenanceAgent(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(roleList, o.roleList, true) and 
      compareDeep(whoElement, o.whoElement, true) and compareDeep(onBehalfOfElement, o.onBehalfOfElement, true);
  end;
end;

function TFhirProvenanceAgent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FroleList) and isEmptyProp(FWho) and isEmptyProp(FOnBehalfOf);
end;

procedure TFhirProvenanceAgent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('role');
  fields.add('who');
  fields.add('onBehalfOf');
end;

{ TFhirProvenanceAgent }

Procedure TFhirProvenanceAgent.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirProvenanceAgent.GetRoleList : TFhirCodeableConceptList;
begin
  if FRoleList = nil then
    FRoleList := TFhirCodeableConceptList.Create;
  result := FRoleList;
end;

Function TFhirProvenanceAgent.GetHasRoleList : boolean;
begin
  result := (FRoleList <> nil) and (FRoleList.count > 0);
end;

Procedure TFhirProvenanceAgent.SetWho(value : TFhirReference{TFhirPractitioner});
begin
  FWho.free;
  FWho := value;
end;

Procedure TFhirProvenanceAgent.SetOnBehalfOf(value : TFhirReference{TFhirPractitioner});
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

function TFhirProvenanceAgent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FroleList.sizeInBytes);
  inc(result, FWho.sizeInBytes);
  inc(result, FOnBehalfOf.sizeInBytes);
end;

{ TFhirProvenanceAgentListEnumerator }

Constructor TFhirProvenanceAgentListEnumerator.Create(list : TFhirProvenanceAgentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProvenanceAgentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProvenanceAgentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProvenanceAgentListEnumerator.GetCurrent : TFhirProvenanceAgent;
begin
  Result := FList[FIndex];
end;

function TFhirProvenanceAgentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProvenanceAgentList }
procedure TFhirProvenanceAgentList.AddItem(value: TFhirProvenanceAgent);
begin
  assert(value.ClassName = 'TFhirProvenanceAgent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenanceAgent');
  add(value);
end;

function TFhirProvenanceAgentList.Append: TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceAgentList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceAgentList.GetEnumerator : TFhirProvenanceAgentListEnumerator;
begin
  result := TFhirProvenanceAgentListEnumerator.Create(self.link);
end;

function TFhirProvenanceAgentList.Clone: TFhirProvenanceAgentList;
begin
  result := TFhirProvenanceAgentList(inherited Clone);
end;

function TFhirProvenanceAgentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceAgentList.GetItemN(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(ObjectByIndex[index]);
end;

function TFhirProvenanceAgentList.ItemClass: TFslObjectClass;
begin
  result := TFhirProvenanceAgent;
end;
function TFhirProvenanceAgentList.IndexOf(value: TFhirProvenanceAgent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProvenanceAgentList.Insert(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceAgentList.InsertItem(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  Inherited Insert(index, value);
end;

function TFhirProvenanceAgentList.Item(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(ObjectByIndex[index]);
end;

function TFhirProvenanceAgentList.Link: TFhirProvenanceAgentList;
begin
  result := TFhirProvenanceAgentList(inherited Link);
end;

procedure TFhirProvenanceAgentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceAgentList.SetItemByIndex(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  FhirProvenanceAgents[index] := value;
end;

procedure TFhirProvenanceAgentList.SetItemN(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  ObjectByIndex[index] := value;
end;

{ TFhirProvenanceEntity }

constructor TFhirProvenanceEntity.Create;
begin
  inherited;
end;

destructor TFhirProvenanceEntity.Destroy;
begin
  FRole.free;
  FWhat.free;
  FAgentList.Free;
  inherited;
end;

procedure TFhirProvenanceEntity.Assign(oSource : TFslObject);
begin
  inherited;
  FRole := TFhirProvenanceEntity(oSource).FRole.Link;
  what := TFhirProvenanceEntity(oSource).what.Clone;
  if (TFhirProvenanceEntity(oSource).FAgentList = nil) then
  begin
    FAgentList.free;
    FAgentList := nil;
  end
  else
  begin
    if FAgentList = nil then
      FAgentList := TFhirProvenanceAgentList.Create;
    FAgentList.Assign(TFhirProvenanceEntity(oSource).FAgentList);
  end;
end;

procedure TFhirProvenanceEntity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'what') Then
     list.add(self.link, 'what', FWhat.Link);
  if (child_name = 'agent') Then
    list.addAll(self, 'agent', FAgentList);
end;

procedure TFhirProvenanceEntity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'code', false, TFHIREnum, FRole.Link));{1}
  oList.add(TFHIRProperty.create(self, 'what', 'Reference(Any)', false, TFhirReference{TFhirReference}, FWhat.Link));{2}
  oList.add(TFHIRProperty.create(self, 'agent', '@Provenance.agent', true, TFhirProvenanceAgent, FAgentList.Link)){3};
end;

function TFhirProvenanceEntity.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    RoleElement := asEnum(SYSTEMS_TFhirProvenanceEntityRoleEnum, CODES_TFhirProvenanceEntityRoleEnum, propValue);
    result := propValue
  end
  else if (propName = 'what') then
  begin
    What := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'agent') then
  begin
    AgentList.add(propValue as TFhirProvenanceAgent){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProvenanceEntity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'agent') then AgentList.insertItem(index, propValue as TFhirProvenanceAgent){2a}
  else inherited;
end;

function TFhirProvenanceEntity.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'what') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'agent') then result := AgentList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProvenanceEntity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'code'
  else if (propName = 'what') then result := 'Reference'
  else if (propName = 'agent') then result := '@Provenance.agent'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProvenanceEntity.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'what') then WhatElement := nil
  else if (propName = 'agent') then deletePropertyValue('agent', AgentList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProvenanceEntity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := asEnum(SYSTEMS_TFhirProvenanceEntityRoleEnum, CODES_TFhirProvenanceEntityRoleEnum, new){4}
  else if (propName = 'what') then WhatElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'agent') then replacePropertyValue('agent', AgentList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProvenanceEntity.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'agent') then AgentList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProvenanceEntity.fhirType : string;
begin
  result := 'entity';
end;

function TFhirProvenanceEntity.Link : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(inherited Link);
end;

function TFhirProvenanceEntity.Clone : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(inherited Clone);
end;

function TFhirProvenanceEntity.equals(other : TObject) : boolean; 
var
  o : TFhirProvenanceEntity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProvenanceEntity)) then
    result := false
  else
  begin
    o := TFhirProvenanceEntity(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(whatElement, o.whatElement, true) and 
      compareDeep(agentList, o.agentList, true);
  end;
end;

function TFhirProvenanceEntity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FWhat) and isEmptyProp(FagentList);
end;

procedure TFhirProvenanceEntity.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('what');
  fields.add('agent');
end;

{ TFhirProvenanceEntity }

Procedure TFhirProvenanceEntity.SetRole(value : TFhirEnum);
begin
  FRole.free;
  FRole := value;
end;

Function TFhirProvenanceEntity.GetRoleST : TFhirProvenanceEntityRoleEnum;
begin
  if FRole = nil then
    result := TFhirProvenanceEntityRoleEnum(0)
  else
    result := TFhirProvenanceEntityRoleEnum(StringArrayIndexOfSensitive(CODES_TFhirProvenanceEntityRoleEnum, FRole.value));
end;

Procedure TFhirProvenanceEntity.SetRoleST(value : TFhirProvenanceEntityRoleEnum);
begin
  if ord(value) = 0 then
    RoleElement := nil
  else
    RoleElement := TFhirEnum.create(SYSTEMS_TFhirProvenanceEntityRoleEnum[value], CODES_TFhirProvenanceEntityRoleEnum[value]);
end;

Procedure TFhirProvenanceEntity.SetWhat(value : TFhirReference{TFhirReference});
begin
  FWhat.free;
  FWhat := value;
end;

Function TFhirProvenanceEntity.GetAgentList : TFhirProvenanceAgentList;
begin
  if FAgentList = nil then
    FAgentList := TFhirProvenanceAgentList.Create;
  result := FAgentList;
end;

Function TFhirProvenanceEntity.GetHasAgentList : boolean;
begin
  result := (FAgentList <> nil) and (FAgentList.count > 0);
end;

function TFhirProvenanceEntity.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRole.sizeInBytes);
  inc(result, FWhat.sizeInBytes);
  inc(result, FagentList.sizeInBytes);
end;

{ TFhirProvenanceEntityListEnumerator }

Constructor TFhirProvenanceEntityListEnumerator.Create(list : TFhirProvenanceEntityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProvenanceEntityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProvenanceEntityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProvenanceEntityListEnumerator.GetCurrent : TFhirProvenanceEntity;
begin
  Result := FList[FIndex];
end;

function TFhirProvenanceEntityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProvenanceEntityList }
procedure TFhirProvenanceEntityList.AddItem(value: TFhirProvenanceEntity);
begin
  assert(value.ClassName = 'TFhirProvenanceEntity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenanceEntity');
  add(value);
end;

function TFhirProvenanceEntityList.Append: TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceEntityList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceEntityList.GetEnumerator : TFhirProvenanceEntityListEnumerator;
begin
  result := TFhirProvenanceEntityListEnumerator.Create(self.link);
end;

function TFhirProvenanceEntityList.Clone: TFhirProvenanceEntityList;
begin
  result := TFhirProvenanceEntityList(inherited Clone);
end;

function TFhirProvenanceEntityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceEntityList.GetItemN(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(ObjectByIndex[index]);
end;

function TFhirProvenanceEntityList.ItemClass: TFslObjectClass;
begin
  result := TFhirProvenanceEntity;
end;
function TFhirProvenanceEntityList.IndexOf(value: TFhirProvenanceEntity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProvenanceEntityList.Insert(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceEntityList.InsertItem(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  Inherited Insert(index, value);
end;

function TFhirProvenanceEntityList.Item(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(ObjectByIndex[index]);
end;

function TFhirProvenanceEntityList.Link: TFhirProvenanceEntityList;
begin
  result := TFhirProvenanceEntityList(inherited Link);
end;

procedure TFhirProvenanceEntityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceEntityList.SetItemByIndex(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  FhirProvenanceEntities[index] := value;
end;

procedure TFhirProvenanceEntityList.SetItemN(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  ObjectByIndex[index] := value;
end;

{ TFhirProvenance }

constructor TFhirProvenance.Create;
begin
  inherited;
end;

destructor TFhirProvenance.Destroy;
begin
  FTargetList.Free;
  FOccurred.free;
  FRecorded.free;
  FPolicyList.Free;
  FLocation.free;
  FReasonList.Free;
  FActivity.free;
  FAgentList.Free;
  FEntityList.Free;
  FSignatureList.Free;
  inherited;
end;

function TFhirProvenance.GetResourceType : TFhirResourceType;
begin
  result := frtProvenance;
end;

procedure TFhirProvenance.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirProvenance(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirReferenceList{TFhirReference}.Create;
    FTargetList.Assign(TFhirProvenance(oSource).FTargetList);
  end;
  occurred := TFhirProvenance(oSource).occurred.Clone;
  recordedElement := TFhirProvenance(oSource).recordedElement.Clone;
  if (TFhirProvenance(oSource).FPolicyList = nil) then
  begin
    FPolicyList.free;
    FPolicyList := nil;
  end
  else
  begin
    if FPolicyList = nil then
      FPolicyList := TFhirUriList.Create;
    FPolicyList.Assign(TFhirProvenance(oSource).FPolicyList);
  end;
  location := TFhirProvenance(oSource).location.Clone;
  if (TFhirProvenance(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirProvenance(oSource).FReasonList);
  end;
  activity := TFhirProvenance(oSource).activity.Clone;
  if (TFhirProvenance(oSource).FAgentList = nil) then
  begin
    FAgentList.free;
    FAgentList := nil;
  end
  else
  begin
    if FAgentList = nil then
      FAgentList := TFhirProvenanceAgentList.Create;
    FAgentList.Assign(TFhirProvenance(oSource).FAgentList);
  end;
  if (TFhirProvenance(oSource).FEntityList = nil) then
  begin
    FEntityList.free;
    FEntityList := nil;
  end
  else
  begin
    if FEntityList = nil then
      FEntityList := TFhirProvenanceEntityList.Create;
    FEntityList.Assign(TFhirProvenance(oSource).FEntityList);
  end;
  if (TFhirProvenance(oSource).FSignatureList = nil) then
  begin
    FSignatureList.free;
    FSignatureList := nil;
  end
  else
  begin
    if FSignatureList = nil then
      FSignatureList := TFhirSignatureList.Create;
    FSignatureList.Assign(TFhirProvenance(oSource).FSignatureList);
  end;
end;

procedure TFhirProvenance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
  if (child_name = 'occurred[x]') or (child_name = 'occurred') Then
     list.add(self.link, 'occurred[x]', FOccurred.Link);
  if (child_name = 'recorded') Then
     list.add(self.link, 'recorded', FRecorded.Link);
  if (child_name = 'policy') Then
    list.addAll(self, 'policy', FPolicyList);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'activity') Then
     list.add(self.link, 'activity', FActivity.Link);
  if (child_name = 'agent') Then
    list.addAll(self, 'agent', FAgentList);
  if (child_name = 'entity') Then
    list.addAll(self, 'entity', FEntityList);
  if (child_name = 'signature') Then
    list.addAll(self, 'signature', FSignatureList);
end;

procedure TFhirProvenance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'target', 'Reference(Any)', true, TFhirReference{TFhirReference}, FTargetList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'occurred[x]', 'Period|dateTime', false, TFhirType, FOccurred.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recorded', 'instant', false, TFhirInstant, FRecorded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'policy', 'uri', true, TFhirUri, FPolicyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'location', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'activity', 'CodeableConcept', false, TFhirCodeableConcept, FActivity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'agent', '', true, TFhirProvenanceAgent, FAgentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'entity', '', true, TFhirProvenanceEntity, FEntityList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'signature', 'Signature', true, TFhirSignature, FSignatureList.Link)){3};
end;

function TFhirProvenance.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurred', ['Period', 'DateTime'])) then
  begin
    Occurred := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'recorded') then
  begin
    RecordedElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'policy') then
  begin
    PolicyList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'activity') then
  begin
    Activity := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'agent') then
  begin
    AgentList.add(propValue as TFhirProvenanceAgent){2a};
    result := propValue;
  end
  else if (propName = 'entity') then
  begin
    EntityList.add(propValue as TFhirProvenanceEntity){2a};
    result := propValue;
  end
  else if (propName = 'signature') then
  begin
    SignatureList.add(propValue as TFhirSignature){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirProvenance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'policy') then PolicyList.insertItem(index, asUri(propValue)){2}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'agent') then AgentList.insertItem(index, propValue as TFhirProvenanceAgent){2a}
  else if (propName = 'entity') then EntityList.insertItem(index, propValue as TFhirProvenanceEntity){2a}
  else if (propName = 'signature') then SignatureList.insertItem(index, propValue as TFhirSignature){2a}
  else inherited;
end;

function TFhirProvenance.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'target') then result := TargetList.new(){2}
  else if (isMatchingName(propName, 'occurred', ['Period', 'DateTime'])) then raise EFHIRException.create('Cannot make property Occurred'){4x}
  else if (propName = 'recorded') then result := TFhirInstant.create() {5b}
  else if (propName = 'policy') then result := PolicyList.new(){2}
  else if (propName = 'location') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'reason') then result := ReasonList.new(){2}
  else if (propName = 'activity') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'agent') then result := AgentList.new(){2}
  else if (propName = 'entity') then result := EntityList.new(){2}
  else if (propName = 'signature') then result := SignatureList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProvenance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'target') then result := 'Reference'
  else if (propName = 'occurred[x]') then result := 'Period|dateTime'
  else if (propName = 'recorded') then result := 'instant'
  else if (propName = 'policy') then result := 'uri'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'activity') then result := 'CodeableConcept'
  else if (propName = 'agent') then result := ''
  else if (propName = 'entity') then result := ''
  else if (propName = 'signature') then result := 'Signature'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProvenance.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'target') then deletePropertyValue('target', TargetList, value) {2}
  else if (isMatchingName(propName, 'occurred', ['Period', 'DateTime'])) then OccurredElement := nil{4x}
  else if (propName = 'recorded') then RecordedElement := nil
  else if (propName = 'policy') then deletePropertyValue('policy', PolicyList, value) {2}
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {2}
  else if (propName = 'activity') then ActivityElement := nil
  else if (propName = 'agent') then deletePropertyValue('agent', AgentList, value) {2}
  else if (propName = 'entity') then deletePropertyValue('entity', EntityList, value) {2}
  else if (propName = 'signature') then deletePropertyValue('signature', SignatureList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProvenance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new) {2}
  else if (isMatchingName(propName, 'occurred', ['Period', 'DateTime'])) then OccurredElement := new as TFhirType{4x}
  else if (propName = 'recorded') then RecordedElement := asInstant(new){5b}
  else if (propName = 'policy') then replacePropertyValue('policy', PolicyList, existing, new) {2}
  else if (propName = 'location') then LocationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {2}
  else if (propName = 'activity') then ActivityElement := new as TFhirCodeableConcept{4}
  else if (propName = 'agent') then replacePropertyValue('agent', AgentList, existing, new) {2}
  else if (propName = 'entity') then replacePropertyValue('entity', EntityList, existing, new) {2}
  else if (propName = 'signature') then replacePropertyValue('signature', SignatureList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProvenance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'target') then TargetList.move(source, destination){2a}
  else if (propName = 'policy') then PolicyList.move(source, destination){2}
  else if (propName = 'reason') then ReasonList.move(source, destination){2a}
  else if (propName = 'agent') then AgentList.move(source, destination){2a}
  else if (propName = 'entity') then EntityList.move(source, destination){2a}
  else if (propName = 'signature') then SignatureList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProvenance.fhirType : string;
begin
  result := 'Provenance';
end;

function TFhirProvenance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FtargetList) and isEmptyProp(FOccurred) and isEmptyProp(FRecorded) and isEmptyProp(FpolicyList) and isEmptyProp(FLocation) and isEmptyProp(FreasonList) and isEmptyProp(FActivity) and isEmptyProp(FagentList) and isEmptyProp(FentityList) and isEmptyProp(FsignatureList);
end;

function TFhirProvenance.equals(other : TObject) : boolean; 
var
  o : TFhirProvenance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProvenance)) then
    result := false
  else
  begin
    o := TFhirProvenance(other);
    result := compareDeep(targetList, o.targetList, true) and compareDeep(occurredElement, o.occurredElement, true) and 
      compareDeep(recordedElement, o.recordedElement, true) and compareDeep(policyList, o.policyList, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(reasonList, o.reasonList, true) and 
      compareDeep(activityElement, o.activityElement, true) and compareDeep(agentList, o.agentList, true) and 
      compareDeep(entityList, o.entityList, true) and compareDeep(signatureList, o.signatureList, true);
  end;
end;

function TFhirProvenance.Link : TFhirProvenance;
begin
  result := TFhirProvenance(inherited Link);
end;

function TFhirProvenance.Clone : TFhirProvenance;
begin
  result := TFhirProvenance(inherited Clone);
end;

procedure TFhirProvenance.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('target');
  fields.add('occurred[x]');
  fields.add('recorded');
  fields.add('policy');
  fields.add('location');
  fields.add('reason');
  fields.add('activity');
  fields.add('agent');
  fields.add('entity');
  fields.add('signature');
end;

{ TFhirProvenance }

Function TFhirProvenance.GetTargetList : TFhirReferenceList{TFhirReference};
begin
  if FTargetList = nil then
    FTargetList := TFhirReferenceList{TFhirReference}.Create;
  result := FTargetList;
end;

Function TFhirProvenance.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

Procedure TFhirProvenance.SetOccurred(value : TFhirType);
begin
  FOccurred.free;
  FOccurred := value;
end;

Procedure TFhirProvenance.SetRecorded(value : TFhirInstant);
begin
  FRecorded.free;
  FRecorded := value;
end;

Function TFhirProvenance.GetRecordedST : TFslDateTime;
begin
  if FRecorded = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecorded.value;
end;

Procedure TFhirProvenance.SetRecordedST(value : TFslDateTime);
begin
  if FRecorded = nil then
    FRecorded := TFhirInstant.create;
  FRecorded.value := value
end;

Function TFhirProvenance.GetPolicyList : TFhirUriList;
begin
  if FPolicyList = nil then
    FPolicyList := TFhirUriList.Create;
  result := FPolicyList;
end;

Function TFhirProvenance.GetHasPolicyList : boolean;
begin
  result := (FPolicyList <> nil) and (FPolicyList.count > 0);
end;

Procedure TFhirProvenance.SetLocation(value : TFhirReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Function TFhirProvenance.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

Function TFhirProvenance.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

Procedure TFhirProvenance.SetActivity(value : TFhirCodeableConcept);
begin
  FActivity.free;
  FActivity := value;
end;

Function TFhirProvenance.GetAgentList : TFhirProvenanceAgentList;
begin
  if FAgentList = nil then
    FAgentList := TFhirProvenanceAgentList.Create;
  result := FAgentList;
end;

Function TFhirProvenance.GetHasAgentList : boolean;
begin
  result := (FAgentList <> nil) and (FAgentList.count > 0);
end;

Function TFhirProvenance.GetEntityList : TFhirProvenanceEntityList;
begin
  if FEntityList = nil then
    FEntityList := TFhirProvenanceEntityList.Create;
  result := FEntityList;
end;

Function TFhirProvenance.GetHasEntityList : boolean;
begin
  result := (FEntityList <> nil) and (FEntityList.count > 0);
end;

Function TFhirProvenance.GetSignatureList : TFhirSignatureList;
begin
  if FSignatureList = nil then
    FSignatureList := TFhirSignatureList.Create;
  result := FSignatureList;
end;

Function TFhirProvenance.GetHasSignatureList : boolean;
begin
  result := (FSignatureList <> nil) and (FSignatureList.count > 0);
end;

function TFhirProvenance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FtargetList.sizeInBytes);
  inc(result, FOccurred.sizeInBytes);
  inc(result, FRecorded.sizeInBytes);
  inc(result, FpolicyList.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FActivity.sizeInBytes);
  inc(result, FagentList.sizeInBytes);
  inc(result, FentityList.sizeInBytes);
  inc(result, FsignatureList.sizeInBytes);
end;

{ TFhirProvenanceListEnumerator }

Constructor TFhirProvenanceListEnumerator.Create(list : TFhirProvenanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProvenanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProvenanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProvenanceListEnumerator.GetCurrent : TFhirProvenance;
begin
  Result := FList[FIndex];
end;

function TFhirProvenanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProvenanceList }
procedure TFhirProvenanceList.AddItem(value: TFhirProvenance);
begin
  assert(value.ClassName = 'TFhirProvenance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenance');
  add(value);
end;

function TFhirProvenanceList.Append: TFhirProvenance;
begin
  result := TFhirProvenance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceList.GetEnumerator : TFhirProvenanceListEnumerator;
begin
  result := TFhirProvenanceListEnumerator.Create(self.link);
end;

function TFhirProvenanceList.Clone: TFhirProvenanceList;
begin
  result := TFhirProvenanceList(inherited Clone);
end;

function TFhirProvenanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceList.GetItemN(index: Integer): TFhirProvenance;
begin
  result := TFhirProvenance(ObjectByIndex[index]);
end;

function TFhirProvenanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirProvenance;
end;
function TFhirProvenanceList.IndexOf(value: TFhirProvenance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProvenanceList.Insert(index: Integer): TFhirProvenance;
begin
  result := TFhirProvenance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceList.InsertItem(index: Integer; value: TFhirProvenance);
begin
  assert(value is TFhirProvenance);
  Inherited Insert(index, value);
end;

function TFhirProvenanceList.Item(index: Integer): TFhirProvenance;
begin
  result := TFhirProvenance(ObjectByIndex[index]);
end;

function TFhirProvenanceList.Link: TFhirProvenanceList;
begin
  result := TFhirProvenanceList(inherited Link);
end;

procedure TFhirProvenanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceList.SetItemByIndex(index: Integer; value: TFhirProvenance);
begin
  assert(value is TFhirProvenance);
  FhirProvenances[index] := value;
end;

procedure TFhirProvenanceList.SetItemN(index: Integer; value: TFhirProvenance);
begin
  assert(value is TFhirProvenance);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PROVENANCE}

{$IFDEF FHIR_REQUESTGROUP}

{ TFhirRequestGroupAction }

constructor TFhirRequestGroupAction.Create;
begin
  inherited;
end;

destructor TFhirRequestGroupAction.Destroy;
begin
  FPrefix.free;
  FTitle.free;
  FDescription.free;
  FTextEquivalent.free;
  FPriority.free;
  FCodeList.Free;
  FDocumentationList.Free;
  FConditionList.Free;
  FRelatedActionList.Free;
  FTiming.free;
  FParticipantList.Free;
  FType_.free;
  FGroupingBehavior.free;
  FSelectionBehavior.free;
  FRequiredBehavior.free;
  FPrecheckBehavior.free;
  FCardinalityBehavior.free;
  FResource.free;
  FActionList.Free;
  inherited;
end;

procedure TFhirRequestGroupAction.Assign(oSource : TFslObject);
begin
  inherited;
  prefixElement := TFhirRequestGroupAction(oSource).prefixElement.Clone;
  titleElement := TFhirRequestGroupAction(oSource).titleElement.Clone;
  descriptionElement := TFhirRequestGroupAction(oSource).descriptionElement.Clone;
  textEquivalentElement := TFhirRequestGroupAction(oSource).textEquivalentElement.Clone;
  FPriority := TFhirRequestGroupAction(oSource).FPriority.Link;
  if (TFhirRequestGroupAction(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirRequestGroupAction(oSource).FCodeList);
  end;
  if (TFhirRequestGroupAction(oSource).FDocumentationList = nil) then
  begin
    FDocumentationList.free;
    FDocumentationList := nil;
  end
  else
  begin
    if FDocumentationList = nil then
      FDocumentationList := TFhirRelatedArtifactList.Create;
    FDocumentationList.Assign(TFhirRequestGroupAction(oSource).FDocumentationList);
  end;
  if (TFhirRequestGroupAction(oSource).FConditionList = nil) then
  begin
    FConditionList.free;
    FConditionList := nil;
  end
  else
  begin
    if FConditionList = nil then
      FConditionList := TFhirRequestGroupActionConditionList.Create;
    FConditionList.Assign(TFhirRequestGroupAction(oSource).FConditionList);
  end;
  if (TFhirRequestGroupAction(oSource).FRelatedActionList = nil) then
  begin
    FRelatedActionList.free;
    FRelatedActionList := nil;
  end
  else
  begin
    if FRelatedActionList = nil then
      FRelatedActionList := TFhirRequestGroupActionRelatedActionList.Create;
    FRelatedActionList.Assign(TFhirRequestGroupAction(oSource).FRelatedActionList);
  end;
  timing := TFhirRequestGroupAction(oSource).timing.Clone;
  if (TFhirRequestGroupAction(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirReferenceList{TFhirPatient}.Create;
    FParticipantList.Assign(TFhirRequestGroupAction(oSource).FParticipantList);
  end;
  type_ := TFhirRequestGroupAction(oSource).type_.Clone;
  FGroupingBehavior := TFhirRequestGroupAction(oSource).FGroupingBehavior.Link;
  FSelectionBehavior := TFhirRequestGroupAction(oSource).FSelectionBehavior.Link;
  FRequiredBehavior := TFhirRequestGroupAction(oSource).FRequiredBehavior.Link;
  FPrecheckBehavior := TFhirRequestGroupAction(oSource).FPrecheckBehavior.Link;
  FCardinalityBehavior := TFhirRequestGroupAction(oSource).FCardinalityBehavior.Link;
  resource := TFhirRequestGroupAction(oSource).resource.Clone;
  if (TFhirRequestGroupAction(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirRequestGroupActionList.Create;
    FActionList.Assign(TFhirRequestGroupAction(oSource).FActionList);
  end;
end;

procedure TFhirRequestGroupAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'prefix') Then
     list.add(self.link, 'prefix', FPrefix.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'textEquivalent') Then
     list.add(self.link, 'textEquivalent', FTextEquivalent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'documentation') Then
    list.addAll(self, 'documentation', FDocumentationList);
  if (child_name = 'condition') Then
    list.addAll(self, 'condition', FConditionList);
  if (child_name = 'relatedAction') Then
    list.addAll(self, 'relatedAction', FRelatedActionList);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'groupingBehavior') Then
     list.add(self.link, 'groupingBehavior', FGroupingBehavior.Link);
  if (child_name = 'selectionBehavior') Then
     list.add(self.link, 'selectionBehavior', FSelectionBehavior.Link);
  if (child_name = 'requiredBehavior') Then
     list.add(self.link, 'requiredBehavior', FRequiredBehavior.Link);
  if (child_name = 'precheckBehavior') Then
     list.add(self.link, 'precheckBehavior', FPrecheckBehavior.Link);
  if (child_name = 'cardinalityBehavior') Then
     list.add(self.link, 'cardinalityBehavior', FCardinalityBehavior.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirRequestGroupAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'prefix', 'string', false, TFhirString, FPrefix.Link));{2}
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'textEquivalent', 'string', false, TFhirString, FTextEquivalent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFHIREnum, FPriority.Link));{1}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'documentation', 'RelatedArtifact', true, TFhirRelatedArtifact, FDocumentationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'condition', '', true, TFhirRequestGroupActionCondition, FConditionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relatedAction', '', true, TFhirRequestGroupActionRelatedAction, FRelatedActionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'dateTime|Age|Period|Duration|Range|Timing', false, TFhirType, FTiming.Link));{2}
  oList.add(TFHIRProperty.create(self, 'participant', 'Reference(Patient)', true, TFhirReference{TFhirPatient}, FParticipantList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'groupingBehavior', 'code', false, TFHIREnum, FGroupingBehavior.Link));{1}
  oList.add(TFHIRProperty.create(self, 'selectionBehavior', 'code', false, TFHIREnum, FSelectionBehavior.Link));{1}
  oList.add(TFHIRProperty.create(self, 'requiredBehavior', 'code', false, TFHIREnum, FRequiredBehavior.Link));{1}
  oList.add(TFHIRProperty.create(self, 'precheckBehavior', 'code', false, TFHIREnum, FPrecheckBehavior.Link));{1}
  oList.add(TFHIRProperty.create(self, 'cardinalityBehavior', 'code', false, TFHIREnum, FCardinalityBehavior.Link));{1}
  oList.add(TFHIRProperty.create(self, 'resource', 'Reference(Any)', false, TFhirReference{TFhirReference}, FResource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'action', '@RequestGroup.action', true, TFhirRequestGroupAction, FActionList.Link)){3};
end;

function TFhirRequestGroupAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'prefix') then
  begin
    PrefixElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'textEquivalent') then
  begin
    TextEquivalentElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationList.add(propValue as TFhirRelatedArtifact){2a};
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionList.add(propValue as TFhirRequestGroupActionCondition){2a};
    result := propValue;
  end
  else if (propName = 'relatedAction') then
  begin
    RelatedActionList.add(propValue as TFhirRequestGroupActionRelatedAction){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Age', 'Period', 'Duration', 'Range', 'Timing'])) then
  begin
    Timing := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirReference{TFhirPatient}){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'groupingBehavior') then
  begin
    GroupingBehaviorElement := asEnum(SYSTEMS_TFhirActionGroupingBehaviorEnum, CODES_TFhirActionGroupingBehaviorEnum, propValue);
    result := propValue
  end
  else if (propName = 'selectionBehavior') then
  begin
    SelectionBehaviorElement := asEnum(SYSTEMS_TFhirActionSelectionBehaviorEnum, CODES_TFhirActionSelectionBehaviorEnum, propValue);
    result := propValue
  end
  else if (propName = 'requiredBehavior') then
  begin
    RequiredBehaviorElement := asEnum(SYSTEMS_TFhirActionRequiredBehaviorEnum, CODES_TFhirActionRequiredBehaviorEnum, propValue);
    result := propValue
  end
  else if (propName = 'precheckBehavior') then
  begin
    PrecheckBehaviorElement := asEnum(SYSTEMS_TFhirActionPrecheckBehaviorEnum, CODES_TFhirActionPrecheckBehaviorEnum, propValue);
    result := propValue
  end
  else if (propName = 'cardinalityBehavior') then
  begin
    CardinalityBehaviorElement := asEnum(SYSTEMS_TFhirActionCardinalityBehaviorEnum, CODES_TFhirActionCardinalityBehaviorEnum, propValue);
    result := propValue
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirRequestGroupAction){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestGroupAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'documentation') then DocumentationList.insertItem(index, propValue as TFhirRelatedArtifact){2a}
  else if (propName = 'condition') then ConditionList.insertItem(index, propValue as TFhirRequestGroupActionCondition){2a}
  else if (propName = 'relatedAction') then RelatedActionList.insertItem(index, propValue as TFhirRequestGroupActionRelatedAction){2a}
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirReference{TFhirPatient}){2a}
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirRequestGroupAction){2a}
  else inherited;
end;

function TFhirRequestGroupAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'prefix') then result := TFhirString.create() {5b}
  else if (propName = 'title') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'textEquivalent') then result := TFhirString.create() {5b}
  else if (propName = 'code') then result := CodeList.new(){2}
  else if (propName = 'documentation') then result := DocumentationList.new(){2}
  else if (propName = 'condition') then result := ConditionList.new(){2}
  else if (propName = 'relatedAction') then result := RelatedActionList.new(){2}
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Age', 'Period', 'Duration', 'Range', 'Timing'])) then raise EFHIRException.create('Cannot make property Timing'){4x}
  else if (propName = 'participant') then result := ParticipantList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'resource') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'action') then result := ActionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestGroupAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'prefix') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'textEquivalent') then result := 'string'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'documentation') then result := 'RelatedArtifact'
  else if (propName = 'condition') then result := ''
  else if (propName = 'relatedAction') then result := ''
  else if (propName = 'timing[x]') then result := 'dateTime|Age|Period|Duration|Range|Timing'
  else if (propName = 'participant') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'groupingBehavior') then result := 'code'
  else if (propName = 'selectionBehavior') then result := 'code'
  else if (propName = 'requiredBehavior') then result := 'code'
  else if (propName = 'precheckBehavior') then result := 'code'
  else if (propName = 'cardinalityBehavior') then result := 'code'
  else if (propName = 'resource') then result := 'Reference'
  else if (propName = 'action') then result := '@RequestGroup.action'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestGroupAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'prefix') then PrefixElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'textEquivalent') then TextEquivalentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value) {2}
  else if (propName = 'documentation') then deletePropertyValue('documentation', DocumentationList, value) {2}
  else if (propName = 'condition') then deletePropertyValue('condition', ConditionList, value) {2}
  else if (propName = 'relatedAction') then deletePropertyValue('relatedAction', RelatedActionList, value) {2}
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Age', 'Period', 'Duration', 'Range', 'Timing'])) then TimingElement := nil{4x}
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'groupingBehavior') then GroupingBehaviorElement := nil
  else if (propName = 'selectionBehavior') then SelectionBehaviorElement := nil
  else if (propName = 'requiredBehavior') then RequiredBehaviorElement := nil
  else if (propName = 'precheckBehavior') then PrecheckBehaviorElement := nil
  else if (propName = 'cardinalityBehavior') then CardinalityBehaviorElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestGroupAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'prefix') then PrefixElement := asString(new){5b}
  else if (propName = 'title') then TitleElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'textEquivalent') then TextEquivalentElement := asString(new){5b}
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new){4}
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {2}
  else if (propName = 'documentation') then replacePropertyValue('documentation', DocumentationList, existing, new) {2}
  else if (propName = 'condition') then replacePropertyValue('condition', ConditionList, existing, new) {2}
  else if (propName = 'relatedAction') then replacePropertyValue('relatedAction', RelatedActionList, existing, new) {2}
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Age', 'Period', 'Duration', 'Range', 'Timing'])) then TimingElement := new as TFhirType{4x}
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new) {2}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'groupingBehavior') then GroupingBehaviorElement := asEnum(SYSTEMS_TFhirActionGroupingBehaviorEnum, CODES_TFhirActionGroupingBehaviorEnum, new){4}
  else if (propName = 'selectionBehavior') then SelectionBehaviorElement := asEnum(SYSTEMS_TFhirActionSelectionBehaviorEnum, CODES_TFhirActionSelectionBehaviorEnum, new){4}
  else if (propName = 'requiredBehavior') then RequiredBehaviorElement := asEnum(SYSTEMS_TFhirActionRequiredBehaviorEnum, CODES_TFhirActionRequiredBehaviorEnum, new){4}
  else if (propName = 'precheckBehavior') then PrecheckBehaviorElement := asEnum(SYSTEMS_TFhirActionPrecheckBehaviorEnum, CODES_TFhirActionPrecheckBehaviorEnum, new){4}
  else if (propName = 'cardinalityBehavior') then CardinalityBehaviorElement := asEnum(SYSTEMS_TFhirActionCardinalityBehaviorEnum, CODES_TFhirActionCardinalityBehaviorEnum, new){4}
  else if (propName = 'resource') then ResourceElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestGroupAction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination){2a}
  else if (propName = 'documentation') then DocumentationList.move(source, destination){2a}
  else if (propName = 'condition') then ConditionList.move(source, destination){2a}
  else if (propName = 'relatedAction') then RelatedActionList.move(source, destination){2a}
  else if (propName = 'participant') then ParticipantList.move(source, destination){2a}
  else if (propName = 'action') then ActionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestGroupAction.fhirType : string;
begin
  result := 'action';
end;

function TFhirRequestGroupAction.Link : TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction(inherited Link);
end;

function TFhirRequestGroupAction.Clone : TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction(inherited Clone);
end;

function TFhirRequestGroupAction.equals(other : TObject) : boolean; 
var
  o : TFhirRequestGroupAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestGroupAction)) then
    result := false
  else
  begin
    o := TFhirRequestGroupAction(other);
    result := compareDeep(prefixElement, o.prefixElement, true) and compareDeep(titleElement, o.titleElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(textEquivalentElement, o.textEquivalentElement, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(documentationList, o.documentationList, true) and compareDeep(conditionList, o.conditionList, true) and 
      compareDeep(relatedActionList, o.relatedActionList, true) and compareDeep(timingElement, o.timingElement, true) and 
      compareDeep(participantList, o.participantList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(groupingBehaviorElement, o.groupingBehaviorElement, true) and compareDeep(selectionBehaviorElement, o.selectionBehaviorElement, true) and 
      compareDeep(requiredBehaviorElement, o.requiredBehaviorElement, true) and compareDeep(precheckBehaviorElement, o.precheckBehaviorElement, true) and 
      compareDeep(cardinalityBehaviorElement, o.cardinalityBehaviorElement, true) and 
      compareDeep(resourceElement, o.resourceElement, true) and compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirRequestGroupAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPrefix) and isEmptyProp(FTitle) and isEmptyProp(FDescription) and isEmptyProp(FTextEquivalent) and isEmptyProp(FPriority) and isEmptyProp(FcodeList) and isEmptyProp(FdocumentationList) and isEmptyProp(FconditionList) and isEmptyProp(FrelatedActionList) and isEmptyProp(FTiming) and isEmptyProp(FparticipantList) and isEmptyProp(FType_) and isEmptyProp(FGroupingBehavior) and isEmptyProp(FSelectionBehavior) and isEmptyProp(FRequiredBehavior) and isEmptyProp(FPrecheckBehavior) and isEmptyProp(FCardinalityBehavior) and isEmptyProp(FResource) and isEmptyProp(FactionList);
end;

procedure TFhirRequestGroupAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('prefix');
  fields.add('title');
  fields.add('description');
  fields.add('textEquivalent');
  fields.add('priority');
  fields.add('code');
  fields.add('documentation');
  fields.add('condition');
  fields.add('relatedAction');
  fields.add('timing[x]');
  fields.add('participant');
  fields.add('type');
  fields.add('groupingBehavior');
  fields.add('selectionBehavior');
  fields.add('requiredBehavior');
  fields.add('precheckBehavior');
  fields.add('cardinalityBehavior');
  fields.add('resource');
  fields.add('action');
end;

{ TFhirRequestGroupAction }

Procedure TFhirRequestGroupAction.SetPrefix(value : TFhirString);
begin
  FPrefix.free;
  FPrefix := value;
end;

Function TFhirRequestGroupAction.GetPrefixST : String;
begin
  if FPrefix = nil then
    result := ''
  else
    result := FPrefix.value;
end;

Procedure TFhirRequestGroupAction.SetPrefixST(value : String);
begin
  if value <> '' then
  begin
    if FPrefix = nil then
      FPrefix := TFhirString.create;
    FPrefix.value := value
  end
  else if FPrefix <> nil then
    FPrefix.value := '';
end;

Procedure TFhirRequestGroupAction.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirRequestGroupAction.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirRequestGroupAction.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirRequestGroupAction.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirRequestGroupAction.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirRequestGroupAction.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirRequestGroupAction.SetTextEquivalent(value : TFhirString);
begin
  FTextEquivalent.free;
  FTextEquivalent := value;
end;

Function TFhirRequestGroupAction.GetTextEquivalentST : String;
begin
  if FTextEquivalent = nil then
    result := ''
  else
    result := FTextEquivalent.value;
end;

Procedure TFhirRequestGroupAction.SetTextEquivalentST(value : String);
begin
  if value <> '' then
  begin
    if FTextEquivalent = nil then
      FTextEquivalent := TFhirString.create;
    FTextEquivalent.value := value
  end
  else if FTextEquivalent <> nil then
    FTextEquivalent.value := '';
end;

Procedure TFhirRequestGroupAction.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

Function TFhirRequestGroupAction.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

Procedure TFhirRequestGroupAction.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

Function TFhirRequestGroupAction.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

Function TFhirRequestGroupAction.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

Function TFhirRequestGroupAction.GetDocumentationList : TFhirRelatedArtifactList;
begin
  if FDocumentationList = nil then
    FDocumentationList := TFhirRelatedArtifactList.Create;
  result := FDocumentationList;
end;

Function TFhirRequestGroupAction.GetHasDocumentationList : boolean;
begin
  result := (FDocumentationList <> nil) and (FDocumentationList.count > 0);
end;

Function TFhirRequestGroupAction.GetConditionList : TFhirRequestGroupActionConditionList;
begin
  if FConditionList = nil then
    FConditionList := TFhirRequestGroupActionConditionList.Create;
  result := FConditionList;
end;

Function TFhirRequestGroupAction.GetHasConditionList : boolean;
begin
  result := (FConditionList <> nil) and (FConditionList.count > 0);
end;

Function TFhirRequestGroupAction.GetRelatedActionList : TFhirRequestGroupActionRelatedActionList;
begin
  if FRelatedActionList = nil then
    FRelatedActionList := TFhirRequestGroupActionRelatedActionList.Create;
  result := FRelatedActionList;
end;

Function TFhirRequestGroupAction.GetHasRelatedActionList : boolean;
begin
  result := (FRelatedActionList <> nil) and (FRelatedActionList.count > 0);
end;

Procedure TFhirRequestGroupAction.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Function TFhirRequestGroupAction.GetParticipantList : TFhirReferenceList{TFhirPatient};
begin
  if FParticipantList = nil then
    FParticipantList := TFhirReferenceList{TFhirPatient}.Create;
  result := FParticipantList;
end;

Function TFhirRequestGroupAction.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

Procedure TFhirRequestGroupAction.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirRequestGroupAction.SetGroupingBehavior(value : TFhirEnum);
begin
  FGroupingBehavior.free;
  FGroupingBehavior := value;
end;

Function TFhirRequestGroupAction.GetGroupingBehaviorST : TFhirActionGroupingBehaviorEnum;
begin
  if FGroupingBehavior = nil then
    result := TFhirActionGroupingBehaviorEnum(0)
  else
    result := TFhirActionGroupingBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionGroupingBehaviorEnum, FGroupingBehavior.value));
end;

Procedure TFhirRequestGroupAction.SetGroupingBehaviorST(value : TFhirActionGroupingBehaviorEnum);
begin
  if ord(value) = 0 then
    GroupingBehaviorElement := nil
  else
    GroupingBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionGroupingBehaviorEnum[value], CODES_TFhirActionGroupingBehaviorEnum[value]);
end;

Procedure TFhirRequestGroupAction.SetSelectionBehavior(value : TFhirEnum);
begin
  FSelectionBehavior.free;
  FSelectionBehavior := value;
end;

Function TFhirRequestGroupAction.GetSelectionBehaviorST : TFhirActionSelectionBehaviorEnum;
begin
  if FSelectionBehavior = nil then
    result := TFhirActionSelectionBehaviorEnum(0)
  else
    result := TFhirActionSelectionBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionSelectionBehaviorEnum, FSelectionBehavior.value));
end;

Procedure TFhirRequestGroupAction.SetSelectionBehaviorST(value : TFhirActionSelectionBehaviorEnum);
begin
  if ord(value) = 0 then
    SelectionBehaviorElement := nil
  else
    SelectionBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionSelectionBehaviorEnum[value], CODES_TFhirActionSelectionBehaviorEnum[value]);
end;

Procedure TFhirRequestGroupAction.SetRequiredBehavior(value : TFhirEnum);
begin
  FRequiredBehavior.free;
  FRequiredBehavior := value;
end;

Function TFhirRequestGroupAction.GetRequiredBehaviorST : TFhirActionRequiredBehaviorEnum;
begin
  if FRequiredBehavior = nil then
    result := TFhirActionRequiredBehaviorEnum(0)
  else
    result := TFhirActionRequiredBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionRequiredBehaviorEnum, FRequiredBehavior.value));
end;

Procedure TFhirRequestGroupAction.SetRequiredBehaviorST(value : TFhirActionRequiredBehaviorEnum);
begin
  if ord(value) = 0 then
    RequiredBehaviorElement := nil
  else
    RequiredBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionRequiredBehaviorEnum[value], CODES_TFhirActionRequiredBehaviorEnum[value]);
end;

Procedure TFhirRequestGroupAction.SetPrecheckBehavior(value : TFhirEnum);
begin
  FPrecheckBehavior.free;
  FPrecheckBehavior := value;
end;

Function TFhirRequestGroupAction.GetPrecheckBehaviorST : TFhirActionPrecheckBehaviorEnum;
begin
  if FPrecheckBehavior = nil then
    result := TFhirActionPrecheckBehaviorEnum(0)
  else
    result := TFhirActionPrecheckBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionPrecheckBehaviorEnum, FPrecheckBehavior.value));
end;

Procedure TFhirRequestGroupAction.SetPrecheckBehaviorST(value : TFhirActionPrecheckBehaviorEnum);
begin
  if ord(value) = 0 then
    PrecheckBehaviorElement := nil
  else
    PrecheckBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionPrecheckBehaviorEnum[value], CODES_TFhirActionPrecheckBehaviorEnum[value]);
end;

Procedure TFhirRequestGroupAction.SetCardinalityBehavior(value : TFhirEnum);
begin
  FCardinalityBehavior.free;
  FCardinalityBehavior := value;
end;

Function TFhirRequestGroupAction.GetCardinalityBehaviorST : TFhirActionCardinalityBehaviorEnum;
begin
  if FCardinalityBehavior = nil then
    result := TFhirActionCardinalityBehaviorEnum(0)
  else
    result := TFhirActionCardinalityBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionCardinalityBehaviorEnum, FCardinalityBehavior.value));
end;

Procedure TFhirRequestGroupAction.SetCardinalityBehaviorST(value : TFhirActionCardinalityBehaviorEnum);
begin
  if ord(value) = 0 then
    CardinalityBehaviorElement := nil
  else
    CardinalityBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionCardinalityBehaviorEnum[value], CODES_TFhirActionCardinalityBehaviorEnum[value]);
end;

Procedure TFhirRequestGroupAction.SetResource(value : TFhirReference{TFhirReference});
begin
  FResource.free;
  FResource := value;
end;

Function TFhirRequestGroupAction.GetActionList : TFhirRequestGroupActionList;
begin
  if FActionList = nil then
    FActionList := TFhirRequestGroupActionList.Create;
  result := FActionList;
end;

Function TFhirRequestGroupAction.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirRequestGroupAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPrefix.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FTextEquivalent.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FcodeList.sizeInBytes);
  inc(result, FdocumentationList.sizeInBytes);
  inc(result, FconditionList.sizeInBytes);
  inc(result, FrelatedActionList.sizeInBytes);
  inc(result, FTiming.sizeInBytes);
  inc(result, FparticipantList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FGroupingBehavior.sizeInBytes);
  inc(result, FSelectionBehavior.sizeInBytes);
  inc(result, FRequiredBehavior.sizeInBytes);
  inc(result, FPrecheckBehavior.sizeInBytes);
  inc(result, FCardinalityBehavior.sizeInBytes);
  inc(result, FResource.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
end;

{ TFhirRequestGroupActionListEnumerator }

Constructor TFhirRequestGroupActionListEnumerator.Create(list : TFhirRequestGroupActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestGroupActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestGroupActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestGroupActionListEnumerator.GetCurrent : TFhirRequestGroupAction;
begin
  Result := FList[FIndex];
end;

function TFhirRequestGroupActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRequestGroupActionList }
procedure TFhirRequestGroupActionList.AddItem(value: TFhirRequestGroupAction);
begin
  assert(value.ClassName = 'TFhirRequestGroupAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestGroupAction');
  add(value);
end;

function TFhirRequestGroupActionList.Append: TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionList.ClearItems;
begin
  Clear;
end;

function TFhirRequestGroupActionList.GetEnumerator : TFhirRequestGroupActionListEnumerator;
begin
  result := TFhirRequestGroupActionListEnumerator.Create(self.link);
end;

function TFhirRequestGroupActionList.Clone: TFhirRequestGroupActionList;
begin
  result := TFhirRequestGroupActionList(inherited Clone);
end;

function TFhirRequestGroupActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestGroupActionList.GetItemN(index: Integer): TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestGroupAction;
end;
function TFhirRequestGroupActionList.IndexOf(value: TFhirRequestGroupAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestGroupActionList.Insert(index: Integer): TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionList.InsertItem(index: Integer; value: TFhirRequestGroupAction);
begin
  assert(value is TFhirRequestGroupAction);
  Inherited Insert(index, value);
end;

function TFhirRequestGroupActionList.Item(index: Integer): TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionList.Link: TFhirRequestGroupActionList;
begin
  result := TFhirRequestGroupActionList(inherited Link);
end;

procedure TFhirRequestGroupActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestGroupActionList.SetItemByIndex(index: Integer; value: TFhirRequestGroupAction);
begin
  assert(value is TFhirRequestGroupAction);
  FhirRequestGroupActions[index] := value;
end;

procedure TFhirRequestGroupActionList.SetItemN(index: Integer; value: TFhirRequestGroupAction);
begin
  assert(value is TFhirRequestGroupAction);
  ObjectByIndex[index] := value;
end;

{ TFhirRequestGroupActionCondition }

constructor TFhirRequestGroupActionCondition.Create;
begin
  inherited;
end;

destructor TFhirRequestGroupActionCondition.Destroy;
begin
  FKind.free;
  FExpression.free;
  inherited;
end;

procedure TFhirRequestGroupActionCondition.Assign(oSource : TFslObject);
begin
  inherited;
  FKind := TFhirRequestGroupActionCondition(oSource).FKind.Link;
  expression := TFhirRequestGroupActionCondition(oSource).expression.Clone;
end;

procedure TFhirRequestGroupActionCondition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirRequestGroupActionCondition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFHIREnum, FKind.Link));{1}
  oList.add(TFHIRProperty.create(self, 'expression', 'Expression', false, TFhirExpression, FExpression.Link));{2}
end;

function TFhirRequestGroupActionCondition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirActionConditionKindEnum, CODES_TFhirActionConditionKindEnum, propValue);
    result := propValue
  end
  else if (propName = 'expression') then
  begin
    Expression := propValue as TFhirExpression{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestGroupActionCondition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRequestGroupActionCondition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'expression') then result := TFhirExpression.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestGroupActionCondition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'kind') then result := 'code'
  else if (propName = 'expression') then result := 'Expression'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestGroupActionCondition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestGroupActionCondition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirActionConditionKindEnum, CODES_TFhirActionConditionKindEnum, new){4}
  else if (propName = 'expression') then ExpressionElement := new as TFhirExpression{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestGroupActionCondition.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestGroupActionCondition.fhirType : string;
begin
  result := 'condition';
end;

function TFhirRequestGroupActionCondition.Link : TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition(inherited Link);
end;

function TFhirRequestGroupActionCondition.Clone : TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition(inherited Clone);
end;

function TFhirRequestGroupActionCondition.equals(other : TObject) : boolean; 
var
  o : TFhirRequestGroupActionCondition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestGroupActionCondition)) then
    result := false
  else
  begin
    o := TFhirRequestGroupActionCondition(other);
    result := compareDeep(kindElement, o.kindElement, true) and compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirRequestGroupActionCondition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FKind) and isEmptyProp(FExpression);
end;

procedure TFhirRequestGroupActionCondition.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('kind');
  fields.add('expression');
end;

{ TFhirRequestGroupActionCondition }

Procedure TFhirRequestGroupActionCondition.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

Function TFhirRequestGroupActionCondition.GetKindST : TFhirActionConditionKindEnum;
begin
  if FKind = nil then
    result := TFhirActionConditionKindEnum(0)
  else
    result := TFhirActionConditionKindEnum(StringArrayIndexOfSensitive(CODES_TFhirActionConditionKindEnum, FKind.value));
end;

Procedure TFhirRequestGroupActionCondition.SetKindST(value : TFhirActionConditionKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirActionConditionKindEnum[value], CODES_TFhirActionConditionKindEnum[value]);
end;

Procedure TFhirRequestGroupActionCondition.SetExpression(value : TFhirExpression);
begin
  FExpression.free;
  FExpression := value;
end;

function TFhirRequestGroupActionCondition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FKind.sizeInBytes);
  inc(result, FExpression.sizeInBytes);
end;

{ TFhirRequestGroupActionConditionListEnumerator }

Constructor TFhirRequestGroupActionConditionListEnumerator.Create(list : TFhirRequestGroupActionConditionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestGroupActionConditionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestGroupActionConditionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestGroupActionConditionListEnumerator.GetCurrent : TFhirRequestGroupActionCondition;
begin
  Result := FList[FIndex];
end;

function TFhirRequestGroupActionConditionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRequestGroupActionConditionList }
procedure TFhirRequestGroupActionConditionList.AddItem(value: TFhirRequestGroupActionCondition);
begin
  assert(value.ClassName = 'TFhirRequestGroupActionCondition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestGroupActionCondition');
  add(value);
end;

function TFhirRequestGroupActionConditionList.Append: TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionConditionList.ClearItems;
begin
  Clear;
end;

function TFhirRequestGroupActionConditionList.GetEnumerator : TFhirRequestGroupActionConditionListEnumerator;
begin
  result := TFhirRequestGroupActionConditionListEnumerator.Create(self.link);
end;

function TFhirRequestGroupActionConditionList.Clone: TFhirRequestGroupActionConditionList;
begin
  result := TFhirRequestGroupActionConditionList(inherited Clone);
end;

function TFhirRequestGroupActionConditionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestGroupActionConditionList.GetItemN(index: Integer): TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionConditionList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestGroupActionCondition;
end;
function TFhirRequestGroupActionConditionList.IndexOf(value: TFhirRequestGroupActionCondition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestGroupActionConditionList.Insert(index: Integer): TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionConditionList.InsertItem(index: Integer; value: TFhirRequestGroupActionCondition);
begin
  assert(value is TFhirRequestGroupActionCondition);
  Inherited Insert(index, value);
end;

function TFhirRequestGroupActionConditionList.Item(index: Integer): TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionConditionList.Link: TFhirRequestGroupActionConditionList;
begin
  result := TFhirRequestGroupActionConditionList(inherited Link);
end;

procedure TFhirRequestGroupActionConditionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestGroupActionConditionList.SetItemByIndex(index: Integer; value: TFhirRequestGroupActionCondition);
begin
  assert(value is TFhirRequestGroupActionCondition);
  FhirRequestGroupActionConditions[index] := value;
end;

procedure TFhirRequestGroupActionConditionList.SetItemN(index: Integer; value: TFhirRequestGroupActionCondition);
begin
  assert(value is TFhirRequestGroupActionCondition);
  ObjectByIndex[index] := value;
end;

{ TFhirRequestGroupActionRelatedAction }

constructor TFhirRequestGroupActionRelatedAction.Create;
begin
  inherited;
end;

destructor TFhirRequestGroupActionRelatedAction.Destroy;
begin
  FActionId.free;
  FRelationship.free;
  FOffset.free;
  inherited;
end;

procedure TFhirRequestGroupActionRelatedAction.Assign(oSource : TFslObject);
begin
  inherited;
  actionIdElement := TFhirRequestGroupActionRelatedAction(oSource).actionIdElement.Clone;
  FRelationship := TFhirRequestGroupActionRelatedAction(oSource).FRelationship.Link;
  offset := TFhirRequestGroupActionRelatedAction(oSource).offset.Clone;
end;

procedure TFhirRequestGroupActionRelatedAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'actionId') Then
     list.add(self.link, 'actionId', FActionId.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'offset[x]') or (child_name = 'offset') Then
     list.add(self.link, 'offset[x]', FOffset.Link);
end;

procedure TFhirRequestGroupActionRelatedAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'actionId', 'id', false, TFhirId, FActionId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relationship', 'code', false, TFHIREnum, FRelationship.Link));{1}
  oList.add(TFHIRProperty.create(self, 'offset[x]', 'Duration|Range', false, TFhirType, FOffset.Link));{2}
end;

function TFhirRequestGroupActionRelatedAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'actionId') then
  begin
    ActionIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    RelationshipElement := asEnum(SYSTEMS_TFhirActionRelationshipTypeEnum, CODES_TFhirActionRelationshipTypeEnum, propValue);
    result := propValue
  end
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then
  begin
    Offset := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestGroupActionRelatedAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRequestGroupActionRelatedAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'actionId') then result := TFhirId.create() {5b}
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then raise EFHIRException.create('Cannot make property Offset'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestGroupActionRelatedAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'actionId') then result := 'id'
  else if (propName = 'relationship') then result := 'code'
  else if (propName = 'offset[x]') then result := 'Duration|Range'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestGroupActionRelatedAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'actionId') then ActionIdElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then OffsetElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestGroupActionRelatedAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'actionId') then ActionIdElement := asId(new){5b}
  else if (propName = 'relationship') then RelationshipElement := asEnum(SYSTEMS_TFhirActionRelationshipTypeEnum, CODES_TFhirActionRelationshipTypeEnum, new){4}
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then OffsetElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestGroupActionRelatedAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestGroupActionRelatedAction.fhirType : string;
begin
  result := 'relatedAction';
end;

function TFhirRequestGroupActionRelatedAction.Link : TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction(inherited Link);
end;

function TFhirRequestGroupActionRelatedAction.Clone : TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction(inherited Clone);
end;

function TFhirRequestGroupActionRelatedAction.equals(other : TObject) : boolean; 
var
  o : TFhirRequestGroupActionRelatedAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestGroupActionRelatedAction)) then
    result := false
  else
  begin
    o := TFhirRequestGroupActionRelatedAction(other);
    result := compareDeep(actionIdElement, o.actionIdElement, true) and compareDeep(relationshipElement, o.relationshipElement, true) and 
      compareDeep(offsetElement, o.offsetElement, true);
  end;
end;

function TFhirRequestGroupActionRelatedAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FActionId) and isEmptyProp(FRelationship) and isEmptyProp(FOffset);
end;

procedure TFhirRequestGroupActionRelatedAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('actionId');
  fields.add('relationship');
  fields.add('offset[x]');
end;

{ TFhirRequestGroupActionRelatedAction }

Procedure TFhirRequestGroupActionRelatedAction.SetActionId(value : TFhirId);
begin
  FActionId.free;
  FActionId := value;
end;

Function TFhirRequestGroupActionRelatedAction.GetActionIdST : String;
begin
  if FActionId = nil then
    result := ''
  else
    result := FActionId.value;
end;

Procedure TFhirRequestGroupActionRelatedAction.SetActionIdST(value : String);
begin
  if value <> '' then
  begin
    if FActionId = nil then
      FActionId := TFhirId.create;
    FActionId.value := value
  end
  else if FActionId <> nil then
    FActionId.value := '';
end;

Procedure TFhirRequestGroupActionRelatedAction.SetRelationship(value : TFhirEnum);
begin
  FRelationship.free;
  FRelationship := value;
end;

Function TFhirRequestGroupActionRelatedAction.GetRelationshipST : TFhirActionRelationshipTypeEnum;
begin
  if FRelationship = nil then
    result := TFhirActionRelationshipTypeEnum(0)
  else
    result := TFhirActionRelationshipTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirActionRelationshipTypeEnum, FRelationship.value));
end;

Procedure TFhirRequestGroupActionRelatedAction.SetRelationshipST(value : TFhirActionRelationshipTypeEnum);
begin
  if ord(value) = 0 then
    RelationshipElement := nil
  else
    RelationshipElement := TFhirEnum.create(SYSTEMS_TFhirActionRelationshipTypeEnum[value], CODES_TFhirActionRelationshipTypeEnum[value]);
end;

Procedure TFhirRequestGroupActionRelatedAction.SetOffset(value : TFhirType);
begin
  FOffset.free;
  FOffset := value;
end;

function TFhirRequestGroupActionRelatedAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FActionId.sizeInBytes);
  inc(result, FRelationship.sizeInBytes);
  inc(result, FOffset.sizeInBytes);
end;

{ TFhirRequestGroupActionRelatedActionListEnumerator }

Constructor TFhirRequestGroupActionRelatedActionListEnumerator.Create(list : TFhirRequestGroupActionRelatedActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestGroupActionRelatedActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestGroupActionRelatedActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestGroupActionRelatedActionListEnumerator.GetCurrent : TFhirRequestGroupActionRelatedAction;
begin
  Result := FList[FIndex];
end;

function TFhirRequestGroupActionRelatedActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRequestGroupActionRelatedActionList }
procedure TFhirRequestGroupActionRelatedActionList.AddItem(value: TFhirRequestGroupActionRelatedAction);
begin
  assert(value.ClassName = 'TFhirRequestGroupActionRelatedAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestGroupActionRelatedAction');
  add(value);
end;

function TFhirRequestGroupActionRelatedActionList.Append: TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionRelatedActionList.ClearItems;
begin
  Clear;
end;

function TFhirRequestGroupActionRelatedActionList.GetEnumerator : TFhirRequestGroupActionRelatedActionListEnumerator;
begin
  result := TFhirRequestGroupActionRelatedActionListEnumerator.Create(self.link);
end;

function TFhirRequestGroupActionRelatedActionList.Clone: TFhirRequestGroupActionRelatedActionList;
begin
  result := TFhirRequestGroupActionRelatedActionList(inherited Clone);
end;

function TFhirRequestGroupActionRelatedActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestGroupActionRelatedActionList.GetItemN(index: Integer): TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionRelatedActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestGroupActionRelatedAction;
end;
function TFhirRequestGroupActionRelatedActionList.IndexOf(value: TFhirRequestGroupActionRelatedAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestGroupActionRelatedActionList.Insert(index: Integer): TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionRelatedActionList.InsertItem(index: Integer; value: TFhirRequestGroupActionRelatedAction);
begin
  assert(value is TFhirRequestGroupActionRelatedAction);
  Inherited Insert(index, value);
end;

function TFhirRequestGroupActionRelatedActionList.Item(index: Integer): TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionRelatedActionList.Link: TFhirRequestGroupActionRelatedActionList;
begin
  result := TFhirRequestGroupActionRelatedActionList(inherited Link);
end;

procedure TFhirRequestGroupActionRelatedActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestGroupActionRelatedActionList.SetItemByIndex(index: Integer; value: TFhirRequestGroupActionRelatedAction);
begin
  assert(value is TFhirRequestGroupActionRelatedAction);
  FhirRequestGroupActionRelatedActions[index] := value;
end;

procedure TFhirRequestGroupActionRelatedActionList.SetItemN(index: Integer; value: TFhirRequestGroupActionRelatedAction);
begin
  assert(value is TFhirRequestGroupActionRelatedAction);
  ObjectByIndex[index] := value;
end;

{ TFhirRequestGroup }

constructor TFhirRequestGroup.Create;
begin
  inherited;
end;

destructor TFhirRequestGroup.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FBasedOnList.Free;
  FReplacesList.Free;
  FGroupIdentifier.free;
  FStatus.free;
  FIntent.free;
  FPriority.free;
  FCode.free;
  FSubject.free;
  FEncounter.free;
  FAuthoredOn.free;
  FAuthor.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FNoteList.Free;
  FActionList.Free;
  inherited;
end;

function TFhirRequestGroup.GetResourceType : TFhirResourceType;
begin
  result := frtRequestGroup;
end;

procedure TFhirRequestGroup.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirRequestGroup(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirRequestGroup(oSource).FIdentifierList);
  end;
  if (TFhirRequestGroup(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirRequestGroup(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirRequestGroup(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirRequestGroup(oSource).FInstantiatesUriList);
  end;
  if (TFhirRequestGroup(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList{TFhirReference}.Create;
    FBasedOnList.Assign(TFhirRequestGroup(oSource).FBasedOnList);
  end;
  if (TFhirRequestGroup(oSource).FReplacesList = nil) then
  begin
    FReplacesList.free;
    FReplacesList := nil;
  end
  else
  begin
    if FReplacesList = nil then
      FReplacesList := TFhirReferenceList{TFhirReference}.Create;
    FReplacesList.Assign(TFhirRequestGroup(oSource).FReplacesList);
  end;
  groupIdentifier := TFhirRequestGroup(oSource).groupIdentifier.Clone;
  FStatus := TFhirRequestGroup(oSource).FStatus.Link;
  FIntent := TFhirRequestGroup(oSource).FIntent.Link;
  FPriority := TFhirRequestGroup(oSource).FPriority.Link;
  code := TFhirRequestGroup(oSource).code.Clone;
  subject := TFhirRequestGroup(oSource).subject.Clone;
  encounter := TFhirRequestGroup(oSource).encounter.Clone;
  authoredOnElement := TFhirRequestGroup(oSource).authoredOnElement.Clone;
  author := TFhirRequestGroup(oSource).author.Clone;
  if (TFhirRequestGroup(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirRequestGroup(oSource).FReasonCodeList);
  end;
  if (TFhirRequestGroup(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList{TFhirCondition}.Create;
    FReasonReferenceList.Assign(TFhirRequestGroup(oSource).FReasonReferenceList);
  end;
  if (TFhirRequestGroup(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirRequestGroup(oSource).FNoteList);
  end;
  if (TFhirRequestGroup(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirRequestGroupActionList.Create;
    FActionList.Assign(TFhirRequestGroup(oSource).FActionList);
  end;
end;

procedure TFhirRequestGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'replaces') Then
    list.addAll(self, 'replaces', FReplacesList);
  if (child_name = 'groupIdentifier') Then
     list.add(self.link, 'groupIdentifier', FGroupIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirRequestGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference(Any)', true, TFhirReference{TFhirReference}, FBasedOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'replaces', 'Reference(Any)', true, TFhirReference{TFhirReference}, FReplacesList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'groupIdentifier', 'Identifier', false, TFhirIdentifier, FGroupIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFHIREnum, FIntent.Link));{1}
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFHIREnum, FPriority.Link));{1}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Device)', false, TFhirReference{TFhirDevice}, FAuthor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference(Condition)', true, TFhirReference{TFhirCondition}, FReasonReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirRequestGroupAction, FActionList.Link)){3};
end;

function TFhirRequestGroup.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'replaces') then
  begin
    ReplacesList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'groupIdentifier') then
  begin
    GroupIdentifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, propValue);
    result := propValue
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{TFhirDevice}{4b};
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference{TFhirCondition}){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirRequestGroupAction){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirRequestGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue)){2}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue)){2}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'replaces') then ReplacesList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference{TFhirCondition}){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirRequestGroupAction){2a}
  else inherited;
end;

function TFhirRequestGroup.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new(){2}
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new(){2}
  else if (propName = 'basedOn') then result := BasedOnList.new(){2}
  else if (propName = 'replaces') then result := ReplacesList.new(){2}
  else if (propName = 'groupIdentifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'authoredOn') then result := TFhirDateTime.create() {5b}
  else if (propName = 'author') then result := TFhirReference{TFhirDevice}.create(){4b}
  else if (propName = 'reasonCode') then result := ReasonCodeList.new(){2}
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'action') then result := ActionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'replaces') then result := 'Reference'
  else if (propName = 'groupIdentifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'action') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestGroup.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value) {2}
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value) {2}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {2}
  else if (propName = 'replaces') then deletePropertyValue('replaces', ReplacesList, value) {2}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value) {2}
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new) {2}
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new) {2}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {2}
  else if (propName = 'replaces') then replacePropertyValue('replaces', ReplacesList, existing, new) {2}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, new){4}
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, new){4}
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new){4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new){5b}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{TFhirDevice}{4}
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new) {2}
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination){2}
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination){2}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination){2a}
  else if (propName = 'replaces') then ReplacesList.move(source, destination){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'action') then ActionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestGroup.fhirType : string;
begin
  result := 'RequestGroup';
end;

function TFhirRequestGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FbasedOnList) and isEmptyProp(FreplacesList) and isEmptyProp(FGroupIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FIntent) and isEmptyProp(FPriority) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FAuthoredOn) and isEmptyProp(FAuthor) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FnoteList) and isEmptyProp(FactionList);
end;

function TFhirRequestGroup.equals(other : TObject) : boolean; 
var
  o : TFhirRequestGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestGroup)) then
    result := false
  else
  begin
    o := TFhirRequestGroup(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(replacesList, o.replacesList, true) and compareDeep(groupIdentifierElement, o.groupIdentifierElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(intentElement, o.intentElement, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(authoredOnElement, o.authoredOnElement, true) and compareDeep(authorElement, o.authorElement, true) and 
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(reasonReferenceList, o.reasonReferenceList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirRequestGroup.Link : TFhirRequestGroup;
begin
  result := TFhirRequestGroup(inherited Link);
end;

function TFhirRequestGroup.Clone : TFhirRequestGroup;
begin
  result := TFhirRequestGroup(inherited Clone);
end;

procedure TFhirRequestGroup.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('replaces');
  fields.add('groupIdentifier');
  fields.add('status');
  fields.add('intent');
  fields.add('priority');
  fields.add('code');
  fields.add('subject');
  fields.add('encounter');
  fields.add('authoredOn');
  fields.add('author');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('note');
  fields.add('action');
end;

{ TFhirRequestGroup }

Function TFhirRequestGroup.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirRequestGroup.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirRequestGroup.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

Function TFhirRequestGroup.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

Function TFhirRequestGroup.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

Function TFhirRequestGroup.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

Function TFhirRequestGroup.GetBasedOnList : TFhirReferenceList{TFhirReference};
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList{TFhirReference}.Create;
  result := FBasedOnList;
end;

Function TFhirRequestGroup.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

Function TFhirRequestGroup.GetReplacesList : TFhirReferenceList{TFhirReference};
begin
  if FReplacesList = nil then
    FReplacesList := TFhirReferenceList{TFhirReference}.Create;
  result := FReplacesList;
end;

Function TFhirRequestGroup.GetHasReplacesList : boolean;
begin
  result := (FReplacesList <> nil) and (FReplacesList.count > 0);
end;

Procedure TFhirRequestGroup.SetGroupIdentifier(value : TFhirIdentifier);
begin
  FGroupIdentifier.free;
  FGroupIdentifier := value;
end;

Procedure TFhirRequestGroup.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirRequestGroup.GetStatusST : TFhirRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirRequestStatusEnum(0)
  else
    result := TFhirRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestStatusEnum, FStatus.value));
end;

Procedure TFhirRequestGroup.SetStatusST(value : TFhirRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[value], CODES_TFhirRequestStatusEnum[value]);
end;

Procedure TFhirRequestGroup.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

Function TFhirRequestGroup.GetIntentST : TFhirRequestIntentEnum;
begin
  if FIntent = nil then
    result := TFhirRequestIntentEnum(0)
  else
    result := TFhirRequestIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestIntentEnum, FIntent.value));
end;

Procedure TFhirRequestGroup.SetIntentST(value : TFhirRequestIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[value], CODES_TFhirRequestIntentEnum[value]);
end;

Procedure TFhirRequestGroup.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

Function TFhirRequestGroup.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

Procedure TFhirRequestGroup.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

Procedure TFhirRequestGroup.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirRequestGroup.SetSubject(value : TFhirReference{TFhirPatient});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirRequestGroup.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirRequestGroup.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value;
end;

Function TFhirRequestGroup.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

Procedure TFhirRequestGroup.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

Procedure TFhirRequestGroup.SetAuthor(value : TFhirReference{TFhirDevice});
begin
  FAuthor.free;
  FAuthor := value;
end;

Function TFhirRequestGroup.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

Function TFhirRequestGroup.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

Function TFhirRequestGroup.GetReasonReferenceList : TFhirReferenceList{TFhirCondition};
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList{TFhirCondition}.Create;
  result := FReasonReferenceList;
end;

Function TFhirRequestGroup.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

Function TFhirRequestGroup.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirRequestGroup.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirRequestGroup.GetActionList : TFhirRequestGroupActionList;
begin
  if FActionList = nil then
    FActionList := TFhirRequestGroupActionList.Create;
  result := FActionList;
end;

Function TFhirRequestGroup.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirRequestGroup.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FinstantiatesCanonicalList.sizeInBytes);
  inc(result, FinstantiatesUriList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FreplacesList.sizeInBytes);
  inc(result, FGroupIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FIntent.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FAuthoredOn.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
  inc(result, FreasonCodeList.sizeInBytes);
  inc(result, FreasonReferenceList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
end;

{ TFhirRequestGroupListEnumerator }

Constructor TFhirRequestGroupListEnumerator.Create(list : TFhirRequestGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestGroupListEnumerator.GetCurrent : TFhirRequestGroup;
begin
  Result := FList[FIndex];
end;

function TFhirRequestGroupListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRequestGroupList }
procedure TFhirRequestGroupList.AddItem(value: TFhirRequestGroup);
begin
  assert(value.ClassName = 'TFhirRequestGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestGroup');
  add(value);
end;

function TFhirRequestGroupList.Append: TFhirRequestGroup;
begin
  result := TFhirRequestGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupList.ClearItems;
begin
  Clear;
end;

function TFhirRequestGroupList.GetEnumerator : TFhirRequestGroupListEnumerator;
begin
  result := TFhirRequestGroupListEnumerator.Create(self.link);
end;

function TFhirRequestGroupList.Clone: TFhirRequestGroupList;
begin
  result := TFhirRequestGroupList(inherited Clone);
end;

function TFhirRequestGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestGroupList.GetItemN(index: Integer): TFhirRequestGroup;
begin
  result := TFhirRequestGroup(ObjectByIndex[index]);
end;

function TFhirRequestGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestGroup;
end;
function TFhirRequestGroupList.IndexOf(value: TFhirRequestGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestGroupList.Insert(index: Integer): TFhirRequestGroup;
begin
  result := TFhirRequestGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupList.InsertItem(index: Integer; value: TFhirRequestGroup);
begin
  assert(value is TFhirRequestGroup);
  Inherited Insert(index, value);
end;

function TFhirRequestGroupList.Item(index: Integer): TFhirRequestGroup;
begin
  result := TFhirRequestGroup(ObjectByIndex[index]);
end;

function TFhirRequestGroupList.Link: TFhirRequestGroupList;
begin
  result := TFhirRequestGroupList(inherited Link);
end;

procedure TFhirRequestGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestGroupList.SetItemByIndex(index: Integer; value: TFhirRequestGroup);
begin
  assert(value is TFhirRequestGroup);
  FhirRequestGroups[index] := value;
end;

procedure TFhirRequestGroupList.SetItemN(index: Integer; value: TFhirRequestGroup);
begin
  assert(value is TFhirRequestGroup);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_REQUESTGROUP}

{$IFDEF FHIR_RESEARCHDEFINITION}

{ TFhirResearchDefinition }

constructor TFhirResearchDefinition.Create;
begin
  inherited;
end;

destructor TFhirResearchDefinition.Destroy;
begin
  FIdentifierList.Free;
  FShortTitle.free;
  FSubtitle.free;
  FSubject.free;
  FCommentList.Free;
  FPurpose.free;
  FUsage.free;
  FCopyright.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FTopicList.Free;
  FAuthorList.Free;
  FEditorList.Free;
  FReviewerList.Free;
  FEndorserList.Free;
  FRelatedArtifactList.Free;
  FLibrary_List.Free;
  FPopulation.free;
  FExposure.free;
  FExposureAlternative.free;
  FOutcome.free;
  inherited;
end;

function TFhirResearchDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtResearchDefinition;
end;

procedure TFhirResearchDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirResearchDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirResearchDefinition(oSource).FIdentifierList);
  end;
  shortTitleElement := TFhirResearchDefinition(oSource).shortTitleElement.Clone;
  subtitleElement := TFhirResearchDefinition(oSource).subtitleElement.Clone;
  subject := TFhirResearchDefinition(oSource).subject.Clone;
  if (TFhirResearchDefinition(oSource).FCommentList = nil) then
  begin
    FCommentList.free;
    FCommentList := nil;
  end
  else
  begin
    if FCommentList = nil then
      FCommentList := TFhirStringList.Create;
    FCommentList.Assign(TFhirResearchDefinition(oSource).FCommentList);
  end;
  purposeElement := TFhirResearchDefinition(oSource).purposeElement.Clone;
  usageElement := TFhirResearchDefinition(oSource).usageElement.Clone;
  copyrightElement := TFhirResearchDefinition(oSource).copyrightElement.Clone;
  approvalDateElement := TFhirResearchDefinition(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirResearchDefinition(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirResearchDefinition(oSource).effectivePeriod.Clone;
  if (TFhirResearchDefinition(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirCodeableConceptList.Create;
    FTopicList.Assign(TFhirResearchDefinition(oSource).FTopicList);
  end;
  if (TFhirResearchDefinition(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirContactDetailList.Create;
    FAuthorList.Assign(TFhirResearchDefinition(oSource).FAuthorList);
  end;
  if (TFhirResearchDefinition(oSource).FEditorList = nil) then
  begin
    FEditorList.free;
    FEditorList := nil;
  end
  else
  begin
    if FEditorList = nil then
      FEditorList := TFhirContactDetailList.Create;
    FEditorList.Assign(TFhirResearchDefinition(oSource).FEditorList);
  end;
  if (TFhirResearchDefinition(oSource).FReviewerList = nil) then
  begin
    FReviewerList.free;
    FReviewerList := nil;
  end
  else
  begin
    if FReviewerList = nil then
      FReviewerList := TFhirContactDetailList.Create;
    FReviewerList.Assign(TFhirResearchDefinition(oSource).FReviewerList);
  end;
  if (TFhirResearchDefinition(oSource).FEndorserList = nil) then
  begin
    FEndorserList.free;
    FEndorserList := nil;
  end
  else
  begin
    if FEndorserList = nil then
      FEndorserList := TFhirContactDetailList.Create;
    FEndorserList.Assign(TFhirResearchDefinition(oSource).FEndorserList);
  end;
  if (TFhirResearchDefinition(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirResearchDefinition(oSource).FRelatedArtifactList);
  end;
  if (TFhirResearchDefinition(oSource).FLibrary_List = nil) then
  begin
    FLibrary_List.free;
    FLibrary_List := nil;
  end
  else
  begin
    if FLibrary_List = nil then
      FLibrary_List := TFhirCanonicalList.Create;
    FLibrary_List.Assign(TFhirResearchDefinition(oSource).FLibrary_List);
  end;
  population := TFhirResearchDefinition(oSource).population.Clone;
  exposure := TFhirResearchDefinition(oSource).exposure.Clone;
  exposureAlternative := TFhirResearchDefinition(oSource).exposureAlternative.Clone;
  outcome := TFhirResearchDefinition(oSource).outcome.Clone;
end;

procedure TFhirResearchDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'shortTitle') Then
     list.add(self.link, 'shortTitle', FShortTitle.Link);
  if (child_name = 'subtitle') Then
     list.add(self.link, 'subtitle', FSubtitle.Link);
  if (child_name = 'subject[x]') or (child_name = 'subject') Then
     list.add(self.link, 'subject[x]', FSubject.Link);
  if (child_name = 'comment') Then
    list.addAll(self, 'comment', FCommentList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'usage') Then
     list.add(self.link, 'usage', FUsage.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'editor') Then
    list.addAll(self, 'editor', FEditorList);
  if (child_name = 'reviewer') Then
    list.addAll(self, 'reviewer', FReviewerList);
  if (child_name = 'endorser') Then
    list.addAll(self, 'endorser', FEndorserList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'library') Then
    list.addAll(self, 'library', FLibrary_List);
  if (child_name = 'population') Then
     list.add(self.link, 'population', FPopulation.Link);
  if (child_name = 'exposure') Then
     list.add(self.link, 'exposure', FExposure.Link);
  if (child_name = 'exposureAlternative') Then
     list.add(self.link, 'exposureAlternative', FExposureAlternative.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
end;

procedure TFhirResearchDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'shortTitle', 'string', false, TFhirString, FShortTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subtitle', 'string', false, TFhirString, FSubtitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject[x]', 'CodeableConcept|Reference(Group)', false, TFhirType, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', true, TFhirString, FCommentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'usage', 'string', false, TFhirString, FUsage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'topic', 'CodeableConcept', true, TFhirCodeableConcept, FTopicList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'author', 'ContactDetail', true, TFhirContactDetail, FAuthorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'editor', 'ContactDetail', true, TFhirContactDetail, FEditorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reviewer', 'ContactDetail', true, TFhirContactDetail, FReviewerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'endorser', 'ContactDetail', true, TFhirContactDetail, FEndorserList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'library', 'canonical', true, TFhirCanonical, FLibrary_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'population', 'Reference(ResearchElementDefinition)', false, TFhirReference{TFhirResearchElementDefinition}, FPopulation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'exposure', 'Reference(ResearchElementDefinition)', false, TFhirReference{TFhirResearchElementDefinition}, FExposure.Link));{2}
  oList.add(TFHIRProperty.create(self, 'exposureAlternative', 'Reference(ResearchElementDefinition)', false, TFhirReference{TFhirResearchElementDefinition}, FExposureAlternative.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'Reference(ResearchElementDefinition)', false, TFhirReference{TFhirResearchElementDefinition}, FOutcome.Link));{2}
end;

function TFhirResearchDefinition.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'shortTitle') then
  begin
    ShortTitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subtitle') then
  begin
    SubtitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then
  begin
    Subject := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'editor') then
  begin
    EditorList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'reviewer') then
  begin
    ReviewerList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'endorser') then
  begin
    EndorserList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact){2a};
    result := propValue;
  end
  else if (propName = 'library') then
  begin
    Library_List.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'population') then
  begin
    Population := propValue as TFhirReference{TFhirResearchElementDefinition}{4b};
    result := propValue;
  end
  else if (propName = 'exposure') then
  begin
    Exposure := propValue as TFhirReference{TFhirResearchElementDefinition}{4b};
    result := propValue;
  end
  else if (propName = 'exposureAlternative') then
  begin
    ExposureAlternative := propValue as TFhirReference{TFhirResearchElementDefinition}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirReference{TFhirResearchElementDefinition}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirResearchDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'comment') then CommentList.insertItem(index, asString(propValue)){2}
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'editor') then EditorList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'reviewer') then ReviewerList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'endorser') then EndorserList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact){2a}
  else if (propName = 'library') then Library_List.insertItem(index, asCanonical(propValue)){2}
  else inherited;
end;

function TFhirResearchDefinition.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'shortTitle') then result := TFhirString.create() {5b}
  else if (propName = 'subtitle') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Subject'){4x}
  else if (propName = 'comment') then result := CommentList.new(){2}
  else if (propName = 'purpose') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'usage') then result := TFhirString.create() {5b}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'approvalDate') then result := TFhirDate.create() {5b}
  else if (propName = 'lastReviewDate') then result := TFhirDate.create() {5b}
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'topic') then result := TopicList.new(){2}
  else if (propName = 'author') then result := AuthorList.new(){2}
  else if (propName = 'editor') then result := EditorList.new(){2}
  else if (propName = 'reviewer') then result := ReviewerList.new(){2}
  else if (propName = 'endorser') then result := EndorserList.new(){2}
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new(){2}
  else if (propName = 'library') then result := Library_List.new(){2}
  else if (propName = 'population') then result := TFhirReference{TFhirResearchElementDefinition}.create(){4b}
  else if (propName = 'exposure') then result := TFhirReference{TFhirResearchElementDefinition}.create(){4b}
  else if (propName = 'exposureAlternative') then result := TFhirReference{TFhirResearchElementDefinition}.create(){4b}
  else if (propName = 'outcome') then result := TFhirReference{TFhirResearchElementDefinition}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'shortTitle') then result := 'string'
  else if (propName = 'subtitle') then result := 'string'
  else if (propName = 'subject[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'usage') then result := 'string'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'topic') then result := 'CodeableConcept'
  else if (propName = 'author') then result := 'ContactDetail'
  else if (propName = 'editor') then result := 'ContactDetail'
  else if (propName = 'reviewer') then result := 'ContactDetail'
  else if (propName = 'endorser') then result := 'ContactDetail'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'library') then result := 'canonical'
  else if (propName = 'population') then result := 'Reference'
  else if (propName = 'exposure') then result := 'Reference'
  else if (propName = 'exposureAlternative') then result := 'Reference'
  else if (propName = 'outcome') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchDefinition.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'shortTitle') then ShortTitleElement := nil
  else if (propName = 'subtitle') then SubtitleElement := nil
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then SubjectElement := nil{4x}
  else if (propName = 'comment') then deletePropertyValue('comment', CommentList, value) {2}
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'usage') then UsageElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value) {2}
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value) {2}
  else if (propName = 'editor') then deletePropertyValue('editor', EditorList, value) {2}
  else if (propName = 'reviewer') then deletePropertyValue('reviewer', ReviewerList, value) {2}
  else if (propName = 'endorser') then deletePropertyValue('endorser', EndorserList, value) {2}
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value) {2}
  else if (propName = 'library') then deletePropertyValue('library', Library_List, value) {2}
  else if (propName = 'population') then PopulationElement := nil
  else if (propName = 'exposure') then ExposureElement := nil
  else if (propName = 'exposureAlternative') then ExposureAlternativeElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'shortTitle') then ShortTitleElement := asString(new){5b}
  else if (propName = 'subtitle') then SubtitleElement := asString(new){5b}
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then SubjectElement := new as TFhirType{4x}
  else if (propName = 'comment') then replacePropertyValue('comment', CommentList, existing, new) {2}
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new){5b}
  else if (propName = 'usage') then UsageElement := asString(new){5b}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new){5b}
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new){5b}
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod{4}
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new) {2}
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new) {2}
  else if (propName = 'editor') then replacePropertyValue('editor', EditorList, existing, new) {2}
  else if (propName = 'reviewer') then replacePropertyValue('reviewer', ReviewerList, existing, new) {2}
  else if (propName = 'endorser') then replacePropertyValue('endorser', EndorserList, existing, new) {2}
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new) {2}
  else if (propName = 'library') then replacePropertyValue('library', Library_List, existing, new) {2}
  else if (propName = 'population') then PopulationElement := new as TFhirReference{TFhirResearchElementDefinition}{4}
  else if (propName = 'exposure') then ExposureElement := new as TFhirReference{TFhirResearchElementDefinition}{4}
  else if (propName = 'exposureAlternative') then ExposureAlternativeElement := new as TFhirReference{TFhirResearchElementDefinition}{4}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirReference{TFhirResearchElementDefinition}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'comment') then CommentList.move(source, destination){2}
  else if (propName = 'topic') then TopicList.move(source, destination){2a}
  else if (propName = 'author') then AuthorList.move(source, destination){2a}
  else if (propName = 'editor') then EditorList.move(source, destination){2a}
  else if (propName = 'reviewer') then ReviewerList.move(source, destination){2a}
  else if (propName = 'endorser') then EndorserList.move(source, destination){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination){2a}
  else if (propName = 'library') then Library_List.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchDefinition.fhirType : string;
begin
  result := 'ResearchDefinition';
end;

function TFhirResearchDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FShortTitle) and isEmptyProp(FSubtitle) and isEmptyProp(FSubject) and isEmptyProp(FcommentList) and isEmptyProp(FPurpose) and isEmptyProp(FUsage) and isEmptyProp(FCopyright) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FtopicList) and isEmptyProp(FauthorList) and isEmptyProp(FeditorList) and isEmptyProp(FreviewerList) and isEmptyProp(FendorserList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(Flibrary_List) and isEmptyProp(FPopulation) and isEmptyProp(FExposure) and isEmptyProp(FExposureAlternative) and isEmptyProp(FOutcome);
end;

function TFhirResearchDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirResearchDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchDefinition)) then
    result := false
  else
  begin
    o := TFhirResearchDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(shortTitleElement, o.shortTitleElement, true) and 
      compareDeep(subtitleElement, o.subtitleElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(commentList, o.commentList, true) and compareDeep(purposeElement, o.purposeElement, true) and 
      compareDeep(usageElement, o.usageElement, true) and compareDeep(copyrightElement, o.copyrightElement, true) and 
      compareDeep(approvalDateElement, o.approvalDateElement, true) and compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and 
      compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and compareDeep(topicList, o.topicList, true) and 
      compareDeep(authorList, o.authorList, true) and compareDeep(editorList, o.editorList, true) and 
      compareDeep(reviewerList, o.reviewerList, true) and compareDeep(endorserList, o.endorserList, true) and 
      compareDeep(relatedArtifactList, o.relatedArtifactList, true) and compareDeep(library_List, o.library_List, true) and 
      compareDeep(populationElement, o.populationElement, true) and compareDeep(exposureElement, o.exposureElement, true) and 
      compareDeep(exposureAlternativeElement, o.exposureAlternativeElement, true) and 
      compareDeep(outcomeElement, o.outcomeElement, true);
  end;
end;

function TFhirResearchDefinition.Link : TFhirResearchDefinition;
begin
  result := TFhirResearchDefinition(inherited Link);
end;

function TFhirResearchDefinition.Clone : TFhirResearchDefinition;
begin
  result := TFhirResearchDefinition(inherited Clone);
end;

procedure TFhirResearchDefinition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('shortTitle');
  fields.add('subtitle');
  fields.add('status');
  fields.add('experimental');
  fields.add('subject[x]');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('comment');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('usage');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('topic');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatedArtifact');
  fields.add('library');
  fields.add('population');
  fields.add('exposure');
  fields.add('exposureAlternative');
  fields.add('outcome');
end;

{ TFhirResearchDefinition }

Function TFhirResearchDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirResearchDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirResearchDefinition.SetShortTitle(value : TFhirString);
begin
  FShortTitle.free;
  FShortTitle := value;
end;

Function TFhirResearchDefinition.GetShortTitleST : String;
begin
  if FShortTitle = nil then
    result := ''
  else
    result := FShortTitle.value;
end;

Procedure TFhirResearchDefinition.SetShortTitleST(value : String);
begin
  if value <> '' then
  begin
    if FShortTitle = nil then
      FShortTitle := TFhirString.create;
    FShortTitle.value := value
  end
  else if FShortTitle <> nil then
    FShortTitle.value := '';
end;

Procedure TFhirResearchDefinition.SetSubtitle(value : TFhirString);
begin
  FSubtitle.free;
  FSubtitle := value;
end;

Function TFhirResearchDefinition.GetSubtitleST : String;
begin
  if FSubtitle = nil then
    result := ''
  else
    result := FSubtitle.value;
end;

Procedure TFhirResearchDefinition.SetSubtitleST(value : String);
begin
  if value <> '' then
  begin
    if FSubtitle = nil then
      FSubtitle := TFhirString.create;
    FSubtitle.value := value
  end
  else if FSubtitle <> nil then
    FSubtitle.value := '';
end;

Procedure TFhirResearchDefinition.SetSubject(value : TFhirType);
begin
  FSubject.free;
  FSubject := value;
end;

Function TFhirResearchDefinition.GetCommentList : TFhirStringList;
begin
  if FCommentList = nil then
    FCommentList := TFhirStringList.Create;
  result := FCommentList;
end;

Function TFhirResearchDefinition.GetHasCommentList : boolean;
begin
  result := (FCommentList <> nil) and (FCommentList.count > 0);
end;

Procedure TFhirResearchDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirResearchDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirResearchDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

Procedure TFhirResearchDefinition.SetUsage(value : TFhirString);
begin
  FUsage.free;
  FUsage := value;
end;

Function TFhirResearchDefinition.GetUsageST : String;
begin
  if FUsage = nil then
    result := ''
  else
    result := FUsage.value;
end;

Procedure TFhirResearchDefinition.SetUsageST(value : String);
begin
  if value <> '' then
  begin
    if FUsage = nil then
      FUsage := TFhirString.create;
    FUsage.value := value
  end
  else if FUsage <> nil then
    FUsage.value := '';
end;

Procedure TFhirResearchDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirResearchDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirResearchDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Procedure TFhirResearchDefinition.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

Function TFhirResearchDefinition.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

Procedure TFhirResearchDefinition.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

Procedure TFhirResearchDefinition.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

Function TFhirResearchDefinition.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

Procedure TFhirResearchDefinition.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

Procedure TFhirResearchDefinition.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

Function TFhirResearchDefinition.GetTopicList : TFhirCodeableConceptList;
begin
  if FTopicList = nil then
    FTopicList := TFhirCodeableConceptList.Create;
  result := FTopicList;
end;

Function TFhirResearchDefinition.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

Function TFhirResearchDefinition.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

Function TFhirResearchDefinition.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

Function TFhirResearchDefinition.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

Function TFhirResearchDefinition.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

Function TFhirResearchDefinition.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

Function TFhirResearchDefinition.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

Function TFhirResearchDefinition.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

Function TFhirResearchDefinition.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

Function TFhirResearchDefinition.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

Function TFhirResearchDefinition.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

Function TFhirResearchDefinition.GetLibrary_List : TFhirCanonicalList;
begin
  if FLibrary_List = nil then
    FLibrary_List := TFhirCanonicalList.Create;
  result := FLibrary_List;
end;

Function TFhirResearchDefinition.GetHasLibrary_List : boolean;
begin
  result := (FLibrary_List <> nil) and (FLibrary_List.count > 0);
end;

Procedure TFhirResearchDefinition.SetPopulation(value : TFhirReference{TFhirResearchElementDefinition});
begin
  FPopulation.free;
  FPopulation := value;
end;

Procedure TFhirResearchDefinition.SetExposure(value : TFhirReference{TFhirResearchElementDefinition});
begin
  FExposure.free;
  FExposure := value;
end;

Procedure TFhirResearchDefinition.SetExposureAlternative(value : TFhirReference{TFhirResearchElementDefinition});
begin
  FExposureAlternative.free;
  FExposureAlternative := value;
end;

Procedure TFhirResearchDefinition.SetOutcome(value : TFhirReference{TFhirResearchElementDefinition});
begin
  FOutcome.free;
  FOutcome := value;
end;

function TFhirResearchDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FShortTitle.sizeInBytes);
  inc(result, FSubtitle.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FcommentList.sizeInBytes);
  inc(result, FPurpose.sizeInBytes);
  inc(result, FUsage.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FApprovalDate.sizeInBytes);
  inc(result, FLastReviewDate.sizeInBytes);
  inc(result, FEffectivePeriod.sizeInBytes);
  inc(result, FtopicList.sizeInBytes);
  inc(result, FauthorList.sizeInBytes);
  inc(result, FeditorList.sizeInBytes);
  inc(result, FreviewerList.sizeInBytes);
  inc(result, FendorserList.sizeInBytes);
  inc(result, FrelatedArtifactList.sizeInBytes);
  inc(result, Flibrary_List.sizeInBytes);
  inc(result, FPopulation.sizeInBytes);
  inc(result, FExposure.sizeInBytes);
  inc(result, FExposureAlternative.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
end;

{ TFhirResearchDefinitionListEnumerator }

Constructor TFhirResearchDefinitionListEnumerator.Create(list : TFhirResearchDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchDefinitionListEnumerator.GetCurrent : TFhirResearchDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirResearchDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirResearchDefinitionList }
procedure TFhirResearchDefinitionList.AddItem(value: TFhirResearchDefinition);
begin
  assert(value.ClassName = 'TFhirResearchDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchDefinition');
  add(value);
end;

function TFhirResearchDefinitionList.Append: TFhirResearchDefinition;
begin
  result := TFhirResearchDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirResearchDefinitionList.GetEnumerator : TFhirResearchDefinitionListEnumerator;
begin
  result := TFhirResearchDefinitionListEnumerator.Create(self.link);
end;

function TFhirResearchDefinitionList.Clone: TFhirResearchDefinitionList;
begin
  result := TFhirResearchDefinitionList(inherited Clone);
end;

function TFhirResearchDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchDefinitionList.GetItemN(index: Integer): TFhirResearchDefinition;
begin
  result := TFhirResearchDefinition(ObjectByIndex[index]);
end;

function TFhirResearchDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchDefinition;
end;
function TFhirResearchDefinitionList.IndexOf(value: TFhirResearchDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchDefinitionList.Insert(index: Integer): TFhirResearchDefinition;
begin
  result := TFhirResearchDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchDefinitionList.InsertItem(index: Integer; value: TFhirResearchDefinition);
begin
  assert(value is TFhirResearchDefinition);
  Inherited Insert(index, value);
end;

function TFhirResearchDefinitionList.Item(index: Integer): TFhirResearchDefinition;
begin
  result := TFhirResearchDefinition(ObjectByIndex[index]);
end;

function TFhirResearchDefinitionList.Link: TFhirResearchDefinitionList;
begin
  result := TFhirResearchDefinitionList(inherited Link);
end;

procedure TFhirResearchDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchDefinitionList.SetItemByIndex(index: Integer; value: TFhirResearchDefinition);
begin
  assert(value is TFhirResearchDefinition);
  FhirResearchDefinitions[index] := value;
end;

procedure TFhirResearchDefinitionList.SetItemN(index: Integer; value: TFhirResearchDefinition);
begin
  assert(value is TFhirResearchDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RESEARCHDEFINITION}

{$IFDEF FHIR_RESEARCHELEMENTDEFINITION}

{ TFhirResearchElementDefinitionCharacteristic }

constructor TFhirResearchElementDefinitionCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirResearchElementDefinitionCharacteristic.Destroy;
begin
  FDefinition.free;
  FUsageContextList.Free;
  FExclude.free;
  FUnitOfMeasure.free;
  FStudyEffectiveDescription.free;
  FStudyEffective.free;
  FStudyEffectiveTimeFromStart.free;
  FStudyEffectiveGroupMeasure.free;
  FParticipantEffectiveDescription.free;
  FParticipantEffective.free;
  FParticipantEffectiveTimeFromStart.free;
  FParticipantEffectiveGroupMeasure.free;
  inherited;
end;

procedure TFhirResearchElementDefinitionCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  definition := TFhirResearchElementDefinitionCharacteristic(oSource).definition.Clone;
  if (TFhirResearchElementDefinitionCharacteristic(oSource).FUsageContextList = nil) then
  begin
    FUsageContextList.free;
    FUsageContextList := nil;
  end
  else
  begin
    if FUsageContextList = nil then
      FUsageContextList := TFhirUsageContextList.Create;
    FUsageContextList.Assign(TFhirResearchElementDefinitionCharacteristic(oSource).FUsageContextList);
  end;
  excludeElement := TFhirResearchElementDefinitionCharacteristic(oSource).excludeElement.Clone;
  unitOfMeasure := TFhirResearchElementDefinitionCharacteristic(oSource).unitOfMeasure.Clone;
  studyEffectiveDescriptionElement := TFhirResearchElementDefinitionCharacteristic(oSource).studyEffectiveDescriptionElement.Clone;
  studyEffective := TFhirResearchElementDefinitionCharacteristic(oSource).studyEffective.Clone;
  studyEffectiveTimeFromStart := TFhirResearchElementDefinitionCharacteristic(oSource).studyEffectiveTimeFromStart.Clone;
  FStudyEffectiveGroupMeasure := TFhirResearchElementDefinitionCharacteristic(oSource).FStudyEffectiveGroupMeasure.Link;
  participantEffectiveDescriptionElement := TFhirResearchElementDefinitionCharacteristic(oSource).participantEffectiveDescriptionElement.Clone;
  participantEffective := TFhirResearchElementDefinitionCharacteristic(oSource).participantEffective.Clone;
  participantEffectiveTimeFromStart := TFhirResearchElementDefinitionCharacteristic(oSource).participantEffectiveTimeFromStart.Clone;
  FParticipantEffectiveGroupMeasure := TFhirResearchElementDefinitionCharacteristic(oSource).FParticipantEffectiveGroupMeasure.Link;
end;

procedure TFhirResearchElementDefinitionCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'definition[x]') or (child_name = 'definition') Then
     list.add(self.link, 'definition[x]', FDefinition.Link);
  if (child_name = 'usageContext') Then
    list.addAll(self, 'usageContext', FUsageContextList);
  if (child_name = 'exclude') Then
     list.add(self.link, 'exclude', FExclude.Link);
  if (child_name = 'unitOfMeasure') Then
     list.add(self.link, 'unitOfMeasure', FUnitOfMeasure.Link);
  if (child_name = 'studyEffectiveDescription') Then
     list.add(self.link, 'studyEffectiveDescription', FStudyEffectiveDescription.Link);
  if (child_name = 'studyEffective[x]') or (child_name = 'studyEffective') Then
     list.add(self.link, 'studyEffective[x]', FStudyEffective.Link);
  if (child_name = 'studyEffectiveTimeFromStart') Then
     list.add(self.link, 'studyEffectiveTimeFromStart', FStudyEffectiveTimeFromStart.Link);
  if (child_name = 'studyEffectiveGroupMeasure') Then
     list.add(self.link, 'studyEffectiveGroupMeasure', FStudyEffectiveGroupMeasure.Link);
  if (child_name = 'participantEffectiveDescription') Then
     list.add(self.link, 'participantEffectiveDescription', FParticipantEffectiveDescription.Link);
  if (child_name = 'participantEffective[x]') or (child_name = 'participantEffective') Then
     list.add(self.link, 'participantEffective[x]', FParticipantEffective.Link);
  if (child_name = 'participantEffectiveTimeFromStart') Then
     list.add(self.link, 'participantEffectiveTimeFromStart', FParticipantEffectiveTimeFromStart.Link);
  if (child_name = 'participantEffectiveGroupMeasure') Then
     list.add(self.link, 'participantEffectiveGroupMeasure', FParticipantEffectiveGroupMeasure.Link);
end;

procedure TFhirResearchElementDefinitionCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'definition[x]', 'CodeableConcept|canonical|Expression|DataRequirement', false, TFhirType, FDefinition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'usageContext', 'UsageContext', true, TFhirUsageContext, FUsageContextList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'exclude', 'boolean', false, TFhirBoolean, FExclude.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitOfMeasure', 'CodeableConcept', false, TFhirCodeableConcept, FUnitOfMeasure.Link));{2}
  oList.add(TFHIRProperty.create(self, 'studyEffectiveDescription', 'string', false, TFhirString, FStudyEffectiveDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'studyEffective[x]', 'dateTime|Period|Duration|Timing', false, TFhirType, FStudyEffective.Link));{2}
  oList.add(TFHIRProperty.create(self, 'studyEffectiveTimeFromStart', 'Duration', false, TFhirDuration, FStudyEffectiveTimeFromStart.Link));{2}
  oList.add(TFHIRProperty.create(self, 'studyEffectiveGroupMeasure', 'code', false, TFHIREnum, FStudyEffectiveGroupMeasure.Link));{1}
  oList.add(TFHIRProperty.create(self, 'participantEffectiveDescription', 'string', false, TFhirString, FParticipantEffectiveDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'participantEffective[x]', 'dateTime|Period|Duration|Timing', false, TFhirType, FParticipantEffective.Link));{2}
  oList.add(TFHIRProperty.create(self, 'participantEffectiveTimeFromStart', 'Duration', false, TFhirDuration, FParticipantEffectiveTimeFromStart.Link));{2}
  oList.add(TFHIRProperty.create(self, 'participantEffectiveGroupMeasure', 'code', false, TFHIREnum, FParticipantEffectiveGroupMeasure.Link));{1}
end;

function TFhirResearchElementDefinitionCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'definition', ['CodeableConcept', 'Canonical', 'Expression', 'DataRequirement'])) then
  begin
    Definition := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'usageContext') then
  begin
    UsageContextList.add(propValue as TFhirUsageContext){2a};
    result := propValue;
  end
  else if (propName = 'exclude') then
  begin
    ExcludeElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'unitOfMeasure') then
  begin
    UnitOfMeasure := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'studyEffectiveDescription') then
  begin
    StudyEffectiveDescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'studyEffective', ['DateTime', 'Period', 'Duration', 'Timing'])) then
  begin
    StudyEffective := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'studyEffectiveTimeFromStart') then
  begin
    StudyEffectiveTimeFromStart := propValue as TFhirDuration{4b};
    result := propValue;
  end
  else if (propName = 'studyEffectiveGroupMeasure') then
  begin
    StudyEffectiveGroupMeasureElement := asEnum(SYSTEMS_TFhirGroupMeasureEnum, CODES_TFhirGroupMeasureEnum, propValue);
    result := propValue
  end
  else if (propName = 'participantEffectiveDescription') then
  begin
    ParticipantEffectiveDescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'participantEffective', ['DateTime', 'Period', 'Duration', 'Timing'])) then
  begin
    ParticipantEffective := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'participantEffectiveTimeFromStart') then
  begin
    ParticipantEffectiveTimeFromStart := propValue as TFhirDuration{4b};
    result := propValue;
  end
  else if (propName = 'participantEffectiveGroupMeasure') then
  begin
    ParticipantEffectiveGroupMeasureElement := asEnum(SYSTEMS_TFhirGroupMeasureEnum, CODES_TFhirGroupMeasureEnum, propValue);
    result := propValue
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchElementDefinitionCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'usageContext') then UsageContextList.insertItem(index, propValue as TFhirUsageContext){2a}
  else inherited;
end;

function TFhirResearchElementDefinitionCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'definition', ['CodeableConcept', 'Canonical', 'Expression', 'DataRequirement'])) then raise EFHIRException.create('Cannot make property Definition'){4x}
  else if (propName = 'usageContext') then result := UsageContextList.new(){2}
  else if (propName = 'exclude') then result := TFhirBoolean.create() {5b}
  else if (propName = 'unitOfMeasure') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'studyEffectiveDescription') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'studyEffective', ['DateTime', 'Period', 'Duration', 'Timing'])) then raise EFHIRException.create('Cannot make property StudyEffective'){4x}
  else if (propName = 'studyEffectiveTimeFromStart') then result := TFhirDuration.create(){4b}
  else if (propName = 'participantEffectiveDescription') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'participantEffective', ['DateTime', 'Period', 'Duration', 'Timing'])) then raise EFHIRException.create('Cannot make property ParticipantEffective'){4x}
  else if (propName = 'participantEffectiveTimeFromStart') then result := TFhirDuration.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchElementDefinitionCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'definition[x]') then result := 'CodeableConcept|canonical|Expression|DataRequirement'
  else if (propName = 'usageContext') then result := 'UsageContext'
  else if (propName = 'exclude') then result := 'boolean'
  else if (propName = 'unitOfMeasure') then result := 'CodeableConcept'
  else if (propName = 'studyEffectiveDescription') then result := 'string'
  else if (propName = 'studyEffective[x]') then result := 'dateTime|Period|Duration|Timing'
  else if (propName = 'studyEffectiveTimeFromStart') then result := 'Duration'
  else if (propName = 'studyEffectiveGroupMeasure') then result := 'code'
  else if (propName = 'participantEffectiveDescription') then result := 'string'
  else if (propName = 'participantEffective[x]') then result := 'dateTime|Period|Duration|Timing'
  else if (propName = 'participantEffectiveTimeFromStart') then result := 'Duration'
  else if (propName = 'participantEffectiveGroupMeasure') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchElementDefinitionCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'definition', ['CodeableConcept', 'Canonical', 'Expression', 'DataRequirement'])) then DefinitionElement := nil{4x}
  else if (propName = 'usageContext') then deletePropertyValue('usageContext', UsageContextList, value) {2}
  else if (propName = 'exclude') then ExcludeElement := nil
  else if (propName = 'unitOfMeasure') then UnitOfMeasureElement := nil
  else if (propName = 'studyEffectiveDescription') then StudyEffectiveDescriptionElement := nil
  else if (isMatchingName(propName, 'studyEffective', ['DateTime', 'Period', 'Duration', 'Timing'])) then StudyEffectiveElement := nil{4x}
  else if (propName = 'studyEffectiveTimeFromStart') then StudyEffectiveTimeFromStartElement := nil
  else if (propName = 'studyEffectiveGroupMeasure') then StudyEffectiveGroupMeasureElement := nil
  else if (propName = 'participantEffectiveDescription') then ParticipantEffectiveDescriptionElement := nil
  else if (isMatchingName(propName, 'participantEffective', ['DateTime', 'Period', 'Duration', 'Timing'])) then ParticipantEffectiveElement := nil{4x}
  else if (propName = 'participantEffectiveTimeFromStart') then ParticipantEffectiveTimeFromStartElement := nil
  else if (propName = 'participantEffectiveGroupMeasure') then ParticipantEffectiveGroupMeasureElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchElementDefinitionCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'definition', ['CodeableConcept', 'Canonical', 'Expression', 'DataRequirement'])) then DefinitionElement := new as TFhirType{4x}
  else if (propName = 'usageContext') then replacePropertyValue('usageContext', UsageContextList, existing, new) {2}
  else if (propName = 'exclude') then ExcludeElement := asBoolean(new){5b}
  else if (propName = 'unitOfMeasure') then UnitOfMeasureElement := new as TFhirCodeableConcept{4}
  else if (propName = 'studyEffectiveDescription') then StudyEffectiveDescriptionElement := asString(new){5b}
  else if (isMatchingName(propName, 'studyEffective', ['DateTime', 'Period', 'Duration', 'Timing'])) then StudyEffectiveElement := new as TFhirType{4x}
  else if (propName = 'studyEffectiveTimeFromStart') then StudyEffectiveTimeFromStartElement := new as TFhirDuration{4}
  else if (propName = 'studyEffectiveGroupMeasure') then StudyEffectiveGroupMeasureElement := asEnum(SYSTEMS_TFhirGroupMeasureEnum, CODES_TFhirGroupMeasureEnum, new){4}
  else if (propName = 'participantEffectiveDescription') then ParticipantEffectiveDescriptionElement := asString(new){5b}
  else if (isMatchingName(propName, 'participantEffective', ['DateTime', 'Period', 'Duration', 'Timing'])) then ParticipantEffectiveElement := new as TFhirType{4x}
  else if (propName = 'participantEffectiveTimeFromStart') then ParticipantEffectiveTimeFromStartElement := new as TFhirDuration{4}
  else if (propName = 'participantEffectiveGroupMeasure') then ParticipantEffectiveGroupMeasureElement := asEnum(SYSTEMS_TFhirGroupMeasureEnum, CODES_TFhirGroupMeasureEnum, new){4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchElementDefinitionCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'usageContext') then UsageContextList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchElementDefinitionCharacteristic.fhirType : string;
begin
  result := 'characteristic';
end;

function TFhirResearchElementDefinitionCharacteristic.Link : TFhirResearchElementDefinitionCharacteristic;
begin
  result := TFhirResearchElementDefinitionCharacteristic(inherited Link);
end;

function TFhirResearchElementDefinitionCharacteristic.Clone : TFhirResearchElementDefinitionCharacteristic;
begin
  result := TFhirResearchElementDefinitionCharacteristic(inherited Clone);
end;

function TFhirResearchElementDefinitionCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirResearchElementDefinitionCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchElementDefinitionCharacteristic)) then
    result := false
  else
  begin
    o := TFhirResearchElementDefinitionCharacteristic(other);
    result := compareDeep(definitionElement, o.definitionElement, true) and compareDeep(usageContextList, o.usageContextList, true) and 
      compareDeep(excludeElement, o.excludeElement, true) and compareDeep(unitOfMeasureElement, o.unitOfMeasureElement, true) and 
      compareDeep(studyEffectiveDescriptionElement, o.studyEffectiveDescriptionElement, true) and 
      compareDeep(studyEffectiveElement, o.studyEffectiveElement, true) and compareDeep(studyEffectiveTimeFromStartElement, o.studyEffectiveTimeFromStartElement, true) and 
      compareDeep(studyEffectiveGroupMeasureElement, o.studyEffectiveGroupMeasureElement, true) and 
      compareDeep(participantEffectiveDescriptionElement, o.participantEffectiveDescriptionElement, true) and 
      compareDeep(participantEffectiveElement, o.participantEffectiveElement, true) and 
      compareDeep(participantEffectiveTimeFromStartElement, o.participantEffectiveTimeFromStartElement, true) and 
      compareDeep(participantEffectiveGroupMeasureElement, o.participantEffectiveGroupMeasureElement, true);
  end;
end;

function TFhirResearchElementDefinitionCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDefinition) and isEmptyProp(FusageContextList) and isEmptyProp(FExclude) and isEmptyProp(FUnitOfMeasure) and isEmptyProp(FStudyEffectiveDescription) and isEmptyProp(FStudyEffective) and isEmptyProp(FStudyEffectiveTimeFromStart) and isEmptyProp(FStudyEffectiveGroupMeasure) and isEmptyProp(FParticipantEffectiveDescription) and isEmptyProp(FParticipantEffective) and isEmptyProp(FParticipantEffectiveTimeFromStart) and isEmptyProp(FParticipantEffectiveGroupMeasure);
end;

procedure TFhirResearchElementDefinitionCharacteristic.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('definition[x]');
  fields.add('usageContext');
  fields.add('exclude');
  fields.add('unitOfMeasure');
  fields.add('studyEffectiveDescription');
  fields.add('studyEffective[x]');
  fields.add('studyEffectiveTimeFromStart');
  fields.add('studyEffectiveGroupMeasure');
  fields.add('participantEffectiveDescription');
  fields.add('participantEffective[x]');
  fields.add('participantEffectiveTimeFromStart');
  fields.add('participantEffectiveGroupMeasure');
end;

{ TFhirResearchElementDefinitionCharacteristic }

Procedure TFhirResearchElementDefinitionCharacteristic.SetDefinition(value : TFhirType);
begin
  FDefinition.free;
  FDefinition := value;
end;

Function TFhirResearchElementDefinitionCharacteristic.GetUsageContextList : TFhirUsageContextList;
begin
  if FUsageContextList = nil then
    FUsageContextList := TFhirUsageContextList.Create;
  result := FUsageContextList;
end;

Function TFhirResearchElementDefinitionCharacteristic.GetHasUsageContextList : boolean;
begin
  result := (FUsageContextList <> nil) and (FUsageContextList.count > 0);
end;

Procedure TFhirResearchElementDefinitionCharacteristic.SetExclude(value : TFhirBoolean);
begin
  FExclude.free;
  FExclude := value;
end;

Function TFhirResearchElementDefinitionCharacteristic.GetExcludeST : Boolean;
begin
  if FExclude = nil then
    result := false
  else
    result := FExclude.value;
end;

Procedure TFhirResearchElementDefinitionCharacteristic.SetExcludeST(value : Boolean);
begin
  if FExclude = nil then
    FExclude := TFhirBoolean.create;
  FExclude.value := value
end;

Procedure TFhirResearchElementDefinitionCharacteristic.SetUnitOfMeasure(value : TFhirCodeableConcept);
begin
  FUnitOfMeasure.free;
  FUnitOfMeasure := value;
end;

Procedure TFhirResearchElementDefinitionCharacteristic.SetStudyEffectiveDescription(value : TFhirString);
begin
  FStudyEffectiveDescription.free;
  FStudyEffectiveDescription := value;
end;

Function TFhirResearchElementDefinitionCharacteristic.GetStudyEffectiveDescriptionST : String;
begin
  if FStudyEffectiveDescription = nil then
    result := ''
  else
    result := FStudyEffectiveDescription.value;
end;

Procedure TFhirResearchElementDefinitionCharacteristic.SetStudyEffectiveDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FStudyEffectiveDescription = nil then
      FStudyEffectiveDescription := TFhirString.create;
    FStudyEffectiveDescription.value := value
  end
  else if FStudyEffectiveDescription <> nil then
    FStudyEffectiveDescription.value := '';
end;

Procedure TFhirResearchElementDefinitionCharacteristic.SetStudyEffective(value : TFhirType);
begin
  FStudyEffective.free;
  FStudyEffective := value;
end;

Procedure TFhirResearchElementDefinitionCharacteristic.SetStudyEffectiveTimeFromStart(value : TFhirDuration);
begin
  FStudyEffectiveTimeFromStart.free;
  FStudyEffectiveTimeFromStart := value;
end;

Procedure TFhirResearchElementDefinitionCharacteristic.SetStudyEffectiveGroupMeasure(value : TFhirEnum);
begin
  FStudyEffectiveGroupMeasure.free;
  FStudyEffectiveGroupMeasure := value;
end;

Function TFhirResearchElementDefinitionCharacteristic.GetStudyEffectiveGroupMeasureST : TFhirGroupMeasureEnum;
begin
  if FStudyEffectiveGroupMeasure = nil then
    result := TFhirGroupMeasureEnum(0)
  else
    result := TFhirGroupMeasureEnum(StringArrayIndexOfSensitive(CODES_TFhirGroupMeasureEnum, FStudyEffectiveGroupMeasure.value));
end;

Procedure TFhirResearchElementDefinitionCharacteristic.SetStudyEffectiveGroupMeasureST(value : TFhirGroupMeasureEnum);
begin
  if ord(value) = 0 then
    StudyEffectiveGroupMeasureElement := nil
  else
    StudyEffectiveGroupMeasureElement := TFhirEnum.create(SYSTEMS_TFhirGroupMeasureEnum[value], CODES_TFhirGroupMeasureEnum[value]);
end;

Procedure TFhirResearchElementDefinitionCharacteristic.SetParticipantEffectiveDescription(value : TFhirString);
begin
  FParticipantEffectiveDescription.free;
  FParticipantEffectiveDescription := value;
end;

Function TFhirResearchElementDefinitionCharacteristic.GetParticipantEffectiveDescriptionST : String;
begin
  if FParticipantEffectiveDescription = nil then
    result := ''
  else
    result := FParticipantEffectiveDescription.value;
end;

Procedure TFhirResearchElementDefinitionCharacteristic.SetParticipantEffectiveDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FParticipantEffectiveDescription = nil then
      FParticipantEffectiveDescription := TFhirString.create;
    FParticipantEffectiveDescription.value := value
  end
  else if FParticipantEffectiveDescription <> nil then
    FParticipantEffectiveDescription.value := '';
end;

Procedure TFhirResearchElementDefinitionCharacteristic.SetParticipantEffective(value : TFhirType);
begin
  FParticipantEffective.free;
  FParticipantEffective := value;
end;

Procedure TFhirResearchElementDefinitionCharacteristic.SetParticipantEffectiveTimeFromStart(value : TFhirDuration);
begin
  FParticipantEffectiveTimeFromStart.free;
  FParticipantEffectiveTimeFromStart := value;
end;

Procedure TFhirResearchElementDefinitionCharacteristic.SetParticipantEffectiveGroupMeasure(value : TFhirEnum);
begin
  FParticipantEffectiveGroupMeasure.free;
  FParticipantEffectiveGroupMeasure := value;
end;

Function TFhirResearchElementDefinitionCharacteristic.GetParticipantEffectiveGroupMeasureST : TFhirGroupMeasureEnum;
begin
  if FParticipantEffectiveGroupMeasure = nil then
    result := TFhirGroupMeasureEnum(0)
  else
    result := TFhirGroupMeasureEnum(StringArrayIndexOfSensitive(CODES_TFhirGroupMeasureEnum, FParticipantEffectiveGroupMeasure.value));
end;

Procedure TFhirResearchElementDefinitionCharacteristic.SetParticipantEffectiveGroupMeasureST(value : TFhirGroupMeasureEnum);
begin
  if ord(value) = 0 then
    ParticipantEffectiveGroupMeasureElement := nil
  else
    ParticipantEffectiveGroupMeasureElement := TFhirEnum.create(SYSTEMS_TFhirGroupMeasureEnum[value], CODES_TFhirGroupMeasureEnum[value]);
end;

function TFhirResearchElementDefinitionCharacteristic.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDefinition.sizeInBytes);
  inc(result, FusageContextList.sizeInBytes);
  inc(result, FExclude.sizeInBytes);
  inc(result, FUnitOfMeasure.sizeInBytes);
  inc(result, FStudyEffectiveDescription.sizeInBytes);
  inc(result, FStudyEffective.sizeInBytes);
  inc(result, FStudyEffectiveTimeFromStart.sizeInBytes);
  inc(result, FStudyEffectiveGroupMeasure.sizeInBytes);
  inc(result, FParticipantEffectiveDescription.sizeInBytes);
  inc(result, FParticipantEffective.sizeInBytes);
  inc(result, FParticipantEffectiveTimeFromStart.sizeInBytes);
  inc(result, FParticipantEffectiveGroupMeasure.sizeInBytes);
end;

{ TFhirResearchElementDefinitionCharacteristicListEnumerator }

Constructor TFhirResearchElementDefinitionCharacteristicListEnumerator.Create(list : TFhirResearchElementDefinitionCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchElementDefinitionCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchElementDefinitionCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchElementDefinitionCharacteristicListEnumerator.GetCurrent : TFhirResearchElementDefinitionCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirResearchElementDefinitionCharacteristicListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirResearchElementDefinitionCharacteristicList }
procedure TFhirResearchElementDefinitionCharacteristicList.AddItem(value: TFhirResearchElementDefinitionCharacteristic);
begin
  assert(value.ClassName = 'TFhirResearchElementDefinitionCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchElementDefinitionCharacteristic');
  add(value);
end;

function TFhirResearchElementDefinitionCharacteristicList.Append: TFhirResearchElementDefinitionCharacteristic;
begin
  result := TFhirResearchElementDefinitionCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchElementDefinitionCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirResearchElementDefinitionCharacteristicList.GetEnumerator : TFhirResearchElementDefinitionCharacteristicListEnumerator;
begin
  result := TFhirResearchElementDefinitionCharacteristicListEnumerator.Create(self.link);
end;

function TFhirResearchElementDefinitionCharacteristicList.Clone: TFhirResearchElementDefinitionCharacteristicList;
begin
  result := TFhirResearchElementDefinitionCharacteristicList(inherited Clone);
end;

function TFhirResearchElementDefinitionCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchElementDefinitionCharacteristicList.GetItemN(index: Integer): TFhirResearchElementDefinitionCharacteristic;
begin
  result := TFhirResearchElementDefinitionCharacteristic(ObjectByIndex[index]);
end;

function TFhirResearchElementDefinitionCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchElementDefinitionCharacteristic;
end;
function TFhirResearchElementDefinitionCharacteristicList.IndexOf(value: TFhirResearchElementDefinitionCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchElementDefinitionCharacteristicList.Insert(index: Integer): TFhirResearchElementDefinitionCharacteristic;
begin
  result := TFhirResearchElementDefinitionCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchElementDefinitionCharacteristicList.InsertItem(index: Integer; value: TFhirResearchElementDefinitionCharacteristic);
begin
  assert(value is TFhirResearchElementDefinitionCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirResearchElementDefinitionCharacteristicList.Item(index: Integer): TFhirResearchElementDefinitionCharacteristic;
begin
  result := TFhirResearchElementDefinitionCharacteristic(ObjectByIndex[index]);
end;

function TFhirResearchElementDefinitionCharacteristicList.Link: TFhirResearchElementDefinitionCharacteristicList;
begin
  result := TFhirResearchElementDefinitionCharacteristicList(inherited Link);
end;

procedure TFhirResearchElementDefinitionCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchElementDefinitionCharacteristicList.SetItemByIndex(index: Integer; value: TFhirResearchElementDefinitionCharacteristic);
begin
  assert(value is TFhirResearchElementDefinitionCharacteristic);
  FhirResearchElementDefinitionCharacteristics[index] := value;
end;

procedure TFhirResearchElementDefinitionCharacteristicList.SetItemN(index: Integer; value: TFhirResearchElementDefinitionCharacteristic);
begin
  assert(value is TFhirResearchElementDefinitionCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirResearchElementDefinition }

constructor TFhirResearchElementDefinition.Create;
begin
  inherited;
end;

destructor TFhirResearchElementDefinition.Destroy;
begin
  FIdentifierList.Free;
  FShortTitle.free;
  FSubtitle.free;
  FSubject.free;
  FCommentList.Free;
  FPurpose.free;
  FUsage.free;
  FCopyright.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FTopicList.Free;
  FAuthorList.Free;
  FEditorList.Free;
  FReviewerList.Free;
  FEndorserList.Free;
  FRelatedArtifactList.Free;
  FLibrary_List.Free;
  FType_.free;
  FVariableType.free;
  FCharacteristicList.Free;
  inherited;
end;

function TFhirResearchElementDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtResearchElementDefinition;
end;

procedure TFhirResearchElementDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirResearchElementDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirResearchElementDefinition(oSource).FIdentifierList);
  end;
  shortTitleElement := TFhirResearchElementDefinition(oSource).shortTitleElement.Clone;
  subtitleElement := TFhirResearchElementDefinition(oSource).subtitleElement.Clone;
  subject := TFhirResearchElementDefinition(oSource).subject.Clone;
  if (TFhirResearchElementDefinition(oSource).FCommentList = nil) then
  begin
    FCommentList.free;
    FCommentList := nil;
  end
  else
  begin
    if FCommentList = nil then
      FCommentList := TFhirStringList.Create;
    FCommentList.Assign(TFhirResearchElementDefinition(oSource).FCommentList);
  end;
  purposeElement := TFhirResearchElementDefinition(oSource).purposeElement.Clone;
  usageElement := TFhirResearchElementDefinition(oSource).usageElement.Clone;
  copyrightElement := TFhirResearchElementDefinition(oSource).copyrightElement.Clone;
  approvalDateElement := TFhirResearchElementDefinition(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirResearchElementDefinition(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirResearchElementDefinition(oSource).effectivePeriod.Clone;
  if (TFhirResearchElementDefinition(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirCodeableConceptList.Create;
    FTopicList.Assign(TFhirResearchElementDefinition(oSource).FTopicList);
  end;
  if (TFhirResearchElementDefinition(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirContactDetailList.Create;
    FAuthorList.Assign(TFhirResearchElementDefinition(oSource).FAuthorList);
  end;
  if (TFhirResearchElementDefinition(oSource).FEditorList = nil) then
  begin
    FEditorList.free;
    FEditorList := nil;
  end
  else
  begin
    if FEditorList = nil then
      FEditorList := TFhirContactDetailList.Create;
    FEditorList.Assign(TFhirResearchElementDefinition(oSource).FEditorList);
  end;
  if (TFhirResearchElementDefinition(oSource).FReviewerList = nil) then
  begin
    FReviewerList.free;
    FReviewerList := nil;
  end
  else
  begin
    if FReviewerList = nil then
      FReviewerList := TFhirContactDetailList.Create;
    FReviewerList.Assign(TFhirResearchElementDefinition(oSource).FReviewerList);
  end;
  if (TFhirResearchElementDefinition(oSource).FEndorserList = nil) then
  begin
    FEndorserList.free;
    FEndorserList := nil;
  end
  else
  begin
    if FEndorserList = nil then
      FEndorserList := TFhirContactDetailList.Create;
    FEndorserList.Assign(TFhirResearchElementDefinition(oSource).FEndorserList);
  end;
  if (TFhirResearchElementDefinition(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirResearchElementDefinition(oSource).FRelatedArtifactList);
  end;
  if (TFhirResearchElementDefinition(oSource).FLibrary_List = nil) then
  begin
    FLibrary_List.free;
    FLibrary_List := nil;
  end
  else
  begin
    if FLibrary_List = nil then
      FLibrary_List := TFhirCanonicalList.Create;
    FLibrary_List.Assign(TFhirResearchElementDefinition(oSource).FLibrary_List);
  end;
  FType_ := TFhirResearchElementDefinition(oSource).FType_.Link;
  FVariableType := TFhirResearchElementDefinition(oSource).FVariableType.Link;
  if (TFhirResearchElementDefinition(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirResearchElementDefinitionCharacteristicList.Create;
    FCharacteristicList.Assign(TFhirResearchElementDefinition(oSource).FCharacteristicList);
  end;
end;

procedure TFhirResearchElementDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'shortTitle') Then
     list.add(self.link, 'shortTitle', FShortTitle.Link);
  if (child_name = 'subtitle') Then
     list.add(self.link, 'subtitle', FSubtitle.Link);
  if (child_name = 'subject[x]') or (child_name = 'subject') Then
     list.add(self.link, 'subject[x]', FSubject.Link);
  if (child_name = 'comment') Then
    list.addAll(self, 'comment', FCommentList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'usage') Then
     list.add(self.link, 'usage', FUsage.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'editor') Then
    list.addAll(self, 'editor', FEditorList);
  if (child_name = 'reviewer') Then
    list.addAll(self, 'reviewer', FReviewerList);
  if (child_name = 'endorser') Then
    list.addAll(self, 'endorser', FEndorserList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'library') Then
    list.addAll(self, 'library', FLibrary_List);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'variableType') Then
     list.add(self.link, 'variableType', FVariableType.Link);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
end;

procedure TFhirResearchElementDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'shortTitle', 'string', false, TFhirString, FShortTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subtitle', 'string', false, TFhirString, FSubtitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject[x]', 'CodeableConcept|Reference(Group)', false, TFhirType, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', true, TFhirString, FCommentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'usage', 'string', false, TFhirString, FUsage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'topic', 'CodeableConcept', true, TFhirCodeableConcept, FTopicList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'author', 'ContactDetail', true, TFhirContactDetail, FAuthorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'editor', 'ContactDetail', true, TFhirContactDetail, FEditorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reviewer', 'ContactDetail', true, TFhirContactDetail, FReviewerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'endorser', 'ContactDetail', true, TFhirContactDetail, FEndorserList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'library', 'canonical', true, TFhirCanonical, FLibrary_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'variableType', 'code', false, TFHIREnum, FVariableType.Link));{1}
  oList.add(TFHIRProperty.create(self, 'characteristic', '', true, TFhirResearchElementDefinitionCharacteristic, FCharacteristicList.Link)){3};
end;

function TFhirResearchElementDefinition.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'shortTitle') then
  begin
    ShortTitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subtitle') then
  begin
    SubtitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then
  begin
    Subject := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'editor') then
  begin
    EditorList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'reviewer') then
  begin
    ReviewerList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'endorser') then
  begin
    EndorserList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact){2a};
    result := propValue;
  end
  else if (propName = 'library') then
  begin
    Library_List.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirResearchElementTypeEnum, CODES_TFhirResearchElementTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'variableType') then
  begin
    VariableTypeElement := asEnum(SYSTEMS_TFhirVariableTypeEnum, CODES_TFhirVariableTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirResearchElementDefinitionCharacteristic){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirResearchElementDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'comment') then CommentList.insertItem(index, asString(propValue)){2}
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'editor') then EditorList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'reviewer') then ReviewerList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'endorser') then EndorserList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact){2a}
  else if (propName = 'library') then Library_List.insertItem(index, asCanonical(propValue)){2}
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirResearchElementDefinitionCharacteristic){2a}
  else inherited;
end;

function TFhirResearchElementDefinition.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'shortTitle') then result := TFhirString.create() {5b}
  else if (propName = 'subtitle') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Subject'){4x}
  else if (propName = 'comment') then result := CommentList.new(){2}
  else if (propName = 'purpose') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'usage') then result := TFhirString.create() {5b}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'approvalDate') then result := TFhirDate.create() {5b}
  else if (propName = 'lastReviewDate') then result := TFhirDate.create() {5b}
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'topic') then result := TopicList.new(){2}
  else if (propName = 'author') then result := AuthorList.new(){2}
  else if (propName = 'editor') then result := EditorList.new(){2}
  else if (propName = 'reviewer') then result := ReviewerList.new(){2}
  else if (propName = 'endorser') then result := EndorserList.new(){2}
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new(){2}
  else if (propName = 'library') then result := Library_List.new(){2}
  else if (propName = 'characteristic') then result := CharacteristicList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchElementDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'shortTitle') then result := 'string'
  else if (propName = 'subtitle') then result := 'string'
  else if (propName = 'subject[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'usage') then result := 'string'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'topic') then result := 'CodeableConcept'
  else if (propName = 'author') then result := 'ContactDetail'
  else if (propName = 'editor') then result := 'ContactDetail'
  else if (propName = 'reviewer') then result := 'ContactDetail'
  else if (propName = 'endorser') then result := 'ContactDetail'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'library') then result := 'canonical'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'variableType') then result := 'code'
  else if (propName = 'characteristic') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchElementDefinition.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'shortTitle') then ShortTitleElement := nil
  else if (propName = 'subtitle') then SubtitleElement := nil
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then SubjectElement := nil{4x}
  else if (propName = 'comment') then deletePropertyValue('comment', CommentList, value) {2}
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'usage') then UsageElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value) {2}
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value) {2}
  else if (propName = 'editor') then deletePropertyValue('editor', EditorList, value) {2}
  else if (propName = 'reviewer') then deletePropertyValue('reviewer', ReviewerList, value) {2}
  else if (propName = 'endorser') then deletePropertyValue('endorser', EndorserList, value) {2}
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value) {2}
  else if (propName = 'library') then deletePropertyValue('library', Library_List, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'variableType') then VariableTypeElement := nil
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchElementDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'shortTitle') then ShortTitleElement := asString(new){5b}
  else if (propName = 'subtitle') then SubtitleElement := asString(new){5b}
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then SubjectElement := new as TFhirType{4x}
  else if (propName = 'comment') then replacePropertyValue('comment', CommentList, existing, new) {2}
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new){5b}
  else if (propName = 'usage') then UsageElement := asString(new){5b}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new){5b}
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new){5b}
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod{4}
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new) {2}
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new) {2}
  else if (propName = 'editor') then replacePropertyValue('editor', EditorList, existing, new) {2}
  else if (propName = 'reviewer') then replacePropertyValue('reviewer', ReviewerList, existing, new) {2}
  else if (propName = 'endorser') then replacePropertyValue('endorser', EndorserList, existing, new) {2}
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new) {2}
  else if (propName = 'library') then replacePropertyValue('library', Library_List, existing, new) {2}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirResearchElementTypeEnum, CODES_TFhirResearchElementTypeEnum, new){4}
  else if (propName = 'variableType') then VariableTypeElement := asEnum(SYSTEMS_TFhirVariableTypeEnum, CODES_TFhirVariableTypeEnum, new){4}
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchElementDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'comment') then CommentList.move(source, destination){2}
  else if (propName = 'topic') then TopicList.move(source, destination){2a}
  else if (propName = 'author') then AuthorList.move(source, destination){2a}
  else if (propName = 'editor') then EditorList.move(source, destination){2a}
  else if (propName = 'reviewer') then ReviewerList.move(source, destination){2a}
  else if (propName = 'endorser') then EndorserList.move(source, destination){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination){2a}
  else if (propName = 'library') then Library_List.move(source, destination){2}
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchElementDefinition.fhirType : string;
begin
  result := 'ResearchElementDefinition';
end;

function TFhirResearchElementDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FShortTitle) and isEmptyProp(FSubtitle) and isEmptyProp(FSubject) and isEmptyProp(FcommentList) and isEmptyProp(FPurpose) and isEmptyProp(FUsage) and isEmptyProp(FCopyright) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FtopicList) and isEmptyProp(FauthorList) and isEmptyProp(FeditorList) and isEmptyProp(FreviewerList) and isEmptyProp(FendorserList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(Flibrary_List) and isEmptyProp(FType_) and isEmptyProp(FVariableType) and isEmptyProp(FcharacteristicList);
end;

function TFhirResearchElementDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirResearchElementDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchElementDefinition)) then
    result := false
  else
  begin
    o := TFhirResearchElementDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(shortTitleElement, o.shortTitleElement, true) and 
      compareDeep(subtitleElement, o.subtitleElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(commentList, o.commentList, true) and compareDeep(purposeElement, o.purposeElement, true) and 
      compareDeep(usageElement, o.usageElement, true) and compareDeep(copyrightElement, o.copyrightElement, true) and 
      compareDeep(approvalDateElement, o.approvalDateElement, true) and compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and 
      compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and compareDeep(topicList, o.topicList, true) and 
      compareDeep(authorList, o.authorList, true) and compareDeep(editorList, o.editorList, true) and 
      compareDeep(reviewerList, o.reviewerList, true) and compareDeep(endorserList, o.endorserList, true) and 
      compareDeep(relatedArtifactList, o.relatedArtifactList, true) and compareDeep(library_List, o.library_List, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(variableTypeElement, o.variableTypeElement, true) and 
      compareDeep(characteristicList, o.characteristicList, true);
  end;
end;

function TFhirResearchElementDefinition.Link : TFhirResearchElementDefinition;
begin
  result := TFhirResearchElementDefinition(inherited Link);
end;

function TFhirResearchElementDefinition.Clone : TFhirResearchElementDefinition;
begin
  result := TFhirResearchElementDefinition(inherited Clone);
end;

procedure TFhirResearchElementDefinition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('shortTitle');
  fields.add('subtitle');
  fields.add('status');
  fields.add('experimental');
  fields.add('subject[x]');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('comment');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('usage');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('topic');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatedArtifact');
  fields.add('library');
  fields.add('type');
  fields.add('variableType');
  fields.add('characteristic');
end;

{ TFhirResearchElementDefinition }

Function TFhirResearchElementDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirResearchElementDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirResearchElementDefinition.SetShortTitle(value : TFhirString);
begin
  FShortTitle.free;
  FShortTitle := value;
end;

Function TFhirResearchElementDefinition.GetShortTitleST : String;
begin
  if FShortTitle = nil then
    result := ''
  else
    result := FShortTitle.value;
end;

Procedure TFhirResearchElementDefinition.SetShortTitleST(value : String);
begin
  if value <> '' then
  begin
    if FShortTitle = nil then
      FShortTitle := TFhirString.create;
    FShortTitle.value := value
  end
  else if FShortTitle <> nil then
    FShortTitle.value := '';
end;

Procedure TFhirResearchElementDefinition.SetSubtitle(value : TFhirString);
begin
  FSubtitle.free;
  FSubtitle := value;
end;

Function TFhirResearchElementDefinition.GetSubtitleST : String;
begin
  if FSubtitle = nil then
    result := ''
  else
    result := FSubtitle.value;
end;

Procedure TFhirResearchElementDefinition.SetSubtitleST(value : String);
begin
  if value <> '' then
  begin
    if FSubtitle = nil then
      FSubtitle := TFhirString.create;
    FSubtitle.value := value
  end
  else if FSubtitle <> nil then
    FSubtitle.value := '';
end;

Procedure TFhirResearchElementDefinition.SetSubject(value : TFhirType);
begin
  FSubject.free;
  FSubject := value;
end;

Function TFhirResearchElementDefinition.GetCommentList : TFhirStringList;
begin
  if FCommentList = nil then
    FCommentList := TFhirStringList.Create;
  result := FCommentList;
end;

Function TFhirResearchElementDefinition.GetHasCommentList : boolean;
begin
  result := (FCommentList <> nil) and (FCommentList.count > 0);
end;

Procedure TFhirResearchElementDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirResearchElementDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirResearchElementDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

Procedure TFhirResearchElementDefinition.SetUsage(value : TFhirString);
begin
  FUsage.free;
  FUsage := value;
end;

Function TFhirResearchElementDefinition.GetUsageST : String;
begin
  if FUsage = nil then
    result := ''
  else
    result := FUsage.value;
end;

Procedure TFhirResearchElementDefinition.SetUsageST(value : String);
begin
  if value <> '' then
  begin
    if FUsage = nil then
      FUsage := TFhirString.create;
    FUsage.value := value
  end
  else if FUsage <> nil then
    FUsage.value := '';
end;

Procedure TFhirResearchElementDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirResearchElementDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirResearchElementDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Procedure TFhirResearchElementDefinition.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

Function TFhirResearchElementDefinition.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

Procedure TFhirResearchElementDefinition.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

Procedure TFhirResearchElementDefinition.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

Function TFhirResearchElementDefinition.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

Procedure TFhirResearchElementDefinition.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

Procedure TFhirResearchElementDefinition.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

Function TFhirResearchElementDefinition.GetTopicList : TFhirCodeableConceptList;
begin
  if FTopicList = nil then
    FTopicList := TFhirCodeableConceptList.Create;
  result := FTopicList;
end;

Function TFhirResearchElementDefinition.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

Function TFhirResearchElementDefinition.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

Function TFhirResearchElementDefinition.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

Function TFhirResearchElementDefinition.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

Function TFhirResearchElementDefinition.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

Function TFhirResearchElementDefinition.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

Function TFhirResearchElementDefinition.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

Function TFhirResearchElementDefinition.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

Function TFhirResearchElementDefinition.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

Function TFhirResearchElementDefinition.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

Function TFhirResearchElementDefinition.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

Function TFhirResearchElementDefinition.GetLibrary_List : TFhirCanonicalList;
begin
  if FLibrary_List = nil then
    FLibrary_List := TFhirCanonicalList.Create;
  result := FLibrary_List;
end;

Function TFhirResearchElementDefinition.GetHasLibrary_List : boolean;
begin
  result := (FLibrary_List <> nil) and (FLibrary_List.count > 0);
end;

Procedure TFhirResearchElementDefinition.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirResearchElementDefinition.GetType_ST : TFhirResearchElementTypeEnum;
begin
  if FType_ = nil then
    result := TFhirResearchElementTypeEnum(0)
  else
    result := TFhirResearchElementTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirResearchElementTypeEnum, FType_.value));
end;

Procedure TFhirResearchElementDefinition.SetType_ST(value : TFhirResearchElementTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirResearchElementTypeEnum[value], CODES_TFhirResearchElementTypeEnum[value]);
end;

Procedure TFhirResearchElementDefinition.SetVariableType(value : TFhirEnum);
begin
  FVariableType.free;
  FVariableType := value;
end;

Function TFhirResearchElementDefinition.GetVariableTypeST : TFhirVariableTypeEnum;
begin
  if FVariableType = nil then
    result := TFhirVariableTypeEnum(0)
  else
    result := TFhirVariableTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirVariableTypeEnum, FVariableType.value));
end;

Procedure TFhirResearchElementDefinition.SetVariableTypeST(value : TFhirVariableTypeEnum);
begin
  if ord(value) = 0 then
    VariableTypeElement := nil
  else
    VariableTypeElement := TFhirEnum.create(SYSTEMS_TFhirVariableTypeEnum[value], CODES_TFhirVariableTypeEnum[value]);
end;

Function TFhirResearchElementDefinition.GetCharacteristicList : TFhirResearchElementDefinitionCharacteristicList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirResearchElementDefinitionCharacteristicList.Create;
  result := FCharacteristicList;
end;

Function TFhirResearchElementDefinition.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

function TFhirResearchElementDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FShortTitle.sizeInBytes);
  inc(result, FSubtitle.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FcommentList.sizeInBytes);
  inc(result, FPurpose.sizeInBytes);
  inc(result, FUsage.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FApprovalDate.sizeInBytes);
  inc(result, FLastReviewDate.sizeInBytes);
  inc(result, FEffectivePeriod.sizeInBytes);
  inc(result, FtopicList.sizeInBytes);
  inc(result, FauthorList.sizeInBytes);
  inc(result, FeditorList.sizeInBytes);
  inc(result, FreviewerList.sizeInBytes);
  inc(result, FendorserList.sizeInBytes);
  inc(result, FrelatedArtifactList.sizeInBytes);
  inc(result, Flibrary_List.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FVariableType.sizeInBytes);
  inc(result, FcharacteristicList.sizeInBytes);
end;

{ TFhirResearchElementDefinitionListEnumerator }

Constructor TFhirResearchElementDefinitionListEnumerator.Create(list : TFhirResearchElementDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchElementDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchElementDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchElementDefinitionListEnumerator.GetCurrent : TFhirResearchElementDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirResearchElementDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirResearchElementDefinitionList }
procedure TFhirResearchElementDefinitionList.AddItem(value: TFhirResearchElementDefinition);
begin
  assert(value.ClassName = 'TFhirResearchElementDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchElementDefinition');
  add(value);
end;

function TFhirResearchElementDefinitionList.Append: TFhirResearchElementDefinition;
begin
  result := TFhirResearchElementDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchElementDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirResearchElementDefinitionList.GetEnumerator : TFhirResearchElementDefinitionListEnumerator;
begin
  result := TFhirResearchElementDefinitionListEnumerator.Create(self.link);
end;

function TFhirResearchElementDefinitionList.Clone: TFhirResearchElementDefinitionList;
begin
  result := TFhirResearchElementDefinitionList(inherited Clone);
end;

function TFhirResearchElementDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchElementDefinitionList.GetItemN(index: Integer): TFhirResearchElementDefinition;
begin
  result := TFhirResearchElementDefinition(ObjectByIndex[index]);
end;

function TFhirResearchElementDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchElementDefinition;
end;
function TFhirResearchElementDefinitionList.IndexOf(value: TFhirResearchElementDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchElementDefinitionList.Insert(index: Integer): TFhirResearchElementDefinition;
begin
  result := TFhirResearchElementDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchElementDefinitionList.InsertItem(index: Integer; value: TFhirResearchElementDefinition);
begin
  assert(value is TFhirResearchElementDefinition);
  Inherited Insert(index, value);
end;

function TFhirResearchElementDefinitionList.Item(index: Integer): TFhirResearchElementDefinition;
begin
  result := TFhirResearchElementDefinition(ObjectByIndex[index]);
end;

function TFhirResearchElementDefinitionList.Link: TFhirResearchElementDefinitionList;
begin
  result := TFhirResearchElementDefinitionList(inherited Link);
end;

procedure TFhirResearchElementDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchElementDefinitionList.SetItemByIndex(index: Integer; value: TFhirResearchElementDefinition);
begin
  assert(value is TFhirResearchElementDefinition);
  FhirResearchElementDefinitions[index] := value;
end;

procedure TFhirResearchElementDefinitionList.SetItemN(index: Integer; value: TFhirResearchElementDefinition);
begin
  assert(value is TFhirResearchElementDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RESEARCHELEMENTDEFINITION}

{$IFDEF FHIR_RESEARCHSTUDY}

{ TFhirResearchStudyArm }

constructor TFhirResearchStudyArm.Create;
begin
  inherited;
end;

destructor TFhirResearchStudyArm.Destroy;
begin
  FName.free;
  FType_.free;
  FDescription.free;
  inherited;
end;

procedure TFhirResearchStudyArm.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirResearchStudyArm(oSource).nameElement.Clone;
  type_ := TFhirResearchStudyArm(oSource).type_.Clone;
  descriptionElement := TFhirResearchStudyArm(oSource).descriptionElement.Clone;
end;

procedure TFhirResearchStudyArm.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
end;

procedure TFhirResearchStudyArm.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
end;

function TFhirResearchStudyArm.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchStudyArm.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirResearchStudyArm.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchStudyArm.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchStudyArm.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'description') then DescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchStudyArm.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchStudyArm.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchStudyArm.fhirType : string;
begin
  result := 'arm';
end;

function TFhirResearchStudyArm.Link : TFhirResearchStudyArm;
begin
  result := TFhirResearchStudyArm(inherited Link);
end;

function TFhirResearchStudyArm.Clone : TFhirResearchStudyArm;
begin
  result := TFhirResearchStudyArm(inherited Clone);
end;

function TFhirResearchStudyArm.equals(other : TObject) : boolean; 
var
  o : TFhirResearchStudyArm;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchStudyArm)) then
    result := false
  else
  begin
    o := TFhirResearchStudyArm(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true);
  end;
end;

function TFhirResearchStudyArm.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FType_) and isEmptyProp(FDescription);
end;

procedure TFhirResearchStudyArm.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('type');
  fields.add('description');
end;

{ TFhirResearchStudyArm }

Procedure TFhirResearchStudyArm.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirResearchStudyArm.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirResearchStudyArm.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirResearchStudyArm.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirResearchStudyArm.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirResearchStudyArm.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirResearchStudyArm.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirResearchStudyArm.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
end;

{ TFhirResearchStudyArmListEnumerator }

Constructor TFhirResearchStudyArmListEnumerator.Create(list : TFhirResearchStudyArmList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchStudyArmListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchStudyArmListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchStudyArmListEnumerator.GetCurrent : TFhirResearchStudyArm;
begin
  Result := FList[FIndex];
end;

function TFhirResearchStudyArmListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirResearchStudyArmList }
procedure TFhirResearchStudyArmList.AddItem(value: TFhirResearchStudyArm);
begin
  assert(value.ClassName = 'TFhirResearchStudyArm', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchStudyArm');
  add(value);
end;

function TFhirResearchStudyArmList.Append: TFhirResearchStudyArm;
begin
  result := TFhirResearchStudyArm.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyArmList.ClearItems;
begin
  Clear;
end;

function TFhirResearchStudyArmList.GetEnumerator : TFhirResearchStudyArmListEnumerator;
begin
  result := TFhirResearchStudyArmListEnumerator.Create(self.link);
end;

function TFhirResearchStudyArmList.Clone: TFhirResearchStudyArmList;
begin
  result := TFhirResearchStudyArmList(inherited Clone);
end;

function TFhirResearchStudyArmList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchStudyArmList.GetItemN(index: Integer): TFhirResearchStudyArm;
begin
  result := TFhirResearchStudyArm(ObjectByIndex[index]);
end;

function TFhirResearchStudyArmList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchStudyArm;
end;
function TFhirResearchStudyArmList.IndexOf(value: TFhirResearchStudyArm): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchStudyArmList.Insert(index: Integer): TFhirResearchStudyArm;
begin
  result := TFhirResearchStudyArm.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyArmList.InsertItem(index: Integer; value: TFhirResearchStudyArm);
begin
  assert(value is TFhirResearchStudyArm);
  Inherited Insert(index, value);
end;

function TFhirResearchStudyArmList.Item(index: Integer): TFhirResearchStudyArm;
begin
  result := TFhirResearchStudyArm(ObjectByIndex[index]);
end;

function TFhirResearchStudyArmList.Link: TFhirResearchStudyArmList;
begin
  result := TFhirResearchStudyArmList(inherited Link);
end;

procedure TFhirResearchStudyArmList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchStudyArmList.SetItemByIndex(index: Integer; value: TFhirResearchStudyArm);
begin
  assert(value is TFhirResearchStudyArm);
  FhirResearchStudyArms[index] := value;
end;

procedure TFhirResearchStudyArmList.SetItemN(index: Integer; value: TFhirResearchStudyArm);
begin
  assert(value is TFhirResearchStudyArm);
  ObjectByIndex[index] := value;
end;

{ TFhirResearchStudyObjective }

constructor TFhirResearchStudyObjective.Create;
begin
  inherited;
end;

destructor TFhirResearchStudyObjective.Destroy;
begin
  FName.free;
  FType_.free;
  inherited;
end;

procedure TFhirResearchStudyObjective.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirResearchStudyObjective(oSource).nameElement.Clone;
  type_ := TFhirResearchStudyObjective(oSource).type_.Clone;
end;

procedure TFhirResearchStudyObjective.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirResearchStudyObjective.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
end;

function TFhirResearchStudyObjective.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchStudyObjective.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirResearchStudyObjective.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchStudyObjective.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchStudyObjective.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchStudyObjective.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchStudyObjective.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchStudyObjective.fhirType : string;
begin
  result := 'objective';
end;

function TFhirResearchStudyObjective.Link : TFhirResearchStudyObjective;
begin
  result := TFhirResearchStudyObjective(inherited Link);
end;

function TFhirResearchStudyObjective.Clone : TFhirResearchStudyObjective;
begin
  result := TFhirResearchStudyObjective(inherited Clone);
end;

function TFhirResearchStudyObjective.equals(other : TObject) : boolean; 
var
  o : TFhirResearchStudyObjective;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchStudyObjective)) then
    result := false
  else
  begin
    o := TFhirResearchStudyObjective(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirResearchStudyObjective.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FType_);
end;

procedure TFhirResearchStudyObjective.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('type');
end;

{ TFhirResearchStudyObjective }

Procedure TFhirResearchStudyObjective.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirResearchStudyObjective.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirResearchStudyObjective.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirResearchStudyObjective.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirResearchStudyObjective.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FType_.sizeInBytes);
end;

{ TFhirResearchStudyObjectiveListEnumerator }

Constructor TFhirResearchStudyObjectiveListEnumerator.Create(list : TFhirResearchStudyObjectiveList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchStudyObjectiveListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchStudyObjectiveListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchStudyObjectiveListEnumerator.GetCurrent : TFhirResearchStudyObjective;
begin
  Result := FList[FIndex];
end;

function TFhirResearchStudyObjectiveListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirResearchStudyObjectiveList }
procedure TFhirResearchStudyObjectiveList.AddItem(value: TFhirResearchStudyObjective);
begin
  assert(value.ClassName = 'TFhirResearchStudyObjective', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchStudyObjective');
  add(value);
end;

function TFhirResearchStudyObjectiveList.Append: TFhirResearchStudyObjective;
begin
  result := TFhirResearchStudyObjective.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyObjectiveList.ClearItems;
begin
  Clear;
end;

function TFhirResearchStudyObjectiveList.GetEnumerator : TFhirResearchStudyObjectiveListEnumerator;
begin
  result := TFhirResearchStudyObjectiveListEnumerator.Create(self.link);
end;

function TFhirResearchStudyObjectiveList.Clone: TFhirResearchStudyObjectiveList;
begin
  result := TFhirResearchStudyObjectiveList(inherited Clone);
end;

function TFhirResearchStudyObjectiveList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchStudyObjectiveList.GetItemN(index: Integer): TFhirResearchStudyObjective;
begin
  result := TFhirResearchStudyObjective(ObjectByIndex[index]);
end;

function TFhirResearchStudyObjectiveList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchStudyObjective;
end;
function TFhirResearchStudyObjectiveList.IndexOf(value: TFhirResearchStudyObjective): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchStudyObjectiveList.Insert(index: Integer): TFhirResearchStudyObjective;
begin
  result := TFhirResearchStudyObjective.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyObjectiveList.InsertItem(index: Integer; value: TFhirResearchStudyObjective);
begin
  assert(value is TFhirResearchStudyObjective);
  Inherited Insert(index, value);
end;

function TFhirResearchStudyObjectiveList.Item(index: Integer): TFhirResearchStudyObjective;
begin
  result := TFhirResearchStudyObjective(ObjectByIndex[index]);
end;

function TFhirResearchStudyObjectiveList.Link: TFhirResearchStudyObjectiveList;
begin
  result := TFhirResearchStudyObjectiveList(inherited Link);
end;

procedure TFhirResearchStudyObjectiveList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchStudyObjectiveList.SetItemByIndex(index: Integer; value: TFhirResearchStudyObjective);
begin
  assert(value is TFhirResearchStudyObjective);
  FhirResearchStudyObjectives[index] := value;
end;

procedure TFhirResearchStudyObjectiveList.SetItemN(index: Integer; value: TFhirResearchStudyObjective);
begin
  assert(value is TFhirResearchStudyObjective);
  ObjectByIndex[index] := value;
end;

{ TFhirResearchStudy }

constructor TFhirResearchStudy.Create;
begin
  inherited;
end;

destructor TFhirResearchStudy.Destroy;
begin
  FIdentifierList.Free;
  FTitle.free;
  FProtocolList.Free;
  FPartOfList.Free;
  FStatus.free;
  FPrimaryPurposeType.free;
  FPhase.free;
  FCategoryList.Free;
  FFocusList.Free;
  FConditionList.Free;
  FContactList.Free;
  FRelatedArtifactList.Free;
  FKeywordList.Free;
  FLocationList.Free;
  FDescription.free;
  FEnrollmentList.Free;
  FPeriod.free;
  FSponsor.free;
  FPrincipalInvestigator.free;
  FSiteList.Free;
  FReasonStopped.free;
  FNoteList.Free;
  FArmList.Free;
  FObjectiveList.Free;
  inherited;
end;

function TFhirResearchStudy.GetResourceType : TFhirResourceType;
begin
  result := frtResearchStudy;
end;

procedure TFhirResearchStudy.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirResearchStudy(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirResearchStudy(oSource).FIdentifierList);
  end;
  titleElement := TFhirResearchStudy(oSource).titleElement.Clone;
  if (TFhirResearchStudy(oSource).FProtocolList = nil) then
  begin
    FProtocolList.free;
    FProtocolList := nil;
  end
  else
  begin
    if FProtocolList = nil then
      FProtocolList := TFhirReferenceList{TFhirPlanDefinition}.Create;
    FProtocolList.Assign(TFhirResearchStudy(oSource).FProtocolList);
  end;
  if (TFhirResearchStudy(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList{TFhirResearchStudy}.Create;
    FPartOfList.Assign(TFhirResearchStudy(oSource).FPartOfList);
  end;
  FStatus := TFhirResearchStudy(oSource).FStatus.Link;
  primaryPurposeType := TFhirResearchStudy(oSource).primaryPurposeType.Clone;
  phase := TFhirResearchStudy(oSource).phase.Clone;
  if (TFhirResearchStudy(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirResearchStudy(oSource).FCategoryList);
  end;
  if (TFhirResearchStudy(oSource).FFocusList = nil) then
  begin
    FFocusList.free;
    FFocusList := nil;
  end
  else
  begin
    if FFocusList = nil then
      FFocusList := TFhirCodeableConceptList.Create;
    FFocusList.Assign(TFhirResearchStudy(oSource).FFocusList);
  end;
  if (TFhirResearchStudy(oSource).FConditionList = nil) then
  begin
    FConditionList.free;
    FConditionList := nil;
  end
  else
  begin
    if FConditionList = nil then
      FConditionList := TFhirCodeableConceptList.Create;
    FConditionList.Assign(TFhirResearchStudy(oSource).FConditionList);
  end;
  if (TFhirResearchStudy(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirResearchStudy(oSource).FContactList);
  end;
  if (TFhirResearchStudy(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirResearchStudy(oSource).FRelatedArtifactList);
  end;
  if (TFhirResearchStudy(oSource).FKeywordList = nil) then
  begin
    FKeywordList.free;
    FKeywordList := nil;
  end
  else
  begin
    if FKeywordList = nil then
      FKeywordList := TFhirCodeableConceptList.Create;
    FKeywordList.Assign(TFhirResearchStudy(oSource).FKeywordList);
  end;
  if (TFhirResearchStudy(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirCodeableConceptList.Create;
    FLocationList.Assign(TFhirResearchStudy(oSource).FLocationList);
  end;
  descriptionElement := TFhirResearchStudy(oSource).descriptionElement.Clone;
  if (TFhirResearchStudy(oSource).FEnrollmentList = nil) then
  begin
    FEnrollmentList.free;
    FEnrollmentList := nil;
  end
  else
  begin
    if FEnrollmentList = nil then
      FEnrollmentList := TFhirReferenceList{TFhirGroup}.Create;
    FEnrollmentList.Assign(TFhirResearchStudy(oSource).FEnrollmentList);
  end;
  period := TFhirResearchStudy(oSource).period.Clone;
  sponsor := TFhirResearchStudy(oSource).sponsor.Clone;
  principalInvestigator := TFhirResearchStudy(oSource).principalInvestigator.Clone;
  if (TFhirResearchStudy(oSource).FSiteList = nil) then
  begin
    FSiteList.free;
    FSiteList := nil;
  end
  else
  begin
    if FSiteList = nil then
      FSiteList := TFhirReferenceList{TFhirLocation}.Create;
    FSiteList.Assign(TFhirResearchStudy(oSource).FSiteList);
  end;
  reasonStopped := TFhirResearchStudy(oSource).reasonStopped.Clone;
  if (TFhirResearchStudy(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirResearchStudy(oSource).FNoteList);
  end;
  if (TFhirResearchStudy(oSource).FArmList = nil) then
  begin
    FArmList.free;
    FArmList := nil;
  end
  else
  begin
    if FArmList = nil then
      FArmList := TFhirResearchStudyArmList.Create;
    FArmList.Assign(TFhirResearchStudy(oSource).FArmList);
  end;
  if (TFhirResearchStudy(oSource).FObjectiveList = nil) then
  begin
    FObjectiveList.free;
    FObjectiveList := nil;
  end
  else
  begin
    if FObjectiveList = nil then
      FObjectiveList := TFhirResearchStudyObjectiveList.Create;
    FObjectiveList.Assign(TFhirResearchStudy(oSource).FObjectiveList);
  end;
end;

procedure TFhirResearchStudy.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'protocol') Then
    list.addAll(self, 'protocol', FProtocolList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'primaryPurposeType') Then
     list.add(self.link, 'primaryPurposeType', FPrimaryPurposeType.Link);
  if (child_name = 'phase') Then
     list.add(self.link, 'phase', FPhase.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'focus') Then
    list.addAll(self, 'focus', FFocusList);
  if (child_name = 'condition') Then
    list.addAll(self, 'condition', FConditionList);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'keyword') Then
    list.addAll(self, 'keyword', FKeywordList);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'enrollment') Then
    list.addAll(self, 'enrollment', FEnrollmentList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'sponsor') Then
     list.add(self.link, 'sponsor', FSponsor.Link);
  if (child_name = 'principalInvestigator') Then
     list.add(self.link, 'principalInvestigator', FPrincipalInvestigator.Link);
  if (child_name = 'site') Then
    list.addAll(self, 'site', FSiteList);
  if (child_name = 'reasonStopped') Then
     list.add(self.link, 'reasonStopped', FReasonStopped.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'arm') Then
    list.addAll(self, 'arm', FArmList);
  if (child_name = 'objective') Then
    list.addAll(self, 'objective', FObjectiveList);
end;

procedure TFhirResearchStudy.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'protocol', 'Reference(PlanDefinition)', true, TFhirReference{TFhirPlanDefinition}, FProtocolList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference(ResearchStudy)', true, TFhirReference{TFhirResearchStudy}, FPartOfList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'primaryPurposeType', 'CodeableConcept', false, TFhirCodeableConcept, FPrimaryPurposeType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'phase', 'CodeableConcept', false, TFhirCodeableConcept, FPhase.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'focus', 'CodeableConcept', true, TFhirCodeableConcept, FFocusList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'condition', 'CodeableConcept', true, TFhirCodeableConcept, FConditionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'keyword', 'CodeableConcept', true, TFhirCodeableConcept, FKeywordList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'location', 'CodeableConcept', true, TFhirCodeableConcept, FLocationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'enrollment', 'Reference(Group)', true, TFhirReference{TFhirGroup}, FEnrollmentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sponsor', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FSponsor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'principalInvestigator', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FPrincipalInvestigator.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site', 'Reference(Location)', true, TFhirReference{TFhirLocation}, FSiteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonStopped', 'CodeableConcept', false, TFhirCodeableConcept, FReasonStopped.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'arm', '', true, TFhirResearchStudyArm, FArmList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'objective', '', true, TFhirResearchStudyObjective, FObjectiveList.Link)){3};
end;

function TFhirResearchStudy.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'protocol') then
  begin
    ProtocolList.add(propValue as TFhirReference{TFhirPlanDefinition}){2a};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference{TFhirResearchStudy}){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirResearchStudyStatusEnum, CODES_TFhirResearchStudyStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'primaryPurposeType') then
  begin
    PrimaryPurposeType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'phase') then
  begin
    Phase := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    FocusList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact){2a};
    result := propValue;
  end
  else if (propName = 'keyword') then
  begin
    KeywordList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'enrollment') then
  begin
    EnrollmentList.add(propValue as TFhirReference{TFhirGroup}){2a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'sponsor') then
  begin
    Sponsor := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'principalInvestigator') then
  begin
    PrincipalInvestigator := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'site') then
  begin
    SiteList.add(propValue as TFhirReference{TFhirLocation}){2a};
    result := propValue;
  end
  else if (propName = 'reasonStopped') then
  begin
    ReasonStopped := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'arm') then
  begin
    ArmList.add(propValue as TFhirResearchStudyArm){2a};
    result := propValue;
  end
  else if (propName = 'objective') then
  begin
    ObjectiveList.add(propValue as TFhirResearchStudyObjective){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirResearchStudy.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'protocol') then ProtocolList.insertItem(index, propValue as TFhirReference{TFhirPlanDefinition}){2a}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference{TFhirResearchStudy}){2a}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'focus') then FocusList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'condition') then ConditionList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact){2a}
  else if (propName = 'keyword') then KeywordList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'location') then LocationList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'enrollment') then EnrollmentList.insertItem(index, propValue as TFhirReference{TFhirGroup}){2a}
  else if (propName = 'site') then SiteList.insertItem(index, propValue as TFhirReference{TFhirLocation}){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'arm') then ArmList.insertItem(index, propValue as TFhirResearchStudyArm){2a}
  else if (propName = 'objective') then ObjectiveList.insertItem(index, propValue as TFhirResearchStudyObjective){2a}
  else inherited;
end;

function TFhirResearchStudy.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'title') then result := TFhirString.create() {5b}
  else if (propName = 'protocol') then result := ProtocolList.new(){2}
  else if (propName = 'partOf') then result := PartOfList.new(){2}
  else if (propName = 'primaryPurposeType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'phase') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := CategoryList.new(){2}
  else if (propName = 'focus') then result := FocusList.new(){2}
  else if (propName = 'condition') then result := ConditionList.new(){2}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new(){2}
  else if (propName = 'keyword') then result := KeywordList.new(){2}
  else if (propName = 'location') then result := LocationList.new(){2}
  else if (propName = 'description') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'enrollment') then result := EnrollmentList.new(){2}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'sponsor') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'principalInvestigator') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'site') then result := SiteList.new(){2}
  else if (propName = 'reasonStopped') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'arm') then result := ArmList.new(){2}
  else if (propName = 'objective') then result := ObjectiveList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchStudy.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'protocol') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'primaryPurposeType') then result := 'CodeableConcept'
  else if (propName = 'phase') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'focus') then result := 'CodeableConcept'
  else if (propName = 'condition') then result := 'CodeableConcept'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'keyword') then result := 'CodeableConcept'
  else if (propName = 'location') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'enrollment') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'sponsor') then result := 'Reference'
  else if (propName = 'principalInvestigator') then result := 'Reference'
  else if (propName = 'site') then result := 'Reference'
  else if (propName = 'reasonStopped') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'arm') then result := ''
  else if (propName = 'objective') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchStudy.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'protocol') then deletePropertyValue('protocol', ProtocolList, value) {2}
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'primaryPurposeType') then PrimaryPurposeTypeElement := nil
  else if (propName = 'phase') then PhaseElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {2}
  else if (propName = 'focus') then deletePropertyValue('focus', FocusList, value) {2}
  else if (propName = 'condition') then deletePropertyValue('condition', ConditionList, value) {2}
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value) {2}
  else if (propName = 'keyword') then deletePropertyValue('keyword', KeywordList, value) {2}
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value) {2}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'enrollment') then deletePropertyValue('enrollment', EnrollmentList, value) {2}
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'sponsor') then SponsorElement := nil
  else if (propName = 'principalInvestigator') then PrincipalInvestigatorElement := nil
  else if (propName = 'site') then deletePropertyValue('site', SiteList, value) {2}
  else if (propName = 'reasonStopped') then ReasonStoppedElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'arm') then deletePropertyValue('arm', ArmList, value) {2}
  else if (propName = 'objective') then deletePropertyValue('objective', ObjectiveList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchStudy.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'title') then TitleElement := asString(new){5b}
  else if (propName = 'protocol') then replacePropertyValue('protocol', ProtocolList, existing, new) {2}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirResearchStudyStatusEnum, CODES_TFhirResearchStudyStatusEnum, new){4}
  else if (propName = 'primaryPurposeType') then PrimaryPurposeTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'phase') then PhaseElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {2}
  else if (propName = 'focus') then replacePropertyValue('focus', FocusList, existing, new) {2}
  else if (propName = 'condition') then replacePropertyValue('condition', ConditionList, existing, new) {2}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new) {2}
  else if (propName = 'keyword') then replacePropertyValue('keyword', KeywordList, existing, new) {2}
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new) {2}
  else if (propName = 'description') then DescriptionElement := asMarkdown(new){5b}
  else if (propName = 'enrollment') then replacePropertyValue('enrollment', EnrollmentList, existing, new) {2}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'sponsor') then SponsorElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'principalInvestigator') then PrincipalInvestigatorElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'site') then replacePropertyValue('site', SiteList, existing, new) {2}
  else if (propName = 'reasonStopped') then ReasonStoppedElement := new as TFhirCodeableConcept{4}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'arm') then replacePropertyValue('arm', ArmList, existing, new) {2}
  else if (propName = 'objective') then replacePropertyValue('objective', ObjectiveList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchStudy.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'protocol') then ProtocolList.move(source, destination){2a}
  else if (propName = 'partOf') then PartOfList.move(source, destination){2a}
  else if (propName = 'category') then CategoryList.move(source, destination){2a}
  else if (propName = 'focus') then FocusList.move(source, destination){2a}
  else if (propName = 'condition') then ConditionList.move(source, destination){2a}
  else if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination){2a}
  else if (propName = 'keyword') then KeywordList.move(source, destination){2a}
  else if (propName = 'location') then LocationList.move(source, destination){2a}
  else if (propName = 'enrollment') then EnrollmentList.move(source, destination){2a}
  else if (propName = 'site') then SiteList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'arm') then ArmList.move(source, destination){2a}
  else if (propName = 'objective') then ObjectiveList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchStudy.fhirType : string;
begin
  result := 'ResearchStudy';
end;

function TFhirResearchStudy.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FTitle) and isEmptyProp(FprotocolList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FPrimaryPurposeType) and isEmptyProp(FPhase) and isEmptyProp(FcategoryList) and isEmptyProp(FfocusList) and isEmptyProp(FconditionList) and isEmptyProp(FcontactList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(FkeywordList) and isEmptyProp(FlocationList) and isEmptyProp(FDescription) and isEmptyProp(FenrollmentList) and isEmptyProp(FPeriod) and isEmptyProp(FSponsor) and isEmptyProp(FPrincipalInvestigator) and isEmptyProp(FsiteList) and isEmptyProp(FReasonStopped) and isEmptyProp(FnoteList) and isEmptyProp(FarmList) and isEmptyProp(FobjectiveList);
end;

function TFhirResearchStudy.equals(other : TObject) : boolean; 
var
  o : TFhirResearchStudy;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchStudy)) then
    result := false
  else
  begin
    o := TFhirResearchStudy(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(titleElement, o.titleElement, true) and 
      compareDeep(protocolList, o.protocolList, true) and compareDeep(partOfList, o.partOfList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(primaryPurposeTypeElement, o.primaryPurposeTypeElement, true) and 
      compareDeep(phaseElement, o.phaseElement, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(focusList, o.focusList, true) and compareDeep(conditionList, o.conditionList, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(relatedArtifactList, o.relatedArtifactList, true) and 
      compareDeep(keywordList, o.keywordList, true) and compareDeep(locationList, o.locationList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(enrollmentList, o.enrollmentList, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(sponsorElement, o.sponsorElement, true) and 
      compareDeep(principalInvestigatorElement, o.principalInvestigatorElement, true) and 
      compareDeep(siteList, o.siteList, true) and compareDeep(reasonStoppedElement, o.reasonStoppedElement, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(armList, o.armList, true) and 
      compareDeep(objectiveList, o.objectiveList, true);
  end;
end;

function TFhirResearchStudy.Link : TFhirResearchStudy;
begin
  result := TFhirResearchStudy(inherited Link);
end;

function TFhirResearchStudy.Clone : TFhirResearchStudy;
begin
  result := TFhirResearchStudy(inherited Clone);
end;

procedure TFhirResearchStudy.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('title');
  fields.add('protocol');
  fields.add('partOf');
  fields.add('status');
  fields.add('primaryPurposeType');
  fields.add('phase');
  fields.add('category');
  fields.add('focus');
  fields.add('condition');
  fields.add('contact');
  fields.add('relatedArtifact');
  fields.add('keyword');
  fields.add('location');
  fields.add('description');
  fields.add('enrollment');
  fields.add('period');
  fields.add('sponsor');
  fields.add('principalInvestigator');
  fields.add('site');
  fields.add('reasonStopped');
  fields.add('note');
  fields.add('arm');
  fields.add('objective');
end;

{ TFhirResearchStudy }

Function TFhirResearchStudy.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirResearchStudy.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirResearchStudy.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirResearchStudy.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirResearchStudy.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Function TFhirResearchStudy.GetProtocolList : TFhirReferenceList{TFhirPlanDefinition};
begin
  if FProtocolList = nil then
    FProtocolList := TFhirReferenceList{TFhirPlanDefinition}.Create;
  result := FProtocolList;
end;

Function TFhirResearchStudy.GetHasProtocolList : boolean;
begin
  result := (FProtocolList <> nil) and (FProtocolList.count > 0);
end;

Function TFhirResearchStudy.GetPartOfList : TFhirReferenceList{TFhirResearchStudy};
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList{TFhirResearchStudy}.Create;
  result := FPartOfList;
end;

Function TFhirResearchStudy.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

Procedure TFhirResearchStudy.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirResearchStudy.GetStatusST : TFhirResearchStudyStatusEnum;
begin
  if FStatus = nil then
    result := TFhirResearchStudyStatusEnum(0)
  else
    result := TFhirResearchStudyStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirResearchStudyStatusEnum, FStatus.value));
end;

Procedure TFhirResearchStudy.SetStatusST(value : TFhirResearchStudyStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirResearchStudyStatusEnum[value], CODES_TFhirResearchStudyStatusEnum[value]);
end;

Procedure TFhirResearchStudy.SetPrimaryPurposeType(value : TFhirCodeableConcept);
begin
  FPrimaryPurposeType.free;
  FPrimaryPurposeType := value;
end;

Procedure TFhirResearchStudy.SetPhase(value : TFhirCodeableConcept);
begin
  FPhase.free;
  FPhase := value;
end;

Function TFhirResearchStudy.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

Function TFhirResearchStudy.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

Function TFhirResearchStudy.GetFocusList : TFhirCodeableConceptList;
begin
  if FFocusList = nil then
    FFocusList := TFhirCodeableConceptList.Create;
  result := FFocusList;
end;

Function TFhirResearchStudy.GetHasFocusList : boolean;
begin
  result := (FFocusList <> nil) and (FFocusList.count > 0);
end;

Function TFhirResearchStudy.GetConditionList : TFhirCodeableConceptList;
begin
  if FConditionList = nil then
    FConditionList := TFhirCodeableConceptList.Create;
  result := FConditionList;
end;

Function TFhirResearchStudy.GetHasConditionList : boolean;
begin
  result := (FConditionList <> nil) and (FConditionList.count > 0);
end;

Function TFhirResearchStudy.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

Function TFhirResearchStudy.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Function TFhirResearchStudy.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

Function TFhirResearchStudy.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

Function TFhirResearchStudy.GetKeywordList : TFhirCodeableConceptList;
begin
  if FKeywordList = nil then
    FKeywordList := TFhirCodeableConceptList.Create;
  result := FKeywordList;
end;

Function TFhirResearchStudy.GetHasKeywordList : boolean;
begin
  result := (FKeywordList <> nil) and (FKeywordList.count > 0);
end;

Function TFhirResearchStudy.GetLocationList : TFhirCodeableConceptList;
begin
  if FLocationList = nil then
    FLocationList := TFhirCodeableConceptList.Create;
  result := FLocationList;
end;

Function TFhirResearchStudy.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

Procedure TFhirResearchStudy.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirResearchStudy.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirResearchStudy.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirResearchStudy.GetEnrollmentList : TFhirReferenceList{TFhirGroup};
begin
  if FEnrollmentList = nil then
    FEnrollmentList := TFhirReferenceList{TFhirGroup}.Create;
  result := FEnrollmentList;
end;

Function TFhirResearchStudy.GetHasEnrollmentList : boolean;
begin
  result := (FEnrollmentList <> nil) and (FEnrollmentList.count > 0);
end;

Procedure TFhirResearchStudy.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirResearchStudy.SetSponsor(value : TFhirReference{TFhirOrganization});
begin
  FSponsor.free;
  FSponsor := value;
end;

Procedure TFhirResearchStudy.SetPrincipalInvestigator(value : TFhirReference{TFhirPractitioner});
begin
  FPrincipalInvestigator.free;
  FPrincipalInvestigator := value;
end;

Function TFhirResearchStudy.GetSiteList : TFhirReferenceList{TFhirLocation};
begin
  if FSiteList = nil then
    FSiteList := TFhirReferenceList{TFhirLocation}.Create;
  result := FSiteList;
end;

Function TFhirResearchStudy.GetHasSiteList : boolean;
begin
  result := (FSiteList <> nil) and (FSiteList.count > 0);
end;

Procedure TFhirResearchStudy.SetReasonStopped(value : TFhirCodeableConcept);
begin
  FReasonStopped.free;
  FReasonStopped := value;
end;

Function TFhirResearchStudy.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirResearchStudy.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirResearchStudy.GetArmList : TFhirResearchStudyArmList;
begin
  if FArmList = nil then
    FArmList := TFhirResearchStudyArmList.Create;
  result := FArmList;
end;

Function TFhirResearchStudy.GetHasArmList : boolean;
begin
  result := (FArmList <> nil) and (FArmList.count > 0);
end;

Function TFhirResearchStudy.GetObjectiveList : TFhirResearchStudyObjectiveList;
begin
  if FObjectiveList = nil then
    FObjectiveList := TFhirResearchStudyObjectiveList.Create;
  result := FObjectiveList;
end;

Function TFhirResearchStudy.GetHasObjectiveList : boolean;
begin
  result := (FObjectiveList <> nil) and (FObjectiveList.count > 0);
end;

function TFhirResearchStudy.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
  inc(result, FprotocolList.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPrimaryPurposeType.sizeInBytes);
  inc(result, FPhase.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FfocusList.sizeInBytes);
  inc(result, FconditionList.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FrelatedArtifactList.sizeInBytes);
  inc(result, FkeywordList.sizeInBytes);
  inc(result, FlocationList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FenrollmentList.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FSponsor.sizeInBytes);
  inc(result, FPrincipalInvestigator.sizeInBytes);
  inc(result, FsiteList.sizeInBytes);
  inc(result, FReasonStopped.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FarmList.sizeInBytes);
  inc(result, FobjectiveList.sizeInBytes);
end;

{ TFhirResearchStudyListEnumerator }

Constructor TFhirResearchStudyListEnumerator.Create(list : TFhirResearchStudyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchStudyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchStudyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchStudyListEnumerator.GetCurrent : TFhirResearchStudy;
begin
  Result := FList[FIndex];
end;

function TFhirResearchStudyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirResearchStudyList }
procedure TFhirResearchStudyList.AddItem(value: TFhirResearchStudy);
begin
  assert(value.ClassName = 'TFhirResearchStudy', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchStudy');
  add(value);
end;

function TFhirResearchStudyList.Append: TFhirResearchStudy;
begin
  result := TFhirResearchStudy.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyList.ClearItems;
begin
  Clear;
end;

function TFhirResearchStudyList.GetEnumerator : TFhirResearchStudyListEnumerator;
begin
  result := TFhirResearchStudyListEnumerator.Create(self.link);
end;

function TFhirResearchStudyList.Clone: TFhirResearchStudyList;
begin
  result := TFhirResearchStudyList(inherited Clone);
end;

function TFhirResearchStudyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchStudyList.GetItemN(index: Integer): TFhirResearchStudy;
begin
  result := TFhirResearchStudy(ObjectByIndex[index]);
end;

function TFhirResearchStudyList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchStudy;
end;
function TFhirResearchStudyList.IndexOf(value: TFhirResearchStudy): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchStudyList.Insert(index: Integer): TFhirResearchStudy;
begin
  result := TFhirResearchStudy.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyList.InsertItem(index: Integer; value: TFhirResearchStudy);
begin
  assert(value is TFhirResearchStudy);
  Inherited Insert(index, value);
end;

function TFhirResearchStudyList.Item(index: Integer): TFhirResearchStudy;
begin
  result := TFhirResearchStudy(ObjectByIndex[index]);
end;

function TFhirResearchStudyList.Link: TFhirResearchStudyList;
begin
  result := TFhirResearchStudyList(inherited Link);
end;

procedure TFhirResearchStudyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchStudyList.SetItemByIndex(index: Integer; value: TFhirResearchStudy);
begin
  assert(value is TFhirResearchStudy);
  FhirResearchStudies[index] := value;
end;

procedure TFhirResearchStudyList.SetItemN(index: Integer; value: TFhirResearchStudy);
begin
  assert(value is TFhirResearchStudy);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RESEARCHSTUDY}

{$IFDEF FHIR_RESEARCHSUBJECT}

{ TFhirResearchSubject }

constructor TFhirResearchSubject.Create;
begin
  inherited;
end;

destructor TFhirResearchSubject.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FPeriod.free;
  FStudy.free;
  FIndividual.free;
  FAssignedArm.free;
  FActualArm.free;
  FConsent.free;
  inherited;
end;

function TFhirResearchSubject.GetResourceType : TFhirResourceType;
begin
  result := frtResearchSubject;
end;

procedure TFhirResearchSubject.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirResearchSubject(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirResearchSubject(oSource).FIdentifierList);
  end;
  FStatus := TFhirResearchSubject(oSource).FStatus.Link;
  period := TFhirResearchSubject(oSource).period.Clone;
  study := TFhirResearchSubject(oSource).study.Clone;
  individual := TFhirResearchSubject(oSource).individual.Clone;
  assignedArmElement := TFhirResearchSubject(oSource).assignedArmElement.Clone;
  actualArmElement := TFhirResearchSubject(oSource).actualArmElement.Clone;
  consent := TFhirResearchSubject(oSource).consent.Clone;
end;

procedure TFhirResearchSubject.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'study') Then
     list.add(self.link, 'study', FStudy.Link);
  if (child_name = 'individual') Then
     list.add(self.link, 'individual', FIndividual.Link);
  if (child_name = 'assignedArm') Then
     list.add(self.link, 'assignedArm', FAssignedArm.Link);
  if (child_name = 'actualArm') Then
     list.add(self.link, 'actualArm', FActualArm.Link);
  if (child_name = 'consent') Then
     list.add(self.link, 'consent', FConsent.Link);
end;

procedure TFhirResearchSubject.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'study', 'Reference(ResearchStudy)', false, TFhirReference{TFhirResearchStudy}, FStudy.Link));{2}
  oList.add(TFHIRProperty.create(self, 'individual', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FIndividual.Link));{2}
  oList.add(TFHIRProperty.create(self, 'assignedArm', 'string', false, TFhirString, FAssignedArm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'actualArm', 'string', false, TFhirString, FActualArm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'consent', 'Reference(Consent)', false, TFhirReference{TFhirConsent}, FConsent.Link));{2}
end;

function TFhirResearchSubject.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirResearchSubjectStatusEnum, CODES_TFhirResearchSubjectStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'study') then
  begin
    Study := propValue as TFhirReference{TFhirResearchStudy}{4b};
    result := propValue;
  end
  else if (propName = 'individual') then
  begin
    Individual := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'assignedArm') then
  begin
    AssignedArmElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'actualArm') then
  begin
    ActualArmElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'consent') then
  begin
    Consent := propValue as TFhirReference{TFhirConsent}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirResearchSubject.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirResearchSubject.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'study') then result := TFhirReference{TFhirResearchStudy}.create(){4b}
  else if (propName = 'individual') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'assignedArm') then result := TFhirString.create() {5b}
  else if (propName = 'actualArm') then result := TFhirString.create() {5b}
  else if (propName = 'consent') then result := TFhirReference{TFhirConsent}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchSubject.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'study') then result := 'Reference'
  else if (propName = 'individual') then result := 'Reference'
  else if (propName = 'assignedArm') then result := 'string'
  else if (propName = 'actualArm') then result := 'string'
  else if (propName = 'consent') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchSubject.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'study') then StudyElement := nil
  else if (propName = 'individual') then IndividualElement := nil
  else if (propName = 'assignedArm') then AssignedArmElement := nil
  else if (propName = 'actualArm') then ActualArmElement := nil
  else if (propName = 'consent') then ConsentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchSubject.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirResearchSubjectStatusEnum, CODES_TFhirResearchSubjectStatusEnum, new){4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'study') then StudyElement := new as TFhirReference{TFhirResearchStudy}{4}
  else if (propName = 'individual') then IndividualElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'assignedArm') then AssignedArmElement := asString(new){5b}
  else if (propName = 'actualArm') then ActualArmElement := asString(new){5b}
  else if (propName = 'consent') then ConsentElement := new as TFhirReference{TFhirConsent}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchSubject.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchSubject.fhirType : string;
begin
  result := 'ResearchSubject';
end;

function TFhirResearchSubject.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FPeriod) and isEmptyProp(FStudy) and isEmptyProp(FIndividual) and isEmptyProp(FAssignedArm) and isEmptyProp(FActualArm) and isEmptyProp(FConsent);
end;

function TFhirResearchSubject.equals(other : TObject) : boolean; 
var
  o : TFhirResearchSubject;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchSubject)) then
    result := false
  else
  begin
    o := TFhirResearchSubject(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(studyElement, o.studyElement, true) and 
      compareDeep(individualElement, o.individualElement, true) and compareDeep(assignedArmElement, o.assignedArmElement, true) and 
      compareDeep(actualArmElement, o.actualArmElement, true) and compareDeep(consentElement, o.consentElement, true);
  end;
end;

function TFhirResearchSubject.Link : TFhirResearchSubject;
begin
  result := TFhirResearchSubject(inherited Link);
end;

function TFhirResearchSubject.Clone : TFhirResearchSubject;
begin
  result := TFhirResearchSubject(inherited Clone);
end;

procedure TFhirResearchSubject.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('period');
  fields.add('study');
  fields.add('individual');
  fields.add('assignedArm');
  fields.add('actualArm');
  fields.add('consent');
end;

{ TFhirResearchSubject }

Function TFhirResearchSubject.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirResearchSubject.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirResearchSubject.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirResearchSubject.GetStatusST : TFhirResearchSubjectStatusEnum;
begin
  if FStatus = nil then
    result := TFhirResearchSubjectStatusEnum(0)
  else
    result := TFhirResearchSubjectStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirResearchSubjectStatusEnum, FStatus.value));
end;

Procedure TFhirResearchSubject.SetStatusST(value : TFhirResearchSubjectStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirResearchSubjectStatusEnum[value], CODES_TFhirResearchSubjectStatusEnum[value]);
end;

Procedure TFhirResearchSubject.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirResearchSubject.SetStudy(value : TFhirReference{TFhirResearchStudy});
begin
  FStudy.free;
  FStudy := value;
end;

Procedure TFhirResearchSubject.SetIndividual(value : TFhirReference{TFhirPatient});
begin
  FIndividual.free;
  FIndividual := value;
end;

Procedure TFhirResearchSubject.SetAssignedArm(value : TFhirString);
begin
  FAssignedArm.free;
  FAssignedArm := value;
end;

Function TFhirResearchSubject.GetAssignedArmST : String;
begin
  if FAssignedArm = nil then
    result := ''
  else
    result := FAssignedArm.value;
end;

Procedure TFhirResearchSubject.SetAssignedArmST(value : String);
begin
  if value <> '' then
  begin
    if FAssignedArm = nil then
      FAssignedArm := TFhirString.create;
    FAssignedArm.value := value
  end
  else if FAssignedArm <> nil then
    FAssignedArm.value := '';
end;

Procedure TFhirResearchSubject.SetActualArm(value : TFhirString);
begin
  FActualArm.free;
  FActualArm := value;
end;

Function TFhirResearchSubject.GetActualArmST : String;
begin
  if FActualArm = nil then
    result := ''
  else
    result := FActualArm.value;
end;

Procedure TFhirResearchSubject.SetActualArmST(value : String);
begin
  if value <> '' then
  begin
    if FActualArm = nil then
      FActualArm := TFhirString.create;
    FActualArm.value := value
  end
  else if FActualArm <> nil then
    FActualArm.value := '';
end;

Procedure TFhirResearchSubject.SetConsent(value : TFhirReference{TFhirConsent});
begin
  FConsent.free;
  FConsent := value;
end;

function TFhirResearchSubject.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FStudy.sizeInBytes);
  inc(result, FIndividual.sizeInBytes);
  inc(result, FAssignedArm.sizeInBytes);
  inc(result, FActualArm.sizeInBytes);
  inc(result, FConsent.sizeInBytes);
end;

{ TFhirResearchSubjectListEnumerator }

Constructor TFhirResearchSubjectListEnumerator.Create(list : TFhirResearchSubjectList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchSubjectListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchSubjectListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchSubjectListEnumerator.GetCurrent : TFhirResearchSubject;
begin
  Result := FList[FIndex];
end;

function TFhirResearchSubjectListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirResearchSubjectList }
procedure TFhirResearchSubjectList.AddItem(value: TFhirResearchSubject);
begin
  assert(value.ClassName = 'TFhirResearchSubject', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchSubject');
  add(value);
end;

function TFhirResearchSubjectList.Append: TFhirResearchSubject;
begin
  result := TFhirResearchSubject.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchSubjectList.ClearItems;
begin
  Clear;
end;

function TFhirResearchSubjectList.GetEnumerator : TFhirResearchSubjectListEnumerator;
begin
  result := TFhirResearchSubjectListEnumerator.Create(self.link);
end;

function TFhirResearchSubjectList.Clone: TFhirResearchSubjectList;
begin
  result := TFhirResearchSubjectList(inherited Clone);
end;

function TFhirResearchSubjectList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchSubjectList.GetItemN(index: Integer): TFhirResearchSubject;
begin
  result := TFhirResearchSubject(ObjectByIndex[index]);
end;

function TFhirResearchSubjectList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchSubject;
end;
function TFhirResearchSubjectList.IndexOf(value: TFhirResearchSubject): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchSubjectList.Insert(index: Integer): TFhirResearchSubject;
begin
  result := TFhirResearchSubject.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchSubjectList.InsertItem(index: Integer; value: TFhirResearchSubject);
begin
  assert(value is TFhirResearchSubject);
  Inherited Insert(index, value);
end;

function TFhirResearchSubjectList.Item(index: Integer): TFhirResearchSubject;
begin
  result := TFhirResearchSubject(ObjectByIndex[index]);
end;

function TFhirResearchSubjectList.Link: TFhirResearchSubjectList;
begin
  result := TFhirResearchSubjectList(inherited Link);
end;

procedure TFhirResearchSubjectList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchSubjectList.SetItemByIndex(index: Integer; value: TFhirResearchSubject);
begin
  assert(value is TFhirResearchSubject);
  FhirResearchSubjects[index] := value;
end;

procedure TFhirResearchSubjectList.SetItemN(index: Integer; value: TFhirResearchSubject);
begin
  assert(value is TFhirResearchSubject);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RESEARCHSUBJECT}

{$IFDEF FHIR_RISKEVIDENCESYNTHESIS}

{ TFhirRiskEvidenceSynthesisSampleSize }

constructor TFhirRiskEvidenceSynthesisSampleSize.Create;
begin
  inherited;
end;

destructor TFhirRiskEvidenceSynthesisSampleSize.Destroy;
begin
  FDescription.free;
  FNumberOfStudies.free;
  FNumberOfParticipants.free;
  inherited;
end;

procedure TFhirRiskEvidenceSynthesisSampleSize.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirRiskEvidenceSynthesisSampleSize(oSource).descriptionElement.Clone;
  numberOfStudiesElement := TFhirRiskEvidenceSynthesisSampleSize(oSource).numberOfStudiesElement.Clone;
  numberOfParticipantsElement := TFhirRiskEvidenceSynthesisSampleSize(oSource).numberOfParticipantsElement.Clone;
end;

procedure TFhirRiskEvidenceSynthesisSampleSize.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'numberOfStudies') Then
     list.add(self.link, 'numberOfStudies', FNumberOfStudies.Link);
  if (child_name = 'numberOfParticipants') Then
     list.add(self.link, 'numberOfParticipants', FNumberOfParticipants.Link);
end;

procedure TFhirRiskEvidenceSynthesisSampleSize.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'numberOfStudies', 'integer', false, TFhirInteger, FNumberOfStudies.Link));{2}
  oList.add(TFHIRProperty.create(self, 'numberOfParticipants', 'integer', false, TFhirInteger, FNumberOfParticipants.Link));{2}
end;

function TFhirRiskEvidenceSynthesisSampleSize.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'numberOfStudies') then
  begin
    NumberOfStudiesElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'numberOfParticipants') then
  begin
    NumberOfParticipantsElement := asInteger(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRiskEvidenceSynthesisSampleSize.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRiskEvidenceSynthesisSampleSize.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'numberOfStudies') then result := TFhirInteger.create() {5b}
  else if (propName = 'numberOfParticipants') then result := TFhirInteger.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRiskEvidenceSynthesisSampleSize.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'numberOfStudies') then result := 'integer'
  else if (propName = 'numberOfParticipants') then result := 'integer'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRiskEvidenceSynthesisSampleSize.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'numberOfStudies') then NumberOfStudiesElement := nil
  else if (propName = 'numberOfParticipants') then NumberOfParticipantsElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRiskEvidenceSynthesisSampleSize.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'numberOfStudies') then NumberOfStudiesElement := asInteger(new){5b}
  else if (propName = 'numberOfParticipants') then NumberOfParticipantsElement := asInteger(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRiskEvidenceSynthesisSampleSize.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRiskEvidenceSynthesisSampleSize.fhirType : string;
begin
  result := 'sampleSize';
end;

function TFhirRiskEvidenceSynthesisSampleSize.Link : TFhirRiskEvidenceSynthesisSampleSize;
begin
  result := TFhirRiskEvidenceSynthesisSampleSize(inherited Link);
end;

function TFhirRiskEvidenceSynthesisSampleSize.Clone : TFhirRiskEvidenceSynthesisSampleSize;
begin
  result := TFhirRiskEvidenceSynthesisSampleSize(inherited Clone);
end;

function TFhirRiskEvidenceSynthesisSampleSize.equals(other : TObject) : boolean; 
var
  o : TFhirRiskEvidenceSynthesisSampleSize;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRiskEvidenceSynthesisSampleSize)) then
    result := false
  else
  begin
    o := TFhirRiskEvidenceSynthesisSampleSize(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(numberOfStudiesElement, o.numberOfStudiesElement, true) and 
      compareDeep(numberOfParticipantsElement, o.numberOfParticipantsElement, true);
  end;
end;

function TFhirRiskEvidenceSynthesisSampleSize.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FNumberOfStudies) and isEmptyProp(FNumberOfParticipants);
end;

procedure TFhirRiskEvidenceSynthesisSampleSize.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('numberOfStudies');
  fields.add('numberOfParticipants');
end;

{ TFhirRiskEvidenceSynthesisSampleSize }

Procedure TFhirRiskEvidenceSynthesisSampleSize.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirRiskEvidenceSynthesisSampleSize.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirRiskEvidenceSynthesisSampleSize.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirRiskEvidenceSynthesisSampleSize.SetNumberOfStudies(value : TFhirInteger);
begin
  FNumberOfStudies.free;
  FNumberOfStudies := value;
end;

Function TFhirRiskEvidenceSynthesisSampleSize.GetNumberOfStudiesST : String;
begin
  if FNumberOfStudies = nil then
    result := ''
  else
    result := FNumberOfStudies.value;
end;

Procedure TFhirRiskEvidenceSynthesisSampleSize.SetNumberOfStudiesST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfStudies = nil then
      FNumberOfStudies := TFhirInteger.create;
    FNumberOfStudies.value := value
  end
  else if FNumberOfStudies <> nil then
    FNumberOfStudies.value := '';
end;

Procedure TFhirRiskEvidenceSynthesisSampleSize.SetNumberOfParticipants(value : TFhirInteger);
begin
  FNumberOfParticipants.free;
  FNumberOfParticipants := value;
end;

Function TFhirRiskEvidenceSynthesisSampleSize.GetNumberOfParticipantsST : String;
begin
  if FNumberOfParticipants = nil then
    result := ''
  else
    result := FNumberOfParticipants.value;
end;

Procedure TFhirRiskEvidenceSynthesisSampleSize.SetNumberOfParticipantsST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfParticipants = nil then
      FNumberOfParticipants := TFhirInteger.create;
    FNumberOfParticipants.value := value
  end
  else if FNumberOfParticipants <> nil then
    FNumberOfParticipants.value := '';
end;

function TFhirRiskEvidenceSynthesisSampleSize.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDescription.sizeInBytes);
  inc(result, FNumberOfStudies.sizeInBytes);
  inc(result, FNumberOfParticipants.sizeInBytes);
end;

{ TFhirRiskEvidenceSynthesisSampleSizeListEnumerator }

Constructor TFhirRiskEvidenceSynthesisSampleSizeListEnumerator.Create(list : TFhirRiskEvidenceSynthesisSampleSizeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRiskEvidenceSynthesisSampleSizeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRiskEvidenceSynthesisSampleSizeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRiskEvidenceSynthesisSampleSizeListEnumerator.GetCurrent : TFhirRiskEvidenceSynthesisSampleSize;
begin
  Result := FList[FIndex];
end;

function TFhirRiskEvidenceSynthesisSampleSizeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRiskEvidenceSynthesisSampleSizeList }
procedure TFhirRiskEvidenceSynthesisSampleSizeList.AddItem(value: TFhirRiskEvidenceSynthesisSampleSize);
begin
  assert(value.ClassName = 'TFhirRiskEvidenceSynthesisSampleSize', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRiskEvidenceSynthesisSampleSize');
  add(value);
end;

function TFhirRiskEvidenceSynthesisSampleSizeList.Append: TFhirRiskEvidenceSynthesisSampleSize;
begin
  result := TFhirRiskEvidenceSynthesisSampleSize.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskEvidenceSynthesisSampleSizeList.ClearItems;
begin
  Clear;
end;

function TFhirRiskEvidenceSynthesisSampleSizeList.GetEnumerator : TFhirRiskEvidenceSynthesisSampleSizeListEnumerator;
begin
  result := TFhirRiskEvidenceSynthesisSampleSizeListEnumerator.Create(self.link);
end;

function TFhirRiskEvidenceSynthesisSampleSizeList.Clone: TFhirRiskEvidenceSynthesisSampleSizeList;
begin
  result := TFhirRiskEvidenceSynthesisSampleSizeList(inherited Clone);
end;

function TFhirRiskEvidenceSynthesisSampleSizeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRiskEvidenceSynthesisSampleSizeList.GetItemN(index: Integer): TFhirRiskEvidenceSynthesisSampleSize;
begin
  result := TFhirRiskEvidenceSynthesisSampleSize(ObjectByIndex[index]);
end;

function TFhirRiskEvidenceSynthesisSampleSizeList.ItemClass: TFslObjectClass;
begin
  result := TFhirRiskEvidenceSynthesisSampleSize;
end;
function TFhirRiskEvidenceSynthesisSampleSizeList.IndexOf(value: TFhirRiskEvidenceSynthesisSampleSize): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRiskEvidenceSynthesisSampleSizeList.Insert(index: Integer): TFhirRiskEvidenceSynthesisSampleSize;
begin
  result := TFhirRiskEvidenceSynthesisSampleSize.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskEvidenceSynthesisSampleSizeList.InsertItem(index: Integer; value: TFhirRiskEvidenceSynthesisSampleSize);
begin
  assert(value is TFhirRiskEvidenceSynthesisSampleSize);
  Inherited Insert(index, value);
end;

function TFhirRiskEvidenceSynthesisSampleSizeList.Item(index: Integer): TFhirRiskEvidenceSynthesisSampleSize;
begin
  result := TFhirRiskEvidenceSynthesisSampleSize(ObjectByIndex[index]);
end;

function TFhirRiskEvidenceSynthesisSampleSizeList.Link: TFhirRiskEvidenceSynthesisSampleSizeList;
begin
  result := TFhirRiskEvidenceSynthesisSampleSizeList(inherited Link);
end;

procedure TFhirRiskEvidenceSynthesisSampleSizeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRiskEvidenceSynthesisSampleSizeList.SetItemByIndex(index: Integer; value: TFhirRiskEvidenceSynthesisSampleSize);
begin
  assert(value is TFhirRiskEvidenceSynthesisSampleSize);
  FhirRiskEvidenceSynthesisSampleSizes[index] := value;
end;

procedure TFhirRiskEvidenceSynthesisSampleSizeList.SetItemN(index: Integer; value: TFhirRiskEvidenceSynthesisSampleSize);
begin
  assert(value is TFhirRiskEvidenceSynthesisSampleSize);
  ObjectByIndex[index] := value;
end;

{ TFhirRiskEvidenceSynthesisRiskEstimate }

constructor TFhirRiskEvidenceSynthesisRiskEstimate.Create;
begin
  inherited;
end;

destructor TFhirRiskEvidenceSynthesisRiskEstimate.Destroy;
begin
  FDescription.free;
  FType_.free;
  FValue.free;
  FUnitOfMeasure.free;
  FDenominatorCount.free;
  FNumeratorCount.free;
  FPrecisionEstimateList.Free;
  inherited;
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimate.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirRiskEvidenceSynthesisRiskEstimate(oSource).descriptionElement.Clone;
  type_ := TFhirRiskEvidenceSynthesisRiskEstimate(oSource).type_.Clone;
  valueElement := TFhirRiskEvidenceSynthesisRiskEstimate(oSource).valueElement.Clone;
  unitOfMeasure := TFhirRiskEvidenceSynthesisRiskEstimate(oSource).unitOfMeasure.Clone;
  denominatorCountElement := TFhirRiskEvidenceSynthesisRiskEstimate(oSource).denominatorCountElement.Clone;
  numeratorCountElement := TFhirRiskEvidenceSynthesisRiskEstimate(oSource).numeratorCountElement.Clone;
  if (TFhirRiskEvidenceSynthesisRiskEstimate(oSource).FPrecisionEstimateList = nil) then
  begin
    FPrecisionEstimateList.free;
    FPrecisionEstimateList := nil;
  end
  else
  begin
    if FPrecisionEstimateList = nil then
      FPrecisionEstimateList := TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList.Create;
    FPrecisionEstimateList.Assign(TFhirRiskEvidenceSynthesisRiskEstimate(oSource).FPrecisionEstimateList);
  end;
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimate.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'unitOfMeasure') Then
     list.add(self.link, 'unitOfMeasure', FUnitOfMeasure.Link);
  if (child_name = 'denominatorCount') Then
     list.add(self.link, 'denominatorCount', FDenominatorCount.Link);
  if (child_name = 'numeratorCount') Then
     list.add(self.link, 'numeratorCount', FNumeratorCount.Link);
  if (child_name = 'precisionEstimate') Then
    list.addAll(self, 'precisionEstimate', FPrecisionEstimateList);
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimate.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'decimal', false, TFhirDecimal, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitOfMeasure', 'CodeableConcept', false, TFhirCodeableConcept, FUnitOfMeasure.Link));{2}
  oList.add(TFHIRProperty.create(self, 'denominatorCount', 'integer', false, TFhirInteger, FDenominatorCount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'numeratorCount', 'integer', false, TFhirInteger, FNumeratorCount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'precisionEstimate', '', true, TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate, FPrecisionEstimateList.Link)){3};
end;

function TFhirRiskEvidenceSynthesisRiskEstimate.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'unitOfMeasure') then
  begin
    UnitOfMeasure := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'denominatorCount') then
  begin
    DenominatorCountElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'numeratorCount') then
  begin
    NumeratorCountElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'precisionEstimate') then
  begin
    PrecisionEstimateList.add(propValue as TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimate.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'precisionEstimate') then PrecisionEstimateList.insertItem(index, propValue as TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate){2a}
  else inherited;
end;

function TFhirRiskEvidenceSynthesisRiskEstimate.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'value') then result := TFhirDecimal.create() {5b}
  else if (propName = 'unitOfMeasure') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'denominatorCount') then result := TFhirInteger.create() {5b}
  else if (propName = 'numeratorCount') then result := TFhirInteger.create() {5b}
  else if (propName = 'precisionEstimate') then result := PrecisionEstimateList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRiskEvidenceSynthesisRiskEstimate.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'decimal'
  else if (propName = 'unitOfMeasure') then result := 'CodeableConcept'
  else if (propName = 'denominatorCount') then result := 'integer'
  else if (propName = 'numeratorCount') then result := 'integer'
  else if (propName = 'precisionEstimate') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimate.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'unitOfMeasure') then UnitOfMeasureElement := nil
  else if (propName = 'denominatorCount') then DenominatorCountElement := nil
  else if (propName = 'numeratorCount') then NumeratorCountElement := nil
  else if (propName = 'precisionEstimate') then deletePropertyValue('precisionEstimate', PrecisionEstimateList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimate.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'value') then ValueElement := asDecimal(new){5b}
  else if (propName = 'unitOfMeasure') then UnitOfMeasureElement := new as TFhirCodeableConcept{4}
  else if (propName = 'denominatorCount') then DenominatorCountElement := asInteger(new){5b}
  else if (propName = 'numeratorCount') then NumeratorCountElement := asInteger(new){5b}
  else if (propName = 'precisionEstimate') then replacePropertyValue('precisionEstimate', PrecisionEstimateList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimate.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'precisionEstimate') then PrecisionEstimateList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRiskEvidenceSynthesisRiskEstimate.fhirType : string;
begin
  result := 'riskEstimate';
end;

function TFhirRiskEvidenceSynthesisRiskEstimate.Link : TFhirRiskEvidenceSynthesisRiskEstimate;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimate(inherited Link);
end;

function TFhirRiskEvidenceSynthesisRiskEstimate.Clone : TFhirRiskEvidenceSynthesisRiskEstimate;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimate(inherited Clone);
end;

function TFhirRiskEvidenceSynthesisRiskEstimate.equals(other : TObject) : boolean; 
var
  o : TFhirRiskEvidenceSynthesisRiskEstimate;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRiskEvidenceSynthesisRiskEstimate)) then
    result := false
  else
  begin
    o := TFhirRiskEvidenceSynthesisRiskEstimate(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(valueElement, o.valueElement, true) and compareDeep(unitOfMeasureElement, o.unitOfMeasureElement, true) and 
      compareDeep(denominatorCountElement, o.denominatorCountElement, true) and compareDeep(numeratorCountElement, o.numeratorCountElement, true) and 
      compareDeep(precisionEstimateList, o.precisionEstimateList, true);
  end;
end;

function TFhirRiskEvidenceSynthesisRiskEstimate.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FType_) and isEmptyProp(FValue) and isEmptyProp(FUnitOfMeasure) and isEmptyProp(FDenominatorCount) and isEmptyProp(FNumeratorCount) and isEmptyProp(FprecisionEstimateList);
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimate.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('type');
  fields.add('value');
  fields.add('unitOfMeasure');
  fields.add('denominatorCount');
  fields.add('numeratorCount');
  fields.add('precisionEstimate');
end;

{ TFhirRiskEvidenceSynthesisRiskEstimate }

Procedure TFhirRiskEvidenceSynthesisRiskEstimate.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirRiskEvidenceSynthesisRiskEstimate.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirRiskEvidenceSynthesisRiskEstimate.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirRiskEvidenceSynthesisRiskEstimate.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirRiskEvidenceSynthesisRiskEstimate.SetValue(value : TFhirDecimal);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirRiskEvidenceSynthesisRiskEstimate.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirRiskEvidenceSynthesisRiskEstimate.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirDecimal.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

Procedure TFhirRiskEvidenceSynthesisRiskEstimate.SetUnitOfMeasure(value : TFhirCodeableConcept);
begin
  FUnitOfMeasure.free;
  FUnitOfMeasure := value;
end;

Procedure TFhirRiskEvidenceSynthesisRiskEstimate.SetDenominatorCount(value : TFhirInteger);
begin
  FDenominatorCount.free;
  FDenominatorCount := value;
end;

Function TFhirRiskEvidenceSynthesisRiskEstimate.GetDenominatorCountST : String;
begin
  if FDenominatorCount = nil then
    result := ''
  else
    result := FDenominatorCount.value;
end;

Procedure TFhirRiskEvidenceSynthesisRiskEstimate.SetDenominatorCountST(value : String);
begin
  if value <> '' then
  begin
    if FDenominatorCount = nil then
      FDenominatorCount := TFhirInteger.create;
    FDenominatorCount.value := value
  end
  else if FDenominatorCount <> nil then
    FDenominatorCount.value := '';
end;

Procedure TFhirRiskEvidenceSynthesisRiskEstimate.SetNumeratorCount(value : TFhirInteger);
begin
  FNumeratorCount.free;
  FNumeratorCount := value;
end;

Function TFhirRiskEvidenceSynthesisRiskEstimate.GetNumeratorCountST : String;
begin
  if FNumeratorCount = nil then
    result := ''
  else
    result := FNumeratorCount.value;
end;

Procedure TFhirRiskEvidenceSynthesisRiskEstimate.SetNumeratorCountST(value : String);
begin
  if value <> '' then
  begin
    if FNumeratorCount = nil then
      FNumeratorCount := TFhirInteger.create;
    FNumeratorCount.value := value
  end
  else if FNumeratorCount <> nil then
    FNumeratorCount.value := '';
end;

Function TFhirRiskEvidenceSynthesisRiskEstimate.GetPrecisionEstimateList : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList;
begin
  if FPrecisionEstimateList = nil then
    FPrecisionEstimateList := TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList.Create;
  result := FPrecisionEstimateList;
end;

Function TFhirRiskEvidenceSynthesisRiskEstimate.GetHasPrecisionEstimateList : boolean;
begin
  result := (FPrecisionEstimateList <> nil) and (FPrecisionEstimateList.count > 0);
end;

function TFhirRiskEvidenceSynthesisRiskEstimate.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDescription.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FUnitOfMeasure.sizeInBytes);
  inc(result, FDenominatorCount.sizeInBytes);
  inc(result, FNumeratorCount.sizeInBytes);
  inc(result, FprecisionEstimateList.sizeInBytes);
end;

{ TFhirRiskEvidenceSynthesisRiskEstimateListEnumerator }

Constructor TFhirRiskEvidenceSynthesisRiskEstimateListEnumerator.Create(list : TFhirRiskEvidenceSynthesisRiskEstimateList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRiskEvidenceSynthesisRiskEstimateListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRiskEvidenceSynthesisRiskEstimateListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRiskEvidenceSynthesisRiskEstimateListEnumerator.GetCurrent : TFhirRiskEvidenceSynthesisRiskEstimate;
begin
  Result := FList[FIndex];
end;

function TFhirRiskEvidenceSynthesisRiskEstimateListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRiskEvidenceSynthesisRiskEstimateList }
procedure TFhirRiskEvidenceSynthesisRiskEstimateList.AddItem(value: TFhirRiskEvidenceSynthesisRiskEstimate);
begin
  assert(value.ClassName = 'TFhirRiskEvidenceSynthesisRiskEstimate', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRiskEvidenceSynthesisRiskEstimate');
  add(value);
end;

function TFhirRiskEvidenceSynthesisRiskEstimateList.Append: TFhirRiskEvidenceSynthesisRiskEstimate;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimate.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimateList.ClearItems;
begin
  Clear;
end;

function TFhirRiskEvidenceSynthesisRiskEstimateList.GetEnumerator : TFhirRiskEvidenceSynthesisRiskEstimateListEnumerator;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimateListEnumerator.Create(self.link);
end;

function TFhirRiskEvidenceSynthesisRiskEstimateList.Clone: TFhirRiskEvidenceSynthesisRiskEstimateList;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimateList(inherited Clone);
end;

function TFhirRiskEvidenceSynthesisRiskEstimateList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRiskEvidenceSynthesisRiskEstimateList.GetItemN(index: Integer): TFhirRiskEvidenceSynthesisRiskEstimate;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimate(ObjectByIndex[index]);
end;

function TFhirRiskEvidenceSynthesisRiskEstimateList.ItemClass: TFslObjectClass;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimate;
end;
function TFhirRiskEvidenceSynthesisRiskEstimateList.IndexOf(value: TFhirRiskEvidenceSynthesisRiskEstimate): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRiskEvidenceSynthesisRiskEstimateList.Insert(index: Integer): TFhirRiskEvidenceSynthesisRiskEstimate;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimate.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimateList.InsertItem(index: Integer; value: TFhirRiskEvidenceSynthesisRiskEstimate);
begin
  assert(value is TFhirRiskEvidenceSynthesisRiskEstimate);
  Inherited Insert(index, value);
end;

function TFhirRiskEvidenceSynthesisRiskEstimateList.Item(index: Integer): TFhirRiskEvidenceSynthesisRiskEstimate;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimate(ObjectByIndex[index]);
end;

function TFhirRiskEvidenceSynthesisRiskEstimateList.Link: TFhirRiskEvidenceSynthesisRiskEstimateList;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimateList(inherited Link);
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimateList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimateList.SetItemByIndex(index: Integer; value: TFhirRiskEvidenceSynthesisRiskEstimate);
begin
  assert(value is TFhirRiskEvidenceSynthesisRiskEstimate);
  FhirRiskEvidenceSynthesisRiskEstimates[index] := value;
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimateList.SetItemN(index: Integer; value: TFhirRiskEvidenceSynthesisRiskEstimate);
begin
  assert(value is TFhirRiskEvidenceSynthesisRiskEstimate);
  ObjectByIndex[index] := value;
end;

{ TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate }

constructor TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.Create;
begin
  inherited;
end;

destructor TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.Destroy;
begin
  FType_.free;
  FLevel.free;
  FFrom.free;
  FTo_.free;
  inherited;
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(oSource).type_.Clone;
  levelElement := TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(oSource).levelElement.Clone;
  fromElement := TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(oSource).fromElement.Clone;
  to_Element := TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(oSource).to_Element.Clone;
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'level') Then
     list.add(self.link, 'level', FLevel.Link);
  if (child_name = 'from') Then
     list.add(self.link, 'from', FFrom.Link);
  if (child_name = 'to') Then
     list.add(self.link, 'to', FTo_.Link);
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'level', 'decimal', false, TFhirDecimal, FLevel.Link));{2}
  oList.add(TFHIRProperty.create(self, 'from', 'decimal', false, TFhirDecimal, FFrom.Link));{2}
  oList.add(TFHIRProperty.create(self, 'to', 'decimal', false, TFhirDecimal, FTo_.Link));{2}
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'level') then
  begin
    LevelElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'from') then
  begin
    FromElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'to') then
  begin
    To_Element := asDecimal(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'level') then result := TFhirDecimal.create() {5b}
  else if (propName = 'from') then result := TFhirDecimal.create() {5b}
  else if (propName = 'to') then result := TFhirDecimal.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'level') then result := 'decimal'
  else if (propName = 'from') then result := 'decimal'
  else if (propName = 'to') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'level') then LevelElement := nil
  else if (propName = 'from') then FromElement := nil
  else if (propName = 'to') then To_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'level') then LevelElement := asDecimal(new){5b}
  else if (propName = 'from') then FromElement := asDecimal(new){5b}
  else if (propName = 'to') then To_Element := asDecimal(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.fhirType : string;
begin
  result := 'precisionEstimate';
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.Link : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(inherited Link);
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.Clone : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(inherited Clone);
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.equals(other : TObject) : boolean; 
var
  o : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate)) then
    result := false
  else
  begin
    o := TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(levelElement, o.levelElement, true) and 
      compareDeep(fromElement, o.fromElement, true) and compareDeep(to_Element, o.to_Element, true);
  end;
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FLevel) and isEmptyProp(FFrom) and isEmptyProp(FTo_);
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('level');
  fields.add('from');
  fields.add('to');
end;

{ TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate }

Procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.SetLevel(value : TFhirDecimal);
begin
  FLevel.free;
  FLevel := value;
end;

Function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.GetLevelST : String;
begin
  if FLevel = nil then
    result := ''
  else
    result := FLevel.value;
end;

Procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.SetLevelST(value : String);
begin
  if value <> '' then
  begin
    if FLevel = nil then
      FLevel := TFhirDecimal.create;
    FLevel.value := value
  end
  else if FLevel <> nil then
    FLevel.value := '';
end;

Procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.SetFrom(value : TFhirDecimal);
begin
  FFrom.free;
  FFrom := value;
end;

Function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.GetFromST : String;
begin
  if FFrom = nil then
    result := ''
  else
    result := FFrom.value;
end;

Procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.SetFromST(value : String);
begin
  if value <> '' then
  begin
    if FFrom = nil then
      FFrom := TFhirDecimal.create;
    FFrom.value := value
  end
  else if FFrom <> nil then
    FFrom.value := '';
end;

Procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.SetTo_(value : TFhirDecimal);
begin
  FTo_.free;
  FTo_ := value;
end;

Function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.GetTo_ST : String;
begin
  if FTo_ = nil then
    result := ''
  else
    result := FTo_.value;
end;

Procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.SetTo_ST(value : String);
begin
  if value <> '' then
  begin
    if FTo_ = nil then
      FTo_ := TFhirDecimal.create;
    FTo_.value := value
  end
  else if FTo_ <> nil then
    FTo_.value := '';
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FLevel.sizeInBytes);
  inc(result, FFrom.sizeInBytes);
  inc(result, FTo_.sizeInBytes);
end;

{ TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateListEnumerator }

Constructor TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateListEnumerator.Create(list : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateListEnumerator.GetCurrent : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate;
begin
  Result := FList[FIndex];
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList }
procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList.AddItem(value: TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate);
begin
  assert(value.ClassName = 'TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate');
  add(value);
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList.Append: TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList.ClearItems;
begin
  Clear;
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList.GetEnumerator : TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateListEnumerator;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateListEnumerator.Create(self.link);
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList.Clone: TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList(inherited Clone);
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList.GetItemN(index: Integer): TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(ObjectByIndex[index]);
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList.ItemClass: TFslObjectClass;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate;
end;
function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList.IndexOf(value: TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList.Insert(index: Integer): TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList.InsertItem(index: Integer; value: TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate);
begin
  assert(value is TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate);
  Inherited Insert(index, value);
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList.Item(index: Integer): TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate(ObjectByIndex[index]);
end;

function TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList.Link: TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList;
begin
  result := TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList(inherited Link);
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList.SetItemByIndex(index: Integer; value: TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate);
begin
  assert(value is TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate);
  FhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimates[index] := value;
end;

procedure TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimateList.SetItemN(index: Integer; value: TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate);
begin
  assert(value is TFhirRiskEvidenceSynthesisRiskEstimatePrecisionEstimate);
  ObjectByIndex[index] := value;
end;

{ TFhirRiskEvidenceSynthesisCertainty }

constructor TFhirRiskEvidenceSynthesisCertainty.Create;
begin
  inherited;
end;

destructor TFhirRiskEvidenceSynthesisCertainty.Destroy;
begin
  FRatingList.Free;
  FNoteList.Free;
  FCertaintySubcomponentList.Free;
  inherited;
end;

procedure TFhirRiskEvidenceSynthesisCertainty.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirRiskEvidenceSynthesisCertainty(oSource).FRatingList = nil) then
  begin
    FRatingList.free;
    FRatingList := nil;
  end
  else
  begin
    if FRatingList = nil then
      FRatingList := TFhirCodeableConceptList.Create;
    FRatingList.Assign(TFhirRiskEvidenceSynthesisCertainty(oSource).FRatingList);
  end;
  if (TFhirRiskEvidenceSynthesisCertainty(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirRiskEvidenceSynthesisCertainty(oSource).FNoteList);
  end;
  if (TFhirRiskEvidenceSynthesisCertainty(oSource).FCertaintySubcomponentList = nil) then
  begin
    FCertaintySubcomponentList.free;
    FCertaintySubcomponentList := nil;
  end
  else
  begin
    if FCertaintySubcomponentList = nil then
      FCertaintySubcomponentList := TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList.Create;
    FCertaintySubcomponentList.Assign(TFhirRiskEvidenceSynthesisCertainty(oSource).FCertaintySubcomponentList);
  end;
end;

procedure TFhirRiskEvidenceSynthesisCertainty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'rating') Then
    list.addAll(self, 'rating', FRatingList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'certaintySubcomponent') Then
    list.addAll(self, 'certaintySubcomponent', FCertaintySubcomponentList);
end;

procedure TFhirRiskEvidenceSynthesisCertainty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'rating', 'CodeableConcept', true, TFhirCodeableConcept, FRatingList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'certaintySubcomponent', '', true, TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent, FCertaintySubcomponentList.Link)){3};
end;

function TFhirRiskEvidenceSynthesisCertainty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'rating') then
  begin
    RatingList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'certaintySubcomponent') then
  begin
    CertaintySubcomponentList.add(propValue as TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRiskEvidenceSynthesisCertainty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'rating') then RatingList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'certaintySubcomponent') then CertaintySubcomponentList.insertItem(index, propValue as TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent){2a}
  else inherited;
end;

function TFhirRiskEvidenceSynthesisCertainty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'rating') then result := RatingList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'certaintySubcomponent') then result := CertaintySubcomponentList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRiskEvidenceSynthesisCertainty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'rating') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'certaintySubcomponent') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRiskEvidenceSynthesisCertainty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'rating') then deletePropertyValue('rating', RatingList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'certaintySubcomponent') then deletePropertyValue('certaintySubcomponent', CertaintySubcomponentList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRiskEvidenceSynthesisCertainty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'rating') then replacePropertyValue('rating', RatingList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'certaintySubcomponent') then replacePropertyValue('certaintySubcomponent', CertaintySubcomponentList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRiskEvidenceSynthesisCertainty.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'rating') then RatingList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'certaintySubcomponent') then CertaintySubcomponentList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRiskEvidenceSynthesisCertainty.fhirType : string;
begin
  result := 'certainty';
end;

function TFhirRiskEvidenceSynthesisCertainty.Link : TFhirRiskEvidenceSynthesisCertainty;
begin
  result := TFhirRiskEvidenceSynthesisCertainty(inherited Link);
end;

function TFhirRiskEvidenceSynthesisCertainty.Clone : TFhirRiskEvidenceSynthesisCertainty;
begin
  result := TFhirRiskEvidenceSynthesisCertainty(inherited Clone);
end;

function TFhirRiskEvidenceSynthesisCertainty.equals(other : TObject) : boolean; 
var
  o : TFhirRiskEvidenceSynthesisCertainty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRiskEvidenceSynthesisCertainty)) then
    result := false
  else
  begin
    o := TFhirRiskEvidenceSynthesisCertainty(other);
    result := compareDeep(ratingList, o.ratingList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(certaintySubcomponentList, o.certaintySubcomponentList, true);
  end;
end;

function TFhirRiskEvidenceSynthesisCertainty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FratingList) and isEmptyProp(FnoteList) and isEmptyProp(FcertaintySubcomponentList);
end;

procedure TFhirRiskEvidenceSynthesisCertainty.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('rating');
  fields.add('note');
  fields.add('certaintySubcomponent');
end;

{ TFhirRiskEvidenceSynthesisCertainty }

Function TFhirRiskEvidenceSynthesisCertainty.GetRatingList : TFhirCodeableConceptList;
begin
  if FRatingList = nil then
    FRatingList := TFhirCodeableConceptList.Create;
  result := FRatingList;
end;

Function TFhirRiskEvidenceSynthesisCertainty.GetHasRatingList : boolean;
begin
  result := (FRatingList <> nil) and (FRatingList.count > 0);
end;

Function TFhirRiskEvidenceSynthesisCertainty.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirRiskEvidenceSynthesisCertainty.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirRiskEvidenceSynthesisCertainty.GetCertaintySubcomponentList : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList;
begin
  if FCertaintySubcomponentList = nil then
    FCertaintySubcomponentList := TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList.Create;
  result := FCertaintySubcomponentList;
end;

Function TFhirRiskEvidenceSynthesisCertainty.GetHasCertaintySubcomponentList : boolean;
begin
  result := (FCertaintySubcomponentList <> nil) and (FCertaintySubcomponentList.count > 0);
end;

function TFhirRiskEvidenceSynthesisCertainty.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FratingList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FcertaintySubcomponentList.sizeInBytes);
end;

{ TFhirRiskEvidenceSynthesisCertaintyListEnumerator }

Constructor TFhirRiskEvidenceSynthesisCertaintyListEnumerator.Create(list : TFhirRiskEvidenceSynthesisCertaintyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRiskEvidenceSynthesisCertaintyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRiskEvidenceSynthesisCertaintyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRiskEvidenceSynthesisCertaintyListEnumerator.GetCurrent : TFhirRiskEvidenceSynthesisCertainty;
begin
  Result := FList[FIndex];
end;

function TFhirRiskEvidenceSynthesisCertaintyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRiskEvidenceSynthesisCertaintyList }
procedure TFhirRiskEvidenceSynthesisCertaintyList.AddItem(value: TFhirRiskEvidenceSynthesisCertainty);
begin
  assert(value.ClassName = 'TFhirRiskEvidenceSynthesisCertainty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRiskEvidenceSynthesisCertainty');
  add(value);
end;

function TFhirRiskEvidenceSynthesisCertaintyList.Append: TFhirRiskEvidenceSynthesisCertainty;
begin
  result := TFhirRiskEvidenceSynthesisCertainty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskEvidenceSynthesisCertaintyList.ClearItems;
begin
  Clear;
end;

function TFhirRiskEvidenceSynthesisCertaintyList.GetEnumerator : TFhirRiskEvidenceSynthesisCertaintyListEnumerator;
begin
  result := TFhirRiskEvidenceSynthesisCertaintyListEnumerator.Create(self.link);
end;

function TFhirRiskEvidenceSynthesisCertaintyList.Clone: TFhirRiskEvidenceSynthesisCertaintyList;
begin
  result := TFhirRiskEvidenceSynthesisCertaintyList(inherited Clone);
end;

function TFhirRiskEvidenceSynthesisCertaintyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRiskEvidenceSynthesisCertaintyList.GetItemN(index: Integer): TFhirRiskEvidenceSynthesisCertainty;
begin
  result := TFhirRiskEvidenceSynthesisCertainty(ObjectByIndex[index]);
end;

function TFhirRiskEvidenceSynthesisCertaintyList.ItemClass: TFslObjectClass;
begin
  result := TFhirRiskEvidenceSynthesisCertainty;
end;
function TFhirRiskEvidenceSynthesisCertaintyList.IndexOf(value: TFhirRiskEvidenceSynthesisCertainty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRiskEvidenceSynthesisCertaintyList.Insert(index: Integer): TFhirRiskEvidenceSynthesisCertainty;
begin
  result := TFhirRiskEvidenceSynthesisCertainty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskEvidenceSynthesisCertaintyList.InsertItem(index: Integer; value: TFhirRiskEvidenceSynthesisCertainty);
begin
  assert(value is TFhirRiskEvidenceSynthesisCertainty);
  Inherited Insert(index, value);
end;

function TFhirRiskEvidenceSynthesisCertaintyList.Item(index: Integer): TFhirRiskEvidenceSynthesisCertainty;
begin
  result := TFhirRiskEvidenceSynthesisCertainty(ObjectByIndex[index]);
end;

function TFhirRiskEvidenceSynthesisCertaintyList.Link: TFhirRiskEvidenceSynthesisCertaintyList;
begin
  result := TFhirRiskEvidenceSynthesisCertaintyList(inherited Link);
end;

procedure TFhirRiskEvidenceSynthesisCertaintyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRiskEvidenceSynthesisCertaintyList.SetItemByIndex(index: Integer; value: TFhirRiskEvidenceSynthesisCertainty);
begin
  assert(value is TFhirRiskEvidenceSynthesisCertainty);
  FhirRiskEvidenceSynthesisCertainties[index] := value;
end;

procedure TFhirRiskEvidenceSynthesisCertaintyList.SetItemN(index: Integer; value: TFhirRiskEvidenceSynthesisCertainty);
begin
  assert(value is TFhirRiskEvidenceSynthesisCertainty);
  ObjectByIndex[index] := value;
end;

{ TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent }

constructor TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.Create;
begin
  inherited;
end;

destructor TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.Destroy;
begin
  FType_.free;
  FRatingList.Free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent(oSource).type_.Clone;
  if (TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent(oSource).FRatingList = nil) then
  begin
    FRatingList.free;
    FRatingList := nil;
  end
  else
  begin
    if FRatingList = nil then
      FRatingList := TFhirCodeableConceptList.Create;
    FRatingList.Assign(TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent(oSource).FRatingList);
  end;
  if (TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent(oSource).FNoteList);
  end;
end;

procedure TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'rating') Then
    list.addAll(self, 'rating', FRatingList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rating', 'CodeableConcept', true, TFhirCodeableConcept, FRatingList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'rating') then
  begin
    RatingList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'rating') then RatingList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else inherited;
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'rating') then result := RatingList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'rating') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'rating') then deletePropertyValue('rating', RatingList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'rating') then replacePropertyValue('rating', RatingList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'rating') then RatingList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.fhirType : string;
begin
  result := 'certaintySubcomponent';
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.Link : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent;
begin
  result := TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent(inherited Link);
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.Clone : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent;
begin
  result := TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent(inherited Clone);
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.equals(other : TObject) : boolean; 
var
  o : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent)) then
    result := false
  else
  begin
    o := TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(ratingList, o.ratingList, true) and 
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FratingList) and isEmptyProp(FnoteList);
end;

procedure TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('rating');
  fields.add('note');
end;

{ TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent }

Procedure TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.GetRatingList : TFhirCodeableConceptList;
begin
  if FRatingList = nil then
    FRatingList := TFhirCodeableConceptList.Create;
  result := FRatingList;
end;

Function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.GetHasRatingList : boolean;
begin
  result := (FRatingList <> nil) and (FRatingList.count > 0);
end;

Function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FratingList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentListEnumerator }

Constructor TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentListEnumerator.Create(list : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentListEnumerator.GetCurrent : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent;
begin
  Result := FList[FIndex];
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList }
procedure TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList.AddItem(value: TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent);
begin
  assert(value.ClassName = 'TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent');
  add(value);
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList.Append: TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent;
begin
  result := TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList.ClearItems;
begin
  Clear;
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList.GetEnumerator : TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentListEnumerator;
begin
  result := TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentListEnumerator.Create(self.link);
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList.Clone: TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList;
begin
  result := TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList(inherited Clone);
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList.GetItemN(index: Integer): TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent;
begin
  result := TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent(ObjectByIndex[index]);
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList.ItemClass: TFslObjectClass;
begin
  result := TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent;
end;
function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList.IndexOf(value: TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList.Insert(index: Integer): TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent;
begin
  result := TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList.InsertItem(index: Integer; value: TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent);
begin
  assert(value is TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent);
  Inherited Insert(index, value);
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList.Item(index: Integer): TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent;
begin
  result := TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent(ObjectByIndex[index]);
end;

function TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList.Link: TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList;
begin
  result := TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList(inherited Link);
end;

procedure TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList.SetItemByIndex(index: Integer; value: TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent);
begin
  assert(value is TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent);
  FhirRiskEvidenceSynthesisCertaintyCertaintySubcomponents[index] := value;
end;

procedure TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponentList.SetItemN(index: Integer; value: TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent);
begin
  assert(value is TFhirRiskEvidenceSynthesisCertaintyCertaintySubcomponent);
  ObjectByIndex[index] := value;
end;

{ TFhirRiskEvidenceSynthesis }

constructor TFhirRiskEvidenceSynthesis.Create;
begin
  inherited;
end;

destructor TFhirRiskEvidenceSynthesis.Destroy;
begin
  FIdentifierList.Free;
  FNoteList.Free;
  FCopyright.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FTopicList.Free;
  FAuthorList.Free;
  FEditorList.Free;
  FReviewerList.Free;
  FEndorserList.Free;
  FRelatedArtifactList.Free;
  FSynthesisType.free;
  FStudyType.free;
  FPopulation.free;
  FExposure.free;
  FOutcome.free;
  FSampleSize.free;
  FRiskEstimate.free;
  FCertaintyList.Free;
  inherited;
end;

function TFhirRiskEvidenceSynthesis.GetResourceType : TFhirResourceType;
begin
  result := frtRiskEvidenceSynthesis;
end;

procedure TFhirRiskEvidenceSynthesis.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirRiskEvidenceSynthesis(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirRiskEvidenceSynthesis(oSource).FIdentifierList);
  end;
  if (TFhirRiskEvidenceSynthesis(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirRiskEvidenceSynthesis(oSource).FNoteList);
  end;
  copyrightElement := TFhirRiskEvidenceSynthesis(oSource).copyrightElement.Clone;
  approvalDateElement := TFhirRiskEvidenceSynthesis(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirRiskEvidenceSynthesis(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirRiskEvidenceSynthesis(oSource).effectivePeriod.Clone;
  if (TFhirRiskEvidenceSynthesis(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirCodeableConceptList.Create;
    FTopicList.Assign(TFhirRiskEvidenceSynthesis(oSource).FTopicList);
  end;
  if (TFhirRiskEvidenceSynthesis(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirContactDetailList.Create;
    FAuthorList.Assign(TFhirRiskEvidenceSynthesis(oSource).FAuthorList);
  end;
  if (TFhirRiskEvidenceSynthesis(oSource).FEditorList = nil) then
  begin
    FEditorList.free;
    FEditorList := nil;
  end
  else
  begin
    if FEditorList = nil then
      FEditorList := TFhirContactDetailList.Create;
    FEditorList.Assign(TFhirRiskEvidenceSynthesis(oSource).FEditorList);
  end;
  if (TFhirRiskEvidenceSynthesis(oSource).FReviewerList = nil) then
  begin
    FReviewerList.free;
    FReviewerList := nil;
  end
  else
  begin
    if FReviewerList = nil then
      FReviewerList := TFhirContactDetailList.Create;
    FReviewerList.Assign(TFhirRiskEvidenceSynthesis(oSource).FReviewerList);
  end;
  if (TFhirRiskEvidenceSynthesis(oSource).FEndorserList = nil) then
  begin
    FEndorserList.free;
    FEndorserList := nil;
  end
  else
  begin
    if FEndorserList = nil then
      FEndorserList := TFhirContactDetailList.Create;
    FEndorserList.Assign(TFhirRiskEvidenceSynthesis(oSource).FEndorserList);
  end;
  if (TFhirRiskEvidenceSynthesis(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirRiskEvidenceSynthesis(oSource).FRelatedArtifactList);
  end;
  synthesisType := TFhirRiskEvidenceSynthesis(oSource).synthesisType.Clone;
  studyType := TFhirRiskEvidenceSynthesis(oSource).studyType.Clone;
  population := TFhirRiskEvidenceSynthesis(oSource).population.Clone;
  exposure := TFhirRiskEvidenceSynthesis(oSource).exposure.Clone;
  outcome := TFhirRiskEvidenceSynthesis(oSource).outcome.Clone;
  sampleSize := TFhirRiskEvidenceSynthesis(oSource).sampleSize.Clone;
  riskEstimate := TFhirRiskEvidenceSynthesis(oSource).riskEstimate.Clone;
  if (TFhirRiskEvidenceSynthesis(oSource).FCertaintyList = nil) then
  begin
    FCertaintyList.free;
    FCertaintyList := nil;
  end
  else
  begin
    if FCertaintyList = nil then
      FCertaintyList := TFhirRiskEvidenceSynthesisCertaintyList.Create;
    FCertaintyList.Assign(TFhirRiskEvidenceSynthesis(oSource).FCertaintyList);
  end;
end;

procedure TFhirRiskEvidenceSynthesis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'editor') Then
    list.addAll(self, 'editor', FEditorList);
  if (child_name = 'reviewer') Then
    list.addAll(self, 'reviewer', FReviewerList);
  if (child_name = 'endorser') Then
    list.addAll(self, 'endorser', FEndorserList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'synthesisType') Then
     list.add(self.link, 'synthesisType', FSynthesisType.Link);
  if (child_name = 'studyType') Then
     list.add(self.link, 'studyType', FStudyType.Link);
  if (child_name = 'population') Then
     list.add(self.link, 'population', FPopulation.Link);
  if (child_name = 'exposure') Then
     list.add(self.link, 'exposure', FExposure.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'sampleSize') Then
     list.add(self.link, 'sampleSize', FSampleSize.Link);
  if (child_name = 'riskEstimate') Then
     list.add(self.link, 'riskEstimate', FRiskEstimate.Link);
  if (child_name = 'certainty') Then
    list.addAll(self, 'certainty', FCertaintyList);
end;

procedure TFhirRiskEvidenceSynthesis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'topic', 'CodeableConcept', true, TFhirCodeableConcept, FTopicList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'author', 'ContactDetail', true, TFhirContactDetail, FAuthorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'editor', 'ContactDetail', true, TFhirContactDetail, FEditorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reviewer', 'ContactDetail', true, TFhirContactDetail, FReviewerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'endorser', 'ContactDetail', true, TFhirContactDetail, FEndorserList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'synthesisType', 'CodeableConcept', false, TFhirCodeableConcept, FSynthesisType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'studyType', 'CodeableConcept', false, TFhirCodeableConcept, FStudyType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'population', 'Reference(EvidenceVariable)', false, TFhirReference{TFhirEvidenceVariable}, FPopulation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'exposure', 'Reference(EvidenceVariable)', false, TFhirReference{TFhirEvidenceVariable}, FExposure.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'Reference(EvidenceVariable)', false, TFhirReference{TFhirEvidenceVariable}, FOutcome.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sampleSize', '', false, TFhirRiskEvidenceSynthesisSampleSize, FSampleSize.Link));{2}
  oList.add(TFHIRProperty.create(self, 'riskEstimate', '', false, TFhirRiskEvidenceSynthesisRiskEstimate, FRiskEstimate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'certainty', '', true, TFhirRiskEvidenceSynthesisCertainty, FCertaintyList.Link)){3};
end;

function TFhirRiskEvidenceSynthesis.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'editor') then
  begin
    EditorList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'reviewer') then
  begin
    ReviewerList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'endorser') then
  begin
    EndorserList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact){2a};
    result := propValue;
  end
  else if (propName = 'synthesisType') then
  begin
    SynthesisType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'studyType') then
  begin
    StudyType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'population') then
  begin
    Population := propValue as TFhirReference{TFhirEvidenceVariable}{4b};
    result := propValue;
  end
  else if (propName = 'exposure') then
  begin
    Exposure := propValue as TFhirReference{TFhirEvidenceVariable}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirReference{TFhirEvidenceVariable}{4b};
    result := propValue;
  end
  else if (propName = 'sampleSize') then
  begin
    SampleSize := propValue as TFhirRiskEvidenceSynthesisSampleSize{4b};
    result := propValue;
  end
  else if (propName = 'riskEstimate') then
  begin
    RiskEstimate := propValue as TFhirRiskEvidenceSynthesisRiskEstimate{4b};
    result := propValue;
  end
  else if (propName = 'certainty') then
  begin
    CertaintyList.add(propValue as TFhirRiskEvidenceSynthesisCertainty){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirRiskEvidenceSynthesis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'editor') then EditorList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'reviewer') then ReviewerList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'endorser') then EndorserList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact){2a}
  else if (propName = 'certainty') then CertaintyList.insertItem(index, propValue as TFhirRiskEvidenceSynthesisCertainty){2a}
  else inherited;
end;

function TFhirRiskEvidenceSynthesis.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'approvalDate') then result := TFhirDate.create() {5b}
  else if (propName = 'lastReviewDate') then result := TFhirDate.create() {5b}
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'topic') then result := TopicList.new(){2}
  else if (propName = 'author') then result := AuthorList.new(){2}
  else if (propName = 'editor') then result := EditorList.new(){2}
  else if (propName = 'reviewer') then result := ReviewerList.new(){2}
  else if (propName = 'endorser') then result := EndorserList.new(){2}
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new(){2}
  else if (propName = 'synthesisType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'studyType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'population') then result := TFhirReference{TFhirEvidenceVariable}.create(){4b}
  else if (propName = 'exposure') then result := TFhirReference{TFhirEvidenceVariable}.create(){4b}
  else if (propName = 'outcome') then result := TFhirReference{TFhirEvidenceVariable}.create(){4b}
  else if (propName = 'sampleSize') then result := TFhirRiskEvidenceSynthesisSampleSize.create(){4b}
  else if (propName = 'riskEstimate') then result := TFhirRiskEvidenceSynthesisRiskEstimate.create(){4b}
  else if (propName = 'certainty') then result := CertaintyList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRiskEvidenceSynthesis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'topic') then result := 'CodeableConcept'
  else if (propName = 'author') then result := 'ContactDetail'
  else if (propName = 'editor') then result := 'ContactDetail'
  else if (propName = 'reviewer') then result := 'ContactDetail'
  else if (propName = 'endorser') then result := 'ContactDetail'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'synthesisType') then result := 'CodeableConcept'
  else if (propName = 'studyType') then result := 'CodeableConcept'
  else if (propName = 'population') then result := 'Reference'
  else if (propName = 'exposure') then result := 'Reference'
  else if (propName = 'outcome') then result := 'Reference'
  else if (propName = 'sampleSize') then result := ''
  else if (propName = 'riskEstimate') then result := ''
  else if (propName = 'certainty') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRiskEvidenceSynthesis.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value) {2}
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value) {2}
  else if (propName = 'editor') then deletePropertyValue('editor', EditorList, value) {2}
  else if (propName = 'reviewer') then deletePropertyValue('reviewer', ReviewerList, value) {2}
  else if (propName = 'endorser') then deletePropertyValue('endorser', EndorserList, value) {2}
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value) {2}
  else if (propName = 'synthesisType') then SynthesisTypeElement := nil
  else if (propName = 'studyType') then StudyTypeElement := nil
  else if (propName = 'population') then PopulationElement := nil
  else if (propName = 'exposure') then ExposureElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'sampleSize') then SampleSizeElement := nil
  else if (propName = 'riskEstimate') then RiskEstimateElement := nil
  else if (propName = 'certainty') then deletePropertyValue('certainty', CertaintyList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRiskEvidenceSynthesis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new){5b}
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new){5b}
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod{4}
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new) {2}
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new) {2}
  else if (propName = 'editor') then replacePropertyValue('editor', EditorList, existing, new) {2}
  else if (propName = 'reviewer') then replacePropertyValue('reviewer', ReviewerList, existing, new) {2}
  else if (propName = 'endorser') then replacePropertyValue('endorser', EndorserList, existing, new) {2}
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new) {2}
  else if (propName = 'synthesisType') then SynthesisTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'studyType') then StudyTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'population') then PopulationElement := new as TFhirReference{TFhirEvidenceVariable}{4}
  else if (propName = 'exposure') then ExposureElement := new as TFhirReference{TFhirEvidenceVariable}{4}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirReference{TFhirEvidenceVariable}{4}
  else if (propName = 'sampleSize') then SampleSizeElement := new as TFhirRiskEvidenceSynthesisSampleSize{4}
  else if (propName = 'riskEstimate') then RiskEstimateElement := new as TFhirRiskEvidenceSynthesisRiskEstimate{4}
  else if (propName = 'certainty') then replacePropertyValue('certainty', CertaintyList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRiskEvidenceSynthesis.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'topic') then TopicList.move(source, destination){2a}
  else if (propName = 'author') then AuthorList.move(source, destination){2a}
  else if (propName = 'editor') then EditorList.move(source, destination){2a}
  else if (propName = 'reviewer') then ReviewerList.move(source, destination){2a}
  else if (propName = 'endorser') then EndorserList.move(source, destination){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination){2a}
  else if (propName = 'certainty') then CertaintyList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRiskEvidenceSynthesis.fhirType : string;
begin
  result := 'RiskEvidenceSynthesis';
end;

function TFhirRiskEvidenceSynthesis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FnoteList) and isEmptyProp(FCopyright) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FtopicList) and isEmptyProp(FauthorList) and isEmptyProp(FeditorList) and isEmptyProp(FreviewerList) and isEmptyProp(FendorserList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(FSynthesisType) and isEmptyProp(FStudyType) and isEmptyProp(FPopulation) and isEmptyProp(FExposure) and isEmptyProp(FOutcome) and isEmptyProp(FSampleSize) and isEmptyProp(FRiskEstimate) and isEmptyProp(FcertaintyList);
end;

function TFhirRiskEvidenceSynthesis.equals(other : TObject) : boolean; 
var
  o : TFhirRiskEvidenceSynthesis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRiskEvidenceSynthesis)) then
    result := false
  else
  begin
    o := TFhirRiskEvidenceSynthesis(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(approvalDateElement, o.approvalDateElement, true) and 
      compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and 
      compareDeep(topicList, o.topicList, true) and compareDeep(authorList, o.authorList, true) and 
      compareDeep(editorList, o.editorList, true) and compareDeep(reviewerList, o.reviewerList, true) and 
      compareDeep(endorserList, o.endorserList, true) and compareDeep(relatedArtifactList, o.relatedArtifactList, true) and 
      compareDeep(synthesisTypeElement, o.synthesisTypeElement, true) and compareDeep(studyTypeElement, o.studyTypeElement, true) and 
      compareDeep(populationElement, o.populationElement, true) and compareDeep(exposureElement, o.exposureElement, true) and 
      compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(sampleSizeElement, o.sampleSizeElement, true) and 
      compareDeep(riskEstimateElement, o.riskEstimateElement, true) and compareDeep(certaintyList, o.certaintyList, true);
  end;
end;

function TFhirRiskEvidenceSynthesis.Link : TFhirRiskEvidenceSynthesis;
begin
  result := TFhirRiskEvidenceSynthesis(inherited Link);
end;

function TFhirRiskEvidenceSynthesis.Clone : TFhirRiskEvidenceSynthesis;
begin
  result := TFhirRiskEvidenceSynthesis(inherited Clone);
end;

procedure TFhirRiskEvidenceSynthesis.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('note');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('topic');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatedArtifact');
  fields.add('synthesisType');
  fields.add('studyType');
  fields.add('population');
  fields.add('exposure');
  fields.add('outcome');
  fields.add('sampleSize');
  fields.add('riskEstimate');
  fields.add('certainty');
end;

{ TFhirRiskEvidenceSynthesis }

Function TFhirRiskEvidenceSynthesis.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirRiskEvidenceSynthesis.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirRiskEvidenceSynthesis.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirRiskEvidenceSynthesis.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Procedure TFhirRiskEvidenceSynthesis.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirRiskEvidenceSynthesis.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirRiskEvidenceSynthesis.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Procedure TFhirRiskEvidenceSynthesis.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

Function TFhirRiskEvidenceSynthesis.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

Procedure TFhirRiskEvidenceSynthesis.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

Procedure TFhirRiskEvidenceSynthesis.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

Function TFhirRiskEvidenceSynthesis.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

Procedure TFhirRiskEvidenceSynthesis.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

Procedure TFhirRiskEvidenceSynthesis.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

Function TFhirRiskEvidenceSynthesis.GetTopicList : TFhirCodeableConceptList;
begin
  if FTopicList = nil then
    FTopicList := TFhirCodeableConceptList.Create;
  result := FTopicList;
end;

Function TFhirRiskEvidenceSynthesis.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

Function TFhirRiskEvidenceSynthesis.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

Function TFhirRiskEvidenceSynthesis.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

Function TFhirRiskEvidenceSynthesis.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

Function TFhirRiskEvidenceSynthesis.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

Function TFhirRiskEvidenceSynthesis.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

Function TFhirRiskEvidenceSynthesis.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

Function TFhirRiskEvidenceSynthesis.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

Function TFhirRiskEvidenceSynthesis.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

Function TFhirRiskEvidenceSynthesis.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

Function TFhirRiskEvidenceSynthesis.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

Procedure TFhirRiskEvidenceSynthesis.SetSynthesisType(value : TFhirCodeableConcept);
begin
  FSynthesisType.free;
  FSynthesisType := value;
end;

Procedure TFhirRiskEvidenceSynthesis.SetStudyType(value : TFhirCodeableConcept);
begin
  FStudyType.free;
  FStudyType := value;
end;

Procedure TFhirRiskEvidenceSynthesis.SetPopulation(value : TFhirReference{TFhirEvidenceVariable});
begin
  FPopulation.free;
  FPopulation := value;
end;

Procedure TFhirRiskEvidenceSynthesis.SetExposure(value : TFhirReference{TFhirEvidenceVariable});
begin
  FExposure.free;
  FExposure := value;
end;

Procedure TFhirRiskEvidenceSynthesis.SetOutcome(value : TFhirReference{TFhirEvidenceVariable});
begin
  FOutcome.free;
  FOutcome := value;
end;

Procedure TFhirRiskEvidenceSynthesis.SetSampleSize(value : TFhirRiskEvidenceSynthesisSampleSize);
begin
  FSampleSize.free;
  FSampleSize := value;
end;

Procedure TFhirRiskEvidenceSynthesis.SetRiskEstimate(value : TFhirRiskEvidenceSynthesisRiskEstimate);
begin
  FRiskEstimate.free;
  FRiskEstimate := value;
end;

Function TFhirRiskEvidenceSynthesis.GetCertaintyList : TFhirRiskEvidenceSynthesisCertaintyList;
begin
  if FCertaintyList = nil then
    FCertaintyList := TFhirRiskEvidenceSynthesisCertaintyList.Create;
  result := FCertaintyList;
end;

Function TFhirRiskEvidenceSynthesis.GetHasCertaintyList : boolean;
begin
  result := (FCertaintyList <> nil) and (FCertaintyList.count > 0);
end;

function TFhirRiskEvidenceSynthesis.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FApprovalDate.sizeInBytes);
  inc(result, FLastReviewDate.sizeInBytes);
  inc(result, FEffectivePeriod.sizeInBytes);
  inc(result, FtopicList.sizeInBytes);
  inc(result, FauthorList.sizeInBytes);
  inc(result, FeditorList.sizeInBytes);
  inc(result, FreviewerList.sizeInBytes);
  inc(result, FendorserList.sizeInBytes);
  inc(result, FrelatedArtifactList.sizeInBytes);
  inc(result, FSynthesisType.sizeInBytes);
  inc(result, FStudyType.sizeInBytes);
  inc(result, FPopulation.sizeInBytes);
  inc(result, FExposure.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FSampleSize.sizeInBytes);
  inc(result, FRiskEstimate.sizeInBytes);
  inc(result, FcertaintyList.sizeInBytes);
end;

{ TFhirRiskEvidenceSynthesisListEnumerator }

Constructor TFhirRiskEvidenceSynthesisListEnumerator.Create(list : TFhirRiskEvidenceSynthesisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRiskEvidenceSynthesisListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRiskEvidenceSynthesisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRiskEvidenceSynthesisListEnumerator.GetCurrent : TFhirRiskEvidenceSynthesis;
begin
  Result := FList[FIndex];
end;

function TFhirRiskEvidenceSynthesisListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRiskEvidenceSynthesisList }
procedure TFhirRiskEvidenceSynthesisList.AddItem(value: TFhirRiskEvidenceSynthesis);
begin
  assert(value.ClassName = 'TFhirRiskEvidenceSynthesis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRiskEvidenceSynthesis');
  add(value);
end;

function TFhirRiskEvidenceSynthesisList.Append: TFhirRiskEvidenceSynthesis;
begin
  result := TFhirRiskEvidenceSynthesis.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskEvidenceSynthesisList.ClearItems;
begin
  Clear;
end;

function TFhirRiskEvidenceSynthesisList.GetEnumerator : TFhirRiskEvidenceSynthesisListEnumerator;
begin
  result := TFhirRiskEvidenceSynthesisListEnumerator.Create(self.link);
end;

function TFhirRiskEvidenceSynthesisList.Clone: TFhirRiskEvidenceSynthesisList;
begin
  result := TFhirRiskEvidenceSynthesisList(inherited Clone);
end;

function TFhirRiskEvidenceSynthesisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRiskEvidenceSynthesisList.GetItemN(index: Integer): TFhirRiskEvidenceSynthesis;
begin
  result := TFhirRiskEvidenceSynthesis(ObjectByIndex[index]);
end;

function TFhirRiskEvidenceSynthesisList.ItemClass: TFslObjectClass;
begin
  result := TFhirRiskEvidenceSynthesis;
end;
function TFhirRiskEvidenceSynthesisList.IndexOf(value: TFhirRiskEvidenceSynthesis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRiskEvidenceSynthesisList.Insert(index: Integer): TFhirRiskEvidenceSynthesis;
begin
  result := TFhirRiskEvidenceSynthesis.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskEvidenceSynthesisList.InsertItem(index: Integer; value: TFhirRiskEvidenceSynthesis);
begin
  assert(value is TFhirRiskEvidenceSynthesis);
  Inherited Insert(index, value);
end;

function TFhirRiskEvidenceSynthesisList.Item(index: Integer): TFhirRiskEvidenceSynthesis;
begin
  result := TFhirRiskEvidenceSynthesis(ObjectByIndex[index]);
end;

function TFhirRiskEvidenceSynthesisList.Link: TFhirRiskEvidenceSynthesisList;
begin
  result := TFhirRiskEvidenceSynthesisList(inherited Link);
end;

procedure TFhirRiskEvidenceSynthesisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRiskEvidenceSynthesisList.SetItemByIndex(index: Integer; value: TFhirRiskEvidenceSynthesis);
begin
  assert(value is TFhirRiskEvidenceSynthesis);
  FhirRiskEvidenceSyntheses[index] := value;
end;

procedure TFhirRiskEvidenceSynthesisList.SetItemN(index: Integer; value: TFhirRiskEvidenceSynthesis);
begin
  assert(value is TFhirRiskEvidenceSynthesis);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RISKEVIDENCESYNTHESIS}

{$IFDEF FHIR_SUBSCRIPTION}

{ TFhirSubscriptionChannel }

constructor TFhirSubscriptionChannel.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionChannel.Destroy;
begin
  FType_.free;
  FEndpoint.free;
  FPayload.free;
  FHeaderList.Free;
  inherited;
end;

procedure TFhirSubscriptionChannel.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirSubscriptionChannel(oSource).FType_.Link;
  endpointElement := TFhirSubscriptionChannel(oSource).endpointElement.Clone;
  payloadElement := TFhirSubscriptionChannel(oSource).payloadElement.Clone;
  if (TFhirSubscriptionChannel(oSource).FHeaderList = nil) then
  begin
    FHeaderList.free;
    FHeaderList := nil;
  end
  else
  begin
    if FHeaderList = nil then
      FHeaderList := TFhirStringList.Create;
    FHeaderList.Assign(TFhirSubscriptionChannel(oSource).FHeaderList);
  end;
end;

procedure TFhirSubscriptionChannel.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'endpoint') Then
     list.add(self.link, 'endpoint', FEndpoint.Link);
  if (child_name = 'payload') Then
     list.add(self.link, 'payload', FPayload.Link);
  if (child_name = 'header') Then
    list.addAll(self, 'header', FHeaderList);
end;

procedure TFhirSubscriptionChannel.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'url', false, TFhirUrl, FEndpoint.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payload', 'code', false, TFhirCode, FPayload.Link));{2}
  oList.add(TFHIRProperty.create(self, 'header', 'string', true, TFhirString, FHeaderList.Link)){3};
end;

function TFhirSubscriptionChannel.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirSubscriptionChannelTypeEnum, CODES_TFhirSubscriptionChannelTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'endpoint') then
  begin
    EndpointElement := asUrl(propValue){5a};
    result := propValue;
  end
  else if (propName = 'payload') then
  begin
    PayloadElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'header') then
  begin
    HeaderList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionChannel.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'header') then HeaderList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirSubscriptionChannel.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'endpoint') then result := TFhirUrl.create() {5b}
  else if (propName = 'payload') then result := TFhirCode.create() {5b}
  else if (propName = 'header') then result := HeaderList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionChannel.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'endpoint') then result := 'url'
  else if (propName = 'payload') then result := 'code'
  else if (propName = 'header') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionChannel.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'endpoint') then EndpointElement := nil
  else if (propName = 'payload') then PayloadElement := nil
  else if (propName = 'header') then deletePropertyValue('header', HeaderList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionChannel.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirSubscriptionChannelTypeEnum, CODES_TFhirSubscriptionChannelTypeEnum, new){4}
  else if (propName = 'endpoint') then EndpointElement := asUrl(new){5b}
  else if (propName = 'payload') then PayloadElement := asCode(new){5b}
  else if (propName = 'header') then replacePropertyValue('header', HeaderList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionChannel.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'header') then HeaderList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionChannel.fhirType : string;
begin
  result := 'channel';
end;

function TFhirSubscriptionChannel.Link : TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel(inherited Link);
end;

function TFhirSubscriptionChannel.Clone : TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel(inherited Clone);
end;

function TFhirSubscriptionChannel.equals(other : TObject) : boolean; 
var
  o : TFhirSubscriptionChannel;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionChannel)) then
    result := false
  else
  begin
    o := TFhirSubscriptionChannel(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(endpointElement, o.endpointElement, true) and 
      compareDeep(payloadElement, o.payloadElement, true) and compareDeep(headerList, o.headerList, true);
  end;
end;

function TFhirSubscriptionChannel.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FEndpoint) and isEmptyProp(FPayload) and isEmptyProp(FheaderList);
end;

procedure TFhirSubscriptionChannel.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('endpoint');
  fields.add('payload');
  fields.add('header');
end;

{ TFhirSubscriptionChannel }

Procedure TFhirSubscriptionChannel.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirSubscriptionChannel.GetType_ST : TFhirSubscriptionChannelTypeEnum;
begin
  if FType_ = nil then
    result := TFhirSubscriptionChannelTypeEnum(0)
  else
    result := TFhirSubscriptionChannelTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirSubscriptionChannelTypeEnum, FType_.value));
end;

Procedure TFhirSubscriptionChannel.SetType_ST(value : TFhirSubscriptionChannelTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirSubscriptionChannelTypeEnum[value], CODES_TFhirSubscriptionChannelTypeEnum[value]);
end;

Procedure TFhirSubscriptionChannel.SetEndpoint(value : TFhirUrl);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

Function TFhirSubscriptionChannel.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := FEndpoint.value;
end;

Procedure TFhirSubscriptionChannel.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUrl.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;

Procedure TFhirSubscriptionChannel.SetPayload(value : TFhirCode);
begin
  FPayload.free;
  FPayload := value;
end;

Function TFhirSubscriptionChannel.GetPayloadST : String;
begin
  if FPayload = nil then
    result := ''
  else
    result := FPayload.value;
end;

Procedure TFhirSubscriptionChannel.SetPayloadST(value : String);
begin
  if value <> '' then
  begin
    if FPayload = nil then
      FPayload := TFhirCode.create;
    FPayload.value := value
  end
  else if FPayload <> nil then
    FPayload.value := '';
end;

Function TFhirSubscriptionChannel.GetHeaderList : TFhirStringList;
begin
  if FHeaderList = nil then
    FHeaderList := TFhirStringList.Create;
  result := FHeaderList;
end;

Function TFhirSubscriptionChannel.GetHasHeaderList : boolean;
begin
  result := (FHeaderList <> nil) and (FHeaderList.count > 0);
end;

function TFhirSubscriptionChannel.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FEndpoint.sizeInBytes);
  inc(result, FPayload.sizeInBytes);
  inc(result, FheaderList.sizeInBytes);
end;

{ TFhirSubscriptionChannelListEnumerator }

Constructor TFhirSubscriptionChannelListEnumerator.Create(list : TFhirSubscriptionChannelList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionChannelListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionChannelListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionChannelListEnumerator.GetCurrent : TFhirSubscriptionChannel;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionChannelListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubscriptionChannelList }
procedure TFhirSubscriptionChannelList.AddItem(value: TFhirSubscriptionChannel);
begin
  assert(value.ClassName = 'TFhirSubscriptionChannel', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionChannel');
  add(value);
end;

function TFhirSubscriptionChannelList.Append: TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionChannelList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionChannelList.GetEnumerator : TFhirSubscriptionChannelListEnumerator;
begin
  result := TFhirSubscriptionChannelListEnumerator.Create(self.link);
end;

function TFhirSubscriptionChannelList.Clone: TFhirSubscriptionChannelList;
begin
  result := TFhirSubscriptionChannelList(inherited Clone);
end;

function TFhirSubscriptionChannelList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionChannelList.GetItemN(index: Integer): TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel(ObjectByIndex[index]);
end;

function TFhirSubscriptionChannelList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionChannel;
end;
function TFhirSubscriptionChannelList.IndexOf(value: TFhirSubscriptionChannel): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionChannelList.Insert(index: Integer): TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionChannelList.InsertItem(index: Integer; value: TFhirSubscriptionChannel);
begin
  assert(value is TFhirSubscriptionChannel);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionChannelList.Item(index: Integer): TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel(ObjectByIndex[index]);
end;

function TFhirSubscriptionChannelList.Link: TFhirSubscriptionChannelList;
begin
  result := TFhirSubscriptionChannelList(inherited Link);
end;

procedure TFhirSubscriptionChannelList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionChannelList.SetItemByIndex(index: Integer; value: TFhirSubscriptionChannel);
begin
  assert(value is TFhirSubscriptionChannel);
  FhirSubscriptionChannels[index] := value;
end;

procedure TFhirSubscriptionChannelList.SetItemN(index: Integer; value: TFhirSubscriptionChannel);
begin
  assert(value is TFhirSubscriptionChannel);
  ObjectByIndex[index] := value;
end;

{ TFhirSubscription }

constructor TFhirSubscription.Create;
begin
  inherited;
end;

destructor TFhirSubscription.Destroy;
begin
  FStatus.free;
  FContactList.Free;
  FEnd_.free;
  FReason.free;
  FCriteria.free;
  FError.free;
  FChannel.free;
  inherited;
end;

function TFhirSubscription.GetResourceType : TFhirResourceType;
begin
  result := frtSubscription;
end;

procedure TFhirSubscription.Assign(oSource : TFslObject);
begin
  inherited;
  FStatus := TFhirSubscription(oSource).FStatus.Link;
  if (TFhirSubscription(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactPointList.Create;
    FContactList.Assign(TFhirSubscription(oSource).FContactList);
  end;
  end_Element := TFhirSubscription(oSource).end_Element.Clone;
  reasonElement := TFhirSubscription(oSource).reasonElement.Clone;
  criteriaElement := TFhirSubscription(oSource).criteriaElement.Clone;
  errorElement := TFhirSubscription(oSource).errorElement.Clone;
  channel := TFhirSubscription(oSource).channel.Clone;
end;

procedure TFhirSubscription.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'criteria') Then
     list.add(self.link, 'criteria', FCriteria.Link);
  if (child_name = 'error') Then
     list.add(self.link, 'error', FError.Link);
  if (child_name = 'channel') Then
     list.add(self.link, 'channel', FChannel.Link);
end;

procedure TFhirSubscription.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactPoint', true, TFhirContactPoint, FContactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'end', 'instant', false, TFhirInstant, FEnd_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'string', false, TFhirString, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'criteria', 'string', false, TFhirString, FCriteria.Link));{2}
  oList.add(TFHIRProperty.create(self, 'error', 'string', false, TFhirString, FError.Link));{2}
  oList.add(TFHIRProperty.create(self, 'channel', '', false, TFhirSubscriptionChannel, FChannel.Link));{2}
end;

function TFhirSubscription.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSubscriptionStatusEnum, CODES_TFhirSubscriptionStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'criteria') then
  begin
    CriteriaElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'error') then
  begin
    ErrorElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'channel') then
  begin
    Channel := propValue as TFhirSubscriptionChannel{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSubscription.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactPoint){2a}
  else inherited;
end;

function TFhirSubscription.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'end') then result := TFhirInstant.create() {5b}
  else if (propName = 'reason') then result := TFhirString.create() {5b}
  else if (propName = 'criteria') then result := TFhirString.create() {5b}
  else if (propName = 'error') then result := TFhirString.create() {5b}
  else if (propName = 'channel') then result := TFhirSubscriptionChannel.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscription.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'code'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'end') then result := 'instant'
  else if (propName = 'reason') then result := 'string'
  else if (propName = 'criteria') then result := 'string'
  else if (propName = 'error') then result := 'string'
  else if (propName = 'channel') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscription.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'criteria') then CriteriaElement := nil
  else if (propName = 'error') then ErrorElement := nil
  else if (propName = 'channel') then ChannelElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscription.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSubscriptionStatusEnum, CODES_TFhirSubscriptionStatusEnum, new){4}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'end') then End_Element := asInstant(new){5b}
  else if (propName = 'reason') then ReasonElement := asString(new){5b}
  else if (propName = 'criteria') then CriteriaElement := asString(new){5b}
  else if (propName = 'error') then ErrorElement := asString(new){5b}
  else if (propName = 'channel') then ChannelElement := new as TFhirSubscriptionChannel{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscription.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscription.fhirType : string;
begin
  result := 'Subscription';
end;

function TFhirSubscription.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FcontactList) and isEmptyProp(FEnd_) and isEmptyProp(FReason) and isEmptyProp(FCriteria) and isEmptyProp(FError) and isEmptyProp(FChannel);
end;

function TFhirSubscription.equals(other : TObject) : boolean; 
var
  o : TFhirSubscription;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscription)) then
    result := false
  else
  begin
    o := TFhirSubscription(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(end_Element, o.end_Element, true) and compareDeep(reasonElement, o.reasonElement, true) and 
      compareDeep(criteriaElement, o.criteriaElement, true) and compareDeep(errorElement, o.errorElement, true) and 
      compareDeep(channelElement, o.channelElement, true);
  end;
end;

function TFhirSubscription.Link : TFhirSubscription;
begin
  result := TFhirSubscription(inherited Link);
end;

function TFhirSubscription.Clone : TFhirSubscription;
begin
  result := TFhirSubscription(inherited Clone);
end;

procedure TFhirSubscription.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('status');
  fields.add('contact');
  fields.add('end');
  fields.add('reason');
  fields.add('criteria');
  fields.add('error');
  fields.add('channel');
end;

{ TFhirSubscription }

Procedure TFhirSubscription.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirSubscription.GetStatusST : TFhirSubscriptionStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSubscriptionStatusEnum(0)
  else
    result := TFhirSubscriptionStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSubscriptionStatusEnum, FStatus.value));
end;

Procedure TFhirSubscription.SetStatusST(value : TFhirSubscriptionStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSubscriptionStatusEnum[value], CODES_TFhirSubscriptionStatusEnum[value]);
end;

Function TFhirSubscription.GetContactList : TFhirContactPointList;
begin
  if FContactList = nil then
    FContactList := TFhirContactPointList.Create;
  result := FContactList;
end;

Function TFhirSubscription.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Procedure TFhirSubscription.SetEnd_(value : TFhirInstant);
begin
  FEnd_.free;
  FEnd_ := value;
end;

Function TFhirSubscription.GetEnd_ST : TFslDateTime;
begin
  if FEnd_ = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnd_.value;
end;

Procedure TFhirSubscription.SetEnd_ST(value : TFslDateTime);
begin
  if FEnd_ = nil then
    FEnd_ := TFhirInstant.create;
  FEnd_.value := value
end;

Procedure TFhirSubscription.SetReason(value : TFhirString);
begin
  FReason.free;
  FReason := value;
end;

Function TFhirSubscription.GetReasonST : String;
begin
  if FReason = nil then
    result := ''
  else
    result := FReason.value;
end;

Procedure TFhirSubscription.SetReasonST(value : String);
begin
  if value <> '' then
  begin
    if FReason = nil then
      FReason := TFhirString.create;
    FReason.value := value
  end
  else if FReason <> nil then
    FReason.value := '';
end;

Procedure TFhirSubscription.SetCriteria(value : TFhirString);
begin
  FCriteria.free;
  FCriteria := value;
end;

Function TFhirSubscription.GetCriteriaST : String;
begin
  if FCriteria = nil then
    result := ''
  else
    result := FCriteria.value;
end;

Procedure TFhirSubscription.SetCriteriaST(value : String);
begin
  if value <> '' then
  begin
    if FCriteria = nil then
      FCriteria := TFhirString.create;
    FCriteria.value := value
  end
  else if FCriteria <> nil then
    FCriteria.value := '';
end;

Procedure TFhirSubscription.SetError(value : TFhirString);
begin
  FError.free;
  FError := value;
end;

Function TFhirSubscription.GetErrorST : String;
begin
  if FError = nil then
    result := ''
  else
    result := FError.value;
end;

Procedure TFhirSubscription.SetErrorST(value : String);
begin
  if value <> '' then
  begin
    if FError = nil then
      FError := TFhirString.create;
    FError.value := value
  end
  else if FError <> nil then
    FError.value := '';
end;

Procedure TFhirSubscription.SetChannel(value : TFhirSubscriptionChannel);
begin
  FChannel.free;
  FChannel := value;
end;

function TFhirSubscription.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStatus.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FEnd_.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FCriteria.sizeInBytes);
  inc(result, FError.sizeInBytes);
  inc(result, FChannel.sizeInBytes);
end;

{ TFhirSubscriptionListEnumerator }

Constructor TFhirSubscriptionListEnumerator.Create(list : TFhirSubscriptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionListEnumerator.GetCurrent : TFhirSubscription;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubscriptionList }
procedure TFhirSubscriptionList.AddItem(value: TFhirSubscription);
begin
  assert(value.ClassName = 'TFhirSubscription', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscription');
  add(value);
end;

function TFhirSubscriptionList.Append: TFhirSubscription;
begin
  result := TFhirSubscription.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionList.GetEnumerator : TFhirSubscriptionListEnumerator;
begin
  result := TFhirSubscriptionListEnumerator.Create(self.link);
end;

function TFhirSubscriptionList.Clone: TFhirSubscriptionList;
begin
  result := TFhirSubscriptionList(inherited Clone);
end;

function TFhirSubscriptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionList.GetItemN(index: Integer): TFhirSubscription;
begin
  result := TFhirSubscription(ObjectByIndex[index]);
end;

function TFhirSubscriptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscription;
end;
function TFhirSubscriptionList.IndexOf(value: TFhirSubscription): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionList.Insert(index: Integer): TFhirSubscription;
begin
  result := TFhirSubscription.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionList.InsertItem(index: Integer; value: TFhirSubscription);
begin
  assert(value is TFhirSubscription);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionList.Item(index: Integer): TFhirSubscription;
begin
  result := TFhirSubscription(ObjectByIndex[index]);
end;

function TFhirSubscriptionList.Link: TFhirSubscriptionList;
begin
  result := TFhirSubscriptionList(inherited Link);
end;

procedure TFhirSubscriptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionList.SetItemByIndex(index: Integer; value: TFhirSubscription);
begin
  assert(value is TFhirSubscription);
  FhirSubscriptions[index] := value;
end;

procedure TFhirSubscriptionList.SetItemN(index: Integer; value: TFhirSubscription);
begin
  assert(value is TFhirSubscription);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSCRIPTION}

{$IFDEF FHIR_TASK}

{ TFhirTaskRestriction }

constructor TFhirTaskRestriction.Create;
begin
  inherited;
end;

destructor TFhirTaskRestriction.Destroy;
begin
  FRepetitions.free;
  FPeriod.free;
  FRecipientList.Free;
  inherited;
end;

procedure TFhirTaskRestriction.Assign(oSource : TFslObject);
begin
  inherited;
  repetitionsElement := TFhirTaskRestriction(oSource).repetitionsElement.Clone;
  period := TFhirTaskRestriction(oSource).period.Clone;
  if (TFhirTaskRestriction(oSource).FRecipientList = nil) then
  begin
    FRecipientList.free;
    FRecipientList := nil;
  end
  else
  begin
    if FRecipientList = nil then
      FRecipientList := TFhirReferenceList{TFhirPatient}.Create;
    FRecipientList.Assign(TFhirTaskRestriction(oSource).FRecipientList);
  end;
end;

procedure TFhirTaskRestriction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'repetitions') Then
     list.add(self.link, 'repetitions', FRepetitions.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'recipient') Then
    list.addAll(self, 'recipient', FRecipientList);
end;

procedure TFhirTaskRestriction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'repetitions', 'positiveInt', false, TFhirPositiveInt, FRepetitions.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference(Patient)', true, TFhirReference{TFhirPatient}, FRecipientList.Link)){3};
end;

function TFhirTaskRestriction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'repetitions') then
  begin
    RepetitionsElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    RecipientList.add(propValue as TFhirReference{TFhirPatient}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTaskRestriction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'recipient') then RecipientList.insertItem(index, propValue as TFhirReference{TFhirPatient}){2a}
  else inherited;
end;

function TFhirTaskRestriction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'repetitions') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'recipient') then result := RecipientList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTaskRestriction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'repetitions') then result := 'positiveInt'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'recipient') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTaskRestriction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'repetitions') then RepetitionsElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'recipient') then deletePropertyValue('recipient', RecipientList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTaskRestriction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'repetitions') then RepetitionsElement := asPositiveInt(new){5b}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'recipient') then replacePropertyValue('recipient', RecipientList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTaskRestriction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'recipient') then RecipientList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTaskRestriction.fhirType : string;
begin
  result := 'restriction';
end;

function TFhirTaskRestriction.Link : TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction(inherited Link);
end;

function TFhirTaskRestriction.Clone : TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction(inherited Clone);
end;

function TFhirTaskRestriction.equals(other : TObject) : boolean; 
var
  o : TFhirTaskRestriction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTaskRestriction)) then
    result := false
  else
  begin
    o := TFhirTaskRestriction(other);
    result := compareDeep(repetitionsElement, o.repetitionsElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(recipientList, o.recipientList, true);
  end;
end;

function TFhirTaskRestriction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRepetitions) and isEmptyProp(FPeriod) and isEmptyProp(FrecipientList);
end;

procedure TFhirTaskRestriction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('repetitions');
  fields.add('period');
  fields.add('recipient');
end;

{ TFhirTaskRestriction }

Procedure TFhirTaskRestriction.SetRepetitions(value : TFhirPositiveInt);
begin
  FRepetitions.free;
  FRepetitions := value;
end;

Function TFhirTaskRestriction.GetRepetitionsST : String;
begin
  if FRepetitions = nil then
    result := ''
  else
    result := FRepetitions.value;
end;

Procedure TFhirTaskRestriction.SetRepetitionsST(value : String);
begin
  if value <> '' then
  begin
    if FRepetitions = nil then
      FRepetitions := TFhirPositiveInt.create;
    FRepetitions.value := value
  end
  else if FRepetitions <> nil then
    FRepetitions.value := '';
end;

Procedure TFhirTaskRestriction.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Function TFhirTaskRestriction.GetRecipientList : TFhirReferenceList{TFhirPatient};
begin
  if FRecipientList = nil then
    FRecipientList := TFhirReferenceList{TFhirPatient}.Create;
  result := FRecipientList;
end;

Function TFhirTaskRestriction.GetHasRecipientList : boolean;
begin
  result := (FRecipientList <> nil) and (FRecipientList.count > 0);
end;

function TFhirTaskRestriction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRepetitions.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FrecipientList.sizeInBytes);
end;

{ TFhirTaskRestrictionListEnumerator }

Constructor TFhirTaskRestrictionListEnumerator.Create(list : TFhirTaskRestrictionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTaskRestrictionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTaskRestrictionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTaskRestrictionListEnumerator.GetCurrent : TFhirTaskRestriction;
begin
  Result := FList[FIndex];
end;

function TFhirTaskRestrictionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTaskRestrictionList }
procedure TFhirTaskRestrictionList.AddItem(value: TFhirTaskRestriction);
begin
  assert(value.ClassName = 'TFhirTaskRestriction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTaskRestriction');
  add(value);
end;

function TFhirTaskRestrictionList.Append: TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskRestrictionList.ClearItems;
begin
  Clear;
end;

function TFhirTaskRestrictionList.GetEnumerator : TFhirTaskRestrictionListEnumerator;
begin
  result := TFhirTaskRestrictionListEnumerator.Create(self.link);
end;

function TFhirTaskRestrictionList.Clone: TFhirTaskRestrictionList;
begin
  result := TFhirTaskRestrictionList(inherited Clone);
end;

function TFhirTaskRestrictionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTaskRestrictionList.GetItemN(index: Integer): TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction(ObjectByIndex[index]);
end;

function TFhirTaskRestrictionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTaskRestriction;
end;
function TFhirTaskRestrictionList.IndexOf(value: TFhirTaskRestriction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTaskRestrictionList.Insert(index: Integer): TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskRestrictionList.InsertItem(index: Integer; value: TFhirTaskRestriction);
begin
  assert(value is TFhirTaskRestriction);
  Inherited Insert(index, value);
end;

function TFhirTaskRestrictionList.Item(index: Integer): TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction(ObjectByIndex[index]);
end;

function TFhirTaskRestrictionList.Link: TFhirTaskRestrictionList;
begin
  result := TFhirTaskRestrictionList(inherited Link);
end;

procedure TFhirTaskRestrictionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTaskRestrictionList.SetItemByIndex(index: Integer; value: TFhirTaskRestriction);
begin
  assert(value is TFhirTaskRestriction);
  FhirTaskRestrictions[index] := value;
end;

procedure TFhirTaskRestrictionList.SetItemN(index: Integer; value: TFhirTaskRestriction);
begin
  assert(value is TFhirTaskRestriction);
  ObjectByIndex[index] := value;
end;

{ TFhirTaskInput }

constructor TFhirTaskInput.Create;
begin
  inherited;
end;

destructor TFhirTaskInput.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirTaskInput.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirTaskInput(oSource).type_.Clone;
  value := TFhirTaskInput(oSource).value.Clone;
end;

procedure TFhirTaskInput.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirTaskInput.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage', false, TFhirType, FValue.Link));{2}
end;

function TFhirTaskInput.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTaskInput.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTaskInput.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTaskInput.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTaskInput.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then ValueElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTaskInput.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then ValueElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTaskInput.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTaskInput.fhirType : string;
begin
  result := 'input';
end;

function TFhirTaskInput.Link : TFhirTaskInput;
begin
  result := TFhirTaskInput(inherited Link);
end;

function TFhirTaskInput.Clone : TFhirTaskInput;
begin
  result := TFhirTaskInput(inherited Clone);
end;

function TFhirTaskInput.equals(other : TObject) : boolean; 
var
  o : TFhirTaskInput;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTaskInput)) then
    result := false
  else
  begin
    o := TFhirTaskInput(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirTaskInput.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirTaskInput.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

{ TFhirTaskInput }

Procedure TFhirTaskInput.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirTaskInput.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

function TFhirTaskInput.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirTaskInputListEnumerator }

Constructor TFhirTaskInputListEnumerator.Create(list : TFhirTaskInputList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTaskInputListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTaskInputListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTaskInputListEnumerator.GetCurrent : TFhirTaskInput;
begin
  Result := FList[FIndex];
end;

function TFhirTaskInputListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTaskInputList }
procedure TFhirTaskInputList.AddItem(value: TFhirTaskInput);
begin
  assert(value.ClassName = 'TFhirTaskInput', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTaskInput');
  add(value);
end;

function TFhirTaskInputList.Append: TFhirTaskInput;
begin
  result := TFhirTaskInput.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskInputList.ClearItems;
begin
  Clear;
end;

function TFhirTaskInputList.GetEnumerator : TFhirTaskInputListEnumerator;
begin
  result := TFhirTaskInputListEnumerator.Create(self.link);
end;

function TFhirTaskInputList.Clone: TFhirTaskInputList;
begin
  result := TFhirTaskInputList(inherited Clone);
end;

function TFhirTaskInputList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTaskInputList.GetItemN(index: Integer): TFhirTaskInput;
begin
  result := TFhirTaskInput(ObjectByIndex[index]);
end;

function TFhirTaskInputList.ItemClass: TFslObjectClass;
begin
  result := TFhirTaskInput;
end;
function TFhirTaskInputList.IndexOf(value: TFhirTaskInput): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTaskInputList.Insert(index: Integer): TFhirTaskInput;
begin
  result := TFhirTaskInput.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskInputList.InsertItem(index: Integer; value: TFhirTaskInput);
begin
  assert(value is TFhirTaskInput);
  Inherited Insert(index, value);
end;

function TFhirTaskInputList.Item(index: Integer): TFhirTaskInput;
begin
  result := TFhirTaskInput(ObjectByIndex[index]);
end;

function TFhirTaskInputList.Link: TFhirTaskInputList;
begin
  result := TFhirTaskInputList(inherited Link);
end;

procedure TFhirTaskInputList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTaskInputList.SetItemByIndex(index: Integer; value: TFhirTaskInput);
begin
  assert(value is TFhirTaskInput);
  FhirTaskInputs[index] := value;
end;

procedure TFhirTaskInputList.SetItemN(index: Integer; value: TFhirTaskInput);
begin
  assert(value is TFhirTaskInput);
  ObjectByIndex[index] := value;
end;

{ TFhirTaskOutput }

constructor TFhirTaskOutput.Create;
begin
  inherited;
end;

destructor TFhirTaskOutput.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirTaskOutput.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirTaskOutput(oSource).type_.Clone;
  value := TFhirTaskOutput(oSource).value.Clone;
end;

procedure TFhirTaskOutput.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirTaskOutput.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage', false, TFhirType, FValue.Link));{2}
end;

function TFhirTaskOutput.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTaskOutput.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTaskOutput.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTaskOutput.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTaskOutput.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then ValueElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTaskOutput.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then ValueElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTaskOutput.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTaskOutput.fhirType : string;
begin
  result := 'output';
end;

function TFhirTaskOutput.Link : TFhirTaskOutput;
begin
  result := TFhirTaskOutput(inherited Link);
end;

function TFhirTaskOutput.Clone : TFhirTaskOutput;
begin
  result := TFhirTaskOutput(inherited Clone);
end;

function TFhirTaskOutput.equals(other : TObject) : boolean; 
var
  o : TFhirTaskOutput;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTaskOutput)) then
    result := false
  else
  begin
    o := TFhirTaskOutput(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirTaskOutput.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirTaskOutput.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

{ TFhirTaskOutput }

Procedure TFhirTaskOutput.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirTaskOutput.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

function TFhirTaskOutput.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirTaskOutputListEnumerator }

Constructor TFhirTaskOutputListEnumerator.Create(list : TFhirTaskOutputList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTaskOutputListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTaskOutputListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTaskOutputListEnumerator.GetCurrent : TFhirTaskOutput;
begin
  Result := FList[FIndex];
end;

function TFhirTaskOutputListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTaskOutputList }
procedure TFhirTaskOutputList.AddItem(value: TFhirTaskOutput);
begin
  assert(value.ClassName = 'TFhirTaskOutput', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTaskOutput');
  add(value);
end;

function TFhirTaskOutputList.Append: TFhirTaskOutput;
begin
  result := TFhirTaskOutput.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskOutputList.ClearItems;
begin
  Clear;
end;

function TFhirTaskOutputList.GetEnumerator : TFhirTaskOutputListEnumerator;
begin
  result := TFhirTaskOutputListEnumerator.Create(self.link);
end;

function TFhirTaskOutputList.Clone: TFhirTaskOutputList;
begin
  result := TFhirTaskOutputList(inherited Clone);
end;

function TFhirTaskOutputList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTaskOutputList.GetItemN(index: Integer): TFhirTaskOutput;
begin
  result := TFhirTaskOutput(ObjectByIndex[index]);
end;

function TFhirTaskOutputList.ItemClass: TFslObjectClass;
begin
  result := TFhirTaskOutput;
end;
function TFhirTaskOutputList.IndexOf(value: TFhirTaskOutput): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTaskOutputList.Insert(index: Integer): TFhirTaskOutput;
begin
  result := TFhirTaskOutput.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskOutputList.InsertItem(index: Integer; value: TFhirTaskOutput);
begin
  assert(value is TFhirTaskOutput);
  Inherited Insert(index, value);
end;

function TFhirTaskOutputList.Item(index: Integer): TFhirTaskOutput;
begin
  result := TFhirTaskOutput(ObjectByIndex[index]);
end;

function TFhirTaskOutputList.Link: TFhirTaskOutputList;
begin
  result := TFhirTaskOutputList(inherited Link);
end;

procedure TFhirTaskOutputList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTaskOutputList.SetItemByIndex(index: Integer; value: TFhirTaskOutput);
begin
  assert(value is TFhirTaskOutput);
  FhirTaskOutputs[index] := value;
end;

procedure TFhirTaskOutputList.SetItemN(index: Integer; value: TFhirTaskOutput);
begin
  assert(value is TFhirTaskOutput);
  ObjectByIndex[index] := value;
end;

{ TFhirTask }

constructor TFhirTask.Create;
begin
  inherited;
end;

destructor TFhirTask.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonical.free;
  FInstantiatesUri.free;
  FBasedOnList.Free;
  FGroupIdentifier.free;
  FPartOfList.Free;
  FStatus.free;
  FStatusReason.free;
  FBusinessStatus.free;
  FIntent.free;
  FPriority.free;
  FCode.free;
  FDescription.free;
  FFocus.free;
  FFor_.free;
  FEncounter.free;
  FExecutionPeriod.free;
  FAuthoredOn.free;
  FLastModified.free;
  FRequester.free;
  FPerformerTypeList.Free;
  FOwner.free;
  FLocation.free;
  FReasonCode.free;
  FReasonReference.free;
  FInsuranceList.Free;
  FNoteList.Free;
  FRelevantHistoryList.Free;
  FRestriction.free;
  FInputList.Free;
  FOutputList.Free;
  inherited;
end;

function TFhirTask.GetResourceType : TFhirResourceType;
begin
  result := frtTask;
end;

procedure TFhirTask.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTask(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirTask(oSource).FIdentifierList);
  end;
  instantiatesCanonicalElement := TFhirTask(oSource).instantiatesCanonicalElement.Clone;
  instantiatesUriElement := TFhirTask(oSource).instantiatesUriElement.Clone;
  if (TFhirTask(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList{TFhirReference}.Create;
    FBasedOnList.Assign(TFhirTask(oSource).FBasedOnList);
  end;
  groupIdentifier := TFhirTask(oSource).groupIdentifier.Clone;
  if (TFhirTask(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList{TFhirTask}.Create;
    FPartOfList.Assign(TFhirTask(oSource).FPartOfList);
  end;
  FStatus := TFhirTask(oSource).FStatus.Link;
  statusReason := TFhirTask(oSource).statusReason.Clone;
  businessStatus := TFhirTask(oSource).businessStatus.Clone;
  FIntent := TFhirTask(oSource).FIntent.Link;
  FPriority := TFhirTask(oSource).FPriority.Link;
  code := TFhirTask(oSource).code.Clone;
  descriptionElement := TFhirTask(oSource).descriptionElement.Clone;
  focus := TFhirTask(oSource).focus.Clone;
  for_ := TFhirTask(oSource).for_.Clone;
  encounter := TFhirTask(oSource).encounter.Clone;
  executionPeriod := TFhirTask(oSource).executionPeriod.Clone;
  authoredOnElement := TFhirTask(oSource).authoredOnElement.Clone;
  lastModifiedElement := TFhirTask(oSource).lastModifiedElement.Clone;
  requester := TFhirTask(oSource).requester.Clone;
  if (TFhirTask(oSource).FPerformerTypeList = nil) then
  begin
    FPerformerTypeList.free;
    FPerformerTypeList := nil;
  end
  else
  begin
    if FPerformerTypeList = nil then
      FPerformerTypeList := TFhirCodeableConceptList.Create;
    FPerformerTypeList.Assign(TFhirTask(oSource).FPerformerTypeList);
  end;
  owner := TFhirTask(oSource).owner.Clone;
  location := TFhirTask(oSource).location.Clone;
  reasonCode := TFhirTask(oSource).reasonCode.Clone;
  reasonReference := TFhirTask(oSource).reasonReference.Clone;
  if (TFhirTask(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirReferenceList{TFhirCoverage}.Create;
    FInsuranceList.Assign(TFhirTask(oSource).FInsuranceList);
  end;
  if (TFhirTask(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirTask(oSource).FNoteList);
  end;
  if (TFhirTask(oSource).FRelevantHistoryList = nil) then
  begin
    FRelevantHistoryList.free;
    FRelevantHistoryList := nil;
  end
  else
  begin
    if FRelevantHistoryList = nil then
      FRelevantHistoryList := TFhirReferenceList{TFhirProvenance}.Create;
    FRelevantHistoryList.Assign(TFhirTask(oSource).FRelevantHistoryList);
  end;
  restriction := TFhirTask(oSource).restriction.Clone;
  if (TFhirTask(oSource).FInputList = nil) then
  begin
    FInputList.free;
    FInputList := nil;
  end
  else
  begin
    if FInputList = nil then
      FInputList := TFhirTaskInputList.Create;
    FInputList.Assign(TFhirTask(oSource).FInputList);
  end;
  if (TFhirTask(oSource).FOutputList = nil) then
  begin
    FOutputList.free;
    FOutputList := nil;
  end
  else
  begin
    if FOutputList = nil then
      FOutputList := TFhirTaskOutputList.Create;
    FOutputList.Assign(TFhirTask(oSource).FOutputList);
  end;
end;

procedure TFhirTask.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
     list.add(self.link, 'instantiatesCanonical', FInstantiatesCanonical.Link);
  if (child_name = 'instantiatesUri') Then
     list.add(self.link, 'instantiatesUri', FInstantiatesUri.Link);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'groupIdentifier') Then
     list.add(self.link, 'groupIdentifier', FGroupIdentifier.Link);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'businessStatus') Then
     list.add(self.link, 'businessStatus', FBusinessStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'focus') Then
     list.add(self.link, 'focus', FFocus.Link);
  if (child_name = 'for') Then
     list.add(self.link, 'for', FFor_.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'executionPeriod') Then
     list.add(self.link, 'executionPeriod', FExecutionPeriod.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'lastModified') Then
     list.add(self.link, 'lastModified', FLastModified.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'performerType') Then
    list.addAll(self, 'performerType', FPerformerTypeList);
  if (child_name = 'owner') Then
     list.add(self.link, 'owner', FOwner.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'reasonCode') Then
     list.add(self.link, 'reasonCode', FReasonCode.Link);
  if (child_name = 'reasonReference') Then
     list.add(self.link, 'reasonReference', FReasonReference.Link);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'relevantHistory') Then
    list.addAll(self, 'relevantHistory', FRelevantHistoryList);
  if (child_name = 'restriction') Then
     list.add(self.link, 'restriction', FRestriction.Link);
  if (child_name = 'input') Then
    list.addAll(self, 'input', FInputList);
  if (child_name = 'output') Then
    list.addAll(self, 'output', FOutputList);
end;

procedure TFhirTask.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', false, TFhirCanonical, FInstantiatesCanonical.Link));{2}
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', false, TFhirUri, FInstantiatesUri.Link));{2}
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference(Any)', true, TFhirReference{TFhirReference}, FBasedOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'groupIdentifier', 'Identifier', false, TFhirIdentifier, FGroupIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference(Task)', true, TFhirReference{TFhirTask}, FPartOfList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', false, TFhirCodeableConcept, FStatusReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'businessStatus', 'CodeableConcept', false, TFhirCodeableConcept, FBusinessStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFHIREnum, FIntent.Link));{1}
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFHIREnum, FPriority.Link));{1}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'focus', 'Reference(Any)', false, TFhirReference{TFhirReference}, FFocus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'for', 'Reference(Any)', false, TFhirReference{TFhirReference}, FFor_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'executionPeriod', 'Period', false, TFhirPeriod, FExecutionPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lastModified', 'dateTime', false, TFhirDateTime, FLastModified.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requester', 'Reference(Device)', false, TFhirReference{TFhirDevice}, FRequester.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performerType', 'CodeableConcept', true, TFhirCodeableConcept, FPerformerTypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'owner', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FOwner.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', false, TFhirCodeableConcept, FReasonCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference(Any)', false, TFhirReference{TFhirReference}, FReasonReference.Link));{2}
  oList.add(TFHIRProperty.create(self, 'insurance', 'Reference(Coverage)', true, TFhirReference{TFhirCoverage}, FInsuranceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relevantHistory', 'Reference(Provenance)', true, TFhirReference{TFhirProvenance}, FRelevantHistoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'restriction', '', false, TFhirTaskRestriction, FRestriction.Link));{2}
  oList.add(TFHIRProperty.create(self, 'input', '', true, TFhirTaskInput, FInputList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'output', '', true, TFhirTaskOutput, FOutputList.Link)){3};
end;

function TFhirTask.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalElement := asCanonical(propValue){5a};
    result := propValue;
  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'groupIdentifier') then
  begin
    GroupIdentifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference{TFhirTask}){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirTaskStatusEnum, CODES_TFhirTaskStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'businessStatus') then
  begin
    BusinessStatus := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirTaskIntentEnum, CODES_TFhirTaskIntentEnum, propValue);
    result := propValue
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    Focus := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'for') then
  begin
    For_ := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'executionPeriod') then
  begin
    ExecutionPeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lastModified') then
  begin
    LastModifiedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirReference{TFhirDevice}{4b};
    result := propValue;
  end
  else if (propName = 'performerType') then
  begin
    PerformerTypeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'owner') then
  begin
    Owner := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCode := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReference := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirReference{TFhirCoverage}){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'relevantHistory') then
  begin
    RelevantHistoryList.add(propValue as TFhirReference{TFhirProvenance}){2a};
    result := propValue;
  end
  else if (propName = 'restriction') then
  begin
    Restriction := propValue as TFhirTaskRestriction{4b};
    result := propValue;
  end
  else if (propName = 'input') then
  begin
    InputList.add(propValue as TFhirTaskInput){2a};
    result := propValue;
  end
  else if (propName = 'output') then
  begin
    OutputList.add(propValue as TFhirTaskOutput){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirTask.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference{TFhirTask}){2a}
  else if (propName = 'performerType') then PerformerTypeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirReference{TFhirCoverage}){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'relevantHistory') then RelevantHistoryList.insertItem(index, propValue as TFhirReference{TFhirProvenance}){2a}
  else if (propName = 'input') then InputList.insertItem(index, propValue as TFhirTaskInput){2a}
  else if (propName = 'output') then OutputList.insertItem(index, propValue as TFhirTaskOutput){2a}
  else inherited;
end;

function TFhirTask.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'instantiatesCanonical') then result := TFhirCanonical.create() {5b}
  else if (propName = 'instantiatesUri') then result := TFhirUri.create() {5b}
  else if (propName = 'basedOn') then result := BasedOnList.new(){2}
  else if (propName = 'groupIdentifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'partOf') then result := PartOfList.new(){2}
  else if (propName = 'statusReason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'businessStatus') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'focus') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'for') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'executionPeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'authoredOn') then result := TFhirDateTime.create() {5b}
  else if (propName = 'lastModified') then result := TFhirDateTime.create() {5b}
  else if (propName = 'requester') then result := TFhirReference{TFhirDevice}.create(){4b}
  else if (propName = 'performerType') then result := PerformerTypeList.new(){2}
  else if (propName = 'owner') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'location') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'reasonCode') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reasonReference') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'insurance') then result := InsuranceList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'relevantHistory') then result := RelevantHistoryList.new(){2}
  else if (propName = 'restriction') then result := TFhirTaskRestriction.create(){4b}
  else if (propName = 'input') then result := InputList.new(){2}
  else if (propName = 'output') then result := OutputList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTask.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'groupIdentifier') then result := 'Identifier'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'businessStatus') then result := 'CodeableConcept'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'focus') then result := 'Reference'
  else if (propName = 'for') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'executionPeriod') then result := 'Period'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'lastModified') then result := 'dateTime'
  else if (propName = 'requester') then result := 'Reference'
  else if (propName = 'performerType') then result := 'CodeableConcept'
  else if (propName = 'owner') then result := 'Reference'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'insurance') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'relevantHistory') then result := 'Reference'
  else if (propName = 'restriction') then result := ''
  else if (propName = 'input') then result := ''
  else if (propName = 'output') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTask.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalElement := nil
  else if (propName = 'instantiatesUri') then InstantiatesUriElement := nil
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {2}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := nil
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'businessStatus') then BusinessStatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'focus') then FocusElement := nil
  else if (propName = 'for') then For_Element := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'executionPeriod') then ExecutionPeriodElement := nil
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'lastModified') then LastModifiedElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'performerType') then deletePropertyValue('performerType', PerformerTypeList, value) {2}
  else if (propName = 'owner') then OwnerElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'reasonCode') then ReasonCodeElement := nil
  else if (propName = 'reasonReference') then ReasonReferenceElement := nil
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'relevantHistory') then deletePropertyValue('relevantHistory', RelevantHistoryList, value) {2}
  else if (propName = 'restriction') then RestrictionElement := nil
  else if (propName = 'input') then deletePropertyValue('input', InputList, value) {2}
  else if (propName = 'output') then deletePropertyValue('output', OutputList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTask.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalElement := asCanonical(new){5b}
  else if (propName = 'instantiatesUri') then InstantiatesUriElement := asUri(new){5b}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {2}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirTaskStatusEnum, CODES_TFhirTaskStatusEnum, new){4}
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'businessStatus') then BusinessStatusElement := new as TFhirCodeableConcept{4}
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirTaskIntentEnum, CODES_TFhirTaskIntentEnum, new){4}
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new){4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'focus') then FocusElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'for') then For_Element := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'executionPeriod') then ExecutionPeriodElement := new as TFhirPeriod{4}
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new){5b}
  else if (propName = 'lastModified') then LastModifiedElement := asDateTime(new){5b}
  else if (propName = 'requester') then RequesterElement := new as TFhirReference{TFhirDevice}{4}
  else if (propName = 'performerType') then replacePropertyValue('performerType', PerformerTypeList, existing, new) {2}
  else if (propName = 'owner') then OwnerElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'location') then LocationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'reasonCode') then ReasonCodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'reasonReference') then ReasonReferenceElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'relevantHistory') then replacePropertyValue('relevantHistory', RelevantHistoryList, existing, new) {2}
  else if (propName = 'restriction') then RestrictionElement := new as TFhirTaskRestriction{4}
  else if (propName = 'input') then replacePropertyValue('input', InputList, existing, new) {2}
  else if (propName = 'output') then replacePropertyValue('output', OutputList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTask.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination){2a}
  else if (propName = 'partOf') then PartOfList.move(source, destination){2a}
  else if (propName = 'performerType') then PerformerTypeList.move(source, destination){2a}
  else if (propName = 'insurance') then InsuranceList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'relevantHistory') then RelevantHistoryList.move(source, destination){2a}
  else if (propName = 'input') then InputList.move(source, destination){2a}
  else if (propName = 'output') then OutputList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTask.fhirType : string;
begin
  result := 'Task';
end;

function TFhirTask.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FInstantiatesCanonical) and isEmptyProp(FInstantiatesUri) and isEmptyProp(FbasedOnList) and isEmptyProp(FGroupIdentifier) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FBusinessStatus) and isEmptyProp(FIntent) and isEmptyProp(FPriority) and isEmptyProp(FCode) and isEmptyProp(FDescription) and isEmptyProp(FFocus) and isEmptyProp(FFor_) and isEmptyProp(FEncounter) and isEmptyProp(FExecutionPeriod) and isEmptyProp(FAuthoredOn) and isEmptyProp(FLastModified) and isEmptyProp(FRequester) and isEmptyProp(FperformerTypeList) and isEmptyProp(FOwner) and isEmptyProp(FLocation) and isEmptyProp(FReasonCode) and isEmptyProp(FReasonReference) and isEmptyProp(FinsuranceList) and isEmptyProp(FnoteList) and isEmptyProp(FrelevantHistoryList) and isEmptyProp(FRestriction) and isEmptyProp(FinputList) and isEmptyProp(FoutputList);
end;

function TFhirTask.equals(other : TObject) : boolean; 
var
  o : TFhirTask;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTask)) then
    result := false
  else
  begin
    o := TFhirTask(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalElement, o.instantiatesCanonicalElement, true) and 
      compareDeep(instantiatesUriElement, o.instantiatesUriElement, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(groupIdentifierElement, o.groupIdentifierElement, true) and compareDeep(partOfList, o.partOfList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(statusReasonElement, o.statusReasonElement, true) and 
      compareDeep(businessStatusElement, o.businessStatusElement, true) and compareDeep(intentElement, o.intentElement, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(focusElement, o.focusElement, true) and 
      compareDeep(for_Element, o.for_Element, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(executionPeriodElement, o.executionPeriodElement, true) and compareDeep(authoredOnElement, o.authoredOnElement, true) and 
      compareDeep(lastModifiedElement, o.lastModifiedElement, true) and compareDeep(requesterElement, o.requesterElement, true) and 
      compareDeep(performerTypeList, o.performerTypeList, true) and compareDeep(ownerElement, o.ownerElement, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(reasonCodeElement, o.reasonCodeElement, true) and 
      compareDeep(reasonReferenceElement, o.reasonReferenceElement, true) and compareDeep(insuranceList, o.insuranceList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(relevantHistoryList, o.relevantHistoryList, true) and 
      compareDeep(restrictionElement, o.restrictionElement, true) and compareDeep(inputList, o.inputList, true) and 
      compareDeep(outputList, o.outputList, true);
  end;
end;

function TFhirTask.Link : TFhirTask;
begin
  result := TFhirTask(inherited Link);
end;

function TFhirTask.Clone : TFhirTask;
begin
  result := TFhirTask(inherited Clone);
end;

procedure TFhirTask.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('groupIdentifier');
  fields.add('partOf');
  fields.add('status');
  fields.add('statusReason');
  fields.add('businessStatus');
  fields.add('intent');
  fields.add('priority');
  fields.add('code');
  fields.add('description');
  fields.add('focus');
  fields.add('for');
  fields.add('encounter');
  fields.add('executionPeriod');
  fields.add('authoredOn');
  fields.add('lastModified');
  fields.add('requester');
  fields.add('performerType');
  fields.add('owner');
  fields.add('location');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('insurance');
  fields.add('note');
  fields.add('relevantHistory');
  fields.add('restriction');
  fields.add('input');
  fields.add('output');
end;

{ TFhirTask }

Function TFhirTask.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirTask.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirTask.SetInstantiatesCanonical(value : TFhirCanonical);
begin
  FInstantiatesCanonical.free;
  FInstantiatesCanonical := value;
end;

Function TFhirTask.GetInstantiatesCanonicalST : String;
begin
  if FInstantiatesCanonical = nil then
    result := ''
  else
    result := FInstantiatesCanonical.value;
end;

Procedure TFhirTask.SetInstantiatesCanonicalST(value : String);
begin
  if value <> '' then
  begin
    if FInstantiatesCanonical = nil then
      FInstantiatesCanonical := TFhirCanonical.create;
    FInstantiatesCanonical.value := value
  end
  else if FInstantiatesCanonical <> nil then
    FInstantiatesCanonical.value := '';
end;

Procedure TFhirTask.SetInstantiatesUri(value : TFhirUri);
begin
  FInstantiatesUri.free;
  FInstantiatesUri := value;
end;

Function TFhirTask.GetInstantiatesUriST : String;
begin
  if FInstantiatesUri = nil then
    result := ''
  else
    result := FInstantiatesUri.value;
end;

Procedure TFhirTask.SetInstantiatesUriST(value : String);
begin
  if value <> '' then
  begin
    if FInstantiatesUri = nil then
      FInstantiatesUri := TFhirUri.create;
    FInstantiatesUri.value := value
  end
  else if FInstantiatesUri <> nil then
    FInstantiatesUri.value := '';
end;

Function TFhirTask.GetBasedOnList : TFhirReferenceList{TFhirReference};
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList{TFhirReference}.Create;
  result := FBasedOnList;
end;

Function TFhirTask.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

Procedure TFhirTask.SetGroupIdentifier(value : TFhirIdentifier);
begin
  FGroupIdentifier.free;
  FGroupIdentifier := value;
end;

Function TFhirTask.GetPartOfList : TFhirReferenceList{TFhirTask};
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList{TFhirTask}.Create;
  result := FPartOfList;
end;

Function TFhirTask.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

Procedure TFhirTask.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirTask.GetStatusST : TFhirTaskStatusEnum;
begin
  if FStatus = nil then
    result := TFhirTaskStatusEnum(0)
  else
    result := TFhirTaskStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirTaskStatusEnum, FStatus.value));
end;

Procedure TFhirTask.SetStatusST(value : TFhirTaskStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirTaskStatusEnum[value], CODES_TFhirTaskStatusEnum[value]);
end;

Procedure TFhirTask.SetStatusReason(value : TFhirCodeableConcept);
begin
  FStatusReason.free;
  FStatusReason := value;
end;

Procedure TFhirTask.SetBusinessStatus(value : TFhirCodeableConcept);
begin
  FBusinessStatus.free;
  FBusinessStatus := value;
end;

Procedure TFhirTask.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

Function TFhirTask.GetIntentST : TFhirTaskIntentEnum;
begin
  if FIntent = nil then
    result := TFhirTaskIntentEnum(0)
  else
    result := TFhirTaskIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirTaskIntentEnum, FIntent.value));
end;

Procedure TFhirTask.SetIntentST(value : TFhirTaskIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirTaskIntentEnum[value], CODES_TFhirTaskIntentEnum[value]);
end;

Procedure TFhirTask.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

Function TFhirTask.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

Procedure TFhirTask.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

Procedure TFhirTask.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirTask.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirTask.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirTask.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirTask.SetFocus(value : TFhirReference{TFhirReference});
begin
  FFocus.free;
  FFocus := value;
end;

Procedure TFhirTask.SetFor_(value : TFhirReference{TFhirReference});
begin
  FFor_.free;
  FFor_ := value;
end;

Procedure TFhirTask.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirTask.SetExecutionPeriod(value : TFhirPeriod);
begin
  FExecutionPeriod.free;
  FExecutionPeriod := value;
end;

Procedure TFhirTask.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value;
end;

Function TFhirTask.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

Procedure TFhirTask.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

Procedure TFhirTask.SetLastModified(value : TFhirDateTime);
begin
  FLastModified.free;
  FLastModified := value;
end;

Function TFhirTask.GetLastModifiedST : TFslDateTime;
begin
  if FLastModified = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastModified.value;
end;

Procedure TFhirTask.SetLastModifiedST(value : TFslDateTime);
begin
  if FLastModified = nil then
    FLastModified := TFhirDateTime.create;
  FLastModified.value := value
end;

Procedure TFhirTask.SetRequester(value : TFhirReference{TFhirDevice});
begin
  FRequester.free;
  FRequester := value;
end;

Function TFhirTask.GetPerformerTypeList : TFhirCodeableConceptList;
begin
  if FPerformerTypeList = nil then
    FPerformerTypeList := TFhirCodeableConceptList.Create;
  result := FPerformerTypeList;
end;

Function TFhirTask.GetHasPerformerTypeList : boolean;
begin
  result := (FPerformerTypeList <> nil) and (FPerformerTypeList.count > 0);
end;

Procedure TFhirTask.SetOwner(value : TFhirReference{TFhirPractitioner});
begin
  FOwner.free;
  FOwner := value;
end;

Procedure TFhirTask.SetLocation(value : TFhirReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Procedure TFhirTask.SetReasonCode(value : TFhirCodeableConcept);
begin
  FReasonCode.free;
  FReasonCode := value;
end;

Procedure TFhirTask.SetReasonReference(value : TFhirReference{TFhirReference});
begin
  FReasonReference.free;
  FReasonReference := value;
end;

Function TFhirTask.GetInsuranceList : TFhirReferenceList{TFhirCoverage};
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirReferenceList{TFhirCoverage}.Create;
  result := FInsuranceList;
end;

Function TFhirTask.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

Function TFhirTask.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirTask.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirTask.GetRelevantHistoryList : TFhirReferenceList{TFhirProvenance};
begin
  if FRelevantHistoryList = nil then
    FRelevantHistoryList := TFhirReferenceList{TFhirProvenance}.Create;
  result := FRelevantHistoryList;
end;

Function TFhirTask.GetHasRelevantHistoryList : boolean;
begin
  result := (FRelevantHistoryList <> nil) and (FRelevantHistoryList.count > 0);
end;

Procedure TFhirTask.SetRestriction(value : TFhirTaskRestriction);
begin
  FRestriction.free;
  FRestriction := value;
end;

Function TFhirTask.GetInputList : TFhirTaskInputList;
begin
  if FInputList = nil then
    FInputList := TFhirTaskInputList.Create;
  result := FInputList;
end;

Function TFhirTask.GetHasInputList : boolean;
begin
  result := (FInputList <> nil) and (FInputList.count > 0);
end;

Function TFhirTask.GetOutputList : TFhirTaskOutputList;
begin
  if FOutputList = nil then
    FOutputList := TFhirTaskOutputList.Create;
  result := FOutputList;
end;

Function TFhirTask.GetHasOutputList : boolean;
begin
  result := (FOutputList <> nil) and (FOutputList.count > 0);
end;

function TFhirTask.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FInstantiatesCanonical.sizeInBytes);
  inc(result, FInstantiatesUri.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FGroupIdentifier.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStatusReason.sizeInBytes);
  inc(result, FBusinessStatus.sizeInBytes);
  inc(result, FIntent.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FFocus.sizeInBytes);
  inc(result, FFor_.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FExecutionPeriod.sizeInBytes);
  inc(result, FAuthoredOn.sizeInBytes);
  inc(result, FLastModified.sizeInBytes);
  inc(result, FRequester.sizeInBytes);
  inc(result, FperformerTypeList.sizeInBytes);
  inc(result, FOwner.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FReasonCode.sizeInBytes);
  inc(result, FReasonReference.sizeInBytes);
  inc(result, FinsuranceList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FrelevantHistoryList.sizeInBytes);
  inc(result, FRestriction.sizeInBytes);
  inc(result, FinputList.sizeInBytes);
  inc(result, FoutputList.sizeInBytes);
end;

{ TFhirTaskListEnumerator }

Constructor TFhirTaskListEnumerator.Create(list : TFhirTaskList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTaskListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTaskListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTaskListEnumerator.GetCurrent : TFhirTask;
begin
  Result := FList[FIndex];
end;

function TFhirTaskListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTaskList }
procedure TFhirTaskList.AddItem(value: TFhirTask);
begin
  assert(value.ClassName = 'TFhirTask', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTask');
  add(value);
end;

function TFhirTaskList.Append: TFhirTask;
begin
  result := TFhirTask.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskList.ClearItems;
begin
  Clear;
end;

function TFhirTaskList.GetEnumerator : TFhirTaskListEnumerator;
begin
  result := TFhirTaskListEnumerator.Create(self.link);
end;

function TFhirTaskList.Clone: TFhirTaskList;
begin
  result := TFhirTaskList(inherited Clone);
end;

function TFhirTaskList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTaskList.GetItemN(index: Integer): TFhirTask;
begin
  result := TFhirTask(ObjectByIndex[index]);
end;

function TFhirTaskList.ItemClass: TFslObjectClass;
begin
  result := TFhirTask;
end;
function TFhirTaskList.IndexOf(value: TFhirTask): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTaskList.Insert(index: Integer): TFhirTask;
begin
  result := TFhirTask.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskList.InsertItem(index: Integer; value: TFhirTask);
begin
  assert(value is TFhirTask);
  Inherited Insert(index, value);
end;

function TFhirTaskList.Item(index: Integer): TFhirTask;
begin
  result := TFhirTask(ObjectByIndex[index]);
end;

function TFhirTaskList.Link: TFhirTaskList;
begin
  result := TFhirTaskList(inherited Link);
end;

procedure TFhirTaskList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTaskList.SetItemByIndex(index: Integer; value: TFhirTask);
begin
  assert(value is TFhirTask);
  FhirTasks[index] := value;
end;

procedure TFhirTaskList.SetItemN(index: Integer; value: TFhirTask);
begin
  assert(value is TFhirTask);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_TASK}

{$IFDEF FHIR_TESTREPORT}

{ TFhirTestReportParticipant }

constructor TFhirTestReportParticipant.Create;
begin
  inherited;
end;

destructor TFhirTestReportParticipant.Destroy;
begin
  FType_.free;
  FUri.free;
  FDisplay.free;
  inherited;
end;

procedure TFhirTestReportParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirTestReportParticipant(oSource).FType_.Link;
  uriElement := TFhirTestReportParticipant(oSource).uriElement.Clone;
  displayElement := TFhirTestReportParticipant(oSource).displayElement.Clone;
end;

procedure TFhirTestReportParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'uri') Then
     list.add(self.link, 'uri', FUri.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
end;

procedure TFhirTestReportParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'uri', 'uri', false, TFhirUri, FUri.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));{2}
end;

function TFhirTestReportParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirReportParticipantTypeEnum, CODES_TFhirReportParticipantTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'uri') then
  begin
    UriElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'uri') then result := TFhirUri.create() {5b}
  else if (propName = 'display') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'uri') then result := 'uri'
  else if (propName = 'display') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'uri') then UriElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirReportParticipantTypeEnum, CODES_TFhirReportParticipantTypeEnum, new){4}
  else if (propName = 'uri') then UriElement := asUri(new){5b}
  else if (propName = 'display') then DisplayElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportParticipant.fhirType : string;
begin
  result := 'participant';
end;

function TFhirTestReportParticipant.Link : TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant(inherited Link);
end;

function TFhirTestReportParticipant.Clone : TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant(inherited Clone);
end;

function TFhirTestReportParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportParticipant)) then
    result := false
  else
  begin
    o := TFhirTestReportParticipant(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(uriElement, o.uriElement, true) and 
      compareDeep(displayElement, o.displayElement, true);
  end;
end;

function TFhirTestReportParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FUri) and isEmptyProp(FDisplay);
end;

procedure TFhirTestReportParticipant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('uri');
  fields.add('display');
end;

{ TFhirTestReportParticipant }

Procedure TFhirTestReportParticipant.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirTestReportParticipant.GetType_ST : TFhirReportParticipantTypeEnum;
begin
  if FType_ = nil then
    result := TFhirReportParticipantTypeEnum(0)
  else
    result := TFhirReportParticipantTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirReportParticipantTypeEnum, FType_.value));
end;

Procedure TFhirTestReportParticipant.SetType_ST(value : TFhirReportParticipantTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirReportParticipantTypeEnum[value], CODES_TFhirReportParticipantTypeEnum[value]);
end;

Procedure TFhirTestReportParticipant.SetUri(value : TFhirUri);
begin
  FUri.free;
  FUri := value;
end;

Function TFhirTestReportParticipant.GetUriST : String;
begin
  if FUri = nil then
    result := ''
  else
    result := FUri.value;
end;

Procedure TFhirTestReportParticipant.SetUriST(value : String);
begin
  if value <> '' then
  begin
    if FUri = nil then
      FUri := TFhirUri.create;
    FUri.value := value
  end
  else if FUri <> nil then
    FUri.value := '';
end;

Procedure TFhirTestReportParticipant.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirTestReportParticipant.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirTestReportParticipant.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

function TFhirTestReportParticipant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FUri.sizeInBytes);
  inc(result, FDisplay.sizeInBytes);
end;

{ TFhirTestReportParticipantListEnumerator }

Constructor TFhirTestReportParticipantListEnumerator.Create(list : TFhirTestReportParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportParticipantListEnumerator.GetCurrent : TFhirTestReportParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportParticipantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestReportParticipantList }
procedure TFhirTestReportParticipantList.AddItem(value: TFhirTestReportParticipant);
begin
  assert(value.ClassName = 'TFhirTestReportParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportParticipant');
  add(value);
end;

function TFhirTestReportParticipantList.Append: TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportParticipantList.GetEnumerator : TFhirTestReportParticipantListEnumerator;
begin
  result := TFhirTestReportParticipantListEnumerator.Create(self.link);
end;

function TFhirTestReportParticipantList.Clone: TFhirTestReportParticipantList;
begin
  result := TFhirTestReportParticipantList(inherited Clone);
end;

function TFhirTestReportParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportParticipantList.GetItemN(index: Integer): TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant(ObjectByIndex[index]);
end;

function TFhirTestReportParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportParticipant;
end;
function TFhirTestReportParticipantList.IndexOf(value: TFhirTestReportParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportParticipantList.Insert(index: Integer): TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportParticipantList.InsertItem(index: Integer; value: TFhirTestReportParticipant);
begin
  assert(value is TFhirTestReportParticipant);
  Inherited Insert(index, value);
end;

function TFhirTestReportParticipantList.Item(index: Integer): TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant(ObjectByIndex[index]);
end;

function TFhirTestReportParticipantList.Link: TFhirTestReportParticipantList;
begin
  result := TFhirTestReportParticipantList(inherited Link);
end;

procedure TFhirTestReportParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportParticipantList.SetItemByIndex(index: Integer; value: TFhirTestReportParticipant);
begin
  assert(value is TFhirTestReportParticipant);
  FhirTestReportParticipants[index] := value;
end;

procedure TFhirTestReportParticipantList.SetItemN(index: Integer; value: TFhirTestReportParticipant);
begin
  assert(value is TFhirTestReportParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportSetup }

constructor TFhirTestReportSetup.Create;
begin
  inherited;
end;

destructor TFhirTestReportSetup.Destroy;
begin
  FActionList.Free;
  inherited;
end;

procedure TFhirTestReportSetup.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTestReportSetup(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestReportSetupActionList.Create;
    FActionList.Assign(TFhirTestReportSetup(oSource).FActionList);
  end;
end;

procedure TFhirTestReportSetup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestReportSetup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirTestReportSetupAction, FActionList.Link)){3};
end;

function TFhirTestReportSetup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestReportSetupAction){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportSetup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestReportSetupAction){2a}
  else inherited;
end;

function TFhirTestReportSetup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := ActionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportSetup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportSetup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportSetup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportSetup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportSetup.fhirType : string;
begin
  result := 'setup';
end;

function TFhirTestReportSetup.Link : TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup(inherited Link);
end;

function TFhirTestReportSetup.Clone : TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup(inherited Clone);
end;

function TFhirTestReportSetup.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportSetup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportSetup)) then
    result := false
  else
  begin
    o := TFhirTestReportSetup(other);
    result := compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestReportSetup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FactionList);
end;

procedure TFhirTestReportSetup.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('action');
end;

{ TFhirTestReportSetup }

Function TFhirTestReportSetup.GetActionList : TFhirTestReportSetupActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestReportSetupActionList.Create;
  result := FActionList;
end;

Function TFhirTestReportSetup.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirTestReportSetup.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FactionList.sizeInBytes);
end;

{ TFhirTestReportSetupListEnumerator }

Constructor TFhirTestReportSetupListEnumerator.Create(list : TFhirTestReportSetupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportSetupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportSetupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportSetupListEnumerator.GetCurrent : TFhirTestReportSetup;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportSetupListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestReportSetupList }
procedure TFhirTestReportSetupList.AddItem(value: TFhirTestReportSetup);
begin
  assert(value.ClassName = 'TFhirTestReportSetup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportSetup');
  add(value);
end;

function TFhirTestReportSetupList.Append: TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportSetupList.GetEnumerator : TFhirTestReportSetupListEnumerator;
begin
  result := TFhirTestReportSetupListEnumerator.Create(self.link);
end;

function TFhirTestReportSetupList.Clone: TFhirTestReportSetupList;
begin
  result := TFhirTestReportSetupList(inherited Clone);
end;

function TFhirTestReportSetupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportSetupList.GetItemN(index: Integer): TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup(ObjectByIndex[index]);
end;

function TFhirTestReportSetupList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportSetup;
end;
function TFhirTestReportSetupList.IndexOf(value: TFhirTestReportSetup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportSetupList.Insert(index: Integer): TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupList.InsertItem(index: Integer; value: TFhirTestReportSetup);
begin
  assert(value is TFhirTestReportSetup);
  Inherited Insert(index, value);
end;

function TFhirTestReportSetupList.Item(index: Integer): TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup(ObjectByIndex[index]);
end;

function TFhirTestReportSetupList.Link: TFhirTestReportSetupList;
begin
  result := TFhirTestReportSetupList(inherited Link);
end;

procedure TFhirTestReportSetupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportSetupList.SetItemByIndex(index: Integer; value: TFhirTestReportSetup);
begin
  assert(value is TFhirTestReportSetup);
  FhirTestReportSetups[index] := value;
end;

procedure TFhirTestReportSetupList.SetItemN(index: Integer; value: TFhirTestReportSetup);
begin
  assert(value is TFhirTestReportSetup);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportSetupAction }

constructor TFhirTestReportSetupAction.Create;
begin
  inherited;
end;

destructor TFhirTestReportSetupAction.Destroy;
begin
  FOperation.free;
  FAssert.free;
  inherited;
end;

procedure TFhirTestReportSetupAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestReportSetupAction(oSource).operation.Clone;
  assert := TFhirTestReportSetupAction(oSource).assert.Clone;
end;

procedure TFhirTestReportSetupAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
  if (child_name = 'assert') Then
     list.add(self.link, 'assert', FAssert.Link);
end;

procedure TFhirTestReportSetupAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', '', false, TFhirTestReportSetupActionOperation, FOperation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'assert', '', false, TFhirTestReportSetupActionAssert, FAssert.Link));{2}
end;

function TFhirTestReportSetupAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestReportSetupActionOperation{4b};
    result := propValue;
  end
  else if (propName = 'assert') then
  begin
    Assert := propValue as TFhirTestReportSetupActionAssert{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportSetupAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportSetupAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestReportSetupActionOperation.create(){4b}
  else if (propName = 'assert') then result := TFhirTestReportSetupActionAssert.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportSetupAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := ''
  else if (propName = 'assert') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportSetupAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else if (propName = 'assert') then AssertElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportSetupAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestReportSetupActionOperation{4}
  else if (propName = 'assert') then AssertElement := new as TFhirTestReportSetupActionAssert{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportSetupAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportSetupAction.fhirType : string;
begin
  result := 'action';
end;

function TFhirTestReportSetupAction.Link : TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction(inherited Link);
end;

function TFhirTestReportSetupAction.Clone : TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction(inherited Clone);
end;

function TFhirTestReportSetupAction.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportSetupAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportSetupAction)) then
    result := false
  else
  begin
    o := TFhirTestReportSetupAction(other);
    result := compareDeep(operationElement, o.operationElement, true) and compareDeep(assertElement, o.assertElement, true);
  end;
end;

function TFhirTestReportSetupAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation) and isEmptyProp(FAssert);
end;

procedure TFhirTestReportSetupAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('operation');
  fields.add('assert');
end;

{ TFhirTestReportSetupAction }

Procedure TFhirTestReportSetupAction.SetOperation(value : TFhirTestReportSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

Procedure TFhirTestReportSetupAction.SetAssert(value : TFhirTestReportSetupActionAssert);
begin
  FAssert.free;
  FAssert := value;
end;

function TFhirTestReportSetupAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOperation.sizeInBytes);
  inc(result, FAssert.sizeInBytes);
end;

{ TFhirTestReportSetupActionListEnumerator }

Constructor TFhirTestReportSetupActionListEnumerator.Create(list : TFhirTestReportSetupActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportSetupActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportSetupActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportSetupActionListEnumerator.GetCurrent : TFhirTestReportSetupAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportSetupActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestReportSetupActionList }
procedure TFhirTestReportSetupActionList.AddItem(value: TFhirTestReportSetupAction);
begin
  assert(value.ClassName = 'TFhirTestReportSetupAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportSetupAction');
  add(value);
end;

function TFhirTestReportSetupActionList.Append: TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportSetupActionList.GetEnumerator : TFhirTestReportSetupActionListEnumerator;
begin
  result := TFhirTestReportSetupActionListEnumerator.Create(self.link);
end;

function TFhirTestReportSetupActionList.Clone: TFhirTestReportSetupActionList;
begin
  result := TFhirTestReportSetupActionList(inherited Clone);
end;

function TFhirTestReportSetupActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportSetupActionList.GetItemN(index: Integer): TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportSetupAction;
end;
function TFhirTestReportSetupActionList.IndexOf(value: TFhirTestReportSetupAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportSetupActionList.Insert(index: Integer): TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionList.InsertItem(index: Integer; value: TFhirTestReportSetupAction);
begin
  assert(value is TFhirTestReportSetupAction);
  Inherited Insert(index, value);
end;

function TFhirTestReportSetupActionList.Item(index: Integer): TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionList.Link: TFhirTestReportSetupActionList;
begin
  result := TFhirTestReportSetupActionList(inherited Link);
end;

procedure TFhirTestReportSetupActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportSetupActionList.SetItemByIndex(index: Integer; value: TFhirTestReportSetupAction);
begin
  assert(value is TFhirTestReportSetupAction);
  FhirTestReportSetupActions[index] := value;
end;

procedure TFhirTestReportSetupActionList.SetItemN(index: Integer; value: TFhirTestReportSetupAction);
begin
  assert(value is TFhirTestReportSetupAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportSetupActionOperation }

constructor TFhirTestReportSetupActionOperation.Create;
begin
  inherited;
end;

destructor TFhirTestReportSetupActionOperation.Destroy;
begin
  FResult.free;
  FMessage.free;
  FDetail.free;
  inherited;
end;

procedure TFhirTestReportSetupActionOperation.Assign(oSource : TFslObject);
begin
  inherited;
  FResult := TFhirTestReportSetupActionOperation(oSource).FResult.Link;
  messageElement := TFhirTestReportSetupActionOperation(oSource).messageElement.Clone;
  detailElement := TFhirTestReportSetupActionOperation(oSource).detailElement.Clone;
end;

procedure TFhirTestReportSetupActionOperation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'result') Then
     list.add(self.link, 'result', FResult.Link);
  if (child_name = 'message') Then
     list.add(self.link, 'message', FMessage.Link);
  if (child_name = 'detail') Then
     list.add(self.link, 'detail', FDetail.Link);
end;

procedure TFhirTestReportSetupActionOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'result', 'code', false, TFHIREnum, FResult.Link));{1}
  oList.add(TFHIRProperty.create(self, 'message', 'markdown', false, TFhirMarkdown, FMessage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'uri', false, TFhirUri, FDetail.Link));{2}
end;

function TFhirTestReportSetupActionOperation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'result') then
  begin
    ResultElement := asEnum(SYSTEMS_TFhirReportActionResultCodesEnum, CODES_TFhirReportActionResultCodesEnum, propValue);
    result := propValue
  end
  else if (propName = 'message') then
  begin
    MessageElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportSetupActionOperation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportSetupActionOperation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'message') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'detail') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportSetupActionOperation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'result') then result := 'code'
  else if (propName = 'message') then result := 'markdown'
  else if (propName = 'detail') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportSetupActionOperation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'result') then ResultElement := nil
  else if (propName = 'message') then MessageElement := nil
  else if (propName = 'detail') then DetailElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportSetupActionOperation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'result') then ResultElement := asEnum(SYSTEMS_TFhirReportActionResultCodesEnum, CODES_TFhirReportActionResultCodesEnum, new){4}
  else if (propName = 'message') then MessageElement := asMarkdown(new){5b}
  else if (propName = 'detail') then DetailElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportSetupActionOperation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportSetupActionOperation.fhirType : string;
begin
  result := 'operation';
end;

function TFhirTestReportSetupActionOperation.Link : TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation(inherited Link);
end;

function TFhirTestReportSetupActionOperation.Clone : TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation(inherited Clone);
end;

function TFhirTestReportSetupActionOperation.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportSetupActionOperation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportSetupActionOperation)) then
    result := false
  else
  begin
    o := TFhirTestReportSetupActionOperation(other);
    result := compareDeep(resultElement, o.resultElement, true) and compareDeep(messageElement, o.messageElement, true) and 
      compareDeep(detailElement, o.detailElement, true);
  end;
end;

function TFhirTestReportSetupActionOperation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FResult) and isEmptyProp(FMessage) and isEmptyProp(FDetail);
end;

procedure TFhirTestReportSetupActionOperation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('result');
  fields.add('message');
  fields.add('detail');
end;

{ TFhirTestReportSetupActionOperation }

Procedure TFhirTestReportSetupActionOperation.SetResult(value : TFhirEnum);
begin
  FResult.free;
  FResult := value;
end;

Function TFhirTestReportSetupActionOperation.GetResultST : TFhirReportActionResultCodesEnum;
begin
  if FResult = nil then
    result := TFhirReportActionResultCodesEnum(0)
  else
    result := TFhirReportActionResultCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirReportActionResultCodesEnum, FResult.value));
end;

Procedure TFhirTestReportSetupActionOperation.SetResultST(value : TFhirReportActionResultCodesEnum);
begin
  if ord(value) = 0 then
    ResultElement := nil
  else
    ResultElement := TFhirEnum.create(SYSTEMS_TFhirReportActionResultCodesEnum[value], CODES_TFhirReportActionResultCodesEnum[value]);
end;

Procedure TFhirTestReportSetupActionOperation.SetMessage(value : TFhirMarkdown);
begin
  FMessage.free;
  FMessage := value;
end;

Function TFhirTestReportSetupActionOperation.GetMessageST : String;
begin
  if FMessage = nil then
    result := ''
  else
    result := FMessage.value;
end;

Procedure TFhirTestReportSetupActionOperation.SetMessageST(value : String);
begin
  if value <> '' then
  begin
    if FMessage = nil then
      FMessage := TFhirMarkdown.create;
    FMessage.value := value
  end
  else if FMessage <> nil then
    FMessage.value := '';
end;

Procedure TFhirTestReportSetupActionOperation.SetDetail(value : TFhirUri);
begin
  FDetail.free;
  FDetail := value;
end;

Function TFhirTestReportSetupActionOperation.GetDetailST : String;
begin
  if FDetail = nil then
    result := ''
  else
    result := FDetail.value;
end;

Procedure TFhirTestReportSetupActionOperation.SetDetailST(value : String);
begin
  if value <> '' then
  begin
    if FDetail = nil then
      FDetail := TFhirUri.create;
    FDetail.value := value
  end
  else if FDetail <> nil then
    FDetail.value := '';
end;

function TFhirTestReportSetupActionOperation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FResult.sizeInBytes);
  inc(result, FMessage.sizeInBytes);
  inc(result, FDetail.sizeInBytes);
end;

{ TFhirTestReportSetupActionOperationListEnumerator }

Constructor TFhirTestReportSetupActionOperationListEnumerator.Create(list : TFhirTestReportSetupActionOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportSetupActionOperationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportSetupActionOperationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportSetupActionOperationListEnumerator.GetCurrent : TFhirTestReportSetupActionOperation;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportSetupActionOperationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestReportSetupActionOperationList }
procedure TFhirTestReportSetupActionOperationList.AddItem(value: TFhirTestReportSetupActionOperation);
begin
  assert(value.ClassName = 'TFhirTestReportSetupActionOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportSetupActionOperation');
  add(value);
end;

function TFhirTestReportSetupActionOperationList.Append: TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionOperationList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportSetupActionOperationList.GetEnumerator : TFhirTestReportSetupActionOperationListEnumerator;
begin
  result := TFhirTestReportSetupActionOperationListEnumerator.Create(self.link);
end;

function TFhirTestReportSetupActionOperationList.Clone: TFhirTestReportSetupActionOperationList;
begin
  result := TFhirTestReportSetupActionOperationList(inherited Clone);
end;

function TFhirTestReportSetupActionOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportSetupActionOperationList.GetItemN(index: Integer): TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionOperationList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportSetupActionOperation;
end;
function TFhirTestReportSetupActionOperationList.IndexOf(value: TFhirTestReportSetupActionOperation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportSetupActionOperationList.Insert(index: Integer): TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionOperationList.InsertItem(index: Integer; value: TFhirTestReportSetupActionOperation);
begin
  assert(value is TFhirTestReportSetupActionOperation);
  Inherited Insert(index, value);
end;

function TFhirTestReportSetupActionOperationList.Item(index: Integer): TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionOperationList.Link: TFhirTestReportSetupActionOperationList;
begin
  result := TFhirTestReportSetupActionOperationList(inherited Link);
end;

procedure TFhirTestReportSetupActionOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportSetupActionOperationList.SetItemByIndex(index: Integer; value: TFhirTestReportSetupActionOperation);
begin
  assert(value is TFhirTestReportSetupActionOperation);
  FhirTestReportSetupActionOperations[index] := value;
end;

procedure TFhirTestReportSetupActionOperationList.SetItemN(index: Integer; value: TFhirTestReportSetupActionOperation);
begin
  assert(value is TFhirTestReportSetupActionOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportSetupActionAssert }

constructor TFhirTestReportSetupActionAssert.Create;
begin
  inherited;
end;

destructor TFhirTestReportSetupActionAssert.Destroy;
begin
  FResult.free;
  FMessage.free;
  FDetail.free;
  inherited;
end;

procedure TFhirTestReportSetupActionAssert.Assign(oSource : TFslObject);
begin
  inherited;
  FResult := TFhirTestReportSetupActionAssert(oSource).FResult.Link;
  messageElement := TFhirTestReportSetupActionAssert(oSource).messageElement.Clone;
  detailElement := TFhirTestReportSetupActionAssert(oSource).detailElement.Clone;
end;

procedure TFhirTestReportSetupActionAssert.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'result') Then
     list.add(self.link, 'result', FResult.Link);
  if (child_name = 'message') Then
     list.add(self.link, 'message', FMessage.Link);
  if (child_name = 'detail') Then
     list.add(self.link, 'detail', FDetail.Link);
end;

procedure TFhirTestReportSetupActionAssert.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'result', 'code', false, TFHIREnum, FResult.Link));{1}
  oList.add(TFHIRProperty.create(self, 'message', 'markdown', false, TFhirMarkdown, FMessage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'string', false, TFhirString, FDetail.Link));{2}
end;

function TFhirTestReportSetupActionAssert.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'result') then
  begin
    ResultElement := asEnum(SYSTEMS_TFhirReportActionResultCodesEnum, CODES_TFhirReportActionResultCodesEnum, propValue);
    result := propValue
  end
  else if (propName = 'message') then
  begin
    MessageElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportSetupActionAssert.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportSetupActionAssert.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'message') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'detail') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportSetupActionAssert.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'result') then result := 'code'
  else if (propName = 'message') then result := 'markdown'
  else if (propName = 'detail') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportSetupActionAssert.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'result') then ResultElement := nil
  else if (propName = 'message') then MessageElement := nil
  else if (propName = 'detail') then DetailElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportSetupActionAssert.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'result') then ResultElement := asEnum(SYSTEMS_TFhirReportActionResultCodesEnum, CODES_TFhirReportActionResultCodesEnum, new){4}
  else if (propName = 'message') then MessageElement := asMarkdown(new){5b}
  else if (propName = 'detail') then DetailElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportSetupActionAssert.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportSetupActionAssert.fhirType : string;
begin
  result := 'assert';
end;

function TFhirTestReportSetupActionAssert.Link : TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert(inherited Link);
end;

function TFhirTestReportSetupActionAssert.Clone : TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert(inherited Clone);
end;

function TFhirTestReportSetupActionAssert.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportSetupActionAssert;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportSetupActionAssert)) then
    result := false
  else
  begin
    o := TFhirTestReportSetupActionAssert(other);
    result := compareDeep(resultElement, o.resultElement, true) and compareDeep(messageElement, o.messageElement, true) and 
      compareDeep(detailElement, o.detailElement, true);
  end;
end;

function TFhirTestReportSetupActionAssert.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FResult) and isEmptyProp(FMessage) and isEmptyProp(FDetail);
end;

procedure TFhirTestReportSetupActionAssert.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('result');
  fields.add('message');
  fields.add('detail');
end;

{ TFhirTestReportSetupActionAssert }

Procedure TFhirTestReportSetupActionAssert.SetResult(value : TFhirEnum);
begin
  FResult.free;
  FResult := value;
end;

Function TFhirTestReportSetupActionAssert.GetResultST : TFhirReportActionResultCodesEnum;
begin
  if FResult = nil then
    result := TFhirReportActionResultCodesEnum(0)
  else
    result := TFhirReportActionResultCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirReportActionResultCodesEnum, FResult.value));
end;

Procedure TFhirTestReportSetupActionAssert.SetResultST(value : TFhirReportActionResultCodesEnum);
begin
  if ord(value) = 0 then
    ResultElement := nil
  else
    ResultElement := TFhirEnum.create(SYSTEMS_TFhirReportActionResultCodesEnum[value], CODES_TFhirReportActionResultCodesEnum[value]);
end;

Procedure TFhirTestReportSetupActionAssert.SetMessage(value : TFhirMarkdown);
begin
  FMessage.free;
  FMessage := value;
end;

Function TFhirTestReportSetupActionAssert.GetMessageST : String;
begin
  if FMessage = nil then
    result := ''
  else
    result := FMessage.value;
end;

Procedure TFhirTestReportSetupActionAssert.SetMessageST(value : String);
begin
  if value <> '' then
  begin
    if FMessage = nil then
      FMessage := TFhirMarkdown.create;
    FMessage.value := value
  end
  else if FMessage <> nil then
    FMessage.value := '';
end;

Procedure TFhirTestReportSetupActionAssert.SetDetail(value : TFhirString);
begin
  FDetail.free;
  FDetail := value;
end;

Function TFhirTestReportSetupActionAssert.GetDetailST : String;
begin
  if FDetail = nil then
    result := ''
  else
    result := FDetail.value;
end;

Procedure TFhirTestReportSetupActionAssert.SetDetailST(value : String);
begin
  if value <> '' then
  begin
    if FDetail = nil then
      FDetail := TFhirString.create;
    FDetail.value := value
  end
  else if FDetail <> nil then
    FDetail.value := '';
end;

function TFhirTestReportSetupActionAssert.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FResult.sizeInBytes);
  inc(result, FMessage.sizeInBytes);
  inc(result, FDetail.sizeInBytes);
end;

{ TFhirTestReportSetupActionAssertListEnumerator }

Constructor TFhirTestReportSetupActionAssertListEnumerator.Create(list : TFhirTestReportSetupActionAssertList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportSetupActionAssertListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportSetupActionAssertListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportSetupActionAssertListEnumerator.GetCurrent : TFhirTestReportSetupActionAssert;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportSetupActionAssertListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestReportSetupActionAssertList }
procedure TFhirTestReportSetupActionAssertList.AddItem(value: TFhirTestReportSetupActionAssert);
begin
  assert(value.ClassName = 'TFhirTestReportSetupActionAssert', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportSetupActionAssert');
  add(value);
end;

function TFhirTestReportSetupActionAssertList.Append: TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionAssertList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportSetupActionAssertList.GetEnumerator : TFhirTestReportSetupActionAssertListEnumerator;
begin
  result := TFhirTestReportSetupActionAssertListEnumerator.Create(self.link);
end;

function TFhirTestReportSetupActionAssertList.Clone: TFhirTestReportSetupActionAssertList;
begin
  result := TFhirTestReportSetupActionAssertList(inherited Clone);
end;

function TFhirTestReportSetupActionAssertList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportSetupActionAssertList.GetItemN(index: Integer): TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionAssertList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportSetupActionAssert;
end;
function TFhirTestReportSetupActionAssertList.IndexOf(value: TFhirTestReportSetupActionAssert): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportSetupActionAssertList.Insert(index: Integer): TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionAssertList.InsertItem(index: Integer; value: TFhirTestReportSetupActionAssert);
begin
  assert(value is TFhirTestReportSetupActionAssert);
  Inherited Insert(index, value);
end;

function TFhirTestReportSetupActionAssertList.Item(index: Integer): TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionAssertList.Link: TFhirTestReportSetupActionAssertList;
begin
  result := TFhirTestReportSetupActionAssertList(inherited Link);
end;

procedure TFhirTestReportSetupActionAssertList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportSetupActionAssertList.SetItemByIndex(index: Integer; value: TFhirTestReportSetupActionAssert);
begin
  assert(value is TFhirTestReportSetupActionAssert);
  FhirTestReportSetupActionAsserts[index] := value;
end;

procedure TFhirTestReportSetupActionAssertList.SetItemN(index: Integer; value: TFhirTestReportSetupActionAssert);
begin
  assert(value is TFhirTestReportSetupActionAssert);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportTest }

constructor TFhirTestReportTest.Create;
begin
  inherited;
end;

destructor TFhirTestReportTest.Destroy;
begin
  FName.free;
  FDescription.free;
  FActionList.Free;
  inherited;
end;

procedure TFhirTestReportTest.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirTestReportTest(oSource).nameElement.Clone;
  descriptionElement := TFhirTestReportTest(oSource).descriptionElement.Clone;
  if (TFhirTestReportTest(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestReportTestActionList.Create;
    FActionList.Assign(TFhirTestReportTest(oSource).FActionList);
  end;
end;

procedure TFhirTestReportTest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestReportTest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirTestReportTestAction, FActionList.Link)){3};
end;

function TFhirTestReportTest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestReportTestAction){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportTest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestReportTestAction){2a}
  else inherited;
end;

function TFhirTestReportTest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'action') then result := ActionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportTest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'action') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportTest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportTest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportTest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportTest.fhirType : string;
begin
  result := 'test';
end;

function TFhirTestReportTest.Link : TFhirTestReportTest;
begin
  result := TFhirTestReportTest(inherited Link);
end;

function TFhirTestReportTest.Clone : TFhirTestReportTest;
begin
  result := TFhirTestReportTest(inherited Clone);
end;

function TFhirTestReportTest.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportTest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportTest)) then
    result := false
  else
  begin
    o := TFhirTestReportTest(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestReportTest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FactionList);
end;

procedure TFhirTestReportTest.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('description');
  fields.add('action');
end;

{ TFhirTestReportTest }

Procedure TFhirTestReportTest.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirTestReportTest.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirTestReportTest.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirTestReportTest.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirTestReportTest.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirTestReportTest.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirTestReportTest.GetActionList : TFhirTestReportTestActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestReportTestActionList.Create;
  result := FActionList;
end;

Function TFhirTestReportTest.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirTestReportTest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
end;

{ TFhirTestReportTestListEnumerator }

Constructor TFhirTestReportTestListEnumerator.Create(list : TFhirTestReportTestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportTestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportTestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportTestListEnumerator.GetCurrent : TFhirTestReportTest;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportTestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestReportTestList }
procedure TFhirTestReportTestList.AddItem(value: TFhirTestReportTest);
begin
  assert(value.ClassName = 'TFhirTestReportTest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportTest');
  add(value);
end;

function TFhirTestReportTestList.Append: TFhirTestReportTest;
begin
  result := TFhirTestReportTest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTestList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportTestList.GetEnumerator : TFhirTestReportTestListEnumerator;
begin
  result := TFhirTestReportTestListEnumerator.Create(self.link);
end;

function TFhirTestReportTestList.Clone: TFhirTestReportTestList;
begin
  result := TFhirTestReportTestList(inherited Clone);
end;

function TFhirTestReportTestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportTestList.GetItemN(index: Integer): TFhirTestReportTest;
begin
  result := TFhirTestReportTest(ObjectByIndex[index]);
end;

function TFhirTestReportTestList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportTest;
end;
function TFhirTestReportTestList.IndexOf(value: TFhirTestReportTest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportTestList.Insert(index: Integer): TFhirTestReportTest;
begin
  result := TFhirTestReportTest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTestList.InsertItem(index: Integer; value: TFhirTestReportTest);
begin
  assert(value is TFhirTestReportTest);
  Inherited Insert(index, value);
end;

function TFhirTestReportTestList.Item(index: Integer): TFhirTestReportTest;
begin
  result := TFhirTestReportTest(ObjectByIndex[index]);
end;

function TFhirTestReportTestList.Link: TFhirTestReportTestList;
begin
  result := TFhirTestReportTestList(inherited Link);
end;

procedure TFhirTestReportTestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportTestList.SetItemByIndex(index: Integer; value: TFhirTestReportTest);
begin
  assert(value is TFhirTestReportTest);
  FhirTestReportTests[index] := value;
end;

procedure TFhirTestReportTestList.SetItemN(index: Integer; value: TFhirTestReportTest);
begin
  assert(value is TFhirTestReportTest);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportTestAction }

constructor TFhirTestReportTestAction.Create;
begin
  inherited;
end;

destructor TFhirTestReportTestAction.Destroy;
begin
  FOperation.free;
  FAssert.free;
  inherited;
end;

procedure TFhirTestReportTestAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestReportTestAction(oSource).operation.Clone;
  assert := TFhirTestReportTestAction(oSource).assert.Clone;
end;

procedure TFhirTestReportTestAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
  if (child_name = 'assert') Then
     list.add(self.link, 'assert', FAssert.Link);
end;

procedure TFhirTestReportTestAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', '@TestReport.setup.action.operation', false, TFhirTestReportSetupActionOperation, FOperation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'assert', '@TestReport.setup.action.assert', false, TFhirTestReportSetupActionAssert, FAssert.Link));{2}
end;

function TFhirTestReportTestAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestReportSetupActionOperation{4b};
    result := propValue;
  end
  else if (propName = 'assert') then
  begin
    Assert := propValue as TFhirTestReportSetupActionAssert{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportTestAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportTestAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestReportSetupActionOperation.create(){4b}
  else if (propName = 'assert') then result := TFhirTestReportSetupActionAssert.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportTestAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := '@TestReport.setup.action.operation'
  else if (propName = 'assert') then result := '@TestReport.setup.action.assert'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportTestAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else if (propName = 'assert') then AssertElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportTestAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestReportSetupActionOperation{4}
  else if (propName = 'assert') then AssertElement := new as TFhirTestReportSetupActionAssert{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportTestAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportTestAction.fhirType : string;
begin
  result := 'action';
end;

function TFhirTestReportTestAction.Link : TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction(inherited Link);
end;

function TFhirTestReportTestAction.Clone : TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction(inherited Clone);
end;

function TFhirTestReportTestAction.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportTestAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportTestAction)) then
    result := false
  else
  begin
    o := TFhirTestReportTestAction(other);
    result := compareDeep(operationElement, o.operationElement, true) and compareDeep(assertElement, o.assertElement, true);
  end;
end;

function TFhirTestReportTestAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation) and isEmptyProp(FAssert);
end;

procedure TFhirTestReportTestAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('operation');
  fields.add('assert');
end;

{ TFhirTestReportTestAction }

Procedure TFhirTestReportTestAction.SetOperation(value : TFhirTestReportSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

Procedure TFhirTestReportTestAction.SetAssert(value : TFhirTestReportSetupActionAssert);
begin
  FAssert.free;
  FAssert := value;
end;

function TFhirTestReportTestAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOperation.sizeInBytes);
  inc(result, FAssert.sizeInBytes);
end;

{ TFhirTestReportTestActionListEnumerator }

Constructor TFhirTestReportTestActionListEnumerator.Create(list : TFhirTestReportTestActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportTestActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportTestActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportTestActionListEnumerator.GetCurrent : TFhirTestReportTestAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportTestActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestReportTestActionList }
procedure TFhirTestReportTestActionList.AddItem(value: TFhirTestReportTestAction);
begin
  assert(value.ClassName = 'TFhirTestReportTestAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportTestAction');
  add(value);
end;

function TFhirTestReportTestActionList.Append: TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTestActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportTestActionList.GetEnumerator : TFhirTestReportTestActionListEnumerator;
begin
  result := TFhirTestReportTestActionListEnumerator.Create(self.link);
end;

function TFhirTestReportTestActionList.Clone: TFhirTestReportTestActionList;
begin
  result := TFhirTestReportTestActionList(inherited Clone);
end;

function TFhirTestReportTestActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportTestActionList.GetItemN(index: Integer): TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction(ObjectByIndex[index]);
end;

function TFhirTestReportTestActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportTestAction;
end;
function TFhirTestReportTestActionList.IndexOf(value: TFhirTestReportTestAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportTestActionList.Insert(index: Integer): TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTestActionList.InsertItem(index: Integer; value: TFhirTestReportTestAction);
begin
  assert(value is TFhirTestReportTestAction);
  Inherited Insert(index, value);
end;

function TFhirTestReportTestActionList.Item(index: Integer): TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction(ObjectByIndex[index]);
end;

function TFhirTestReportTestActionList.Link: TFhirTestReportTestActionList;
begin
  result := TFhirTestReportTestActionList(inherited Link);
end;

procedure TFhirTestReportTestActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportTestActionList.SetItemByIndex(index: Integer; value: TFhirTestReportTestAction);
begin
  assert(value is TFhirTestReportTestAction);
  FhirTestReportTestActions[index] := value;
end;

procedure TFhirTestReportTestActionList.SetItemN(index: Integer; value: TFhirTestReportTestAction);
begin
  assert(value is TFhirTestReportTestAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportTeardown }

constructor TFhirTestReportTeardown.Create;
begin
  inherited;
end;

destructor TFhirTestReportTeardown.Destroy;
begin
  FActionList.Free;
  inherited;
end;

procedure TFhirTestReportTeardown.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTestReportTeardown(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestReportTeardownActionList.Create;
    FActionList.Assign(TFhirTestReportTeardown(oSource).FActionList);
  end;
end;

procedure TFhirTestReportTeardown.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestReportTeardown.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirTestReportTeardownAction, FActionList.Link)){3};
end;

function TFhirTestReportTeardown.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestReportTeardownAction){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportTeardown.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestReportTeardownAction){2a}
  else inherited;
end;

function TFhirTestReportTeardown.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := ActionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportTeardown.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportTeardown.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportTeardown.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportTeardown.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportTeardown.fhirType : string;
begin
  result := 'teardown';
end;

function TFhirTestReportTeardown.Link : TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown(inherited Link);
end;

function TFhirTestReportTeardown.Clone : TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown(inherited Clone);
end;

function TFhirTestReportTeardown.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportTeardown;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportTeardown)) then
    result := false
  else
  begin
    o := TFhirTestReportTeardown(other);
    result := compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestReportTeardown.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FactionList);
end;

procedure TFhirTestReportTeardown.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('action');
end;

{ TFhirTestReportTeardown }

Function TFhirTestReportTeardown.GetActionList : TFhirTestReportTeardownActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestReportTeardownActionList.Create;
  result := FActionList;
end;

Function TFhirTestReportTeardown.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirTestReportTeardown.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FactionList.sizeInBytes);
end;

{ TFhirTestReportTeardownListEnumerator }

Constructor TFhirTestReportTeardownListEnumerator.Create(list : TFhirTestReportTeardownList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportTeardownListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportTeardownListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportTeardownListEnumerator.GetCurrent : TFhirTestReportTeardown;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportTeardownListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestReportTeardownList }
procedure TFhirTestReportTeardownList.AddItem(value: TFhirTestReportTeardown);
begin
  assert(value.ClassName = 'TFhirTestReportTeardown', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportTeardown');
  add(value);
end;

function TFhirTestReportTeardownList.Append: TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTeardownList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportTeardownList.GetEnumerator : TFhirTestReportTeardownListEnumerator;
begin
  result := TFhirTestReportTeardownListEnumerator.Create(self.link);
end;

function TFhirTestReportTeardownList.Clone: TFhirTestReportTeardownList;
begin
  result := TFhirTestReportTeardownList(inherited Clone);
end;

function TFhirTestReportTeardownList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportTeardownList.GetItemN(index: Integer): TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown(ObjectByIndex[index]);
end;

function TFhirTestReportTeardownList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportTeardown;
end;
function TFhirTestReportTeardownList.IndexOf(value: TFhirTestReportTeardown): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportTeardownList.Insert(index: Integer): TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTeardownList.InsertItem(index: Integer; value: TFhirTestReportTeardown);
begin
  assert(value is TFhirTestReportTeardown);
  Inherited Insert(index, value);
end;

function TFhirTestReportTeardownList.Item(index: Integer): TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown(ObjectByIndex[index]);
end;

function TFhirTestReportTeardownList.Link: TFhirTestReportTeardownList;
begin
  result := TFhirTestReportTeardownList(inherited Link);
end;

procedure TFhirTestReportTeardownList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportTeardownList.SetItemByIndex(index: Integer; value: TFhirTestReportTeardown);
begin
  assert(value is TFhirTestReportTeardown);
  FhirTestReportTeardowns[index] := value;
end;

procedure TFhirTestReportTeardownList.SetItemN(index: Integer; value: TFhirTestReportTeardown);
begin
  assert(value is TFhirTestReportTeardown);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportTeardownAction }

constructor TFhirTestReportTeardownAction.Create;
begin
  inherited;
end;

destructor TFhirTestReportTeardownAction.Destroy;
begin
  FOperation.free;
  inherited;
end;

procedure TFhirTestReportTeardownAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestReportTeardownAction(oSource).operation.Clone;
end;

procedure TFhirTestReportTeardownAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
end;

procedure TFhirTestReportTeardownAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', '@TestReport.setup.action.operation', false, TFhirTestReportSetupActionOperation, FOperation.Link));{2}
end;

function TFhirTestReportTeardownAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestReportSetupActionOperation{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportTeardownAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportTeardownAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestReportSetupActionOperation.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportTeardownAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := '@TestReport.setup.action.operation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportTeardownAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportTeardownAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestReportSetupActionOperation{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportTeardownAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportTeardownAction.fhirType : string;
begin
  result := 'action';
end;

function TFhirTestReportTeardownAction.Link : TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction(inherited Link);
end;

function TFhirTestReportTeardownAction.Clone : TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction(inherited Clone);
end;

function TFhirTestReportTeardownAction.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportTeardownAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportTeardownAction)) then
    result := false
  else
  begin
    o := TFhirTestReportTeardownAction(other);
    result := compareDeep(operationElement, o.operationElement, true);
  end;
end;

function TFhirTestReportTeardownAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation);
end;

procedure TFhirTestReportTeardownAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('operation');
end;

{ TFhirTestReportTeardownAction }

Procedure TFhirTestReportTeardownAction.SetOperation(value : TFhirTestReportSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

function TFhirTestReportTeardownAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOperation.sizeInBytes);
end;

{ TFhirTestReportTeardownActionListEnumerator }

Constructor TFhirTestReportTeardownActionListEnumerator.Create(list : TFhirTestReportTeardownActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportTeardownActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportTeardownActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportTeardownActionListEnumerator.GetCurrent : TFhirTestReportTeardownAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportTeardownActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestReportTeardownActionList }
procedure TFhirTestReportTeardownActionList.AddItem(value: TFhirTestReportTeardownAction);
begin
  assert(value.ClassName = 'TFhirTestReportTeardownAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportTeardownAction');
  add(value);
end;

function TFhirTestReportTeardownActionList.Append: TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTeardownActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportTeardownActionList.GetEnumerator : TFhirTestReportTeardownActionListEnumerator;
begin
  result := TFhirTestReportTeardownActionListEnumerator.Create(self.link);
end;

function TFhirTestReportTeardownActionList.Clone: TFhirTestReportTeardownActionList;
begin
  result := TFhirTestReportTeardownActionList(inherited Clone);
end;

function TFhirTestReportTeardownActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportTeardownActionList.GetItemN(index: Integer): TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction(ObjectByIndex[index]);
end;

function TFhirTestReportTeardownActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportTeardownAction;
end;
function TFhirTestReportTeardownActionList.IndexOf(value: TFhirTestReportTeardownAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportTeardownActionList.Insert(index: Integer): TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTeardownActionList.InsertItem(index: Integer; value: TFhirTestReportTeardownAction);
begin
  assert(value is TFhirTestReportTeardownAction);
  Inherited Insert(index, value);
end;

function TFhirTestReportTeardownActionList.Item(index: Integer): TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction(ObjectByIndex[index]);
end;

function TFhirTestReportTeardownActionList.Link: TFhirTestReportTeardownActionList;
begin
  result := TFhirTestReportTeardownActionList(inherited Link);
end;

procedure TFhirTestReportTeardownActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportTeardownActionList.SetItemByIndex(index: Integer; value: TFhirTestReportTeardownAction);
begin
  assert(value is TFhirTestReportTeardownAction);
  FhirTestReportTeardownActions[index] := value;
end;

procedure TFhirTestReportTeardownActionList.SetItemN(index: Integer; value: TFhirTestReportTeardownAction);
begin
  assert(value is TFhirTestReportTeardownAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReport }

constructor TFhirTestReport.Create;
begin
  inherited;
end;

destructor TFhirTestReport.Destroy;
begin
  FIdentifier.free;
  FName.free;
  FStatus.free;
  FTestScript.free;
  FResult.free;
  FScore.free;
  FTester.free;
  FIssued.free;
  FParticipantList.Free;
  FSetup.free;
  FTestList.Free;
  FTeardown.free;
  inherited;
end;

function TFhirTestReport.GetResourceType : TFhirResourceType;
begin
  result := frtTestReport;
end;

procedure TFhirTestReport.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirTestReport(oSource).identifier.Clone;
  nameElement := TFhirTestReport(oSource).nameElement.Clone;
  FStatus := TFhirTestReport(oSource).FStatus.Link;
  testScript := TFhirTestReport(oSource).testScript.Clone;
  FResult := TFhirTestReport(oSource).FResult.Link;
  scoreElement := TFhirTestReport(oSource).scoreElement.Clone;
  testerElement := TFhirTestReport(oSource).testerElement.Clone;
  issuedElement := TFhirTestReport(oSource).issuedElement.Clone;
  if (TFhirTestReport(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirTestReportParticipantList.Create;
    FParticipantList.Assign(TFhirTestReport(oSource).FParticipantList);
  end;
  setup := TFhirTestReport(oSource).setup.Clone;
  if (TFhirTestReport(oSource).FTestList = nil) then
  begin
    FTestList.free;
    FTestList := nil;
  end
  else
  begin
    if FTestList = nil then
      FTestList := TFhirTestReportTestList.Create;
    FTestList.Assign(TFhirTestReport(oSource).FTestList);
  end;
  teardown := TFhirTestReport(oSource).teardown.Clone;
end;

procedure TFhirTestReport.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'testScript') Then
     list.add(self.link, 'testScript', FTestScript.Link);
  if (child_name = 'result') Then
     list.add(self.link, 'result', FResult.Link);
  if (child_name = 'score') Then
     list.add(self.link, 'score', FScore.Link);
  if (child_name = 'tester') Then
     list.add(self.link, 'tester', FTester.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'setup') Then
     list.add(self.link, 'setup', FSetup.Link);
  if (child_name = 'test') Then
    list.addAll(self, 'test', FTestList);
  if (child_name = 'teardown') Then
     list.add(self.link, 'teardown', FTeardown.Link);
end;

procedure TFhirTestReport.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'testScript', 'Reference(TestScript)', false, TFhirReference{TFhirTestScript}, FTestScript.Link));{2}
  oList.add(TFHIRProperty.create(self, 'result', 'code', false, TFHIREnum, FResult.Link));{1}
  oList.add(TFHIRProperty.create(self, 'score', 'decimal', false, TFhirDecimal, FScore.Link));{2}
  oList.add(TFHIRProperty.create(self, 'tester', 'string', false, TFhirString, FTester.Link));{2}
  oList.add(TFHIRProperty.create(self, 'issued', 'dateTime', false, TFhirDateTime, FIssued.Link));{2}
  oList.add(TFHIRProperty.create(self, 'participant', '', true, TFhirTestReportParticipant, FParticipantList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'setup', '', false, TFhirTestReportSetup, FSetup.Link));{2}
  oList.add(TFHIRProperty.create(self, 'test', '', true, TFhirTestReportTest, FTestList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'teardown', '', false, TFhirTestReportTeardown, FTeardown.Link));{2}
end;

function TFhirTestReport.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirReportStatusCodesEnum, CODES_TFhirReportStatusCodesEnum, propValue);
    result := propValue
  end
  else if (propName = 'testScript') then
  begin
    TestScript := propValue as TFhirReference{TFhirTestScript}{4b};
    result := propValue;
  end
  else if (propName = 'result') then
  begin
    ResultElement := asEnum(SYSTEMS_TFhirReportResultCodesEnum, CODES_TFhirReportResultCodesEnum, propValue);
    result := propValue
  end
  else if (propName = 'score') then
  begin
    ScoreElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'tester') then
  begin
    TesterElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirTestReportParticipant){2a};
    result := propValue;
  end
  else if (propName = 'setup') then
  begin
    Setup := propValue as TFhirTestReportSetup{4b};
    result := propValue;
  end
  else if (propName = 'test') then
  begin
    TestList.add(propValue as TFhirTestReportTest){2a};
    result := propValue;
  end
  else if (propName = 'teardown') then
  begin
    Teardown := propValue as TFhirTestReportTeardown{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirTestReport.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirTestReportParticipant){2a}
  else if (propName = 'test') then TestList.insertItem(index, propValue as TFhirTestReportTest){2a}
  else inherited;
end;

function TFhirTestReport.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'testScript') then result := TFhirReference{TFhirTestScript}.create(){4b}
  else if (propName = 'score') then result := TFhirDecimal.create() {5b}
  else if (propName = 'tester') then result := TFhirString.create() {5b}
  else if (propName = 'issued') then result := TFhirDateTime.create() {5b}
  else if (propName = 'participant') then result := ParticipantList.new(){2}
  else if (propName = 'setup') then result := TFhirTestReportSetup.create(){4b}
  else if (propName = 'test') then result := TestList.new(){2}
  else if (propName = 'teardown') then result := TFhirTestReportTeardown.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReport.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'testScript') then result := 'Reference'
  else if (propName = 'result') then result := 'code'
  else if (propName = 'score') then result := 'decimal'
  else if (propName = 'tester') then result := 'string'
  else if (propName = 'issued') then result := 'dateTime'
  else if (propName = 'participant') then result := ''
  else if (propName = 'setup') then result := ''
  else if (propName = 'test') then result := ''
  else if (propName = 'teardown') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReport.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'testScript') then TestScriptElement := nil
  else if (propName = 'result') then ResultElement := nil
  else if (propName = 'score') then ScoreElement := nil
  else if (propName = 'tester') then TesterElement := nil
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value) {2}
  else if (propName = 'setup') then SetupElement := nil
  else if (propName = 'test') then deletePropertyValue('test', TestList, value) {2}
  else if (propName = 'teardown') then TeardownElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReport.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirReportStatusCodesEnum, CODES_TFhirReportStatusCodesEnum, new){4}
  else if (propName = 'testScript') then TestScriptElement := new as TFhirReference{TFhirTestScript}{4}
  else if (propName = 'result') then ResultElement := asEnum(SYSTEMS_TFhirReportResultCodesEnum, CODES_TFhirReportResultCodesEnum, new){4}
  else if (propName = 'score') then ScoreElement := asDecimal(new){5b}
  else if (propName = 'tester') then TesterElement := asString(new){5b}
  else if (propName = 'issued') then IssuedElement := asDateTime(new){5b}
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new) {2}
  else if (propName = 'setup') then SetupElement := new as TFhirTestReportSetup{4}
  else if (propName = 'test') then replacePropertyValue('test', TestList, existing, new) {2}
  else if (propName = 'teardown') then TeardownElement := new as TFhirTestReportTeardown{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReport.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'participant') then ParticipantList.move(source, destination){2a}
  else if (propName = 'test') then TestList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReport.fhirType : string;
begin
  result := 'TestReport';
end;

function TFhirTestReport.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FName) and isEmptyProp(FStatus) and isEmptyProp(FTestScript) and isEmptyProp(FResult) and isEmptyProp(FScore) and isEmptyProp(FTester) and isEmptyProp(FIssued) and isEmptyProp(FparticipantList) and isEmptyProp(FSetup) and isEmptyProp(FtestList) and isEmptyProp(FTeardown);
end;

function TFhirTestReport.equals(other : TObject) : boolean; 
var
  o : TFhirTestReport;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReport)) then
    result := false
  else
  begin
    o := TFhirTestReport(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(testScriptElement, o.testScriptElement, true) and 
      compareDeep(resultElement, o.resultElement, true) and compareDeep(scoreElement, o.scoreElement, true) and 
      compareDeep(testerElement, o.testerElement, true) and compareDeep(issuedElement, o.issuedElement, true) and 
      compareDeep(participantList, o.participantList, true) and compareDeep(setupElement, o.setupElement, true) and 
      compareDeep(testList, o.testList, true) and compareDeep(teardownElement, o.teardownElement, true);
  end;
end;

function TFhirTestReport.Link : TFhirTestReport;
begin
  result := TFhirTestReport(inherited Link);
end;

function TFhirTestReport.Clone : TFhirTestReport;
begin
  result := TFhirTestReport(inherited Clone);
end;

procedure TFhirTestReport.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('name');
  fields.add('status');
  fields.add('testScript');
  fields.add('result');
  fields.add('score');
  fields.add('tester');
  fields.add('issued');
  fields.add('participant');
  fields.add('setup');
  fields.add('test');
  fields.add('teardown');
end;

{ TFhirTestReport }

Procedure TFhirTestReport.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirTestReport.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirTestReport.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirTestReport.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirTestReport.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirTestReport.GetStatusST : TFhirReportStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirReportStatusCodesEnum(0)
  else
    result := TFhirReportStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirReportStatusCodesEnum, FStatus.value));
end;

Procedure TFhirTestReport.SetStatusST(value : TFhirReportStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirReportStatusCodesEnum[value], CODES_TFhirReportStatusCodesEnum[value]);
end;

Procedure TFhirTestReport.SetTestScript(value : TFhirReference{TFhirTestScript});
begin
  FTestScript.free;
  FTestScript := value;
end;

Procedure TFhirTestReport.SetResult(value : TFhirEnum);
begin
  FResult.free;
  FResult := value;
end;

Function TFhirTestReport.GetResultST : TFhirReportResultCodesEnum;
begin
  if FResult = nil then
    result := TFhirReportResultCodesEnum(0)
  else
    result := TFhirReportResultCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirReportResultCodesEnum, FResult.value));
end;

Procedure TFhirTestReport.SetResultST(value : TFhirReportResultCodesEnum);
begin
  if ord(value) = 0 then
    ResultElement := nil
  else
    ResultElement := TFhirEnum.create(SYSTEMS_TFhirReportResultCodesEnum[value], CODES_TFhirReportResultCodesEnum[value]);
end;

Procedure TFhirTestReport.SetScore(value : TFhirDecimal);
begin
  FScore.free;
  FScore := value;
end;

Function TFhirTestReport.GetScoreST : String;
begin
  if FScore = nil then
    result := ''
  else
    result := FScore.value;
end;

Procedure TFhirTestReport.SetScoreST(value : String);
begin
  if value <> '' then
  begin
    if FScore = nil then
      FScore := TFhirDecimal.create;
    FScore.value := value
  end
  else if FScore <> nil then
    FScore.value := '';
end;

Procedure TFhirTestReport.SetTester(value : TFhirString);
begin
  FTester.free;
  FTester := value;
end;

Function TFhirTestReport.GetTesterST : String;
begin
  if FTester = nil then
    result := ''
  else
    result := FTester.value;
end;

Procedure TFhirTestReport.SetTesterST(value : String);
begin
  if value <> '' then
  begin
    if FTester = nil then
      FTester := TFhirString.create;
    FTester.value := value
  end
  else if FTester <> nil then
    FTester.value := '';
end;

Procedure TFhirTestReport.SetIssued(value : TFhirDateTime);
begin
  FIssued.free;
  FIssued := value;
end;

Function TFhirTestReport.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

Procedure TFhirTestReport.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirDateTime.create;
  FIssued.value := value
end;

Function TFhirTestReport.GetParticipantList : TFhirTestReportParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirTestReportParticipantList.Create;
  result := FParticipantList;
end;

Function TFhirTestReport.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

Procedure TFhirTestReport.SetSetup(value : TFhirTestReportSetup);
begin
  FSetup.free;
  FSetup := value;
end;

Function TFhirTestReport.GetTestList : TFhirTestReportTestList;
begin
  if FTestList = nil then
    FTestList := TFhirTestReportTestList.Create;
  result := FTestList;
end;

Function TFhirTestReport.GetHasTestList : boolean;
begin
  result := (FTestList <> nil) and (FTestList.count > 0);
end;

Procedure TFhirTestReport.SetTeardown(value : TFhirTestReportTeardown);
begin
  FTeardown.free;
  FTeardown := value;
end;

function TFhirTestReport.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FTestScript.sizeInBytes);
  inc(result, FResult.sizeInBytes);
  inc(result, FScore.sizeInBytes);
  inc(result, FTester.sizeInBytes);
  inc(result, FIssued.sizeInBytes);
  inc(result, FparticipantList.sizeInBytes);
  inc(result, FSetup.sizeInBytes);
  inc(result, FtestList.sizeInBytes);
  inc(result, FTeardown.sizeInBytes);
end;

{ TFhirTestReportListEnumerator }

Constructor TFhirTestReportListEnumerator.Create(list : TFhirTestReportList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportListEnumerator.GetCurrent : TFhirTestReport;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestReportList }
procedure TFhirTestReportList.AddItem(value: TFhirTestReport);
begin
  assert(value.ClassName = 'TFhirTestReport', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReport');
  add(value);
end;

function TFhirTestReportList.Append: TFhirTestReport;
begin
  result := TFhirTestReport.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportList.GetEnumerator : TFhirTestReportListEnumerator;
begin
  result := TFhirTestReportListEnumerator.Create(self.link);
end;

function TFhirTestReportList.Clone: TFhirTestReportList;
begin
  result := TFhirTestReportList(inherited Clone);
end;

function TFhirTestReportList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportList.GetItemN(index: Integer): TFhirTestReport;
begin
  result := TFhirTestReport(ObjectByIndex[index]);
end;

function TFhirTestReportList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReport;
end;
function TFhirTestReportList.IndexOf(value: TFhirTestReport): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportList.Insert(index: Integer): TFhirTestReport;
begin
  result := TFhirTestReport.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportList.InsertItem(index: Integer; value: TFhirTestReport);
begin
  assert(value is TFhirTestReport);
  Inherited Insert(index, value);
end;

function TFhirTestReportList.Item(index: Integer): TFhirTestReport;
begin
  result := TFhirTestReport(ObjectByIndex[index]);
end;

function TFhirTestReportList.Link: TFhirTestReportList;
begin
  result := TFhirTestReportList(inherited Link);
end;

procedure TFhirTestReportList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportList.SetItemByIndex(index: Integer; value: TFhirTestReport);
begin
  assert(value is TFhirTestReport);
  FhirTestReports[index] := value;
end;

procedure TFhirTestReportList.SetItemN(index: Integer; value: TFhirTestReport);
begin
  assert(value is TFhirTestReport);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_TESTREPORT}

{$IFDEF FHIR_VERIFICATIONRESULT}

{ TFhirVerificationResultPrimarySource }

constructor TFhirVerificationResultPrimarySource.Create;
begin
  inherited;
end;

destructor TFhirVerificationResultPrimarySource.Destroy;
begin
  FWho.free;
  FType_List.Free;
  FCommunicationMethodList.Free;
  FValidationStatus.free;
  FValidationDate.free;
  FCanPushUpdates.free;
  FPushTypeAvailableList.Free;
  inherited;
end;

procedure TFhirVerificationResultPrimarySource.Assign(oSource : TFslObject);
begin
  inherited;
  who := TFhirVerificationResultPrimarySource(oSource).who.Clone;
  if (TFhirVerificationResultPrimarySource(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirVerificationResultPrimarySource(oSource).FType_List);
  end;
  if (TFhirVerificationResultPrimarySource(oSource).FCommunicationMethodList = nil) then
  begin
    FCommunicationMethodList.free;
    FCommunicationMethodList := nil;
  end
  else
  begin
    if FCommunicationMethodList = nil then
      FCommunicationMethodList := TFhirCodeableConceptList.Create;
    FCommunicationMethodList.Assign(TFhirVerificationResultPrimarySource(oSource).FCommunicationMethodList);
  end;
  validationStatus := TFhirVerificationResultPrimarySource(oSource).validationStatus.Clone;
  validationDateElement := TFhirVerificationResultPrimarySource(oSource).validationDateElement.Clone;
  canPushUpdates := TFhirVerificationResultPrimarySource(oSource).canPushUpdates.Clone;
  if (TFhirVerificationResultPrimarySource(oSource).FPushTypeAvailableList = nil) then
  begin
    FPushTypeAvailableList.free;
    FPushTypeAvailableList := nil;
  end
  else
  begin
    if FPushTypeAvailableList = nil then
      FPushTypeAvailableList := TFhirCodeableConceptList.Create;
    FPushTypeAvailableList.Assign(TFhirVerificationResultPrimarySource(oSource).FPushTypeAvailableList);
  end;
end;

procedure TFhirVerificationResultPrimarySource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'who') Then
     list.add(self.link, 'who', FWho.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'communicationMethod') Then
    list.addAll(self, 'communicationMethod', FCommunicationMethodList);
  if (child_name = 'validationStatus') Then
     list.add(self.link, 'validationStatus', FValidationStatus.Link);
  if (child_name = 'validationDate') Then
     list.add(self.link, 'validationDate', FValidationDate.Link);
  if (child_name = 'canPushUpdates') Then
     list.add(self.link, 'canPushUpdates', FCanPushUpdates.Link);
  if (child_name = 'pushTypeAvailable') Then
    list.addAll(self, 'pushTypeAvailable', FPushTypeAvailableList);
end;

procedure TFhirVerificationResultPrimarySource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'who', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FWho.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'communicationMethod', 'CodeableConcept', true, TFhirCodeableConcept, FCommunicationMethodList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'validationStatus', 'CodeableConcept', false, TFhirCodeableConcept, FValidationStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'validationDate', 'dateTime', false, TFhirDateTime, FValidationDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'canPushUpdates', 'CodeableConcept', false, TFhirCodeableConcept, FCanPushUpdates.Link));{2}
  oList.add(TFHIRProperty.create(self, 'pushTypeAvailable', 'CodeableConcept', true, TFhirCodeableConcept, FPushTypeAvailableList.Link)){3};
end;

function TFhirVerificationResultPrimarySource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'who') then
  begin
    Who := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'communicationMethod') then
  begin
    CommunicationMethodList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'validationStatus') then
  begin
    ValidationStatus := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'validationDate') then
  begin
    ValidationDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'canPushUpdates') then
  begin
    CanPushUpdates := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'pushTypeAvailable') then
  begin
    PushTypeAvailableList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirVerificationResultPrimarySource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'communicationMethod') then CommunicationMethodList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'pushTypeAvailable') then PushTypeAvailableList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirVerificationResultPrimarySource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'who') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'communicationMethod') then result := CommunicationMethodList.new(){2}
  else if (propName = 'validationStatus') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'validationDate') then result := TFhirDateTime.create() {5b}
  else if (propName = 'canPushUpdates') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'pushTypeAvailable') then result := PushTypeAvailableList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirVerificationResultPrimarySource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'who') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'communicationMethod') then result := 'CodeableConcept'
  else if (propName = 'validationStatus') then result := 'CodeableConcept'
  else if (propName = 'validationDate') then result := 'dateTime'
  else if (propName = 'canPushUpdates') then result := 'CodeableConcept'
  else if (propName = 'pushTypeAvailable') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVerificationResultPrimarySource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'who') then WhoElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'communicationMethod') then deletePropertyValue('communicationMethod', CommunicationMethodList, value) {2}
  else if (propName = 'validationStatus') then ValidationStatusElement := nil
  else if (propName = 'validationDate') then ValidationDateElement := nil
  else if (propName = 'canPushUpdates') then CanPushUpdatesElement := nil
  else if (propName = 'pushTypeAvailable') then deletePropertyValue('pushTypeAvailable', PushTypeAvailableList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVerificationResultPrimarySource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'who') then WhoElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'communicationMethod') then replacePropertyValue('communicationMethod', CommunicationMethodList, existing, new) {2}
  else if (propName = 'validationStatus') then ValidationStatusElement := new as TFhirCodeableConcept{4}
  else if (propName = 'validationDate') then ValidationDateElement := asDateTime(new){5b}
  else if (propName = 'canPushUpdates') then CanPushUpdatesElement := new as TFhirCodeableConcept{4}
  else if (propName = 'pushTypeAvailable') then replacePropertyValue('pushTypeAvailable', PushTypeAvailableList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVerificationResultPrimarySource.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination){2a}
  else if (propName = 'communicationMethod') then CommunicationMethodList.move(source, destination){2a}
  else if (propName = 'pushTypeAvailable') then PushTypeAvailableList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirVerificationResultPrimarySource.fhirType : string;
begin
  result := 'primarySource';
end;

function TFhirVerificationResultPrimarySource.Link : TFhirVerificationResultPrimarySource;
begin
  result := TFhirVerificationResultPrimarySource(inherited Link);
end;

function TFhirVerificationResultPrimarySource.Clone : TFhirVerificationResultPrimarySource;
begin
  result := TFhirVerificationResultPrimarySource(inherited Clone);
end;

function TFhirVerificationResultPrimarySource.equals(other : TObject) : boolean; 
var
  o : TFhirVerificationResultPrimarySource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVerificationResultPrimarySource)) then
    result := false
  else
  begin
    o := TFhirVerificationResultPrimarySource(other);
    result := compareDeep(whoElement, o.whoElement, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(communicationMethodList, o.communicationMethodList, true) and compareDeep(validationStatusElement, o.validationStatusElement, true) and 
      compareDeep(validationDateElement, o.validationDateElement, true) and compareDeep(canPushUpdatesElement, o.canPushUpdatesElement, true) and 
      compareDeep(pushTypeAvailableList, o.pushTypeAvailableList, true);
  end;
end;

function TFhirVerificationResultPrimarySource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FWho) and isEmptyProp(Ftype_List) and isEmptyProp(FcommunicationMethodList) and isEmptyProp(FValidationStatus) and isEmptyProp(FValidationDate) and isEmptyProp(FCanPushUpdates) and isEmptyProp(FpushTypeAvailableList);
end;

procedure TFhirVerificationResultPrimarySource.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('who');
  fields.add('type');
  fields.add('communicationMethod');
  fields.add('validationStatus');
  fields.add('validationDate');
  fields.add('canPushUpdates');
  fields.add('pushTypeAvailable');
end;

{ TFhirVerificationResultPrimarySource }

Procedure TFhirVerificationResultPrimarySource.SetWho(value : TFhirReference{TFhirOrganization});
begin
  FWho.free;
  FWho := value;
end;

Function TFhirVerificationResultPrimarySource.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

Function TFhirVerificationResultPrimarySource.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Function TFhirVerificationResultPrimarySource.GetCommunicationMethodList : TFhirCodeableConceptList;
begin
  if FCommunicationMethodList = nil then
    FCommunicationMethodList := TFhirCodeableConceptList.Create;
  result := FCommunicationMethodList;
end;

Function TFhirVerificationResultPrimarySource.GetHasCommunicationMethodList : boolean;
begin
  result := (FCommunicationMethodList <> nil) and (FCommunicationMethodList.count > 0);
end;

Procedure TFhirVerificationResultPrimarySource.SetValidationStatus(value : TFhirCodeableConcept);
begin
  FValidationStatus.free;
  FValidationStatus := value;
end;

Procedure TFhirVerificationResultPrimarySource.SetValidationDate(value : TFhirDateTime);
begin
  FValidationDate.free;
  FValidationDate := value;
end;

Function TFhirVerificationResultPrimarySource.GetValidationDateST : TFslDateTime;
begin
  if FValidationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FValidationDate.value;
end;

Procedure TFhirVerificationResultPrimarySource.SetValidationDateST(value : TFslDateTime);
begin
  if FValidationDate = nil then
    FValidationDate := TFhirDateTime.create;
  FValidationDate.value := value
end;

Procedure TFhirVerificationResultPrimarySource.SetCanPushUpdates(value : TFhirCodeableConcept);
begin
  FCanPushUpdates.free;
  FCanPushUpdates := value;
end;

Function TFhirVerificationResultPrimarySource.GetPushTypeAvailableList : TFhirCodeableConceptList;
begin
  if FPushTypeAvailableList = nil then
    FPushTypeAvailableList := TFhirCodeableConceptList.Create;
  result := FPushTypeAvailableList;
end;

Function TFhirVerificationResultPrimarySource.GetHasPushTypeAvailableList : boolean;
begin
  result := (FPushTypeAvailableList <> nil) and (FPushTypeAvailableList.count > 0);
end;

function TFhirVerificationResultPrimarySource.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FWho.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FcommunicationMethodList.sizeInBytes);
  inc(result, FValidationStatus.sizeInBytes);
  inc(result, FValidationDate.sizeInBytes);
  inc(result, FCanPushUpdates.sizeInBytes);
  inc(result, FpushTypeAvailableList.sizeInBytes);
end;

{ TFhirVerificationResultPrimarySourceListEnumerator }

Constructor TFhirVerificationResultPrimarySourceListEnumerator.Create(list : TFhirVerificationResultPrimarySourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVerificationResultPrimarySourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVerificationResultPrimarySourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVerificationResultPrimarySourceListEnumerator.GetCurrent : TFhirVerificationResultPrimarySource;
begin
  Result := FList[FIndex];
end;

function TFhirVerificationResultPrimarySourceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirVerificationResultPrimarySourceList }
procedure TFhirVerificationResultPrimarySourceList.AddItem(value: TFhirVerificationResultPrimarySource);
begin
  assert(value.ClassName = 'TFhirVerificationResultPrimarySource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVerificationResultPrimarySource');
  add(value);
end;

function TFhirVerificationResultPrimarySourceList.Append: TFhirVerificationResultPrimarySource;
begin
  result := TFhirVerificationResultPrimarySource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultPrimarySourceList.ClearItems;
begin
  Clear;
end;

function TFhirVerificationResultPrimarySourceList.GetEnumerator : TFhirVerificationResultPrimarySourceListEnumerator;
begin
  result := TFhirVerificationResultPrimarySourceListEnumerator.Create(self.link);
end;

function TFhirVerificationResultPrimarySourceList.Clone: TFhirVerificationResultPrimarySourceList;
begin
  result := TFhirVerificationResultPrimarySourceList(inherited Clone);
end;

function TFhirVerificationResultPrimarySourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVerificationResultPrimarySourceList.GetItemN(index: Integer): TFhirVerificationResultPrimarySource;
begin
  result := TFhirVerificationResultPrimarySource(ObjectByIndex[index]);
end;

function TFhirVerificationResultPrimarySourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirVerificationResultPrimarySource;
end;
function TFhirVerificationResultPrimarySourceList.IndexOf(value: TFhirVerificationResultPrimarySource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVerificationResultPrimarySourceList.Insert(index: Integer): TFhirVerificationResultPrimarySource;
begin
  result := TFhirVerificationResultPrimarySource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultPrimarySourceList.InsertItem(index: Integer; value: TFhirVerificationResultPrimarySource);
begin
  assert(value is TFhirVerificationResultPrimarySource);
  Inherited Insert(index, value);
end;

function TFhirVerificationResultPrimarySourceList.Item(index: Integer): TFhirVerificationResultPrimarySource;
begin
  result := TFhirVerificationResultPrimarySource(ObjectByIndex[index]);
end;

function TFhirVerificationResultPrimarySourceList.Link: TFhirVerificationResultPrimarySourceList;
begin
  result := TFhirVerificationResultPrimarySourceList(inherited Link);
end;

procedure TFhirVerificationResultPrimarySourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVerificationResultPrimarySourceList.SetItemByIndex(index: Integer; value: TFhirVerificationResultPrimarySource);
begin
  assert(value is TFhirVerificationResultPrimarySource);
  FhirVerificationResultPrimarySources[index] := value;
end;

procedure TFhirVerificationResultPrimarySourceList.SetItemN(index: Integer; value: TFhirVerificationResultPrimarySource);
begin
  assert(value is TFhirVerificationResultPrimarySource);
  ObjectByIndex[index] := value;
end;

{ TFhirVerificationResultAttestation }

constructor TFhirVerificationResultAttestation.Create;
begin
  inherited;
end;

destructor TFhirVerificationResultAttestation.Destroy;
begin
  FWho.free;
  FOnBehalfOf.free;
  FCommunicationMethod.free;
  FDate.free;
  FSourceIdentityCertificate.free;
  FProxyIdentityCertificate.free;
  FProxySignature.free;
  FSourceSignature.free;
  inherited;
end;

procedure TFhirVerificationResultAttestation.Assign(oSource : TFslObject);
begin
  inherited;
  who := TFhirVerificationResultAttestation(oSource).who.Clone;
  onBehalfOf := TFhirVerificationResultAttestation(oSource).onBehalfOf.Clone;
  communicationMethod := TFhirVerificationResultAttestation(oSource).communicationMethod.Clone;
  dateElement := TFhirVerificationResultAttestation(oSource).dateElement.Clone;
  sourceIdentityCertificateElement := TFhirVerificationResultAttestation(oSource).sourceIdentityCertificateElement.Clone;
  proxyIdentityCertificateElement := TFhirVerificationResultAttestation(oSource).proxyIdentityCertificateElement.Clone;
  proxySignature := TFhirVerificationResultAttestation(oSource).proxySignature.Clone;
  sourceSignature := TFhirVerificationResultAttestation(oSource).sourceSignature.Clone;
end;

procedure TFhirVerificationResultAttestation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'who') Then
     list.add(self.link, 'who', FWho.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
  if (child_name = 'communicationMethod') Then
     list.add(self.link, 'communicationMethod', FCommunicationMethod.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'sourceIdentityCertificate') Then
     list.add(self.link, 'sourceIdentityCertificate', FSourceIdentityCertificate.Link);
  if (child_name = 'proxyIdentityCertificate') Then
     list.add(self.link, 'proxyIdentityCertificate', FProxyIdentityCertificate.Link);
  if (child_name = 'proxySignature') Then
     list.add(self.link, 'proxySignature', FProxySignature.Link);
  if (child_name = 'sourceSignature') Then
     list.add(self.link, 'sourceSignature', FSourceSignature.Link);
end;

procedure TFhirVerificationResultAttestation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'who', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FWho.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOnBehalfOf.Link));{2}
  oList.add(TFHIRProperty.create(self, 'communicationMethod', 'CodeableConcept', false, TFhirCodeableConcept, FCommunicationMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sourceIdentityCertificate', 'string', false, TFhirString, FSourceIdentityCertificate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'proxyIdentityCertificate', 'string', false, TFhirString, FProxyIdentityCertificate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'proxySignature', 'Signature', false, TFhirSignature, FProxySignature.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sourceSignature', 'Signature', false, TFhirSignature, FSourceSignature.Link));{2}
end;

function TFhirVerificationResultAttestation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'who') then
  begin
    Who := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'communicationMethod') then
  begin
    CommunicationMethod := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'sourceIdentityCertificate') then
  begin
    SourceIdentityCertificateElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'proxyIdentityCertificate') then
  begin
    ProxyIdentityCertificateElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'proxySignature') then
  begin
    ProxySignature := propValue as TFhirSignature{4b};
    result := propValue;
  end
  else if (propName = 'sourceSignature') then
  begin
    SourceSignature := propValue as TFhirSignature{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirVerificationResultAttestation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirVerificationResultAttestation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'who') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'onBehalfOf') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'communicationMethod') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'date') then result := TFhirDate.create() {5b}
  else if (propName = 'sourceIdentityCertificate') then result := TFhirString.create() {5b}
  else if (propName = 'proxyIdentityCertificate') then result := TFhirString.create() {5b}
  else if (propName = 'proxySignature') then result := TFhirSignature.create(){4b}
  else if (propName = 'sourceSignature') then result := TFhirSignature.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirVerificationResultAttestation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'who') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else if (propName = 'communicationMethod') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'date'
  else if (propName = 'sourceIdentityCertificate') then result := 'string'
  else if (propName = 'proxyIdentityCertificate') then result := 'string'
  else if (propName = 'proxySignature') then result := 'Signature'
  else if (propName = 'sourceSignature') then result := 'Signature'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVerificationResultAttestation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'who') then WhoElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else if (propName = 'communicationMethod') then CommunicationMethodElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'sourceIdentityCertificate') then SourceIdentityCertificateElement := nil
  else if (propName = 'proxyIdentityCertificate') then ProxyIdentityCertificateElement := nil
  else if (propName = 'proxySignature') then ProxySignatureElement := nil
  else if (propName = 'sourceSignature') then SourceSignatureElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVerificationResultAttestation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'who') then WhoElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'communicationMethod') then CommunicationMethodElement := new as TFhirCodeableConcept{4}
  else if (propName = 'date') then DateElement := asDate(new){5b}
  else if (propName = 'sourceIdentityCertificate') then SourceIdentityCertificateElement := asString(new){5b}
  else if (propName = 'proxyIdentityCertificate') then ProxyIdentityCertificateElement := asString(new){5b}
  else if (propName = 'proxySignature') then ProxySignatureElement := new as TFhirSignature{4}
  else if (propName = 'sourceSignature') then SourceSignatureElement := new as TFhirSignature{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVerificationResultAttestation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirVerificationResultAttestation.fhirType : string;
begin
  result := 'attestation';
end;

function TFhirVerificationResultAttestation.Link : TFhirVerificationResultAttestation;
begin
  result := TFhirVerificationResultAttestation(inherited Link);
end;

function TFhirVerificationResultAttestation.Clone : TFhirVerificationResultAttestation;
begin
  result := TFhirVerificationResultAttestation(inherited Clone);
end;

function TFhirVerificationResultAttestation.equals(other : TObject) : boolean; 
var
  o : TFhirVerificationResultAttestation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVerificationResultAttestation)) then
    result := false
  else
  begin
    o := TFhirVerificationResultAttestation(other);
    result := compareDeep(whoElement, o.whoElement, true) and compareDeep(onBehalfOfElement, o.onBehalfOfElement, true) and 
      compareDeep(communicationMethodElement, o.communicationMethodElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(sourceIdentityCertificateElement, o.sourceIdentityCertificateElement, true) and 
      compareDeep(proxyIdentityCertificateElement, o.proxyIdentityCertificateElement, true) and 
      compareDeep(proxySignatureElement, o.proxySignatureElement, true) and compareDeep(sourceSignatureElement, o.sourceSignatureElement, true);
  end;
end;

function TFhirVerificationResultAttestation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FWho) and isEmptyProp(FOnBehalfOf) and isEmptyProp(FCommunicationMethod) and isEmptyProp(FDate) and isEmptyProp(FSourceIdentityCertificate) and isEmptyProp(FProxyIdentityCertificate) and isEmptyProp(FProxySignature) and isEmptyProp(FSourceSignature);
end;

procedure TFhirVerificationResultAttestation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('who');
  fields.add('onBehalfOf');
  fields.add('communicationMethod');
  fields.add('date');
  fields.add('sourceIdentityCertificate');
  fields.add('proxyIdentityCertificate');
  fields.add('proxySignature');
  fields.add('sourceSignature');
end;

{ TFhirVerificationResultAttestation }

Procedure TFhirVerificationResultAttestation.SetWho(value : TFhirReference{TFhirPractitioner});
begin
  FWho.free;
  FWho := value;
end;

Procedure TFhirVerificationResultAttestation.SetOnBehalfOf(value : TFhirReference{TFhirOrganization});
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

Procedure TFhirVerificationResultAttestation.SetCommunicationMethod(value : TFhirCodeableConcept);
begin
  FCommunicationMethod.free;
  FCommunicationMethod := value;
end;

Procedure TFhirVerificationResultAttestation.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirVerificationResultAttestation.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirVerificationResultAttestation.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

Procedure TFhirVerificationResultAttestation.SetSourceIdentityCertificate(value : TFhirString);
begin
  FSourceIdentityCertificate.free;
  FSourceIdentityCertificate := value;
end;

Function TFhirVerificationResultAttestation.GetSourceIdentityCertificateST : String;
begin
  if FSourceIdentityCertificate = nil then
    result := ''
  else
    result := FSourceIdentityCertificate.value;
end;

Procedure TFhirVerificationResultAttestation.SetSourceIdentityCertificateST(value : String);
begin
  if value <> '' then
  begin
    if FSourceIdentityCertificate = nil then
      FSourceIdentityCertificate := TFhirString.create;
    FSourceIdentityCertificate.value := value
  end
  else if FSourceIdentityCertificate <> nil then
    FSourceIdentityCertificate.value := '';
end;

Procedure TFhirVerificationResultAttestation.SetProxyIdentityCertificate(value : TFhirString);
begin
  FProxyIdentityCertificate.free;
  FProxyIdentityCertificate := value;
end;

Function TFhirVerificationResultAttestation.GetProxyIdentityCertificateST : String;
begin
  if FProxyIdentityCertificate = nil then
    result := ''
  else
    result := FProxyIdentityCertificate.value;
end;

Procedure TFhirVerificationResultAttestation.SetProxyIdentityCertificateST(value : String);
begin
  if value <> '' then
  begin
    if FProxyIdentityCertificate = nil then
      FProxyIdentityCertificate := TFhirString.create;
    FProxyIdentityCertificate.value := value
  end
  else if FProxyIdentityCertificate <> nil then
    FProxyIdentityCertificate.value := '';
end;

Procedure TFhirVerificationResultAttestation.SetProxySignature(value : TFhirSignature);
begin
  FProxySignature.free;
  FProxySignature := value;
end;

Procedure TFhirVerificationResultAttestation.SetSourceSignature(value : TFhirSignature);
begin
  FSourceSignature.free;
  FSourceSignature := value;
end;

function TFhirVerificationResultAttestation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FWho.sizeInBytes);
  inc(result, FOnBehalfOf.sizeInBytes);
  inc(result, FCommunicationMethod.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FSourceIdentityCertificate.sizeInBytes);
  inc(result, FProxyIdentityCertificate.sizeInBytes);
  inc(result, FProxySignature.sizeInBytes);
  inc(result, FSourceSignature.sizeInBytes);
end;

{ TFhirVerificationResultAttestationListEnumerator }

Constructor TFhirVerificationResultAttestationListEnumerator.Create(list : TFhirVerificationResultAttestationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVerificationResultAttestationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVerificationResultAttestationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVerificationResultAttestationListEnumerator.GetCurrent : TFhirVerificationResultAttestation;
begin
  Result := FList[FIndex];
end;

function TFhirVerificationResultAttestationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirVerificationResultAttestationList }
procedure TFhirVerificationResultAttestationList.AddItem(value: TFhirVerificationResultAttestation);
begin
  assert(value.ClassName = 'TFhirVerificationResultAttestation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVerificationResultAttestation');
  add(value);
end;

function TFhirVerificationResultAttestationList.Append: TFhirVerificationResultAttestation;
begin
  result := TFhirVerificationResultAttestation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultAttestationList.ClearItems;
begin
  Clear;
end;

function TFhirVerificationResultAttestationList.GetEnumerator : TFhirVerificationResultAttestationListEnumerator;
begin
  result := TFhirVerificationResultAttestationListEnumerator.Create(self.link);
end;

function TFhirVerificationResultAttestationList.Clone: TFhirVerificationResultAttestationList;
begin
  result := TFhirVerificationResultAttestationList(inherited Clone);
end;

function TFhirVerificationResultAttestationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVerificationResultAttestationList.GetItemN(index: Integer): TFhirVerificationResultAttestation;
begin
  result := TFhirVerificationResultAttestation(ObjectByIndex[index]);
end;

function TFhirVerificationResultAttestationList.ItemClass: TFslObjectClass;
begin
  result := TFhirVerificationResultAttestation;
end;
function TFhirVerificationResultAttestationList.IndexOf(value: TFhirVerificationResultAttestation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVerificationResultAttestationList.Insert(index: Integer): TFhirVerificationResultAttestation;
begin
  result := TFhirVerificationResultAttestation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultAttestationList.InsertItem(index: Integer; value: TFhirVerificationResultAttestation);
begin
  assert(value is TFhirVerificationResultAttestation);
  Inherited Insert(index, value);
end;

function TFhirVerificationResultAttestationList.Item(index: Integer): TFhirVerificationResultAttestation;
begin
  result := TFhirVerificationResultAttestation(ObjectByIndex[index]);
end;

function TFhirVerificationResultAttestationList.Link: TFhirVerificationResultAttestationList;
begin
  result := TFhirVerificationResultAttestationList(inherited Link);
end;

procedure TFhirVerificationResultAttestationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVerificationResultAttestationList.SetItemByIndex(index: Integer; value: TFhirVerificationResultAttestation);
begin
  assert(value is TFhirVerificationResultAttestation);
  FhirVerificationResultAttestations[index] := value;
end;

procedure TFhirVerificationResultAttestationList.SetItemN(index: Integer; value: TFhirVerificationResultAttestation);
begin
  assert(value is TFhirVerificationResultAttestation);
  ObjectByIndex[index] := value;
end;

{ TFhirVerificationResultValidator }

constructor TFhirVerificationResultValidator.Create;
begin
  inherited;
end;

destructor TFhirVerificationResultValidator.Destroy;
begin
  FOrganization.free;
  FIdentityCertificate.free;
  FAttestationSignature.free;
  inherited;
end;

procedure TFhirVerificationResultValidator.Assign(oSource : TFslObject);
begin
  inherited;
  organization := TFhirVerificationResultValidator(oSource).organization.Clone;
  identityCertificateElement := TFhirVerificationResultValidator(oSource).identityCertificateElement.Clone;
  attestationSignature := TFhirVerificationResultValidator(oSource).attestationSignature.Clone;
end;

procedure TFhirVerificationResultValidator.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'identityCertificate') Then
     list.add(self.link, 'identityCertificate', FIdentityCertificate.Link);
  if (child_name = 'attestationSignature') Then
     list.add(self.link, 'attestationSignature', FAttestationSignature.Link);
end;

procedure TFhirVerificationResultValidator.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identityCertificate', 'string', false, TFhirString, FIdentityCertificate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'attestationSignature', 'Signature', false, TFhirSignature, FAttestationSignature.Link));{2}
end;

function TFhirVerificationResultValidator.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'identityCertificate') then
  begin
    IdentityCertificateElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'attestationSignature') then
  begin
    AttestationSignature := propValue as TFhirSignature{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirVerificationResultValidator.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirVerificationResultValidator.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'identityCertificate') then result := TFhirString.create() {5b}
  else if (propName = 'attestationSignature') then result := TFhirSignature.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirVerificationResultValidator.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'organization') then result := 'Reference'
  else if (propName = 'identityCertificate') then result := 'string'
  else if (propName = 'attestationSignature') then result := 'Signature'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVerificationResultValidator.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'identityCertificate') then IdentityCertificateElement := nil
  else if (propName = 'attestationSignature') then AttestationSignatureElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVerificationResultValidator.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'identityCertificate') then IdentityCertificateElement := asString(new){5b}
  else if (propName = 'attestationSignature') then AttestationSignatureElement := new as TFhirSignature{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVerificationResultValidator.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirVerificationResultValidator.fhirType : string;
begin
  result := 'validator';
end;

function TFhirVerificationResultValidator.Link : TFhirVerificationResultValidator;
begin
  result := TFhirVerificationResultValidator(inherited Link);
end;

function TFhirVerificationResultValidator.Clone : TFhirVerificationResultValidator;
begin
  result := TFhirVerificationResultValidator(inherited Clone);
end;

function TFhirVerificationResultValidator.equals(other : TObject) : boolean; 
var
  o : TFhirVerificationResultValidator;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVerificationResultValidator)) then
    result := false
  else
  begin
    o := TFhirVerificationResultValidator(other);
    result := compareDeep(organizationElement, o.organizationElement, true) and 
      compareDeep(identityCertificateElement, o.identityCertificateElement, true) and 
      compareDeep(attestationSignatureElement, o.attestationSignatureElement, true);
  end;
end;

function TFhirVerificationResultValidator.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOrganization) and isEmptyProp(FIdentityCertificate) and isEmptyProp(FAttestationSignature);
end;

procedure TFhirVerificationResultValidator.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('organization');
  fields.add('identityCertificate');
  fields.add('attestationSignature');
end;

{ TFhirVerificationResultValidator }

Procedure TFhirVerificationResultValidator.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirVerificationResultValidator.SetIdentityCertificate(value : TFhirString);
begin
  FIdentityCertificate.free;
  FIdentityCertificate := value;
end;

Function TFhirVerificationResultValidator.GetIdentityCertificateST : String;
begin
  if FIdentityCertificate = nil then
    result := ''
  else
    result := FIdentityCertificate.value;
end;

Procedure TFhirVerificationResultValidator.SetIdentityCertificateST(value : String);
begin
  if value <> '' then
  begin
    if FIdentityCertificate = nil then
      FIdentityCertificate := TFhirString.create;
    FIdentityCertificate.value := value
  end
  else if FIdentityCertificate <> nil then
    FIdentityCertificate.value := '';
end;

Procedure TFhirVerificationResultValidator.SetAttestationSignature(value : TFhirSignature);
begin
  FAttestationSignature.free;
  FAttestationSignature := value;
end;

function TFhirVerificationResultValidator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOrganization.sizeInBytes);
  inc(result, FIdentityCertificate.sizeInBytes);
  inc(result, FAttestationSignature.sizeInBytes);
end;

{ TFhirVerificationResultValidatorListEnumerator }

Constructor TFhirVerificationResultValidatorListEnumerator.Create(list : TFhirVerificationResultValidatorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVerificationResultValidatorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVerificationResultValidatorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVerificationResultValidatorListEnumerator.GetCurrent : TFhirVerificationResultValidator;
begin
  Result := FList[FIndex];
end;

function TFhirVerificationResultValidatorListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirVerificationResultValidatorList }
procedure TFhirVerificationResultValidatorList.AddItem(value: TFhirVerificationResultValidator);
begin
  assert(value.ClassName = 'TFhirVerificationResultValidator', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVerificationResultValidator');
  add(value);
end;

function TFhirVerificationResultValidatorList.Append: TFhirVerificationResultValidator;
begin
  result := TFhirVerificationResultValidator.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultValidatorList.ClearItems;
begin
  Clear;
end;

function TFhirVerificationResultValidatorList.GetEnumerator : TFhirVerificationResultValidatorListEnumerator;
begin
  result := TFhirVerificationResultValidatorListEnumerator.Create(self.link);
end;

function TFhirVerificationResultValidatorList.Clone: TFhirVerificationResultValidatorList;
begin
  result := TFhirVerificationResultValidatorList(inherited Clone);
end;

function TFhirVerificationResultValidatorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVerificationResultValidatorList.GetItemN(index: Integer): TFhirVerificationResultValidator;
begin
  result := TFhirVerificationResultValidator(ObjectByIndex[index]);
end;

function TFhirVerificationResultValidatorList.ItemClass: TFslObjectClass;
begin
  result := TFhirVerificationResultValidator;
end;
function TFhirVerificationResultValidatorList.IndexOf(value: TFhirVerificationResultValidator): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVerificationResultValidatorList.Insert(index: Integer): TFhirVerificationResultValidator;
begin
  result := TFhirVerificationResultValidator.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultValidatorList.InsertItem(index: Integer; value: TFhirVerificationResultValidator);
begin
  assert(value is TFhirVerificationResultValidator);
  Inherited Insert(index, value);
end;

function TFhirVerificationResultValidatorList.Item(index: Integer): TFhirVerificationResultValidator;
begin
  result := TFhirVerificationResultValidator(ObjectByIndex[index]);
end;

function TFhirVerificationResultValidatorList.Link: TFhirVerificationResultValidatorList;
begin
  result := TFhirVerificationResultValidatorList(inherited Link);
end;

procedure TFhirVerificationResultValidatorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVerificationResultValidatorList.SetItemByIndex(index: Integer; value: TFhirVerificationResultValidator);
begin
  assert(value is TFhirVerificationResultValidator);
  FhirVerificationResultValidators[index] := value;
end;

procedure TFhirVerificationResultValidatorList.SetItemN(index: Integer; value: TFhirVerificationResultValidator);
begin
  assert(value is TFhirVerificationResultValidator);
  ObjectByIndex[index] := value;
end;

{ TFhirVerificationResult }

constructor TFhirVerificationResult.Create;
begin
  inherited;
end;

destructor TFhirVerificationResult.Destroy;
begin
  FTargetList.Free;
  FTargetLocationList.Free;
  FNeed.free;
  FStatus.free;
  FStatusDate.free;
  FValidationType.free;
  FValidationProcessList.Free;
  FFrequency.free;
  FLastPerformed.free;
  FNextScheduled.free;
  FFailureAction.free;
  FPrimarySourceList.Free;
  FAttestation.free;
  FValidatorList.Free;
  inherited;
end;

function TFhirVerificationResult.GetResourceType : TFhirResourceType;
begin
  result := frtVerificationResult;
end;

procedure TFhirVerificationResult.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirVerificationResult(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirReferenceList{TFhirReference}.Create;
    FTargetList.Assign(TFhirVerificationResult(oSource).FTargetList);
  end;
  if (TFhirVerificationResult(oSource).FTargetLocationList = nil) then
  begin
    FTargetLocationList.free;
    FTargetLocationList := nil;
  end
  else
  begin
    if FTargetLocationList = nil then
      FTargetLocationList := TFhirStringList.Create;
    FTargetLocationList.Assign(TFhirVerificationResult(oSource).FTargetLocationList);
  end;
  need := TFhirVerificationResult(oSource).need.Clone;
  FStatus := TFhirVerificationResult(oSource).FStatus.Link;
  statusDateElement := TFhirVerificationResult(oSource).statusDateElement.Clone;
  validationType := TFhirVerificationResult(oSource).validationType.Clone;
  if (TFhirVerificationResult(oSource).FValidationProcessList = nil) then
  begin
    FValidationProcessList.free;
    FValidationProcessList := nil;
  end
  else
  begin
    if FValidationProcessList = nil then
      FValidationProcessList := TFhirCodeableConceptList.Create;
    FValidationProcessList.Assign(TFhirVerificationResult(oSource).FValidationProcessList);
  end;
  frequency := TFhirVerificationResult(oSource).frequency.Clone;
  lastPerformedElement := TFhirVerificationResult(oSource).lastPerformedElement.Clone;
  nextScheduledElement := TFhirVerificationResult(oSource).nextScheduledElement.Clone;
  failureAction := TFhirVerificationResult(oSource).failureAction.Clone;
  if (TFhirVerificationResult(oSource).FPrimarySourceList = nil) then
  begin
    FPrimarySourceList.free;
    FPrimarySourceList := nil;
  end
  else
  begin
    if FPrimarySourceList = nil then
      FPrimarySourceList := TFhirVerificationResultPrimarySourceList.Create;
    FPrimarySourceList.Assign(TFhirVerificationResult(oSource).FPrimarySourceList);
  end;
  attestation := TFhirVerificationResult(oSource).attestation.Clone;
  if (TFhirVerificationResult(oSource).FValidatorList = nil) then
  begin
    FValidatorList.free;
    FValidatorList := nil;
  end
  else
  begin
    if FValidatorList = nil then
      FValidatorList := TFhirVerificationResultValidatorList.Create;
    FValidatorList.Assign(TFhirVerificationResult(oSource).FValidatorList);
  end;
end;

procedure TFhirVerificationResult.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
  if (child_name = 'targetLocation') Then
    list.addAll(self, 'targetLocation', FTargetLocationList);
  if (child_name = 'need') Then
     list.add(self.link, 'need', FNeed.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'validationType') Then
     list.add(self.link, 'validationType', FValidationType.Link);
  if (child_name = 'validationProcess') Then
    list.addAll(self, 'validationProcess', FValidationProcessList);
  if (child_name = 'frequency') Then
     list.add(self.link, 'frequency', FFrequency.Link);
  if (child_name = 'lastPerformed') Then
     list.add(self.link, 'lastPerformed', FLastPerformed.Link);
  if (child_name = 'nextScheduled') Then
     list.add(self.link, 'nextScheduled', FNextScheduled.Link);
  if (child_name = 'failureAction') Then
     list.add(self.link, 'failureAction', FFailureAction.Link);
  if (child_name = 'primarySource') Then
    list.addAll(self, 'primarySource', FPrimarySourceList);
  if (child_name = 'attestation') Then
     list.add(self.link, 'attestation', FAttestation.Link);
  if (child_name = 'validator') Then
    list.addAll(self, 'validator', FValidatorList);
end;

procedure TFhirVerificationResult.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'target', 'Reference(Any)', true, TFhirReference{TFhirReference}, FTargetList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'targetLocation', 'string', true, TFhirString, FTargetLocationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'need', 'CodeableConcept', false, TFhirCodeableConcept, FNeed.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'statusDate', 'dateTime', false, TFhirDateTime, FStatusDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'validationType', 'CodeableConcept', false, TFhirCodeableConcept, FValidationType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'validationProcess', 'CodeableConcept', true, TFhirCodeableConcept, FValidationProcessList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'frequency', 'Timing', false, TFhirTiming, FFrequency.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lastPerformed', 'dateTime', false, TFhirDateTime, FLastPerformed.Link));{2}
  oList.add(TFHIRProperty.create(self, 'nextScheduled', 'date', false, TFhirDate, FNextScheduled.Link));{2}
  oList.add(TFHIRProperty.create(self, 'failureAction', 'CodeableConcept', false, TFhirCodeableConcept, FFailureAction.Link));{2}
  oList.add(TFHIRProperty.create(self, 'primarySource', '', true, TFhirVerificationResultPrimarySource, FPrimarySourceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'attestation', '', false, TFhirVerificationResultAttestation, FAttestation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'validator', '', true, TFhirVerificationResultValidator, FValidatorList.Link)){3};
end;

function TFhirVerificationResult.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'targetLocation') then
  begin
    TargetLocationList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'need') then
  begin
    Need := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirVerificationresultStatusEnum, CODES_TFhirVerificationresultStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'validationType') then
  begin
    ValidationType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'validationProcess') then
  begin
    ValidationProcessList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'frequency') then
  begin
    Frequency := propValue as TFhirTiming{4b};
    result := propValue;
  end
  else if (propName = 'lastPerformed') then
  begin
    LastPerformedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'nextScheduled') then
  begin
    NextScheduledElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'failureAction') then
  begin
    FailureAction := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'primarySource') then
  begin
    PrimarySourceList.add(propValue as TFhirVerificationResultPrimarySource){2a};
    result := propValue;
  end
  else if (propName = 'attestation') then
  begin
    Attestation := propValue as TFhirVerificationResultAttestation{4b};
    result := propValue;
  end
  else if (propName = 'validator') then
  begin
    ValidatorList.add(propValue as TFhirVerificationResultValidator){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirVerificationResult.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'targetLocation') then TargetLocationList.insertItem(index, asString(propValue)){2}
  else if (propName = 'validationProcess') then ValidationProcessList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'primarySource') then PrimarySourceList.insertItem(index, propValue as TFhirVerificationResultPrimarySource){2a}
  else if (propName = 'validator') then ValidatorList.insertItem(index, propValue as TFhirVerificationResultValidator){2a}
  else inherited;
end;

function TFhirVerificationResult.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'target') then result := TargetList.new(){2}
  else if (propName = 'targetLocation') then result := TargetLocationList.new(){2}
  else if (propName = 'need') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'statusDate') then result := TFhirDateTime.create() {5b}
  else if (propName = 'validationType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'validationProcess') then result := ValidationProcessList.new(){2}
  else if (propName = 'frequency') then result := TFhirTiming.create(){4b}
  else if (propName = 'lastPerformed') then result := TFhirDateTime.create() {5b}
  else if (propName = 'nextScheduled') then result := TFhirDate.create() {5b}
  else if (propName = 'failureAction') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'primarySource') then result := PrimarySourceList.new(){2}
  else if (propName = 'attestation') then result := TFhirVerificationResultAttestation.create(){4b}
  else if (propName = 'validator') then result := ValidatorList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirVerificationResult.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'target') then result := 'Reference'
  else if (propName = 'targetLocation') then result := 'string'
  else if (propName = 'need') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusDate') then result := 'dateTime'
  else if (propName = 'validationType') then result := 'CodeableConcept'
  else if (propName = 'validationProcess') then result := 'CodeableConcept'
  else if (propName = 'frequency') then result := 'Timing'
  else if (propName = 'lastPerformed') then result := 'dateTime'
  else if (propName = 'nextScheduled') then result := 'date'
  else if (propName = 'failureAction') then result := 'CodeableConcept'
  else if (propName = 'primarySource') then result := ''
  else if (propName = 'attestation') then result := ''
  else if (propName = 'validator') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVerificationResult.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'target') then deletePropertyValue('target', TargetList, value) {2}
  else if (propName = 'targetLocation') then deletePropertyValue('targetLocation', TargetLocationList, value) {2}
  else if (propName = 'need') then NeedElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'validationType') then ValidationTypeElement := nil
  else if (propName = 'validationProcess') then deletePropertyValue('validationProcess', ValidationProcessList, value) {2}
  else if (propName = 'frequency') then FrequencyElement := nil
  else if (propName = 'lastPerformed') then LastPerformedElement := nil
  else if (propName = 'nextScheduled') then NextScheduledElement := nil
  else if (propName = 'failureAction') then FailureActionElement := nil
  else if (propName = 'primarySource') then deletePropertyValue('primarySource', PrimarySourceList, value) {2}
  else if (propName = 'attestation') then AttestationElement := nil
  else if (propName = 'validator') then deletePropertyValue('validator', ValidatorList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVerificationResult.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new) {2}
  else if (propName = 'targetLocation') then replacePropertyValue('targetLocation', TargetLocationList, existing, new) {2}
  else if (propName = 'need') then NeedElement := new as TFhirCodeableConcept{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirVerificationresultStatusEnum, CODES_TFhirVerificationresultStatusEnum, new){4}
  else if (propName = 'statusDate') then StatusDateElement := asDateTime(new){5b}
  else if (propName = 'validationType') then ValidationTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'validationProcess') then replacePropertyValue('validationProcess', ValidationProcessList, existing, new) {2}
  else if (propName = 'frequency') then FrequencyElement := new as TFhirTiming{4}
  else if (propName = 'lastPerformed') then LastPerformedElement := asDateTime(new){5b}
  else if (propName = 'nextScheduled') then NextScheduledElement := asDate(new){5b}
  else if (propName = 'failureAction') then FailureActionElement := new as TFhirCodeableConcept{4}
  else if (propName = 'primarySource') then replacePropertyValue('primarySource', PrimarySourceList, existing, new) {2}
  else if (propName = 'attestation') then AttestationElement := new as TFhirVerificationResultAttestation{4}
  else if (propName = 'validator') then replacePropertyValue('validator', ValidatorList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVerificationResult.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'target') then TargetList.move(source, destination){2a}
  else if (propName = 'targetLocation') then TargetLocationList.move(source, destination){2}
  else if (propName = 'validationProcess') then ValidationProcessList.move(source, destination){2a}
  else if (propName = 'primarySource') then PrimarySourceList.move(source, destination){2a}
  else if (propName = 'validator') then ValidatorList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirVerificationResult.fhirType : string;
begin
  result := 'VerificationResult';
end;

function TFhirVerificationResult.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FtargetList) and isEmptyProp(FtargetLocationList) and isEmptyProp(FNeed) and isEmptyProp(FStatus) and isEmptyProp(FStatusDate) and isEmptyProp(FValidationType) and isEmptyProp(FvalidationProcessList) and isEmptyProp(FFrequency) and isEmptyProp(FLastPerformed) and isEmptyProp(FNextScheduled) and isEmptyProp(FFailureAction) and isEmptyProp(FprimarySourceList) and isEmptyProp(FAttestation) and isEmptyProp(FvalidatorList);
end;

function TFhirVerificationResult.equals(other : TObject) : boolean; 
var
  o : TFhirVerificationResult;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVerificationResult)) then
    result := false
  else
  begin
    o := TFhirVerificationResult(other);
    result := compareDeep(targetList, o.targetList, true) and compareDeep(targetLocationList, o.targetLocationList, true) and 
      compareDeep(needElement, o.needElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusDateElement, o.statusDateElement, true) and compareDeep(validationTypeElement, o.validationTypeElement, true) and 
      compareDeep(validationProcessList, o.validationProcessList, true) and compareDeep(frequencyElement, o.frequencyElement, true) and 
      compareDeep(lastPerformedElement, o.lastPerformedElement, true) and compareDeep(nextScheduledElement, o.nextScheduledElement, true) and 
      compareDeep(failureActionElement, o.failureActionElement, true) and compareDeep(primarySourceList, o.primarySourceList, true) and 
      compareDeep(attestationElement, o.attestationElement, true) and compareDeep(validatorList, o.validatorList, true);
  end;
end;

function TFhirVerificationResult.Link : TFhirVerificationResult;
begin
  result := TFhirVerificationResult(inherited Link);
end;

function TFhirVerificationResult.Clone : TFhirVerificationResult;
begin
  result := TFhirVerificationResult(inherited Clone);
end;

procedure TFhirVerificationResult.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('target');
  fields.add('targetLocation');
  fields.add('need');
  fields.add('status');
  fields.add('statusDate');
  fields.add('validationType');
  fields.add('validationProcess');
  fields.add('frequency');
  fields.add('lastPerformed');
  fields.add('nextScheduled');
  fields.add('failureAction');
  fields.add('primarySource');
  fields.add('attestation');
  fields.add('validator');
end;

{ TFhirVerificationResult }

Function TFhirVerificationResult.GetTargetList : TFhirReferenceList{TFhirReference};
begin
  if FTargetList = nil then
    FTargetList := TFhirReferenceList{TFhirReference}.Create;
  result := FTargetList;
end;

Function TFhirVerificationResult.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

Function TFhirVerificationResult.GetTargetLocationList : TFhirStringList;
begin
  if FTargetLocationList = nil then
    FTargetLocationList := TFhirStringList.Create;
  result := FTargetLocationList;
end;

Function TFhirVerificationResult.GetHasTargetLocationList : boolean;
begin
  result := (FTargetLocationList <> nil) and (FTargetLocationList.count > 0);
end;

Procedure TFhirVerificationResult.SetNeed(value : TFhirCodeableConcept);
begin
  FNeed.free;
  FNeed := value;
end;

Procedure TFhirVerificationResult.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirVerificationResult.GetStatusST : TFhirVerificationresultStatusEnum;
begin
  if FStatus = nil then
    result := TFhirVerificationresultStatusEnum(0)
  else
    result := TFhirVerificationresultStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirVerificationresultStatusEnum, FStatus.value));
end;

Procedure TFhirVerificationResult.SetStatusST(value : TFhirVerificationresultStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirVerificationresultStatusEnum[value], CODES_TFhirVerificationresultStatusEnum[value]);
end;

Procedure TFhirVerificationResult.SetStatusDate(value : TFhirDateTime);
begin
  FStatusDate.free;
  FStatusDate := value;
end;

Function TFhirVerificationResult.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

Procedure TFhirVerificationResult.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDateTime.create;
  FStatusDate.value := value
end;

Procedure TFhirVerificationResult.SetValidationType(value : TFhirCodeableConcept);
begin
  FValidationType.free;
  FValidationType := value;
end;

Function TFhirVerificationResult.GetValidationProcessList : TFhirCodeableConceptList;
begin
  if FValidationProcessList = nil then
    FValidationProcessList := TFhirCodeableConceptList.Create;
  result := FValidationProcessList;
end;

Function TFhirVerificationResult.GetHasValidationProcessList : boolean;
begin
  result := (FValidationProcessList <> nil) and (FValidationProcessList.count > 0);
end;

Procedure TFhirVerificationResult.SetFrequency(value : TFhirTiming);
begin
  FFrequency.free;
  FFrequency := value;
end;

Procedure TFhirVerificationResult.SetLastPerformed(value : TFhirDateTime);
begin
  FLastPerformed.free;
  FLastPerformed := value;
end;

Function TFhirVerificationResult.GetLastPerformedST : TFslDateTime;
begin
  if FLastPerformed = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastPerformed.value;
end;

Procedure TFhirVerificationResult.SetLastPerformedST(value : TFslDateTime);
begin
  if FLastPerformed = nil then
    FLastPerformed := TFhirDateTime.create;
  FLastPerformed.value := value
end;

Procedure TFhirVerificationResult.SetNextScheduled(value : TFhirDate);
begin
  FNextScheduled.free;
  FNextScheduled := value;
end;

Function TFhirVerificationResult.GetNextScheduledST : TFslDateTime;
begin
  if FNextScheduled = nil then
    result := TFslDateTime.makeNull
  else
    result := FNextScheduled.value;
end;

Procedure TFhirVerificationResult.SetNextScheduledST(value : TFslDateTime);
begin
  if FNextScheduled = nil then
    FNextScheduled := TFhirDate.create;
  FNextScheduled.value := value
end;

Procedure TFhirVerificationResult.SetFailureAction(value : TFhirCodeableConcept);
begin
  FFailureAction.free;
  FFailureAction := value;
end;

Function TFhirVerificationResult.GetPrimarySourceList : TFhirVerificationResultPrimarySourceList;
begin
  if FPrimarySourceList = nil then
    FPrimarySourceList := TFhirVerificationResultPrimarySourceList.Create;
  result := FPrimarySourceList;
end;

Function TFhirVerificationResult.GetHasPrimarySourceList : boolean;
begin
  result := (FPrimarySourceList <> nil) and (FPrimarySourceList.count > 0);
end;

Procedure TFhirVerificationResult.SetAttestation(value : TFhirVerificationResultAttestation);
begin
  FAttestation.free;
  FAttestation := value;
end;

Function TFhirVerificationResult.GetValidatorList : TFhirVerificationResultValidatorList;
begin
  if FValidatorList = nil then
    FValidatorList := TFhirVerificationResultValidatorList.Create;
  result := FValidatorList;
end;

Function TFhirVerificationResult.GetHasValidatorList : boolean;
begin
  result := (FValidatorList <> nil) and (FValidatorList.count > 0);
end;

function TFhirVerificationResult.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FtargetList.sizeInBytes);
  inc(result, FtargetLocationList.sizeInBytes);
  inc(result, FNeed.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStatusDate.sizeInBytes);
  inc(result, FValidationType.sizeInBytes);
  inc(result, FvalidationProcessList.sizeInBytes);
  inc(result, FFrequency.sizeInBytes);
  inc(result, FLastPerformed.sizeInBytes);
  inc(result, FNextScheduled.sizeInBytes);
  inc(result, FFailureAction.sizeInBytes);
  inc(result, FprimarySourceList.sizeInBytes);
  inc(result, FAttestation.sizeInBytes);
  inc(result, FvalidatorList.sizeInBytes);
end;

{ TFhirVerificationResultListEnumerator }

Constructor TFhirVerificationResultListEnumerator.Create(list : TFhirVerificationResultList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVerificationResultListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVerificationResultListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVerificationResultListEnumerator.GetCurrent : TFhirVerificationResult;
begin
  Result := FList[FIndex];
end;

function TFhirVerificationResultListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirVerificationResultList }
procedure TFhirVerificationResultList.AddItem(value: TFhirVerificationResult);
begin
  assert(value.ClassName = 'TFhirVerificationResult', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVerificationResult');
  add(value);
end;

function TFhirVerificationResultList.Append: TFhirVerificationResult;
begin
  result := TFhirVerificationResult.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultList.ClearItems;
begin
  Clear;
end;

function TFhirVerificationResultList.GetEnumerator : TFhirVerificationResultListEnumerator;
begin
  result := TFhirVerificationResultListEnumerator.Create(self.link);
end;

function TFhirVerificationResultList.Clone: TFhirVerificationResultList;
begin
  result := TFhirVerificationResultList(inherited Clone);
end;

function TFhirVerificationResultList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVerificationResultList.GetItemN(index: Integer): TFhirVerificationResult;
begin
  result := TFhirVerificationResult(ObjectByIndex[index]);
end;

function TFhirVerificationResultList.ItemClass: TFslObjectClass;
begin
  result := TFhirVerificationResult;
end;
function TFhirVerificationResultList.IndexOf(value: TFhirVerificationResult): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVerificationResultList.Insert(index: Integer): TFhirVerificationResult;
begin
  result := TFhirVerificationResult.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultList.InsertItem(index: Integer; value: TFhirVerificationResult);
begin
  assert(value is TFhirVerificationResult);
  Inherited Insert(index, value);
end;

function TFhirVerificationResultList.Item(index: Integer): TFhirVerificationResult;
begin
  result := TFhirVerificationResult(ObjectByIndex[index]);
end;

function TFhirVerificationResultList.Link: TFhirVerificationResultList;
begin
  result := TFhirVerificationResultList(inherited Link);
end;

procedure TFhirVerificationResultList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVerificationResultList.SetItemByIndex(index: Integer; value: TFhirVerificationResult);
begin
  assert(value is TFhirVerificationResult);
  FhirVerificationResults[index] := value;
end;

procedure TFhirVerificationResultList.SetItemN(index: Integer; value: TFhirVerificationResult);
begin
  assert(value is TFhirVerificationResult);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_VERIFICATIONRESULT}

end.

