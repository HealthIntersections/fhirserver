unit fhir4_resources_financial;

{$I fhir4.inc}

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to
     endorse or promote products derived from this software without specific
     prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

}

{$I fhir.inc}

interface

// FHIR v4.0.0 generated 2019-01-21T22:41:56+11:00

uses
  SysUtils, Classes,
  fsl_base, fsl_utilities, fsl_stream,
  fhir_objects, 
  fhir4_types, fhir4_resources_base;

Type
{$IFDEF FHIR_CHARGEITEM}
  TFhirChargeItemPerformer = class;
  TFhirChargeItemPerformerList = class;
  TFhirChargeItem = class;
  TFhirChargeItemList = class;
{$ENDIF FHIR_CHARGEITEM}
{$IFDEF FHIR_CLAIM}
  TFhirClaimRelated = class;
  TFhirClaimRelatedList = class;
  TFhirClaimPayee = class;
  TFhirClaimPayeeList = class;
  TFhirClaimCareTeam = class;
  TFhirClaimCareTeamList = class;
  TFhirClaimSupportingInfo = class;
  TFhirClaimSupportingInfoList = class;
  TFhirClaimDiagnosis = class;
  TFhirClaimDiagnosisList = class;
  TFhirClaimProcedure = class;
  TFhirClaimProcedureList = class;
  TFhirClaimInsurance = class;
  TFhirClaimInsuranceList = class;
  TFhirClaimAccident = class;
  TFhirClaimAccidentList = class;
  TFhirClaimItem = class;
  TFhirClaimItemList = class;
  TFhirClaimItemDetail = class;
  TFhirClaimItemDetailList = class;
  TFhirClaimItemDetailSubDetail = class;
  TFhirClaimItemDetailSubDetailList = class;
  TFhirClaim = class;
  TFhirClaimList = class;
{$ENDIF FHIR_CLAIM}
{$IFDEF FHIR_CLAIMRESPONSE}
  TFhirClaimResponseItem = class;
  TFhirClaimResponseItemList = class;
  TFhirClaimResponseItemAdjudication = class;
  TFhirClaimResponseItemAdjudicationList = class;
  TFhirClaimResponseItemDetail = class;
  TFhirClaimResponseItemDetailList = class;
  TFhirClaimResponseItemDetailSubDetail = class;
  TFhirClaimResponseItemDetailSubDetailList = class;
  TFhirClaimResponseAddItem = class;
  TFhirClaimResponseAddItemList = class;
  TFhirClaimResponseAddItemDetail = class;
  TFhirClaimResponseAddItemDetailList = class;
  TFhirClaimResponseAddItemDetailSubDetail = class;
  TFhirClaimResponseAddItemDetailSubDetailList = class;
  TFhirClaimResponseTotal = class;
  TFhirClaimResponseTotalList = class;
  TFhirClaimResponsePayment = class;
  TFhirClaimResponsePaymentList = class;
  TFhirClaimResponseProcessNote = class;
  TFhirClaimResponseProcessNoteList = class;
  TFhirClaimResponseInsurance = class;
  TFhirClaimResponseInsuranceList = class;
  TFhirClaimResponseError = class;
  TFhirClaimResponseErrorList = class;
  TFhirClaimResponse = class;
  TFhirClaimResponseList = class;
{$ENDIF FHIR_CLAIMRESPONSE}
{$IFDEF FHIR_COVERAGE}
  TFhirCoverageClass = class;
  TFhirCoverageClassList = class;
  TFhirCoverageCostToBeneficiary = class;
  TFhirCoverageCostToBeneficiaryList = class;
  TFhirCoverageCostToBeneficiaryException = class;
  TFhirCoverageCostToBeneficiaryExceptionList = class;
  TFhirCoverage = class;
  TFhirCoverageList = class;
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}
  TFhirCoverageEligibilityRequestSupportingInfo = class;
  TFhirCoverageEligibilityRequestSupportingInfoList = class;
  TFhirCoverageEligibilityRequestInsurance = class;
  TFhirCoverageEligibilityRequestInsuranceList = class;
  TFhirCoverageEligibilityRequestItem = class;
  TFhirCoverageEligibilityRequestItemList = class;
  TFhirCoverageEligibilityRequestItemDiagnosis = class;
  TFhirCoverageEligibilityRequestItemDiagnosisList = class;
  TFhirCoverageEligibilityRequest = class;
  TFhirCoverageEligibilityRequestList = class;
{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}
{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}
  TFhirCoverageEligibilityResponseInsurance = class;
  TFhirCoverageEligibilityResponseInsuranceList = class;
  TFhirCoverageEligibilityResponseInsuranceItem = class;
  TFhirCoverageEligibilityResponseInsuranceItemList = class;
  TFhirCoverageEligibilityResponseInsuranceItemBenefit = class;
  TFhirCoverageEligibilityResponseInsuranceItemBenefitList = class;
  TFhirCoverageEligibilityResponseError = class;
  TFhirCoverageEligibilityResponseErrorList = class;
  TFhirCoverageEligibilityResponse = class;
  TFhirCoverageEligibilityResponseList = class;
{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}
{$IFDEF FHIR_ENROLLMENTREQUEST}
  TFhirEnrollmentRequest = class;
  TFhirEnrollmentRequestList = class;
{$ENDIF FHIR_ENROLLMENTREQUEST}
{$IFDEF FHIR_ENROLLMENTRESPONSE}
  TFhirEnrollmentResponse = class;
  TFhirEnrollmentResponseList = class;
{$ENDIF FHIR_ENROLLMENTRESPONSE}
{$IFDEF FHIR_EXPLANATIONOFBENEFIT}
  TFhirExplanationOfBenefitRelated = class;
  TFhirExplanationOfBenefitRelatedList = class;
  TFhirExplanationOfBenefitPayee = class;
  TFhirExplanationOfBenefitPayeeList = class;
  TFhirExplanationOfBenefitCareTeam = class;
  TFhirExplanationOfBenefitCareTeamList = class;
  TFhirExplanationOfBenefitSupportingInfo = class;
  TFhirExplanationOfBenefitSupportingInfoList = class;
  TFhirExplanationOfBenefitDiagnosis = class;
  TFhirExplanationOfBenefitDiagnosisList = class;
  TFhirExplanationOfBenefitProcedure = class;
  TFhirExplanationOfBenefitProcedureList = class;
  TFhirExplanationOfBenefitInsurance = class;
  TFhirExplanationOfBenefitInsuranceList = class;
  TFhirExplanationOfBenefitAccident = class;
  TFhirExplanationOfBenefitAccidentList = class;
  TFhirExplanationOfBenefitItem = class;
  TFhirExplanationOfBenefitItemList = class;
  TFhirExplanationOfBenefitItemAdjudication = class;
  TFhirExplanationOfBenefitItemAdjudicationList = class;
  TFhirExplanationOfBenefitItemDetail = class;
  TFhirExplanationOfBenefitItemDetailList = class;
  TFhirExplanationOfBenefitItemDetailSubDetail = class;
  TFhirExplanationOfBenefitItemDetailSubDetailList = class;
  TFhirExplanationOfBenefitAddItem = class;
  TFhirExplanationOfBenefitAddItemList = class;
  TFhirExplanationOfBenefitAddItemDetail = class;
  TFhirExplanationOfBenefitAddItemDetailList = class;
  TFhirExplanationOfBenefitAddItemDetailSubDetail = class;
  TFhirExplanationOfBenefitAddItemDetailSubDetailList = class;
  TFhirExplanationOfBenefitTotal = class;
  TFhirExplanationOfBenefitTotalList = class;
  TFhirExplanationOfBenefitPayment = class;
  TFhirExplanationOfBenefitPaymentList = class;
  TFhirExplanationOfBenefitProcessNote = class;
  TFhirExplanationOfBenefitProcessNoteList = class;
  TFhirExplanationOfBenefitBenefitBalance = class;
  TFhirExplanationOfBenefitBenefitBalanceList = class;
  TFhirExplanationOfBenefitBenefitBalanceFinancial = class;
  TFhirExplanationOfBenefitBenefitBalanceFinancialList = class;
  TFhirExplanationOfBenefit = class;
  TFhirExplanationOfBenefitList = class;
{$ENDIF FHIR_EXPLANATIONOFBENEFIT}
{$IFDEF FHIR_INSURANCEPLAN}
  TFhirInsurancePlanContact = class;
  TFhirInsurancePlanContactList = class;
  TFhirInsurancePlanCoverage = class;
  TFhirInsurancePlanCoverageList = class;
  TFhirInsurancePlanCoverageBenefit = class;
  TFhirInsurancePlanCoverageBenefitList = class;
  TFhirInsurancePlanCoverageBenefitLimit = class;
  TFhirInsurancePlanCoverageBenefitLimitList = class;
  TFhirInsurancePlanPlan = class;
  TFhirInsurancePlanPlanList = class;
  TFhirInsurancePlanPlanGeneralCost = class;
  TFhirInsurancePlanPlanGeneralCostList = class;
  TFhirInsurancePlanPlanSpecificCost = class;
  TFhirInsurancePlanPlanSpecificCostList = class;
  TFhirInsurancePlanPlanSpecificCostBenefit = class;
  TFhirInsurancePlanPlanSpecificCostBenefitList = class;
  TFhirInsurancePlanPlanSpecificCostBenefitCost = class;
  TFhirInsurancePlanPlanSpecificCostBenefitCostList = class;
  TFhirInsurancePlan = class;
  TFhirInsurancePlanList = class;
{$ENDIF FHIR_INSURANCEPLAN}
{$IFDEF FHIR_INVOICE}
  TFhirInvoiceParticipant = class;
  TFhirInvoiceParticipantList = class;
  TFhirInvoiceLineItem = class;
  TFhirInvoiceLineItemList = class;
  TFhirInvoiceLineItemPriceComponent = class;
  TFhirInvoiceLineItemPriceComponentList = class;
  TFhirInvoice = class;
  TFhirInvoiceList = class;
{$ENDIF FHIR_INVOICE}
{$IFDEF FHIR_PAYMENTNOTICE}
  TFhirPaymentNotice = class;
  TFhirPaymentNoticeList = class;
{$ENDIF FHIR_PAYMENTNOTICE}
{$IFDEF FHIR_PAYMENTRECONCILIATION}
  TFhirPaymentReconciliationDetail = class;
  TFhirPaymentReconciliationDetailList = class;
  TFhirPaymentReconciliationProcessNote = class;
  TFhirPaymentReconciliationProcessNoteList = class;
  TFhirPaymentReconciliation = class;
  TFhirPaymentReconciliationList = class;
{$ENDIF FHIR_PAYMENTRECONCILIATION}

{$IFDEF FHIR_CHARGEITEM}

  // Indicates who or what performed or participated in the charged service.
  TFhirChargeItemPerformer = class (TFhirBackboneElement)
  protected
    FFunction_ : TFhirCodeableConcept;
    FActor : TFhirReference{TFhirPractitioner};
    Procedure SetFunction_(value : TFhirCodeableConcept);
    Procedure SetActor(value : TFhirReference{TFhirPractitioner});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirChargeItemPerformer; overload;
    function Clone : TFhirChargeItemPerformer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Describes the type of performance or participation(e.g. primary surgeon, anesthesiologiest, etc.). (defined for API consistency)
    property function_ : TFhirCodeableConcept read FFunction_ write SetFunction_;
    // Describes the type of performance or participation(e.g. primary surgeon, anesthesiologiest, etc.).
    property function_Element : TFhirCodeableConcept read FFunction_ write SetFunction_;

    // Typed access to The device, practitioner, etc. who performed or participated in the service. (defined for API consistency)
    property actor : TFhirReference{TFhirPractitioner} read FActor write SetActor;
    // The device, practitioner, etc. who performed or participated in the service.
    property actorElement : TFhirReference{TFhirPractitioner} read FActor write SetActor;

  end;

  TFhirChargeItemPerformerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirChargeItemPerformerList;
    function GetCurrent : TFhirChargeItemPerformer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirChargeItemPerformerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirChargeItemPerformer read GetCurrent;
  end;

  TFhirChargeItemPerformerList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirChargeItemPerformer;
    procedure SetItemN(index : Integer; value : TFhirChargeItemPerformer);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirChargeItemPerformerList; Overload;
    function Clone : TFhirChargeItemPerformerList; Overload;
    function GetEnumerator : TFhirChargeItemPerformerListEnumerator;
    

    //  Add a FhirChargeItemPerformer to the end of the list.
    function Append : TFhirChargeItemPerformer;

    
    // Add an already existing FhirChargeItemPerformer to the end of the list.
    procedure AddItem(value : TFhirChargeItemPerformer); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirChargeItemPerformer) : Integer;
    

    // Insert FhirChargeItemPerformer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirChargeItemPerformer;
    

    // Insert an existing FhirChargeItemPerformer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirChargeItemPerformer);
    
    // Get the iIndexth FhirChargeItemPerformer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirChargeItemPerformer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirChargeItemPerformer;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirChargeItemPerformers[index : Integer] : TFhirChargeItemPerformer read GetItemN write SetItemN; default;
  End;

  // The resource ChargeItem describes the provision of healthcare provider products for a certain patient, therefore referring not only to the product, but containing in addition details of the provision, like date, time, amounts and participating organizations and persons. Main Usage of the ChargeItem is to enable the billing process and internal cost allocation.
  TFhirChargeItem = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FdefinitionUriList : TFhirUriList;
    FdefinitionCanonicalList : TFhirCanonicalList;
    FStatus : TFhirEnum;
    FpartOfList : TFhirReferenceList{TFhirChargeItem};
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference{TFhirPatient};
    FContext : TFhirReference{TFhirEncounter};
    FOccurrence : TFhirType;
    FperformerList : TFhirChargeItemPerformerList;
    FPerformingOrganization : TFhirReference{TFhirOrganization};
    FRequestingOrganization : TFhirReference{TFhirOrganization};
    FCostCenter : TFhirReference{TFhirOrganization};
    FQuantity : TFhirQuantity;
    FbodysiteList : TFhirCodeableConceptList;
    FFactorOverride : TFhirDecimal;
    FPriceOverride : TFhirMoney;
    FOverrideReason : TFhirString;
    FEnterer : TFhirReference{TFhirPractitioner};
    FEnteredDate : TFhirDateTime;
    FreasonList : TFhirCodeableConceptList;
    FserviceList : TFhirReferenceList{TFhirDiagnosticReport};
    FProduct : TFhirType;
    FaccountList : TFhirReferenceList{TFhirAccount};
    FnoteList : TFhirAnnotationList;
    FsupportingInformationList : TFhirReferenceList{TFhirReference};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetDefinitionUriList : TFhirUriList;
    function GetHasDefinitionUriList : Boolean;
    function GetDefinitionCanonicalList : TFhirCanonicalList;
    function GetHasDefinitionCanonicalList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirChargeitemStatusEnum;
    Procedure SetStatusST(value : TFhirChargeitemStatusEnum);
    function GetPartOfList : TFhirReferenceList{TFhirChargeItem};
    function GetHasPartOfList : Boolean;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{TFhirPatient});
    Procedure SetContext(value : TFhirReference{TFhirEncounter});
    Procedure SetOccurrence(value : TFhirType);
    function GetPerformerList : TFhirChargeItemPerformerList;
    function GetHasPerformerList : Boolean;
    Procedure SetPerformingOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetRequestingOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetCostCenter(value : TFhirReference{TFhirOrganization});
    Procedure SetQuantity(value : TFhirQuantity);
    function GetBodysiteList : TFhirCodeableConceptList;
    function GetHasBodysiteList : Boolean;
    Procedure SetFactorOverride(value : TFhirDecimal);
    Function GetFactorOverrideST : String;
    Procedure SetFactorOverrideST(value : String);
    Procedure SetPriceOverride(value : TFhirMoney);
    Procedure SetOverrideReason(value : TFhirString);
    Function GetOverrideReasonST : String;
    Procedure SetOverrideReasonST(value : String);
    Procedure SetEnterer(value : TFhirReference{TFhirPractitioner});
    Procedure SetEnteredDate(value : TFhirDateTime);
    Function GetEnteredDateST : TFslDateTime;
    Procedure SetEnteredDateST(value : TFslDateTime);
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
    function GetServiceList : TFhirReferenceList{TFhirDiagnosticReport};
    function GetHasServiceList : Boolean;
    Procedure SetProduct(value : TFhirType);
    function GetAccountList : TFhirReferenceList{TFhirAccount};
    function GetHasAccountList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetSupportingInformationList : TFhirReferenceList{TFhirReference};
    function GetHasSupportingInformationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirChargeItem; overload;
    function Clone : TFhirChargeItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifiers assigned to this event performer or other systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // References the (external) source of pricing information, rules of application for the code this ChargeItem uses.
    property definitionUriList : TFhirUriList read GetDefinitionUriList;
    property hasDefinitionUriList : boolean read GetHasDefinitionUriList;

    // References the source of pricing information, rules of application for the code this ChargeItem uses.
    property definitionCanonicalList : TFhirCanonicalList read GetDefinitionCanonicalList;
    property hasDefinitionCanonicalList : boolean read GetHasDefinitionCanonicalList;

    // The current state of the ChargeItem.
    property status : TFhirChargeitemStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // ChargeItems can be grouped to larger ChargeItems covering the whole set.
    property partOfList : TFhirReferenceList{TFhirChargeItem} read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // Typed access to A code that identifies the charge, like a billing code. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies the charge, like a billing code.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The individual or set of individuals the action is being or was performed on. (defined for API consistency)
    property subject : TFhirReference{TFhirPatient} read FSubject write SetSubject;
    // The individual or set of individuals the action is being or was performed on.
    property subjectElement : TFhirReference{TFhirPatient} read FSubject write SetSubject;

    // Typed access to The encounter or episode of care that establishes the context for this event. (defined for API consistency)
    property context : TFhirReference{TFhirEncounter} read FContext write SetContext;
    // The encounter or episode of care that establishes the context for this event.
    property contextElement : TFhirReference{TFhirEncounter} read FContext write SetContext;

    // Typed access to Date/time(s) or duration when the charged service was applied. (defined for API consistency)
    property occurrence : TFhirType read FOccurrence write SetOccurrence;
    // Date/time(s) or duration when the charged service was applied.
    property occurrenceElement : TFhirType read FOccurrence write SetOccurrence;

    // Indicates who or what performed or participated in the charged service.
    property performerList : TFhirChargeItemPerformerList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Typed access to The organization requesting the service. (defined for API consistency)
    property performingOrganization : TFhirReference{TFhirOrganization} read FPerformingOrganization write SetPerformingOrganization;
    // The organization requesting the service.
    property performingOrganizationElement : TFhirReference{TFhirOrganization} read FPerformingOrganization write SetPerformingOrganization;

    // Typed access to The organization performing the service. (defined for API consistency)
    property requestingOrganization : TFhirReference{TFhirOrganization} read FRequestingOrganization write SetRequestingOrganization;
    // The organization performing the service.
    property requestingOrganizationElement : TFhirReference{TFhirOrganization} read FRequestingOrganization write SetRequestingOrganization;

    // Typed access to The financial cost center permits the tracking of charge attribution. (defined for API consistency)
    property costCenter : TFhirReference{TFhirOrganization} read FCostCenter write SetCostCenter;
    // The financial cost center permits the tracking of charge attribution.
    property costCenterElement : TFhirReference{TFhirOrganization} read FCostCenter write SetCostCenter;

    // Typed access to Quantity of which the charge item has been serviced. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Quantity of which the charge item has been serviced.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // The anatomical location where the related service has been applied.
    property bodysiteList : TFhirCodeableConceptList read GetBodysiteList;
    property hasBodysiteList : boolean read GetHasBodysiteList;

    // Typed access to Factor overriding the factor determined by the rules associated with the code.
    property factorOverride : String read GetFactorOverrideST write SetFactorOverrideST;
    // Factor overriding the factor determined by the rules associated with the code.
    property factorOverrideElement : TFhirDecimal read FFactorOverride write SetFactorOverride;

    // Typed access to Total price of the charge overriding the list price associated with the code. (defined for API consistency)
    property priceOverride : TFhirMoney read FPriceOverride write SetPriceOverride;
    // Total price of the charge overriding the list price associated with the code.
    property priceOverrideElement : TFhirMoney read FPriceOverride write SetPriceOverride;

    // Typed access to If the list price or the rule-based factor associated with the code is overridden, this attribute can capture a text to indicate the  reason for this action.
    property overrideReason : String read GetOverrideReasonST write SetOverrideReasonST;
    // If the list price or the rule-based factor associated with the code is overridden, this attribute can capture a text to indicate the  reason for this action.
    property overrideReasonElement : TFhirString read FOverrideReason write SetOverrideReason;

    // Typed access to The device, practitioner, etc. who entered the charge item. (defined for API consistency)
    property enterer : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;
    // The device, practitioner, etc. who entered the charge item.
    property entererElement : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;

    // Typed access to Date the charge item was entered.
    property enteredDate : TFslDateTime read GetEnteredDateST write SetEnteredDateST;
    // Date the charge item was entered.
    property enteredDateElement : TFhirDateTime read FEnteredDate write SetEnteredDate;

    // Describes why the event occurred in coded or textual form.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Indicated the rendered service that caused this charge.
    property serviceList : TFhirReferenceList{TFhirDiagnosticReport} read GetServiceList;
    property hasServiceList : boolean read GetHasServiceList;

    // Typed access to Identifies the device, food, drug or other product being charged either by type code or reference to an instance. (defined for API consistency)
    property product : TFhirType read FProduct write SetProduct;
    // Identifies the device, food, drug or other product being charged either by type code or reference to an instance.
    property productElement : TFhirType read FProduct write SetProduct;

    // Account into which this ChargeItems belongs.
    property accountList : TFhirReferenceList{TFhirAccount} read GetAccountList;
    property hasAccountList : boolean read GetHasAccountList;

    // Comments made about the event by the performer, subject or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Further information supporting this charge.
    property supportingInformationList : TFhirReferenceList{TFhirReference} read GetSupportingInformationList;
    property hasSupportingInformationList : boolean read GetHasSupportingInformationList;

  end;

  TFhirChargeItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirChargeItemList;
    function GetCurrent : TFhirChargeItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirChargeItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirChargeItem read GetCurrent;
  end;

  TFhirChargeItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirChargeItem;
    procedure SetItemN(index : Integer; value : TFhirChargeItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirChargeItemList; Overload;
    function Clone : TFhirChargeItemList; Overload;
    function GetEnumerator : TFhirChargeItemListEnumerator;
    

    //  Add a FhirChargeItem to the end of the list.
    function Append : TFhirChargeItem;

    
    // Add an already existing FhirChargeItem to the end of the list.
    procedure AddItem(value : TFhirChargeItem); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirChargeItem) : Integer;
    

    // Insert FhirChargeItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirChargeItem;
    

    // Insert an existing FhirChargeItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirChargeItem);
    
    // Get the iIndexth FhirChargeItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirChargeItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirChargeItem;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirChargeItems[index : Integer] : TFhirChargeItem read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CHARGEITEM}

{$IFDEF FHIR_CLAIM}

  // Other claims which are related to this claim such as prior submissions or claims for related services or for the same event.
  TFhirClaimRelated = class (TFhirBackboneElement)
  protected
    FClaim : TFhirReference{TFhirClaim};
    FRelationship : TFhirCodeableConcept;
    FReference : TFhirIdentifier;
    Procedure SetClaim(value : TFhirReference{TFhirClaim});
    Procedure SetRelationship(value : TFhirCodeableConcept);
    Procedure SetReference(value : TFhirIdentifier);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimRelated; overload;
    function Clone : TFhirClaimRelated; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Reference to a related claim. (defined for API consistency)
    property claim : TFhirReference{TFhirClaim} read FClaim write SetClaim;
    // Reference to a related claim.
    property claimElement : TFhirReference{TFhirClaim} read FClaim write SetClaim;

    // Typed access to A code to convey how the claims are related. (defined for API consistency)
    property relationship : TFhirCodeableConcept read FRelationship write SetRelationship;
    // A code to convey how the claims are related.
    property relationshipElement : TFhirCodeableConcept read FRelationship write SetRelationship;

    // Typed access to An alternate organizational reference to the case or file to which this particular claim pertains. (defined for API consistency)
    property reference : TFhirIdentifier read FReference write SetReference;
    // An alternate organizational reference to the case or file to which this particular claim pertains.
    property referenceElement : TFhirIdentifier read FReference write SetReference;

  end;

  TFhirClaimRelatedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimRelatedList;
    function GetCurrent : TFhirClaimRelated;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimRelatedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimRelated read GetCurrent;
  end;

  TFhirClaimRelatedList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimRelated;
    procedure SetItemN(index : Integer; value : TFhirClaimRelated);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimRelatedList; Overload;
    function Clone : TFhirClaimRelatedList; Overload;
    function GetEnumerator : TFhirClaimRelatedListEnumerator;
    

    //  Add a FhirClaimRelated to the end of the list.
    function Append : TFhirClaimRelated;

    
    // Add an already existing FhirClaimRelated to the end of the list.
    procedure AddItem(value : TFhirClaimRelated); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimRelated) : Integer;
    

    // Insert FhirClaimRelated before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimRelated;
    

    // Insert an existing FhirClaimRelated before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimRelated);
    
    // Get the iIndexth FhirClaimRelated. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimRelated);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimRelated;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimRelateds[index : Integer] : TFhirClaimRelated read GetItemN write SetItemN; default;
  End;

  // The party to be reimbursed for cost of the products and services according to the terms of the policy.
  TFhirClaimPayee = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FParty : TFhirReference{TFhirPractitioner};
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetParty(value : TFhirReference{TFhirPractitioner});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimPayee; overload;
    function Clone : TFhirClaimPayee; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Type of Party to be reimbursed: subscriber, provider, other. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of Party to be reimbursed: subscriber, provider, other.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Reference to the individual or organization to whom any payment will be made. (defined for API consistency)
    property party : TFhirReference{TFhirPractitioner} read FParty write SetParty;
    // Reference to the individual or organization to whom any payment will be made.
    property partyElement : TFhirReference{TFhirPractitioner} read FParty write SetParty;

  end;

  TFhirClaimPayeeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimPayeeList;
    function GetCurrent : TFhirClaimPayee;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimPayeeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimPayee read GetCurrent;
  end;

  TFhirClaimPayeeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimPayee;
    procedure SetItemN(index : Integer; value : TFhirClaimPayee);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimPayeeList; Overload;
    function Clone : TFhirClaimPayeeList; Overload;
    function GetEnumerator : TFhirClaimPayeeListEnumerator;
    

    //  Add a FhirClaimPayee to the end of the list.
    function Append : TFhirClaimPayee;

    
    // Add an already existing FhirClaimPayee to the end of the list.
    procedure AddItem(value : TFhirClaimPayee); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimPayee) : Integer;
    

    // Insert FhirClaimPayee before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimPayee;
    

    // Insert an existing FhirClaimPayee before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimPayee);
    
    // Get the iIndexth FhirClaimPayee. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimPayee);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimPayee;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimPayees[index : Integer] : TFhirClaimPayee read GetItemN write SetItemN; default;
  End;

  // The members of the team who provided the products and services.
  TFhirClaimCareTeam = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FProvider : TFhirReference{TFhirPractitioner};
    FResponsible : TFhirBoolean;
    FRole : TFhirCodeableConcept;
    FQualification : TFhirCodeableConcept;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetResponsible(value : TFhirBoolean);
    Function GetResponsibleST : Boolean;
    Procedure SetResponsibleST(value : Boolean);
    Procedure SetRole(value : TFhirCodeableConcept);
    Procedure SetQualification(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimCareTeam; overload;
    function Clone : TFhirClaimCareTeam; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number to uniquely identify care team entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify care team entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to Member of the team who provided the product or service. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // Member of the team who provided the product or service.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to The party who is billing and/or responsible for the claimed products or services.
    property responsible : Boolean read GetResponsibleST write SetResponsibleST;
    // The party who is billing and/or responsible for the claimed products or services.
    property responsibleElement : TFhirBoolean read FResponsible write SetResponsible;

    // Typed access to The lead, assisting or supervising practitioner and their discipline if a multidisciplinary team. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // The lead, assisting or supervising practitioner and their discipline if a multidisciplinary team.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The qualification of the practitioner which is applicable for this service. (defined for API consistency)
    property qualification : TFhirCodeableConcept read FQualification write SetQualification;
    // The qualification of the practitioner which is applicable for this service.
    property qualificationElement : TFhirCodeableConcept read FQualification write SetQualification;

  end;

  TFhirClaimCareTeamListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimCareTeamList;
    function GetCurrent : TFhirClaimCareTeam;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimCareTeamList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimCareTeam read GetCurrent;
  end;

  TFhirClaimCareTeamList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimCareTeam;
    procedure SetItemN(index : Integer; value : TFhirClaimCareTeam);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimCareTeamList; Overload;
    function Clone : TFhirClaimCareTeamList; Overload;
    function GetEnumerator : TFhirClaimCareTeamListEnumerator;
    

    //  Add a FhirClaimCareTeam to the end of the list.
    function Append : TFhirClaimCareTeam;

    
    // Add an already existing FhirClaimCareTeam to the end of the list.
    procedure AddItem(value : TFhirClaimCareTeam); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimCareTeam) : Integer;
    

    // Insert FhirClaimCareTeam before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimCareTeam;
    

    // Insert an existing FhirClaimCareTeam before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimCareTeam);
    
    // Get the iIndexth FhirClaimCareTeam. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimCareTeam);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimCareTeam;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimCareTeams[index : Integer] : TFhirClaimCareTeam read GetItemN write SetItemN; default;
  End;

  // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
  TFhirClaimSupportingInfo = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FCategory : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FTiming : TFhirType;
    FValue : TFhirType;
    FReason : TFhirCodeableConcept;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetTiming(value : TFhirType);
    Procedure SetValue(value : TFhirType);
    Procedure SetReason(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimSupportingInfo; overload;
    function Clone : TFhirClaimSupportingInfo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number to uniquely identify supporting information entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify supporting information entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The general class of the information supplied: information; exception; accident, employment; onset, etc. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // The general class of the information supplied: information; exception; accident, employment; onset, etc.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to System and code pertaining to the specific information regarding special conditions relating to the setting, treatment or patient  for which care is sought. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // System and code pertaining to the specific information regarding special conditions relating to the setting, treatment or patient  for which care is sought.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The date when or period to which this information refers. (defined for API consistency)
    property timing : TFhirType read FTiming write SetTiming;
    // The date when or period to which this information refers.
    property timingElement : TFhirType read FTiming write SetTiming;

    // Typed access to Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
    property valueElement : TFhirType read FValue write SetValue;

    // Typed access to Provides the reason in the situation where a reason code is required in addition to the content. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // Provides the reason in the situation where a reason code is required in addition to the content.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

  end;

  TFhirClaimSupportingInfoListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimSupportingInfoList;
    function GetCurrent : TFhirClaimSupportingInfo;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimSupportingInfoList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimSupportingInfo read GetCurrent;
  end;

  TFhirClaimSupportingInfoList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimSupportingInfo;
    procedure SetItemN(index : Integer; value : TFhirClaimSupportingInfo);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimSupportingInfoList; Overload;
    function Clone : TFhirClaimSupportingInfoList; Overload;
    function GetEnumerator : TFhirClaimSupportingInfoListEnumerator;
    

    //  Add a FhirClaimSupportingInfo to the end of the list.
    function Append : TFhirClaimSupportingInfo;

    
    // Add an already existing FhirClaimSupportingInfo to the end of the list.
    procedure AddItem(value : TFhirClaimSupportingInfo); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimSupportingInfo) : Integer;
    

    // Insert FhirClaimSupportingInfo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimSupportingInfo;
    

    // Insert an existing FhirClaimSupportingInfo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimSupportingInfo);
    
    // Get the iIndexth FhirClaimSupportingInfo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimSupportingInfo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimSupportingInfo;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimSupportingInfos[index : Integer] : TFhirClaimSupportingInfo read GetItemN write SetItemN; default;
  End;

  // Information about diagnoses relevant to the claim items.
  TFhirClaimDiagnosis = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FDiagnosis : TFhirType;
    Ftype_List : TFhirCodeableConceptList;
    FOnAdmission : TFhirCodeableConcept;
    FPackageCode : TFhirCodeableConcept;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetDiagnosis(value : TFhirType);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    Procedure SetOnAdmission(value : TFhirCodeableConcept);
    Procedure SetPackageCode(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimDiagnosis; overload;
    function Clone : TFhirClaimDiagnosis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number to uniquely identify diagnosis entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify diagnosis entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The nature of illness or problem in a coded form or as a reference to an external defined Condition. (defined for API consistency)
    property diagnosis : TFhirType read FDiagnosis write SetDiagnosis;
    // The nature of illness or problem in a coded form or as a reference to an external defined Condition.
    property diagnosisElement : TFhirType read FDiagnosis write SetDiagnosis;

    // When the condition was observed or the relative ranking.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to Indication of whether the diagnosis was present on admission to a facility. (defined for API consistency)
    property onAdmission : TFhirCodeableConcept read FOnAdmission write SetOnAdmission;
    // Indication of whether the diagnosis was present on admission to a facility.
    property onAdmissionElement : TFhirCodeableConcept read FOnAdmission write SetOnAdmission;

    // Typed access to A package billing code or bundle code used to group products and services to a particular health condition (such as heart attack) which is based on a predetermined grouping code system. (defined for API consistency)
    property packageCode : TFhirCodeableConcept read FPackageCode write SetPackageCode;
    // A package billing code or bundle code used to group products and services to a particular health condition (such as heart attack) which is based on a predetermined grouping code system.
    property packageCodeElement : TFhirCodeableConcept read FPackageCode write SetPackageCode;

  end;

  TFhirClaimDiagnosisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimDiagnosisList;
    function GetCurrent : TFhirClaimDiagnosis;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimDiagnosisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimDiagnosis read GetCurrent;
  end;

  TFhirClaimDiagnosisList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimDiagnosis;
    procedure SetItemN(index : Integer; value : TFhirClaimDiagnosis);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimDiagnosisList; Overload;
    function Clone : TFhirClaimDiagnosisList; Overload;
    function GetEnumerator : TFhirClaimDiagnosisListEnumerator;
    

    //  Add a FhirClaimDiagnosis to the end of the list.
    function Append : TFhirClaimDiagnosis;

    
    // Add an already existing FhirClaimDiagnosis to the end of the list.
    procedure AddItem(value : TFhirClaimDiagnosis); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimDiagnosis) : Integer;
    

    // Insert FhirClaimDiagnosis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimDiagnosis;
    

    // Insert an existing FhirClaimDiagnosis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimDiagnosis);
    
    // Get the iIndexth FhirClaimDiagnosis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimDiagnosis);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimDiagnosis;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimDiagnoses[index : Integer] : TFhirClaimDiagnosis read GetItemN write SetItemN; default;
  End;

  // Procedures performed on the patient relevant to the billing items with the claim.
  TFhirClaimProcedure = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    Ftype_List : TFhirCodeableConceptList;
    FDate : TFhirDateTime;
    FProcedure_ : TFhirType;
    FudiList : TFhirReferenceList{TFhirDevice};
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetProcedure_(value : TFhirType);
    function GetUdiList : TFhirReferenceList{TFhirDevice};
    function GetHasUdiList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimProcedure; overload;
    function Clone : TFhirClaimProcedure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number to uniquely identify procedure entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify procedure entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // When the condition was observed or the relative ranking.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to Date and optionally time the procedure was performed.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date and optionally time the procedure was performed.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The code or reference to a Procedure resource which identifies the clinical intervention performed. (defined for API consistency)
    property procedure_ : TFhirType read FProcedure_ write SetProcedure_;
    // The code or reference to a Procedure resource which identifies the clinical intervention performed.
    property procedure_Element : TFhirType read FProcedure_ write SetProcedure_;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList{TFhirDevice} read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

  end;

  TFhirClaimProcedureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimProcedureList;
    function GetCurrent : TFhirClaimProcedure;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimProcedureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimProcedure read GetCurrent;
  end;

  TFhirClaimProcedureList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimProcedure;
    procedure SetItemN(index : Integer; value : TFhirClaimProcedure);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimProcedureList; Overload;
    function Clone : TFhirClaimProcedureList; Overload;
    function GetEnumerator : TFhirClaimProcedureListEnumerator;
    

    //  Add a FhirClaimProcedure to the end of the list.
    function Append : TFhirClaimProcedure;

    
    // Add an already existing FhirClaimProcedure to the end of the list.
    procedure AddItem(value : TFhirClaimProcedure); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimProcedure) : Integer;
    

    // Insert FhirClaimProcedure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimProcedure;
    

    // Insert an existing FhirClaimProcedure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimProcedure);
    
    // Get the iIndexth FhirClaimProcedure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimProcedure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimProcedure;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimProcedures[index : Integer] : TFhirClaimProcedure read GetItemN write SetItemN; default;
  End;

  // Financial instruments for reimbursement for the health care products and services specified on the claim.
  TFhirClaimInsurance = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FFocal : TFhirBoolean;
    FIdentifier : TFhirIdentifier;
    FCoverage : TFhirReference{TFhirCoverage};
    FBusinessArrangement : TFhirString;
    FpreAuthRefList : TFhirStringList;
    FClaimResponse : TFhirReference{TFhirClaimResponse};
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetFocal(value : TFhirBoolean);
    Function GetFocalST : Boolean;
    Procedure SetFocalST(value : Boolean);
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetCoverage(value : TFhirReference{TFhirCoverage});
    Procedure SetBusinessArrangement(value : TFhirString);
    Function GetBusinessArrangementST : String;
    Procedure SetBusinessArrangementST(value : String);
    function GetPreAuthRefList : TFhirStringList;
    function GetHasPreAuthRefList : Boolean;
    Procedure SetClaimResponse(value : TFhirReference{TFhirClaimResponse});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimInsurance; overload;
    function Clone : TFhirClaimInsurance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number to uniquely identify insurance entries and provide a sequence of coverages to convey coordination of benefit order.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify insurance entries and provide a sequence of coverages to convey coordination of benefit order.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true.
    property focal : Boolean read GetFocalST write SetFocalST;
    // A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true.
    property focalElement : TFhirBoolean read FFocal write SetFocal;

    // Typed access to The business identifier to be used when the claim is sent for adjudication against this insurance policy. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // The business identifier to be used when the claim is sent for adjudication against this insurance policy.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system. (defined for API consistency)
    property coverage : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;
    // Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system.
    property coverageElement : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;

    // Typed access to A business agreement number established between the provider and the insurer for special business processing purposes.
    property businessArrangement : String read GetBusinessArrangementST write SetBusinessArrangementST;
    // A business agreement number established between the provider and the insurer for special business processing purposes.
    property businessArrangementElement : TFhirString read FBusinessArrangement write SetBusinessArrangement;

    // Reference numbers previously provided by the insurer to the provider to be quoted on subsequent claims containing services or products related to the prior authorization.
    property preAuthRefList : TFhirStringList read GetPreAuthRefList;
    property hasPreAuthRefList : boolean read GetHasPreAuthRefList;

    // Typed access to The result of the adjudication of the line items for the Coverage specified in this insurance. (defined for API consistency)
    property claimResponse : TFhirReference{TFhirClaimResponse} read FClaimResponse write SetClaimResponse;
    // The result of the adjudication of the line items for the Coverage specified in this insurance.
    property claimResponseElement : TFhirReference{TFhirClaimResponse} read FClaimResponse write SetClaimResponse;

  end;

  TFhirClaimInsuranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimInsuranceList;
    function GetCurrent : TFhirClaimInsurance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimInsuranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimInsurance read GetCurrent;
  end;

  TFhirClaimInsuranceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimInsurance;
    procedure SetItemN(index : Integer; value : TFhirClaimInsurance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimInsuranceList; Overload;
    function Clone : TFhirClaimInsuranceList; Overload;
    function GetEnumerator : TFhirClaimInsuranceListEnumerator;
    

    //  Add a FhirClaimInsurance to the end of the list.
    function Append : TFhirClaimInsurance;

    
    // Add an already existing FhirClaimInsurance to the end of the list.
    procedure AddItem(value : TFhirClaimInsurance); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimInsurance) : Integer;
    

    // Insert FhirClaimInsurance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimInsurance;
    

    // Insert an existing FhirClaimInsurance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimInsurance);
    
    // Get the iIndexth FhirClaimInsurance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimInsurance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimInsurance;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimInsurances[index : Integer] : TFhirClaimInsurance read GetItemN write SetItemN; default;
  End;

  // Details of an accident which resulted in injuries which required the products and services listed in the claim.
  TFhirClaimAccident = class (TFhirBackboneElement)
  protected
    FDate : TFhirDate;
    FType_ : TFhirCodeableConcept;
    FLocation : TFhirType;
    Procedure SetDate(value : TFhirDate);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetLocation(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimAccident; overload;
    function Clone : TFhirClaimAccident; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Date of an accident event  related to the products and services contained in the claim.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date of an accident event  related to the products and services contained in the claim.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to The type or context of the accident event for the purposes of selection of potential insurance coverages and determination of coordination between insurers. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type or context of the accident event for the purposes of selection of potential insurance coverages and determination of coordination between insurers.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The physical location of the accident event. (defined for API consistency)
    property location : TFhirType read FLocation write SetLocation;
    // The physical location of the accident event.
    property locationElement : TFhirType read FLocation write SetLocation;

  end;

  TFhirClaimAccidentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimAccidentList;
    function GetCurrent : TFhirClaimAccident;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimAccidentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimAccident read GetCurrent;
  end;

  TFhirClaimAccidentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimAccident;
    procedure SetItemN(index : Integer; value : TFhirClaimAccident);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimAccidentList; Overload;
    function Clone : TFhirClaimAccidentList; Overload;
    function GetEnumerator : TFhirClaimAccidentListEnumerator;
    

    //  Add a FhirClaimAccident to the end of the list.
    function Append : TFhirClaimAccident;

    
    // Add an already existing FhirClaimAccident to the end of the list.
    procedure AddItem(value : TFhirClaimAccident); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimAccident) : Integer;
    

    // Insert FhirClaimAccident before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimAccident;
    

    // Insert an existing FhirClaimAccident before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimAccident);
    
    // Get the iIndexth FhirClaimAccident. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimAccident);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimAccident;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimAccidents[index : Integer] : TFhirClaimAccident read GetItemN write SetItemN; default;
  End;

  // A claim line. Either a simple  product or service or a 'group' of details which can each be a simple items or groups of sub-details.
  TFhirClaimItem = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FcareTeamSequenceList : TFhirPositiveIntList;
    FdiagnosisSequenceList : TFhirPositiveIntList;
    FprocedureSequenceList : TFhirPositiveIntList;
    FinformationSequenceList : TFhirPositiveIntList;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FServiced : TFhirType;
    FLocation : TFhirType;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList{TFhirDevice};
    FBodySite : TFhirCodeableConcept;
    FsubSiteList : TFhirCodeableConceptList;
    FencounterList : TFhirReferenceList{TFhirEncounter};
    FdetailList : TFhirClaimItemDetailList;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    function GetCareTeamSequenceList : TFhirPositiveIntList;
    function GetHasCareTeamSequenceList : Boolean;
    function GetDiagnosisSequenceList : TFhirPositiveIntList;
    function GetHasDiagnosisSequenceList : Boolean;
    function GetProcedureSequenceList : TFhirPositiveIntList;
    function GetHasProcedureSequenceList : Boolean;
    function GetInformationSequenceList : TFhirPositiveIntList;
    function GetHasInformationSequenceList : Boolean;
    Procedure SetRevenue(value : TFhirCodeableConcept);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    Procedure SetServiced(value : TFhirType);
    Procedure SetLocation(value : TFhirType);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList{TFhirDevice};
    function GetHasUdiList : Boolean;
    Procedure SetBodySite(value : TFhirCodeableConcept);
    function GetSubSiteList : TFhirCodeableConceptList;
    function GetHasSubSiteList : Boolean;
    function GetEncounterList : TFhirReferenceList{TFhirEncounter};
    function GetHasEncounterList : Boolean;
    function GetDetailList : TFhirClaimItemDetailList;
    function GetHasDetailList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimItem; overload;
    function Clone : TFhirClaimItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number to uniquely identify item entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify item entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // CareTeam members related to this service or product.
    property careTeamSequenceList : TFhirPositiveIntList read GetCareTeamSequenceList;
    property hasCareTeamSequenceList : boolean read GetHasCareTeamSequenceList;

    // Diagnosis applicable for this service or product.
    property diagnosisSequenceList : TFhirPositiveIntList read GetDiagnosisSequenceList;
    property hasDiagnosisSequenceList : boolean read GetHasDiagnosisSequenceList;

    // Procedures applicable for this service or product.
    property procedureSequenceList : TFhirPositiveIntList read GetProcedureSequenceList;
    property hasProcedureSequenceList : boolean read GetHasProcedureSequenceList;

    // Exceptions, special conditions and supporting information applicable for this service or product.
    property informationSequenceList : TFhirPositiveIntList read GetInformationSequenceList;
    property hasInformationSequenceList : boolean read GetHasInformationSequenceList;

    // Typed access to The type of revenue or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of revenue or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The date or dates when the service or product was supplied, performed or completed. (defined for API consistency)
    property serviced : TFhirType read FServiced write SetServiced;
    // The date or dates when the service or product was supplied, performed or completed.
    property servicedElement : TFhirType read FServiced write SetServiced;

    // Typed access to Where the product or service was provided. (defined for API consistency)
    property location : TFhirType read FLocation write SetLocation;
    // Where the product or service was provided.
    property locationElement : TFhirType read FLocation write SetLocation;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList{TFhirDevice} read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

    // Typed access to Physical service site on the patient (limb, tooth, etc.). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Physical service site on the patient (limb, tooth, etc.).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // A region or surface of the bodySite, e.g. limb region or tooth surface(s).
    property subSiteList : TFhirCodeableConceptList read GetSubSiteList;
    property hasSubSiteList : boolean read GetHasSubSiteList;

    // The Encounters during which this Claim was created or to which the creation of this record is tightly associated.
    property encounterList : TFhirReferenceList{TFhirEncounter} read GetEncounterList;
    property hasEncounterList : boolean read GetHasEncounterList;

    // A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property detailList : TFhirClaimItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirClaimItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimItemList;
    function GetCurrent : TFhirClaimItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimItem read GetCurrent;
  end;

  TFhirClaimItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimItem;
    procedure SetItemN(index : Integer; value : TFhirClaimItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimItemList; Overload;
    function Clone : TFhirClaimItemList; Overload;
    function GetEnumerator : TFhirClaimItemListEnumerator;
    

    //  Add a FhirClaimItem to the end of the list.
    function Append : TFhirClaimItem;

    
    // Add an already existing FhirClaimItem to the end of the list.
    procedure AddItem(value : TFhirClaimItem); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimItem) : Integer;
    

    // Insert FhirClaimItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimItem;
    

    // Insert an existing FhirClaimItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimItem);
    
    // Get the iIndexth FhirClaimItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimItem;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimItems[index : Integer] : TFhirClaimItem read GetItemN write SetItemN; default;
  End;

  // A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
  TFhirClaimItemDetail = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList{TFhirDevice};
    FsubDetailList : TFhirClaimItemDetailSubDetailList;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetRevenue(value : TFhirCodeableConcept);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList{TFhirDevice};
    function GetHasUdiList : Boolean;
    function GetSubDetailList : TFhirClaimItemDetailSubDetailList;
    function GetHasSubDetailList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimItemDetail; overload;
    function Clone : TFhirClaimItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number to uniquely identify item entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify item entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The type of revenue or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of revenue or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList{TFhirDevice} read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

    // A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property subDetailList : TFhirClaimItemDetailSubDetailList read GetSubDetailList;
    property hasSubDetailList : boolean read GetHasSubDetailList;

  end;

  TFhirClaimItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimItemDetailList;
    function GetCurrent : TFhirClaimItemDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimItemDetail read GetCurrent;
  end;

  TFhirClaimItemDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimItemDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimItemDetailList; Overload;
    function Clone : TFhirClaimItemDetailList; Overload;
    function GetEnumerator : TFhirClaimItemDetailListEnumerator;
    

    //  Add a FhirClaimItemDetail to the end of the list.
    function Append : TFhirClaimItemDetail;

    
    // Add an already existing FhirClaimItemDetail to the end of the list.
    procedure AddItem(value : TFhirClaimItemDetail); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimItemDetail) : Integer;
    

    // Insert FhirClaimItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimItemDetail;
    

    // Insert an existing FhirClaimItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimItemDetail);
    
    // Get the iIndexth FhirClaimItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimItemDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimItemDetail;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimItemDetails[index : Integer] : TFhirClaimItemDetail read GetItemN write SetItemN; default;
  End;

  // A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
  TFhirClaimItemDetailSubDetail = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList{TFhirDevice};
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetRevenue(value : TFhirCodeableConcept);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList{TFhirDevice};
    function GetHasUdiList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimItemDetailSubDetail; overload;
    function Clone : TFhirClaimItemDetailSubDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number to uniquely identify item entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify item entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The type of revenue or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of revenue or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList{TFhirDevice} read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

  end;

  TFhirClaimItemDetailSubDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimItemDetailSubDetailList;
    function GetCurrent : TFhirClaimItemDetailSubDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimItemDetailSubDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimItemDetailSubDetail read GetCurrent;
  end;

  TFhirClaimItemDetailSubDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimItemDetailSubDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimItemDetailSubDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimItemDetailSubDetailList; Overload;
    function Clone : TFhirClaimItemDetailSubDetailList; Overload;
    function GetEnumerator : TFhirClaimItemDetailSubDetailListEnumerator;
    

    //  Add a FhirClaimItemDetailSubDetail to the end of the list.
    function Append : TFhirClaimItemDetailSubDetail;

    
    // Add an already existing FhirClaimItemDetailSubDetail to the end of the list.
    procedure AddItem(value : TFhirClaimItemDetailSubDetail); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimItemDetailSubDetail) : Integer;
    

    // Insert FhirClaimItemDetailSubDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimItemDetailSubDetail;
    

    // Insert an existing FhirClaimItemDetailSubDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimItemDetailSubDetail);
    
    // Get the iIndexth FhirClaimItemDetailSubDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimItemDetailSubDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimItemDetailSubDetail;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimItemDetailSubDetails[index : Integer] : TFhirClaimItemDetailSubDetail read GetItemN write SetItemN; default;
  End;

  // A provider issued list of professional services and products which have been provided, or are to be provided, to a patient which is sent to an insurer for reimbursement.
  TFhirClaim = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FSubType : TFhirCodeableConcept;
    FUse : TFhirEnum;
    FPatient : TFhirReference{TFhirPatient};
    FBillablePeriod : TFhirPeriod;
    FCreated : TFhirDateTime;
    FEnterer : TFhirReference{TFhirPractitioner};
    FInsurer : TFhirReference{TFhirOrganization};
    FProvider : TFhirReference{TFhirPractitioner};
    FPriority : TFhirCodeableConcept;
    FFundsReserve : TFhirCodeableConcept;
    FrelatedList : TFhirClaimRelatedList;
    FPrescription : TFhirReference{TFhirDeviceRequest};
    FOriginalPrescription : TFhirReference{TFhirDeviceRequest};
    FPayee : TFhirClaimPayee;
    FReferral : TFhirReference{TFhirServiceRequest};
    FFacility : TFhirReference{TFhirLocation};
    FcareTeamList : TFhirClaimCareTeamList;
    FsupportingInfoList : TFhirClaimSupportingInfoList;
    FdiagnosisList : TFhirClaimDiagnosisList;
    Fprocedure_List : TFhirClaimProcedureList;
    FinsuranceList : TFhirClaimInsuranceList;
    FAccident : TFhirClaimAccident;
    FitemList : TFhirClaimItemList;
    FTotal : TFhirMoney;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetSubType(value : TFhirCodeableConcept);
    Procedure SetUse(value : TFhirEnum);
    Function GetUseST : TFhirClaimUseEnum;
    Procedure SetUseST(value : TFhirClaimUseEnum);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetBillablePeriod(value : TFhirPeriod);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetEnterer(value : TFhirReference{TFhirPractitioner});
    Procedure SetInsurer(value : TFhirReference{TFhirOrganization});
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetPriority(value : TFhirCodeableConcept);
    Procedure SetFundsReserve(value : TFhirCodeableConcept);
    function GetRelatedList : TFhirClaimRelatedList;
    function GetHasRelatedList : Boolean;
    Procedure SetPrescription(value : TFhirReference{TFhirDeviceRequest});
    Procedure SetOriginalPrescription(value : TFhirReference{TFhirDeviceRequest});
    Procedure SetPayee(value : TFhirClaimPayee);
    Procedure SetReferral(value : TFhirReference{TFhirServiceRequest});
    Procedure SetFacility(value : TFhirReference{TFhirLocation});
    function GetCareTeamList : TFhirClaimCareTeamList;
    function GetHasCareTeamList : Boolean;
    function GetSupportingInfoList : TFhirClaimSupportingInfoList;
    function GetHasSupportingInfoList : Boolean;
    function GetDiagnosisList : TFhirClaimDiagnosisList;
    function GetHasDiagnosisList : Boolean;
    function GetProcedure_List : TFhirClaimProcedureList;
    function GetHasProcedure_List : Boolean;
    function GetInsuranceList : TFhirClaimInsuranceList;
    function GetHasInsuranceList : Boolean;
    Procedure SetAccident(value : TFhirClaimAccident);
    function GetItemList : TFhirClaimItemList;
    function GetHasItemList : Boolean;
    Procedure SetTotal(value : TFhirMoney);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaim; overload;
    function Clone : TFhirClaim; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A unique identifier assigned to this claim.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The category of claim, e.g. oral, pharmacy, vision, institutional, professional. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of claim, e.g. oral, pharmacy, vision, institutional, professional.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service. (defined for API consistency)
    property subType : TFhirCodeableConcept read FSubType write SetSubType;
    // A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service.
    property subTypeElement : TFhirCodeableConcept read FSubType write SetSubType;

    // A code to indicate whether the nature of the request is: to request adjudication of products and services previously rendered; or requesting authorization and adjudication for provision in the future; or requesting the non-binding adjudication of the listed products and services which could be provided in the future.
    property use : TFhirClaimUseEnum read GetUseST write SetUseST;
    property useElement : TFhirEnum read FUse write SetUse;

    // Typed access to The party to whom the professional services and/or products have been supplied or are being considered and for whom actual or forecast reimbursement is sought. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The party to whom the professional services and/or products have been supplied or are being considered and for whom actual or forecast reimbursement is sought.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The period for which charges are being submitted. (defined for API consistency)
    property billablePeriod : TFhirPeriod read FBillablePeriod write SetBillablePeriod;
    // The period for which charges are being submitted.
    property billablePeriodElement : TFhirPeriod read FBillablePeriod write SetBillablePeriod;

    // Typed access to The date this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to Individual who created the claim, predetermination or preauthorization. (defined for API consistency)
    property enterer : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;
    // Individual who created the claim, predetermination or preauthorization.
    property entererElement : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;

    // Typed access to The Insurer who is target of the request. (defined for API consistency)
    property insurer : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;
    // The Insurer who is target of the request.
    property insurerElement : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;

    // Typed access to The provider which is responsible for the claim, predetermination or preauthorization. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // The provider which is responsible for the claim, predetermination or preauthorization.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to The provider-required urgency of processing the request. Typical values include: stat, routine deferred. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // The provider-required urgency of processing the request. Typical values include: stat, routine deferred.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Typed access to A code to indicate whether and for whom funds are to be reserved for future claims. (defined for API consistency)
    property fundsReserve : TFhirCodeableConcept read FFundsReserve write SetFundsReserve;
    // A code to indicate whether and for whom funds are to be reserved for future claims.
    property fundsReserveElement : TFhirCodeableConcept read FFundsReserve write SetFundsReserve;

    // Other claims which are related to this claim such as prior submissions or claims for related services or for the same event.
    property relatedList : TFhirClaimRelatedList read GetRelatedList;
    property hasRelatedList : boolean read GetHasRelatedList;

    // Typed access to Prescription to support the dispensing of pharmacy, device or vision products. (defined for API consistency)
    property prescription : TFhirReference{TFhirDeviceRequest} read FPrescription write SetPrescription;
    // Prescription to support the dispensing of pharmacy, device or vision products.
    property prescriptionElement : TFhirReference{TFhirDeviceRequest} read FPrescription write SetPrescription;

    // Typed access to Original prescription which has been superseded by this prescription to support the dispensing of pharmacy services, medications or products. (defined for API consistency)
    property originalPrescription : TFhirReference{TFhirDeviceRequest} read FOriginalPrescription write SetOriginalPrescription;
    // Original prescription which has been superseded by this prescription to support the dispensing of pharmacy services, medications or products.
    property originalPrescriptionElement : TFhirReference{TFhirDeviceRequest} read FOriginalPrescription write SetOriginalPrescription;

    // Typed access to The party to be reimbursed for cost of the products and services according to the terms of the policy. (defined for API consistency)
    property payee : TFhirClaimPayee read FPayee write SetPayee;
    // The party to be reimbursed for cost of the products and services according to the terms of the policy.
    property payeeElement : TFhirClaimPayee read FPayee write SetPayee;

    // Typed access to A reference to a referral resource. (defined for API consistency)
    property referral : TFhirReference{TFhirServiceRequest} read FReferral write SetReferral;
    // A reference to a referral resource.
    property referralElement : TFhirReference{TFhirServiceRequest} read FReferral write SetReferral;

    // Typed access to Facility where the services were provided. (defined for API consistency)
    property facility : TFhirReference{TFhirLocation} read FFacility write SetFacility;
    // Facility where the services were provided.
    property facilityElement : TFhirReference{TFhirLocation} read FFacility write SetFacility;

    // The members of the team who provided the products and services.
    property careTeamList : TFhirClaimCareTeamList read GetCareTeamList;
    property hasCareTeamList : boolean read GetHasCareTeamList;

    // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
    property supportingInfoList : TFhirClaimSupportingInfoList read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Information about diagnoses relevant to the claim items.
    property diagnosisList : TFhirClaimDiagnosisList read GetDiagnosisList;
    property hasDiagnosisList : boolean read GetHasDiagnosisList;

    // Procedures performed on the patient relevant to the billing items with the claim.
    property procedure_List : TFhirClaimProcedureList read GetProcedure_List;
    property hasProcedure_List : boolean read GetHasProcedure_List;

    // Financial instruments for reimbursement for the health care products and services specified on the claim.
    property insuranceList : TFhirClaimInsuranceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Typed access to Details of an accident which resulted in injuries which required the products and services listed in the claim. (defined for API consistency)
    property accident : TFhirClaimAccident read FAccident write SetAccident;
    // Details of an accident which resulted in injuries which required the products and services listed in the claim.
    property accidentElement : TFhirClaimAccident read FAccident write SetAccident;

    // A claim line. Either a simple  product or service or a 'group' of details which can each be a simple items or groups of sub-details.
    property itemList : TFhirClaimItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

    // Typed access to The total value of the all the items in the claim. (defined for API consistency)
    property total : TFhirMoney read FTotal write SetTotal;
    // The total value of the all the items in the claim.
    property totalElement : TFhirMoney read FTotal write SetTotal;

  end;

  TFhirClaimListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimList;
    function GetCurrent : TFhirClaim;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaim read GetCurrent;
  end;

  TFhirClaimList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaim;
    procedure SetItemN(index : Integer; value : TFhirClaim);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimList; Overload;
    function Clone : TFhirClaimList; Overload;
    function GetEnumerator : TFhirClaimListEnumerator;
    

    //  Add a FhirClaim to the end of the list.
    function Append : TFhirClaim;

    
    // Add an already existing FhirClaim to the end of the list.
    procedure AddItem(value : TFhirClaim); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaim) : Integer;
    

    // Insert FhirClaim before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaim;
    

    // Insert an existing FhirClaim before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaim);
    
    // Get the iIndexth FhirClaim. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaim);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaim;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaims[index : Integer] : TFhirClaim read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CLAIM}

{$IFDEF FHIR_CLAIMRESPONSE}

  // A claim line. Either a simple (a product or service) or a 'group' of details which can also be a simple items or groups of sub-details.
  TFhirClaimResponseItem = class (TFhirBackboneElement)
  protected
    FItemSequence : TFhirPositiveInt;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    FdetailList : TFhirClaimResponseItemDetailList;
    Procedure SetItemSequence(value : TFhirPositiveInt);
    Function GetItemSequenceST : String;
    Procedure SetItemSequenceST(value : String);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetDetailList : TFhirClaimResponseItemDetailList;
    function GetHasDetailList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItem; overload;
    function Clone : TFhirClaimResponseItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number to uniquely reference the claim item entries.
    property itemSequence : String read GetItemSequenceST write SetItemSequenceST;
    // A number to uniquely reference the claim item entries.
    property itemSequenceElement : TFhirPositiveInt read FItemSequence write SetItemSequence;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // If this item is a group then the values here are a summary of the adjudication of the detail items. If this item is a simple product or service then this is the result of the adjudication of this item.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // A claim detail. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property detailList : TFhirClaimResponseItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirClaimResponseItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemList;
    function GetCurrent : TFhirClaimResponseItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItem read GetCurrent;
  end;

  TFhirClaimResponseItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseItem;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseItemList; Overload;
    function Clone : TFhirClaimResponseItemList; Overload;
    function GetEnumerator : TFhirClaimResponseItemListEnumerator;
    

    //  Add a FhirClaimResponseItem to the end of the list.
    function Append : TFhirClaimResponseItem;

    
    // Add an already existing FhirClaimResponseItem to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItem); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItem) : Integer;
    

    // Insert FhirClaimResponseItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItem;
    

    // Insert an existing FhirClaimResponseItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItem);
    
    // Get the iIndexth FhirClaimResponseItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItem;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimResponseItems[index : Integer] : TFhirClaimResponseItem read GetItemN write SetItemN; default;
  End;

  // If this item is a group then the values here are a summary of the adjudication of the detail items. If this item is a simple product or service then this is the result of the adjudication of this item.
  TFhirClaimResponseItemAdjudication = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FReason : TFhirCodeableConcept;
    FAmount : TFhirMoney;
    FValue : TFhirDecimal;
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetReason(value : TFhirCodeableConcept);
    Procedure SetAmount(value : TFhirMoney);
    Procedure SetValue(value : TFhirDecimal);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItemAdjudication; overload;
    function Clone : TFhirClaimResponseItemAdjudication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A code to indicate the information type of this adjudication record. Information types may include the value submitted, maximum values or percentages allowed or payable under the plan, amounts that: the patient is responsible for in aggregate or pertaining to this item; amounts paid by other coverages; and, the benefit payable for this item. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A code to indicate the information type of this adjudication record. Information types may include the value submitted, maximum values or percentages allowed or payable under the plan, amounts that: the patient is responsible for in aggregate or pertaining to this item; amounts paid by other coverages; and, the benefit payable for this item.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to A code supporting the understanding of the adjudication result and explaining variance from expected amount. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // A code supporting the understanding of the adjudication result and explaining variance from expected amount.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

    // Typed access to Monetary amount associated with the category. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Monetary amount associated with the category.
    property amountElement : TFhirMoney read FAmount write SetAmount;

    // Typed access to A non-monetary value associated with the category. Mutually exclusive to the amount element above.
    property value : String read GetValueST write SetValueST;
    // A non-monetary value associated with the category. Mutually exclusive to the amount element above.
    property valueElement : TFhirDecimal read FValue write SetValue;

  end;

  TFhirClaimResponseItemAdjudicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemAdjudicationList;
    function GetCurrent : TFhirClaimResponseItemAdjudication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemAdjudicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItemAdjudication read GetCurrent;
  end;

  TFhirClaimResponseItemAdjudicationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseItemAdjudication;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItemAdjudication);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseItemAdjudicationList; Overload;
    function Clone : TFhirClaimResponseItemAdjudicationList; Overload;
    function GetEnumerator : TFhirClaimResponseItemAdjudicationListEnumerator;
    

    //  Add a FhirClaimResponseItemAdjudication to the end of the list.
    function Append : TFhirClaimResponseItemAdjudication;

    
    // Add an already existing FhirClaimResponseItemAdjudication to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItemAdjudication); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItemAdjudication) : Integer;
    

    // Insert FhirClaimResponseItemAdjudication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItemAdjudication;
    

    // Insert an existing FhirClaimResponseItemAdjudication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItemAdjudication);
    
    // Get the iIndexth FhirClaimResponseItemAdjudication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItemAdjudication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItemAdjudication;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimResponseItemAdjudications[index : Integer] : TFhirClaimResponseItemAdjudication read GetItemN write SetItemN; default;
  End;

  // A claim detail. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
  TFhirClaimResponseItemDetail = class (TFhirBackboneElement)
  protected
    FDetailSequence : TFhirPositiveInt;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    FsubDetailList : TFhirClaimResponseItemDetailSubDetailList;
    Procedure SetDetailSequence(value : TFhirPositiveInt);
    Function GetDetailSequenceST : String;
    Procedure SetDetailSequenceST(value : String);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetSubDetailList : TFhirClaimResponseItemDetailSubDetailList;
    function GetHasSubDetailList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItemDetail; overload;
    function Clone : TFhirClaimResponseItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number to uniquely reference the claim detail entry.
    property detailSequence : String read GetDetailSequenceST write SetDetailSequenceST;
    // A number to uniquely reference the claim detail entry.
    property detailSequenceElement : TFhirPositiveInt read FDetailSequence write SetDetailSequence;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // A sub-detail adjudication of a simple product or service.
    property subDetailList : TFhirClaimResponseItemDetailSubDetailList read GetSubDetailList;
    property hasSubDetailList : boolean read GetHasSubDetailList;

  end;

  TFhirClaimResponseItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemDetailList;
    function GetCurrent : TFhirClaimResponseItemDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItemDetail read GetCurrent;
  end;

  TFhirClaimResponseItemDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseItemDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseItemDetailList; Overload;
    function Clone : TFhirClaimResponseItemDetailList; Overload;
    function GetEnumerator : TFhirClaimResponseItemDetailListEnumerator;
    

    //  Add a FhirClaimResponseItemDetail to the end of the list.
    function Append : TFhirClaimResponseItemDetail;

    
    // Add an already existing FhirClaimResponseItemDetail to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItemDetail); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItemDetail) : Integer;
    

    // Insert FhirClaimResponseItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItemDetail;
    

    // Insert an existing FhirClaimResponseItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItemDetail);
    
    // Get the iIndexth FhirClaimResponseItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItemDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItemDetail;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimResponseItemDetails[index : Integer] : TFhirClaimResponseItemDetail read GetItemN write SetItemN; default;
  End;

  // A sub-detail adjudication of a simple product or service.
  TFhirClaimResponseItemDetailSubDetail = class (TFhirBackboneElement)
  protected
    FSubDetailSequence : TFhirPositiveInt;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    Procedure SetSubDetailSequence(value : TFhirPositiveInt);
    Function GetSubDetailSequenceST : String;
    Procedure SetSubDetailSequenceST(value : String);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseItemDetailSubDetail; overload;
    function Clone : TFhirClaimResponseItemDetailSubDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number to uniquely reference the claim sub-detail entry.
    property subDetailSequence : String read GetSubDetailSequenceST write SetSubDetailSequenceST;
    // A number to uniquely reference the claim sub-detail entry.
    property subDetailSequenceElement : TFhirPositiveInt read FSubDetailSequence write SetSubDetailSequence;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

  end;

  TFhirClaimResponseItemDetailSubDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseItemDetailSubDetailList;
    function GetCurrent : TFhirClaimResponseItemDetailSubDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseItemDetailSubDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseItemDetailSubDetail read GetCurrent;
  end;

  TFhirClaimResponseItemDetailSubDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseItemDetailSubDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseItemDetailSubDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseItemDetailSubDetailList; Overload;
    function Clone : TFhirClaimResponseItemDetailSubDetailList; Overload;
    function GetEnumerator : TFhirClaimResponseItemDetailSubDetailListEnumerator;
    

    //  Add a FhirClaimResponseItemDetailSubDetail to the end of the list.
    function Append : TFhirClaimResponseItemDetailSubDetail;

    
    // Add an already existing FhirClaimResponseItemDetailSubDetail to the end of the list.
    procedure AddItem(value : TFhirClaimResponseItemDetailSubDetail); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseItemDetailSubDetail) : Integer;
    

    // Insert FhirClaimResponseItemDetailSubDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseItemDetailSubDetail;
    

    // Insert an existing FhirClaimResponseItemDetailSubDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseItemDetailSubDetail);
    
    // Get the iIndexth FhirClaimResponseItemDetailSubDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseItemDetailSubDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseItemDetailSubDetail;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimResponseItemDetailSubDetails[index : Integer] : TFhirClaimResponseItemDetailSubDetail read GetItemN write SetItemN; default;
  End;

  // The first-tier service adjudications for payor added product or service lines.
  TFhirClaimResponseAddItem = class (TFhirBackboneElement)
  protected
    FitemSequenceList : TFhirPositiveIntList;
    FdetailSequenceList : TFhirPositiveIntList;
    FsubdetailSequenceList : TFhirPositiveIntList;
    FproviderList : TFhirReferenceList{TFhirPractitioner};
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FServiced : TFhirType;
    FLocation : TFhirType;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FBodySite : TFhirCodeableConcept;
    FsubSiteList : TFhirCodeableConceptList;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    FdetailList : TFhirClaimResponseAddItemDetailList;
    function GetItemSequenceList : TFhirPositiveIntList;
    function GetHasItemSequenceList : Boolean;
    function GetDetailSequenceList : TFhirPositiveIntList;
    function GetHasDetailSequenceList : Boolean;
    function GetSubdetailSequenceList : TFhirPositiveIntList;
    function GetHasSubdetailSequenceList : Boolean;
    function GetProviderList : TFhirReferenceList{TFhirPractitioner};
    function GetHasProviderList : Boolean;
    Procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    Procedure SetServiced(value : TFhirType);
    Procedure SetLocation(value : TFhirType);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetNet(value : TFhirMoney);
    Procedure SetBodySite(value : TFhirCodeableConcept);
    function GetSubSiteList : TFhirCodeableConceptList;
    function GetHasSubSiteList : Boolean;
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetDetailList : TFhirClaimResponseAddItemDetailList;
    function GetHasDetailList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseAddItem; overload;
    function Clone : TFhirClaimResponseAddItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Claim items which this service line is intended to replace.
    property itemSequenceList : TFhirPositiveIntList read GetItemSequenceList;
    property hasItemSequenceList : boolean read GetHasItemSequenceList;

    // The sequence number of the details within the claim item which this line is intended to replace.
    property detailSequenceList : TFhirPositiveIntList read GetDetailSequenceList;
    property hasDetailSequenceList : boolean read GetHasDetailSequenceList;

    // The sequence number of the sub-details within the details within the claim item which this line is intended to replace.
    property subdetailSequenceList : TFhirPositiveIntList read GetSubdetailSequenceList;
    property hasSubdetailSequenceList : boolean read GetHasSubdetailSequenceList;

    // The providers who are authorized for the services rendered to the patient.
    property providerList : TFhirReferenceList{TFhirPractitioner} read GetProviderList;
    property hasProviderList : boolean read GetHasProviderList;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The date or dates when the service or product was supplied, performed or completed. (defined for API consistency)
    property serviced : TFhirType read FServiced write SetServiced;
    // The date or dates when the service or product was supplied, performed or completed.
    property servicedElement : TFhirType read FServiced write SetServiced;

    // Typed access to Where the product or service was provided. (defined for API consistency)
    property location : TFhirType read FLocation write SetLocation;
    // Where the product or service was provided.
    property locationElement : TFhirType read FLocation write SetLocation;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Typed access to Physical service site on the patient (limb, tooth, etc.). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Physical service site on the patient (limb, tooth, etc.).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // A region or surface of the bodySite, e.g. limb region or tooth surface(s).
    property subSiteList : TFhirCodeableConceptList read GetSubSiteList;
    property hasSubSiteList : boolean read GetHasSubSiteList;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // The second-tier service adjudications for payor added services.
    property detailList : TFhirClaimResponseAddItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirClaimResponseAddItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseAddItemList;
    function GetCurrent : TFhirClaimResponseAddItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseAddItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseAddItem read GetCurrent;
  end;

  TFhirClaimResponseAddItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseAddItem;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseAddItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseAddItemList; Overload;
    function Clone : TFhirClaimResponseAddItemList; Overload;
    function GetEnumerator : TFhirClaimResponseAddItemListEnumerator;
    

    //  Add a FhirClaimResponseAddItem to the end of the list.
    function Append : TFhirClaimResponseAddItem;

    
    // Add an already existing FhirClaimResponseAddItem to the end of the list.
    procedure AddItem(value : TFhirClaimResponseAddItem); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseAddItem) : Integer;
    

    // Insert FhirClaimResponseAddItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseAddItem;
    

    // Insert an existing FhirClaimResponseAddItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseAddItem);
    
    // Get the iIndexth FhirClaimResponseAddItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseAddItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseAddItem;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimResponseAddItems[index : Integer] : TFhirClaimResponseAddItem read GetItemN write SetItemN; default;
  End;

  // The second-tier service adjudications for payor added services.
  TFhirClaimResponseAddItemDetail = class (TFhirBackboneElement)
  protected
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    FsubDetailList : TFhirClaimResponseAddItemDetailSubDetailList;
    Procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetNet(value : TFhirMoney);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetSubDetailList : TFhirClaimResponseAddItemDetailSubDetailList;
    function GetHasSubDetailList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseAddItemDetail; overload;
    function Clone : TFhirClaimResponseAddItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // The third-tier service adjudications for payor added services.
    property subDetailList : TFhirClaimResponseAddItemDetailSubDetailList read GetSubDetailList;
    property hasSubDetailList : boolean read GetHasSubDetailList;

  end;

  TFhirClaimResponseAddItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseAddItemDetailList;
    function GetCurrent : TFhirClaimResponseAddItemDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseAddItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseAddItemDetail read GetCurrent;
  end;

  TFhirClaimResponseAddItemDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseAddItemDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseAddItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseAddItemDetailList; Overload;
    function Clone : TFhirClaimResponseAddItemDetailList; Overload;
    function GetEnumerator : TFhirClaimResponseAddItemDetailListEnumerator;
    

    //  Add a FhirClaimResponseAddItemDetail to the end of the list.
    function Append : TFhirClaimResponseAddItemDetail;

    
    // Add an already existing FhirClaimResponseAddItemDetail to the end of the list.
    procedure AddItem(value : TFhirClaimResponseAddItemDetail); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseAddItemDetail) : Integer;
    

    // Insert FhirClaimResponseAddItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseAddItemDetail;
    

    // Insert an existing FhirClaimResponseAddItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseAddItemDetail);
    
    // Get the iIndexth FhirClaimResponseAddItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseAddItemDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseAddItemDetail;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimResponseAddItemDetails[index : Integer] : TFhirClaimResponseAddItemDetail read GetItemN write SetItemN; default;
  End;

  // The third-tier service adjudications for payor added services.
  TFhirClaimResponseAddItemDetailSubDetail = class (TFhirBackboneElement)
  protected
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    Procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetNet(value : TFhirMoney);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseAddItemDetailSubDetail; overload;
    function Clone : TFhirClaimResponseAddItemDetailSubDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

  end;

  TFhirClaimResponseAddItemDetailSubDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseAddItemDetailSubDetailList;
    function GetCurrent : TFhirClaimResponseAddItemDetailSubDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseAddItemDetailSubDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseAddItemDetailSubDetail read GetCurrent;
  end;

  TFhirClaimResponseAddItemDetailSubDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseAddItemDetailSubDetail;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseAddItemDetailSubDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseAddItemDetailSubDetailList; Overload;
    function Clone : TFhirClaimResponseAddItemDetailSubDetailList; Overload;
    function GetEnumerator : TFhirClaimResponseAddItemDetailSubDetailListEnumerator;
    

    //  Add a FhirClaimResponseAddItemDetailSubDetail to the end of the list.
    function Append : TFhirClaimResponseAddItemDetailSubDetail;

    
    // Add an already existing FhirClaimResponseAddItemDetailSubDetail to the end of the list.
    procedure AddItem(value : TFhirClaimResponseAddItemDetailSubDetail); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseAddItemDetailSubDetail) : Integer;
    

    // Insert FhirClaimResponseAddItemDetailSubDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseAddItemDetailSubDetail;
    

    // Insert an existing FhirClaimResponseAddItemDetailSubDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseAddItemDetailSubDetail);
    
    // Get the iIndexth FhirClaimResponseAddItemDetailSubDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseAddItemDetailSubDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseAddItemDetailSubDetail;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimResponseAddItemDetailSubDetails[index : Integer] : TFhirClaimResponseAddItemDetailSubDetail read GetItemN write SetItemN; default;
  End;

  // Categorized monetary totals for the adjudication.
  TFhirClaimResponseTotal = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FAmount : TFhirMoney;
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetAmount(value : TFhirMoney);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseTotal; overload;
    function Clone : TFhirClaimResponseTotal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A code to indicate the information type of this adjudication record. Information types may include: the value submitted, maximum values or percentages allowed or payable under the plan, amounts that the patient is responsible for in aggregate or pertaining to this item, amounts paid by other coverages, and the benefit payable for this item. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A code to indicate the information type of this adjudication record. Information types may include: the value submitted, maximum values or percentages allowed or payable under the plan, amounts that the patient is responsible for in aggregate or pertaining to this item, amounts paid by other coverages, and the benefit payable for this item.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Monetary total amount associated with the category. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Monetary total amount associated with the category.
    property amountElement : TFhirMoney read FAmount write SetAmount;

  end;

  TFhirClaimResponseTotalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseTotalList;
    function GetCurrent : TFhirClaimResponseTotal;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseTotalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseTotal read GetCurrent;
  end;

  TFhirClaimResponseTotalList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseTotal;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseTotal);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseTotalList; Overload;
    function Clone : TFhirClaimResponseTotalList; Overload;
    function GetEnumerator : TFhirClaimResponseTotalListEnumerator;
    

    //  Add a FhirClaimResponseTotal to the end of the list.
    function Append : TFhirClaimResponseTotal;

    
    // Add an already existing FhirClaimResponseTotal to the end of the list.
    procedure AddItem(value : TFhirClaimResponseTotal); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseTotal) : Integer;
    

    // Insert FhirClaimResponseTotal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseTotal;
    

    // Insert an existing FhirClaimResponseTotal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseTotal);
    
    // Get the iIndexth FhirClaimResponseTotal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseTotal);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseTotal;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimResponseTotals[index : Integer] : TFhirClaimResponseTotal read GetItemN write SetItemN; default;
  End;

  // Payment details for the adjudication of the claim.
  TFhirClaimResponsePayment = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAdjustment : TFhirMoney;
    FAdjustmentReason : TFhirCodeableConcept;
    FDate : TFhirDate;
    FAmount : TFhirMoney;
    FIdentifier : TFhirIdentifier;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetAdjustment(value : TFhirMoney);
    Procedure SetAdjustmentReason(value : TFhirCodeableConcept);
    Procedure SetDate(value : TFhirDate);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetAmount(value : TFhirMoney);
    Procedure SetIdentifier(value : TFhirIdentifier);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponsePayment; overload;
    function Clone : TFhirClaimResponsePayment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Whether this represents partial or complete payment of the benefits payable. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Whether this represents partial or complete payment of the benefits payable.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Total amount of all adjustments to this payment included in this transaction which are not related to this claim's adjudication. (defined for API consistency)
    property adjustment : TFhirMoney read FAdjustment write SetAdjustment;
    // Total amount of all adjustments to this payment included in this transaction which are not related to this claim's adjudication.
    property adjustmentElement : TFhirMoney read FAdjustment write SetAdjustment;

    // Typed access to Reason for the payment adjustment. (defined for API consistency)
    property adjustmentReason : TFhirCodeableConcept read FAdjustmentReason write SetAdjustmentReason;
    // Reason for the payment adjustment.
    property adjustmentReasonElement : TFhirCodeableConcept read FAdjustmentReason write SetAdjustmentReason;

    // Typed access to Estimated date the payment will be issued or the actual issue date of payment.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Estimated date the payment will be issued or the actual issue date of payment.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to Benefits payable less any payment adjustment. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Benefits payable less any payment adjustment.
    property amountElement : TFhirMoney read FAmount write SetAmount;

    // Typed access to Issuer's unique identifier for the payment instrument. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Issuer's unique identifier for the payment instrument.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

  end;

  TFhirClaimResponsePaymentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponsePaymentList;
    function GetCurrent : TFhirClaimResponsePayment;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponsePaymentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponsePayment read GetCurrent;
  end;

  TFhirClaimResponsePaymentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponsePayment;
    procedure SetItemN(index : Integer; value : TFhirClaimResponsePayment);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponsePaymentList; Overload;
    function Clone : TFhirClaimResponsePaymentList; Overload;
    function GetEnumerator : TFhirClaimResponsePaymentListEnumerator;
    

    //  Add a FhirClaimResponsePayment to the end of the list.
    function Append : TFhirClaimResponsePayment;

    
    // Add an already existing FhirClaimResponsePayment to the end of the list.
    procedure AddItem(value : TFhirClaimResponsePayment); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponsePayment) : Integer;
    

    // Insert FhirClaimResponsePayment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponsePayment;
    

    // Insert an existing FhirClaimResponsePayment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponsePayment);
    
    // Get the iIndexth FhirClaimResponsePayment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponsePayment);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponsePayment;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimResponsePayments[index : Integer] : TFhirClaimResponsePayment read GetItemN write SetItemN; default;
  End;

  // A note that describes or explains adjudication results in a human readable form.
  TFhirClaimResponseProcessNote = class (TFhirBackboneElement)
  protected
    FNumber : TFhirPositiveInt;
    FType_ : TFhirEnum;
    FText : TFhirString;
    FLanguage : TFhirCodeableConcept;
    Procedure SetNumber(value : TFhirPositiveInt);
    Function GetNumberST : String;
    Procedure SetNumberST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirNoteTypeEnum;
    Procedure SetType_ST(value : TFhirNoteTypeEnum);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetLanguage(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseProcessNote; overload;
    function Clone : TFhirClaimResponseProcessNote; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number to uniquely identify a note entry.
    property number : String read GetNumberST write SetNumberST;
    // A number to uniquely identify a note entry.
    property numberElement : TFhirPositiveInt read FNumber write SetNumber;

    // The business purpose of the note text.
    property type_ : TFhirNoteTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The explanation or description associated with the processing.
    property text : String read GetTextST write SetTextST;
    // The explanation or description associated with the processing.
    property textElement : TFhirString read FText write SetText;

    // Typed access to A code to define the language used in the text of the note. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // A code to define the language used in the text of the note.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

  end;

  TFhirClaimResponseProcessNoteListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseProcessNoteList;
    function GetCurrent : TFhirClaimResponseProcessNote;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseProcessNoteList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseProcessNote read GetCurrent;
  end;

  TFhirClaimResponseProcessNoteList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseProcessNote;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseProcessNote);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseProcessNoteList; Overload;
    function Clone : TFhirClaimResponseProcessNoteList; Overload;
    function GetEnumerator : TFhirClaimResponseProcessNoteListEnumerator;
    

    //  Add a FhirClaimResponseProcessNote to the end of the list.
    function Append : TFhirClaimResponseProcessNote;

    
    // Add an already existing FhirClaimResponseProcessNote to the end of the list.
    procedure AddItem(value : TFhirClaimResponseProcessNote); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseProcessNote) : Integer;
    

    // Insert FhirClaimResponseProcessNote before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseProcessNote;
    

    // Insert an existing FhirClaimResponseProcessNote before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseProcessNote);
    
    // Get the iIndexth FhirClaimResponseProcessNote. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseProcessNote);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseProcessNote;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimResponseProcessNotes[index : Integer] : TFhirClaimResponseProcessNote read GetItemN write SetItemN; default;
  End;

  // Financial instruments for reimbursement for the health care products and services specified on the claim.
  TFhirClaimResponseInsurance = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FFocal : TFhirBoolean;
    FCoverage : TFhirReference{TFhirCoverage};
    FBusinessArrangement : TFhirString;
    FClaimResponse : TFhirReference{TFhirClaimResponse};
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetFocal(value : TFhirBoolean);
    Function GetFocalST : Boolean;
    Procedure SetFocalST(value : Boolean);
    Procedure SetCoverage(value : TFhirReference{TFhirCoverage});
    Procedure SetBusinessArrangement(value : TFhirString);
    Function GetBusinessArrangementST : String;
    Procedure SetBusinessArrangementST(value : String);
    Procedure SetClaimResponse(value : TFhirReference{TFhirClaimResponse});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseInsurance; overload;
    function Clone : TFhirClaimResponseInsurance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number to uniquely identify insurance entries and provide a sequence of coverages to convey coordination of benefit order.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify insurance entries and provide a sequence of coverages to convey coordination of benefit order.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true.
    property focal : Boolean read GetFocalST write SetFocalST;
    // A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true.
    property focalElement : TFhirBoolean read FFocal write SetFocal;

    // Typed access to Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system. (defined for API consistency)
    property coverage : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;
    // Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system.
    property coverageElement : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;

    // Typed access to A business agreement number established between the provider and the insurer for special business processing purposes.
    property businessArrangement : String read GetBusinessArrangementST write SetBusinessArrangementST;
    // A business agreement number established between the provider and the insurer for special business processing purposes.
    property businessArrangementElement : TFhirString read FBusinessArrangement write SetBusinessArrangement;

    // Typed access to The result of the adjudication of the line items for the Coverage specified in this insurance. (defined for API consistency)
    property claimResponse : TFhirReference{TFhirClaimResponse} read FClaimResponse write SetClaimResponse;
    // The result of the adjudication of the line items for the Coverage specified in this insurance.
    property claimResponseElement : TFhirReference{TFhirClaimResponse} read FClaimResponse write SetClaimResponse;

  end;

  TFhirClaimResponseInsuranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseInsuranceList;
    function GetCurrent : TFhirClaimResponseInsurance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseInsuranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseInsurance read GetCurrent;
  end;

  TFhirClaimResponseInsuranceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseInsurance;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseInsurance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseInsuranceList; Overload;
    function Clone : TFhirClaimResponseInsuranceList; Overload;
    function GetEnumerator : TFhirClaimResponseInsuranceListEnumerator;
    

    //  Add a FhirClaimResponseInsurance to the end of the list.
    function Append : TFhirClaimResponseInsurance;

    
    // Add an already existing FhirClaimResponseInsurance to the end of the list.
    procedure AddItem(value : TFhirClaimResponseInsurance); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseInsurance) : Integer;
    

    // Insert FhirClaimResponseInsurance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseInsurance;
    

    // Insert an existing FhirClaimResponseInsurance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseInsurance);
    
    // Get the iIndexth FhirClaimResponseInsurance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseInsurance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseInsurance;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimResponseInsurances[index : Integer] : TFhirClaimResponseInsurance read GetItemN write SetItemN; default;
  End;

  // Errors encountered during the processing of the adjudication.
  TFhirClaimResponseError = class (TFhirBackboneElement)
  protected
    FItemSequence : TFhirPositiveInt;
    FDetailSequence : TFhirPositiveInt;
    FSubDetailSequence : TFhirPositiveInt;
    FCode : TFhirCodeableConcept;
    Procedure SetItemSequence(value : TFhirPositiveInt);
    Function GetItemSequenceST : String;
    Procedure SetItemSequenceST(value : String);
    Procedure SetDetailSequence(value : TFhirPositiveInt);
    Function GetDetailSequenceST : String;
    Procedure SetDetailSequenceST(value : String);
    Procedure SetSubDetailSequence(value : TFhirPositiveInt);
    Function GetSubDetailSequenceST : String;
    Procedure SetSubDetailSequenceST(value : String);
    Procedure SetCode(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponseError; overload;
    function Clone : TFhirClaimResponseError; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The sequence number of the line item submitted which contains the error. This value is omitted when the error occurs outside of the item structure.
    property itemSequence : String read GetItemSequenceST write SetItemSequenceST;
    // The sequence number of the line item submitted which contains the error. This value is omitted when the error occurs outside of the item structure.
    property itemSequenceElement : TFhirPositiveInt read FItemSequence write SetItemSequence;

    // Typed access to The sequence number of the detail within the line item submitted which contains the error. This value is omitted when the error occurs outside of the item structure.
    property detailSequence : String read GetDetailSequenceST write SetDetailSequenceST;
    // The sequence number of the detail within the line item submitted which contains the error. This value is omitted when the error occurs outside of the item structure.
    property detailSequenceElement : TFhirPositiveInt read FDetailSequence write SetDetailSequence;

    // Typed access to The sequence number of the sub-detail within the detail within the line item submitted which contains the error. This value is omitted when the error occurs outside of the item structure.
    property subDetailSequence : String read GetSubDetailSequenceST write SetSubDetailSequenceST;
    // The sequence number of the sub-detail within the detail within the line item submitted which contains the error. This value is omitted when the error occurs outside of the item structure.
    property subDetailSequenceElement : TFhirPositiveInt read FSubDetailSequence write SetSubDetailSequence;

    // Typed access to An error code, from a specified code system, which details why the claim could not be adjudicated. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // An error code, from a specified code system, which details why the claim could not be adjudicated.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

  end;

  TFhirClaimResponseErrorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseErrorList;
    function GetCurrent : TFhirClaimResponseError;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseErrorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponseError read GetCurrent;
  end;

  TFhirClaimResponseErrorList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponseError;
    procedure SetItemN(index : Integer; value : TFhirClaimResponseError);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseErrorList; Overload;
    function Clone : TFhirClaimResponseErrorList; Overload;
    function GetEnumerator : TFhirClaimResponseErrorListEnumerator;
    

    //  Add a FhirClaimResponseError to the end of the list.
    function Append : TFhirClaimResponseError;

    
    // Add an already existing FhirClaimResponseError to the end of the list.
    procedure AddItem(value : TFhirClaimResponseError); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponseError) : Integer;
    

    // Insert FhirClaimResponseError before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponseError;
    

    // Insert an existing FhirClaimResponseError before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponseError);
    
    // Get the iIndexth FhirClaimResponseError. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponseError);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponseError;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimResponseErrors[index : Integer] : TFhirClaimResponseError read GetItemN write SetItemN; default;
  End;

  // This resource provides the adjudication details from the processing of a Claim resource.
  TFhirClaimResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FSubType : TFhirCodeableConcept;
    FUse : TFhirEnum;
    FPatient : TFhirReference{TFhirPatient};
    FCreated : TFhirDateTime;
    FInsurer : TFhirReference{TFhirOrganization};
    FRequestor : TFhirReference{TFhirPractitioner};
    FRequest : TFhirReference{TFhirClaim};
    FOutcome : TFhirEnum;
    FDisposition : TFhirString;
    FPreAuthRef : TFhirString;
    FPreAuthPeriod : TFhirPeriod;
    FPayeeType : TFhirCodeableConcept;
    FitemList : TFhirClaimResponseItemList;
    FaddItemList : TFhirClaimResponseAddItemList;
    FadjudicationList : TFhirClaimResponseItemAdjudicationList;
    FtotalList : TFhirClaimResponseTotalList;
    FPayment : TFhirClaimResponsePayment;
    FFundsReserve : TFhirCodeableConcept;
    FFormCode : TFhirCodeableConcept;
    FForm : TFhirAttachment;
    FprocessNoteList : TFhirClaimResponseProcessNoteList;
    FcommunicationRequestList : TFhirReferenceList{TFhirCommunicationRequest};
    FinsuranceList : TFhirClaimResponseInsuranceList;
    FerrorList : TFhirClaimResponseErrorList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetSubType(value : TFhirCodeableConcept);
    Procedure SetUse(value : TFhirEnum);
    Function GetUseST : TFhirClaimUseEnum;
    Procedure SetUseST(value : TFhirClaimUseEnum);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetInsurer(value : TFhirReference{TFhirOrganization});
    Procedure SetRequestor(value : TFhirReference{TFhirPractitioner});
    Procedure SetRequest(value : TFhirReference{TFhirClaim});
    Procedure SetOutcome(value : TFhirEnum);
    Function GetOutcomeST : TFhirRemittanceOutcomeEnum;
    Procedure SetOutcomeST(value : TFhirRemittanceOutcomeEnum);
    Procedure SetDisposition(value : TFhirString);
    Function GetDispositionST : String;
    Procedure SetDispositionST(value : String);
    Procedure SetPreAuthRef(value : TFhirString);
    Function GetPreAuthRefST : String;
    Procedure SetPreAuthRefST(value : String);
    Procedure SetPreAuthPeriod(value : TFhirPeriod);
    Procedure SetPayeeType(value : TFhirCodeableConcept);
    function GetItemList : TFhirClaimResponseItemList;
    function GetHasItemList : Boolean;
    function GetAddItemList : TFhirClaimResponseAddItemList;
    function GetHasAddItemList : Boolean;
    function GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetTotalList : TFhirClaimResponseTotalList;
    function GetHasTotalList : Boolean;
    Procedure SetPayment(value : TFhirClaimResponsePayment);
    Procedure SetFundsReserve(value : TFhirCodeableConcept);
    Procedure SetFormCode(value : TFhirCodeableConcept);
    Procedure SetForm(value : TFhirAttachment);
    function GetProcessNoteList : TFhirClaimResponseProcessNoteList;
    function GetHasProcessNoteList : Boolean;
    function GetCommunicationRequestList : TFhirReferenceList{TFhirCommunicationRequest};
    function GetHasCommunicationRequestList : Boolean;
    function GetInsuranceList : TFhirClaimResponseInsuranceList;
    function GetHasInsuranceList : Boolean;
    function GetErrorList : TFhirClaimResponseErrorList;
    function GetHasErrorList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClaimResponse; overload;
    function Clone : TFhirClaimResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A unique identifier assigned to this claim response.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service. (defined for API consistency)
    property subType : TFhirCodeableConcept read FSubType write SetSubType;
    // A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service.
    property subTypeElement : TFhirCodeableConcept read FSubType write SetSubType;

    // A code to indicate whether the nature of the request is: to request adjudication of products and services previously rendered; or requesting authorization and adjudication for provision in the future; or requesting the non-binding adjudication of the listed products and services which could be provided in the future.
    property use : TFhirClaimUseEnum read GetUseST write SetUseST;
    property useElement : TFhirEnum read FUse write SetUse;

    // Typed access to The party to whom the professional services and/or products have been supplied or are being considered and for whom actual for facast reimbursement is sought. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The party to whom the professional services and/or products have been supplied or are being considered and for whom actual for facast reimbursement is sought.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The date this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The party responsible for authorization, adjudication and reimbursement. (defined for API consistency)
    property insurer : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;
    // The party responsible for authorization, adjudication and reimbursement.
    property insurerElement : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;

    // Typed access to The provider which is responsible for the claim, predetermination or preauthorization. (defined for API consistency)
    property requestor : TFhirReference{TFhirPractitioner} read FRequestor write SetRequestor;
    // The provider which is responsible for the claim, predetermination or preauthorization.
    property requestorElement : TFhirReference{TFhirPractitioner} read FRequestor write SetRequestor;

    // Typed access to Original request resource reference. (defined for API consistency)
    property request : TFhirReference{TFhirClaim} read FRequest write SetRequest;
    // Original request resource reference.
    property requestElement : TFhirReference{TFhirClaim} read FRequest write SetRequest;

    // The outcome of the claim, predetermination, or preauthorization processing.
    property outcome : TFhirRemittanceOutcomeEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A human readable description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A human readable description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to Reference from the Insurer which is used in later communications which refers to this adjudication.
    property preAuthRef : String read GetPreAuthRefST write SetPreAuthRefST;
    // Reference from the Insurer which is used in later communications which refers to this adjudication.
    property preAuthRefElement : TFhirString read FPreAuthRef write SetPreAuthRef;

    // Typed access to The time frame during which this authorization is effective. (defined for API consistency)
    property preAuthPeriod : TFhirPeriod read FPreAuthPeriod write SetPreAuthPeriod;
    // The time frame during which this authorization is effective.
    property preAuthPeriodElement : TFhirPeriod read FPreAuthPeriod write SetPreAuthPeriod;

    // Typed access to Type of Party to be reimbursed: subscriber, provider, other. (defined for API consistency)
    property payeeType : TFhirCodeableConcept read FPayeeType write SetPayeeType;
    // Type of Party to be reimbursed: subscriber, provider, other.
    property payeeTypeElement : TFhirCodeableConcept read FPayeeType write SetPayeeType;

    // A claim line. Either a simple (a product or service) or a 'group' of details which can also be a simple items or groups of sub-details.
    property itemList : TFhirClaimResponseItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

    // The first-tier service adjudications for payor added product or service lines.
    property addItemList : TFhirClaimResponseAddItemList read GetAddItemList;
    property hasAddItemList : boolean read GetHasAddItemList;

    // The adjudication results which are presented at the header level rather than at the line-item or add-item levels.
    property adjudicationList : TFhirClaimResponseItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // Categorized monetary totals for the adjudication.
    property totalList : TFhirClaimResponseTotalList read GetTotalList;
    property hasTotalList : boolean read GetHasTotalList;

    // Typed access to Payment details for the adjudication of the claim. (defined for API consistency)
    property payment : TFhirClaimResponsePayment read FPayment write SetPayment;
    // Payment details for the adjudication of the claim.
    property paymentElement : TFhirClaimResponsePayment read FPayment write SetPayment;

    // Typed access to A code, used only on a response to a preauthorization, to indicate whether the benefits payable have been reserved and for whom. (defined for API consistency)
    property fundsReserve : TFhirCodeableConcept read FFundsReserve write SetFundsReserve;
    // A code, used only on a response to a preauthorization, to indicate whether the benefits payable have been reserved and for whom.
    property fundsReserveElement : TFhirCodeableConcept read FFundsReserve write SetFundsReserve;

    // Typed access to A code for the form to be used for printing the content. (defined for API consistency)
    property formCode : TFhirCodeableConcept read FFormCode write SetFormCode;
    // A code for the form to be used for printing the content.
    property formCodeElement : TFhirCodeableConcept read FFormCode write SetFormCode;

    // Typed access to The actual form, by reference or inclusion, for printing the content or an EOB. (defined for API consistency)
    property form : TFhirAttachment read FForm write SetForm;
    // The actual form, by reference or inclusion, for printing the content or an EOB.
    property formElement : TFhirAttachment read FForm write SetForm;

    // A note that describes or explains adjudication results in a human readable form.
    property processNoteList : TFhirClaimResponseProcessNoteList read GetProcessNoteList;
    property hasProcessNoteList : boolean read GetHasProcessNoteList;

    // Request for additional supporting or authorizing information.
    property communicationRequestList : TFhirReferenceList{TFhirCommunicationRequest} read GetCommunicationRequestList;
    property hasCommunicationRequestList : boolean read GetHasCommunicationRequestList;

    // Financial instruments for reimbursement for the health care products and services specified on the claim.
    property insuranceList : TFhirClaimResponseInsuranceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Errors encountered during the processing of the adjudication.
    property errorList : TFhirClaimResponseErrorList read GetErrorList;
    property hasErrorList : boolean read GetHasErrorList;

  end;

  TFhirClaimResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClaimResponseList;
    function GetCurrent : TFhirClaimResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClaimResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClaimResponse read GetCurrent;
  end;

  TFhirClaimResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClaimResponse;
    procedure SetItemN(index : Integer; value : TFhirClaimResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClaimResponseList; Overload;
    function Clone : TFhirClaimResponseList; Overload;
    function GetEnumerator : TFhirClaimResponseListEnumerator;
    

    //  Add a FhirClaimResponse to the end of the list.
    function Append : TFhirClaimResponse;

    
    // Add an already existing FhirClaimResponse to the end of the list.
    procedure AddItem(value : TFhirClaimResponse); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClaimResponse) : Integer;
    

    // Insert FhirClaimResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClaimResponse;
    

    // Insert an existing FhirClaimResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClaimResponse);
    
    // Get the iIndexth FhirClaimResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClaimResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClaimResponse;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirClaimResponses[index : Integer] : TFhirClaimResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CLAIMRESPONSE}

{$IFDEF FHIR_COVERAGE}

  // A suite of underwriter specific classifiers.
  TFhirCoverageClass = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirString;
    FName : TFhirString;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageClass; overload;
    function Clone : TFhirCoverageClass; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The type of classification for which an insurer-specific class label or number and optional name is provided, for example may be used to identify a class of coverage or employer group, Policy, Plan. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of classification for which an insurer-specific class label or number and optional name is provided, for example may be used to identify a class of coverage or employer group, Policy, Plan.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The alphanumeric string value associated with the insurer issued label.
    property value : String read GetValueST write SetValueST;
    // The alphanumeric string value associated with the insurer issued label.
    property valueElement : TFhirString read FValue write SetValue;

    // Typed access to A short description for the class.
    property name : String read GetNameST write SetNameST;
    // A short description for the class.
    property nameElement : TFhirString read FName write SetName;

  end;

  TFhirCoverageClassListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageClassList;
    function GetCurrent : TFhirCoverageClass;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageClassList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageClass read GetCurrent;
  end;

  TFhirCoverageClassList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCoverageClass;
    procedure SetItemN(index : Integer; value : TFhirCoverageClass);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCoverageClassList; Overload;
    function Clone : TFhirCoverageClassList; Overload;
    function GetEnumerator : TFhirCoverageClassListEnumerator;
    

    //  Add a FhirCoverageClass to the end of the list.
    function Append : TFhirCoverageClass;

    
    // Add an already existing FhirCoverageClass to the end of the list.
    procedure AddItem(value : TFhirCoverageClass); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageClass) : Integer;
    

    // Insert FhirCoverageClass before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageClass;
    

    // Insert an existing FhirCoverageClass before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageClass);
    
    // Get the iIndexth FhirCoverageClass. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageClass);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageClass;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCoverageClasses[index : Integer] : TFhirCoverageClass read GetItemN write SetItemN; default;
  End;

  // A suite of codes indicating the cost category and associated amount which have been detailed in the policy and may have been  included on the health card.
  TFhirCoverageCostToBeneficiary = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirType;
    FexceptionList : TFhirCoverageCostToBeneficiaryExceptionList;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirType);
    function GetExceptionList : TFhirCoverageCostToBeneficiaryExceptionList;
    function GetHasExceptionList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageCostToBeneficiary; overload;
    function Clone : TFhirCoverageCostToBeneficiary; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The category of patient centric costs associated with treatment. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of patient centric costs associated with treatment.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The amount due from the patient for the cost category. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // The amount due from the patient for the cost category.
    property valueElement : TFhirType read FValue write SetValue;

    // A suite of codes indicating exceptions or reductions to patient costs and their effective periods.
    property exceptionList : TFhirCoverageCostToBeneficiaryExceptionList read GetExceptionList;
    property hasExceptionList : boolean read GetHasExceptionList;

  end;

  TFhirCoverageCostToBeneficiaryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageCostToBeneficiaryList;
    function GetCurrent : TFhirCoverageCostToBeneficiary;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageCostToBeneficiaryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageCostToBeneficiary read GetCurrent;
  end;

  TFhirCoverageCostToBeneficiaryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCoverageCostToBeneficiary;
    procedure SetItemN(index : Integer; value : TFhirCoverageCostToBeneficiary);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCoverageCostToBeneficiaryList; Overload;
    function Clone : TFhirCoverageCostToBeneficiaryList; Overload;
    function GetEnumerator : TFhirCoverageCostToBeneficiaryListEnumerator;
    

    //  Add a FhirCoverageCostToBeneficiary to the end of the list.
    function Append : TFhirCoverageCostToBeneficiary;

    
    // Add an already existing FhirCoverageCostToBeneficiary to the end of the list.
    procedure AddItem(value : TFhirCoverageCostToBeneficiary); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageCostToBeneficiary) : Integer;
    

    // Insert FhirCoverageCostToBeneficiary before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageCostToBeneficiary;
    

    // Insert an existing FhirCoverageCostToBeneficiary before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageCostToBeneficiary);
    
    // Get the iIndexth FhirCoverageCostToBeneficiary. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageCostToBeneficiary);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageCostToBeneficiary;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCoverageCostToBeneficiaries[index : Integer] : TFhirCoverageCostToBeneficiary read GetItemN write SetItemN; default;
  End;

  // A suite of codes indicating exceptions or reductions to patient costs and their effective periods.
  TFhirCoverageCostToBeneficiaryException = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetPeriod(value : TFhirPeriod);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageCostToBeneficiaryException; overload;
    function Clone : TFhirCoverageCostToBeneficiaryException; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The code for the specific exception. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The code for the specific exception.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The timeframe during when the exception is in force. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The timeframe during when the exception is in force.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirCoverageCostToBeneficiaryExceptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageCostToBeneficiaryExceptionList;
    function GetCurrent : TFhirCoverageCostToBeneficiaryException;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageCostToBeneficiaryExceptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageCostToBeneficiaryException read GetCurrent;
  end;

  TFhirCoverageCostToBeneficiaryExceptionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCoverageCostToBeneficiaryException;
    procedure SetItemN(index : Integer; value : TFhirCoverageCostToBeneficiaryException);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCoverageCostToBeneficiaryExceptionList; Overload;
    function Clone : TFhirCoverageCostToBeneficiaryExceptionList; Overload;
    function GetEnumerator : TFhirCoverageCostToBeneficiaryExceptionListEnumerator;
    

    //  Add a FhirCoverageCostToBeneficiaryException to the end of the list.
    function Append : TFhirCoverageCostToBeneficiaryException;

    
    // Add an already existing FhirCoverageCostToBeneficiaryException to the end of the list.
    procedure AddItem(value : TFhirCoverageCostToBeneficiaryException); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageCostToBeneficiaryException) : Integer;
    

    // Insert FhirCoverageCostToBeneficiaryException before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageCostToBeneficiaryException;
    

    // Insert an existing FhirCoverageCostToBeneficiaryException before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageCostToBeneficiaryException);
    
    // Get the iIndexth FhirCoverageCostToBeneficiaryException. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageCostToBeneficiaryException);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageCostToBeneficiaryException;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCoverageCostToBeneficiaryExceptions[index : Integer] : TFhirCoverageCostToBeneficiaryException read GetItemN write SetItemN; default;
  End;

  // Financial instrument which may be used to reimburse or pay for health care products and services. Includes both insurance and self-payment.
  TFhirCoverage = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FPolicyHolder : TFhirReference{TFhirPatient};
    FSubscriber : TFhirReference{TFhirPatient};
    FSubscriberId : TFhirString;
    FBeneficiary : TFhirReference{TFhirPatient};
    FDependent : TFhirString;
    FRelationship : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    FpayorList : TFhirReferenceList{TFhirOrganization};
    Fclass_List : TFhirCoverageClassList;
    FOrder : TFhirPositiveInt;
    FNetwork : TFhirString;
    FcostToBeneficiaryList : TFhirCoverageCostToBeneficiaryList;
    FSubrogation : TFhirBoolean;
    FcontractList : TFhirReferenceList{TFhirContract};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetPolicyHolder(value : TFhirReference{TFhirPatient});
    Procedure SetSubscriber(value : TFhirReference{TFhirPatient});
    Procedure SetSubscriberId(value : TFhirString);
    Function GetSubscriberIdST : String;
    Procedure SetSubscriberIdST(value : String);
    Procedure SetBeneficiary(value : TFhirReference{TFhirPatient});
    Procedure SetDependent(value : TFhirString);
    Function GetDependentST : String;
    Procedure SetDependentST(value : String);
    Procedure SetRelationship(value : TFhirCodeableConcept);
    Procedure SetPeriod(value : TFhirPeriod);
    function GetPayorList : TFhirReferenceList{TFhirOrganization};
    function GetHasPayorList : Boolean;
    function GetClass_List : TFhirCoverageClassList;
    function GetHasClass_List : Boolean;
    Procedure SetOrder(value : TFhirPositiveInt);
    Function GetOrderST : String;
    Procedure SetOrderST(value : String);
    Procedure SetNetwork(value : TFhirString);
    Function GetNetworkST : String;
    Procedure SetNetworkST(value : String);
    function GetCostToBeneficiaryList : TFhirCoverageCostToBeneficiaryList;
    function GetHasCostToBeneficiaryList : Boolean;
    Procedure SetSubrogation(value : TFhirBoolean);
    Function GetSubrogationST : Boolean;
    Procedure SetSubrogationST(value : Boolean);
    function GetContractList : TFhirReferenceList{TFhirContract};
    function GetHasContractList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverage; overload;
    function Clone : TFhirCoverage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A unique identifier assigned to this coverage.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The type of coverage: social program, medical plan, accident coverage (workers compensation, auto), group health or payment by an individual or organization. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of coverage: social program, medical plan, accident coverage (workers compensation, auto), group health or payment by an individual or organization.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The party who 'owns' the insurance policy. (defined for API consistency)
    property policyHolder : TFhirReference{TFhirPatient} read FPolicyHolder write SetPolicyHolder;
    // The party who 'owns' the insurance policy.
    property policyHolderElement : TFhirReference{TFhirPatient} read FPolicyHolder write SetPolicyHolder;

    // Typed access to The party who has signed-up for or 'owns' the contractual relationship to the policy or to whom the benefit of the policy for services rendered to them or their family is due. (defined for API consistency)
    property subscriber : TFhirReference{TFhirPatient} read FSubscriber write SetSubscriber;
    // The party who has signed-up for or 'owns' the contractual relationship to the policy or to whom the benefit of the policy for services rendered to them or their family is due.
    property subscriberElement : TFhirReference{TFhirPatient} read FSubscriber write SetSubscriber;

    // Typed access to The insurer assigned ID for the Subscriber.
    property subscriberId : String read GetSubscriberIdST write SetSubscriberIdST;
    // The insurer assigned ID for the Subscriber.
    property subscriberIdElement : TFhirString read FSubscriberId write SetSubscriberId;

    // Typed access to The party who benefits from the insurance coverage; the patient when products and/or services are provided. (defined for API consistency)
    property beneficiary : TFhirReference{TFhirPatient} read FBeneficiary write SetBeneficiary;
    // The party who benefits from the insurance coverage; the patient when products and/or services are provided.
    property beneficiaryElement : TFhirReference{TFhirPatient} read FBeneficiary write SetBeneficiary;

    // Typed access to A unique identifier for a dependent under the coverage.
    property dependent : String read GetDependentST write SetDependentST;
    // A unique identifier for a dependent under the coverage.
    property dependentElement : TFhirString read FDependent write SetDependent;

    // Typed access to The relationship of beneficiary (patient) to the subscriber. (defined for API consistency)
    property relationship : TFhirCodeableConcept read FRelationship write SetRelationship;
    // The relationship of beneficiary (patient) to the subscriber.
    property relationshipElement : TFhirCodeableConcept read FRelationship write SetRelationship;

    // Typed access to Time period during which the coverage is in force. A missing start date indicates the start date isn't known, a missing end date means the coverage is continuing to be in force. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Time period during which the coverage is in force. A missing start date indicates the start date isn't known, a missing end date means the coverage is continuing to be in force.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // The program or plan underwriter or payor including both insurance and non-insurance agreements, such as patient-pay agreements.
    property payorList : TFhirReferenceList{TFhirOrganization} read GetPayorList;
    property hasPayorList : boolean read GetHasPayorList;

    // A suite of underwriter specific classifiers.
    property class_List : TFhirCoverageClassList read GetClass_List;
    property hasClass_List : boolean read GetHasClass_List;

    // Typed access to The order of applicability of this coverage relative to other coverages which are currently in force. Note, there may be gaps in the numbering and this does not imply primary, secondary etc. as the specific positioning of coverages depends upon the episode of care.
    property order : String read GetOrderST write SetOrderST;
    // The order of applicability of this coverage relative to other coverages which are currently in force. Note, there may be gaps in the numbering and this does not imply primary, secondary etc. as the specific positioning of coverages depends upon the episode of care.
    property orderElement : TFhirPositiveInt read FOrder write SetOrder;

    // Typed access to The insurer-specific identifier for the insurer-defined network of providers to which the beneficiary may seek treatment which will be covered at the 'in-network' rate, otherwise 'out of network' terms and conditions apply.
    property network : String read GetNetworkST write SetNetworkST;
    // The insurer-specific identifier for the insurer-defined network of providers to which the beneficiary may seek treatment which will be covered at the 'in-network' rate, otherwise 'out of network' terms and conditions apply.
    property networkElement : TFhirString read FNetwork write SetNetwork;

    // A suite of codes indicating the cost category and associated amount which have been detailed in the policy and may have been  included on the health card.
    property costToBeneficiaryList : TFhirCoverageCostToBeneficiaryList read GetCostToBeneficiaryList;
    property hasCostToBeneficiaryList : boolean read GetHasCostToBeneficiaryList;

    // Typed access to When 'subrogation=true' this insurance instance has been included not for adjudication but to provide insurers with the details to recover costs.
    property subrogation : Boolean read GetSubrogationST write SetSubrogationST;
    // When 'subrogation=true' this insurance instance has been included not for adjudication but to provide insurers with the details to recover costs.
    property subrogationElement : TFhirBoolean read FSubrogation write SetSubrogation;

    // The policy(s) which constitute this insurance coverage.
    property contractList : TFhirReferenceList{TFhirContract} read GetContractList;
    property hasContractList : boolean read GetHasContractList;

  end;

  TFhirCoverageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageList;
    function GetCurrent : TFhirCoverage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverage read GetCurrent;
  end;

  TFhirCoverageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCoverage;
    procedure SetItemN(index : Integer; value : TFhirCoverage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCoverageList; Overload;
    function Clone : TFhirCoverageList; Overload;
    function GetEnumerator : TFhirCoverageListEnumerator;
    

    //  Add a FhirCoverage to the end of the list.
    function Append : TFhirCoverage;

    
    // Add an already existing FhirCoverage to the end of the list.
    procedure AddItem(value : TFhirCoverage); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverage) : Integer;
    

    // Insert FhirCoverage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverage;
    

    // Insert an existing FhirCoverage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverage);
    
    // Get the iIndexth FhirCoverage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverage;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCoverages[index : Integer] : TFhirCoverage read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COVERAGE}

{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}

  // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
  TFhirCoverageEligibilityRequestSupportingInfo = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FInformation : TFhirReference{TFhirReference};
    FAppliesToAll : TFhirBoolean;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetInformation(value : TFhirReference{TFhirReference});
    Procedure SetAppliesToAll(value : TFhirBoolean);
    Function GetAppliesToAllST : Boolean;
    Procedure SetAppliesToAllST(value : Boolean);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityRequestSupportingInfo; overload;
    function Clone : TFhirCoverageEligibilityRequestSupportingInfo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number to uniquely identify supporting information entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify supporting information entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data. (defined for API consistency)
    property information : TFhirReference{TFhirReference} read FInformation write SetInformation;
    // Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
    property informationElement : TFhirReference{TFhirReference} read FInformation write SetInformation;

    // Typed access to The supporting materials are applicable for all detail items, product/servce categories and specific billing codes.
    property appliesToAll : Boolean read GetAppliesToAllST write SetAppliesToAllST;
    // The supporting materials are applicable for all detail items, product/servce categories and specific billing codes.
    property appliesToAllElement : TFhirBoolean read FAppliesToAll write SetAppliesToAll;

  end;

  TFhirCoverageEligibilityRequestSupportingInfoListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityRequestSupportingInfoList;
    function GetCurrent : TFhirCoverageEligibilityRequestSupportingInfo;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityRequestSupportingInfoList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityRequestSupportingInfo read GetCurrent;
  end;

  TFhirCoverageEligibilityRequestSupportingInfoList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCoverageEligibilityRequestSupportingInfo;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityRequestSupportingInfo);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCoverageEligibilityRequestSupportingInfoList; Overload;
    function Clone : TFhirCoverageEligibilityRequestSupportingInfoList; Overload;
    function GetEnumerator : TFhirCoverageEligibilityRequestSupportingInfoListEnumerator;
    

    //  Add a FhirCoverageEligibilityRequestSupportingInfo to the end of the list.
    function Append : TFhirCoverageEligibilityRequestSupportingInfo;

    
    // Add an already existing FhirCoverageEligibilityRequestSupportingInfo to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityRequestSupportingInfo); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityRequestSupportingInfo) : Integer;
    

    // Insert FhirCoverageEligibilityRequestSupportingInfo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityRequestSupportingInfo;
    

    // Insert an existing FhirCoverageEligibilityRequestSupportingInfo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityRequestSupportingInfo);
    
    // Get the iIndexth FhirCoverageEligibilityRequestSupportingInfo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityRequestSupportingInfo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityRequestSupportingInfo;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCoverageEligibilityRequestSupportingInfos[index : Integer] : TFhirCoverageEligibilityRequestSupportingInfo read GetItemN write SetItemN; default;
  End;

  // Financial instruments for reimbursement for the health care products and services.
  TFhirCoverageEligibilityRequestInsurance = class (TFhirBackboneElement)
  protected
    FFocal : TFhirBoolean;
    FCoverage : TFhirReference{TFhirCoverage};
    FBusinessArrangement : TFhirString;
    Procedure SetFocal(value : TFhirBoolean);
    Function GetFocalST : Boolean;
    Procedure SetFocalST(value : Boolean);
    Procedure SetCoverage(value : TFhirReference{TFhirCoverage});
    Procedure SetBusinessArrangement(value : TFhirString);
    Function GetBusinessArrangementST : String;
    Procedure SetBusinessArrangementST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityRequestInsurance; overload;
    function Clone : TFhirCoverageEligibilityRequestInsurance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A flag to indicate that this Coverage is to be used for evaluation of this request when set to true.
    property focal : Boolean read GetFocalST write SetFocalST;
    // A flag to indicate that this Coverage is to be used for evaluation of this request when set to true.
    property focalElement : TFhirBoolean read FFocal write SetFocal;

    // Typed access to Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system. (defined for API consistency)
    property coverage : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;
    // Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system.
    property coverageElement : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;

    // Typed access to A business agreement number established between the provider and the insurer for special business processing purposes.
    property businessArrangement : String read GetBusinessArrangementST write SetBusinessArrangementST;
    // A business agreement number established between the provider and the insurer for special business processing purposes.
    property businessArrangementElement : TFhirString read FBusinessArrangement write SetBusinessArrangement;

  end;

  TFhirCoverageEligibilityRequestInsuranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityRequestInsuranceList;
    function GetCurrent : TFhirCoverageEligibilityRequestInsurance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityRequestInsuranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityRequestInsurance read GetCurrent;
  end;

  TFhirCoverageEligibilityRequestInsuranceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCoverageEligibilityRequestInsurance;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityRequestInsurance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCoverageEligibilityRequestInsuranceList; Overload;
    function Clone : TFhirCoverageEligibilityRequestInsuranceList; Overload;
    function GetEnumerator : TFhirCoverageEligibilityRequestInsuranceListEnumerator;
    

    //  Add a FhirCoverageEligibilityRequestInsurance to the end of the list.
    function Append : TFhirCoverageEligibilityRequestInsurance;

    
    // Add an already existing FhirCoverageEligibilityRequestInsurance to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityRequestInsurance); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityRequestInsurance) : Integer;
    

    // Insert FhirCoverageEligibilityRequestInsurance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityRequestInsurance;
    

    // Insert an existing FhirCoverageEligibilityRequestInsurance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityRequestInsurance);
    
    // Get the iIndexth FhirCoverageEligibilityRequestInsurance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityRequestInsurance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityRequestInsurance;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCoverageEligibilityRequestInsurances[index : Integer] : TFhirCoverageEligibilityRequestInsurance read GetItemN write SetItemN; default;
  End;

  // Service categories or billable services for which benefit details and/or an authorization prior to service delivery may be required by the payor.
  TFhirCoverageEligibilityRequestItem = class (TFhirBackboneElement)
  protected
    FsupportingInfoSequenceList : TFhirPositiveIntList;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FProvider : TFhirReference{TFhirPractitioner};
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFacility : TFhirReference{TFhirLocation};
    FdiagnosisList : TFhirCoverageEligibilityRequestItemDiagnosisList;
    FdetailList : TFhirReferenceList{TFhirReference};
    function GetSupportingInfoSequenceList : TFhirPositiveIntList;
    function GetHasSupportingInfoSequenceList : Boolean;
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFacility(value : TFhirReference{TFhirLocation});
    function GetDiagnosisList : TFhirCoverageEligibilityRequestItemDiagnosisList;
    function GetHasDiagnosisList : Boolean;
    function GetDetailList : TFhirReferenceList{TFhirReference};
    function GetHasDetailList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityRequestItem; overload;
    function Clone : TFhirCoverageEligibilityRequestItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Exceptions, special conditions and supporting information applicable for this service or product line.
    property supportingInfoSequenceList : TFhirPositiveIntList read GetSupportingInfoSequenceList;
    property hasSupportingInfoSequenceList : boolean read GetHasSupportingInfoSequenceList;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to This contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // This contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The practitioner who is responsible for the product or service to be rendered to the patient. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // The practitioner who is responsible for the product or service to be rendered to the patient.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The amount charged to the patient by the provider for a single unit. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // The amount charged to the patient by the provider for a single unit.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to Facility where the services will be provided. (defined for API consistency)
    property facility : TFhirReference{TFhirLocation} read FFacility write SetFacility;
    // Facility where the services will be provided.
    property facilityElement : TFhirReference{TFhirLocation} read FFacility write SetFacility;

    // Patient diagnosis for which care is sought.
    property diagnosisList : TFhirCoverageEligibilityRequestItemDiagnosisList read GetDiagnosisList;
    property hasDiagnosisList : boolean read GetHasDiagnosisList;

    // The plan/proposal/order describing the proposed service in detail.
    property detailList : TFhirReferenceList{TFhirReference} read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirCoverageEligibilityRequestItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityRequestItemList;
    function GetCurrent : TFhirCoverageEligibilityRequestItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityRequestItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityRequestItem read GetCurrent;
  end;

  TFhirCoverageEligibilityRequestItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCoverageEligibilityRequestItem;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityRequestItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCoverageEligibilityRequestItemList; Overload;
    function Clone : TFhirCoverageEligibilityRequestItemList; Overload;
    function GetEnumerator : TFhirCoverageEligibilityRequestItemListEnumerator;
    

    //  Add a FhirCoverageEligibilityRequestItem to the end of the list.
    function Append : TFhirCoverageEligibilityRequestItem;

    
    // Add an already existing FhirCoverageEligibilityRequestItem to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityRequestItem); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityRequestItem) : Integer;
    

    // Insert FhirCoverageEligibilityRequestItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityRequestItem;
    

    // Insert an existing FhirCoverageEligibilityRequestItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityRequestItem);
    
    // Get the iIndexth FhirCoverageEligibilityRequestItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityRequestItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityRequestItem;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCoverageEligibilityRequestItems[index : Integer] : TFhirCoverageEligibilityRequestItem read GetItemN write SetItemN; default;
  End;

  // Patient diagnosis for which care is sought.
  TFhirCoverageEligibilityRequestItemDiagnosis = class (TFhirBackboneElement)
  protected
    FDiagnosis : TFhirType;
    Procedure SetDiagnosis(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityRequestItemDiagnosis; overload;
    function Clone : TFhirCoverageEligibilityRequestItemDiagnosis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The nature of illness or problem in a coded form or as a reference to an external defined Condition. (defined for API consistency)
    property diagnosis : TFhirType read FDiagnosis write SetDiagnosis;
    // The nature of illness or problem in a coded form or as a reference to an external defined Condition.
    property diagnosisElement : TFhirType read FDiagnosis write SetDiagnosis;

  end;

  TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityRequestItemDiagnosisList;
    function GetCurrent : TFhirCoverageEligibilityRequestItemDiagnosis;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityRequestItemDiagnosisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityRequestItemDiagnosis read GetCurrent;
  end;

  TFhirCoverageEligibilityRequestItemDiagnosisList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCoverageEligibilityRequestItemDiagnosis;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityRequestItemDiagnosis);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCoverageEligibilityRequestItemDiagnosisList; Overload;
    function Clone : TFhirCoverageEligibilityRequestItemDiagnosisList; Overload;
    function GetEnumerator : TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator;
    

    //  Add a FhirCoverageEligibilityRequestItemDiagnosis to the end of the list.
    function Append : TFhirCoverageEligibilityRequestItemDiagnosis;

    
    // Add an already existing FhirCoverageEligibilityRequestItemDiagnosis to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityRequestItemDiagnosis); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityRequestItemDiagnosis) : Integer;
    

    // Insert FhirCoverageEligibilityRequestItemDiagnosis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityRequestItemDiagnosis;
    

    // Insert an existing FhirCoverageEligibilityRequestItemDiagnosis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityRequestItemDiagnosis);
    
    // Get the iIndexth FhirCoverageEligibilityRequestItemDiagnosis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityRequestItemDiagnosis);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityRequestItemDiagnosis;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCoverageEligibilityRequestItemDiagnoses[index : Integer] : TFhirCoverageEligibilityRequestItemDiagnosis read GetItemN write SetItemN; default;
  End;

  // The CoverageEligibilityRequest provides patient and insurance coverage information to an insurer for them to respond, in the form of an CoverageEligibilityResponse, with information regarding whether the stated coverage is valid and in-force and optionally to provide the insurance details of the policy.
  TFhirCoverageEligibilityRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FPriority : TFhirCodeableConcept;
    FPurpose : TFhirEnumList;
    FPatient : TFhirReference{TFhirPatient};
    FServiced : TFhirType;
    FCreated : TFhirDateTime;
    FEnterer : TFhirReference{TFhirPractitioner};
    FProvider : TFhirReference{TFhirPractitioner};
    FInsurer : TFhirReference{TFhirOrganization};
    FFacility : TFhirReference{TFhirLocation};
    FsupportingInfoList : TFhirCoverageEligibilityRequestSupportingInfoList;
    FinsuranceList : TFhirCoverageEligibilityRequestInsuranceList;
    FitemList : TFhirCoverageEligibilityRequestItemList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    Procedure SetPriority(value : TFhirCodeableConcept);
    function GetPurpose : TFhirEnumList;
    function GetHasPurpose : Boolean;
    Function GetPurposeST : TFhirEligibilityrequestPurposeEnumList;
    Procedure SetPurposeST(value : TFhirEligibilityrequestPurposeEnumList);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetServiced(value : TFhirType);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetEnterer(value : TFhirReference{TFhirPractitioner});
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetInsurer(value : TFhirReference{TFhirOrganization});
    Procedure SetFacility(value : TFhirReference{TFhirLocation});
    function GetSupportingInfoList : TFhirCoverageEligibilityRequestSupportingInfoList;
    function GetHasSupportingInfoList : Boolean;
    function GetInsuranceList : TFhirCoverageEligibilityRequestInsuranceList;
    function GetHasInsuranceList : Boolean;
    function GetItemList : TFhirCoverageEligibilityRequestItemList;
    function GetHasItemList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityRequest; overload;
    function Clone : TFhirCoverageEligibilityRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A unique identifier assigned to this coverage eligiblity request.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to When the requestor expects the processor to complete processing. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // When the requestor expects the processor to complete processing.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Code to specify whether requesting: prior authorization requirements for some service categories or billing codes; benefits for coverages specified or discovered; discovery and return of coverages for the patient; and/or validation that the specified coverage is in-force at the date/period specified or 'now' if not specified.
    property purpose : TFhirEligibilityrequestPurposeEnumList read GetPurposeST write SetPurposeST;
    property purposeList : TFhirEnumList read GetPurpose;
    property hasPurpose : boolean read GetHasPurpose;
    // Typed access to The party who is the beneficiary of the supplied coverage and for whom eligibility is sought. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The party who is the beneficiary of the supplied coverage and for whom eligibility is sought.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The date or dates when the enclosed suite of services were performed or completed. (defined for API consistency)
    property serviced : TFhirType read FServiced write SetServiced;
    // The date or dates when the enclosed suite of services were performed or completed.
    property servicedElement : TFhirType read FServiced write SetServiced;

    // Typed access to The date when this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to Person who created the request. (defined for API consistency)
    property enterer : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;
    // Person who created the request.
    property entererElement : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;

    // Typed access to The provider which is responsible for the request. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // The provider which is responsible for the request.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to The Insurer who issued the coverage in question and is the recipient of the request. (defined for API consistency)
    property insurer : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;
    // The Insurer who issued the coverage in question and is the recipient of the request.
    property insurerElement : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;

    // Typed access to Facility where the services are intended to be provided. (defined for API consistency)
    property facility : TFhirReference{TFhirLocation} read FFacility write SetFacility;
    // Facility where the services are intended to be provided.
    property facilityElement : TFhirReference{TFhirLocation} read FFacility write SetFacility;

    // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
    property supportingInfoList : TFhirCoverageEligibilityRequestSupportingInfoList read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Financial instruments for reimbursement for the health care products and services.
    property insuranceList : TFhirCoverageEligibilityRequestInsuranceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Service categories or billable services for which benefit details and/or an authorization prior to service delivery may be required by the payor.
    property itemList : TFhirCoverageEligibilityRequestItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirCoverageEligibilityRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityRequestList;
    function GetCurrent : TFhirCoverageEligibilityRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityRequest read GetCurrent;
  end;

  TFhirCoverageEligibilityRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCoverageEligibilityRequest;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCoverageEligibilityRequestList; Overload;
    function Clone : TFhirCoverageEligibilityRequestList; Overload;
    function GetEnumerator : TFhirCoverageEligibilityRequestListEnumerator;
    

    //  Add a FhirCoverageEligibilityRequest to the end of the list.
    function Append : TFhirCoverageEligibilityRequest;

    
    // Add an already existing FhirCoverageEligibilityRequest to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityRequest); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityRequest) : Integer;
    

    // Insert FhirCoverageEligibilityRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityRequest;
    

    // Insert an existing FhirCoverageEligibilityRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityRequest);
    
    // Get the iIndexth FhirCoverageEligibilityRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityRequest;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCoverageEligibilityRequests[index : Integer] : TFhirCoverageEligibilityRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}

{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}

  // Financial instruments for reimbursement for the health care products and services.
  TFhirCoverageEligibilityResponseInsurance = class (TFhirBackboneElement)
  protected
    FCoverage : TFhirReference{TFhirCoverage};
    FInforce : TFhirBoolean;
    FBenefitPeriod : TFhirPeriod;
    FitemList : TFhirCoverageEligibilityResponseInsuranceItemList;
    Procedure SetCoverage(value : TFhirReference{TFhirCoverage});
    Procedure SetInforce(value : TFhirBoolean);
    Function GetInforceST : Boolean;
    Procedure SetInforceST(value : Boolean);
    Procedure SetBenefitPeriod(value : TFhirPeriod);
    function GetItemList : TFhirCoverageEligibilityResponseInsuranceItemList;
    function GetHasItemList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityResponseInsurance; overload;
    function Clone : TFhirCoverageEligibilityResponseInsurance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system. (defined for API consistency)
    property coverage : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;
    // Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system.
    property coverageElement : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;

    // Typed access to Flag indicating if the coverage provided is inforce currently if no service date(s) specified or for the whole duration of the service dates.
    property inforce : Boolean read GetInforceST write SetInforceST;
    // Flag indicating if the coverage provided is inforce currently if no service date(s) specified or for the whole duration of the service dates.
    property inforceElement : TFhirBoolean read FInforce write SetInforce;

    // Typed access to The term of the benefits documented in this response. (defined for API consistency)
    property benefitPeriod : TFhirPeriod read FBenefitPeriod write SetBenefitPeriod;
    // The term of the benefits documented in this response.
    property benefitPeriodElement : TFhirPeriod read FBenefitPeriod write SetBenefitPeriod;

    // Benefits and optionally current balances, and authorization details by category or service.
    property itemList : TFhirCoverageEligibilityResponseInsuranceItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirCoverageEligibilityResponseInsuranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityResponseInsuranceList;
    function GetCurrent : TFhirCoverageEligibilityResponseInsurance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityResponseInsuranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityResponseInsurance read GetCurrent;
  end;

  TFhirCoverageEligibilityResponseInsuranceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCoverageEligibilityResponseInsurance;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityResponseInsurance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCoverageEligibilityResponseInsuranceList; Overload;
    function Clone : TFhirCoverageEligibilityResponseInsuranceList; Overload;
    function GetEnumerator : TFhirCoverageEligibilityResponseInsuranceListEnumerator;
    

    //  Add a FhirCoverageEligibilityResponseInsurance to the end of the list.
    function Append : TFhirCoverageEligibilityResponseInsurance;

    
    // Add an already existing FhirCoverageEligibilityResponseInsurance to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityResponseInsurance); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityResponseInsurance) : Integer;
    

    // Insert FhirCoverageEligibilityResponseInsurance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityResponseInsurance;
    

    // Insert an existing FhirCoverageEligibilityResponseInsurance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityResponseInsurance);
    
    // Get the iIndexth FhirCoverageEligibilityResponseInsurance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityResponseInsurance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityResponseInsurance;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCoverageEligibilityResponseInsurances[index : Integer] : TFhirCoverageEligibilityResponseInsurance read GetItemN write SetItemN; default;
  End;

  // Benefits and optionally current balances, and authorization details by category or service.
  TFhirCoverageEligibilityResponseInsuranceItem = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FProvider : TFhirReference{TFhirPractitioner};
    FExcluded : TFhirBoolean;
    FName : TFhirString;
    FDescription : TFhirString;
    FNetwork : TFhirCodeableConcept;
    FUnit_ : TFhirCodeableConcept;
    FTerm : TFhirCodeableConcept;
    FbenefitList : TFhirCoverageEligibilityResponseInsuranceItemBenefitList;
    FAuthorizationRequired : TFhirBoolean;
    FauthorizationSupportingList : TFhirCodeableConceptList;
    FAuthorizationUrl : TFhirUri;
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetExcluded(value : TFhirBoolean);
    Function GetExcludedST : Boolean;
    Procedure SetExcludedST(value : Boolean);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetNetwork(value : TFhirCodeableConcept);
    Procedure SetUnit_(value : TFhirCodeableConcept);
    Procedure SetTerm(value : TFhirCodeableConcept);
    function GetBenefitList : TFhirCoverageEligibilityResponseInsuranceItemBenefitList;
    function GetHasBenefitList : Boolean;
    Procedure SetAuthorizationRequired(value : TFhirBoolean);
    Function GetAuthorizationRequiredST : Boolean;
    Procedure SetAuthorizationRequiredST(value : Boolean);
    function GetAuthorizationSupportingList : TFhirCodeableConceptList;
    function GetHasAuthorizationSupportingList : Boolean;
    Procedure SetAuthorizationUrl(value : TFhirUri);
    Function GetAuthorizationUrlST : String;
    Procedure SetAuthorizationUrlST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityResponseInsuranceItem; overload;
    function Clone : TFhirCoverageEligibilityResponseInsuranceItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to This contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // This contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The practitioner who is eligible for the provision of the product or service. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // The practitioner who is eligible for the provision of the product or service.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to True if the indicated class of service is excluded from the plan, missing or False indicates the product or service is included in the coverage.
    property excluded : Boolean read GetExcludedST write SetExcludedST;
    // True if the indicated class of service is excluded from the plan, missing or False indicates the product or service is included in the coverage.
    property excludedElement : TFhirBoolean read FExcluded write SetExcluded;

    // Typed access to A short name or tag for the benefit.
    property name : String read GetNameST write SetNameST;
    // A short name or tag for the benefit.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A richer description of the benefit or services covered.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A richer description of the benefit or services covered.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Is a flag to indicate whether the benefits refer to in-network providers or out-of-network providers. (defined for API consistency)
    property network : TFhirCodeableConcept read FNetwork write SetNetwork;
    // Is a flag to indicate whether the benefits refer to in-network providers or out-of-network providers.
    property networkElement : TFhirCodeableConcept read FNetwork write SetNetwork;

    // Typed access to Indicates if the benefits apply to an individual or to the family. (defined for API consistency)
    property unit_ : TFhirCodeableConcept read FUnit_ write SetUnit_;
    // Indicates if the benefits apply to an individual or to the family.
    property unit_Element : TFhirCodeableConcept read FUnit_ write SetUnit_;

    // Typed access to The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual visits'. (defined for API consistency)
    property term : TFhirCodeableConcept read FTerm write SetTerm;
    // The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual visits'.
    property termElement : TFhirCodeableConcept read FTerm write SetTerm;

    // Benefits used to date.
    property benefitList : TFhirCoverageEligibilityResponseInsuranceItemBenefitList read GetBenefitList;
    property hasBenefitList : boolean read GetHasBenefitList;

    // Typed access to A boolean flag indicating whether a preauthorization is required prior to actual service delivery.
    property authorizationRequired : Boolean read GetAuthorizationRequiredST write SetAuthorizationRequiredST;
    // A boolean flag indicating whether a preauthorization is required prior to actual service delivery.
    property authorizationRequiredElement : TFhirBoolean read FAuthorizationRequired write SetAuthorizationRequired;

    // Codes or comments regarding information or actions associated with the preauthorization.
    property authorizationSupportingList : TFhirCodeableConceptList read GetAuthorizationSupportingList;
    property hasAuthorizationSupportingList : boolean read GetHasAuthorizationSupportingList;

    // Typed access to A web location for obtaining requirements or descriptive information regarding the preauthorization.
    property authorizationUrl : String read GetAuthorizationUrlST write SetAuthorizationUrlST;
    // A web location for obtaining requirements or descriptive information regarding the preauthorization.
    property authorizationUrlElement : TFhirUri read FAuthorizationUrl write SetAuthorizationUrl;

  end;

  TFhirCoverageEligibilityResponseInsuranceItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityResponseInsuranceItemList;
    function GetCurrent : TFhirCoverageEligibilityResponseInsuranceItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityResponseInsuranceItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityResponseInsuranceItem read GetCurrent;
  end;

  TFhirCoverageEligibilityResponseInsuranceItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCoverageEligibilityResponseInsuranceItem;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityResponseInsuranceItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCoverageEligibilityResponseInsuranceItemList; Overload;
    function Clone : TFhirCoverageEligibilityResponseInsuranceItemList; Overload;
    function GetEnumerator : TFhirCoverageEligibilityResponseInsuranceItemListEnumerator;
    

    //  Add a FhirCoverageEligibilityResponseInsuranceItem to the end of the list.
    function Append : TFhirCoverageEligibilityResponseInsuranceItem;

    
    // Add an already existing FhirCoverageEligibilityResponseInsuranceItem to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityResponseInsuranceItem); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityResponseInsuranceItem) : Integer;
    

    // Insert FhirCoverageEligibilityResponseInsuranceItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityResponseInsuranceItem;
    

    // Insert an existing FhirCoverageEligibilityResponseInsuranceItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityResponseInsuranceItem);
    
    // Get the iIndexth FhirCoverageEligibilityResponseInsuranceItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityResponseInsuranceItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityResponseInsuranceItem;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCoverageEligibilityResponseInsuranceItems[index : Integer] : TFhirCoverageEligibilityResponseInsuranceItem read GetItemN write SetItemN; default;
  End;

  // Benefits used to date.
  TFhirCoverageEligibilityResponseInsuranceItemBenefit = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAllowed : TFhirType;
    FUsed : TFhirType;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetAllowed(value : TFhirType);
    Procedure SetUsed(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityResponseInsuranceItemBenefit; overload;
    function Clone : TFhirCoverageEligibilityResponseInsuranceItemBenefit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Classification of benefit being provided. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Classification of benefit being provided.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The quantity of the benefit which is permitted under the coverage. (defined for API consistency)
    property allowed : TFhirType read FAllowed write SetAllowed;
    // The quantity of the benefit which is permitted under the coverage.
    property allowedElement : TFhirType read FAllowed write SetAllowed;

    // Typed access to The quantity of the benefit which have been consumed to date. (defined for API consistency)
    property used : TFhirType read FUsed write SetUsed;
    // The quantity of the benefit which have been consumed to date.
    property usedElement : TFhirType read FUsed write SetUsed;

  end;

  TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityResponseInsuranceItemBenefitList;
    function GetCurrent : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityResponseInsuranceItemBenefitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityResponseInsuranceItemBenefit read GetCurrent;
  end;

  TFhirCoverageEligibilityResponseInsuranceItemBenefitList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityResponseInsuranceItemBenefit);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCoverageEligibilityResponseInsuranceItemBenefitList; Overload;
    function Clone : TFhirCoverageEligibilityResponseInsuranceItemBenefitList; Overload;
    function GetEnumerator : TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator;
    

    //  Add a FhirCoverageEligibilityResponseInsuranceItemBenefit to the end of the list.
    function Append : TFhirCoverageEligibilityResponseInsuranceItemBenefit;

    
    // Add an already existing FhirCoverageEligibilityResponseInsuranceItemBenefit to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityResponseInsuranceItemBenefit); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityResponseInsuranceItemBenefit) : Integer;
    

    // Insert FhirCoverageEligibilityResponseInsuranceItemBenefit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
    

    // Insert an existing FhirCoverageEligibilityResponseInsuranceItemBenefit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityResponseInsuranceItemBenefit);
    
    // Get the iIndexth FhirCoverageEligibilityResponseInsuranceItemBenefit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityResponseInsuranceItemBenefit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCoverageEligibilityResponseInsuranceItemBenefits[index : Integer] : TFhirCoverageEligibilityResponseInsuranceItemBenefit read GetItemN write SetItemN; default;
  End;

  // Errors encountered during the processing of the request.
  TFhirCoverageEligibilityResponseError = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    Procedure SetCode(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityResponseError; overload;
    function Clone : TFhirCoverageEligibilityResponseError; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An error code,from a specified code system, which details why the eligibility check could not be performed. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // An error code,from a specified code system, which details why the eligibility check could not be performed.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

  end;

  TFhirCoverageEligibilityResponseErrorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityResponseErrorList;
    function GetCurrent : TFhirCoverageEligibilityResponseError;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityResponseErrorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityResponseError read GetCurrent;
  end;

  TFhirCoverageEligibilityResponseErrorList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCoverageEligibilityResponseError;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityResponseError);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCoverageEligibilityResponseErrorList; Overload;
    function Clone : TFhirCoverageEligibilityResponseErrorList; Overload;
    function GetEnumerator : TFhirCoverageEligibilityResponseErrorListEnumerator;
    

    //  Add a FhirCoverageEligibilityResponseError to the end of the list.
    function Append : TFhirCoverageEligibilityResponseError;

    
    // Add an already existing FhirCoverageEligibilityResponseError to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityResponseError); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityResponseError) : Integer;
    

    // Insert FhirCoverageEligibilityResponseError before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityResponseError;
    

    // Insert an existing FhirCoverageEligibilityResponseError before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityResponseError);
    
    // Get the iIndexth FhirCoverageEligibilityResponseError. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityResponseError);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityResponseError;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCoverageEligibilityResponseErrors[index : Integer] : TFhirCoverageEligibilityResponseError read GetItemN write SetItemN; default;
  End;

  // This resource provides eligibility and plan details from the processing of an CoverageEligibilityRequest resource.
  TFhirCoverageEligibilityResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FPurpose : TFhirEnumList;
    FPatient : TFhirReference{TFhirPatient};
    FServiced : TFhirType;
    FCreated : TFhirDateTime;
    FRequestor : TFhirReference{TFhirPractitioner};
    FRequest : TFhirReference{TFhirCoverageEligibilityRequest};
    FOutcome : TFhirEnum;
    FDisposition : TFhirString;
    FInsurer : TFhirReference{TFhirOrganization};
    FinsuranceList : TFhirCoverageEligibilityResponseInsuranceList;
    FPreAuthRef : TFhirString;
    FForm : TFhirCodeableConcept;
    FerrorList : TFhirCoverageEligibilityResponseErrorList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    function GetPurpose : TFhirEnumList;
    function GetHasPurpose : Boolean;
    Function GetPurposeST : TFhirEligibilityresponsePurposeEnumList;
    Procedure SetPurposeST(value : TFhirEligibilityresponsePurposeEnumList);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetServiced(value : TFhirType);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetRequestor(value : TFhirReference{TFhirPractitioner});
    Procedure SetRequest(value : TFhirReference{TFhirCoverageEligibilityRequest});
    Procedure SetOutcome(value : TFhirEnum);
    Function GetOutcomeST : TFhirRemittanceOutcomeEnum;
    Procedure SetOutcomeST(value : TFhirRemittanceOutcomeEnum);
    Procedure SetDisposition(value : TFhirString);
    Function GetDispositionST : String;
    Procedure SetDispositionST(value : String);
    Procedure SetInsurer(value : TFhirReference{TFhirOrganization});
    function GetInsuranceList : TFhirCoverageEligibilityResponseInsuranceList;
    function GetHasInsuranceList : Boolean;
    Procedure SetPreAuthRef(value : TFhirString);
    Function GetPreAuthRefST : String;
    Procedure SetPreAuthRefST(value : String);
    Procedure SetForm(value : TFhirCodeableConcept);
    function GetErrorList : TFhirCoverageEligibilityResponseErrorList;
    function GetHasErrorList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageEligibilityResponse; overload;
    function Clone : TFhirCoverageEligibilityResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A unique identifier assigned to this coverage eligiblity request.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Code to specify whether requesting: prior authorization requirements for some service categories or billing codes; benefits for coverages specified or discovered; discovery and return of coverages for the patient; and/or validation that the specified coverage is in-force at the date/period specified or 'now' if not specified.
    property purpose : TFhirEligibilityresponsePurposeEnumList read GetPurposeST write SetPurposeST;
    property purposeList : TFhirEnumList read GetPurpose;
    property hasPurpose : boolean read GetHasPurpose;
    // Typed access to The party who is the beneficiary of the supplied coverage and for whom eligibility is sought. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The party who is the beneficiary of the supplied coverage and for whom eligibility is sought.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The date or dates when the enclosed suite of services were performed or completed. (defined for API consistency)
    property serviced : TFhirType read FServiced write SetServiced;
    // The date or dates when the enclosed suite of services were performed or completed.
    property servicedElement : TFhirType read FServiced write SetServiced;

    // Typed access to The date this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The provider which is responsible for the request. (defined for API consistency)
    property requestor : TFhirReference{TFhirPractitioner} read FRequestor write SetRequestor;
    // The provider which is responsible for the request.
    property requestorElement : TFhirReference{TFhirPractitioner} read FRequestor write SetRequestor;

    // Typed access to Reference to the original request resource. (defined for API consistency)
    property request : TFhirReference{TFhirCoverageEligibilityRequest} read FRequest write SetRequest;
    // Reference to the original request resource.
    property requestElement : TFhirReference{TFhirCoverageEligibilityRequest} read FRequest write SetRequest;

    // The outcome of the request processing.
    property outcome : TFhirRemittanceOutcomeEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A human readable description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A human readable description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to The Insurer who issued the coverage in question and is the author of the response. (defined for API consistency)
    property insurer : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;
    // The Insurer who issued the coverage in question and is the author of the response.
    property insurerElement : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;

    // Financial instruments for reimbursement for the health care products and services.
    property insuranceList : TFhirCoverageEligibilityResponseInsuranceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Typed access to A reference from the Insurer to which these services pertain to be used on further communication and as proof that the request occurred.
    property preAuthRef : String read GetPreAuthRefST write SetPreAuthRefST;
    // A reference from the Insurer to which these services pertain to be used on further communication and as proof that the request occurred.
    property preAuthRefElement : TFhirString read FPreAuthRef write SetPreAuthRef;

    // Typed access to A code for the form to be used for printing the content. (defined for API consistency)
    property form : TFhirCodeableConcept read FForm write SetForm;
    // A code for the form to be used for printing the content.
    property formElement : TFhirCodeableConcept read FForm write SetForm;

    // Errors encountered during the processing of the request.
    property errorList : TFhirCoverageEligibilityResponseErrorList read GetErrorList;
    property hasErrorList : boolean read GetHasErrorList;

  end;

  TFhirCoverageEligibilityResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageEligibilityResponseList;
    function GetCurrent : TFhirCoverageEligibilityResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageEligibilityResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageEligibilityResponse read GetCurrent;
  end;

  TFhirCoverageEligibilityResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCoverageEligibilityResponse;
    procedure SetItemN(index : Integer; value : TFhirCoverageEligibilityResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCoverageEligibilityResponseList; Overload;
    function Clone : TFhirCoverageEligibilityResponseList; Overload;
    function GetEnumerator : TFhirCoverageEligibilityResponseListEnumerator;
    

    //  Add a FhirCoverageEligibilityResponse to the end of the list.
    function Append : TFhirCoverageEligibilityResponse;

    
    // Add an already existing FhirCoverageEligibilityResponse to the end of the list.
    procedure AddItem(value : TFhirCoverageEligibilityResponse); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageEligibilityResponse) : Integer;
    

    // Insert FhirCoverageEligibilityResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageEligibilityResponse;
    

    // Insert an existing FhirCoverageEligibilityResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageEligibilityResponse);
    
    // Get the iIndexth FhirCoverageEligibilityResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageEligibilityResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageEligibilityResponse;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCoverageEligibilityResponses[index : Integer] : TFhirCoverageEligibilityResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}

{$IFDEF FHIR_ENROLLMENTREQUEST}

  // This resource provides the insurance enrollment details to the insurer regarding a specified coverage.
  TFhirEnrollmentRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCreated : TFhirDateTime;
    FInsurer : TFhirReference{TFhirOrganization};
    FProvider : TFhirReference{TFhirPractitioner};
    FCandidate : TFhirReference{TFhirPatient};
    FCoverage : TFhirReference{TFhirCoverage};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetInsurer(value : TFhirReference{TFhirOrganization});
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetCandidate(value : TFhirReference{TFhirPatient});
    Procedure SetCoverage(value : TFhirReference{TFhirCoverage});
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEnrollmentRequest; overload;
    function Clone : TFhirEnrollmentRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The date when this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The Insurer who is target  of the request. (defined for API consistency)
    property insurer : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;
    // The Insurer who is target  of the request.
    property insurerElement : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to Patient Resource. (defined for API consistency)
    property candidate : TFhirReference{TFhirPatient} read FCandidate write SetCandidate;
    // Patient Resource.
    property candidateElement : TFhirReference{TFhirPatient} read FCandidate write SetCandidate;

    // Typed access to Reference to the program or plan identification, underwriter or payor. (defined for API consistency)
    property coverage : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;
    // Reference to the program or plan identification, underwriter or payor.
    property coverageElement : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;

  end;

  TFhirEnrollmentRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEnrollmentRequestList;
    function GetCurrent : TFhirEnrollmentRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEnrollmentRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEnrollmentRequest read GetCurrent;
  end;

  TFhirEnrollmentRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEnrollmentRequest;
    procedure SetItemN(index : Integer; value : TFhirEnrollmentRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEnrollmentRequestList; Overload;
    function Clone : TFhirEnrollmentRequestList; Overload;
    function GetEnumerator : TFhirEnrollmentRequestListEnumerator;
    

    //  Add a FhirEnrollmentRequest to the end of the list.
    function Append : TFhirEnrollmentRequest;

    
    // Add an already existing FhirEnrollmentRequest to the end of the list.
    procedure AddItem(value : TFhirEnrollmentRequest); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEnrollmentRequest) : Integer;
    

    // Insert FhirEnrollmentRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEnrollmentRequest;
    

    // Insert an existing FhirEnrollmentRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEnrollmentRequest);
    
    // Get the iIndexth FhirEnrollmentRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEnrollmentRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEnrollmentRequest;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEnrollmentRequests[index : Integer] : TFhirEnrollmentRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ENROLLMENTREQUEST}

{$IFDEF FHIR_ENROLLMENTRESPONSE}

  // This resource provides enrollment and plan details from the processing of an EnrollmentRequest resource.
  TFhirEnrollmentResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FRequest : TFhirReference{TFhirEnrollmentRequest};
    FOutcome : TFhirEnum;
    FDisposition : TFhirString;
    FCreated : TFhirDateTime;
    FOrganization : TFhirReference{TFhirOrganization};
    FRequestProvider : TFhirReference{TFhirPractitioner};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    Procedure SetRequest(value : TFhirReference{TFhirEnrollmentRequest});
    Procedure SetOutcome(value : TFhirEnum);
    Function GetOutcomeST : TFhirRemittanceOutcomeEnum;
    Procedure SetOutcomeST(value : TFhirRemittanceOutcomeEnum);
    Procedure SetDisposition(value : TFhirString);
    Function GetDispositionST : String;
    Procedure SetDispositionST(value : String);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetRequestProvider(value : TFhirReference{TFhirPractitioner});
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEnrollmentResponse; overload;
    function Clone : TFhirEnrollmentResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The Response business identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Original request resource reference. (defined for API consistency)
    property request : TFhirReference{TFhirEnrollmentRequest} read FRequest write SetRequest;
    // Original request resource reference.
    property requestElement : TFhirReference{TFhirEnrollmentRequest} read FRequest write SetRequest;

    // Processing status: error, complete.
    property outcome : TFhirRemittanceOutcomeEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to The date when the enclosed suite of services were performed or completed.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when the enclosed suite of services were performed or completed.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The Insurer who produced this adjudicated response. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The Insurer who produced this adjudicated response.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property requestProvider : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property requestProviderElement : TFhirReference{TFhirPractitioner} read FRequestProvider write SetRequestProvider;

  end;

  TFhirEnrollmentResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEnrollmentResponseList;
    function GetCurrent : TFhirEnrollmentResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEnrollmentResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEnrollmentResponse read GetCurrent;
  end;

  TFhirEnrollmentResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEnrollmentResponse;
    procedure SetItemN(index : Integer; value : TFhirEnrollmentResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEnrollmentResponseList; Overload;
    function Clone : TFhirEnrollmentResponseList; Overload;
    function GetEnumerator : TFhirEnrollmentResponseListEnumerator;
    

    //  Add a FhirEnrollmentResponse to the end of the list.
    function Append : TFhirEnrollmentResponse;

    
    // Add an already existing FhirEnrollmentResponse to the end of the list.
    procedure AddItem(value : TFhirEnrollmentResponse); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEnrollmentResponse) : Integer;
    

    // Insert FhirEnrollmentResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEnrollmentResponse;
    

    // Insert an existing FhirEnrollmentResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEnrollmentResponse);
    
    // Get the iIndexth FhirEnrollmentResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEnrollmentResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEnrollmentResponse;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEnrollmentResponses[index : Integer] : TFhirEnrollmentResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ENROLLMENTRESPONSE}

{$IFDEF FHIR_EXPLANATIONOFBENEFIT}

  // Other claims which are related to this claim such as prior submissions or claims for related services or for the same event.
  TFhirExplanationOfBenefitRelated = class (TFhirBackboneElement)
  protected
    FClaim : TFhirReference{TFhirClaim};
    FRelationship : TFhirCodeableConcept;
    FReference : TFhirIdentifier;
    Procedure SetClaim(value : TFhirReference{TFhirClaim});
    Procedure SetRelationship(value : TFhirCodeableConcept);
    Procedure SetReference(value : TFhirIdentifier);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitRelated; overload;
    function Clone : TFhirExplanationOfBenefitRelated; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Reference to a related claim. (defined for API consistency)
    property claim : TFhirReference{TFhirClaim} read FClaim write SetClaim;
    // Reference to a related claim.
    property claimElement : TFhirReference{TFhirClaim} read FClaim write SetClaim;

    // Typed access to A code to convey how the claims are related. (defined for API consistency)
    property relationship : TFhirCodeableConcept read FRelationship write SetRelationship;
    // A code to convey how the claims are related.
    property relationshipElement : TFhirCodeableConcept read FRelationship write SetRelationship;

    // Typed access to An alternate organizational reference to the case or file to which this particular claim pertains. (defined for API consistency)
    property reference : TFhirIdentifier read FReference write SetReference;
    // An alternate organizational reference to the case or file to which this particular claim pertains.
    property referenceElement : TFhirIdentifier read FReference write SetReference;

  end;

  TFhirExplanationOfBenefitRelatedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitRelatedList;
    function GetCurrent : TFhirExplanationOfBenefitRelated;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitRelatedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitRelated read GetCurrent;
  end;

  TFhirExplanationOfBenefitRelatedList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitRelated;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitRelated);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitRelatedList; Overload;
    function Clone : TFhirExplanationOfBenefitRelatedList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitRelatedListEnumerator;
    

    //  Add a FhirExplanationOfBenefitRelated to the end of the list.
    function Append : TFhirExplanationOfBenefitRelated;

    
    // Add an already existing FhirExplanationOfBenefitRelated to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitRelated); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitRelated) : Integer;
    

    // Insert FhirExplanationOfBenefitRelated before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitRelated;
    

    // Insert an existing FhirExplanationOfBenefitRelated before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitRelated);
    
    // Get the iIndexth FhirExplanationOfBenefitRelated. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitRelated);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitRelated;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefitRelateds[index : Integer] : TFhirExplanationOfBenefitRelated read GetItemN write SetItemN; default;
  End;

  // The party to be reimbursed for cost of the products and services according to the terms of the policy.
  TFhirExplanationOfBenefitPayee = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FParty : TFhirReference{TFhirPractitioner};
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetParty(value : TFhirReference{TFhirPractitioner});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitPayee; overload;
    function Clone : TFhirExplanationOfBenefitPayee; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Type of Party to be reimbursed: Subscriber, provider, other. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of Party to be reimbursed: Subscriber, provider, other.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Reference to the individual or organization to whom any payment will be made. (defined for API consistency)
    property party : TFhirReference{TFhirPractitioner} read FParty write SetParty;
    // Reference to the individual or organization to whom any payment will be made.
    property partyElement : TFhirReference{TFhirPractitioner} read FParty write SetParty;

  end;

  TFhirExplanationOfBenefitPayeeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitPayeeList;
    function GetCurrent : TFhirExplanationOfBenefitPayee;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitPayeeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitPayee read GetCurrent;
  end;

  TFhirExplanationOfBenefitPayeeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitPayee;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitPayee);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitPayeeList; Overload;
    function Clone : TFhirExplanationOfBenefitPayeeList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitPayeeListEnumerator;
    

    //  Add a FhirExplanationOfBenefitPayee to the end of the list.
    function Append : TFhirExplanationOfBenefitPayee;

    
    // Add an already existing FhirExplanationOfBenefitPayee to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitPayee); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitPayee) : Integer;
    

    // Insert FhirExplanationOfBenefitPayee before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitPayee;
    

    // Insert an existing FhirExplanationOfBenefitPayee before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitPayee);
    
    // Get the iIndexth FhirExplanationOfBenefitPayee. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitPayee);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitPayee;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefitPayees[index : Integer] : TFhirExplanationOfBenefitPayee read GetItemN write SetItemN; default;
  End;

  // The members of the team who provided the products and services.
  TFhirExplanationOfBenefitCareTeam = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FProvider : TFhirReference{TFhirPractitioner};
    FResponsible : TFhirBoolean;
    FRole : TFhirCodeableConcept;
    FQualification : TFhirCodeableConcept;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetResponsible(value : TFhirBoolean);
    Function GetResponsibleST : Boolean;
    Procedure SetResponsibleST(value : Boolean);
    Procedure SetRole(value : TFhirCodeableConcept);
    Procedure SetQualification(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitCareTeam; overload;
    function Clone : TFhirExplanationOfBenefitCareTeam; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number to uniquely identify care team entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify care team entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to Member of the team who provided the product or service. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // Member of the team who provided the product or service.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to The party who is billing and/or responsible for the claimed products or services.
    property responsible : Boolean read GetResponsibleST write SetResponsibleST;
    // The party who is billing and/or responsible for the claimed products or services.
    property responsibleElement : TFhirBoolean read FResponsible write SetResponsible;

    // Typed access to The lead, assisting or supervising practitioner and their discipline if a multidisciplinary team. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // The lead, assisting or supervising practitioner and their discipline if a multidisciplinary team.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The qualification of the practitioner which is applicable for this service. (defined for API consistency)
    property qualification : TFhirCodeableConcept read FQualification write SetQualification;
    // The qualification of the practitioner which is applicable for this service.
    property qualificationElement : TFhirCodeableConcept read FQualification write SetQualification;

  end;

  TFhirExplanationOfBenefitCareTeamListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitCareTeamList;
    function GetCurrent : TFhirExplanationOfBenefitCareTeam;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitCareTeamList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitCareTeam read GetCurrent;
  end;

  TFhirExplanationOfBenefitCareTeamList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitCareTeam;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitCareTeam);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitCareTeamList; Overload;
    function Clone : TFhirExplanationOfBenefitCareTeamList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitCareTeamListEnumerator;
    

    //  Add a FhirExplanationOfBenefitCareTeam to the end of the list.
    function Append : TFhirExplanationOfBenefitCareTeam;

    
    // Add an already existing FhirExplanationOfBenefitCareTeam to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitCareTeam); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitCareTeam) : Integer;
    

    // Insert FhirExplanationOfBenefitCareTeam before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitCareTeam;
    

    // Insert an existing FhirExplanationOfBenefitCareTeam before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitCareTeam);
    
    // Get the iIndexth FhirExplanationOfBenefitCareTeam. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitCareTeam);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitCareTeam;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefitCareTeams[index : Integer] : TFhirExplanationOfBenefitCareTeam read GetItemN write SetItemN; default;
  End;

  // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
  TFhirExplanationOfBenefitSupportingInfo = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FCategory : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FTiming : TFhirType;
    FValue : TFhirType;
    FReason : TFhirCoding;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetTiming(value : TFhirType);
    Procedure SetValue(value : TFhirType);
    Procedure SetReason(value : TFhirCoding);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitSupportingInfo; overload;
    function Clone : TFhirExplanationOfBenefitSupportingInfo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number to uniquely identify supporting information entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify supporting information entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The general class of the information supplied: information; exception; accident, employment; onset, etc. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // The general class of the information supplied: information; exception; accident, employment; onset, etc.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to System and code pertaining to the specific information regarding special conditions relating to the setting, treatment or patient  for which care is sought. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // System and code pertaining to the specific information regarding special conditions relating to the setting, treatment or patient  for which care is sought.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The date when or period to which this information refers. (defined for API consistency)
    property timing : TFhirType read FTiming write SetTiming;
    // The date when or period to which this information refers.
    property timingElement : TFhirType read FTiming write SetTiming;

    // Typed access to Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
    property valueElement : TFhirType read FValue write SetValue;

    // Typed access to Provides the reason in the situation where a reason code is required in addition to the content. (defined for API consistency)
    property reason : TFhirCoding read FReason write SetReason;
    // Provides the reason in the situation where a reason code is required in addition to the content.
    property reasonElement : TFhirCoding read FReason write SetReason;

  end;

  TFhirExplanationOfBenefitSupportingInfoListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitSupportingInfoList;
    function GetCurrent : TFhirExplanationOfBenefitSupportingInfo;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitSupportingInfoList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitSupportingInfo read GetCurrent;
  end;

  TFhirExplanationOfBenefitSupportingInfoList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitSupportingInfo;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitSupportingInfo);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitSupportingInfoList; Overload;
    function Clone : TFhirExplanationOfBenefitSupportingInfoList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitSupportingInfoListEnumerator;
    

    //  Add a FhirExplanationOfBenefitSupportingInfo to the end of the list.
    function Append : TFhirExplanationOfBenefitSupportingInfo;

    
    // Add an already existing FhirExplanationOfBenefitSupportingInfo to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitSupportingInfo); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitSupportingInfo) : Integer;
    

    // Insert FhirExplanationOfBenefitSupportingInfo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitSupportingInfo;
    

    // Insert an existing FhirExplanationOfBenefitSupportingInfo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitSupportingInfo);
    
    // Get the iIndexth FhirExplanationOfBenefitSupportingInfo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitSupportingInfo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitSupportingInfo;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefitSupportingInfos[index : Integer] : TFhirExplanationOfBenefitSupportingInfo read GetItemN write SetItemN; default;
  End;

  // Information about diagnoses relevant to the claim items.
  TFhirExplanationOfBenefitDiagnosis = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FDiagnosis : TFhirType;
    Ftype_List : TFhirCodeableConceptList;
    FOnAdmission : TFhirCodeableConcept;
    FPackageCode : TFhirCodeableConcept;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetDiagnosis(value : TFhirType);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    Procedure SetOnAdmission(value : TFhirCodeableConcept);
    Procedure SetPackageCode(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitDiagnosis; overload;
    function Clone : TFhirExplanationOfBenefitDiagnosis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number to uniquely identify diagnosis entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify diagnosis entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The nature of illness or problem in a coded form or as a reference to an external defined Condition. (defined for API consistency)
    property diagnosis : TFhirType read FDiagnosis write SetDiagnosis;
    // The nature of illness or problem in a coded form or as a reference to an external defined Condition.
    property diagnosisElement : TFhirType read FDiagnosis write SetDiagnosis;

    // When the condition was observed or the relative ranking.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to Indication of whether the diagnosis was present on admission to a facility. (defined for API consistency)
    property onAdmission : TFhirCodeableConcept read FOnAdmission write SetOnAdmission;
    // Indication of whether the diagnosis was present on admission to a facility.
    property onAdmissionElement : TFhirCodeableConcept read FOnAdmission write SetOnAdmission;

    // Typed access to A package billing code or bundle code used to group products and services to a particular health condition (such as heart attack) which is based on a predetermined grouping code system. (defined for API consistency)
    property packageCode : TFhirCodeableConcept read FPackageCode write SetPackageCode;
    // A package billing code or bundle code used to group products and services to a particular health condition (such as heart attack) which is based on a predetermined grouping code system.
    property packageCodeElement : TFhirCodeableConcept read FPackageCode write SetPackageCode;

  end;

  TFhirExplanationOfBenefitDiagnosisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitDiagnosisList;
    function GetCurrent : TFhirExplanationOfBenefitDiagnosis;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitDiagnosisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitDiagnosis read GetCurrent;
  end;

  TFhirExplanationOfBenefitDiagnosisList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitDiagnosis;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitDiagnosis);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitDiagnosisList; Overload;
    function Clone : TFhirExplanationOfBenefitDiagnosisList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitDiagnosisListEnumerator;
    

    //  Add a FhirExplanationOfBenefitDiagnosis to the end of the list.
    function Append : TFhirExplanationOfBenefitDiagnosis;

    
    // Add an already existing FhirExplanationOfBenefitDiagnosis to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitDiagnosis); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitDiagnosis) : Integer;
    

    // Insert FhirExplanationOfBenefitDiagnosis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitDiagnosis;
    

    // Insert an existing FhirExplanationOfBenefitDiagnosis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitDiagnosis);
    
    // Get the iIndexth FhirExplanationOfBenefitDiagnosis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitDiagnosis);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitDiagnosis;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefitDiagnoses[index : Integer] : TFhirExplanationOfBenefitDiagnosis read GetItemN write SetItemN; default;
  End;

  // Procedures performed on the patient relevant to the billing items with the claim.
  TFhirExplanationOfBenefitProcedure = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    Ftype_List : TFhirCodeableConceptList;
    FDate : TFhirDateTime;
    FProcedure_ : TFhirType;
    FudiList : TFhirReferenceList{TFhirDevice};
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetProcedure_(value : TFhirType);
    function GetUdiList : TFhirReferenceList{TFhirDevice};
    function GetHasUdiList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitProcedure; overload;
    function Clone : TFhirExplanationOfBenefitProcedure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number to uniquely identify procedure entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify procedure entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // When the condition was observed or the relative ranking.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to Date and optionally time the procedure was performed.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date and optionally time the procedure was performed.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The code or reference to a Procedure resource which identifies the clinical intervention performed. (defined for API consistency)
    property procedure_ : TFhirType read FProcedure_ write SetProcedure_;
    // The code or reference to a Procedure resource which identifies the clinical intervention performed.
    property procedure_Element : TFhirType read FProcedure_ write SetProcedure_;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList{TFhirDevice} read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

  end;

  TFhirExplanationOfBenefitProcedureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitProcedureList;
    function GetCurrent : TFhirExplanationOfBenefitProcedure;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitProcedureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitProcedure read GetCurrent;
  end;

  TFhirExplanationOfBenefitProcedureList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitProcedure;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitProcedure);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitProcedureList; Overload;
    function Clone : TFhirExplanationOfBenefitProcedureList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitProcedureListEnumerator;
    

    //  Add a FhirExplanationOfBenefitProcedure to the end of the list.
    function Append : TFhirExplanationOfBenefitProcedure;

    
    // Add an already existing FhirExplanationOfBenefitProcedure to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitProcedure); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitProcedure) : Integer;
    

    // Insert FhirExplanationOfBenefitProcedure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitProcedure;
    

    // Insert an existing FhirExplanationOfBenefitProcedure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitProcedure);
    
    // Get the iIndexth FhirExplanationOfBenefitProcedure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitProcedure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitProcedure;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefitProcedures[index : Integer] : TFhirExplanationOfBenefitProcedure read GetItemN write SetItemN; default;
  End;

  // Financial instruments for reimbursement for the health care products and services specified on the claim.
  TFhirExplanationOfBenefitInsurance = class (TFhirBackboneElement)
  protected
    FFocal : TFhirBoolean;
    FCoverage : TFhirReference{TFhirCoverage};
    FpreAuthRefList : TFhirStringList;
    Procedure SetFocal(value : TFhirBoolean);
    Function GetFocalST : Boolean;
    Procedure SetFocalST(value : Boolean);
    Procedure SetCoverage(value : TFhirReference{TFhirCoverage});
    function GetPreAuthRefList : TFhirStringList;
    function GetHasPreAuthRefList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitInsurance; overload;
    function Clone : TFhirExplanationOfBenefitInsurance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true.
    property focal : Boolean read GetFocalST write SetFocalST;
    // A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true.
    property focalElement : TFhirBoolean read FFocal write SetFocal;

    // Typed access to Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system. (defined for API consistency)
    property coverage : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;
    // Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system.
    property coverageElement : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;

    // Reference numbers previously provided by the insurer to the provider to be quoted on subsequent claims containing services or products related to the prior authorization.
    property preAuthRefList : TFhirStringList read GetPreAuthRefList;
    property hasPreAuthRefList : boolean read GetHasPreAuthRefList;

  end;

  TFhirExplanationOfBenefitInsuranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitInsuranceList;
    function GetCurrent : TFhirExplanationOfBenefitInsurance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitInsuranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitInsurance read GetCurrent;
  end;

  TFhirExplanationOfBenefitInsuranceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitInsurance;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitInsurance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitInsuranceList; Overload;
    function Clone : TFhirExplanationOfBenefitInsuranceList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitInsuranceListEnumerator;
    

    //  Add a FhirExplanationOfBenefitInsurance to the end of the list.
    function Append : TFhirExplanationOfBenefitInsurance;

    
    // Add an already existing FhirExplanationOfBenefitInsurance to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitInsurance); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitInsurance) : Integer;
    

    // Insert FhirExplanationOfBenefitInsurance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitInsurance;
    

    // Insert an existing FhirExplanationOfBenefitInsurance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitInsurance);
    
    // Get the iIndexth FhirExplanationOfBenefitInsurance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitInsurance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitInsurance;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefitInsurances[index : Integer] : TFhirExplanationOfBenefitInsurance read GetItemN write SetItemN; default;
  End;

  // Details of a accident which resulted in injuries which required the products and services listed in the claim.
  TFhirExplanationOfBenefitAccident = class (TFhirBackboneElement)
  protected
    FDate : TFhirDate;
    FType_ : TFhirCodeableConcept;
    FLocation : TFhirType;
    Procedure SetDate(value : TFhirDate);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetLocation(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitAccident; overload;
    function Clone : TFhirExplanationOfBenefitAccident; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Date of an accident event  related to the products and services contained in the claim.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date of an accident event  related to the products and services contained in the claim.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to The type or context of the accident event for the purposes of selection of potential insurance coverages and determination of coordination between insurers. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type or context of the accident event for the purposes of selection of potential insurance coverages and determination of coordination between insurers.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The physical location of the accident event. (defined for API consistency)
    property location : TFhirType read FLocation write SetLocation;
    // The physical location of the accident event.
    property locationElement : TFhirType read FLocation write SetLocation;

  end;

  TFhirExplanationOfBenefitAccidentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitAccidentList;
    function GetCurrent : TFhirExplanationOfBenefitAccident;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitAccidentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitAccident read GetCurrent;
  end;

  TFhirExplanationOfBenefitAccidentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitAccident;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitAccident);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitAccidentList; Overload;
    function Clone : TFhirExplanationOfBenefitAccidentList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitAccidentListEnumerator;
    

    //  Add a FhirExplanationOfBenefitAccident to the end of the list.
    function Append : TFhirExplanationOfBenefitAccident;

    
    // Add an already existing FhirExplanationOfBenefitAccident to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitAccident); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitAccident) : Integer;
    

    // Insert FhirExplanationOfBenefitAccident before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitAccident;
    

    // Insert an existing FhirExplanationOfBenefitAccident before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitAccident);
    
    // Get the iIndexth FhirExplanationOfBenefitAccident. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitAccident);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitAccident;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefitAccidents[index : Integer] : TFhirExplanationOfBenefitAccident read GetItemN write SetItemN; default;
  End;

  // A claim line. Either a simple (a product or service) or a 'group' of details which can also be a simple items or groups of sub-details.
  TFhirExplanationOfBenefitItem = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FcareTeamSequenceList : TFhirPositiveIntList;
    FdiagnosisSequenceList : TFhirPositiveIntList;
    FprocedureSequenceList : TFhirPositiveIntList;
    FinformationSequenceList : TFhirPositiveIntList;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FServiced : TFhirType;
    FLocation : TFhirType;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList{TFhirDevice};
    FBodySite : TFhirCodeableConcept;
    FsubSiteList : TFhirCodeableConceptList;
    FencounterList : TFhirReferenceList{TFhirEncounter};
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    FdetailList : TFhirExplanationOfBenefitItemDetailList;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    function GetCareTeamSequenceList : TFhirPositiveIntList;
    function GetHasCareTeamSequenceList : Boolean;
    function GetDiagnosisSequenceList : TFhirPositiveIntList;
    function GetHasDiagnosisSequenceList : Boolean;
    function GetProcedureSequenceList : TFhirPositiveIntList;
    function GetHasProcedureSequenceList : Boolean;
    function GetInformationSequenceList : TFhirPositiveIntList;
    function GetHasInformationSequenceList : Boolean;
    Procedure SetRevenue(value : TFhirCodeableConcept);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    Procedure SetServiced(value : TFhirType);
    Procedure SetLocation(value : TFhirType);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList{TFhirDevice};
    function GetHasUdiList : Boolean;
    Procedure SetBodySite(value : TFhirCodeableConcept);
    function GetSubSiteList : TFhirCodeableConceptList;
    function GetHasSubSiteList : Boolean;
    function GetEncounterList : TFhirReferenceList{TFhirEncounter};
    function GetHasEncounterList : Boolean;
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetDetailList : TFhirExplanationOfBenefitItemDetailList;
    function GetHasDetailList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitItem; overload;
    function Clone : TFhirExplanationOfBenefitItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number to uniquely identify item entries.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A number to uniquely identify item entries.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Care team members related to this service or product.
    property careTeamSequenceList : TFhirPositiveIntList read GetCareTeamSequenceList;
    property hasCareTeamSequenceList : boolean read GetHasCareTeamSequenceList;

    // Diagnoses applicable for this service or product.
    property diagnosisSequenceList : TFhirPositiveIntList read GetDiagnosisSequenceList;
    property hasDiagnosisSequenceList : boolean read GetHasDiagnosisSequenceList;

    // Procedures applicable for this service or product.
    property procedureSequenceList : TFhirPositiveIntList read GetProcedureSequenceList;
    property hasProcedureSequenceList : boolean read GetHasProcedureSequenceList;

    // Exceptions, special conditions and supporting information applicable for this service or product.
    property informationSequenceList : TFhirPositiveIntList read GetInformationSequenceList;
    property hasInformationSequenceList : boolean read GetHasInformationSequenceList;

    // Typed access to The type of revenue or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of revenue or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The date or dates when the service or product was supplied, performed or completed. (defined for API consistency)
    property serviced : TFhirType read FServiced write SetServiced;
    // The date or dates when the service or product was supplied, performed or completed.
    property servicedElement : TFhirType read FServiced write SetServiced;

    // Typed access to Where the product or service was provided. (defined for API consistency)
    property location : TFhirType read FLocation write SetLocation;
    // Where the product or service was provided.
    property locationElement : TFhirType read FLocation write SetLocation;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList{TFhirDevice} read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

    // Typed access to Physical service site on the patient (limb, tooth, etc.). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Physical service site on the patient (limb, tooth, etc.).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // A region or surface of the bodySite, e.g. limb region or tooth surface(s).
    property subSiteList : TFhirCodeableConceptList read GetSubSiteList;
    property hasSubSiteList : boolean read GetHasSubSiteList;

    // A billed item may include goods or services provided in multiple encounters.
    property encounterList : TFhirReferenceList{TFhirEncounter} read GetEncounterList;
    property hasEncounterList : boolean read GetHasEncounterList;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // If this item is a group then the values here are a summary of the adjudication of the detail items. If this item is a simple product or service then this is the result of the adjudication of this item.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // Second-tier of goods and services.
    property detailList : TFhirExplanationOfBenefitItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirExplanationOfBenefitItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitItemList;
    function GetCurrent : TFhirExplanationOfBenefitItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitItem read GetCurrent;
  end;

  TFhirExplanationOfBenefitItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitItem;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitItemList; Overload;
    function Clone : TFhirExplanationOfBenefitItemList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitItemListEnumerator;
    

    //  Add a FhirExplanationOfBenefitItem to the end of the list.
    function Append : TFhirExplanationOfBenefitItem;

    
    // Add an already existing FhirExplanationOfBenefitItem to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitItem); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitItem) : Integer;
    

    // Insert FhirExplanationOfBenefitItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitItem;
    

    // Insert an existing FhirExplanationOfBenefitItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitItem);
    
    // Get the iIndexth FhirExplanationOfBenefitItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitItem;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefitItems[index : Integer] : TFhirExplanationOfBenefitItem read GetItemN write SetItemN; default;
  End;

  // If this item is a group then the values here are a summary of the adjudication of the detail items. If this item is a simple product or service then this is the result of the adjudication of this item.
  TFhirExplanationOfBenefitItemAdjudication = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FReason : TFhirCodeableConcept;
    FAmount : TFhirMoney;
    FValue : TFhirDecimal;
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetReason(value : TFhirCodeableConcept);
    Procedure SetAmount(value : TFhirMoney);
    Procedure SetValue(value : TFhirDecimal);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitItemAdjudication; overload;
    function Clone : TFhirExplanationOfBenefitItemAdjudication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A code to indicate the information type of this adjudication record. Information types may include: the value submitted, maximum values or percentages allowed or payable under the plan, amounts that the patient is responsible for in-aggregate or pertaining to this item, amounts paid by other coverages, and the benefit payable for this item. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A code to indicate the information type of this adjudication record. Information types may include: the value submitted, maximum values or percentages allowed or payable under the plan, amounts that the patient is responsible for in-aggregate or pertaining to this item, amounts paid by other coverages, and the benefit payable for this item.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to A code supporting the understanding of the adjudication result and explaining variance from expected amount. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // A code supporting the understanding of the adjudication result and explaining variance from expected amount.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

    // Typed access to Monetary amount associated with the category. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Monetary amount associated with the category.
    property amountElement : TFhirMoney read FAmount write SetAmount;

    // Typed access to A non-monetary value associated with the category. Mutually exclusive to the amount element above.
    property value : String read GetValueST write SetValueST;
    // A non-monetary value associated with the category. Mutually exclusive to the amount element above.
    property valueElement : TFhirDecimal read FValue write SetValue;

  end;

  TFhirExplanationOfBenefitItemAdjudicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetCurrent : TFhirExplanationOfBenefitItemAdjudication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitItemAdjudicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitItemAdjudication read GetCurrent;
  end;

  TFhirExplanationOfBenefitItemAdjudicationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitItemAdjudication;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitItemAdjudication);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitItemAdjudicationList; Overload;
    function Clone : TFhirExplanationOfBenefitItemAdjudicationList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitItemAdjudicationListEnumerator;
    

    //  Add a FhirExplanationOfBenefitItemAdjudication to the end of the list.
    function Append : TFhirExplanationOfBenefitItemAdjudication;

    
    // Add an already existing FhirExplanationOfBenefitItemAdjudication to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitItemAdjudication); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitItemAdjudication) : Integer;
    

    // Insert FhirExplanationOfBenefitItemAdjudication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitItemAdjudication;
    

    // Insert an existing FhirExplanationOfBenefitItemAdjudication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitItemAdjudication);
    
    // Get the iIndexth FhirExplanationOfBenefitItemAdjudication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitItemAdjudication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitItemAdjudication;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefitItemAdjudications[index : Integer] : TFhirExplanationOfBenefitItemAdjudication read GetItemN write SetItemN; default;
  End;

  // Second-tier of goods and services.
  TFhirExplanationOfBenefitItemDetail = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList{TFhirDevice};
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    FsubDetailList : TFhirExplanationOfBenefitItemDetailSubDetailList;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetRevenue(value : TFhirCodeableConcept);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList{TFhirDevice};
    function GetHasUdiList : Boolean;
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetSubDetailList : TFhirExplanationOfBenefitItemDetailSubDetailList;
    function GetHasSubDetailList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitItemDetail; overload;
    function Clone : TFhirExplanationOfBenefitItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The type of revenue or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of revenue or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList{TFhirDevice} read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // Third-tier of goods and services.
    property subDetailList : TFhirExplanationOfBenefitItemDetailSubDetailList read GetSubDetailList;
    property hasSubDetailList : boolean read GetHasSubDetailList;

  end;

  TFhirExplanationOfBenefitItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitItemDetailList;
    function GetCurrent : TFhirExplanationOfBenefitItemDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitItemDetail read GetCurrent;
  end;

  TFhirExplanationOfBenefitItemDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitItemDetail;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitItemDetailList; Overload;
    function Clone : TFhirExplanationOfBenefitItemDetailList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitItemDetailListEnumerator;
    

    //  Add a FhirExplanationOfBenefitItemDetail to the end of the list.
    function Append : TFhirExplanationOfBenefitItemDetail;

    
    // Add an already existing FhirExplanationOfBenefitItemDetail to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitItemDetail); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitItemDetail) : Integer;
    

    // Insert FhirExplanationOfBenefitItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitItemDetail;
    

    // Insert an existing FhirExplanationOfBenefitItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitItemDetail);
    
    // Get the iIndexth FhirExplanationOfBenefitItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitItemDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitItemDetail;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefitItemDetails[index : Integer] : TFhirExplanationOfBenefitItemDetail read GetItemN write SetItemN; default;
  End;

  // Third-tier of goods and services.
  TFhirExplanationOfBenefitItemDetailSubDetail = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FRevenue : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FudiList : TFhirReferenceList{TFhirDevice};
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetRevenue(value : TFhirCodeableConcept);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetNet(value : TFhirMoney);
    function GetUdiList : TFhirReferenceList{TFhirDevice};
    function GetHasUdiList : Boolean;
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitItemDetailSubDetail; overload;
    function Clone : TFhirExplanationOfBenefitItemDetailSubDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property sequence : String read GetSequenceST write SetSequenceST;
    // A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The type of revenue or cost center providing the product and/or service. (defined for API consistency)
    property revenue : TFhirCodeableConcept read FRevenue write SetRevenue;
    // The type of revenue or cost center providing the product and/or service.
    property revenueElement : TFhirCodeableConcept read FRevenue write SetRevenue;

    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Unique Device Identifiers associated with this line item.
    property udiList : TFhirReferenceList{TFhirDevice} read GetUdiList;
    property hasUdiList : boolean read GetHasUdiList;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

  end;

  TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitItemDetailSubDetailList;
    function GetCurrent : TFhirExplanationOfBenefitItemDetailSubDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitItemDetailSubDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitItemDetailSubDetail read GetCurrent;
  end;

  TFhirExplanationOfBenefitItemDetailSubDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitItemDetailSubDetail;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitItemDetailSubDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitItemDetailSubDetailList; Overload;
    function Clone : TFhirExplanationOfBenefitItemDetailSubDetailList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator;
    

    //  Add a FhirExplanationOfBenefitItemDetailSubDetail to the end of the list.
    function Append : TFhirExplanationOfBenefitItemDetailSubDetail;

    
    // Add an already existing FhirExplanationOfBenefitItemDetailSubDetail to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitItemDetailSubDetail); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitItemDetailSubDetail) : Integer;
    

    // Insert FhirExplanationOfBenefitItemDetailSubDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitItemDetailSubDetail;
    

    // Insert an existing FhirExplanationOfBenefitItemDetailSubDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitItemDetailSubDetail);
    
    // Get the iIndexth FhirExplanationOfBenefitItemDetailSubDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitItemDetailSubDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitItemDetailSubDetail;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefitItemDetailSubDetails[index : Integer] : TFhirExplanationOfBenefitItemDetailSubDetail read GetItemN write SetItemN; default;
  End;

  // The first-tier service adjudications for payor added product or service lines.
  TFhirExplanationOfBenefitAddItem = class (TFhirBackboneElement)
  protected
    FitemSequenceList : TFhirPositiveIntList;
    FdetailSequenceList : TFhirPositiveIntList;
    FsubDetailSequenceList : TFhirPositiveIntList;
    FproviderList : TFhirReferenceList{TFhirPractitioner};
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FprogramCodeList : TFhirCodeableConceptList;
    FServiced : TFhirType;
    FLocation : TFhirType;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FBodySite : TFhirCodeableConcept;
    FsubSiteList : TFhirCodeableConceptList;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    FdetailList : TFhirExplanationOfBenefitAddItemDetailList;
    function GetItemSequenceList : TFhirPositiveIntList;
    function GetHasItemSequenceList : Boolean;
    function GetDetailSequenceList : TFhirPositiveIntList;
    function GetHasDetailSequenceList : Boolean;
    function GetSubDetailSequenceList : TFhirPositiveIntList;
    function GetHasSubDetailSequenceList : Boolean;
    function GetProviderList : TFhirReferenceList{TFhirPractitioner};
    function GetHasProviderList : Boolean;
    Procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    function GetProgramCodeList : TFhirCodeableConceptList;
    function GetHasProgramCodeList : Boolean;
    Procedure SetServiced(value : TFhirType);
    Procedure SetLocation(value : TFhirType);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetNet(value : TFhirMoney);
    Procedure SetBodySite(value : TFhirCodeableConcept);
    function GetSubSiteList : TFhirCodeableConceptList;
    function GetHasSubSiteList : Boolean;
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetDetailList : TFhirExplanationOfBenefitAddItemDetailList;
    function GetHasDetailList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitAddItem; overload;
    function Clone : TFhirExplanationOfBenefitAddItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Claim items which this service line is intended to replace.
    property itemSequenceList : TFhirPositiveIntList read GetItemSequenceList;
    property hasItemSequenceList : boolean read GetHasItemSequenceList;

    // The sequence number of the details within the claim item which this line is intended to replace.
    property detailSequenceList : TFhirPositiveIntList read GetDetailSequenceList;
    property hasDetailSequenceList : boolean read GetHasDetailSequenceList;

    // The sequence number of the sub-details woithin the details within the claim item which this line is intended to replace.
    property subDetailSequenceList : TFhirPositiveIntList read GetSubDetailSequenceList;
    property hasSubDetailSequenceList : boolean read GetHasSubDetailSequenceList;

    // The providers who are authorized for the services rendered to the patient.
    property providerList : TFhirReferenceList{TFhirPractitioner} read GetProviderList;
    property hasProviderList : boolean read GetHasProviderList;

    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Identifies the program under which this may be recovered.
    property programCodeList : TFhirCodeableConceptList read GetProgramCodeList;
    property hasProgramCodeList : boolean read GetHasProgramCodeList;

    // Typed access to The date or dates when the service or product was supplied, performed or completed. (defined for API consistency)
    property serviced : TFhirType read FServiced write SetServiced;
    // The date or dates when the service or product was supplied, performed or completed.
    property servicedElement : TFhirType read FServiced write SetServiced;

    // Typed access to Where the product or service was provided. (defined for API consistency)
    property location : TFhirType read FLocation write SetLocation;
    // Where the product or service was provided.
    property locationElement : TFhirType read FLocation write SetLocation;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // Typed access to Physical service site on the patient (limb, tooth, etc.). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Physical service site on the patient (limb, tooth, etc.).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // A region or surface of the bodySite, e.g. limb region or tooth surface(s).
    property subSiteList : TFhirCodeableConceptList read GetSubSiteList;
    property hasSubSiteList : boolean read GetHasSubSiteList;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // The second-tier service adjudications for payor added services.
    property detailList : TFhirExplanationOfBenefitAddItemDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirExplanationOfBenefitAddItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitAddItemList;
    function GetCurrent : TFhirExplanationOfBenefitAddItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitAddItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitAddItem read GetCurrent;
  end;

  TFhirExplanationOfBenefitAddItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitAddItem;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitAddItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitAddItemList; Overload;
    function Clone : TFhirExplanationOfBenefitAddItemList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitAddItemListEnumerator;
    

    //  Add a FhirExplanationOfBenefitAddItem to the end of the list.
    function Append : TFhirExplanationOfBenefitAddItem;

    
    // Add an already existing FhirExplanationOfBenefitAddItem to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitAddItem); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitAddItem) : Integer;
    

    // Insert FhirExplanationOfBenefitAddItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitAddItem;
    

    // Insert an existing FhirExplanationOfBenefitAddItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitAddItem);
    
    // Get the iIndexth FhirExplanationOfBenefitAddItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitAddItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitAddItem;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefitAddItems[index : Integer] : TFhirExplanationOfBenefitAddItem read GetItemN write SetItemN; default;
  End;

  // The second-tier service adjudications for payor added services.
  TFhirExplanationOfBenefitAddItemDetail = class (TFhirBackboneElement)
  protected
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    FsubDetailList : TFhirExplanationOfBenefitAddItemDetailSubDetailList;
    Procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetNet(value : TFhirMoney);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetSubDetailList : TFhirExplanationOfBenefitAddItemDetailSubDetailList;
    function GetHasSubDetailList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitAddItemDetail; overload;
    function Clone : TFhirExplanationOfBenefitAddItemDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // The third-tier service adjudications for payor added services.
    property subDetailList : TFhirExplanationOfBenefitAddItemDetailSubDetailList read GetSubDetailList;
    property hasSubDetailList : boolean read GetHasSubDetailList;

  end;

  TFhirExplanationOfBenefitAddItemDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitAddItemDetailList;
    function GetCurrent : TFhirExplanationOfBenefitAddItemDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitAddItemDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitAddItemDetail read GetCurrent;
  end;

  TFhirExplanationOfBenefitAddItemDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitAddItemDetail;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitAddItemDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitAddItemDetailList; Overload;
    function Clone : TFhirExplanationOfBenefitAddItemDetailList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitAddItemDetailListEnumerator;
    

    //  Add a FhirExplanationOfBenefitAddItemDetail to the end of the list.
    function Append : TFhirExplanationOfBenefitAddItemDetail;

    
    // Add an already existing FhirExplanationOfBenefitAddItemDetail to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitAddItemDetail); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitAddItemDetail) : Integer;
    

    // Insert FhirExplanationOfBenefitAddItemDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitAddItemDetail;
    

    // Insert an existing FhirExplanationOfBenefitAddItemDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitAddItemDetail);
    
    // Get the iIndexth FhirExplanationOfBenefitAddItemDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitAddItemDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitAddItemDetail;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefitAddItemDetails[index : Integer] : TFhirExplanationOfBenefitAddItemDetail read GetItemN write SetItemN; default;
  End;

  // The third-tier service adjudications for payor added services.
  TFhirExplanationOfBenefitAddItemDetailSubDetail = class (TFhirBackboneElement)
  protected
    FProductOrService : TFhirCodeableConcept;
    FmodifierList : TFhirCodeableConceptList;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FNet : TFhirMoney;
    FnoteNumberList : TFhirPositiveIntList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    Procedure SetProductOrService(value : TFhirCodeableConcept);
    function GetModifierList : TFhirCodeableConceptList;
    function GetHasModifierList : Boolean;
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetUnitPrice(value : TFhirMoney);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetNet(value : TFhirMoney);
    function GetNoteNumberList : TFhirPositiveIntList;
    function GetHasNoteNumberList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitAddItemDetailSubDetail; overload;
    function Clone : TFhirExplanationOfBenefitAddItemDetailSubDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item. (defined for API consistency)
    property productOrService : TFhirCodeableConcept read FProductOrService write SetProductOrService;
    // When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
    property productOrServiceElement : TFhirCodeableConcept read FProductOrService write SetProductOrService;

    // Item typification or modifiers codes to convey additional context for the product or service.
    property modifierList : TFhirCodeableConceptList read GetModifierList;
    property hasModifierList : boolean read GetHasModifierList;

    // Typed access to The number of repetitions of a service or product. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of repetitions of a service or product.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The quantity times the unit price for an additional service or product or charge. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // The quantity times the unit price for an additional service or product or charge.
    property netElement : TFhirMoney read FNet write SetNet;

    // The numbers associated with notes below which apply to the adjudication of this item.
    property noteNumberList : TFhirPositiveIntList read GetNoteNumberList;
    property hasNoteNumberList : boolean read GetHasNoteNumberList;

    // The adjudication results.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

  end;

  TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitAddItemDetailSubDetailList;
    function GetCurrent : TFhirExplanationOfBenefitAddItemDetailSubDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitAddItemDetailSubDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitAddItemDetailSubDetail read GetCurrent;
  end;

  TFhirExplanationOfBenefitAddItemDetailSubDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitAddItemDetailSubDetail;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitAddItemDetailSubDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitAddItemDetailSubDetailList; Overload;
    function Clone : TFhirExplanationOfBenefitAddItemDetailSubDetailList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator;
    

    //  Add a FhirExplanationOfBenefitAddItemDetailSubDetail to the end of the list.
    function Append : TFhirExplanationOfBenefitAddItemDetailSubDetail;

    
    // Add an already existing FhirExplanationOfBenefitAddItemDetailSubDetail to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitAddItemDetailSubDetail); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitAddItemDetailSubDetail) : Integer;
    

    // Insert FhirExplanationOfBenefitAddItemDetailSubDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitAddItemDetailSubDetail;
    

    // Insert an existing FhirExplanationOfBenefitAddItemDetailSubDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitAddItemDetailSubDetail);
    
    // Get the iIndexth FhirExplanationOfBenefitAddItemDetailSubDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitAddItemDetailSubDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitAddItemDetailSubDetail;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefitAddItemDetailSubDetails[index : Integer] : TFhirExplanationOfBenefitAddItemDetailSubDetail read GetItemN write SetItemN; default;
  End;

  // Categorized monetary totals for the adjudication.
  TFhirExplanationOfBenefitTotal = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FAmount : TFhirMoney;
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetAmount(value : TFhirMoney);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitTotal; overload;
    function Clone : TFhirExplanationOfBenefitTotal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A code to indicate the information type of this adjudication record. Information types may include: the value submitted, maximum values or percentages allowed or payable under the plan, amounts that the patient is responsible for in aggregate or pertaining to this item, amounts paid by other coverages, and the benefit payable for this item. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A code to indicate the information type of this adjudication record. Information types may include: the value submitted, maximum values or percentages allowed or payable under the plan, amounts that the patient is responsible for in aggregate or pertaining to this item, amounts paid by other coverages, and the benefit payable for this item.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Monetary total amount associated with the category. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Monetary total amount associated with the category.
    property amountElement : TFhirMoney read FAmount write SetAmount;

  end;

  TFhirExplanationOfBenefitTotalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitTotalList;
    function GetCurrent : TFhirExplanationOfBenefitTotal;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitTotalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitTotal read GetCurrent;
  end;

  TFhirExplanationOfBenefitTotalList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitTotal;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitTotal);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitTotalList; Overload;
    function Clone : TFhirExplanationOfBenefitTotalList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitTotalListEnumerator;
    

    //  Add a FhirExplanationOfBenefitTotal to the end of the list.
    function Append : TFhirExplanationOfBenefitTotal;

    
    // Add an already existing FhirExplanationOfBenefitTotal to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitTotal); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitTotal) : Integer;
    

    // Insert FhirExplanationOfBenefitTotal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitTotal;
    

    // Insert an existing FhirExplanationOfBenefitTotal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitTotal);
    
    // Get the iIndexth FhirExplanationOfBenefitTotal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitTotal);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitTotal;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefitTotals[index : Integer] : TFhirExplanationOfBenefitTotal read GetItemN write SetItemN; default;
  End;

  // Payment details for the adjudication of the claim.
  TFhirExplanationOfBenefitPayment = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAdjustment : TFhirMoney;
    FAdjustmentReason : TFhirCodeableConcept;
    FDate : TFhirDate;
    FAmount : TFhirMoney;
    FIdentifier : TFhirIdentifier;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetAdjustment(value : TFhirMoney);
    Procedure SetAdjustmentReason(value : TFhirCodeableConcept);
    Procedure SetDate(value : TFhirDate);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetAmount(value : TFhirMoney);
    Procedure SetIdentifier(value : TFhirIdentifier);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitPayment; overload;
    function Clone : TFhirExplanationOfBenefitPayment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Whether this represents partial or complete payment of the benefits payable. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Whether this represents partial or complete payment of the benefits payable.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Total amount of all adjustments to this payment included in this transaction which are not related to this claim's adjudication. (defined for API consistency)
    property adjustment : TFhirMoney read FAdjustment write SetAdjustment;
    // Total amount of all adjustments to this payment included in this transaction which are not related to this claim's adjudication.
    property adjustmentElement : TFhirMoney read FAdjustment write SetAdjustment;

    // Typed access to Reason for the payment adjustment. (defined for API consistency)
    property adjustmentReason : TFhirCodeableConcept read FAdjustmentReason write SetAdjustmentReason;
    // Reason for the payment adjustment.
    property adjustmentReasonElement : TFhirCodeableConcept read FAdjustmentReason write SetAdjustmentReason;

    // Typed access to Estimated date the payment will be issued or the actual issue date of payment.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Estimated date the payment will be issued or the actual issue date of payment.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to Benefits payable less any payment adjustment. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // Benefits payable less any payment adjustment.
    property amountElement : TFhirMoney read FAmount write SetAmount;

    // Typed access to Issuer's unique identifier for the payment instrument. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Issuer's unique identifier for the payment instrument.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

  end;

  TFhirExplanationOfBenefitPaymentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitPaymentList;
    function GetCurrent : TFhirExplanationOfBenefitPayment;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitPaymentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitPayment read GetCurrent;
  end;

  TFhirExplanationOfBenefitPaymentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitPayment;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitPayment);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitPaymentList; Overload;
    function Clone : TFhirExplanationOfBenefitPaymentList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitPaymentListEnumerator;
    

    //  Add a FhirExplanationOfBenefitPayment to the end of the list.
    function Append : TFhirExplanationOfBenefitPayment;

    
    // Add an already existing FhirExplanationOfBenefitPayment to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitPayment); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitPayment) : Integer;
    

    // Insert FhirExplanationOfBenefitPayment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitPayment;
    

    // Insert an existing FhirExplanationOfBenefitPayment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitPayment);
    
    // Get the iIndexth FhirExplanationOfBenefitPayment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitPayment);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitPayment;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefitPayments[index : Integer] : TFhirExplanationOfBenefitPayment read GetItemN write SetItemN; default;
  End;

  // A note that describes or explains adjudication results in a human readable form.
  TFhirExplanationOfBenefitProcessNote = class (TFhirBackboneElement)
  protected
    FNumber : TFhirPositiveInt;
    FType_ : TFhirEnum;
    FText : TFhirString;
    FLanguage : TFhirCodeableConcept;
    Procedure SetNumber(value : TFhirPositiveInt);
    Function GetNumberST : String;
    Procedure SetNumberST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirNoteTypeEnum;
    Procedure SetType_ST(value : TFhirNoteTypeEnum);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetLanguage(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitProcessNote; overload;
    function Clone : TFhirExplanationOfBenefitProcessNote; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A number to uniquely identify a note entry.
    property number : String read GetNumberST write SetNumberST;
    // A number to uniquely identify a note entry.
    property numberElement : TFhirPositiveInt read FNumber write SetNumber;

    // The business purpose of the note text.
    property type_ : TFhirNoteTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The explanation or description associated with the processing.
    property text : String read GetTextST write SetTextST;
    // The explanation or description associated with the processing.
    property textElement : TFhirString read FText write SetText;

    // Typed access to A code to define the language used in the text of the note. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // A code to define the language used in the text of the note.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

  end;

  TFhirExplanationOfBenefitProcessNoteListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitProcessNoteList;
    function GetCurrent : TFhirExplanationOfBenefitProcessNote;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitProcessNoteList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitProcessNote read GetCurrent;
  end;

  TFhirExplanationOfBenefitProcessNoteList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitProcessNote;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitProcessNote);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitProcessNoteList; Overload;
    function Clone : TFhirExplanationOfBenefitProcessNoteList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitProcessNoteListEnumerator;
    

    //  Add a FhirExplanationOfBenefitProcessNote to the end of the list.
    function Append : TFhirExplanationOfBenefitProcessNote;

    
    // Add an already existing FhirExplanationOfBenefitProcessNote to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitProcessNote); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitProcessNote) : Integer;
    

    // Insert FhirExplanationOfBenefitProcessNote before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitProcessNote;
    

    // Insert an existing FhirExplanationOfBenefitProcessNote before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitProcessNote);
    
    // Get the iIndexth FhirExplanationOfBenefitProcessNote. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitProcessNote);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitProcessNote;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefitProcessNotes[index : Integer] : TFhirExplanationOfBenefitProcessNote read GetItemN write SetItemN; default;
  End;

  // Balance by Benefit Category.
  TFhirExplanationOfBenefitBenefitBalance = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FExcluded : TFhirBoolean;
    FName : TFhirString;
    FDescription : TFhirString;
    FNetwork : TFhirCodeableConcept;
    FUnit_ : TFhirCodeableConcept;
    FTerm : TFhirCodeableConcept;
    FfinancialList : TFhirExplanationOfBenefitBenefitBalanceFinancialList;
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetExcluded(value : TFhirBoolean);
    Function GetExcludedST : Boolean;
    Procedure SetExcludedST(value : Boolean);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetNetwork(value : TFhirCodeableConcept);
    Procedure SetUnit_(value : TFhirCodeableConcept);
    Procedure SetTerm(value : TFhirCodeableConcept);
    function GetFinancialList : TFhirExplanationOfBenefitBenefitBalanceFinancialList;
    function GetHasFinancialList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitBenefitBalance; overload;
    function Clone : TFhirExplanationOfBenefitBenefitBalance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Code to identify the general type of benefits under which products and services are provided. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Code to identify the general type of benefits under which products and services are provided.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to True if the indicated class of service is excluded from the plan, missing or False indicates the product or service is included in the coverage.
    property excluded : Boolean read GetExcludedST write SetExcludedST;
    // True if the indicated class of service is excluded from the plan, missing or False indicates the product or service is included in the coverage.
    property excludedElement : TFhirBoolean read FExcluded write SetExcluded;

    // Typed access to A short name or tag for the benefit.
    property name : String read GetNameST write SetNameST;
    // A short name or tag for the benefit.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A richer description of the benefit or services covered.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A richer description of the benefit or services covered.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Is a flag to indicate whether the benefits refer to in-network providers or out-of-network providers. (defined for API consistency)
    property network : TFhirCodeableConcept read FNetwork write SetNetwork;
    // Is a flag to indicate whether the benefits refer to in-network providers or out-of-network providers.
    property networkElement : TFhirCodeableConcept read FNetwork write SetNetwork;

    // Typed access to Indicates if the benefits apply to an individual or to the family. (defined for API consistency)
    property unit_ : TFhirCodeableConcept read FUnit_ write SetUnit_;
    // Indicates if the benefits apply to an individual or to the family.
    property unit_Element : TFhirCodeableConcept read FUnit_ write SetUnit_;

    // Typed access to The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual visits'. (defined for API consistency)
    property term : TFhirCodeableConcept read FTerm write SetTerm;
    // The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual visits'.
    property termElement : TFhirCodeableConcept read FTerm write SetTerm;

    // Benefits Used to date.
    property financialList : TFhirExplanationOfBenefitBenefitBalanceFinancialList read GetFinancialList;
    property hasFinancialList : boolean read GetHasFinancialList;

  end;

  TFhirExplanationOfBenefitBenefitBalanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitBenefitBalanceList;
    function GetCurrent : TFhirExplanationOfBenefitBenefitBalance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitBenefitBalanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitBenefitBalance read GetCurrent;
  end;

  TFhirExplanationOfBenefitBenefitBalanceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitBenefitBalance;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitBenefitBalance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitBenefitBalanceList; Overload;
    function Clone : TFhirExplanationOfBenefitBenefitBalanceList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitBenefitBalanceListEnumerator;
    

    //  Add a FhirExplanationOfBenefitBenefitBalance to the end of the list.
    function Append : TFhirExplanationOfBenefitBenefitBalance;

    
    // Add an already existing FhirExplanationOfBenefitBenefitBalance to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitBenefitBalance); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitBenefitBalance) : Integer;
    

    // Insert FhirExplanationOfBenefitBenefitBalance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitBenefitBalance;
    

    // Insert an existing FhirExplanationOfBenefitBenefitBalance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitBenefitBalance);
    
    // Get the iIndexth FhirExplanationOfBenefitBenefitBalance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitBenefitBalance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitBenefitBalance;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefitBenefitBalances[index : Integer] : TFhirExplanationOfBenefitBenefitBalance read GetItemN write SetItemN; default;
  End;

  // Benefits Used to date.
  TFhirExplanationOfBenefitBenefitBalanceFinancial = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAllowed : TFhirType;
    FUsed : TFhirType;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetAllowed(value : TFhirType);
    Procedure SetUsed(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefitBenefitBalanceFinancial; overload;
    function Clone : TFhirExplanationOfBenefitBenefitBalanceFinancial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Classification of benefit being provided. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Classification of benefit being provided.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The quantity of the benefit which is permitted under the coverage. (defined for API consistency)
    property allowed : TFhirType read FAllowed write SetAllowed;
    // The quantity of the benefit which is permitted under the coverage.
    property allowedElement : TFhirType read FAllowed write SetAllowed;

    // Typed access to The quantity of the benefit which have been consumed to date. (defined for API consistency)
    property used : TFhirType read FUsed write SetUsed;
    // The quantity of the benefit which have been consumed to date.
    property usedElement : TFhirType read FUsed write SetUsed;

  end;

  TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitBenefitBalanceFinancialList;
    function GetCurrent : TFhirExplanationOfBenefitBenefitBalanceFinancial;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitBenefitBalanceFinancialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefitBenefitBalanceFinancial read GetCurrent;
  end;

  TFhirExplanationOfBenefitBenefitBalanceFinancialList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefitBenefitBalanceFinancial;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefitBenefitBalanceFinancial);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitBenefitBalanceFinancialList; Overload;
    function Clone : TFhirExplanationOfBenefitBenefitBalanceFinancialList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator;
    

    //  Add a FhirExplanationOfBenefitBenefitBalanceFinancial to the end of the list.
    function Append : TFhirExplanationOfBenefitBenefitBalanceFinancial;

    
    // Add an already existing FhirExplanationOfBenefitBenefitBalanceFinancial to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefitBenefitBalanceFinancial); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefitBenefitBalanceFinancial) : Integer;
    

    // Insert FhirExplanationOfBenefitBenefitBalanceFinancial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefitBenefitBalanceFinancial;
    

    // Insert an existing FhirExplanationOfBenefitBenefitBalanceFinancial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefitBenefitBalanceFinancial);
    
    // Get the iIndexth FhirExplanationOfBenefitBenefitBalanceFinancial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefitBenefitBalanceFinancial);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefitBenefitBalanceFinancial;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefitBenefitBalanceFinancials[index : Integer] : TFhirExplanationOfBenefitBenefitBalanceFinancial read GetItemN write SetItemN; default;
  End;

  // This resource provides: the claim details; adjudication details from the processing of a Claim; and optionally account balance information, for informing the subscriber of the benefits provided.
  TFhirExplanationOfBenefit = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FSubType : TFhirCodeableConcept;
    FUse : TFhirEnum;
    FPatient : TFhirReference{TFhirPatient};
    FBillablePeriod : TFhirPeriod;
    FCreated : TFhirDateTime;
    FEnterer : TFhirReference{TFhirPractitioner};
    FInsurer : TFhirReference{TFhirOrganization};
    FProvider : TFhirReference{TFhirPractitioner};
    FPriority : TFhirCodeableConcept;
    FFundsReserveRequested : TFhirCodeableConcept;
    FFundsReserve : TFhirCodeableConcept;
    FrelatedList : TFhirExplanationOfBenefitRelatedList;
    FPrescription : TFhirReference{TFhirMedicationRequest};
    FOriginalPrescription : TFhirReference{TFhirMedicationRequest};
    FPayee : TFhirExplanationOfBenefitPayee;
    FReferral : TFhirReference{TFhirServiceRequest};
    FFacility : TFhirReference{TFhirLocation};
    FClaim : TFhirReference{TFhirClaim};
    FClaimResponse : TFhirReference{TFhirClaimResponse};
    FOutcome : TFhirEnum;
    FDisposition : TFhirString;
    FpreAuthRefList : TFhirStringList;
    FpreAuthRefPeriodList : TFhirPeriodList;
    FcareTeamList : TFhirExplanationOfBenefitCareTeamList;
    FsupportingInfoList : TFhirExplanationOfBenefitSupportingInfoList;
    FdiagnosisList : TFhirExplanationOfBenefitDiagnosisList;
    Fprocedure_List : TFhirExplanationOfBenefitProcedureList;
    FPrecedence : TFhirPositiveInt;
    FinsuranceList : TFhirExplanationOfBenefitInsuranceList;
    FAccident : TFhirExplanationOfBenefitAccident;
    FitemList : TFhirExplanationOfBenefitItemList;
    FaddItemList : TFhirExplanationOfBenefitAddItemList;
    FadjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    FtotalList : TFhirExplanationOfBenefitTotalList;
    FPayment : TFhirExplanationOfBenefitPayment;
    FFormCode : TFhirCodeableConcept;
    FForm : TFhirAttachment;
    FprocessNoteList : TFhirExplanationOfBenefitProcessNoteList;
    FBenefitPeriod : TFhirPeriod;
    FbenefitBalanceList : TFhirExplanationOfBenefitBenefitBalanceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirExplanationofbenefitStatusEnum;
    Procedure SetStatusST(value : TFhirExplanationofbenefitStatusEnum);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetSubType(value : TFhirCodeableConcept);
    Procedure SetUse(value : TFhirEnum);
    Function GetUseST : TFhirClaimUseEnum;
    Procedure SetUseST(value : TFhirClaimUseEnum);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetBillablePeriod(value : TFhirPeriod);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetEnterer(value : TFhirReference{TFhirPractitioner});
    Procedure SetInsurer(value : TFhirReference{TFhirOrganization});
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetPriority(value : TFhirCodeableConcept);
    Procedure SetFundsReserveRequested(value : TFhirCodeableConcept);
    Procedure SetFundsReserve(value : TFhirCodeableConcept);
    function GetRelatedList : TFhirExplanationOfBenefitRelatedList;
    function GetHasRelatedList : Boolean;
    Procedure SetPrescription(value : TFhirReference{TFhirMedicationRequest});
    Procedure SetOriginalPrescription(value : TFhirReference{TFhirMedicationRequest});
    Procedure SetPayee(value : TFhirExplanationOfBenefitPayee);
    Procedure SetReferral(value : TFhirReference{TFhirServiceRequest});
    Procedure SetFacility(value : TFhirReference{TFhirLocation});
    Procedure SetClaim(value : TFhirReference{TFhirClaim});
    Procedure SetClaimResponse(value : TFhirReference{TFhirClaimResponse});
    Procedure SetOutcome(value : TFhirEnum);
    Function GetOutcomeST : TFhirRemittanceOutcomeEnum;
    Procedure SetOutcomeST(value : TFhirRemittanceOutcomeEnum);
    Procedure SetDisposition(value : TFhirString);
    Function GetDispositionST : String;
    Procedure SetDispositionST(value : String);
    function GetPreAuthRefList : TFhirStringList;
    function GetHasPreAuthRefList : Boolean;
    function GetPreAuthRefPeriodList : TFhirPeriodList;
    function GetHasPreAuthRefPeriodList : Boolean;
    function GetCareTeamList : TFhirExplanationOfBenefitCareTeamList;
    function GetHasCareTeamList : Boolean;
    function GetSupportingInfoList : TFhirExplanationOfBenefitSupportingInfoList;
    function GetHasSupportingInfoList : Boolean;
    function GetDiagnosisList : TFhirExplanationOfBenefitDiagnosisList;
    function GetHasDiagnosisList : Boolean;
    function GetProcedure_List : TFhirExplanationOfBenefitProcedureList;
    function GetHasProcedure_List : Boolean;
    Procedure SetPrecedence(value : TFhirPositiveInt);
    Function GetPrecedenceST : String;
    Procedure SetPrecedenceST(value : String);
    function GetInsuranceList : TFhirExplanationOfBenefitInsuranceList;
    function GetHasInsuranceList : Boolean;
    Procedure SetAccident(value : TFhirExplanationOfBenefitAccident);
    function GetItemList : TFhirExplanationOfBenefitItemList;
    function GetHasItemList : Boolean;
    function GetAddItemList : TFhirExplanationOfBenefitAddItemList;
    function GetHasAddItemList : Boolean;
    function GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
    function GetHasAdjudicationList : Boolean;
    function GetTotalList : TFhirExplanationOfBenefitTotalList;
    function GetHasTotalList : Boolean;
    Procedure SetPayment(value : TFhirExplanationOfBenefitPayment);
    Procedure SetFormCode(value : TFhirCodeableConcept);
    Procedure SetForm(value : TFhirAttachment);
    function GetProcessNoteList : TFhirExplanationOfBenefitProcessNoteList;
    function GetHasProcessNoteList : Boolean;
    Procedure SetBenefitPeriod(value : TFhirPeriod);
    function GetBenefitBalanceList : TFhirExplanationOfBenefitBenefitBalanceList;
    function GetHasBenefitBalanceList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExplanationOfBenefit; overload;
    function Clone : TFhirExplanationOfBenefit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A unique identifier assigned to this explanation of benefit.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirExplanationofbenefitStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The category of claim, e.g. oral, pharmacy, vision, institutional, professional. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of claim, e.g. oral, pharmacy, vision, institutional, professional.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service. (defined for API consistency)
    property subType : TFhirCodeableConcept read FSubType write SetSubType;
    // A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service.
    property subTypeElement : TFhirCodeableConcept read FSubType write SetSubType;

    // A code to indicate whether the nature of the request is: to request adjudication of products and services previously rendered; or requesting authorization and adjudication for provision in the future; or requesting the non-binding adjudication of the listed products and services which could be provided in the future.
    property use : TFhirClaimUseEnum read GetUseST write SetUseST;
    property useElement : TFhirEnum read FUse write SetUse;

    // Typed access to The party to whom the professional services and/or products have been supplied or are being considered and for whom actual for forecast reimbursement is sought. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The party to whom the professional services and/or products have been supplied or are being considered and for whom actual for forecast reimbursement is sought.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The period for which charges are being submitted. (defined for API consistency)
    property billablePeriod : TFhirPeriod read FBillablePeriod write SetBillablePeriod;
    // The period for which charges are being submitted.
    property billablePeriodElement : TFhirPeriod read FBillablePeriod write SetBillablePeriod;

    // Typed access to The date this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to Individual who created the claim, predetermination or preauthorization. (defined for API consistency)
    property enterer : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;
    // Individual who created the claim, predetermination or preauthorization.
    property entererElement : TFhirReference{TFhirPractitioner} read FEnterer write SetEnterer;

    // Typed access to The party responsible for authorization, adjudication and reimbursement. (defined for API consistency)
    property insurer : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;
    // The party responsible for authorization, adjudication and reimbursement.
    property insurerElement : TFhirReference{TFhirOrganization} read FInsurer write SetInsurer;

    // Typed access to The provider which is responsible for the claim, predetermination or preauthorization. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // The provider which is responsible for the claim, predetermination or preauthorization.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to The provider-required urgency of processing the request. Typical values include: stat, routine deferred. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // The provider-required urgency of processing the request. Typical values include: stat, routine deferred.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Typed access to A code to indicate whether and for whom funds are to be reserved for future claims. (defined for API consistency)
    property fundsReserveRequested : TFhirCodeableConcept read FFundsReserveRequested write SetFundsReserveRequested;
    // A code to indicate whether and for whom funds are to be reserved for future claims.
    property fundsReserveRequestedElement : TFhirCodeableConcept read FFundsReserveRequested write SetFundsReserveRequested;

    // Typed access to A code, used only on a response to a preauthorization, to indicate whether the benefits payable have been reserved and for whom. (defined for API consistency)
    property fundsReserve : TFhirCodeableConcept read FFundsReserve write SetFundsReserve;
    // A code, used only on a response to a preauthorization, to indicate whether the benefits payable have been reserved and for whom.
    property fundsReserveElement : TFhirCodeableConcept read FFundsReserve write SetFundsReserve;

    // Other claims which are related to this claim such as prior submissions or claims for related services or for the same event.
    property relatedList : TFhirExplanationOfBenefitRelatedList read GetRelatedList;
    property hasRelatedList : boolean read GetHasRelatedList;

    // Typed access to Prescription to support the dispensing of pharmacy, device or vision products. (defined for API consistency)
    property prescription : TFhirReference{TFhirMedicationRequest} read FPrescription write SetPrescription;
    // Prescription to support the dispensing of pharmacy, device or vision products.
    property prescriptionElement : TFhirReference{TFhirMedicationRequest} read FPrescription write SetPrescription;

    // Typed access to Original prescription which has been superseded by this prescription to support the dispensing of pharmacy services, medications or products. (defined for API consistency)
    property originalPrescription : TFhirReference{TFhirMedicationRequest} read FOriginalPrescription write SetOriginalPrescription;
    // Original prescription which has been superseded by this prescription to support the dispensing of pharmacy services, medications or products.
    property originalPrescriptionElement : TFhirReference{TFhirMedicationRequest} read FOriginalPrescription write SetOriginalPrescription;

    // Typed access to The party to be reimbursed for cost of the products and services according to the terms of the policy. (defined for API consistency)
    property payee : TFhirExplanationOfBenefitPayee read FPayee write SetPayee;
    // The party to be reimbursed for cost of the products and services according to the terms of the policy.
    property payeeElement : TFhirExplanationOfBenefitPayee read FPayee write SetPayee;

    // Typed access to A reference to a referral resource. (defined for API consistency)
    property referral : TFhirReference{TFhirServiceRequest} read FReferral write SetReferral;
    // A reference to a referral resource.
    property referralElement : TFhirReference{TFhirServiceRequest} read FReferral write SetReferral;

    // Typed access to Facility where the services were provided. (defined for API consistency)
    property facility : TFhirReference{TFhirLocation} read FFacility write SetFacility;
    // Facility where the services were provided.
    property facilityElement : TFhirReference{TFhirLocation} read FFacility write SetFacility;

    // Typed access to The business identifier for the instance of the adjudication request: claim predetermination or preauthorization. (defined for API consistency)
    property claim : TFhirReference{TFhirClaim} read FClaim write SetClaim;
    // The business identifier for the instance of the adjudication request: claim predetermination or preauthorization.
    property claimElement : TFhirReference{TFhirClaim} read FClaim write SetClaim;

    // Typed access to The business identifier for the instance of the adjudication response: claim, predetermination or preauthorization response. (defined for API consistency)
    property claimResponse : TFhirReference{TFhirClaimResponse} read FClaimResponse write SetClaimResponse;
    // The business identifier for the instance of the adjudication response: claim, predetermination or preauthorization response.
    property claimResponseElement : TFhirReference{TFhirClaimResponse} read FClaimResponse write SetClaimResponse;

    // The outcome of the claim, predetermination, or preauthorization processing.
    property outcome : TFhirRemittanceOutcomeEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A human readable description of the status of the adjudication.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A human readable description of the status of the adjudication.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Reference from the Insurer which is used in later communications which refers to this adjudication.
    property preAuthRefList : TFhirStringList read GetPreAuthRefList;
    property hasPreAuthRefList : boolean read GetHasPreAuthRefList;

    // The timeframe during which the supplied preauthorization reference may be quoted on claims to obtain the adjudication as provided.
    property preAuthRefPeriodList : TFhirPeriodList read GetPreAuthRefPeriodList;
    property hasPreAuthRefPeriodList : boolean read GetHasPreAuthRefPeriodList;

    // The members of the team who provided the products and services.
    property careTeamList : TFhirExplanationOfBenefitCareTeamList read GetCareTeamList;
    property hasCareTeamList : boolean read GetHasCareTeamList;

    // Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
    property supportingInfoList : TFhirExplanationOfBenefitSupportingInfoList read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Information about diagnoses relevant to the claim items.
    property diagnosisList : TFhirExplanationOfBenefitDiagnosisList read GetDiagnosisList;
    property hasDiagnosisList : boolean read GetHasDiagnosisList;

    // Procedures performed on the patient relevant to the billing items with the claim.
    property procedure_List : TFhirExplanationOfBenefitProcedureList read GetProcedure_List;
    property hasProcedure_List : boolean read GetHasProcedure_List;

    // Typed access to This indicates the relative order of a series of EOBs related to different coverages for the same suite of services.
    property precedence : String read GetPrecedenceST write SetPrecedenceST;
    // This indicates the relative order of a series of EOBs related to different coverages for the same suite of services.
    property precedenceElement : TFhirPositiveInt read FPrecedence write SetPrecedence;

    // Financial instruments for reimbursement for the health care products and services specified on the claim.
    property insuranceList : TFhirExplanationOfBenefitInsuranceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Typed access to Details of a accident which resulted in injuries which required the products and services listed in the claim. (defined for API consistency)
    property accident : TFhirExplanationOfBenefitAccident read FAccident write SetAccident;
    // Details of a accident which resulted in injuries which required the products and services listed in the claim.
    property accidentElement : TFhirExplanationOfBenefitAccident read FAccident write SetAccident;

    // A claim line. Either a simple (a product or service) or a 'group' of details which can also be a simple items or groups of sub-details.
    property itemList : TFhirExplanationOfBenefitItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

    // The first-tier service adjudications for payor added product or service lines.
    property addItemList : TFhirExplanationOfBenefitAddItemList read GetAddItemList;
    property hasAddItemList : boolean read GetHasAddItemList;

    // The adjudication results which are presented at the header level rather than at the line-item or add-item levels.
    property adjudicationList : TFhirExplanationOfBenefitItemAdjudicationList read GetAdjudicationList;
    property hasAdjudicationList : boolean read GetHasAdjudicationList;

    // Categorized monetary totals for the adjudication.
    property totalList : TFhirExplanationOfBenefitTotalList read GetTotalList;
    property hasTotalList : boolean read GetHasTotalList;

    // Typed access to Payment details for the adjudication of the claim. (defined for API consistency)
    property payment : TFhirExplanationOfBenefitPayment read FPayment write SetPayment;
    // Payment details for the adjudication of the claim.
    property paymentElement : TFhirExplanationOfBenefitPayment read FPayment write SetPayment;

    // Typed access to A code for the form to be used for printing the content. (defined for API consistency)
    property formCode : TFhirCodeableConcept read FFormCode write SetFormCode;
    // A code for the form to be used for printing the content.
    property formCodeElement : TFhirCodeableConcept read FFormCode write SetFormCode;

    // Typed access to The actual form, by reference or inclusion, for printing the content or an EOB. (defined for API consistency)
    property form : TFhirAttachment read FForm write SetForm;
    // The actual form, by reference or inclusion, for printing the content or an EOB.
    property formElement : TFhirAttachment read FForm write SetForm;

    // A note that describes or explains adjudication results in a human readable form.
    property processNoteList : TFhirExplanationOfBenefitProcessNoteList read GetProcessNoteList;
    property hasProcessNoteList : boolean read GetHasProcessNoteList;

    // Typed access to The term of the benefits documented in this response. (defined for API consistency)
    property benefitPeriod : TFhirPeriod read FBenefitPeriod write SetBenefitPeriod;
    // The term of the benefits documented in this response.
    property benefitPeriodElement : TFhirPeriod read FBenefitPeriod write SetBenefitPeriod;

    // Balance by Benefit Category.
    property benefitBalanceList : TFhirExplanationOfBenefitBenefitBalanceList read GetBenefitBalanceList;
    property hasBenefitBalanceList : boolean read GetHasBenefitBalanceList;

  end;

  TFhirExplanationOfBenefitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExplanationOfBenefitList;
    function GetCurrent : TFhirExplanationOfBenefit;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExplanationOfBenefitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExplanationOfBenefit read GetCurrent;
  end;

  TFhirExplanationOfBenefitList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExplanationOfBenefit;
    procedure SetItemN(index : Integer; value : TFhirExplanationOfBenefit);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExplanationOfBenefitList; Overload;
    function Clone : TFhirExplanationOfBenefitList; Overload;
    function GetEnumerator : TFhirExplanationOfBenefitListEnumerator;
    

    //  Add a FhirExplanationOfBenefit to the end of the list.
    function Append : TFhirExplanationOfBenefit;

    
    // Add an already existing FhirExplanationOfBenefit to the end of the list.
    procedure AddItem(value : TFhirExplanationOfBenefit); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExplanationOfBenefit) : Integer;
    

    // Insert FhirExplanationOfBenefit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExplanationOfBenefit;
    

    // Insert an existing FhirExplanationOfBenefit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExplanationOfBenefit);
    
    // Get the iIndexth FhirExplanationOfBenefit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExplanationOfBenefit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExplanationOfBenefit;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExplanationOfBenefits[index : Integer] : TFhirExplanationOfBenefit read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_EXPLANATIONOFBENEFIT}

{$IFDEF FHIR_INSURANCEPLAN}

  // The contact for the health insurance product for a certain purpose.
  TFhirInsurancePlanContact = class (TFhirBackboneElement)
  protected
    FPurpose : TFhirCodeableConcept;
    FName : TFhirHumanName;
    FtelecomList : TFhirContactPointList;
    FAddress : TFhirAddress;
    Procedure SetPurpose(value : TFhirCodeableConcept);
    Procedure SetName(value : TFhirHumanName);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    Procedure SetAddress(value : TFhirAddress);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanContact; overload;
    function Clone : TFhirInsurancePlanContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Indicates a purpose for which the contact can be reached. (defined for API consistency)
    property purpose : TFhirCodeableConcept read FPurpose write SetPurpose;
    // Indicates a purpose for which the contact can be reached.
    property purposeElement : TFhirCodeableConcept read FPurpose write SetPurpose;

    // Typed access to A name associated with the contact. (defined for API consistency)
    property name : TFhirHumanName read FName write SetName;
    // A name associated with the contact.
    property nameElement : TFhirHumanName read FName write SetName;

    // A contact detail (e.g. a telephone number or an email address) by which the party may be contacted.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Typed access to Visiting or postal addresses for the contact. (defined for API consistency)
    property address : TFhirAddress read FAddress write SetAddress;
    // Visiting or postal addresses for the contact.
    property addressElement : TFhirAddress read FAddress write SetAddress;

  end;

  TFhirInsurancePlanContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanContactList;
    function GetCurrent : TFhirInsurancePlanContact;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanContact read GetCurrent;
  end;

  TFhirInsurancePlanContactList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirInsurancePlanContact;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirInsurancePlanContactList; Overload;
    function Clone : TFhirInsurancePlanContactList; Overload;
    function GetEnumerator : TFhirInsurancePlanContactListEnumerator;
    

    //  Add a FhirInsurancePlanContact to the end of the list.
    function Append : TFhirInsurancePlanContact;

    
    // Add an already existing FhirInsurancePlanContact to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanContact); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanContact) : Integer;
    

    // Insert FhirInsurancePlanContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanContact;
    

    // Insert an existing FhirInsurancePlanContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanContact);
    
    // Get the iIndexth FhirInsurancePlanContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanContact;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirInsurancePlanContacts[index : Integer] : TFhirInsurancePlanContact read GetItemN write SetItemN; default;
  End;

  // Details about the coverage offered by the insurance product.
  TFhirInsurancePlanCoverage = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FnetworkList : TFhirReferenceList{TFhirOrganization};
    FbenefitList : TFhirInsurancePlanCoverageBenefitList;
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetNetworkList : TFhirReferenceList{TFhirOrganization};
    function GetHasNetworkList : Boolean;
    function GetBenefitList : TFhirInsurancePlanCoverageBenefitList;
    function GetHasBenefitList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanCoverage; overload;
    function Clone : TFhirInsurancePlanCoverage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Type of coverage  (Medical; Dental; Mental Health; Substance Abuse; Vision; Drug; Short Term; Long Term Care; Hospice; Home Health). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of coverage  (Medical; Dental; Mental Health; Substance Abuse; Vision; Drug; Short Term; Long Term Care; Hospice; Home Health).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Reference to the network that providing the type of coverage.
    property networkList : TFhirReferenceList{TFhirOrganization} read GetNetworkList;
    property hasNetworkList : boolean read GetHasNetworkList;

    // Specific benefits under this type of coverage.
    property benefitList : TFhirInsurancePlanCoverageBenefitList read GetBenefitList;
    property hasBenefitList : boolean read GetHasBenefitList;

  end;

  TFhirInsurancePlanCoverageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanCoverageList;
    function GetCurrent : TFhirInsurancePlanCoverage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanCoverageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanCoverage read GetCurrent;
  end;

  TFhirInsurancePlanCoverageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirInsurancePlanCoverage;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanCoverage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirInsurancePlanCoverageList; Overload;
    function Clone : TFhirInsurancePlanCoverageList; Overload;
    function GetEnumerator : TFhirInsurancePlanCoverageListEnumerator;
    

    //  Add a FhirInsurancePlanCoverage to the end of the list.
    function Append : TFhirInsurancePlanCoverage;

    
    // Add an already existing FhirInsurancePlanCoverage to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanCoverage); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanCoverage) : Integer;
    

    // Insert FhirInsurancePlanCoverage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanCoverage;
    

    // Insert an existing FhirInsurancePlanCoverage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanCoverage);
    
    // Get the iIndexth FhirInsurancePlanCoverage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanCoverage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanCoverage;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirInsurancePlanCoverages[index : Integer] : TFhirInsurancePlanCoverage read GetItemN write SetItemN; default;
  End;

  // Specific benefits under this type of coverage.
  TFhirInsurancePlanCoverageBenefit = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FRequirement : TFhirString;
    FlimitList : TFhirInsurancePlanCoverageBenefitLimitList;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetRequirement(value : TFhirString);
    Function GetRequirementST : String;
    Procedure SetRequirementST(value : String);
    function GetLimitList : TFhirInsurancePlanCoverageBenefitLimitList;
    function GetHasLimitList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanCoverageBenefit; overload;
    function Clone : TFhirInsurancePlanCoverageBenefit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Type of benefit (primary care; speciality care; inpatient; outpatient). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of benefit (primary care; speciality care; inpatient; outpatient).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The referral requirements to have access/coverage for this benefit.
    property requirement : String read GetRequirementST write SetRequirementST;
    // The referral requirements to have access/coverage for this benefit.
    property requirementElement : TFhirString read FRequirement write SetRequirement;

    // The specific limits on the benefit.
    property limitList : TFhirInsurancePlanCoverageBenefitLimitList read GetLimitList;
    property hasLimitList : boolean read GetHasLimitList;

  end;

  TFhirInsurancePlanCoverageBenefitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanCoverageBenefitList;
    function GetCurrent : TFhirInsurancePlanCoverageBenefit;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanCoverageBenefitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanCoverageBenefit read GetCurrent;
  end;

  TFhirInsurancePlanCoverageBenefitList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirInsurancePlanCoverageBenefit;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanCoverageBenefit);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirInsurancePlanCoverageBenefitList; Overload;
    function Clone : TFhirInsurancePlanCoverageBenefitList; Overload;
    function GetEnumerator : TFhirInsurancePlanCoverageBenefitListEnumerator;
    

    //  Add a FhirInsurancePlanCoverageBenefit to the end of the list.
    function Append : TFhirInsurancePlanCoverageBenefit;

    
    // Add an already existing FhirInsurancePlanCoverageBenefit to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanCoverageBenefit); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanCoverageBenefit) : Integer;
    

    // Insert FhirInsurancePlanCoverageBenefit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanCoverageBenefit;
    

    // Insert an existing FhirInsurancePlanCoverageBenefit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanCoverageBenefit);
    
    // Get the iIndexth FhirInsurancePlanCoverageBenefit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanCoverageBenefit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanCoverageBenefit;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirInsurancePlanCoverageBenefits[index : Integer] : TFhirInsurancePlanCoverageBenefit read GetItemN write SetItemN; default;
  End;

  // The specific limits on the benefit.
  TFhirInsurancePlanCoverageBenefitLimit = class (TFhirBackboneElement)
  protected
    FValue : TFhirQuantity;
    FCode : TFhirCodeableConcept;
    Procedure SetValue(value : TFhirQuantity);
    Procedure SetCode(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanCoverageBenefitLimit; overload;
    function Clone : TFhirInsurancePlanCoverageBenefitLimit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The maximum amount of a service item a plan will pay for a covered benefit.  For examples. wellness visits, or eyeglasses. (defined for API consistency)
    property value : TFhirQuantity read FValue write SetValue;
    // The maximum amount of a service item a plan will pay for a covered benefit.  For examples. wellness visits, or eyeglasses.
    property valueElement : TFhirQuantity read FValue write SetValue;

    // Typed access to The specific limit on the benefit. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The specific limit on the benefit.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

  end;

  TFhirInsurancePlanCoverageBenefitLimitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanCoverageBenefitLimitList;
    function GetCurrent : TFhirInsurancePlanCoverageBenefitLimit;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanCoverageBenefitLimitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanCoverageBenefitLimit read GetCurrent;
  end;

  TFhirInsurancePlanCoverageBenefitLimitList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirInsurancePlanCoverageBenefitLimit;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanCoverageBenefitLimit);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirInsurancePlanCoverageBenefitLimitList; Overload;
    function Clone : TFhirInsurancePlanCoverageBenefitLimitList; Overload;
    function GetEnumerator : TFhirInsurancePlanCoverageBenefitLimitListEnumerator;
    

    //  Add a FhirInsurancePlanCoverageBenefitLimit to the end of the list.
    function Append : TFhirInsurancePlanCoverageBenefitLimit;

    
    // Add an already existing FhirInsurancePlanCoverageBenefitLimit to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanCoverageBenefitLimit); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanCoverageBenefitLimit) : Integer;
    

    // Insert FhirInsurancePlanCoverageBenefitLimit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanCoverageBenefitLimit;
    

    // Insert an existing FhirInsurancePlanCoverageBenefitLimit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanCoverageBenefitLimit);
    
    // Get the iIndexth FhirInsurancePlanCoverageBenefitLimit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanCoverageBenefitLimit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanCoverageBenefitLimit;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirInsurancePlanCoverageBenefitLimits[index : Integer] : TFhirInsurancePlanCoverageBenefitLimit read GetItemN write SetItemN; default;
  End;

  // Details about an insurance plan.
  TFhirInsurancePlanPlan = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCodeableConcept;
    FcoverageAreaList : TFhirReferenceList{TFhirLocation};
    FnetworkList : TFhirReferenceList{TFhirOrganization};
    FgeneralCostList : TFhirInsurancePlanPlanGeneralCostList;
    FspecificCostList : TFhirInsurancePlanPlanSpecificCostList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetCoverageAreaList : TFhirReferenceList{TFhirLocation};
    function GetHasCoverageAreaList : Boolean;
    function GetNetworkList : TFhirReferenceList{TFhirOrganization};
    function GetHasNetworkList : Boolean;
    function GetGeneralCostList : TFhirInsurancePlanPlanGeneralCostList;
    function GetHasGeneralCostList : Boolean;
    function GetSpecificCostList : TFhirInsurancePlanPlanSpecificCostList;
    function GetHasSpecificCostList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanPlan; overload;
    function Clone : TFhirInsurancePlanPlan; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Business identifiers assigned to this health insurance plan which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Type of plan. For example, "Platinum" or "High Deductable". (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of plan. For example, "Platinum" or "High Deductable".
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The geographic region in which a health insurance plan's benefits apply.
    property coverageAreaList : TFhirReferenceList{TFhirLocation} read GetCoverageAreaList;
    property hasCoverageAreaList : boolean read GetHasCoverageAreaList;

    // Reference to the network that providing the type of coverage.
    property networkList : TFhirReferenceList{TFhirOrganization} read GetNetworkList;
    property hasNetworkList : boolean read GetHasNetworkList;

    // Overall costs associated with the plan.
    property generalCostList : TFhirInsurancePlanPlanGeneralCostList read GetGeneralCostList;
    property hasGeneralCostList : boolean read GetHasGeneralCostList;

    // Costs associated with the coverage provided by the product.
    property specificCostList : TFhirInsurancePlanPlanSpecificCostList read GetSpecificCostList;
    property hasSpecificCostList : boolean read GetHasSpecificCostList;

  end;

  TFhirInsurancePlanPlanListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanPlanList;
    function GetCurrent : TFhirInsurancePlanPlan;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanPlanList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanPlan read GetCurrent;
  end;

  TFhirInsurancePlanPlanList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirInsurancePlanPlan;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanPlan);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirInsurancePlanPlanList; Overload;
    function Clone : TFhirInsurancePlanPlanList; Overload;
    function GetEnumerator : TFhirInsurancePlanPlanListEnumerator;
    

    //  Add a FhirInsurancePlanPlan to the end of the list.
    function Append : TFhirInsurancePlanPlan;

    
    // Add an already existing FhirInsurancePlanPlan to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanPlan); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanPlan) : Integer;
    

    // Insert FhirInsurancePlanPlan before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanPlan;
    

    // Insert an existing FhirInsurancePlanPlan before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanPlan);
    
    // Get the iIndexth FhirInsurancePlanPlan. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanPlan);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanPlan;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirInsurancePlanPlans[index : Integer] : TFhirInsurancePlanPlan read GetItemN write SetItemN; default;
  End;

  // Overall costs associated with the plan.
  TFhirInsurancePlanPlanGeneralCost = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FGroupSize : TFhirPositiveInt;
    FCost : TFhirMoney;
    FComment : TFhirString;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetGroupSize(value : TFhirPositiveInt);
    Function GetGroupSizeST : String;
    Procedure SetGroupSizeST(value : String);
    Procedure SetCost(value : TFhirMoney);
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanPlanGeneralCost; overload;
    function Clone : TFhirInsurancePlanPlanGeneralCost; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Type of cost. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of cost.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Number of participants enrolled in the plan.
    property groupSize : String read GetGroupSizeST write SetGroupSizeST;
    // Number of participants enrolled in the plan.
    property groupSizeElement : TFhirPositiveInt read FGroupSize write SetGroupSize;

    // Typed access to Value of the cost. (defined for API consistency)
    property cost : TFhirMoney read FCost write SetCost;
    // Value of the cost.
    property costElement : TFhirMoney read FCost write SetCost;

    // Typed access to Additional information about the general costs associated with this plan.
    property comment : String read GetCommentST write SetCommentST;
    // Additional information about the general costs associated with this plan.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirInsurancePlanPlanGeneralCostListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanPlanGeneralCostList;
    function GetCurrent : TFhirInsurancePlanPlanGeneralCost;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanPlanGeneralCostList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanPlanGeneralCost read GetCurrent;
  end;

  TFhirInsurancePlanPlanGeneralCostList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirInsurancePlanPlanGeneralCost;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanPlanGeneralCost);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirInsurancePlanPlanGeneralCostList; Overload;
    function Clone : TFhirInsurancePlanPlanGeneralCostList; Overload;
    function GetEnumerator : TFhirInsurancePlanPlanGeneralCostListEnumerator;
    

    //  Add a FhirInsurancePlanPlanGeneralCost to the end of the list.
    function Append : TFhirInsurancePlanPlanGeneralCost;

    
    // Add an already existing FhirInsurancePlanPlanGeneralCost to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanPlanGeneralCost); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanPlanGeneralCost) : Integer;
    

    // Insert FhirInsurancePlanPlanGeneralCost before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanPlanGeneralCost;
    

    // Insert an existing FhirInsurancePlanPlanGeneralCost before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanPlanGeneralCost);
    
    // Get the iIndexth FhirInsurancePlanPlanGeneralCost. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanPlanGeneralCost);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanPlanGeneralCost;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirInsurancePlanPlanGeneralCosts[index : Integer] : TFhirInsurancePlanPlanGeneralCost read GetItemN write SetItemN; default;
  End;

  // Costs associated with the coverage provided by the product.
  TFhirInsurancePlanPlanSpecificCost = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FbenefitList : TFhirInsurancePlanPlanSpecificCostBenefitList;
    Procedure SetCategory(value : TFhirCodeableConcept);
    function GetBenefitList : TFhirInsurancePlanPlanSpecificCostBenefitList;
    function GetHasBenefitList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanPlanSpecificCost; overload;
    function Clone : TFhirInsurancePlanPlanSpecificCost; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to General category of benefit (Medical; Dental; Vision; Drug; Mental Health; Substance Abuse; Hospice, Home Health). (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // General category of benefit (Medical; Dental; Vision; Drug; Mental Health; Substance Abuse; Hospice, Home Health).
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // List of the specific benefits under this category of benefit.
    property benefitList : TFhirInsurancePlanPlanSpecificCostBenefitList read GetBenefitList;
    property hasBenefitList : boolean read GetHasBenefitList;

  end;

  TFhirInsurancePlanPlanSpecificCostListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanPlanSpecificCostList;
    function GetCurrent : TFhirInsurancePlanPlanSpecificCost;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanPlanSpecificCostList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanPlanSpecificCost read GetCurrent;
  end;

  TFhirInsurancePlanPlanSpecificCostList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirInsurancePlanPlanSpecificCost;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanPlanSpecificCost);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirInsurancePlanPlanSpecificCostList; Overload;
    function Clone : TFhirInsurancePlanPlanSpecificCostList; Overload;
    function GetEnumerator : TFhirInsurancePlanPlanSpecificCostListEnumerator;
    

    //  Add a FhirInsurancePlanPlanSpecificCost to the end of the list.
    function Append : TFhirInsurancePlanPlanSpecificCost;

    
    // Add an already existing FhirInsurancePlanPlanSpecificCost to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanPlanSpecificCost); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanPlanSpecificCost) : Integer;
    

    // Insert FhirInsurancePlanPlanSpecificCost before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanPlanSpecificCost;
    

    // Insert an existing FhirInsurancePlanPlanSpecificCost before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanPlanSpecificCost);
    
    // Get the iIndexth FhirInsurancePlanPlanSpecificCost. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanPlanSpecificCost);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanPlanSpecificCost;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirInsurancePlanPlanSpecificCosts[index : Integer] : TFhirInsurancePlanPlanSpecificCost read GetItemN write SetItemN; default;
  End;

  // List of the specific benefits under this category of benefit.
  TFhirInsurancePlanPlanSpecificCostBenefit = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FcostList : TFhirInsurancePlanPlanSpecificCostBenefitCostList;
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetCostList : TFhirInsurancePlanPlanSpecificCostBenefitCostList;
    function GetHasCostList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanPlanSpecificCostBenefit; overload;
    function Clone : TFhirInsurancePlanPlanSpecificCostBenefit; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Type of specific benefit (preventative; primary care office visit; speciality office visit; hospitalization; emergency room; urgent care). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of specific benefit (preventative; primary care office visit; speciality office visit; hospitalization; emergency room; urgent care).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // List of the costs associated with a specific benefit.
    property costList : TFhirInsurancePlanPlanSpecificCostBenefitCostList read GetCostList;
    property hasCostList : boolean read GetHasCostList;

  end;

  TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanPlanSpecificCostBenefitList;
    function GetCurrent : TFhirInsurancePlanPlanSpecificCostBenefit;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanPlanSpecificCostBenefitList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanPlanSpecificCostBenefit read GetCurrent;
  end;

  TFhirInsurancePlanPlanSpecificCostBenefitList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirInsurancePlanPlanSpecificCostBenefit;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanPlanSpecificCostBenefit);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirInsurancePlanPlanSpecificCostBenefitList; Overload;
    function Clone : TFhirInsurancePlanPlanSpecificCostBenefitList; Overload;
    function GetEnumerator : TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator;
    

    //  Add a FhirInsurancePlanPlanSpecificCostBenefit to the end of the list.
    function Append : TFhirInsurancePlanPlanSpecificCostBenefit;

    
    // Add an already existing FhirInsurancePlanPlanSpecificCostBenefit to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanPlanSpecificCostBenefit); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanPlanSpecificCostBenefit) : Integer;
    

    // Insert FhirInsurancePlanPlanSpecificCostBenefit before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanPlanSpecificCostBenefit;
    

    // Insert an existing FhirInsurancePlanPlanSpecificCostBenefit before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanPlanSpecificCostBenefit);
    
    // Get the iIndexth FhirInsurancePlanPlanSpecificCostBenefit. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanPlanSpecificCostBenefit);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanPlanSpecificCostBenefit;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirInsurancePlanPlanSpecificCostBenefits[index : Integer] : TFhirInsurancePlanPlanSpecificCostBenefit read GetItemN write SetItemN; default;
  End;

  // List of the costs associated with a specific benefit.
  TFhirInsurancePlanPlanSpecificCostBenefitCost = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FApplicability : TFhirCodeableConcept;
    FqualifiersList : TFhirCodeableConceptList;
    FValue : TFhirQuantity;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetApplicability(value : TFhirCodeableConcept);
    function GetQualifiersList : TFhirCodeableConceptList;
    function GetHasQualifiersList : Boolean;
    Procedure SetValue(value : TFhirQuantity);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlanPlanSpecificCostBenefitCost; overload;
    function Clone : TFhirInsurancePlanPlanSpecificCostBenefitCost; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Type of cost (copay; individual cap; family cap; coinsurance; deductible). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of cost (copay; individual cap; family cap; coinsurance; deductible).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Whether the cost applies to in-network or out-of-network providers (in-network; out-of-network; other). (defined for API consistency)
    property applicability : TFhirCodeableConcept read FApplicability write SetApplicability;
    // Whether the cost applies to in-network or out-of-network providers (in-network; out-of-network; other).
    property applicabilityElement : TFhirCodeableConcept read FApplicability write SetApplicability;

    // Additional information about the cost, such as information about funding sources (e.g. HSA, HRA, FSA, RRA).
    property qualifiersList : TFhirCodeableConceptList read GetQualifiersList;
    property hasQualifiersList : boolean read GetHasQualifiersList;

    // Typed access to The actual cost value. (some of the costs may be represented as percentages rather than currency, e.g. 10% coinsurance). (defined for API consistency)
    property value : TFhirQuantity read FValue write SetValue;
    // The actual cost value. (some of the costs may be represented as percentages rather than currency, e.g. 10% coinsurance).
    property valueElement : TFhirQuantity read FValue write SetValue;

  end;

  TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanPlanSpecificCostBenefitCostList;
    function GetCurrent : TFhirInsurancePlanPlanSpecificCostBenefitCost;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanPlanSpecificCostBenefitCostList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlanPlanSpecificCostBenefitCost read GetCurrent;
  end;

  TFhirInsurancePlanPlanSpecificCostBenefitCostList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirInsurancePlanPlanSpecificCostBenefitCost;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlanPlanSpecificCostBenefitCost);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirInsurancePlanPlanSpecificCostBenefitCostList; Overload;
    function Clone : TFhirInsurancePlanPlanSpecificCostBenefitCostList; Overload;
    function GetEnumerator : TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator;
    

    //  Add a FhirInsurancePlanPlanSpecificCostBenefitCost to the end of the list.
    function Append : TFhirInsurancePlanPlanSpecificCostBenefitCost;

    
    // Add an already existing FhirInsurancePlanPlanSpecificCostBenefitCost to the end of the list.
    procedure AddItem(value : TFhirInsurancePlanPlanSpecificCostBenefitCost); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlanPlanSpecificCostBenefitCost) : Integer;
    

    // Insert FhirInsurancePlanPlanSpecificCostBenefitCost before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlanPlanSpecificCostBenefitCost;
    

    // Insert an existing FhirInsurancePlanPlanSpecificCostBenefitCost before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlanPlanSpecificCostBenefitCost);
    
    // Get the iIndexth FhirInsurancePlanPlanSpecificCostBenefitCost. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlanPlanSpecificCostBenefitCost);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlanPlanSpecificCostBenefitCost;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirInsurancePlanPlanSpecificCostBenefitCosts[index : Integer] : TFhirInsurancePlanPlanSpecificCostBenefitCost read GetItemN write SetItemN; default;
  End;

  // Details of a Health Insurance product/plan provided by an organization.
  TFhirInsurancePlan = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    Ftype_List : TFhirCodeableConceptList;
    FName : TFhirString;
    FaliasList : TFhirStringList;
    FPeriod : TFhirPeriod;
    FOwnedBy : TFhirReference{TFhirOrganization};
    FAdministeredBy : TFhirReference{TFhirOrganization};
    FcoverageAreaList : TFhirReferenceList{TFhirLocation};
    FcontactList : TFhirInsurancePlanContactList;
    FendpointList : TFhirReferenceList{TFhirEndpoint};
    FnetworkList : TFhirReferenceList{TFhirOrganization};
    FcoverageList : TFhirInsurancePlanCoverageList;
    FplanList : TFhirInsurancePlanPlanList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirPublicationStatusEnum;
    Procedure SetStatusST(value : TFhirPublicationStatusEnum);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    function GetAliasList : TFhirStringList;
    function GetHasAliasList : Boolean;
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetOwnedBy(value : TFhirReference{TFhirOrganization});
    Procedure SetAdministeredBy(value : TFhirReference{TFhirOrganization});
    function GetCoverageAreaList : TFhirReferenceList{TFhirLocation};
    function GetHasCoverageAreaList : Boolean;
    function GetContactList : TFhirInsurancePlanContactList;
    function GetHasContactList : Boolean;
    function GetEndpointList : TFhirReferenceList{TFhirEndpoint};
    function GetHasEndpointList : Boolean;
    function GetNetworkList : TFhirReferenceList{TFhirOrganization};
    function GetHasNetworkList : Boolean;
    function GetCoverageList : TFhirInsurancePlanCoverageList;
    function GetHasCoverageList : Boolean;
    function GetPlanList : TFhirInsurancePlanPlanList;
    function GetHasPlanList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInsurancePlan; overload;
    function Clone : TFhirInsurancePlan; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Business identifiers assigned to this health insurance product which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The current state of the health insurance product.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The kind of health insurance product.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to Official name of the health insurance product as designated by the owner.
    property name : String read GetNameST write SetNameST;
    // Official name of the health insurance product as designated by the owner.
    property nameElement : TFhirString read FName write SetName;

    // A list of alternate names that the product is known as, or was known as in the past.
    property aliasList : TFhirStringList read GetAliasList;
    property hasAliasList : boolean read GetHasAliasList;

    // Typed access to The period of time that the health insurance product is available. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time that the health insurance product is available.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to The entity that is providing  the health insurance product and underwriting the risk.  This is typically an insurance carriers, other third-party payers, or health plan sponsors comonly referred to as 'payers'. (defined for API consistency)
    property ownedBy : TFhirReference{TFhirOrganization} read FOwnedBy write SetOwnedBy;
    // The entity that is providing  the health insurance product and underwriting the risk.  This is typically an insurance carriers, other third-party payers, or health plan sponsors comonly referred to as 'payers'.
    property ownedByElement : TFhirReference{TFhirOrganization} read FOwnedBy write SetOwnedBy;

    // Typed access to An organization which administer other services such as underwriting, customer service and/or claims processing on behalf of the health insurance product owner. (defined for API consistency)
    property administeredBy : TFhirReference{TFhirOrganization} read FAdministeredBy write SetAdministeredBy;
    // An organization which administer other services such as underwriting, customer service and/or claims processing on behalf of the health insurance product owner.
    property administeredByElement : TFhirReference{TFhirOrganization} read FAdministeredBy write SetAdministeredBy;

    // The geographic region in which a health insurance product's benefits apply.
    property coverageAreaList : TFhirReferenceList{TFhirLocation} read GetCoverageAreaList;
    property hasCoverageAreaList : boolean read GetHasCoverageAreaList;

    // The contact for the health insurance product for a certain purpose.
    property contactList : TFhirInsurancePlanContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // The technical endpoints providing access to services operated for the health insurance product.
    property endpointList : TFhirReferenceList{TFhirEndpoint} read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

    // Reference to the network included in the health insurance product.
    property networkList : TFhirReferenceList{TFhirOrganization} read GetNetworkList;
    property hasNetworkList : boolean read GetHasNetworkList;

    // Details about the coverage offered by the insurance product.
    property coverageList : TFhirInsurancePlanCoverageList read GetCoverageList;
    property hasCoverageList : boolean read GetHasCoverageList;

    // Details about an insurance plan.
    property planList : TFhirInsurancePlanPlanList read GetPlanList;
    property hasPlanList : boolean read GetHasPlanList;

  end;

  TFhirInsurancePlanListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInsurancePlanList;
    function GetCurrent : TFhirInsurancePlan;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInsurancePlanList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInsurancePlan read GetCurrent;
  end;

  TFhirInsurancePlanList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirInsurancePlan;
    procedure SetItemN(index : Integer; value : TFhirInsurancePlan);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirInsurancePlanList; Overload;
    function Clone : TFhirInsurancePlanList; Overload;
    function GetEnumerator : TFhirInsurancePlanListEnumerator;
    

    //  Add a FhirInsurancePlan to the end of the list.
    function Append : TFhirInsurancePlan;

    
    // Add an already existing FhirInsurancePlan to the end of the list.
    procedure AddItem(value : TFhirInsurancePlan); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInsurancePlan) : Integer;
    

    // Insert FhirInsurancePlan before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInsurancePlan;
    

    // Insert an existing FhirInsurancePlan before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInsurancePlan);
    
    // Get the iIndexth FhirInsurancePlan. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInsurancePlan);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInsurancePlan;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirInsurancePlans[index : Integer] : TFhirInsurancePlan read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_INSURANCEPLAN}

{$IFDEF FHIR_INVOICE}

  // Indicates who or what performed or participated in the charged service.
  TFhirInvoiceParticipant = class (TFhirBackboneElement)
  protected
    FRole : TFhirCodeableConcept;
    FActor : TFhirReference{TFhirPractitioner};
    Procedure SetRole(value : TFhirCodeableConcept);
    Procedure SetActor(value : TFhirReference{TFhirPractitioner});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInvoiceParticipant; overload;
    function Clone : TFhirInvoiceParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Describes the type of involvement (e.g. transcriptionist, creator etc.). If the invoice has been created automatically, the Participant may be a billing engine or another kind of device. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Describes the type of involvement (e.g. transcriptionist, creator etc.). If the invoice has been created automatically, the Participant may be a billing engine or another kind of device.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The device, practitioner, etc. who performed or participated in the service. (defined for API consistency)
    property actor : TFhirReference{TFhirPractitioner} read FActor write SetActor;
    // The device, practitioner, etc. who performed or participated in the service.
    property actorElement : TFhirReference{TFhirPractitioner} read FActor write SetActor;

  end;

  TFhirInvoiceParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInvoiceParticipantList;
    function GetCurrent : TFhirInvoiceParticipant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInvoiceParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInvoiceParticipant read GetCurrent;
  end;

  TFhirInvoiceParticipantList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirInvoiceParticipant;
    procedure SetItemN(index : Integer; value : TFhirInvoiceParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirInvoiceParticipantList; Overload;
    function Clone : TFhirInvoiceParticipantList; Overload;
    function GetEnumerator : TFhirInvoiceParticipantListEnumerator;
    

    //  Add a FhirInvoiceParticipant to the end of the list.
    function Append : TFhirInvoiceParticipant;

    
    // Add an already existing FhirInvoiceParticipant to the end of the list.
    procedure AddItem(value : TFhirInvoiceParticipant); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInvoiceParticipant) : Integer;
    

    // Insert FhirInvoiceParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInvoiceParticipant;
    

    // Insert an existing FhirInvoiceParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInvoiceParticipant);
    
    // Get the iIndexth FhirInvoiceParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInvoiceParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInvoiceParticipant;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirInvoiceParticipants[index : Integer] : TFhirInvoiceParticipant read GetItemN write SetItemN; default;
  End;

  // Each line item represents one charge for goods and services rendered. Details such as date, code and amount are found in the referenced ChargeItem resource.
  TFhirInvoiceLineItem = class (TFhirBackboneElement)
  protected
    FSequence : TFhirPositiveInt;
    FChargeItem : TFhirType;
    FpriceComponentList : TFhirInvoiceLineItemPriceComponentList;
    Procedure SetSequence(value : TFhirPositiveInt);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetChargeItem(value : TFhirType);
    function GetPriceComponentList : TFhirInvoiceLineItemPriceComponentList;
    function GetHasPriceComponentList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInvoiceLineItem; overload;
    function Clone : TFhirInvoiceLineItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Sequence in which the items appear on the invoice.
    property sequence : String read GetSequenceST write SetSequenceST;
    // Sequence in which the items appear on the invoice.
    property sequenceElement : TFhirPositiveInt read FSequence write SetSequence;

    // Typed access to The ChargeItem contains information such as the billing code, date, amount etc. If no further details are required for the lineItem, inline billing codes can be added using the CodeableConcept data type instead of the Reference. (defined for API consistency)
    property chargeItem : TFhirType read FChargeItem write SetChargeItem;
    // The ChargeItem contains information such as the billing code, date, amount etc. If no further details are required for the lineItem, inline billing codes can be added using the CodeableConcept data type instead of the Reference.
    property chargeItemElement : TFhirType read FChargeItem write SetChargeItem;

    // The price for a ChargeItem may be calculated as a base price with surcharges/deductions that apply in certain conditions. A ChargeItemDefinition resource that defines the prices, factors and conditions that apply to a billing code is currently under development. The priceComponent element can be used to offer transparency to the recipient of the Invoice as to how the prices have been calculated.
    property priceComponentList : TFhirInvoiceLineItemPriceComponentList read GetPriceComponentList;
    property hasPriceComponentList : boolean read GetHasPriceComponentList;

  end;

  TFhirInvoiceLineItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInvoiceLineItemList;
    function GetCurrent : TFhirInvoiceLineItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInvoiceLineItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInvoiceLineItem read GetCurrent;
  end;

  TFhirInvoiceLineItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirInvoiceLineItem;
    procedure SetItemN(index : Integer; value : TFhirInvoiceLineItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirInvoiceLineItemList; Overload;
    function Clone : TFhirInvoiceLineItemList; Overload;
    function GetEnumerator : TFhirInvoiceLineItemListEnumerator;
    

    //  Add a FhirInvoiceLineItem to the end of the list.
    function Append : TFhirInvoiceLineItem;

    
    // Add an already existing FhirInvoiceLineItem to the end of the list.
    procedure AddItem(value : TFhirInvoiceLineItem); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInvoiceLineItem) : Integer;
    

    // Insert FhirInvoiceLineItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInvoiceLineItem;
    

    // Insert an existing FhirInvoiceLineItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInvoiceLineItem);
    
    // Get the iIndexth FhirInvoiceLineItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInvoiceLineItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInvoiceLineItem;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirInvoiceLineItems[index : Integer] : TFhirInvoiceLineItem read GetItemN write SetItemN; default;
  End;

  // The price for a ChargeItem may be calculated as a base price with surcharges/deductions that apply in certain conditions. A ChargeItemDefinition resource that defines the prices, factors and conditions that apply to a billing code is currently under development. The priceComponent element can be used to offer transparency to the recipient of the Invoice as to how the prices have been calculated.
  TFhirInvoiceLineItemPriceComponent = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FFactor : TFhirDecimal;
    FAmount : TFhirMoney;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirInvoicePriceComponentTypeEnum;
    Procedure SetType_ST(value : TFhirInvoicePriceComponentTypeEnum);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetAmount(value : TFhirMoney);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInvoiceLineItemPriceComponent; overload;
    function Clone : TFhirInvoiceLineItemPriceComponent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // This code identifies the type of the component.
    property type_ : TFhirInvoicePriceComponentTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A code that identifies the component. Codes may be used to differentiate between kinds of taxes, surcharges, discounts etc. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies the component. Codes may be used to differentiate between kinds of taxes, surcharges, discounts etc.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The factor that has been applied on the base price for calculating this component.
    property factor : String read GetFactorST write SetFactorST;
    // The factor that has been applied on the base price for calculating this component.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The amount calculated for this component. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // The amount calculated for this component.
    property amountElement : TFhirMoney read FAmount write SetAmount;

  end;

  TFhirInvoiceLineItemPriceComponentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInvoiceLineItemPriceComponentList;
    function GetCurrent : TFhirInvoiceLineItemPriceComponent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInvoiceLineItemPriceComponentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInvoiceLineItemPriceComponent read GetCurrent;
  end;

  TFhirInvoiceLineItemPriceComponentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirInvoiceLineItemPriceComponent;
    procedure SetItemN(index : Integer; value : TFhirInvoiceLineItemPriceComponent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirInvoiceLineItemPriceComponentList; Overload;
    function Clone : TFhirInvoiceLineItemPriceComponentList; Overload;
    function GetEnumerator : TFhirInvoiceLineItemPriceComponentListEnumerator;
    

    //  Add a FhirInvoiceLineItemPriceComponent to the end of the list.
    function Append : TFhirInvoiceLineItemPriceComponent;

    
    // Add an already existing FhirInvoiceLineItemPriceComponent to the end of the list.
    procedure AddItem(value : TFhirInvoiceLineItemPriceComponent); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInvoiceLineItemPriceComponent) : Integer;
    

    // Insert FhirInvoiceLineItemPriceComponent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInvoiceLineItemPriceComponent;
    

    // Insert an existing FhirInvoiceLineItemPriceComponent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInvoiceLineItemPriceComponent);
    
    // Get the iIndexth FhirInvoiceLineItemPriceComponent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInvoiceLineItemPriceComponent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInvoiceLineItemPriceComponent;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirInvoiceLineItemPriceComponents[index : Integer] : TFhirInvoiceLineItemPriceComponent read GetItemN write SetItemN; default;
  End;

  // Invoice containing collected ChargeItems from an Account with calculated individual and total price for Billing purpose.
  TFhirInvoice = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCancelledReason : TFhirString;
    FType_ : TFhirCodeableConcept;
    FSubject : TFhirReference{TFhirPatient};
    FRecipient : TFhirReference{TFhirOrganization};
    FDate : TFhirDateTime;
    FparticipantList : TFhirInvoiceParticipantList;
    FIssuer : TFhirReference{TFhirOrganization};
    FAccount : TFhirReference{TFhirAccount};
    FlineItemList : TFhirInvoiceLineItemList;
    FtotalPriceComponentList : TFhirInvoiceLineItemPriceComponentList;
    FTotalNet : TFhirMoney;
    FTotalGross : TFhirMoney;
    FPaymentTerms : TFhirMarkdown;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirInvoiceStatusEnum;
    Procedure SetStatusST(value : TFhirInvoiceStatusEnum);
    Procedure SetCancelledReason(value : TFhirString);
    Function GetCancelledReasonST : String;
    Procedure SetCancelledReasonST(value : String);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{TFhirPatient});
    Procedure SetRecipient(value : TFhirReference{TFhirOrganization});
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    function GetParticipantList : TFhirInvoiceParticipantList;
    function GetHasParticipantList : Boolean;
    Procedure SetIssuer(value : TFhirReference{TFhirOrganization});
    Procedure SetAccount(value : TFhirReference{TFhirAccount});
    function GetLineItemList : TFhirInvoiceLineItemList;
    function GetHasLineItemList : Boolean;
    function GetTotalPriceComponentList : TFhirInvoiceLineItemPriceComponentList;
    function GetHasTotalPriceComponentList : Boolean;
    Procedure SetTotalNet(value : TFhirMoney);
    Procedure SetTotalGross(value : TFhirMoney);
    Procedure SetPaymentTerms(value : TFhirMarkdown);
    Function GetPaymentTermsST : String;
    Procedure SetPaymentTermsST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirInvoice; overload;
    function Clone : TFhirInvoice; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifier of this Invoice, often used for reference in correspondence about this invoice or for tracking of payments.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The current state of the Invoice.
    property status : TFhirInvoiceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to In case of Invoice cancellation a reason must be given (entered in error, superseded by corrected invoice etc.).
    property cancelledReason : String read GetCancelledReasonST write SetCancelledReasonST;
    // In case of Invoice cancellation a reason must be given (entered in error, superseded by corrected invoice etc.).
    property cancelledReasonElement : TFhirString read FCancelledReason write SetCancelledReason;

    // Typed access to Type of Invoice depending on domain, realm an usage (e.g. internal/external, dental, preliminary). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of Invoice depending on domain, realm an usage (e.g. internal/external, dental, preliminary).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The individual or set of individuals receiving the goods and services billed in this invoice. (defined for API consistency)
    property subject : TFhirReference{TFhirPatient} read FSubject write SetSubject;
    // The individual or set of individuals receiving the goods and services billed in this invoice.
    property subjectElement : TFhirReference{TFhirPatient} read FSubject write SetSubject;

    // Typed access to The individual or Organization responsible for balancing of this invoice. (defined for API consistency)
    property recipient : TFhirReference{TFhirOrganization} read FRecipient write SetRecipient;
    // The individual or Organization responsible for balancing of this invoice.
    property recipientElement : TFhirReference{TFhirOrganization} read FRecipient write SetRecipient;

    // Typed access to Date/time(s) of when this Invoice was posted.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date/time(s) of when this Invoice was posted.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Indicates who or what performed or participated in the charged service.
    property participantList : TFhirInvoiceParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Typed access to The organizationissuing the Invoice. (defined for API consistency)
    property issuer : TFhirReference{TFhirOrganization} read FIssuer write SetIssuer;
    // The organizationissuing the Invoice.
    property issuerElement : TFhirReference{TFhirOrganization} read FIssuer write SetIssuer;

    // Typed access to Account which is supposed to be balanced with this Invoice. (defined for API consistency)
    property account : TFhirReference{TFhirAccount} read FAccount write SetAccount;
    // Account which is supposed to be balanced with this Invoice.
    property accountElement : TFhirReference{TFhirAccount} read FAccount write SetAccount;

    // Each line item represents one charge for goods and services rendered. Details such as date, code and amount are found in the referenced ChargeItem resource.
    property lineItemList : TFhirInvoiceLineItemList read GetLineItemList;
    property hasLineItemList : boolean read GetHasLineItemList;

    // The total amount for the Invoice may be calculated as the sum of the line items with surcharges/deductions that apply in certain conditions.  The priceComponent element can be used to offer transparency to the recipient of the Invoice of how the total price was calculated.
    property totalPriceComponentList : TFhirInvoiceLineItemPriceComponentList read GetTotalPriceComponentList;
    property hasTotalPriceComponentList : boolean read GetHasTotalPriceComponentList;

    // Typed access to Invoice total , taxes excluded. (defined for API consistency)
    property totalNet : TFhirMoney read FTotalNet write SetTotalNet;
    // Invoice total , taxes excluded.
    property totalNetElement : TFhirMoney read FTotalNet write SetTotalNet;

    // Typed access to Invoice total, tax included. (defined for API consistency)
    property totalGross : TFhirMoney read FTotalGross write SetTotalGross;
    // Invoice total, tax included.
    property totalGrossElement : TFhirMoney read FTotalGross write SetTotalGross;

    // Typed access to Payment details such as banking details, period of payment, deductibles, methods of payment.
    property paymentTerms : String read GetPaymentTermsST write SetPaymentTermsST;
    // Payment details such as banking details, period of payment, deductibles, methods of payment.
    property paymentTermsElement : TFhirMarkdown read FPaymentTerms write SetPaymentTerms;

    // Comments made about the invoice by the issuer, subject, or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirInvoiceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInvoiceList;
    function GetCurrent : TFhirInvoice;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInvoiceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInvoice read GetCurrent;
  end;

  TFhirInvoiceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirInvoice;
    procedure SetItemN(index : Integer; value : TFhirInvoice);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirInvoiceList; Overload;
    function Clone : TFhirInvoiceList; Overload;
    function GetEnumerator : TFhirInvoiceListEnumerator;
    

    //  Add a FhirInvoice to the end of the list.
    function Append : TFhirInvoice;

    
    // Add an already existing FhirInvoice to the end of the list.
    procedure AddItem(value : TFhirInvoice); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInvoice) : Integer;
    

    // Insert FhirInvoice before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInvoice;
    

    // Insert an existing FhirInvoice before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInvoice);
    
    // Get the iIndexth FhirInvoice. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInvoice);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInvoice;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirInvoices[index : Integer] : TFhirInvoice read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_INVOICE}

{$IFDEF FHIR_PAYMENTNOTICE}

  // This resource provides the status of the payment for goods and services rendered, and the request and response resource references.
  TFhirPaymentNotice = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FRequest : TFhirReference{TFhirReference};
    FResponse : TFhirReference{TFhirReference};
    FCreated : TFhirDateTime;
    FProvider : TFhirReference{TFhirPractitioner};
    FPayment : TFhirReference{TFhirPaymentReconciliation};
    FPaymentDate : TFhirDate;
    FPayee : TFhirReference{TFhirPractitioner};
    FRecipient : TFhirReference{TFhirOrganization};
    FAmount : TFhirMoney;
    FPaymentStatus : TFhirCodeableConcept;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    Procedure SetRequest(value : TFhirReference{TFhirReference});
    Procedure SetResponse(value : TFhirReference{TFhirReference});
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetProvider(value : TFhirReference{TFhirPractitioner});
    Procedure SetPayment(value : TFhirReference{TFhirPaymentReconciliation});
    Procedure SetPaymentDate(value : TFhirDate);
    Function GetPaymentDateST : TFslDateTime;
    Procedure SetPaymentDateST(value : TFslDateTime);
    Procedure SetPayee(value : TFhirReference{TFhirPractitioner});
    Procedure SetRecipient(value : TFhirReference{TFhirOrganization});
    Procedure SetAmount(value : TFhirMoney);
    Procedure SetPaymentStatus(value : TFhirCodeableConcept);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPaymentNotice; overload;
    function Clone : TFhirPaymentNotice; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A unique identifier assigned to this payment notice.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Reference of resource for which payment is being made. (defined for API consistency)
    property request : TFhirReference{TFhirReference} read FRequest write SetRequest;
    // Reference of resource for which payment is being made.
    property requestElement : TFhirReference{TFhirReference} read FRequest write SetRequest;

    // Typed access to Reference of response to resource for which payment is being made. (defined for API consistency)
    property response : TFhirReference{TFhirReference} read FResponse write SetResponse;
    // Reference of response to resource for which payment is being made.
    property responseElement : TFhirReference{TFhirReference} read FResponse write SetResponse;

    // Typed access to The date when this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property provider : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;
    // The practitioner who is responsible for the services rendered to the patient.
    property providerElement : TFhirReference{TFhirPractitioner} read FProvider write SetProvider;

    // Typed access to A reference to the payment which is the subject of this notice. (defined for API consistency)
    property payment : TFhirReference{TFhirPaymentReconciliation} read FPayment write SetPayment;
    // A reference to the payment which is the subject of this notice.
    property paymentElement : TFhirReference{TFhirPaymentReconciliation} read FPayment write SetPayment;

    // Typed access to The date when the above payment action occurred.
    property paymentDate : TFslDateTime read GetPaymentDateST write SetPaymentDateST;
    // The date when the above payment action occurred.
    property paymentDateElement : TFhirDate read FPaymentDate write SetPaymentDate;

    // Typed access to The party who will receive or has received payment that is the subject of this notification. (defined for API consistency)
    property payee : TFhirReference{TFhirPractitioner} read FPayee write SetPayee;
    // The party who will receive or has received payment that is the subject of this notification.
    property payeeElement : TFhirReference{TFhirPractitioner} read FPayee write SetPayee;

    // Typed access to The party who is notified of the payment status. (defined for API consistency)
    property recipient : TFhirReference{TFhirOrganization} read FRecipient write SetRecipient;
    // The party who is notified of the payment status.
    property recipientElement : TFhirReference{TFhirOrganization} read FRecipient write SetRecipient;

    // Typed access to The amount sent to the payee. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // The amount sent to the payee.
    property amountElement : TFhirMoney read FAmount write SetAmount;

    // Typed access to A code indicating whether payment has been sent or cleared. (defined for API consistency)
    property paymentStatus : TFhirCodeableConcept read FPaymentStatus write SetPaymentStatus;
    // A code indicating whether payment has been sent or cleared.
    property paymentStatusElement : TFhirCodeableConcept read FPaymentStatus write SetPaymentStatus;

  end;

  TFhirPaymentNoticeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPaymentNoticeList;
    function GetCurrent : TFhirPaymentNotice;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPaymentNoticeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPaymentNotice read GetCurrent;
  end;

  TFhirPaymentNoticeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPaymentNotice;
    procedure SetItemN(index : Integer; value : TFhirPaymentNotice);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPaymentNoticeList; Overload;
    function Clone : TFhirPaymentNoticeList; Overload;
    function GetEnumerator : TFhirPaymentNoticeListEnumerator;
    

    //  Add a FhirPaymentNotice to the end of the list.
    function Append : TFhirPaymentNotice;

    
    // Add an already existing FhirPaymentNotice to the end of the list.
    procedure AddItem(value : TFhirPaymentNotice); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPaymentNotice) : Integer;
    

    // Insert FhirPaymentNotice before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPaymentNotice;
    

    // Insert an existing FhirPaymentNotice before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPaymentNotice);
    
    // Get the iIndexth FhirPaymentNotice. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPaymentNotice);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPaymentNotice;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirPaymentNotices[index : Integer] : TFhirPaymentNotice read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PAYMENTNOTICE}

{$IFDEF FHIR_PAYMENTRECONCILIATION}

  // Distribution of the payment amount for a previously acknowledged payable.
  TFhirPaymentReconciliationDetail = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FPredecessor : TFhirIdentifier;
    FType_ : TFhirCodeableConcept;
    FRequest : TFhirReference{TFhirReference};
    FSubmitter : TFhirReference{TFhirPractitioner};
    FResponse : TFhirReference{TFhirReference};
    FDate : TFhirDate;
    FResponsible : TFhirReference{TFhirPractitionerRole};
    FPayee : TFhirReference{TFhirPractitioner};
    FAmount : TFhirMoney;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetPredecessor(value : TFhirIdentifier);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetRequest(value : TFhirReference{TFhirReference});
    Procedure SetSubmitter(value : TFhirReference{TFhirPractitioner});
    Procedure SetResponse(value : TFhirReference{TFhirReference});
    Procedure SetDate(value : TFhirDate);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetResponsible(value : TFhirReference{TFhirPractitionerRole});
    Procedure SetPayee(value : TFhirReference{TFhirPractitioner});
    Procedure SetAmount(value : TFhirMoney);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPaymentReconciliationDetail; overload;
    function Clone : TFhirPaymentReconciliationDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Unique identifier for the current payment item for the referenced payable. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Unique identifier for the current payment item for the referenced payable.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Unique identifier for the prior payment item for the referenced payable. (defined for API consistency)
    property predecessor : TFhirIdentifier read FPredecessor write SetPredecessor;
    // Unique identifier for the prior payment item for the referenced payable.
    property predecessorElement : TFhirIdentifier read FPredecessor write SetPredecessor;

    // Typed access to Code to indicate the nature of the payment. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Code to indicate the nature of the payment.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A resource, such as a Claim, the evaluation of which could lead to payment. (defined for API consistency)
    property request : TFhirReference{TFhirReference} read FRequest write SetRequest;
    // A resource, such as a Claim, the evaluation of which could lead to payment.
    property requestElement : TFhirReference{TFhirReference} read FRequest write SetRequest;

    // Typed access to The party which submitted the claim or financial transaction. (defined for API consistency)
    property submitter : TFhirReference{TFhirPractitioner} read FSubmitter write SetSubmitter;
    // The party which submitted the claim or financial transaction.
    property submitterElement : TFhirReference{TFhirPractitioner} read FSubmitter write SetSubmitter;

    // Typed access to A resource, such as a ClaimResponse, which contains a commitment to payment. (defined for API consistency)
    property response : TFhirReference{TFhirReference} read FResponse write SetResponse;
    // A resource, such as a ClaimResponse, which contains a commitment to payment.
    property responseElement : TFhirReference{TFhirReference} read FResponse write SetResponse;

    // Typed access to The date from the response resource containing a commitment to pay.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date from the response resource containing a commitment to pay.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to A reference to the individual who is responsible for inquiries regarding the response and its payment. (defined for API consistency)
    property responsible : TFhirReference{TFhirPractitionerRole} read FResponsible write SetResponsible;
    // A reference to the individual who is responsible for inquiries regarding the response and its payment.
    property responsibleElement : TFhirReference{TFhirPractitionerRole} read FResponsible write SetResponsible;

    // Typed access to The party which is receiving the payment. (defined for API consistency)
    property payee : TFhirReference{TFhirPractitioner} read FPayee write SetPayee;
    // The party which is receiving the payment.
    property payeeElement : TFhirReference{TFhirPractitioner} read FPayee write SetPayee;

    // Typed access to The monetary amount allocated from the total payment to the payable. (defined for API consistency)
    property amount : TFhirMoney read FAmount write SetAmount;
    // The monetary amount allocated from the total payment to the payable.
    property amountElement : TFhirMoney read FAmount write SetAmount;

  end;

  TFhirPaymentReconciliationDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPaymentReconciliationDetailList;
    function GetCurrent : TFhirPaymentReconciliationDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPaymentReconciliationDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPaymentReconciliationDetail read GetCurrent;
  end;

  TFhirPaymentReconciliationDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPaymentReconciliationDetail;
    procedure SetItemN(index : Integer; value : TFhirPaymentReconciliationDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPaymentReconciliationDetailList; Overload;
    function Clone : TFhirPaymentReconciliationDetailList; Overload;
    function GetEnumerator : TFhirPaymentReconciliationDetailListEnumerator;
    

    //  Add a FhirPaymentReconciliationDetail to the end of the list.
    function Append : TFhirPaymentReconciliationDetail;

    
    // Add an already existing FhirPaymentReconciliationDetail to the end of the list.
    procedure AddItem(value : TFhirPaymentReconciliationDetail); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPaymentReconciliationDetail) : Integer;
    

    // Insert FhirPaymentReconciliationDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPaymentReconciliationDetail;
    

    // Insert an existing FhirPaymentReconciliationDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPaymentReconciliationDetail);
    
    // Get the iIndexth FhirPaymentReconciliationDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPaymentReconciliationDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPaymentReconciliationDetail;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirPaymentReconciliationDetails[index : Integer] : TFhirPaymentReconciliationDetail read GetItemN write SetItemN; default;
  End;

  // A note that describes or explains the processing in a human readable form.
  TFhirPaymentReconciliationProcessNote = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FText : TFhirString;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirNoteTypeEnum;
    Procedure SetType_ST(value : TFhirNoteTypeEnum);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPaymentReconciliationProcessNote; overload;
    function Clone : TFhirPaymentReconciliationProcessNote; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The business purpose of the note text.
    property type_ : TFhirNoteTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The explanation or description associated with the processing.
    property text : String read GetTextST write SetTextST;
    // The explanation or description associated with the processing.
    property textElement : TFhirString read FText write SetText;

  end;

  TFhirPaymentReconciliationProcessNoteListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPaymentReconciliationProcessNoteList;
    function GetCurrent : TFhirPaymentReconciliationProcessNote;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPaymentReconciliationProcessNoteList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPaymentReconciliationProcessNote read GetCurrent;
  end;

  TFhirPaymentReconciliationProcessNoteList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPaymentReconciliationProcessNote;
    procedure SetItemN(index : Integer; value : TFhirPaymentReconciliationProcessNote);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPaymentReconciliationProcessNoteList; Overload;
    function Clone : TFhirPaymentReconciliationProcessNoteList; Overload;
    function GetEnumerator : TFhirPaymentReconciliationProcessNoteListEnumerator;
    

    //  Add a FhirPaymentReconciliationProcessNote to the end of the list.
    function Append : TFhirPaymentReconciliationProcessNote;

    
    // Add an already existing FhirPaymentReconciliationProcessNote to the end of the list.
    procedure AddItem(value : TFhirPaymentReconciliationProcessNote); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPaymentReconciliationProcessNote) : Integer;
    

    // Insert FhirPaymentReconciliationProcessNote before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPaymentReconciliationProcessNote;
    

    // Insert an existing FhirPaymentReconciliationProcessNote before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPaymentReconciliationProcessNote);
    
    // Get the iIndexth FhirPaymentReconciliationProcessNote. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPaymentReconciliationProcessNote);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPaymentReconciliationProcessNote;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirPaymentReconciliationProcessNotes[index : Integer] : TFhirPaymentReconciliationProcessNote read GetItemN write SetItemN; default;
  End;

  // This resource provides the details including amount of a payment and allocates the payment items being paid.
  TFhirPaymentReconciliation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FPeriod : TFhirPeriod;
    FCreated : TFhirDateTime;
    FPaymentIssuer : TFhirReference{TFhirOrganization};
    FRequest : TFhirReference{TFhirTask};
    FRequestor : TFhirReference{TFhirPractitioner};
    FOutcome : TFhirEnum;
    FDisposition : TFhirString;
    FPaymentDate : TFhirDate;
    FPaymentAmount : TFhirMoney;
    FPaymentIdentifier : TFhirIdentifier;
    FdetailList : TFhirPaymentReconciliationDetailList;
    FFormCode : TFhirCodeableConcept;
    FprocessNoteList : TFhirPaymentReconciliationProcessNoteList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetPaymentIssuer(value : TFhirReference{TFhirOrganization});
    Procedure SetRequest(value : TFhirReference{TFhirTask});
    Procedure SetRequestor(value : TFhirReference{TFhirPractitioner});
    Procedure SetOutcome(value : TFhirEnum);
    Function GetOutcomeST : TFhirRemittanceOutcomeEnum;
    Procedure SetOutcomeST(value : TFhirRemittanceOutcomeEnum);
    Procedure SetDisposition(value : TFhirString);
    Function GetDispositionST : String;
    Procedure SetDispositionST(value : String);
    Procedure SetPaymentDate(value : TFhirDate);
    Function GetPaymentDateST : TFslDateTime;
    Procedure SetPaymentDateST(value : TFslDateTime);
    Procedure SetPaymentAmount(value : TFhirMoney);
    Procedure SetPaymentIdentifier(value : TFhirIdentifier);
    function GetDetailList : TFhirPaymentReconciliationDetailList;
    function GetHasDetailList : Boolean;
    Procedure SetFormCode(value : TFhirCodeableConcept);
    function GetProcessNoteList : TFhirPaymentReconciliationProcessNoteList;
    function GetHasProcessNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPaymentReconciliation; overload;
    function Clone : TFhirPaymentReconciliation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A unique identifier assigned to this payment reconciliation.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The period of time for which payments have been gathered into this bulk payment for settlement. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time for which payments have been gathered into this bulk payment for settlement.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to The date when the resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date when the resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to The party who generated the payment. (defined for API consistency)
    property paymentIssuer : TFhirReference{TFhirOrganization} read FPaymentIssuer write SetPaymentIssuer;
    // The party who generated the payment.
    property paymentIssuerElement : TFhirReference{TFhirOrganization} read FPaymentIssuer write SetPaymentIssuer;

    // Typed access to Original request resource reference. (defined for API consistency)
    property request : TFhirReference{TFhirTask} read FRequest write SetRequest;
    // Original request resource reference.
    property requestElement : TFhirReference{TFhirTask} read FRequest write SetRequest;

    // Typed access to The practitioner who is responsible for the services rendered to the patient. (defined for API consistency)
    property requestor : TFhirReference{TFhirPractitioner} read FRequestor write SetRequestor;
    // The practitioner who is responsible for the services rendered to the patient.
    property requestorElement : TFhirReference{TFhirPractitioner} read FRequestor write SetRequestor;

    // The outcome of a request for a reconciliation.
    property outcome : TFhirRemittanceOutcomeEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A human readable description of the status of the request for the reconciliation.
    property disposition : String read GetDispositionST write SetDispositionST;
    // A human readable description of the status of the request for the reconciliation.
    property dispositionElement : TFhirString read FDisposition write SetDisposition;

    // Typed access to The date of payment as indicated on the financial instrument.
    property paymentDate : TFslDateTime read GetPaymentDateST write SetPaymentDateST;
    // The date of payment as indicated on the financial instrument.
    property paymentDateElement : TFhirDate read FPaymentDate write SetPaymentDate;

    // Typed access to Total payment amount as indicated on the financial instrument. (defined for API consistency)
    property paymentAmount : TFhirMoney read FPaymentAmount write SetPaymentAmount;
    // Total payment amount as indicated on the financial instrument.
    property paymentAmountElement : TFhirMoney read FPaymentAmount write SetPaymentAmount;

    // Typed access to Issuer's unique identifier for the payment instrument. (defined for API consistency)
    property paymentIdentifier : TFhirIdentifier read FPaymentIdentifier write SetPaymentIdentifier;
    // Issuer's unique identifier for the payment instrument.
    property paymentIdentifierElement : TFhirIdentifier read FPaymentIdentifier write SetPaymentIdentifier;

    // Distribution of the payment amount for a previously acknowledged payable.
    property detailList : TFhirPaymentReconciliationDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

    // Typed access to A code for the form to be used for printing the content. (defined for API consistency)
    property formCode : TFhirCodeableConcept read FFormCode write SetFormCode;
    // A code for the form to be used for printing the content.
    property formCodeElement : TFhirCodeableConcept read FFormCode write SetFormCode;

    // A note that describes or explains the processing in a human readable form.
    property processNoteList : TFhirPaymentReconciliationProcessNoteList read GetProcessNoteList;
    property hasProcessNoteList : boolean read GetHasProcessNoteList;

  end;

  TFhirPaymentReconciliationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPaymentReconciliationList;
    function GetCurrent : TFhirPaymentReconciliation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPaymentReconciliationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPaymentReconciliation read GetCurrent;
  end;

  TFhirPaymentReconciliationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPaymentReconciliation;
    procedure SetItemN(index : Integer; value : TFhirPaymentReconciliation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPaymentReconciliationList; Overload;
    function Clone : TFhirPaymentReconciliationList; Overload;
    function GetEnumerator : TFhirPaymentReconciliationListEnumerator;
    

    //  Add a FhirPaymentReconciliation to the end of the list.
    function Append : TFhirPaymentReconciliation;

    
    // Add an already existing FhirPaymentReconciliation to the end of the list.
    procedure AddItem(value : TFhirPaymentReconciliation); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPaymentReconciliation) : Integer;
    

    // Insert FhirPaymentReconciliation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPaymentReconciliation;
    

    // Insert an existing FhirPaymentReconciliation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPaymentReconciliation);
    
    // Get the iIndexth FhirPaymentReconciliation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPaymentReconciliation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPaymentReconciliation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirPaymentReconciliations[index : Integer] : TFhirPaymentReconciliation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PAYMENTRECONCILIATION}

implementation

uses
  fhir4_utilities;

{$IFDEF FHIR_CHARGEITEM}

{ TFhirChargeItemPerformer }

constructor TFhirChargeItemPerformer.Create;
begin
  inherited;
end;

destructor TFhirChargeItemPerformer.Destroy;
begin
  FFunction_.free;
  FActor.free;
  inherited;
end;

procedure TFhirChargeItemPerformer.Assign(oSource : TFslObject);
begin
  inherited;
  function_ := TFhirChargeItemPerformer(oSource).function_.Clone;
  actor := TFhirChargeItemPerformer(oSource).actor.Clone;
end;

procedure TFhirChargeItemPerformer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'function') Then
     list.add(self.link, 'function', FFunction_.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirChargeItemPerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', false, TFhirCodeableConcept, FFunction_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FActor.Link));{2}
end;

function TFhirChargeItemPerformer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'function') then
  begin
    Function_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirChargeItemPerformer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirChargeItemPerformer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'function') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'actor') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirChargeItemPerformer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirChargeItemPerformer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirChargeItemPerformer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'actor') then ActorElement := new as TFhirReference{TFhirPractitioner}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirChargeItemPerformer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirChargeItemPerformer.fhirType : string;
begin
  result := 'performer';
end;

function TFhirChargeItemPerformer.Link : TFhirChargeItemPerformer;
begin
  result := TFhirChargeItemPerformer(inherited Link);
end;

function TFhirChargeItemPerformer.Clone : TFhirChargeItemPerformer;
begin
  result := TFhirChargeItemPerformer(inherited Clone);
end;

function TFhirChargeItemPerformer.equals(other : TObject) : boolean; 
var
  o : TFhirChargeItemPerformer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirChargeItemPerformer)) then
    result := false
  else
  begin
    o := TFhirChargeItemPerformer(other);
    result := compareDeep(function_Element, o.function_Element, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirChargeItemPerformer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFunction_) and isEmptyProp(FActor);
end;

procedure TFhirChargeItemPerformer.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('function');
  fields.add('actor');
end;

{ TFhirChargeItemPerformer }

Procedure TFhirChargeItemPerformer.SetFunction_(value : TFhirCodeableConcept);
begin
  FFunction_.free;
  FFunction_ := value;
end;

Procedure TFhirChargeItemPerformer.SetActor(value : TFhirReference{TFhirPractitioner});
begin
  FActor.free;
  FActor := value;
end;

function TFhirChargeItemPerformer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FFunction_.sizeInBytes);
  inc(result, FActor.sizeInBytes);
end;

{ TFhirChargeItemPerformerListEnumerator }

Constructor TFhirChargeItemPerformerListEnumerator.Create(list : TFhirChargeItemPerformerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirChargeItemPerformerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirChargeItemPerformerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirChargeItemPerformerListEnumerator.GetCurrent : TFhirChargeItemPerformer;
begin
  Result := FList[FIndex];
end;

function TFhirChargeItemPerformerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirChargeItemPerformerList }
procedure TFhirChargeItemPerformerList.AddItem(value: TFhirChargeItemPerformer);
begin
  assert(value.ClassName = 'TFhirChargeItemPerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirChargeItemPerformer');
  add(value);
end;

function TFhirChargeItemPerformerList.Append: TFhirChargeItemPerformer;
begin
  result := TFhirChargeItemPerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemPerformerList.ClearItems;
begin
  Clear;
end;

function TFhirChargeItemPerformerList.GetEnumerator : TFhirChargeItemPerformerListEnumerator;
begin
  result := TFhirChargeItemPerformerListEnumerator.Create(self.link);
end;

function TFhirChargeItemPerformerList.Clone: TFhirChargeItemPerformerList;
begin
  result := TFhirChargeItemPerformerList(inherited Clone);
end;

function TFhirChargeItemPerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirChargeItemPerformerList.GetItemN(index: Integer): TFhirChargeItemPerformer;
begin
  result := TFhirChargeItemPerformer(ObjectByIndex[index]);
end;

function TFhirChargeItemPerformerList.ItemClass: TFslObjectClass;
begin
  result := TFhirChargeItemPerformer;
end;
function TFhirChargeItemPerformerList.IndexOf(value: TFhirChargeItemPerformer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirChargeItemPerformerList.Insert(index: Integer): TFhirChargeItemPerformer;
begin
  result := TFhirChargeItemPerformer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemPerformerList.InsertItem(index: Integer; value: TFhirChargeItemPerformer);
begin
  assert(value is TFhirChargeItemPerformer);
  Inherited Insert(index, value);
end;

function TFhirChargeItemPerformerList.Item(index: Integer): TFhirChargeItemPerformer;
begin
  result := TFhirChargeItemPerformer(ObjectByIndex[index]);
end;

function TFhirChargeItemPerformerList.Link: TFhirChargeItemPerformerList;
begin
  result := TFhirChargeItemPerformerList(inherited Link);
end;

procedure TFhirChargeItemPerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirChargeItemPerformerList.SetItemByIndex(index: Integer; value: TFhirChargeItemPerformer);
begin
  assert(value is TFhirChargeItemPerformer);
  FhirChargeItemPerformers[index] := value;
end;

procedure TFhirChargeItemPerformerList.SetItemN(index: Integer; value: TFhirChargeItemPerformer);
begin
  assert(value is TFhirChargeItemPerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirChargeItem }

constructor TFhirChargeItem.Create;
begin
  inherited;
end;

destructor TFhirChargeItem.Destroy;
begin
  FIdentifierList.Free;
  FDefinitionUriList.Free;
  FDefinitionCanonicalList.Free;
  FStatus.free;
  FPartOfList.Free;
  FCode.free;
  FSubject.free;
  FContext.free;
  FOccurrence.free;
  FPerformerList.Free;
  FPerformingOrganization.free;
  FRequestingOrganization.free;
  FCostCenter.free;
  FQuantity.free;
  FBodysiteList.Free;
  FFactorOverride.free;
  FPriceOverride.free;
  FOverrideReason.free;
  FEnterer.free;
  FEnteredDate.free;
  FReasonList.Free;
  FServiceList.Free;
  FProduct.free;
  FAccountList.Free;
  FNoteList.Free;
  FSupportingInformationList.Free;
  inherited;
end;

function TFhirChargeItem.GetResourceType : TFhirResourceType;
begin
  result := frtChargeItem;
end;

procedure TFhirChargeItem.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirChargeItem(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirChargeItem(oSource).FIdentifierList);
  end;
  if (TFhirChargeItem(oSource).FDefinitionUriList = nil) then
  begin
    FDefinitionUriList.free;
    FDefinitionUriList := nil;
  end
  else
  begin
    if FDefinitionUriList = nil then
      FDefinitionUriList := TFhirUriList.Create;
    FDefinitionUriList.Assign(TFhirChargeItem(oSource).FDefinitionUriList);
  end;
  if (TFhirChargeItem(oSource).FDefinitionCanonicalList = nil) then
  begin
    FDefinitionCanonicalList.free;
    FDefinitionCanonicalList := nil;
  end
  else
  begin
    if FDefinitionCanonicalList = nil then
      FDefinitionCanonicalList := TFhirCanonicalList.Create;
    FDefinitionCanonicalList.Assign(TFhirChargeItem(oSource).FDefinitionCanonicalList);
  end;
  FStatus := TFhirChargeItem(oSource).FStatus.Link;
  if (TFhirChargeItem(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList{TFhirChargeItem}.Create;
    FPartOfList.Assign(TFhirChargeItem(oSource).FPartOfList);
  end;
  code := TFhirChargeItem(oSource).code.Clone;
  subject := TFhirChargeItem(oSource).subject.Clone;
  context := TFhirChargeItem(oSource).context.Clone;
  occurrence := TFhirChargeItem(oSource).occurrence.Clone;
  if (TFhirChargeItem(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirChargeItemPerformerList.Create;
    FPerformerList.Assign(TFhirChargeItem(oSource).FPerformerList);
  end;
  performingOrganization := TFhirChargeItem(oSource).performingOrganization.Clone;
  requestingOrganization := TFhirChargeItem(oSource).requestingOrganization.Clone;
  costCenter := TFhirChargeItem(oSource).costCenter.Clone;
  quantity := TFhirChargeItem(oSource).quantity.Clone;
  if (TFhirChargeItem(oSource).FBodysiteList = nil) then
  begin
    FBodysiteList.free;
    FBodysiteList := nil;
  end
  else
  begin
    if FBodysiteList = nil then
      FBodysiteList := TFhirCodeableConceptList.Create;
    FBodysiteList.Assign(TFhirChargeItem(oSource).FBodysiteList);
  end;
  factorOverrideElement := TFhirChargeItem(oSource).factorOverrideElement.Clone;
  priceOverride := TFhirChargeItem(oSource).priceOverride.Clone;
  overrideReasonElement := TFhirChargeItem(oSource).overrideReasonElement.Clone;
  enterer := TFhirChargeItem(oSource).enterer.Clone;
  enteredDateElement := TFhirChargeItem(oSource).enteredDateElement.Clone;
  if (TFhirChargeItem(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirChargeItem(oSource).FReasonList);
  end;
  if (TFhirChargeItem(oSource).FServiceList = nil) then
  begin
    FServiceList.free;
    FServiceList := nil;
  end
  else
  begin
    if FServiceList = nil then
      FServiceList := TFhirReferenceList{TFhirDiagnosticReport}.Create;
    FServiceList.Assign(TFhirChargeItem(oSource).FServiceList);
  end;
  product := TFhirChargeItem(oSource).product.Clone;
  if (TFhirChargeItem(oSource).FAccountList = nil) then
  begin
    FAccountList.free;
    FAccountList := nil;
  end
  else
  begin
    if FAccountList = nil then
      FAccountList := TFhirReferenceList{TFhirAccount}.Create;
    FAccountList.Assign(TFhirChargeItem(oSource).FAccountList);
  end;
  if (TFhirChargeItem(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirChargeItem(oSource).FNoteList);
  end;
  if (TFhirChargeItem(oSource).FSupportingInformationList = nil) then
  begin
    FSupportingInformationList.free;
    FSupportingInformationList := nil;
  end
  else
  begin
    if FSupportingInformationList = nil then
      FSupportingInformationList := TFhirReferenceList{TFhirReference}.Create;
    FSupportingInformationList.Assign(TFhirChargeItem(oSource).FSupportingInformationList);
  end;
end;

procedure TFhirChargeItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'definitionUri') Then
    list.addAll(self, 'definitionUri', FDefinitionUriList);
  if (child_name = 'definitionCanonical') Then
    list.addAll(self, 'definitionCanonical', FDefinitionCanonicalList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'performingOrganization') Then
     list.add(self.link, 'performingOrganization', FPerformingOrganization.Link);
  if (child_name = 'requestingOrganization') Then
     list.add(self.link, 'requestingOrganization', FRequestingOrganization.Link);
  if (child_name = 'costCenter') Then
     list.add(self.link, 'costCenter', FCostCenter.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'bodysite') Then
    list.addAll(self, 'bodysite', FBodysiteList);
  if (child_name = 'factorOverride') Then
     list.add(self.link, 'factorOverride', FFactorOverride.Link);
  if (child_name = 'priceOverride') Then
     list.add(self.link, 'priceOverride', FPriceOverride.Link);
  if (child_name = 'overrideReason') Then
     list.add(self.link, 'overrideReason', FOverrideReason.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'enteredDate') Then
     list.add(self.link, 'enteredDate', FEnteredDate.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'service') Then
    list.addAll(self, 'service', FServiceList);
  if (child_name = 'product[x]') or (child_name = 'product') Then
     list.add(self.link, 'product[x]', FProduct.Link);
  if (child_name = 'account') Then
    list.addAll(self, 'account', FAccountList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'supportingInformation') Then
    list.addAll(self, 'supportingInformation', FSupportingInformationList);
end;

procedure TFhirChargeItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'definitionUri', 'uri', true, TFhirUri, FDefinitionUriList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'definitionCanonical', 'canonical', true, TFhirCanonical, FDefinitionCanonicalList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference(ChargeItem)', true, TFhirReference{TFhirChargeItem}, FPartOfList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|Timing', false, TFhirType, FOccurrence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', '', true, TFhirChargeItemPerformer, FPerformerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'performingOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FPerformingOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestingOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FRequestingOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'costCenter', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FCostCenter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'bodysite', 'CodeableConcept', true, TFhirCodeableConcept, FBodysiteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'factorOverride', 'decimal', false, TFhirDecimal, FFactorOverride.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priceOverride', 'Money', false, TFhirMoney, FPriceOverride.Link));{2}
  oList.add(TFHIRProperty.create(self, 'overrideReason', 'string', false, TFhirString, FOverrideReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FEnterer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'enteredDate', 'dateTime', false, TFhirDateTime, FEnteredDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'service', 'Reference(DiagnosticReport)', true, TFhirReference{TFhirDiagnosticReport}, FServiceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'product[x]', 'Reference(Device)|CodeableConcept', false, TFhirType, FProduct.Link));{2}
  oList.add(TFHIRProperty.create(self, 'account', 'Reference(Account)', true, TFhirReference{TFhirAccount}, FAccountList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'Reference(Any)', true, TFhirReference{TFhirReference}, FSupportingInformationList.Link)){3};
end;

function TFhirChargeItem.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'definitionUri') then
  begin
    DefinitionUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'definitionCanonical') then
  begin
    DefinitionCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirChargeitemStatusEnum, CODES_TFhirChargeitemStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference{TFhirChargeItem}){2a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirChargeItemPerformer){2a};
    result := propValue;
  end
  else if (propName = 'performingOrganization') then
  begin
    PerformingOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'requestingOrganization') then
  begin
    RequestingOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'costCenter') then
  begin
    CostCenter := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'bodysite') then
  begin
    BodysiteList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'factorOverride') then
  begin
    FactorOverrideElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'priceOverride') then
  begin
    PriceOverride := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'overrideReason') then
  begin
    OverrideReasonElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'enteredDate') then
  begin
    EnteredDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'service') then
  begin
    ServiceList.add(propValue as TFhirReference{TFhirDiagnosticReport}){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then
  begin
    Product := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'account') then
  begin
    AccountList.add(propValue as TFhirReference{TFhirAccount}){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirChargeItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'definitionUri') then DefinitionUriList.insertItem(index, asUri(propValue)){2}
  else if (propName = 'definitionCanonical') then DefinitionCanonicalList.insertItem(index, asCanonical(propValue)){2}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference{TFhirChargeItem}){2a}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirChargeItemPerformer){2a}
  else if (propName = 'bodysite') then BodysiteList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'service') then ServiceList.insertItem(index, propValue as TFhirReference{TFhirDiagnosticReport}){2a}
  else if (propName = 'account') then AccountList.insertItem(index, propValue as TFhirReference{TFhirAccount}){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'supportingInformation') then SupportingInformationList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else inherited;
end;

function TFhirChargeItem.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'definitionUri') then result := DefinitionUriList.new(){2}
  else if (propName = 'definitionCanonical') then result := DefinitionCanonicalList.new(){2}
  else if (propName = 'partOf') then result := PartOfList.new(){2}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence'){4x}
  else if (propName = 'performer') then result := PerformerList.new(){2}
  else if (propName = 'performingOrganization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'requestingOrganization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'costCenter') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'bodysite') then result := BodysiteList.new(){2}
  else if (propName = 'factorOverride') then result := TFhirDecimal.create() {5b}
  else if (propName = 'priceOverride') then result := TFhirMoney.create(){4b}
  else if (propName = 'overrideReason') then result := TFhirString.create() {5b}
  else if (propName = 'enterer') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'enteredDate') then result := TFhirDateTime.create() {5b}
  else if (propName = 'reason') then result := ReasonList.new(){2}
  else if (propName = 'service') then result := ServiceList.new(){2}
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Product'){4x}
  else if (propName = 'account') then result := AccountList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'supportingInformation') then result := SupportingInformationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirChargeItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'definitionUri') then result := 'uri'
  else if (propName = 'definitionCanonical') then result := 'canonical'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'performer') then result := ''
  else if (propName = 'performingOrganization') then result := 'Reference'
  else if (propName = 'requestingOrganization') then result := 'Reference'
  else if (propName = 'costCenter') then result := 'Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'bodysite') then result := 'CodeableConcept'
  else if (propName = 'factorOverride') then result := 'decimal'
  else if (propName = 'priceOverride') then result := 'Money'
  else if (propName = 'overrideReason') then result := 'string'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'enteredDate') then result := 'dateTime'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'service') then result := 'Reference'
  else if (propName = 'product[x]') then result := 'Reference|CodeableConcept'
  else if (propName = 'account') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'supportingInformation') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirChargeItem.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'definitionUri') then deletePropertyValue('definitionUri', DefinitionUriList, value) {2}
  else if (propName = 'definitionCanonical') then deletePropertyValue('definitionCanonical', DefinitionCanonicalList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {2}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := nil{4x}
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {2}
  else if (propName = 'performingOrganization') then PerformingOrganizationElement := nil
  else if (propName = 'requestingOrganization') then RequestingOrganizationElement := nil
  else if (propName = 'costCenter') then CostCenterElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'bodysite') then deletePropertyValue('bodysite', BodysiteList, value) {2}
  else if (propName = 'factorOverride') then FactorOverrideElement := nil
  else if (propName = 'priceOverride') then PriceOverrideElement := nil
  else if (propName = 'overrideReason') then OverrideReasonElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'enteredDate') then EnteredDateElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {2}
  else if (propName = 'service') then deletePropertyValue('service', ServiceList, value) {2}
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then ProductElement := nil{4x}
  else if (propName = 'account') then deletePropertyValue('account', AccountList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'supportingInformation') then deletePropertyValue('supportingInformation', SupportingInformationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirChargeItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'definitionUri') then replacePropertyValue('definitionUri', DefinitionUriList, existing, new) {2}
  else if (propName = 'definitionCanonical') then replacePropertyValue('definitionCanonical', DefinitionCanonicalList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirChargeitemStatusEnum, CODES_TFhirChargeitemStatusEnum, new){4}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {2}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{TFhirEncounter}{4}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := new as TFhirType{4x}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {2}
  else if (propName = 'performingOrganization') then PerformingOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'requestingOrganization') then RequestingOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'costCenter') then CostCenterElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'bodysite') then replacePropertyValue('bodysite', BodysiteList, existing, new) {2}
  else if (propName = 'factorOverride') then FactorOverrideElement := asDecimal(new){5b}
  else if (propName = 'priceOverride') then PriceOverrideElement := new as TFhirMoney{4}
  else if (propName = 'overrideReason') then OverrideReasonElement := asString(new){5b}
  else if (propName = 'enterer') then EntererElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'enteredDate') then EnteredDateElement := asDateTime(new){5b}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {2}
  else if (propName = 'service') then replacePropertyValue('service', ServiceList, existing, new) {2}
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then ProductElement := new as TFhirType{4x}
  else if (propName = 'account') then replacePropertyValue('account', AccountList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'supportingInformation') then replacePropertyValue('supportingInformation', SupportingInformationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirChargeItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'definitionUri') then DefinitionUriList.move(source, destination){2}
  else if (propName = 'definitionCanonical') then DefinitionCanonicalList.move(source, destination){2}
  else if (propName = 'partOf') then PartOfList.move(source, destination){2a}
  else if (propName = 'performer') then PerformerList.move(source, destination){2a}
  else if (propName = 'bodysite') then BodysiteList.move(source, destination){2a}
  else if (propName = 'reason') then ReasonList.move(source, destination){2a}
  else if (propName = 'service') then ServiceList.move(source, destination){2a}
  else if (propName = 'account') then AccountList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'supportingInformation') then SupportingInformationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirChargeItem.fhirType : string;
begin
  result := 'ChargeItem';
end;

function TFhirChargeItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FdefinitionUriList) and isEmptyProp(FdefinitionCanonicalList) and isEmptyProp(FStatus) and isEmptyProp(FpartOfList) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FOccurrence) and isEmptyProp(FperformerList) and isEmptyProp(FPerformingOrganization) and isEmptyProp(FRequestingOrganization) and isEmptyProp(FCostCenter) and isEmptyProp(FQuantity) and isEmptyProp(FbodysiteList) and isEmptyProp(FFactorOverride) and isEmptyProp(FPriceOverride) and isEmptyProp(FOverrideReason) and isEmptyProp(FEnterer) and isEmptyProp(FEnteredDate) and isEmptyProp(FreasonList) and isEmptyProp(FserviceList) and isEmptyProp(FProduct) and isEmptyProp(FaccountList) and isEmptyProp(FnoteList) and isEmptyProp(FsupportingInformationList);
end;

function TFhirChargeItem.equals(other : TObject) : boolean; 
var
  o : TFhirChargeItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirChargeItem)) then
    result := false
  else
  begin
    o := TFhirChargeItem(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(definitionUriList, o.definitionUriList, true) and 
      compareDeep(definitionCanonicalList, o.definitionCanonicalList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(partOfList, o.partOfList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(contextElement, o.contextElement, true) and 
      compareDeep(occurrenceElement, o.occurrenceElement, true) and compareDeep(performerList, o.performerList, true) and 
      compareDeep(performingOrganizationElement, o.performingOrganizationElement, true) and 
      compareDeep(requestingOrganizationElement, o.requestingOrganizationElement, true) and 
      compareDeep(costCenterElement, o.costCenterElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(bodysiteList, o.bodysiteList, true) and compareDeep(factorOverrideElement, o.factorOverrideElement, true) and 
      compareDeep(priceOverrideElement, o.priceOverrideElement, true) and compareDeep(overrideReasonElement, o.overrideReasonElement, true) and 
      compareDeep(entererElement, o.entererElement, true) and compareDeep(enteredDateElement, o.enteredDateElement, true) and 
      compareDeep(reasonList, o.reasonList, true) and compareDeep(serviceList, o.serviceList, true) and 
      compareDeep(productElement, o.productElement, true) and compareDeep(accountList, o.accountList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(supportingInformationList, o.supportingInformationList, true);
  end;
end;

function TFhirChargeItem.Link : TFhirChargeItem;
begin
  result := TFhirChargeItem(inherited Link);
end;

function TFhirChargeItem.Clone : TFhirChargeItem;
begin
  result := TFhirChargeItem(inherited Clone);
end;

procedure TFhirChargeItem.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('definitionUri');
  fields.add('definitionCanonical');
  fields.add('status');
  fields.add('partOf');
  fields.add('code');
  fields.add('subject');
  fields.add('context');
  fields.add('occurrence[x]');
  fields.add('performer');
  fields.add('performingOrganization');
  fields.add('requestingOrganization');
  fields.add('costCenter');
  fields.add('quantity');
  fields.add('bodysite');
  fields.add('factorOverride');
  fields.add('priceOverride');
  fields.add('overrideReason');
  fields.add('enterer');
  fields.add('enteredDate');
  fields.add('reason');
  fields.add('service');
  fields.add('product[x]');
  fields.add('account');
  fields.add('note');
  fields.add('supportingInformation');
end;

{ TFhirChargeItem }

Function TFhirChargeItem.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirChargeItem.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirChargeItem.GetDefinitionUriList : TFhirUriList;
begin
  if FDefinitionUriList = nil then
    FDefinitionUriList := TFhirUriList.Create;
  result := FDefinitionUriList;
end;

Function TFhirChargeItem.GetHasDefinitionUriList : boolean;
begin
  result := (FDefinitionUriList <> nil) and (FDefinitionUriList.count > 0);
end;

Function TFhirChargeItem.GetDefinitionCanonicalList : TFhirCanonicalList;
begin
  if FDefinitionCanonicalList = nil then
    FDefinitionCanonicalList := TFhirCanonicalList.Create;
  result := FDefinitionCanonicalList;
end;

Function TFhirChargeItem.GetHasDefinitionCanonicalList : boolean;
begin
  result := (FDefinitionCanonicalList <> nil) and (FDefinitionCanonicalList.count > 0);
end;

Procedure TFhirChargeItem.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirChargeItem.GetStatusST : TFhirChargeitemStatusEnum;
begin
  if FStatus = nil then
    result := TFhirChargeitemStatusEnum(0)
  else
    result := TFhirChargeitemStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirChargeitemStatusEnum, FStatus.value));
end;

Procedure TFhirChargeItem.SetStatusST(value : TFhirChargeitemStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirChargeitemStatusEnum[value], CODES_TFhirChargeitemStatusEnum[value]);
end;

Function TFhirChargeItem.GetPartOfList : TFhirReferenceList{TFhirChargeItem};
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList{TFhirChargeItem}.Create;
  result := FPartOfList;
end;

Function TFhirChargeItem.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

Procedure TFhirChargeItem.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirChargeItem.SetSubject(value : TFhirReference{TFhirPatient});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirChargeItem.SetContext(value : TFhirReference{TFhirEncounter});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirChargeItem.SetOccurrence(value : TFhirType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

Function TFhirChargeItem.GetPerformerList : TFhirChargeItemPerformerList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirChargeItemPerformerList.Create;
  result := FPerformerList;
end;

Function TFhirChargeItem.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

Procedure TFhirChargeItem.SetPerformingOrganization(value : TFhirReference{TFhirOrganization});
begin
  FPerformingOrganization.free;
  FPerformingOrganization := value;
end;

Procedure TFhirChargeItem.SetRequestingOrganization(value : TFhirReference{TFhirOrganization});
begin
  FRequestingOrganization.free;
  FRequestingOrganization := value;
end;

Procedure TFhirChargeItem.SetCostCenter(value : TFhirReference{TFhirOrganization});
begin
  FCostCenter.free;
  FCostCenter := value;
end;

Procedure TFhirChargeItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Function TFhirChargeItem.GetBodysiteList : TFhirCodeableConceptList;
begin
  if FBodysiteList = nil then
    FBodysiteList := TFhirCodeableConceptList.Create;
  result := FBodysiteList;
end;

Function TFhirChargeItem.GetHasBodysiteList : boolean;
begin
  result := (FBodysiteList <> nil) and (FBodysiteList.count > 0);
end;

Procedure TFhirChargeItem.SetFactorOverride(value : TFhirDecimal);
begin
  FFactorOverride.free;
  FFactorOverride := value;
end;

Function TFhirChargeItem.GetFactorOverrideST : String;
begin
  if FFactorOverride = nil then
    result := ''
  else
    result := FFactorOverride.value;
end;

Procedure TFhirChargeItem.SetFactorOverrideST(value : String);
begin
  if value <> '' then
  begin
    if FFactorOverride = nil then
      FFactorOverride := TFhirDecimal.create;
    FFactorOverride.value := value
  end
  else if FFactorOverride <> nil then
    FFactorOverride.value := '';
end;

Procedure TFhirChargeItem.SetPriceOverride(value : TFhirMoney);
begin
  FPriceOverride.free;
  FPriceOverride := value;
end;

Procedure TFhirChargeItem.SetOverrideReason(value : TFhirString);
begin
  FOverrideReason.free;
  FOverrideReason := value;
end;

Function TFhirChargeItem.GetOverrideReasonST : String;
begin
  if FOverrideReason = nil then
    result := ''
  else
    result := FOverrideReason.value;
end;

Procedure TFhirChargeItem.SetOverrideReasonST(value : String);
begin
  if value <> '' then
  begin
    if FOverrideReason = nil then
      FOverrideReason := TFhirString.create;
    FOverrideReason.value := value
  end
  else if FOverrideReason <> nil then
    FOverrideReason.value := '';
end;

Procedure TFhirChargeItem.SetEnterer(value : TFhirReference{TFhirPractitioner});
begin
  FEnterer.free;
  FEnterer := value;
end;

Procedure TFhirChargeItem.SetEnteredDate(value : TFhirDateTime);
begin
  FEnteredDate.free;
  FEnteredDate := value;
end;

Function TFhirChargeItem.GetEnteredDateST : TFslDateTime;
begin
  if FEnteredDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnteredDate.value;
end;

Procedure TFhirChargeItem.SetEnteredDateST(value : TFslDateTime);
begin
  if FEnteredDate = nil then
    FEnteredDate := TFhirDateTime.create;
  FEnteredDate.value := value
end;

Function TFhirChargeItem.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

Function TFhirChargeItem.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

Function TFhirChargeItem.GetServiceList : TFhirReferenceList{TFhirDiagnosticReport};
begin
  if FServiceList = nil then
    FServiceList := TFhirReferenceList{TFhirDiagnosticReport}.Create;
  result := FServiceList;
end;

Function TFhirChargeItem.GetHasServiceList : boolean;
begin
  result := (FServiceList <> nil) and (FServiceList.count > 0);
end;

Procedure TFhirChargeItem.SetProduct(value : TFhirType);
begin
  FProduct.free;
  FProduct := value;
end;

Function TFhirChargeItem.GetAccountList : TFhirReferenceList{TFhirAccount};
begin
  if FAccountList = nil then
    FAccountList := TFhirReferenceList{TFhirAccount}.Create;
  result := FAccountList;
end;

Function TFhirChargeItem.GetHasAccountList : boolean;
begin
  result := (FAccountList <> nil) and (FAccountList.count > 0);
end;

Function TFhirChargeItem.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirChargeItem.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirChargeItem.GetSupportingInformationList : TFhirReferenceList{TFhirReference};
begin
  if FSupportingInformationList = nil then
    FSupportingInformationList := TFhirReferenceList{TFhirReference}.Create;
  result := FSupportingInformationList;
end;

Function TFhirChargeItem.GetHasSupportingInformationList : boolean;
begin
  result := (FSupportingInformationList <> nil) and (FSupportingInformationList.count > 0);
end;

function TFhirChargeItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FdefinitionUriList.sizeInBytes);
  inc(result, FdefinitionCanonicalList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FPerformingOrganization.sizeInBytes);
  inc(result, FRequestingOrganization.sizeInBytes);
  inc(result, FCostCenter.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FbodysiteList.sizeInBytes);
  inc(result, FFactorOverride.sizeInBytes);
  inc(result, FPriceOverride.sizeInBytes);
  inc(result, FOverrideReason.sizeInBytes);
  inc(result, FEnterer.sizeInBytes);
  inc(result, FEnteredDate.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FserviceList.sizeInBytes);
  inc(result, FProduct.sizeInBytes);
  inc(result, FaccountList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FsupportingInformationList.sizeInBytes);
end;

{ TFhirChargeItemListEnumerator }

Constructor TFhirChargeItemListEnumerator.Create(list : TFhirChargeItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirChargeItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirChargeItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirChargeItemListEnumerator.GetCurrent : TFhirChargeItem;
begin
  Result := FList[FIndex];
end;

function TFhirChargeItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirChargeItemList }
procedure TFhirChargeItemList.AddItem(value: TFhirChargeItem);
begin
  assert(value.ClassName = 'TFhirChargeItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirChargeItem');
  add(value);
end;

function TFhirChargeItemList.Append: TFhirChargeItem;
begin
  result := TFhirChargeItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemList.ClearItems;
begin
  Clear;
end;

function TFhirChargeItemList.GetEnumerator : TFhirChargeItemListEnumerator;
begin
  result := TFhirChargeItemListEnumerator.Create(self.link);
end;

function TFhirChargeItemList.Clone: TFhirChargeItemList;
begin
  result := TFhirChargeItemList(inherited Clone);
end;

function TFhirChargeItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirChargeItemList.GetItemN(index: Integer): TFhirChargeItem;
begin
  result := TFhirChargeItem(ObjectByIndex[index]);
end;

function TFhirChargeItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirChargeItem;
end;
function TFhirChargeItemList.IndexOf(value: TFhirChargeItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirChargeItemList.Insert(index: Integer): TFhirChargeItem;
begin
  result := TFhirChargeItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirChargeItemList.InsertItem(index: Integer; value: TFhirChargeItem);
begin
  assert(value is TFhirChargeItem);
  Inherited Insert(index, value);
end;

function TFhirChargeItemList.Item(index: Integer): TFhirChargeItem;
begin
  result := TFhirChargeItem(ObjectByIndex[index]);
end;

function TFhirChargeItemList.Link: TFhirChargeItemList;
begin
  result := TFhirChargeItemList(inherited Link);
end;

procedure TFhirChargeItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirChargeItemList.SetItemByIndex(index: Integer; value: TFhirChargeItem);
begin
  assert(value is TFhirChargeItem);
  FhirChargeItems[index] := value;
end;

procedure TFhirChargeItemList.SetItemN(index: Integer; value: TFhirChargeItem);
begin
  assert(value is TFhirChargeItem);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CHARGEITEM}

{$IFDEF FHIR_CLAIM}

{ TFhirClaimRelated }

constructor TFhirClaimRelated.Create;
begin
  inherited;
end;

destructor TFhirClaimRelated.Destroy;
begin
  FClaim.free;
  FRelationship.free;
  FReference.free;
  inherited;
end;

procedure TFhirClaimRelated.Assign(oSource : TFslObject);
begin
  inherited;
  claim := TFhirClaimRelated(oSource).claim.Clone;
  relationship := TFhirClaimRelated(oSource).relationship.Clone;
  reference := TFhirClaimRelated(oSource).reference.Clone;
end;

procedure TFhirClaimRelated.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'claim') Then
     list.add(self.link, 'claim', FClaim.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirClaimRelated.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'claim', 'Reference(Claim)', false, TFhirReference{TFhirClaim}, FClaim.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', false, TFhirCodeableConcept, FRelationship.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'Identifier', false, TFhirIdentifier, FReference.Link));{2}
end;

function TFhirClaimRelated.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'claim') then
  begin
    Claim := propValue as TFhirReference{TFhirClaim}{4b};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimRelated.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimRelated.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'claim') then result := TFhirReference{TFhirClaim}.create(){4b}
  else if (propName = 'relationship') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reference') then result := TFhirIdentifier.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimRelated.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'claim') then result := 'Reference'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'reference') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimRelated.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'claim') then ClaimElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimRelated.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'claim') then ClaimElement := new as TFhirReference{TFhirClaim}{4}
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCodeableConcept{4}
  else if (propName = 'reference') then ReferenceElement := new as TFhirIdentifier{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimRelated.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimRelated.fhirType : string;
begin
  result := 'related';
end;

function TFhirClaimRelated.Link : TFhirClaimRelated;
begin
  result := TFhirClaimRelated(inherited Link);
end;

function TFhirClaimRelated.Clone : TFhirClaimRelated;
begin
  result := TFhirClaimRelated(inherited Clone);
end;

function TFhirClaimRelated.equals(other : TObject) : boolean; 
var
  o : TFhirClaimRelated;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimRelated)) then
    result := false
  else
  begin
    o := TFhirClaimRelated(other);
    result := compareDeep(claimElement, o.claimElement, true) and compareDeep(relationshipElement, o.relationshipElement, true) and 
      compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirClaimRelated.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FClaim) and isEmptyProp(FRelationship) and isEmptyProp(FReference);
end;

procedure TFhirClaimRelated.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('claim');
  fields.add('relationship');
  fields.add('reference');
end;

{ TFhirClaimRelated }

Procedure TFhirClaimRelated.SetClaim(value : TFhirReference{TFhirClaim});
begin
  FClaim.free;
  FClaim := value;
end;

Procedure TFhirClaimRelated.SetRelationship(value : TFhirCodeableConcept);
begin
  FRelationship.free;
  FRelationship := value;
end;

Procedure TFhirClaimRelated.SetReference(value : TFhirIdentifier);
begin
  FReference.free;
  FReference := value;
end;

function TFhirClaimRelated.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FClaim.sizeInBytes);
  inc(result, FRelationship.sizeInBytes);
  inc(result, FReference.sizeInBytes);
end;

{ TFhirClaimRelatedListEnumerator }

Constructor TFhirClaimRelatedListEnumerator.Create(list : TFhirClaimRelatedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimRelatedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimRelatedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimRelatedListEnumerator.GetCurrent : TFhirClaimRelated;
begin
  Result := FList[FIndex];
end;

function TFhirClaimRelatedListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimRelatedList }
procedure TFhirClaimRelatedList.AddItem(value: TFhirClaimRelated);
begin
  assert(value.ClassName = 'TFhirClaimRelated', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimRelated');
  add(value);
end;

function TFhirClaimRelatedList.Append: TFhirClaimRelated;
begin
  result := TFhirClaimRelated.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimRelatedList.ClearItems;
begin
  Clear;
end;

function TFhirClaimRelatedList.GetEnumerator : TFhirClaimRelatedListEnumerator;
begin
  result := TFhirClaimRelatedListEnumerator.Create(self.link);
end;

function TFhirClaimRelatedList.Clone: TFhirClaimRelatedList;
begin
  result := TFhirClaimRelatedList(inherited Clone);
end;

function TFhirClaimRelatedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimRelatedList.GetItemN(index: Integer): TFhirClaimRelated;
begin
  result := TFhirClaimRelated(ObjectByIndex[index]);
end;

function TFhirClaimRelatedList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimRelated;
end;
function TFhirClaimRelatedList.IndexOf(value: TFhirClaimRelated): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimRelatedList.Insert(index: Integer): TFhirClaimRelated;
begin
  result := TFhirClaimRelated.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimRelatedList.InsertItem(index: Integer; value: TFhirClaimRelated);
begin
  assert(value is TFhirClaimRelated);
  Inherited Insert(index, value);
end;

function TFhirClaimRelatedList.Item(index: Integer): TFhirClaimRelated;
begin
  result := TFhirClaimRelated(ObjectByIndex[index]);
end;

function TFhirClaimRelatedList.Link: TFhirClaimRelatedList;
begin
  result := TFhirClaimRelatedList(inherited Link);
end;

procedure TFhirClaimRelatedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimRelatedList.SetItemByIndex(index: Integer; value: TFhirClaimRelated);
begin
  assert(value is TFhirClaimRelated);
  FhirClaimRelateds[index] := value;
end;

procedure TFhirClaimRelatedList.SetItemN(index: Integer; value: TFhirClaimRelated);
begin
  assert(value is TFhirClaimRelated);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimPayee }

constructor TFhirClaimPayee.Create;
begin
  inherited;
end;

destructor TFhirClaimPayee.Destroy;
begin
  FType_.free;
  FParty.free;
  inherited;
end;

procedure TFhirClaimPayee.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirClaimPayee(oSource).type_.Clone;
  party := TFhirClaimPayee(oSource).party.Clone;
end;

procedure TFhirClaimPayee.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
end;

procedure TFhirClaimPayee.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'party', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FParty.Link));{2}
end;

function TFhirClaimPayee.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    Party := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimPayee.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimPayee.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'party') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimPayee.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'party') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimPayee.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'party') then PartyElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimPayee.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'party') then PartyElement := new as TFhirReference{TFhirPractitioner}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimPayee.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimPayee.fhirType : string;
begin
  result := 'payee';
end;

function TFhirClaimPayee.Link : TFhirClaimPayee;
begin
  result := TFhirClaimPayee(inherited Link);
end;

function TFhirClaimPayee.Clone : TFhirClaimPayee;
begin
  result := TFhirClaimPayee(inherited Clone);
end;

function TFhirClaimPayee.equals(other : TObject) : boolean; 
var
  o : TFhirClaimPayee;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimPayee)) then
    result := false
  else
  begin
    o := TFhirClaimPayee(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(partyElement, o.partyElement, true);
  end;
end;

function TFhirClaimPayee.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FParty);
end;

procedure TFhirClaimPayee.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('party');
end;

{ TFhirClaimPayee }

Procedure TFhirClaimPayee.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirClaimPayee.SetParty(value : TFhirReference{TFhirPractitioner});
begin
  FParty.free;
  FParty := value;
end;

function TFhirClaimPayee.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FParty.sizeInBytes);
end;

{ TFhirClaimPayeeListEnumerator }

Constructor TFhirClaimPayeeListEnumerator.Create(list : TFhirClaimPayeeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimPayeeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimPayeeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimPayeeListEnumerator.GetCurrent : TFhirClaimPayee;
begin
  Result := FList[FIndex];
end;

function TFhirClaimPayeeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimPayeeList }
procedure TFhirClaimPayeeList.AddItem(value: TFhirClaimPayee);
begin
  assert(value.ClassName = 'TFhirClaimPayee', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimPayee');
  add(value);
end;

function TFhirClaimPayeeList.Append: TFhirClaimPayee;
begin
  result := TFhirClaimPayee.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimPayeeList.ClearItems;
begin
  Clear;
end;

function TFhirClaimPayeeList.GetEnumerator : TFhirClaimPayeeListEnumerator;
begin
  result := TFhirClaimPayeeListEnumerator.Create(self.link);
end;

function TFhirClaimPayeeList.Clone: TFhirClaimPayeeList;
begin
  result := TFhirClaimPayeeList(inherited Clone);
end;

function TFhirClaimPayeeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimPayeeList.GetItemN(index: Integer): TFhirClaimPayee;
begin
  result := TFhirClaimPayee(ObjectByIndex[index]);
end;

function TFhirClaimPayeeList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimPayee;
end;
function TFhirClaimPayeeList.IndexOf(value: TFhirClaimPayee): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimPayeeList.Insert(index: Integer): TFhirClaimPayee;
begin
  result := TFhirClaimPayee.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimPayeeList.InsertItem(index: Integer; value: TFhirClaimPayee);
begin
  assert(value is TFhirClaimPayee);
  Inherited Insert(index, value);
end;

function TFhirClaimPayeeList.Item(index: Integer): TFhirClaimPayee;
begin
  result := TFhirClaimPayee(ObjectByIndex[index]);
end;

function TFhirClaimPayeeList.Link: TFhirClaimPayeeList;
begin
  result := TFhirClaimPayeeList(inherited Link);
end;

procedure TFhirClaimPayeeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimPayeeList.SetItemByIndex(index: Integer; value: TFhirClaimPayee);
begin
  assert(value is TFhirClaimPayee);
  FhirClaimPayees[index] := value;
end;

procedure TFhirClaimPayeeList.SetItemN(index: Integer; value: TFhirClaimPayee);
begin
  assert(value is TFhirClaimPayee);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimCareTeam }

constructor TFhirClaimCareTeam.Create;
begin
  inherited;
end;

destructor TFhirClaimCareTeam.Destroy;
begin
  FSequence.free;
  FProvider.free;
  FResponsible.free;
  FRole.free;
  FQualification.free;
  inherited;
end;

procedure TFhirClaimCareTeam.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimCareTeam(oSource).sequenceElement.Clone;
  provider := TFhirClaimCareTeam(oSource).provider.Clone;
  responsibleElement := TFhirClaimCareTeam(oSource).responsibleElement.Clone;
  role := TFhirClaimCareTeam(oSource).role.Clone;
  qualification := TFhirClaimCareTeam(oSource).qualification.Clone;
end;

procedure TFhirClaimCareTeam.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'qualification') Then
     list.add(self.link, 'qualification', FQualification.Link);
end;

procedure TFhirClaimCareTeam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'responsible', 'boolean', false, TFhirBoolean, FResponsible.Link));{2}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'qualification', 'CodeableConcept', false, TFhirCodeableConcept, FQualification.Link));{2}
end;

function TFhirClaimCareTeam.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    ResponsibleElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'qualification') then
  begin
    Qualification := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimCareTeam.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimCareTeam.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'responsible') then result := TFhirBoolean.create() {5b}
  else if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'qualification') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimCareTeam.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'responsible') then result := 'boolean'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'qualification') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimCareTeam.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'qualification') then QualificationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimCareTeam.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'responsible') then ResponsibleElement := asBoolean(new){5b}
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else if (propName = 'qualification') then QualificationElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimCareTeam.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimCareTeam.fhirType : string;
begin
  result := 'careTeam';
end;

function TFhirClaimCareTeam.Link : TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam(inherited Link);
end;

function TFhirClaimCareTeam.Clone : TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam(inherited Clone);
end;

function TFhirClaimCareTeam.equals(other : TObject) : boolean; 
var
  o : TFhirClaimCareTeam;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimCareTeam)) then
    result := false
  else
  begin
    o := TFhirClaimCareTeam(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(providerElement, o.providerElement, true) and 
      compareDeep(responsibleElement, o.responsibleElement, true) and compareDeep(roleElement, o.roleElement, true) and 
      compareDeep(qualificationElement, o.qualificationElement, true);
  end;
end;

function TFhirClaimCareTeam.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FProvider) and isEmptyProp(FResponsible) and isEmptyProp(FRole) and isEmptyProp(FQualification);
end;

procedure TFhirClaimCareTeam.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('provider');
  fields.add('responsible');
  fields.add('role');
  fields.add('qualification');
end;

{ TFhirClaimCareTeam }

Procedure TFhirClaimCareTeam.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimCareTeam.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimCareTeam.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimCareTeam.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirClaimCareTeam.SetResponsible(value : TFhirBoolean);
begin
  FResponsible.free;
  FResponsible := value;
end;

Function TFhirClaimCareTeam.GetResponsibleST : Boolean;
begin
  if FResponsible = nil then
    result := false
  else
    result := FResponsible.value;
end;

Procedure TFhirClaimCareTeam.SetResponsibleST(value : Boolean);
begin
  if FResponsible = nil then
    FResponsible := TFhirBoolean.create;
  FResponsible.value := value
end;

Procedure TFhirClaimCareTeam.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirClaimCareTeam.SetQualification(value : TFhirCodeableConcept);
begin
  FQualification.free;
  FQualification := value;
end;

function TFhirClaimCareTeam.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FResponsible.sizeInBytes);
  inc(result, FRole.sizeInBytes);
  inc(result, FQualification.sizeInBytes);
end;

{ TFhirClaimCareTeamListEnumerator }

Constructor TFhirClaimCareTeamListEnumerator.Create(list : TFhirClaimCareTeamList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimCareTeamListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimCareTeamListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimCareTeamListEnumerator.GetCurrent : TFhirClaimCareTeam;
begin
  Result := FList[FIndex];
end;

function TFhirClaimCareTeamListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimCareTeamList }
procedure TFhirClaimCareTeamList.AddItem(value: TFhirClaimCareTeam);
begin
  assert(value.ClassName = 'TFhirClaimCareTeam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimCareTeam');
  add(value);
end;

function TFhirClaimCareTeamList.Append: TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimCareTeamList.ClearItems;
begin
  Clear;
end;

function TFhirClaimCareTeamList.GetEnumerator : TFhirClaimCareTeamListEnumerator;
begin
  result := TFhirClaimCareTeamListEnumerator.Create(self.link);
end;

function TFhirClaimCareTeamList.Clone: TFhirClaimCareTeamList;
begin
  result := TFhirClaimCareTeamList(inherited Clone);
end;

function TFhirClaimCareTeamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimCareTeamList.GetItemN(index: Integer): TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam(ObjectByIndex[index]);
end;

function TFhirClaimCareTeamList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimCareTeam;
end;
function TFhirClaimCareTeamList.IndexOf(value: TFhirClaimCareTeam): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimCareTeamList.Insert(index: Integer): TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimCareTeamList.InsertItem(index: Integer; value: TFhirClaimCareTeam);
begin
  assert(value is TFhirClaimCareTeam);
  Inherited Insert(index, value);
end;

function TFhirClaimCareTeamList.Item(index: Integer): TFhirClaimCareTeam;
begin
  result := TFhirClaimCareTeam(ObjectByIndex[index]);
end;

function TFhirClaimCareTeamList.Link: TFhirClaimCareTeamList;
begin
  result := TFhirClaimCareTeamList(inherited Link);
end;

procedure TFhirClaimCareTeamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimCareTeamList.SetItemByIndex(index: Integer; value: TFhirClaimCareTeam);
begin
  assert(value is TFhirClaimCareTeam);
  FhirClaimCareTeams[index] := value;
end;

procedure TFhirClaimCareTeamList.SetItemN(index: Integer; value: TFhirClaimCareTeam);
begin
  assert(value is TFhirClaimCareTeam);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimSupportingInfo }

constructor TFhirClaimSupportingInfo.Create;
begin
  inherited;
end;

destructor TFhirClaimSupportingInfo.Destroy;
begin
  FSequence.free;
  FCategory.free;
  FCode.free;
  FTiming.free;
  FValue.free;
  FReason.free;
  inherited;
end;

procedure TFhirClaimSupportingInfo.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimSupportingInfo(oSource).sequenceElement.Clone;
  category := TFhirClaimSupportingInfo(oSource).category.Clone;
  code := TFhirClaimSupportingInfo(oSource).code.Clone;
  timing := TFhirClaimSupportingInfo(oSource).timing.Clone;
  value := TFhirClaimSupportingInfo(oSource).value.Clone;
  reason := TFhirClaimSupportingInfo(oSource).reason.Clone;
end;

procedure TFhirClaimSupportingInfo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
end;

procedure TFhirClaimSupportingInfo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'date|Period', false, TFhirType, FTiming.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'boolean|string|Quantity|Attachment|Reference(Any)', false, TFhirType, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));{2}
end;

function TFhirClaimSupportingInfo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then
  begin
    Timing := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimSupportingInfo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimSupportingInfo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Timing'){4x}
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else if (propName = 'reason') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimSupportingInfo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'timing[x]') then result := 'date|Period'
  else if (propName = 'value[x]') then result := 'boolean|string|Quantity|Attachment|Reference'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimSupportingInfo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then TimingElement := nil{4x}
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then ValueElement := nil{4x}
  else if (propName = 'reason') then ReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimSupportingInfo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then TimingElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then ValueElement := new as TFhirType{4x}
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimSupportingInfo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimSupportingInfo.fhirType : string;
begin
  result := 'supportingInfo';
end;

function TFhirClaimSupportingInfo.Link : TFhirClaimSupportingInfo;
begin
  result := TFhirClaimSupportingInfo(inherited Link);
end;

function TFhirClaimSupportingInfo.Clone : TFhirClaimSupportingInfo;
begin
  result := TFhirClaimSupportingInfo(inherited Clone);
end;

function TFhirClaimSupportingInfo.equals(other : TObject) : boolean; 
var
  o : TFhirClaimSupportingInfo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimSupportingInfo)) then
    result := false
  else
  begin
    o := TFhirClaimSupportingInfo(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(categoryElement, o.categoryElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(timingElement, o.timingElement, true) and 
      compareDeep(valueElement, o.valueElement, true) and compareDeep(reasonElement, o.reasonElement, true);
  end;
end;

function TFhirClaimSupportingInfo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FCategory) and isEmptyProp(FCode) and isEmptyProp(FTiming) and isEmptyProp(FValue) and isEmptyProp(FReason);
end;

procedure TFhirClaimSupportingInfo.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('category');
  fields.add('code');
  fields.add('timing[x]');
  fields.add('value[x]');
  fields.add('reason');
end;

{ TFhirClaimSupportingInfo }

Procedure TFhirClaimSupportingInfo.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimSupportingInfo.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimSupportingInfo.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimSupportingInfo.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirClaimSupportingInfo.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirClaimSupportingInfo.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirClaimSupportingInfo.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Procedure TFhirClaimSupportingInfo.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

function TFhirClaimSupportingInfo.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FTiming.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FReason.sizeInBytes);
end;

{ TFhirClaimSupportingInfoListEnumerator }

Constructor TFhirClaimSupportingInfoListEnumerator.Create(list : TFhirClaimSupportingInfoList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimSupportingInfoListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimSupportingInfoListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimSupportingInfoListEnumerator.GetCurrent : TFhirClaimSupportingInfo;
begin
  Result := FList[FIndex];
end;

function TFhirClaimSupportingInfoListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimSupportingInfoList }
procedure TFhirClaimSupportingInfoList.AddItem(value: TFhirClaimSupportingInfo);
begin
  assert(value.ClassName = 'TFhirClaimSupportingInfo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimSupportingInfo');
  add(value);
end;

function TFhirClaimSupportingInfoList.Append: TFhirClaimSupportingInfo;
begin
  result := TFhirClaimSupportingInfo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimSupportingInfoList.ClearItems;
begin
  Clear;
end;

function TFhirClaimSupportingInfoList.GetEnumerator : TFhirClaimSupportingInfoListEnumerator;
begin
  result := TFhirClaimSupportingInfoListEnumerator.Create(self.link);
end;

function TFhirClaimSupportingInfoList.Clone: TFhirClaimSupportingInfoList;
begin
  result := TFhirClaimSupportingInfoList(inherited Clone);
end;

function TFhirClaimSupportingInfoList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimSupportingInfoList.GetItemN(index: Integer): TFhirClaimSupportingInfo;
begin
  result := TFhirClaimSupportingInfo(ObjectByIndex[index]);
end;

function TFhirClaimSupportingInfoList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimSupportingInfo;
end;
function TFhirClaimSupportingInfoList.IndexOf(value: TFhirClaimSupportingInfo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimSupportingInfoList.Insert(index: Integer): TFhirClaimSupportingInfo;
begin
  result := TFhirClaimSupportingInfo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimSupportingInfoList.InsertItem(index: Integer; value: TFhirClaimSupportingInfo);
begin
  assert(value is TFhirClaimSupportingInfo);
  Inherited Insert(index, value);
end;

function TFhirClaimSupportingInfoList.Item(index: Integer): TFhirClaimSupportingInfo;
begin
  result := TFhirClaimSupportingInfo(ObjectByIndex[index]);
end;

function TFhirClaimSupportingInfoList.Link: TFhirClaimSupportingInfoList;
begin
  result := TFhirClaimSupportingInfoList(inherited Link);
end;

procedure TFhirClaimSupportingInfoList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimSupportingInfoList.SetItemByIndex(index: Integer; value: TFhirClaimSupportingInfo);
begin
  assert(value is TFhirClaimSupportingInfo);
  FhirClaimSupportingInfos[index] := value;
end;

procedure TFhirClaimSupportingInfoList.SetItemN(index: Integer; value: TFhirClaimSupportingInfo);
begin
  assert(value is TFhirClaimSupportingInfo);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimDiagnosis }

constructor TFhirClaimDiagnosis.Create;
begin
  inherited;
end;

destructor TFhirClaimDiagnosis.Destroy;
begin
  FSequence.free;
  FDiagnosis.free;
  FType_List.Free;
  FOnAdmission.free;
  FPackageCode.free;
  inherited;
end;

procedure TFhirClaimDiagnosis.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimDiagnosis(oSource).sequenceElement.Clone;
  diagnosis := TFhirClaimDiagnosis(oSource).diagnosis.Clone;
  if (TFhirClaimDiagnosis(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirClaimDiagnosis(oSource).FType_List);
  end;
  onAdmission := TFhirClaimDiagnosis(oSource).onAdmission.Clone;
  packageCode := TFhirClaimDiagnosis(oSource).packageCode.Clone;
end;

procedure TFhirClaimDiagnosis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'diagnosis[x]') or (child_name = 'diagnosis') Then
     list.add(self.link, 'diagnosis[x]', FDiagnosis.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'onAdmission') Then
     list.add(self.link, 'onAdmission', FOnAdmission.Link);
  if (child_name = 'packageCode') Then
     list.add(self.link, 'packageCode', FPackageCode.Link);
end;

procedure TFhirClaimDiagnosis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'diagnosis[x]', 'CodeableConcept|Reference(Condition)', false, TFhirType, FDiagnosis.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'onAdmission', 'CodeableConcept', false, TFhirCodeableConcept, FOnAdmission.Link));{2}
  oList.add(TFHIRProperty.create(self, 'packageCode', 'CodeableConcept', false, TFhirCodeableConcept, FPackageCode.Link));{2}
end;

function TFhirClaimDiagnosis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then
  begin
    Diagnosis := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'onAdmission') then
  begin
    OnAdmission := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'packageCode') then
  begin
    PackageCode := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimDiagnosis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirClaimDiagnosis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Diagnosis'){4x}
  else if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'onAdmission') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'packageCode') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimDiagnosis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'diagnosis[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'onAdmission') then result := 'CodeableConcept'
  else if (propName = 'packageCode') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimDiagnosis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := nil{4x}
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'onAdmission') then OnAdmissionElement := nil
  else if (propName = 'packageCode') then PackageCodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimDiagnosis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := new as TFhirType{4x}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'onAdmission') then OnAdmissionElement := new as TFhirCodeableConcept{4}
  else if (propName = 'packageCode') then PackageCodeElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimDiagnosis.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimDiagnosis.fhirType : string;
begin
  result := 'diagnosis';
end;

function TFhirClaimDiagnosis.Link : TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis(inherited Link);
end;

function TFhirClaimDiagnosis.Clone : TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis(inherited Clone);
end;

function TFhirClaimDiagnosis.equals(other : TObject) : boolean; 
var
  o : TFhirClaimDiagnosis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimDiagnosis)) then
    result := false
  else
  begin
    o := TFhirClaimDiagnosis(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(diagnosisElement, o.diagnosisElement, true) and 
      compareDeep(type_List, o.type_List, true) and compareDeep(onAdmissionElement, o.onAdmissionElement, true) and 
      compareDeep(packageCodeElement, o.packageCodeElement, true);
  end;
end;

function TFhirClaimDiagnosis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FDiagnosis) and isEmptyProp(Ftype_List) and isEmptyProp(FOnAdmission) and isEmptyProp(FPackageCode);
end;

procedure TFhirClaimDiagnosis.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('diagnosis[x]');
  fields.add('type');
  fields.add('onAdmission');
  fields.add('packageCode');
end;

{ TFhirClaimDiagnosis }

Procedure TFhirClaimDiagnosis.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimDiagnosis.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimDiagnosis.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimDiagnosis.SetDiagnosis(value : TFhirType);
begin
  FDiagnosis.free;
  FDiagnosis := value;
end;

Function TFhirClaimDiagnosis.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

Function TFhirClaimDiagnosis.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Procedure TFhirClaimDiagnosis.SetOnAdmission(value : TFhirCodeableConcept);
begin
  FOnAdmission.free;
  FOnAdmission := value;
end;

Procedure TFhirClaimDiagnosis.SetPackageCode(value : TFhirCodeableConcept);
begin
  FPackageCode.free;
  FPackageCode := value;
end;

function TFhirClaimDiagnosis.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FDiagnosis.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FOnAdmission.sizeInBytes);
  inc(result, FPackageCode.sizeInBytes);
end;

{ TFhirClaimDiagnosisListEnumerator }

Constructor TFhirClaimDiagnosisListEnumerator.Create(list : TFhirClaimDiagnosisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimDiagnosisListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimDiagnosisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimDiagnosisListEnumerator.GetCurrent : TFhirClaimDiagnosis;
begin
  Result := FList[FIndex];
end;

function TFhirClaimDiagnosisListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimDiagnosisList }
procedure TFhirClaimDiagnosisList.AddItem(value: TFhirClaimDiagnosis);
begin
  assert(value.ClassName = 'TFhirClaimDiagnosis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimDiagnosis');
  add(value);
end;

function TFhirClaimDiagnosisList.Append: TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimDiagnosisList.ClearItems;
begin
  Clear;
end;

function TFhirClaimDiagnosisList.GetEnumerator : TFhirClaimDiagnosisListEnumerator;
begin
  result := TFhirClaimDiagnosisListEnumerator.Create(self.link);
end;

function TFhirClaimDiagnosisList.Clone: TFhirClaimDiagnosisList;
begin
  result := TFhirClaimDiagnosisList(inherited Clone);
end;

function TFhirClaimDiagnosisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimDiagnosisList.GetItemN(index: Integer): TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis(ObjectByIndex[index]);
end;

function TFhirClaimDiagnosisList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimDiagnosis;
end;
function TFhirClaimDiagnosisList.IndexOf(value: TFhirClaimDiagnosis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimDiagnosisList.Insert(index: Integer): TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimDiagnosisList.InsertItem(index: Integer; value: TFhirClaimDiagnosis);
begin
  assert(value is TFhirClaimDiagnosis);
  Inherited Insert(index, value);
end;

function TFhirClaimDiagnosisList.Item(index: Integer): TFhirClaimDiagnosis;
begin
  result := TFhirClaimDiagnosis(ObjectByIndex[index]);
end;

function TFhirClaimDiagnosisList.Link: TFhirClaimDiagnosisList;
begin
  result := TFhirClaimDiagnosisList(inherited Link);
end;

procedure TFhirClaimDiagnosisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimDiagnosisList.SetItemByIndex(index: Integer; value: TFhirClaimDiagnosis);
begin
  assert(value is TFhirClaimDiagnosis);
  FhirClaimDiagnoses[index] := value;
end;

procedure TFhirClaimDiagnosisList.SetItemN(index: Integer; value: TFhirClaimDiagnosis);
begin
  assert(value is TFhirClaimDiagnosis);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimProcedure }

constructor TFhirClaimProcedure.Create;
begin
  inherited;
end;

destructor TFhirClaimProcedure.Destroy;
begin
  FSequence.free;
  FType_List.Free;
  FDate.free;
  FProcedure_.free;
  FUdiList.Free;
  inherited;
end;

procedure TFhirClaimProcedure.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimProcedure(oSource).sequenceElement.Clone;
  if (TFhirClaimProcedure(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirClaimProcedure(oSource).FType_List);
  end;
  dateElement := TFhirClaimProcedure(oSource).dateElement.Clone;
  procedure_ := TFhirClaimProcedure(oSource).procedure_.Clone;
  if (TFhirClaimProcedure(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList{TFhirDevice}.Create;
    FUdiList.Assign(TFhirClaimProcedure(oSource).FUdiList);
  end;
end;

procedure TFhirClaimProcedure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'procedure[x]') or (child_name = 'procedure') Then
     list.add(self.link, 'procedure[x]', FProcedure_.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
end;

procedure TFhirClaimProcedure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'procedure[x]', 'CodeableConcept|Reference(Procedure)', false, TFhirType, FProcedure_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference(Device)', true, TFhirReference{TFhirDevice}, FUdiList.Link)){3};
end;

function TFhirClaimProcedure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then
  begin
    Procedure_ := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference{TFhirDevice}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimProcedure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference{TFhirDevice}){2a}
  else inherited;
end;

function TFhirClaimProcedure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Procedure_'){4x}
  else if (propName = 'udi') then result := UdiList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimProcedure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'procedure[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'udi') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimProcedure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'date') then DateElement := nil
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then Procedure_Element := nil{4x}
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimProcedure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then Procedure_Element := new as TFhirType{4x}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimProcedure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination){2a}
  else if (propName = 'udi') then UdiList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimProcedure.fhirType : string;
begin
  result := 'procedure';
end;

function TFhirClaimProcedure.Link : TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure(inherited Link);
end;

function TFhirClaimProcedure.Clone : TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure(inherited Clone);
end;

function TFhirClaimProcedure.equals(other : TObject) : boolean; 
var
  o : TFhirClaimProcedure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimProcedure)) then
    result := false
  else
  begin
    o := TFhirClaimProcedure(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(procedure_Element, o.procedure_Element, true) and 
      compareDeep(udiList, o.udiList, true);
  end;
end;

function TFhirClaimProcedure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(Ftype_List) and isEmptyProp(FDate) and isEmptyProp(FProcedure_) and isEmptyProp(FudiList);
end;

procedure TFhirClaimProcedure.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('type');
  fields.add('date');
  fields.add('procedure[x]');
  fields.add('udi');
end;

{ TFhirClaimProcedure }

Procedure TFhirClaimProcedure.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimProcedure.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimProcedure.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Function TFhirClaimProcedure.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

Function TFhirClaimProcedure.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Procedure TFhirClaimProcedure.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirClaimProcedure.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirClaimProcedure.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirClaimProcedure.SetProcedure_(value : TFhirType);
begin
  FProcedure_.free;
  FProcedure_ := value;
end;

Function TFhirClaimProcedure.GetUdiList : TFhirReferenceList{TFhirDevice};
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList{TFhirDevice}.Create;
  result := FUdiList;
end;

Function TFhirClaimProcedure.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

function TFhirClaimProcedure.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FProcedure_.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
end;

{ TFhirClaimProcedureListEnumerator }

Constructor TFhirClaimProcedureListEnumerator.Create(list : TFhirClaimProcedureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimProcedureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimProcedureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimProcedureListEnumerator.GetCurrent : TFhirClaimProcedure;
begin
  Result := FList[FIndex];
end;

function TFhirClaimProcedureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimProcedureList }
procedure TFhirClaimProcedureList.AddItem(value: TFhirClaimProcedure);
begin
  assert(value.ClassName = 'TFhirClaimProcedure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimProcedure');
  add(value);
end;

function TFhirClaimProcedureList.Append: TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimProcedureList.ClearItems;
begin
  Clear;
end;

function TFhirClaimProcedureList.GetEnumerator : TFhirClaimProcedureListEnumerator;
begin
  result := TFhirClaimProcedureListEnumerator.Create(self.link);
end;

function TFhirClaimProcedureList.Clone: TFhirClaimProcedureList;
begin
  result := TFhirClaimProcedureList(inherited Clone);
end;

function TFhirClaimProcedureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimProcedureList.GetItemN(index: Integer): TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure(ObjectByIndex[index]);
end;

function TFhirClaimProcedureList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimProcedure;
end;
function TFhirClaimProcedureList.IndexOf(value: TFhirClaimProcedure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimProcedureList.Insert(index: Integer): TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimProcedureList.InsertItem(index: Integer; value: TFhirClaimProcedure);
begin
  assert(value is TFhirClaimProcedure);
  Inherited Insert(index, value);
end;

function TFhirClaimProcedureList.Item(index: Integer): TFhirClaimProcedure;
begin
  result := TFhirClaimProcedure(ObjectByIndex[index]);
end;

function TFhirClaimProcedureList.Link: TFhirClaimProcedureList;
begin
  result := TFhirClaimProcedureList(inherited Link);
end;

procedure TFhirClaimProcedureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimProcedureList.SetItemByIndex(index: Integer; value: TFhirClaimProcedure);
begin
  assert(value is TFhirClaimProcedure);
  FhirClaimProcedures[index] := value;
end;

procedure TFhirClaimProcedureList.SetItemN(index: Integer; value: TFhirClaimProcedure);
begin
  assert(value is TFhirClaimProcedure);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimInsurance }

constructor TFhirClaimInsurance.Create;
begin
  inherited;
end;

destructor TFhirClaimInsurance.Destroy;
begin
  FSequence.free;
  FFocal.free;
  FIdentifier.free;
  FCoverage.free;
  FBusinessArrangement.free;
  FPreAuthRefList.Free;
  FClaimResponse.free;
  inherited;
end;

procedure TFhirClaimInsurance.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimInsurance(oSource).sequenceElement.Clone;
  focalElement := TFhirClaimInsurance(oSource).focalElement.Clone;
  identifier := TFhirClaimInsurance(oSource).identifier.Clone;
  coverage := TFhirClaimInsurance(oSource).coverage.Clone;
  businessArrangementElement := TFhirClaimInsurance(oSource).businessArrangementElement.Clone;
  if (TFhirClaimInsurance(oSource).FPreAuthRefList = nil) then
  begin
    FPreAuthRefList.free;
    FPreAuthRefList := nil;
  end
  else
  begin
    if FPreAuthRefList = nil then
      FPreAuthRefList := TFhirStringList.Create;
    FPreAuthRefList.Assign(TFhirClaimInsurance(oSource).FPreAuthRefList);
  end;
  claimResponse := TFhirClaimInsurance(oSource).claimResponse.Clone;
end;

procedure TFhirClaimInsurance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'focal') Then
     list.add(self.link, 'focal', FFocal.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'businessArrangement') Then
     list.add(self.link, 'businessArrangement', FBusinessArrangement.Link);
  if (child_name = 'preAuthRef') Then
    list.addAll(self, 'preAuthRef', FPreAuthRefList);
  if (child_name = 'claimResponse') Then
     list.add(self.link, 'claimResponse', FClaimResponse.Link);
end;

procedure TFhirClaimInsurance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'focal', 'boolean', false, TFhirBoolean, FFocal.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference(Coverage)', false, TFhirReference{TFhirCoverage}, FCoverage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'businessArrangement', 'string', false, TFhirString, FBusinessArrangement.Link));{2}
  oList.add(TFHIRProperty.create(self, 'preAuthRef', 'string', true, TFhirString, FPreAuthRefList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'claimResponse', 'Reference(ClaimResponse)', false, TFhirReference{TFhirClaimResponse}, FClaimResponse.Link));{2}
end;

function TFhirClaimInsurance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'focal') then
  begin
    FocalElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference{TFhirCoverage}{4b};
    result := propValue;
  end
  else if (propName = 'businessArrangement') then
  begin
    BusinessArrangementElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'preAuthRef') then
  begin
    PreAuthRefList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'claimResponse') then
  begin
    ClaimResponse := propValue as TFhirReference{TFhirClaimResponse}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimInsurance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirClaimInsurance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'focal') then result := TFhirBoolean.create() {5b}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'coverage') then result := TFhirReference{TFhirCoverage}.create(){4b}
  else if (propName = 'businessArrangement') then result := TFhirString.create() {5b}
  else if (propName = 'preAuthRef') then result := PreAuthRefList.new(){2}
  else if (propName = 'claimResponse') then result := TFhirReference{TFhirClaimResponse}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimInsurance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'focal') then result := 'boolean'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'businessArrangement') then result := 'string'
  else if (propName = 'preAuthRef') then result := 'string'
  else if (propName = 'claimResponse') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimInsurance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'focal') then FocalElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'businessArrangement') then BusinessArrangementElement := nil
  else if (propName = 'preAuthRef') then deletePropertyValue('preAuthRef', PreAuthRefList, value) {2}
  else if (propName = 'claimResponse') then ClaimResponseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimInsurance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'focal') then FocalElement := asBoolean(new){5b}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference{TFhirCoverage}{4}
  else if (propName = 'businessArrangement') then BusinessArrangementElement := asString(new){5b}
  else if (propName = 'preAuthRef') then replacePropertyValue('preAuthRef', PreAuthRefList, existing, new) {2}
  else if (propName = 'claimResponse') then ClaimResponseElement := new as TFhirReference{TFhirClaimResponse}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimInsurance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimInsurance.fhirType : string;
begin
  result := 'insurance';
end;

function TFhirClaimInsurance.Link : TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance(inherited Link);
end;

function TFhirClaimInsurance.Clone : TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance(inherited Clone);
end;

function TFhirClaimInsurance.equals(other : TObject) : boolean; 
var
  o : TFhirClaimInsurance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimInsurance)) then
    result := false
  else
  begin
    o := TFhirClaimInsurance(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(focalElement, o.focalElement, true) and 
      compareDeep(identifierElement, o.identifierElement, true) and compareDeep(coverageElement, o.coverageElement, true) and 
      compareDeep(businessArrangementElement, o.businessArrangementElement, true) and 
      compareDeep(preAuthRefList, o.preAuthRefList, true) and compareDeep(claimResponseElement, o.claimResponseElement, true);
  end;
end;

function TFhirClaimInsurance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FFocal) and isEmptyProp(FIdentifier) and isEmptyProp(FCoverage) and isEmptyProp(FBusinessArrangement) and isEmptyProp(FpreAuthRefList) and isEmptyProp(FClaimResponse);
end;

procedure TFhirClaimInsurance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('focal');
  fields.add('identifier');
  fields.add('coverage');
  fields.add('businessArrangement');
  fields.add('preAuthRef');
  fields.add('claimResponse');
end;

{ TFhirClaimInsurance }

Procedure TFhirClaimInsurance.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimInsurance.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimInsurance.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimInsurance.SetFocal(value : TFhirBoolean);
begin
  FFocal.free;
  FFocal := value;
end;

Function TFhirClaimInsurance.GetFocalST : Boolean;
begin
  if FFocal = nil then
    result := false
  else
    result := FFocal.value;
end;

Procedure TFhirClaimInsurance.SetFocalST(value : Boolean);
begin
  if FFocal = nil then
    FFocal := TFhirBoolean.create;
  FFocal.value := value
end;

Procedure TFhirClaimInsurance.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirClaimInsurance.SetCoverage(value : TFhirReference{TFhirCoverage});
begin
  FCoverage.free;
  FCoverage := value;
end;

Procedure TFhirClaimInsurance.SetBusinessArrangement(value : TFhirString);
begin
  FBusinessArrangement.free;
  FBusinessArrangement := value;
end;

Function TFhirClaimInsurance.GetBusinessArrangementST : String;
begin
  if FBusinessArrangement = nil then
    result := ''
  else
    result := FBusinessArrangement.value;
end;

Procedure TFhirClaimInsurance.SetBusinessArrangementST(value : String);
begin
  if value <> '' then
  begin
    if FBusinessArrangement = nil then
      FBusinessArrangement := TFhirString.create;
    FBusinessArrangement.value := value
  end
  else if FBusinessArrangement <> nil then
    FBusinessArrangement.value := '';
end;

Function TFhirClaimInsurance.GetPreAuthRefList : TFhirStringList;
begin
  if FPreAuthRefList = nil then
    FPreAuthRefList := TFhirStringList.Create;
  result := FPreAuthRefList;
end;

Function TFhirClaimInsurance.GetHasPreAuthRefList : boolean;
begin
  result := (FPreAuthRefList <> nil) and (FPreAuthRefList.count > 0);
end;

Procedure TFhirClaimInsurance.SetClaimResponse(value : TFhirReference{TFhirClaimResponse});
begin
  FClaimResponse.free;
  FClaimResponse := value;
end;

function TFhirClaimInsurance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FFocal.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FCoverage.sizeInBytes);
  inc(result, FBusinessArrangement.sizeInBytes);
  inc(result, FpreAuthRefList.sizeInBytes);
  inc(result, FClaimResponse.sizeInBytes);
end;

{ TFhirClaimInsuranceListEnumerator }

Constructor TFhirClaimInsuranceListEnumerator.Create(list : TFhirClaimInsuranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimInsuranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimInsuranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimInsuranceListEnumerator.GetCurrent : TFhirClaimInsurance;
begin
  Result := FList[FIndex];
end;

function TFhirClaimInsuranceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimInsuranceList }
procedure TFhirClaimInsuranceList.AddItem(value: TFhirClaimInsurance);
begin
  assert(value.ClassName = 'TFhirClaimInsurance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimInsurance');
  add(value);
end;

function TFhirClaimInsuranceList.Append: TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimInsuranceList.ClearItems;
begin
  Clear;
end;

function TFhirClaimInsuranceList.GetEnumerator : TFhirClaimInsuranceListEnumerator;
begin
  result := TFhirClaimInsuranceListEnumerator.Create(self.link);
end;

function TFhirClaimInsuranceList.Clone: TFhirClaimInsuranceList;
begin
  result := TFhirClaimInsuranceList(inherited Clone);
end;

function TFhirClaimInsuranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimInsuranceList.GetItemN(index: Integer): TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance(ObjectByIndex[index]);
end;

function TFhirClaimInsuranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimInsurance;
end;
function TFhirClaimInsuranceList.IndexOf(value: TFhirClaimInsurance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimInsuranceList.Insert(index: Integer): TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimInsuranceList.InsertItem(index: Integer; value: TFhirClaimInsurance);
begin
  assert(value is TFhirClaimInsurance);
  Inherited Insert(index, value);
end;

function TFhirClaimInsuranceList.Item(index: Integer): TFhirClaimInsurance;
begin
  result := TFhirClaimInsurance(ObjectByIndex[index]);
end;

function TFhirClaimInsuranceList.Link: TFhirClaimInsuranceList;
begin
  result := TFhirClaimInsuranceList(inherited Link);
end;

procedure TFhirClaimInsuranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimInsuranceList.SetItemByIndex(index: Integer; value: TFhirClaimInsurance);
begin
  assert(value is TFhirClaimInsurance);
  FhirClaimInsurances[index] := value;
end;

procedure TFhirClaimInsuranceList.SetItemN(index: Integer; value: TFhirClaimInsurance);
begin
  assert(value is TFhirClaimInsurance);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimAccident }

constructor TFhirClaimAccident.Create;
begin
  inherited;
end;

destructor TFhirClaimAccident.Destroy;
begin
  FDate.free;
  FType_.free;
  FLocation.free;
  inherited;
end;

procedure TFhirClaimAccident.Assign(oSource : TFslObject);
begin
  inherited;
  dateElement := TFhirClaimAccident(oSource).dateElement.Clone;
  type_ := TFhirClaimAccident(oSource).type_.Clone;
  location := TFhirClaimAccident(oSource).location.Clone;
end;

procedure TFhirClaimAccident.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
end;

procedure TFhirClaimAccident.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location[x]', 'Address|Reference(Location)', false, TFhirType, FLocation.Link));{2}
end;

function TFhirClaimAccident.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'date') then
  begin
    DateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then
  begin
    Location := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimAccident.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimAccident.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'date') then result := TFhirDate.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimAccident.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'date') then result := 'date'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'location[x]') then result := 'Address|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimAccident.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'date') then DateElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then LocationElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimAccident.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'date') then DateElement := asDate(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then LocationElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimAccident.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimAccident.fhirType : string;
begin
  result := 'accident';
end;

function TFhirClaimAccident.Link : TFhirClaimAccident;
begin
  result := TFhirClaimAccident(inherited Link);
end;

function TFhirClaimAccident.Clone : TFhirClaimAccident;
begin
  result := TFhirClaimAccident(inherited Clone);
end;

function TFhirClaimAccident.equals(other : TObject) : boolean; 
var
  o : TFhirClaimAccident;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimAccident)) then
    result := false
  else
  begin
    o := TFhirClaimAccident(other);
    result := compareDeep(dateElement, o.dateElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(locationElement, o.locationElement, true);
  end;
end;

function TFhirClaimAccident.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDate) and isEmptyProp(FType_) and isEmptyProp(FLocation);
end;

procedure TFhirClaimAccident.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('date');
  fields.add('type');
  fields.add('location[x]');
end;

{ TFhirClaimAccident }

Procedure TFhirClaimAccident.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirClaimAccident.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirClaimAccident.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

Procedure TFhirClaimAccident.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirClaimAccident.SetLocation(value : TFhirType);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirClaimAccident.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDate.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
end;

{ TFhirClaimAccidentListEnumerator }

Constructor TFhirClaimAccidentListEnumerator.Create(list : TFhirClaimAccidentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimAccidentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimAccidentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimAccidentListEnumerator.GetCurrent : TFhirClaimAccident;
begin
  Result := FList[FIndex];
end;

function TFhirClaimAccidentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimAccidentList }
procedure TFhirClaimAccidentList.AddItem(value: TFhirClaimAccident);
begin
  assert(value.ClassName = 'TFhirClaimAccident', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimAccident');
  add(value);
end;

function TFhirClaimAccidentList.Append: TFhirClaimAccident;
begin
  result := TFhirClaimAccident.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimAccidentList.ClearItems;
begin
  Clear;
end;

function TFhirClaimAccidentList.GetEnumerator : TFhirClaimAccidentListEnumerator;
begin
  result := TFhirClaimAccidentListEnumerator.Create(self.link);
end;

function TFhirClaimAccidentList.Clone: TFhirClaimAccidentList;
begin
  result := TFhirClaimAccidentList(inherited Clone);
end;

function TFhirClaimAccidentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimAccidentList.GetItemN(index: Integer): TFhirClaimAccident;
begin
  result := TFhirClaimAccident(ObjectByIndex[index]);
end;

function TFhirClaimAccidentList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimAccident;
end;
function TFhirClaimAccidentList.IndexOf(value: TFhirClaimAccident): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimAccidentList.Insert(index: Integer): TFhirClaimAccident;
begin
  result := TFhirClaimAccident.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimAccidentList.InsertItem(index: Integer; value: TFhirClaimAccident);
begin
  assert(value is TFhirClaimAccident);
  Inherited Insert(index, value);
end;

function TFhirClaimAccidentList.Item(index: Integer): TFhirClaimAccident;
begin
  result := TFhirClaimAccident(ObjectByIndex[index]);
end;

function TFhirClaimAccidentList.Link: TFhirClaimAccidentList;
begin
  result := TFhirClaimAccidentList(inherited Link);
end;

procedure TFhirClaimAccidentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimAccidentList.SetItemByIndex(index: Integer; value: TFhirClaimAccident);
begin
  assert(value is TFhirClaimAccident);
  FhirClaimAccidents[index] := value;
end;

procedure TFhirClaimAccidentList.SetItemN(index: Integer; value: TFhirClaimAccident);
begin
  assert(value is TFhirClaimAccident);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimItem }

constructor TFhirClaimItem.Create;
begin
  inherited;
end;

destructor TFhirClaimItem.Destroy;
begin
  FSequence.free;
  FCareTeamSequenceList.Free;
  FDiagnosisSequenceList.Free;
  FProcedureSequenceList.Free;
  FInformationSequenceList.Free;
  FRevenue.free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FServiced.free;
  FLocation.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  FBodySite.free;
  FSubSiteList.Free;
  FEncounterList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirClaimItem.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimItem(oSource).sequenceElement.Clone;
  if (TFhirClaimItem(oSource).FCareTeamSequenceList = nil) then
  begin
    FCareTeamSequenceList.free;
    FCareTeamSequenceList := nil;
  end
  else
  begin
    if FCareTeamSequenceList = nil then
      FCareTeamSequenceList := TFhirPositiveIntList.Create;
    FCareTeamSequenceList.Assign(TFhirClaimItem(oSource).FCareTeamSequenceList);
  end;
  if (TFhirClaimItem(oSource).FDiagnosisSequenceList = nil) then
  begin
    FDiagnosisSequenceList.free;
    FDiagnosisSequenceList := nil;
  end
  else
  begin
    if FDiagnosisSequenceList = nil then
      FDiagnosisSequenceList := TFhirPositiveIntList.Create;
    FDiagnosisSequenceList.Assign(TFhirClaimItem(oSource).FDiagnosisSequenceList);
  end;
  if (TFhirClaimItem(oSource).FProcedureSequenceList = nil) then
  begin
    FProcedureSequenceList.free;
    FProcedureSequenceList := nil;
  end
  else
  begin
    if FProcedureSequenceList = nil then
      FProcedureSequenceList := TFhirPositiveIntList.Create;
    FProcedureSequenceList.Assign(TFhirClaimItem(oSource).FProcedureSequenceList);
  end;
  if (TFhirClaimItem(oSource).FInformationSequenceList = nil) then
  begin
    FInformationSequenceList.free;
    FInformationSequenceList := nil;
  end
  else
  begin
    if FInformationSequenceList = nil then
      FInformationSequenceList := TFhirPositiveIntList.Create;
    FInformationSequenceList.Assign(TFhirClaimItem(oSource).FInformationSequenceList);
  end;
  revenue := TFhirClaimItem(oSource).revenue.Clone;
  category := TFhirClaimItem(oSource).category.Clone;
  productOrService := TFhirClaimItem(oSource).productOrService.Clone;
  if (TFhirClaimItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimItem(oSource).FModifierList);
  end;
  if (TFhirClaimItem(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirClaimItem(oSource).FProgramCodeList);
  end;
  serviced := TFhirClaimItem(oSource).serviced.Clone;
  location := TFhirClaimItem(oSource).location.Clone;
  quantity := TFhirClaimItem(oSource).quantity.Clone;
  unitPrice := TFhirClaimItem(oSource).unitPrice.Clone;
  factorElement := TFhirClaimItem(oSource).factorElement.Clone;
  net := TFhirClaimItem(oSource).net.Clone;
  if (TFhirClaimItem(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList{TFhirDevice}.Create;
    FUdiList.Assign(TFhirClaimItem(oSource).FUdiList);
  end;
  bodySite := TFhirClaimItem(oSource).bodySite.Clone;
  if (TFhirClaimItem(oSource).FSubSiteList = nil) then
  begin
    FSubSiteList.free;
    FSubSiteList := nil;
  end
  else
  begin
    if FSubSiteList = nil then
      FSubSiteList := TFhirCodeableConceptList.Create;
    FSubSiteList.Assign(TFhirClaimItem(oSource).FSubSiteList);
  end;
  if (TFhirClaimItem(oSource).FEncounterList = nil) then
  begin
    FEncounterList.free;
    FEncounterList := nil;
  end
  else
  begin
    if FEncounterList = nil then
      FEncounterList := TFhirReferenceList{TFhirEncounter}.Create;
    FEncounterList.Assign(TFhirClaimItem(oSource).FEncounterList);
  end;
  if (TFhirClaimItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirClaimItemDetailList.Create;
    FDetailList.Assign(TFhirClaimItem(oSource).FDetailList);
  end;
end;

procedure TFhirClaimItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'careTeamSequence') Then
    list.addAll(self, 'careTeamSequence', FCareTeamSequenceList);
  if (child_name = 'diagnosisSequence') Then
    list.addAll(self, 'diagnosisSequence', FDiagnosisSequenceList);
  if (child_name = 'procedureSequence') Then
    list.addAll(self, 'procedureSequence', FProcedureSequenceList);
  if (child_name = 'informationSequence') Then
    list.addAll(self, 'informationSequence', FInformationSequenceList);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'subSite') Then
    list.addAll(self, 'subSite', FSubSiteList);
  if (child_name = 'encounter') Then
    list.addAll(self, 'encounter', FEncounterList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirClaimItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'careTeamSequence', 'positiveInt', true, TFhirPositiveInt, FCareTeamSequenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'diagnosisSequence', 'positiveInt', true, TFhirPositiveInt, FDiagnosisSequenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'procedureSequence', 'positiveInt', true, TFhirPositiveInt, FProcedureSequenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'informationSequence', 'positiveInt', true, TFhirPositiveInt, FInformationSequenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirType, FServiced.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location[x]', 'CodeableConcept|Address|Reference(Location)', false, TFhirType, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference(Device)', true, TFhirReference{TFhirDevice}, FUdiList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subSite', 'CodeableConcept', true, TFhirCodeableConcept, FSubSiteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', true, TFhirReference{TFhirEncounter}, FEncounterList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'detail', '', true, TFhirClaimItemDetail, FDetailList.Link)){3};
end;

function TFhirClaimItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'careTeamSequence') then
  begin
    CareTeamSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'diagnosisSequence') then
  begin
    DiagnosisSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'procedureSequence') then
  begin
    ProcedureSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'informationSequence') then
  begin
    InformationSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then
  begin
    Location := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference{TFhirDevice}){2a};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subSite') then
  begin
    SubSiteList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    EncounterList.add(propValue as TFhirReference{TFhirEncounter}){2a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirClaimItemDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'careTeamSequence') then CareTeamSequenceList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'diagnosisSequence') then DiagnosisSequenceList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'procedureSequence') then ProcedureSequenceList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'informationSequence') then InformationSequenceList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference{TFhirDevice}){2a}
  else if (propName = 'subSite') then SubSiteList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'encounter') then EncounterList.insertItem(index, propValue as TFhirReference{TFhirEncounter}){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirClaimItemDetail){2a}
  else inherited;
end;

function TFhirClaimItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'careTeamSequence') then result := CareTeamSequenceList.new(){2}
  else if (propName = 'diagnosisSequence') then result := DiagnosisSequenceList.new(){2}
  else if (propName = 'procedureSequence') then result := ProcedureSequenceList.new(){2}
  else if (propName = 'informationSequence') then result := InformationSequenceList.new(){2}
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'programCode') then result := ProgramCodeList.new(){2}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced'){4x}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location'){4x}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else if (propName = 'udi') then result := UdiList.new(){2}
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subSite') then result := SubSiteList.new(){2}
  else if (propName = 'encounter') then result := EncounterList.new(){2}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'careTeamSequence') then result := 'positiveInt'
  else if (propName = 'diagnosisSequence') then result := 'positiveInt'
  else if (propName = 'procedureSequence') then result := 'positiveInt'
  else if (propName = 'informationSequence') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'location[x]') then result := 'CodeableConcept|Address|Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'subSite') then result := 'CodeableConcept'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'detail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'careTeamSequence') then deletePropertyValue('careTeamSequence', CareTeamSequenceList, value) {2}
  else if (propName = 'diagnosisSequence') then deletePropertyValue('diagnosisSequence', DiagnosisSequenceList, value) {2}
  else if (propName = 'procedureSequence') then deletePropertyValue('procedureSequence', ProcedureSequenceList, value) {2}
  else if (propName = 'informationSequence') then deletePropertyValue('informationSequence', InformationSequenceList, value) {2}
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {2}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil{4x}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := nil{4x}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {2}
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'subSite') then deletePropertyValue('subSite', SubSiteList, value) {2}
  else if (propName = 'encounter') then deletePropertyValue('encounter', EncounterList, value) {2}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'careTeamSequence') then replacePropertyValue('careTeamSequence', CareTeamSequenceList, existing, new) {2}
  else if (propName = 'diagnosisSequence') then replacePropertyValue('diagnosisSequence', DiagnosisSequenceList, existing, new) {2}
  else if (propName = 'procedureSequence') then replacePropertyValue('procedureSequence', ProcedureSequenceList, existing, new) {2}
  else if (propName = 'informationSequence') then replacePropertyValue('informationSequence', InformationSequenceList, existing, new) {2}
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {2}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := new as TFhirType{4x}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {2}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subSite') then replacePropertyValue('subSite', SubSiteList, existing, new) {2}
  else if (propName = 'encounter') then replacePropertyValue('encounter', EncounterList, existing, new) {2}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'careTeamSequence') then CareTeamSequenceList.move(source, destination){2}
  else if (propName = 'diagnosisSequence') then DiagnosisSequenceList.move(source, destination){2}
  else if (propName = 'procedureSequence') then ProcedureSequenceList.move(source, destination){2}
  else if (propName = 'informationSequence') then InformationSequenceList.move(source, destination){2}
  else if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination){2a}
  else if (propName = 'udi') then UdiList.move(source, destination){2a}
  else if (propName = 'subSite') then SubSiteList.move(source, destination){2a}
  else if (propName = 'encounter') then EncounterList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimItem.fhirType : string;
begin
  result := 'item';
end;

function TFhirClaimItem.Link : TFhirClaimItem;
begin
  result := TFhirClaimItem(inherited Link);
end;

function TFhirClaimItem.Clone : TFhirClaimItem;
begin
  result := TFhirClaimItem(inherited Clone);
end;

function TFhirClaimItem.equals(other : TObject) : boolean; 
var
  o : TFhirClaimItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimItem)) then
    result := false
  else
  begin
    o := TFhirClaimItem(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(careTeamSequenceList, o.careTeamSequenceList, true) and 
      compareDeep(diagnosisSequenceList, o.diagnosisSequenceList, true) and compareDeep(procedureSequenceList, o.procedureSequenceList, true) and 
      compareDeep(informationSequenceList, o.informationSequenceList, true) and compareDeep(revenueElement, o.revenueElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and 
      compareDeep(servicedElement, o.servicedElement, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(udiList, o.udiList, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and 
      compareDeep(subSiteList, o.subSiteList, true) and compareDeep(encounterList, o.encounterList, true) and 
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirClaimItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FcareTeamSequenceList) and isEmptyProp(FdiagnosisSequenceList) and isEmptyProp(FprocedureSequenceList) and isEmptyProp(FinformationSequenceList) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FServiced) and isEmptyProp(FLocation) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList) and isEmptyProp(FBodySite) and isEmptyProp(FsubSiteList) and isEmptyProp(FencounterList) and isEmptyProp(FdetailList);
end;

procedure TFhirClaimItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('careTeamSequence');
  fields.add('diagnosisSequence');
  fields.add('procedureSequence');
  fields.add('informationSequence');
  fields.add('revenue');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('serviced[x]');
  fields.add('location[x]');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
  fields.add('bodySite');
  fields.add('subSite');
  fields.add('encounter');
  fields.add('detail');
end;

{ TFhirClaimItem }

Procedure TFhirClaimItem.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimItem.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimItem.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Function TFhirClaimItem.GetCareTeamSequenceList : TFhirPositiveIntList;
begin
  if FCareTeamSequenceList = nil then
    FCareTeamSequenceList := TFhirPositiveIntList.Create;
  result := FCareTeamSequenceList;
end;

Function TFhirClaimItem.GetHasCareTeamSequenceList : boolean;
begin
  result := (FCareTeamSequenceList <> nil) and (FCareTeamSequenceList.count > 0);
end;

Function TFhirClaimItem.GetDiagnosisSequenceList : TFhirPositiveIntList;
begin
  if FDiagnosisSequenceList = nil then
    FDiagnosisSequenceList := TFhirPositiveIntList.Create;
  result := FDiagnosisSequenceList;
end;

Function TFhirClaimItem.GetHasDiagnosisSequenceList : boolean;
begin
  result := (FDiagnosisSequenceList <> nil) and (FDiagnosisSequenceList.count > 0);
end;

Function TFhirClaimItem.GetProcedureSequenceList : TFhirPositiveIntList;
begin
  if FProcedureSequenceList = nil then
    FProcedureSequenceList := TFhirPositiveIntList.Create;
  result := FProcedureSequenceList;
end;

Function TFhirClaimItem.GetHasProcedureSequenceList : boolean;
begin
  result := (FProcedureSequenceList <> nil) and (FProcedureSequenceList.count > 0);
end;

Function TFhirClaimItem.GetInformationSequenceList : TFhirPositiveIntList;
begin
  if FInformationSequenceList = nil then
    FInformationSequenceList := TFhirPositiveIntList.Create;
  result := FInformationSequenceList;
end;

Function TFhirClaimItem.GetHasInformationSequenceList : boolean;
begin
  result := (FInformationSequenceList <> nil) and (FInformationSequenceList.count > 0);
end;

Procedure TFhirClaimItem.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

Procedure TFhirClaimItem.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirClaimItem.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

Function TFhirClaimItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirClaimItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Function TFhirClaimItem.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

Function TFhirClaimItem.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

Procedure TFhirClaimItem.SetServiced(value : TFhirType);
begin
  FServiced.free;
  FServiced := value;
end;

Procedure TFhirClaimItem.SetLocation(value : TFhirType);
begin
  FLocation.free;
  FLocation := value;
end;

Procedure TFhirClaimItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirClaimItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirClaimItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirClaimItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirClaimItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirClaimItem.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

Function TFhirClaimItem.GetUdiList : TFhirReferenceList{TFhirDevice};
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList{TFhirDevice}.Create;
  result := FUdiList;
end;

Function TFhirClaimItem.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

Procedure TFhirClaimItem.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

Function TFhirClaimItem.GetSubSiteList : TFhirCodeableConceptList;
begin
  if FSubSiteList = nil then
    FSubSiteList := TFhirCodeableConceptList.Create;
  result := FSubSiteList;
end;

Function TFhirClaimItem.GetHasSubSiteList : boolean;
begin
  result := (FSubSiteList <> nil) and (FSubSiteList.count > 0);
end;

Function TFhirClaimItem.GetEncounterList : TFhirReferenceList{TFhirEncounter};
begin
  if FEncounterList = nil then
    FEncounterList := TFhirReferenceList{TFhirEncounter}.Create;
  result := FEncounterList;
end;

Function TFhirClaimItem.GetHasEncounterList : boolean;
begin
  result := (FEncounterList <> nil) and (FEncounterList.count > 0);
end;

Function TFhirClaimItem.GetDetailList : TFhirClaimItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirClaimItemDetailList.Create;
  result := FDetailList;
end;

Function TFhirClaimItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirClaimItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FcareTeamSequenceList.sizeInBytes);
  inc(result, FdiagnosisSequenceList.sizeInBytes);
  inc(result, FprocedureSequenceList.sizeInBytes);
  inc(result, FinformationSequenceList.sizeInBytes);
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FServiced.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FsubSiteList.sizeInBytes);
  inc(result, FencounterList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirClaimItemListEnumerator }

Constructor TFhirClaimItemListEnumerator.Create(list : TFhirClaimItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimItemListEnumerator.GetCurrent : TFhirClaimItem;
begin
  Result := FList[FIndex];
end;

function TFhirClaimItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimItemList }
procedure TFhirClaimItemList.AddItem(value: TFhirClaimItem);
begin
  assert(value.ClassName = 'TFhirClaimItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimItem');
  add(value);
end;

function TFhirClaimItemList.Append: TFhirClaimItem;
begin
  result := TFhirClaimItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemList.ClearItems;
begin
  Clear;
end;

function TFhirClaimItemList.GetEnumerator : TFhirClaimItemListEnumerator;
begin
  result := TFhirClaimItemListEnumerator.Create(self.link);
end;

function TFhirClaimItemList.Clone: TFhirClaimItemList;
begin
  result := TFhirClaimItemList(inherited Clone);
end;

function TFhirClaimItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimItemList.GetItemN(index: Integer): TFhirClaimItem;
begin
  result := TFhirClaimItem(ObjectByIndex[index]);
end;

function TFhirClaimItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimItem;
end;
function TFhirClaimItemList.IndexOf(value: TFhirClaimItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimItemList.Insert(index: Integer): TFhirClaimItem;
begin
  result := TFhirClaimItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemList.InsertItem(index: Integer; value: TFhirClaimItem);
begin
  assert(value is TFhirClaimItem);
  Inherited Insert(index, value);
end;

function TFhirClaimItemList.Item(index: Integer): TFhirClaimItem;
begin
  result := TFhirClaimItem(ObjectByIndex[index]);
end;

function TFhirClaimItemList.Link: TFhirClaimItemList;
begin
  result := TFhirClaimItemList(inherited Link);
end;

procedure TFhirClaimItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimItemList.SetItemByIndex(index: Integer; value: TFhirClaimItem);
begin
  assert(value is TFhirClaimItem);
  FhirClaimItems[index] := value;
end;

procedure TFhirClaimItemList.SetItemN(index: Integer; value: TFhirClaimItem);
begin
  assert(value is TFhirClaimItem);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimItemDetail }

constructor TFhirClaimItemDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimItemDetail.Destroy;
begin
  FSequence.free;
  FRevenue.free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  FSubDetailList.Free;
  inherited;
end;

procedure TFhirClaimItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimItemDetail(oSource).sequenceElement.Clone;
  revenue := TFhirClaimItemDetail(oSource).revenue.Clone;
  category := TFhirClaimItemDetail(oSource).category.Clone;
  productOrService := TFhirClaimItemDetail(oSource).productOrService.Clone;
  if (TFhirClaimItemDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimItemDetail(oSource).FModifierList);
  end;
  if (TFhirClaimItemDetail(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirClaimItemDetail(oSource).FProgramCodeList);
  end;
  quantity := TFhirClaimItemDetail(oSource).quantity.Clone;
  unitPrice := TFhirClaimItemDetail(oSource).unitPrice.Clone;
  factorElement := TFhirClaimItemDetail(oSource).factorElement.Clone;
  net := TFhirClaimItemDetail(oSource).net.Clone;
  if (TFhirClaimItemDetail(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList{TFhirDevice}.Create;
    FUdiList.Assign(TFhirClaimItemDetail(oSource).FUdiList);
  end;
  if (TFhirClaimItemDetail(oSource).FSubDetailList = nil) then
  begin
    FSubDetailList.free;
    FSubDetailList := nil;
  end
  else
  begin
    if FSubDetailList = nil then
      FSubDetailList := TFhirClaimItemDetailSubDetailList.Create;
    FSubDetailList.Assign(TFhirClaimItemDetail(oSource).FSubDetailList);
  end;
end;

procedure TFhirClaimItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
  if (child_name = 'subDetail') Then
    list.addAll(self, 'subDetail', FSubDetailList);
end;

procedure TFhirClaimItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference(Device)', true, TFhirReference{TFhirDevice}, FUdiList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subDetail', '', true, TFhirClaimItemDetailSubDetail, FSubDetailList.Link)){3};
end;

function TFhirClaimItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference{TFhirDevice}){2a};
    result := propValue;
  end
  else if (propName = 'subDetail') then
  begin
    SubDetailList.add(propValue as TFhirClaimItemDetailSubDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference{TFhirDevice}){2a}
  else if (propName = 'subDetail') then SubDetailList.insertItem(index, propValue as TFhirClaimItemDetailSubDetail){2a}
  else inherited;
end;

function TFhirClaimItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'programCode') then result := ProgramCodeList.new(){2}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else if (propName = 'udi') then result := UdiList.new(){2}
  else if (propName = 'subDetail') then result := SubDetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else if (propName = 'subDetail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {2}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {2}
  else if (propName = 'subDetail') then deletePropertyValue('subDetail', SubDetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {2}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {2}
  else if (propName = 'subDetail') then replacePropertyValue('subDetail', SubDetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination){2a}
  else if (propName = 'udi') then UdiList.move(source, destination){2a}
  else if (propName = 'subDetail') then SubDetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimItemDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirClaimItemDetail.Link : TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail(inherited Link);
end;

function TFhirClaimItemDetail.Clone : TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail(inherited Clone);
end;

function TFhirClaimItemDetail.equals(other : TObject) : boolean; 
var
  o : TFhirClaimItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimItemDetail)) then
    result := false
  else
  begin
    o := TFhirClaimItemDetail(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(revenueElement, o.revenueElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(udiList, o.udiList, true) and compareDeep(subDetailList, o.subDetailList, true);
  end;
end;

function TFhirClaimItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList) and isEmptyProp(FsubDetailList);
end;

procedure TFhirClaimItemDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('revenue');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
  fields.add('subDetail');
end;

{ TFhirClaimItemDetail }

Procedure TFhirClaimItemDetail.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimItemDetail.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimItemDetail.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimItemDetail.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

Procedure TFhirClaimItemDetail.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirClaimItemDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

Function TFhirClaimItemDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirClaimItemDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Function TFhirClaimItemDetail.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

Function TFhirClaimItemDetail.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

Procedure TFhirClaimItemDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirClaimItemDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirClaimItemDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirClaimItemDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirClaimItemDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirClaimItemDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

Function TFhirClaimItemDetail.GetUdiList : TFhirReferenceList{TFhirDevice};
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList{TFhirDevice}.Create;
  result := FUdiList;
end;

Function TFhirClaimItemDetail.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

Function TFhirClaimItemDetail.GetSubDetailList : TFhirClaimItemDetailSubDetailList;
begin
  if FSubDetailList = nil then
    FSubDetailList := TFhirClaimItemDetailSubDetailList.Create;
  result := FSubDetailList;
end;

Function TFhirClaimItemDetail.GetHasSubDetailList : boolean;
begin
  result := (FSubDetailList <> nil) and (FSubDetailList.count > 0);
end;

function TFhirClaimItemDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
  inc(result, FsubDetailList.sizeInBytes);
end;

{ TFhirClaimItemDetailListEnumerator }

Constructor TFhirClaimItemDetailListEnumerator.Create(list : TFhirClaimItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimItemDetailListEnumerator.GetCurrent : TFhirClaimItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimItemDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimItemDetailList }
procedure TFhirClaimItemDetailList.AddItem(value: TFhirClaimItemDetail);
begin
  assert(value.ClassName = 'TFhirClaimItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimItemDetail');
  add(value);
end;

function TFhirClaimItemDetailList.Append: TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimItemDetailList.GetEnumerator : TFhirClaimItemDetailListEnumerator;
begin
  result := TFhirClaimItemDetailListEnumerator.Create(self.link);
end;

function TFhirClaimItemDetailList.Clone: TFhirClaimItemDetailList;
begin
  result := TFhirClaimItemDetailList(inherited Clone);
end;

function TFhirClaimItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimItemDetailList.GetItemN(index: Integer): TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimItemDetail;
end;
function TFhirClaimItemDetailList.IndexOf(value: TFhirClaimItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimItemDetailList.Insert(index: Integer): TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemDetailList.InsertItem(index: Integer; value: TFhirClaimItemDetail);
begin
  assert(value is TFhirClaimItemDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimItemDetailList.Item(index: Integer): TFhirClaimItemDetail;
begin
  result := TFhirClaimItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimItemDetailList.Link: TFhirClaimItemDetailList;
begin
  result := TFhirClaimItemDetailList(inherited Link);
end;

procedure TFhirClaimItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimItemDetailList.SetItemByIndex(index: Integer; value: TFhirClaimItemDetail);
begin
  assert(value is TFhirClaimItemDetail);
  FhirClaimItemDetails[index] := value;
end;

procedure TFhirClaimItemDetailList.SetItemN(index: Integer; value: TFhirClaimItemDetail);
begin
  assert(value is TFhirClaimItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimItemDetailSubDetail }

constructor TFhirClaimItemDetailSubDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimItemDetailSubDetail.Destroy;
begin
  FSequence.free;
  FRevenue.free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  inherited;
end;

procedure TFhirClaimItemDetailSubDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimItemDetailSubDetail(oSource).sequenceElement.Clone;
  revenue := TFhirClaimItemDetailSubDetail(oSource).revenue.Clone;
  category := TFhirClaimItemDetailSubDetail(oSource).category.Clone;
  productOrService := TFhirClaimItemDetailSubDetail(oSource).productOrService.Clone;
  if (TFhirClaimItemDetailSubDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimItemDetailSubDetail(oSource).FModifierList);
  end;
  if (TFhirClaimItemDetailSubDetail(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirClaimItemDetailSubDetail(oSource).FProgramCodeList);
  end;
  quantity := TFhirClaimItemDetailSubDetail(oSource).quantity.Clone;
  unitPrice := TFhirClaimItemDetailSubDetail(oSource).unitPrice.Clone;
  factorElement := TFhirClaimItemDetailSubDetail(oSource).factorElement.Clone;
  net := TFhirClaimItemDetailSubDetail(oSource).net.Clone;
  if (TFhirClaimItemDetailSubDetail(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList{TFhirDevice}.Create;
    FUdiList.Assign(TFhirClaimItemDetailSubDetail(oSource).FUdiList);
  end;
end;

procedure TFhirClaimItemDetailSubDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
end;

procedure TFhirClaimItemDetailSubDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference(Device)', true, TFhirReference{TFhirDevice}, FUdiList.Link)){3};
end;

function TFhirClaimItemDetailSubDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference{TFhirDevice}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimItemDetailSubDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference{TFhirDevice}){2a}
  else inherited;
end;

function TFhirClaimItemDetailSubDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'programCode') then result := ProgramCodeList.new(){2}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else if (propName = 'udi') then result := UdiList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimItemDetailSubDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimItemDetailSubDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {2}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimItemDetailSubDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {2}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimItemDetailSubDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination){2a}
  else if (propName = 'udi') then UdiList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimItemDetailSubDetail.fhirType : string;
begin
  result := 'subDetail';
end;

function TFhirClaimItemDetailSubDetail.Link : TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail(inherited Link);
end;

function TFhirClaimItemDetailSubDetail.Clone : TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail(inherited Clone);
end;

function TFhirClaimItemDetailSubDetail.equals(other : TObject) : boolean; 
var
  o : TFhirClaimItemDetailSubDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimItemDetailSubDetail)) then
    result := false
  else
  begin
    o := TFhirClaimItemDetailSubDetail(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(revenueElement, o.revenueElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(udiList, o.udiList, true);
  end;
end;

function TFhirClaimItemDetailSubDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList);
end;

procedure TFhirClaimItemDetailSubDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('revenue');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
end;

{ TFhirClaimItemDetailSubDetail }

Procedure TFhirClaimItemDetailSubDetail.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimItemDetailSubDetail.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimItemDetailSubDetail.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimItemDetailSubDetail.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

Procedure TFhirClaimItemDetailSubDetail.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirClaimItemDetailSubDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

Function TFhirClaimItemDetailSubDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirClaimItemDetailSubDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Function TFhirClaimItemDetailSubDetail.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

Function TFhirClaimItemDetailSubDetail.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

Procedure TFhirClaimItemDetailSubDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirClaimItemDetailSubDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirClaimItemDetailSubDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirClaimItemDetailSubDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirClaimItemDetailSubDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirClaimItemDetailSubDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

Function TFhirClaimItemDetailSubDetail.GetUdiList : TFhirReferenceList{TFhirDevice};
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList{TFhirDevice}.Create;
  result := FUdiList;
end;

Function TFhirClaimItemDetailSubDetail.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

function TFhirClaimItemDetailSubDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
end;

{ TFhirClaimItemDetailSubDetailListEnumerator }

Constructor TFhirClaimItemDetailSubDetailListEnumerator.Create(list : TFhirClaimItemDetailSubDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimItemDetailSubDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimItemDetailSubDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimItemDetailSubDetailListEnumerator.GetCurrent : TFhirClaimItemDetailSubDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimItemDetailSubDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimItemDetailSubDetailList }
procedure TFhirClaimItemDetailSubDetailList.AddItem(value: TFhirClaimItemDetailSubDetail);
begin
  assert(value.ClassName = 'TFhirClaimItemDetailSubDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimItemDetailSubDetail');
  add(value);
end;

function TFhirClaimItemDetailSubDetailList.Append: TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemDetailSubDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimItemDetailSubDetailList.GetEnumerator : TFhirClaimItemDetailSubDetailListEnumerator;
begin
  result := TFhirClaimItemDetailSubDetailListEnumerator.Create(self.link);
end;

function TFhirClaimItemDetailSubDetailList.Clone: TFhirClaimItemDetailSubDetailList;
begin
  result := TFhirClaimItemDetailSubDetailList(inherited Clone);
end;

function TFhirClaimItemDetailSubDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimItemDetailSubDetailList.GetItemN(index: Integer): TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimItemDetailSubDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimItemDetailSubDetail;
end;
function TFhirClaimItemDetailSubDetailList.IndexOf(value: TFhirClaimItemDetailSubDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimItemDetailSubDetailList.Insert(index: Integer): TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimItemDetailSubDetailList.InsertItem(index: Integer; value: TFhirClaimItemDetailSubDetail);
begin
  assert(value is TFhirClaimItemDetailSubDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimItemDetailSubDetailList.Item(index: Integer): TFhirClaimItemDetailSubDetail;
begin
  result := TFhirClaimItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimItemDetailSubDetailList.Link: TFhirClaimItemDetailSubDetailList;
begin
  result := TFhirClaimItemDetailSubDetailList(inherited Link);
end;

procedure TFhirClaimItemDetailSubDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimItemDetailSubDetailList.SetItemByIndex(index: Integer; value: TFhirClaimItemDetailSubDetail);
begin
  assert(value is TFhirClaimItemDetailSubDetail);
  FhirClaimItemDetailSubDetails[index] := value;
end;

procedure TFhirClaimItemDetailSubDetailList.SetItemN(index: Integer; value: TFhirClaimItemDetailSubDetail);
begin
  assert(value is TFhirClaimItemDetailSubDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaim }

constructor TFhirClaim.Create;
begin
  inherited;
end;

destructor TFhirClaim.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FSubType.free;
  FUse.free;
  FPatient.free;
  FBillablePeriod.free;
  FCreated.free;
  FEnterer.free;
  FInsurer.free;
  FProvider.free;
  FPriority.free;
  FFundsReserve.free;
  FRelatedList.Free;
  FPrescription.free;
  FOriginalPrescription.free;
  FPayee.free;
  FReferral.free;
  FFacility.free;
  FCareTeamList.Free;
  FSupportingInfoList.Free;
  FDiagnosisList.Free;
  FProcedure_List.Free;
  FInsuranceList.Free;
  FAccident.free;
  FItemList.Free;
  FTotal.free;
  inherited;
end;

function TFhirClaim.GetResourceType : TFhirResourceType;
begin
  result := frtClaim;
end;

procedure TFhirClaim.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClaim(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirClaim(oSource).FIdentifierList);
  end;
  FStatus := TFhirClaim(oSource).FStatus.Link;
  type_ := TFhirClaim(oSource).type_.Clone;
  subType := TFhirClaim(oSource).subType.Clone;
  FUse := TFhirClaim(oSource).FUse.Link;
  patient := TFhirClaim(oSource).patient.Clone;
  billablePeriod := TFhirClaim(oSource).billablePeriod.Clone;
  createdElement := TFhirClaim(oSource).createdElement.Clone;
  enterer := TFhirClaim(oSource).enterer.Clone;
  insurer := TFhirClaim(oSource).insurer.Clone;
  provider := TFhirClaim(oSource).provider.Clone;
  priority := TFhirClaim(oSource).priority.Clone;
  fundsReserve := TFhirClaim(oSource).fundsReserve.Clone;
  if (TFhirClaim(oSource).FRelatedList = nil) then
  begin
    FRelatedList.free;
    FRelatedList := nil;
  end
  else
  begin
    if FRelatedList = nil then
      FRelatedList := TFhirClaimRelatedList.Create;
    FRelatedList.Assign(TFhirClaim(oSource).FRelatedList);
  end;
  prescription := TFhirClaim(oSource).prescription.Clone;
  originalPrescription := TFhirClaim(oSource).originalPrescription.Clone;
  payee := TFhirClaim(oSource).payee.Clone;
  referral := TFhirClaim(oSource).referral.Clone;
  facility := TFhirClaim(oSource).facility.Clone;
  if (TFhirClaim(oSource).FCareTeamList = nil) then
  begin
    FCareTeamList.free;
    FCareTeamList := nil;
  end
  else
  begin
    if FCareTeamList = nil then
      FCareTeamList := TFhirClaimCareTeamList.Create;
    FCareTeamList.Assign(TFhirClaim(oSource).FCareTeamList);
  end;
  if (TFhirClaim(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirClaimSupportingInfoList.Create;
    FSupportingInfoList.Assign(TFhirClaim(oSource).FSupportingInfoList);
  end;
  if (TFhirClaim(oSource).FDiagnosisList = nil) then
  begin
    FDiagnosisList.free;
    FDiagnosisList := nil;
  end
  else
  begin
    if FDiagnosisList = nil then
      FDiagnosisList := TFhirClaimDiagnosisList.Create;
    FDiagnosisList.Assign(TFhirClaim(oSource).FDiagnosisList);
  end;
  if (TFhirClaim(oSource).FProcedure_List = nil) then
  begin
    FProcedure_List.free;
    FProcedure_List := nil;
  end
  else
  begin
    if FProcedure_List = nil then
      FProcedure_List := TFhirClaimProcedureList.Create;
    FProcedure_List.Assign(TFhirClaim(oSource).FProcedure_List);
  end;
  if (TFhirClaim(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirClaimInsuranceList.Create;
    FInsuranceList.Assign(TFhirClaim(oSource).FInsuranceList);
  end;
  accident := TFhirClaim(oSource).accident.Clone;
  if (TFhirClaim(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirClaimItemList.Create;
    FItemList.Assign(TFhirClaim(oSource).FItemList);
  end;
  total := TFhirClaim(oSource).total.Clone;
end;

procedure TFhirClaim.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
     list.add(self.link, 'subType', FSubType.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'billablePeriod') Then
     list.add(self.link, 'billablePeriod', FBillablePeriod.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'fundsReserve') Then
     list.add(self.link, 'fundsReserve', FFundsReserve.Link);
  if (child_name = 'related') Then
    list.addAll(self, 'related', FRelatedList);
  if (child_name = 'prescription') Then
     list.add(self.link, 'prescription', FPrescription.Link);
  if (child_name = 'originalPrescription') Then
     list.add(self.link, 'originalPrescription', FOriginalPrescription.Link);
  if (child_name = 'payee') Then
     list.add(self.link, 'payee', FPayee.Link);
  if (child_name = 'referral') Then
     list.add(self.link, 'referral', FReferral.Link);
  if (child_name = 'facility') Then
     list.add(self.link, 'facility', FFacility.Link);
  if (child_name = 'careTeam') Then
    list.addAll(self, 'careTeam', FCareTeamList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'diagnosis') Then
    list.addAll(self, 'diagnosis', FDiagnosisList);
  if (child_name = 'procedure') Then
    list.addAll(self, 'procedure', FProcedure_List);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'accident') Then
     list.add(self.link, 'accident', FAccident.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
  if (child_name = 'total') Then
     list.add(self.link, 'total', FTotal.Link);
end;

procedure TFhirClaim.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', false, TFhirCodeableConcept, FSubType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'use', 'code', false, TFHIREnum, FUse.Link));{1}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'billablePeriod', 'Period', false, TFhirPeriod, FBillablePeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FEnterer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FInsurer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'fundsReserve', 'CodeableConcept', false, TFhirCodeableConcept, FFundsReserve.Link));{2}
  oList.add(TFHIRProperty.create(self, 'related', '', true, TFhirClaimRelated, FRelatedList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'prescription', 'Reference(DeviceRequest)', false, TFhirReference{TFhirDeviceRequest}, FPrescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'originalPrescription', 'Reference(DeviceRequest)', false, TFhirReference{TFhirDeviceRequest}, FOriginalPrescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payee', '', false, TFhirClaimPayee, FPayee.Link));{2}
  oList.add(TFHIRProperty.create(self, 'referral', 'Reference(ServiceRequest)', false, TFhirReference{TFhirServiceRequest}, FReferral.Link));{2}
  oList.add(TFHIRProperty.create(self, 'facility', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FFacility.Link));{2}
  oList.add(TFHIRProperty.create(self, 'careTeam', '', true, TFhirClaimCareTeam, FCareTeamList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'supportingInfo', '', true, TFhirClaimSupportingInfo, FSupportingInfoList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'diagnosis', '', true, TFhirClaimDiagnosis, FDiagnosisList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'procedure', '', true, TFhirClaimProcedure, FProcedure_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'insurance', '', true, TFhirClaimInsurance, FInsuranceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'accident', '', false, TFhirClaimAccident, FAccident.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirClaimItem, FItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'total', 'Money', false, TFhirMoney, FTotal.Link));{2}
end;

function TFhirClaim.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    UseElement := asEnum(SYSTEMS_TFhirClaimUseEnum, CODES_TFhirClaimUseEnum, propValue);
    result := propValue
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'billablePeriod') then
  begin
    BillablePeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'fundsReserve') then
  begin
    FundsReserve := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'related') then
  begin
    RelatedList.add(propValue as TFhirClaimRelated){2a};
    result := propValue;
  end
  else if (propName = 'prescription') then
  begin
    Prescription := propValue as TFhirReference{TFhirDeviceRequest}{4b};
    result := propValue;
  end
  else if (propName = 'originalPrescription') then
  begin
    OriginalPrescription := propValue as TFhirReference{TFhirDeviceRequest}{4b};
    result := propValue;
  end
  else if (propName = 'payee') then
  begin
    Payee := propValue as TFhirClaimPayee{4b};
    result := propValue;
  end
  else if (propName = 'referral') then
  begin
    Referral := propValue as TFhirReference{TFhirServiceRequest}{4b};
    result := propValue;
  end
  else if (propName = 'facility') then
  begin
    Facility := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'careTeam') then
  begin
    CareTeamList.add(propValue as TFhirClaimCareTeam){2a};
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirClaimSupportingInfo){2a};
    result := propValue;
  end
  else if (propName = 'diagnosis') then
  begin
    DiagnosisList.add(propValue as TFhirClaimDiagnosis){2a};
    result := propValue;
  end
  else if (propName = 'procedure') then
  begin
    Procedure_List.add(propValue as TFhirClaimProcedure){2a};
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirClaimInsurance){2a};
    result := propValue;
  end
  else if (propName = 'accident') then
  begin
    Accident := propValue as TFhirClaimAccident{4b};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirClaimItem){2a};
    result := propValue;
  end
  else if (propName = 'total') then
  begin
    Total := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirClaim.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'related') then RelatedList.insertItem(index, propValue as TFhirClaimRelated){2a}
  else if (propName = 'careTeam') then CareTeamList.insertItem(index, propValue as TFhirClaimCareTeam){2a}
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirClaimSupportingInfo){2a}
  else if (propName = 'diagnosis') then DiagnosisList.insertItem(index, propValue as TFhirClaimDiagnosis){2a}
  else if (propName = 'procedure') then Procedure_List.insertItem(index, propValue as TFhirClaimProcedure){2a}
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirClaimInsurance){2a}
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirClaimItem){2a}
  else inherited;
end;

function TFhirClaim.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'billablePeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'enterer') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'insurer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'priority') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'fundsReserve') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'related') then result := RelatedList.new(){2}
  else if (propName = 'prescription') then result := TFhirReference{TFhirDeviceRequest}.create(){4b}
  else if (propName = 'originalPrescription') then result := TFhirReference{TFhirDeviceRequest}.create(){4b}
  else if (propName = 'payee') then result := TFhirClaimPayee.create(){4b}
  else if (propName = 'referral') then result := TFhirReference{TFhirServiceRequest}.create(){4b}
  else if (propName = 'facility') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'careTeam') then result := CareTeamList.new(){2}
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new(){2}
  else if (propName = 'diagnosis') then result := DiagnosisList.new(){2}
  else if (propName = 'procedure') then result := Procedure_List.new(){2}
  else if (propName = 'insurance') then result := InsuranceList.new(){2}
  else if (propName = 'accident') then result := TFhirClaimAccident.create(){4b}
  else if (propName = 'item') then result := ItemList.new(){2}
  else if (propName = 'total') then result := TFhirMoney.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaim.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'use') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'billablePeriod') then result := 'Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'fundsReserve') then result := 'CodeableConcept'
  else if (propName = 'related') then result := ''
  else if (propName = 'prescription') then result := 'Reference'
  else if (propName = 'originalPrescription') then result := 'Reference'
  else if (propName = 'payee') then result := ''
  else if (propName = 'referral') then result := 'Reference'
  else if (propName = 'facility') then result := 'Reference'
  else if (propName = 'careTeam') then result := ''
  else if (propName = 'supportingInfo') then result := ''
  else if (propName = 'diagnosis') then result := ''
  else if (propName = 'procedure') then result := ''
  else if (propName = 'insurance') then result := ''
  else if (propName = 'accident') then result := ''
  else if (propName = 'item') then result := ''
  else if (propName = 'total') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaim.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then SubTypeElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'billablePeriod') then BillablePeriodElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'fundsReserve') then FundsReserveElement := nil
  else if (propName = 'related') then deletePropertyValue('related', RelatedList, value) {2}
  else if (propName = 'prescription') then PrescriptionElement := nil
  else if (propName = 'originalPrescription') then OriginalPrescriptionElement := nil
  else if (propName = 'payee') then PayeeElement := nil
  else if (propName = 'referral') then ReferralElement := nil
  else if (propName = 'facility') then FacilityElement := nil
  else if (propName = 'careTeam') then deletePropertyValue('careTeam', CareTeamList, value) {2}
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value) {2}
  else if (propName = 'diagnosis') then deletePropertyValue('diagnosis', DiagnosisList, value) {2}
  else if (propName = 'procedure') then deletePropertyValue('procedure', Procedure_List, value) {2}
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value) {2}
  else if (propName = 'accident') then AccidentElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else if (propName = 'total') then TotalElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaim.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'subType') then SubTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'use') then UseElement := asEnum(SYSTEMS_TFhirClaimUseEnum, CODES_TFhirClaimUseEnum, new){4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'billablePeriod') then BillablePeriodElement := new as TFhirPeriod{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'enterer') then EntererElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept{4}
  else if (propName = 'fundsReserve') then FundsReserveElement := new as TFhirCodeableConcept{4}
  else if (propName = 'related') then replacePropertyValue('related', RelatedList, existing, new) {2}
  else if (propName = 'prescription') then PrescriptionElement := new as TFhirReference{TFhirDeviceRequest}{4}
  else if (propName = 'originalPrescription') then OriginalPrescriptionElement := new as TFhirReference{TFhirDeviceRequest}{4}
  else if (propName = 'payee') then PayeeElement := new as TFhirClaimPayee{4}
  else if (propName = 'referral') then ReferralElement := new as TFhirReference{TFhirServiceRequest}{4}
  else if (propName = 'facility') then FacilityElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'careTeam') then replacePropertyValue('careTeam', CareTeamList, existing, new) {2}
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new) {2}
  else if (propName = 'diagnosis') then replacePropertyValue('diagnosis', DiagnosisList, existing, new) {2}
  else if (propName = 'procedure') then replacePropertyValue('procedure', Procedure_List, existing, new) {2}
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new) {2}
  else if (propName = 'accident') then AccidentElement := new as TFhirClaimAccident{4}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else if (propName = 'total') then TotalElement := new as TFhirMoney{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaim.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'related') then RelatedList.move(source, destination){2a}
  else if (propName = 'careTeam') then CareTeamList.move(source, destination){2a}
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination){2a}
  else if (propName = 'diagnosis') then DiagnosisList.move(source, destination){2a}
  else if (propName = 'procedure') then Procedure_List.move(source, destination){2a}
  else if (propName = 'insurance') then InsuranceList.move(source, destination){2a}
  else if (propName = 'item') then ItemList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaim.fhirType : string;
begin
  result := 'Claim';
end;

function TFhirClaim.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FSubType) and isEmptyProp(FUse) and isEmptyProp(FPatient) and isEmptyProp(FBillablePeriod) and isEmptyProp(FCreated) and isEmptyProp(FEnterer) and isEmptyProp(FInsurer) and isEmptyProp(FProvider) and isEmptyProp(FPriority) and isEmptyProp(FFundsReserve) and isEmptyProp(FrelatedList) and isEmptyProp(FPrescription) and isEmptyProp(FOriginalPrescription) and isEmptyProp(FPayee) and isEmptyProp(FReferral) and isEmptyProp(FFacility) and isEmptyProp(FcareTeamList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FdiagnosisList) and isEmptyProp(Fprocedure_List) and isEmptyProp(FinsuranceList) and isEmptyProp(FAccident) and isEmptyProp(FitemList) and isEmptyProp(FTotal);
end;

function TFhirClaim.equals(other : TObject) : boolean; 
var
  o : TFhirClaim;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaim)) then
    result := false
  else
  begin
    o := TFhirClaim(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeElement, o.subTypeElement, true) and 
      compareDeep(useElement, o.useElement, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(billablePeriodElement, o.billablePeriodElement, true) and compareDeep(createdElement, o.createdElement, true) and 
      compareDeep(entererElement, o.entererElement, true) and compareDeep(insurerElement, o.insurerElement, true) and 
      compareDeep(providerElement, o.providerElement, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(fundsReserveElement, o.fundsReserveElement, true) and compareDeep(relatedList, o.relatedList, true) and 
      compareDeep(prescriptionElement, o.prescriptionElement, true) and compareDeep(originalPrescriptionElement, o.originalPrescriptionElement, true) and 
      compareDeep(payeeElement, o.payeeElement, true) and compareDeep(referralElement, o.referralElement, true) and 
      compareDeep(facilityElement, o.facilityElement, true) and compareDeep(careTeamList, o.careTeamList, true) and 
      compareDeep(supportingInfoList, o.supportingInfoList, true) and compareDeep(diagnosisList, o.diagnosisList, true) and 
      compareDeep(procedure_List, o.procedure_List, true) and compareDeep(insuranceList, o.insuranceList, true) and 
      compareDeep(accidentElement, o.accidentElement, true) and compareDeep(itemList, o.itemList, true) and 
      compareDeep(totalElement, o.totalElement, true);
  end;
end;

function TFhirClaim.Link : TFhirClaim;
begin
  result := TFhirClaim(inherited Link);
end;

function TFhirClaim.Clone : TFhirClaim;
begin
  result := TFhirClaim(inherited Clone);
end;

procedure TFhirClaim.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('subType');
  fields.add('use');
  fields.add('patient');
  fields.add('billablePeriod');
  fields.add('created');
  fields.add('enterer');
  fields.add('insurer');
  fields.add('provider');
  fields.add('priority');
  fields.add('fundsReserve');
  fields.add('related');
  fields.add('prescription');
  fields.add('originalPrescription');
  fields.add('payee');
  fields.add('referral');
  fields.add('facility');
  fields.add('careTeam');
  fields.add('supportingInfo');
  fields.add('diagnosis');
  fields.add('procedure');
  fields.add('insurance');
  fields.add('accident');
  fields.add('item');
  fields.add('total');
end;

{ TFhirClaim }

Function TFhirClaim.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirClaim.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirClaim.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirClaim.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirClaim.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Procedure TFhirClaim.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirClaim.SetSubType(value : TFhirCodeableConcept);
begin
  FSubType.free;
  FSubType := value;
end;

Procedure TFhirClaim.SetUse(value : TFhirEnum);
begin
  FUse.free;
  FUse := value;
end;

Function TFhirClaim.GetUseST : TFhirClaimUseEnum;
begin
  if FUse = nil then
    result := TFhirClaimUseEnum(0)
  else
    result := TFhirClaimUseEnum(StringArrayIndexOfSensitive(CODES_TFhirClaimUseEnum, FUse.value));
end;

Procedure TFhirClaim.SetUseST(value : TFhirClaimUseEnum);
begin
  if ord(value) = 0 then
    UseElement := nil
  else
    UseElement := TFhirEnum.create(SYSTEMS_TFhirClaimUseEnum[value], CODES_TFhirClaimUseEnum[value]);
end;

Procedure TFhirClaim.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirClaim.SetBillablePeriod(value : TFhirPeriod);
begin
  FBillablePeriod.free;
  FBillablePeriod := value;
end;

Procedure TFhirClaim.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirClaim.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirClaim.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirClaim.SetEnterer(value : TFhirReference{TFhirPractitioner});
begin
  FEnterer.free;
  FEnterer := value;
end;

Procedure TFhirClaim.SetInsurer(value : TFhirReference{TFhirOrganization});
begin
  FInsurer.free;
  FInsurer := value;
end;

Procedure TFhirClaim.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirClaim.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value;
end;

Procedure TFhirClaim.SetFundsReserve(value : TFhirCodeableConcept);
begin
  FFundsReserve.free;
  FFundsReserve := value;
end;

Function TFhirClaim.GetRelatedList : TFhirClaimRelatedList;
begin
  if FRelatedList = nil then
    FRelatedList := TFhirClaimRelatedList.Create;
  result := FRelatedList;
end;

Function TFhirClaim.GetHasRelatedList : boolean;
begin
  result := (FRelatedList <> nil) and (FRelatedList.count > 0);
end;

Procedure TFhirClaim.SetPrescription(value : TFhirReference{TFhirDeviceRequest});
begin
  FPrescription.free;
  FPrescription := value;
end;

Procedure TFhirClaim.SetOriginalPrescription(value : TFhirReference{TFhirDeviceRequest});
begin
  FOriginalPrescription.free;
  FOriginalPrescription := value;
end;

Procedure TFhirClaim.SetPayee(value : TFhirClaimPayee);
begin
  FPayee.free;
  FPayee := value;
end;

Procedure TFhirClaim.SetReferral(value : TFhirReference{TFhirServiceRequest});
begin
  FReferral.free;
  FReferral := value;
end;

Procedure TFhirClaim.SetFacility(value : TFhirReference{TFhirLocation});
begin
  FFacility.free;
  FFacility := value;
end;

Function TFhirClaim.GetCareTeamList : TFhirClaimCareTeamList;
begin
  if FCareTeamList = nil then
    FCareTeamList := TFhirClaimCareTeamList.Create;
  result := FCareTeamList;
end;

Function TFhirClaim.GetHasCareTeamList : boolean;
begin
  result := (FCareTeamList <> nil) and (FCareTeamList.count > 0);
end;

Function TFhirClaim.GetSupportingInfoList : TFhirClaimSupportingInfoList;
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirClaimSupportingInfoList.Create;
  result := FSupportingInfoList;
end;

Function TFhirClaim.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

Function TFhirClaim.GetDiagnosisList : TFhirClaimDiagnosisList;
begin
  if FDiagnosisList = nil then
    FDiagnosisList := TFhirClaimDiagnosisList.Create;
  result := FDiagnosisList;
end;

Function TFhirClaim.GetHasDiagnosisList : boolean;
begin
  result := (FDiagnosisList <> nil) and (FDiagnosisList.count > 0);
end;

Function TFhirClaim.GetProcedure_List : TFhirClaimProcedureList;
begin
  if FProcedure_List = nil then
    FProcedure_List := TFhirClaimProcedureList.Create;
  result := FProcedure_List;
end;

Function TFhirClaim.GetHasProcedure_List : boolean;
begin
  result := (FProcedure_List <> nil) and (FProcedure_List.count > 0);
end;

Function TFhirClaim.GetInsuranceList : TFhirClaimInsuranceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirClaimInsuranceList.Create;
  result := FInsuranceList;
end;

Function TFhirClaim.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

Procedure TFhirClaim.SetAccident(value : TFhirClaimAccident);
begin
  FAccident.free;
  FAccident := value;
end;

Function TFhirClaim.GetItemList : TFhirClaimItemList;
begin
  if FItemList = nil then
    FItemList := TFhirClaimItemList.Create;
  result := FItemList;
end;

Function TFhirClaim.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

Procedure TFhirClaim.SetTotal(value : TFhirMoney);
begin
  FTotal.free;
  FTotal := value;
end;

function TFhirClaim.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSubType.sizeInBytes);
  inc(result, FUse.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FBillablePeriod.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FEnterer.sizeInBytes);
  inc(result, FInsurer.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FFundsReserve.sizeInBytes);
  inc(result, FrelatedList.sizeInBytes);
  inc(result, FPrescription.sizeInBytes);
  inc(result, FOriginalPrescription.sizeInBytes);
  inc(result, FPayee.sizeInBytes);
  inc(result, FReferral.sizeInBytes);
  inc(result, FFacility.sizeInBytes);
  inc(result, FcareTeamList.sizeInBytes);
  inc(result, FsupportingInfoList.sizeInBytes);
  inc(result, FdiagnosisList.sizeInBytes);
  inc(result, Fprocedure_List.sizeInBytes);
  inc(result, FinsuranceList.sizeInBytes);
  inc(result, FAccident.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
  inc(result, FTotal.sizeInBytes);
end;

{ TFhirClaimListEnumerator }

Constructor TFhirClaimListEnumerator.Create(list : TFhirClaimList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimListEnumerator.GetCurrent : TFhirClaim;
begin
  Result := FList[FIndex];
end;

function TFhirClaimListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimList }
procedure TFhirClaimList.AddItem(value: TFhirClaim);
begin
  assert(value.ClassName = 'TFhirClaim', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaim');
  add(value);
end;

function TFhirClaimList.Append: TFhirClaim;
begin
  result := TFhirClaim.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimList.ClearItems;
begin
  Clear;
end;

function TFhirClaimList.GetEnumerator : TFhirClaimListEnumerator;
begin
  result := TFhirClaimListEnumerator.Create(self.link);
end;

function TFhirClaimList.Clone: TFhirClaimList;
begin
  result := TFhirClaimList(inherited Clone);
end;

function TFhirClaimList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimList.GetItemN(index: Integer): TFhirClaim;
begin
  result := TFhirClaim(ObjectByIndex[index]);
end;

function TFhirClaimList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaim;
end;
function TFhirClaimList.IndexOf(value: TFhirClaim): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimList.Insert(index: Integer): TFhirClaim;
begin
  result := TFhirClaim.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimList.InsertItem(index: Integer; value: TFhirClaim);
begin
  assert(value is TFhirClaim);
  Inherited Insert(index, value);
end;

function TFhirClaimList.Item(index: Integer): TFhirClaim;
begin
  result := TFhirClaim(ObjectByIndex[index]);
end;

function TFhirClaimList.Link: TFhirClaimList;
begin
  result := TFhirClaimList(inherited Link);
end;

procedure TFhirClaimList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimList.SetItemByIndex(index: Integer; value: TFhirClaim);
begin
  assert(value is TFhirClaim);
  FhirClaims[index] := value;
end;

procedure TFhirClaimList.SetItemN(index: Integer; value: TFhirClaim);
begin
  assert(value is TFhirClaim);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CLAIM}

{$IFDEF FHIR_CLAIMRESPONSE}

{ TFhirClaimResponseItem }

constructor TFhirClaimResponseItem.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItem.Destroy;
begin
  FItemSequence.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirClaimResponseItem.Assign(oSource : TFslObject);
begin
  inherited;
  itemSequenceElement := TFhirClaimResponseItem(oSource).itemSequenceElement.Clone;
  if (TFhirClaimResponseItem(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseItem(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseItem(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseItem(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponseItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirClaimResponseItemDetailList.Create;
    FDetailList.Assign(TFhirClaimResponseItem(oSource).FDetailList);
  end;
end;

procedure TFhirClaimResponseItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'itemSequence') Then
     list.add(self.link, 'itemSequence', FItemSequence.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirClaimResponseItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'itemSequence', 'positiveInt', false, TFhirPositiveInt, FItemSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'detail', '', true, TFhirClaimResponseItemDetail, FDetailList.Link)){3};
end;

function TFhirClaimResponseItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'itemSequence') then
  begin
    ItemSequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication){2a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirClaimResponseItemDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirClaimResponseItemDetail){2a}
  else inherited;
end;

function TFhirClaimResponseItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'itemSequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'itemSequence') then result := 'positiveInt'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'detail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'itemSequence') then ItemSequenceElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'itemSequence') then ItemSequenceElement := asPositiveInt(new){5b}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItem.fhirType : string;
begin
  result := 'item';
end;

function TFhirClaimResponseItem.Link : TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem(inherited Link);
end;

function TFhirClaimResponseItem.Clone : TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem(inherited Clone);
end;

function TFhirClaimResponseItem.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItem)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItem(other);
    result := compareDeep(itemSequenceElement, o.itemSequenceElement, true) and 
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true) and 
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirClaimResponseItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItemSequence) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FdetailList);
end;

procedure TFhirClaimResponseItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('itemSequence');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('detail');
end;

{ TFhirClaimResponseItem }

Procedure TFhirClaimResponseItem.SetItemSequence(value : TFhirPositiveInt);
begin
  FItemSequence.free;
  FItemSequence := value;
end;

Function TFhirClaimResponseItem.GetItemSequenceST : String;
begin
  if FItemSequence = nil then
    result := ''
  else
    result := FItemSequence.value;
end;

Procedure TFhirClaimResponseItem.SetItemSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FItemSequence = nil then
      FItemSequence := TFhirPositiveInt.create;
    FItemSequence.value := value
  end
  else if FItemSequence <> nil then
    FItemSequence.value := '';
end;

Function TFhirClaimResponseItem.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirClaimResponseItem.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirClaimResponseItem.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirClaimResponseItem.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

Function TFhirClaimResponseItem.GetDetailList : TFhirClaimResponseItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirClaimResponseItemDetailList.Create;
  result := FDetailList;
end;

Function TFhirClaimResponseItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirClaimResponseItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItemSequence.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirClaimResponseItemListEnumerator }

Constructor TFhirClaimResponseItemListEnumerator.Create(list : TFhirClaimResponseItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemListEnumerator.GetCurrent : TFhirClaimResponseItem;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseItemList }
procedure TFhirClaimResponseItemList.AddItem(value: TFhirClaimResponseItem);
begin
  assert(value.ClassName = 'TFhirClaimResponseItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItem');
  add(value);
end;

function TFhirClaimResponseItemList.Append: TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemList.GetEnumerator : TFhirClaimResponseItemListEnumerator;
begin
  result := TFhirClaimResponseItemListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemList.Clone: TFhirClaimResponseItemList;
begin
  result := TFhirClaimResponseItemList(inherited Clone);
end;

function TFhirClaimResponseItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemList.GetItemN(index: Integer): TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItem;
end;
function TFhirClaimResponseItemList.IndexOf(value: TFhirClaimResponseItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemList.Insert(index: Integer): TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemList.InsertItem(index: Integer; value: TFhirClaimResponseItem);
begin
  assert(value is TFhirClaimResponseItem);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemList.Item(index: Integer): TFhirClaimResponseItem;
begin
  result := TFhirClaimResponseItem(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemList.Link: TFhirClaimResponseItemList;
begin
  result := TFhirClaimResponseItemList(inherited Link);
end;

procedure TFhirClaimResponseItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItem);
begin
  assert(value is TFhirClaimResponseItem);
  FhirClaimResponseItems[index] := value;
end;

procedure TFhirClaimResponseItemList.SetItemN(index: Integer; value: TFhirClaimResponseItem);
begin
  assert(value is TFhirClaimResponseItem);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseItemAdjudication }

constructor TFhirClaimResponseItemAdjudication.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItemAdjudication.Destroy;
begin
  FCategory.free;
  FReason.free;
  FAmount.free;
  FValue.free;
  inherited;
end;

procedure TFhirClaimResponseItemAdjudication.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirClaimResponseItemAdjudication(oSource).category.Clone;
  reason := TFhirClaimResponseItemAdjudication(oSource).reason.Clone;
  amount := TFhirClaimResponseItemAdjudication(oSource).amount.Clone;
  valueElement := TFhirClaimResponseItemAdjudication(oSource).valueElement.Clone;
end;

procedure TFhirClaimResponseItemAdjudication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirClaimResponseItemAdjudication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'decimal', false, TFhirDecimal, FValue.Link));{2}
end;

function TFhirClaimResponseItemAdjudication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItemAdjudication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseItemAdjudication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'amount') then result := TFhirMoney.create(){4b}
  else if (propName = 'value') then result := TFhirDecimal.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItemAdjudication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Money'
  else if (propName = 'value') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItemAdjudication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItemAdjudication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney{4}
  else if (propName = 'value') then ValueElement := asDecimal(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItemAdjudication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItemAdjudication.fhirType : string;
begin
  result := 'adjudication';
end;

function TFhirClaimResponseItemAdjudication.Link : TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication(inherited Link);
end;

function TFhirClaimResponseItemAdjudication.Clone : TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication(inherited Clone);
end;

function TFhirClaimResponseItemAdjudication.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseItemAdjudication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItemAdjudication)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItemAdjudication(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(reasonElement, o.reasonElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirClaimResponseItemAdjudication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FReason) and isEmptyProp(FAmount) and isEmptyProp(FValue);
end;

procedure TFhirClaimResponseItemAdjudication.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('reason');
  fields.add('amount');
  fields.add('value');
end;

{ TFhirClaimResponseItemAdjudication }

Procedure TFhirClaimResponseItemAdjudication.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirClaimResponseItemAdjudication.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

Procedure TFhirClaimResponseItemAdjudication.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

Procedure TFhirClaimResponseItemAdjudication.SetValue(value : TFhirDecimal);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirClaimResponseItemAdjudication.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirClaimResponseItemAdjudication.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirDecimal.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirClaimResponseItemAdjudication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirClaimResponseItemAdjudicationListEnumerator }

Constructor TFhirClaimResponseItemAdjudicationListEnumerator.Create(list : TFhirClaimResponseItemAdjudicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemAdjudicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemAdjudicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemAdjudicationListEnumerator.GetCurrent : TFhirClaimResponseItemAdjudication;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemAdjudicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseItemAdjudicationList }
procedure TFhirClaimResponseItemAdjudicationList.AddItem(value: TFhirClaimResponseItemAdjudication);
begin
  assert(value.ClassName = 'TFhirClaimResponseItemAdjudication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItemAdjudication');
  add(value);
end;

function TFhirClaimResponseItemAdjudicationList.Append: TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemAdjudicationList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemAdjudicationList.GetEnumerator : TFhirClaimResponseItemAdjudicationListEnumerator;
begin
  result := TFhirClaimResponseItemAdjudicationListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemAdjudicationList.Clone: TFhirClaimResponseItemAdjudicationList;
begin
  result := TFhirClaimResponseItemAdjudicationList(inherited Clone);
end;

function TFhirClaimResponseItemAdjudicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemAdjudicationList.GetItemN(index: Integer): TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemAdjudicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItemAdjudication;
end;
function TFhirClaimResponseItemAdjudicationList.IndexOf(value: TFhirClaimResponseItemAdjudication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemAdjudicationList.Insert(index: Integer): TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemAdjudicationList.InsertItem(index: Integer; value: TFhirClaimResponseItemAdjudication);
begin
  assert(value is TFhirClaimResponseItemAdjudication);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemAdjudicationList.Item(index: Integer): TFhirClaimResponseItemAdjudication;
begin
  result := TFhirClaimResponseItemAdjudication(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemAdjudicationList.Link: TFhirClaimResponseItemAdjudicationList;
begin
  result := TFhirClaimResponseItemAdjudicationList(inherited Link);
end;

procedure TFhirClaimResponseItemAdjudicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemAdjudicationList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItemAdjudication);
begin
  assert(value is TFhirClaimResponseItemAdjudication);
  FhirClaimResponseItemAdjudications[index] := value;
end;

procedure TFhirClaimResponseItemAdjudicationList.SetItemN(index: Integer; value: TFhirClaimResponseItemAdjudication);
begin
  assert(value is TFhirClaimResponseItemAdjudication);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseItemDetail }

constructor TFhirClaimResponseItemDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItemDetail.Destroy;
begin
  FDetailSequence.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FSubDetailList.Free;
  inherited;
end;

procedure TFhirClaimResponseItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  detailSequenceElement := TFhirClaimResponseItemDetail(oSource).detailSequenceElement.Clone;
  if (TFhirClaimResponseItemDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseItemDetail(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseItemDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseItemDetail(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponseItemDetail(oSource).FSubDetailList = nil) then
  begin
    FSubDetailList.free;
    FSubDetailList := nil;
  end
  else
  begin
    if FSubDetailList = nil then
      FSubDetailList := TFhirClaimResponseItemDetailSubDetailList.Create;
    FSubDetailList.Assign(TFhirClaimResponseItemDetail(oSource).FSubDetailList);
  end;
end;

procedure TFhirClaimResponseItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'detailSequence') Then
     list.add(self.link, 'detailSequence', FDetailSequence.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'subDetail') Then
    list.addAll(self, 'subDetail', FSubDetailList);
end;

procedure TFhirClaimResponseItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'detailSequence', 'positiveInt', false, TFhirPositiveInt, FDetailSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '@ClaimResponse.item.adjudication', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subDetail', '', true, TFhirClaimResponseItemDetailSubDetail, FSubDetailList.Link)){3};
end;

function TFhirClaimResponseItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'detailSequence') then
  begin
    DetailSequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication){2a};
    result := propValue;
  end
  else if (propName = 'subDetail') then
  begin
    SubDetailList.add(propValue as TFhirClaimResponseItemDetailSubDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication){2a}
  else if (propName = 'subDetail') then SubDetailList.insertItem(index, propValue as TFhirClaimResponseItemDetailSubDetail){2a}
  else inherited;
end;

function TFhirClaimResponseItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'detailSequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else if (propName = 'subDetail') then result := SubDetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'detailSequence') then result := 'positiveInt'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := '@ClaimResponse.item.adjudication'
  else if (propName = 'subDetail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'detailSequence') then DetailSequenceElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else if (propName = 'subDetail') then deletePropertyValue('subDetail', SubDetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'detailSequence') then DetailSequenceElement := asPositiveInt(new){5b}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else if (propName = 'subDetail') then replacePropertyValue('subDetail', SubDetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else if (propName = 'subDetail') then SubDetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItemDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirClaimResponseItemDetail.Link : TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail(inherited Link);
end;

function TFhirClaimResponseItemDetail.Clone : TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail(inherited Clone);
end;

function TFhirClaimResponseItemDetail.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItemDetail)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItemDetail(other);
    result := compareDeep(detailSequenceElement, o.detailSequenceElement, true) and 
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true) and 
      compareDeep(subDetailList, o.subDetailList, true);
  end;
end;

function TFhirClaimResponseItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDetailSequence) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FsubDetailList);
end;

procedure TFhirClaimResponseItemDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('detailSequence');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('subDetail');
end;

{ TFhirClaimResponseItemDetail }

Procedure TFhirClaimResponseItemDetail.SetDetailSequence(value : TFhirPositiveInt);
begin
  FDetailSequence.free;
  FDetailSequence := value;
end;

Function TFhirClaimResponseItemDetail.GetDetailSequenceST : String;
begin
  if FDetailSequence = nil then
    result := ''
  else
    result := FDetailSequence.value;
end;

Procedure TFhirClaimResponseItemDetail.SetDetailSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FDetailSequence = nil then
      FDetailSequence := TFhirPositiveInt.create;
    FDetailSequence.value := value
  end
  else if FDetailSequence <> nil then
    FDetailSequence.value := '';
end;

Function TFhirClaimResponseItemDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirClaimResponseItemDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirClaimResponseItemDetail.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirClaimResponseItemDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

Function TFhirClaimResponseItemDetail.GetSubDetailList : TFhirClaimResponseItemDetailSubDetailList;
begin
  if FSubDetailList = nil then
    FSubDetailList := TFhirClaimResponseItemDetailSubDetailList.Create;
  result := FSubDetailList;
end;

Function TFhirClaimResponseItemDetail.GetHasSubDetailList : boolean;
begin
  result := (FSubDetailList <> nil) and (FSubDetailList.count > 0);
end;

function TFhirClaimResponseItemDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDetailSequence.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FsubDetailList.sizeInBytes);
end;

{ TFhirClaimResponseItemDetailListEnumerator }

Constructor TFhirClaimResponseItemDetailListEnumerator.Create(list : TFhirClaimResponseItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemDetailListEnumerator.GetCurrent : TFhirClaimResponseItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseItemDetailList }
procedure TFhirClaimResponseItemDetailList.AddItem(value: TFhirClaimResponseItemDetail);
begin
  assert(value.ClassName = 'TFhirClaimResponseItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItemDetail');
  add(value);
end;

function TFhirClaimResponseItemDetailList.Append: TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemDetailList.GetEnumerator : TFhirClaimResponseItemDetailListEnumerator;
begin
  result := TFhirClaimResponseItemDetailListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemDetailList.Clone: TFhirClaimResponseItemDetailList;
begin
  result := TFhirClaimResponseItemDetailList(inherited Clone);
end;

function TFhirClaimResponseItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemDetailList.GetItemN(index: Integer): TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItemDetail;
end;
function TFhirClaimResponseItemDetailList.IndexOf(value: TFhirClaimResponseItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemDetailList.Insert(index: Integer): TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailList.InsertItem(index: Integer; value: TFhirClaimResponseItemDetail);
begin
  assert(value is TFhirClaimResponseItemDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemDetailList.Item(index: Integer): TFhirClaimResponseItemDetail;
begin
  result := TFhirClaimResponseItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailList.Link: TFhirClaimResponseItemDetailList;
begin
  result := TFhirClaimResponseItemDetailList(inherited Link);
end;

procedure TFhirClaimResponseItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemDetailList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItemDetail);
begin
  assert(value is TFhirClaimResponseItemDetail);
  FhirClaimResponseItemDetails[index] := value;
end;

procedure TFhirClaimResponseItemDetailList.SetItemN(index: Integer; value: TFhirClaimResponseItemDetail);
begin
  assert(value is TFhirClaimResponseItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseItemDetailSubDetail }

constructor TFhirClaimResponseItemDetailSubDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseItemDetailSubDetail.Destroy;
begin
  FSubDetailSequence.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  inherited;
end;

procedure TFhirClaimResponseItemDetailSubDetail.Assign(oSource : TFslObject);
begin
  inherited;
  subDetailSequenceElement := TFhirClaimResponseItemDetailSubDetail(oSource).subDetailSequenceElement.Clone;
  if (TFhirClaimResponseItemDetailSubDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseItemDetailSubDetail(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseItemDetailSubDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseItemDetailSubDetail(oSource).FAdjudicationList);
  end;
end;

procedure TFhirClaimResponseItemDetailSubDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'subDetailSequence') Then
     list.add(self.link, 'subDetailSequence', FSubDetailSequence.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
end;

procedure TFhirClaimResponseItemDetailSubDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'subDetailSequence', 'positiveInt', false, TFhirPositiveInt, FSubDetailSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '@ClaimResponse.item.adjudication', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link)){3};
end;

function TFhirClaimResponseItemDetailSubDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'subDetailSequence') then
  begin
    SubDetailSequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseItemDetailSubDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication){2a}
  else inherited;
end;

function TFhirClaimResponseItemDetailSubDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'subDetailSequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseItemDetailSubDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'subDetailSequence') then result := 'positiveInt'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := '@ClaimResponse.item.adjudication'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseItemDetailSubDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'subDetailSequence') then SubDetailSequenceElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseItemDetailSubDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'subDetailSequence') then SubDetailSequenceElement := asPositiveInt(new){5b}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseItemDetailSubDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseItemDetailSubDetail.fhirType : string;
begin
  result := 'subDetail';
end;

function TFhirClaimResponseItemDetailSubDetail.Link : TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail(inherited Link);
end;

function TFhirClaimResponseItemDetailSubDetail.Clone : TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail(inherited Clone);
end;

function TFhirClaimResponseItemDetailSubDetail.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseItemDetailSubDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseItemDetailSubDetail)) then
    result := false
  else
  begin
    o := TFhirClaimResponseItemDetailSubDetail(other);
    result := compareDeep(subDetailSequenceElement, o.subDetailSequenceElement, true) and 
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true);
  end;
end;

function TFhirClaimResponseItemDetailSubDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubDetailSequence) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList);
end;

procedure TFhirClaimResponseItemDetailSubDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('subDetailSequence');
  fields.add('noteNumber');
  fields.add('adjudication');
end;

{ TFhirClaimResponseItemDetailSubDetail }

Procedure TFhirClaimResponseItemDetailSubDetail.SetSubDetailSequence(value : TFhirPositiveInt);
begin
  FSubDetailSequence.free;
  FSubDetailSequence := value;
end;

Function TFhirClaimResponseItemDetailSubDetail.GetSubDetailSequenceST : String;
begin
  if FSubDetailSequence = nil then
    result := ''
  else
    result := FSubDetailSequence.value;
end;

Procedure TFhirClaimResponseItemDetailSubDetail.SetSubDetailSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSubDetailSequence = nil then
      FSubDetailSequence := TFhirPositiveInt.create;
    FSubDetailSequence.value := value
  end
  else if FSubDetailSequence <> nil then
    FSubDetailSequence.value := '';
end;

Function TFhirClaimResponseItemDetailSubDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirClaimResponseItemDetailSubDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirClaimResponseItemDetailSubDetail.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirClaimResponseItemDetailSubDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirClaimResponseItemDetailSubDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSubDetailSequence.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
end;

{ TFhirClaimResponseItemDetailSubDetailListEnumerator }

Constructor TFhirClaimResponseItemDetailSubDetailListEnumerator.Create(list : TFhirClaimResponseItemDetailSubDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseItemDetailSubDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseItemDetailSubDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseItemDetailSubDetailListEnumerator.GetCurrent : TFhirClaimResponseItemDetailSubDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseItemDetailSubDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseItemDetailSubDetailList }
procedure TFhirClaimResponseItemDetailSubDetailList.AddItem(value: TFhirClaimResponseItemDetailSubDetail);
begin
  assert(value.ClassName = 'TFhirClaimResponseItemDetailSubDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseItemDetailSubDetail');
  add(value);
end;

function TFhirClaimResponseItemDetailSubDetailList.Append: TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailSubDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseItemDetailSubDetailList.GetEnumerator : TFhirClaimResponseItemDetailSubDetailListEnumerator;
begin
  result := TFhirClaimResponseItemDetailSubDetailListEnumerator.Create(self.link);
end;

function TFhirClaimResponseItemDetailSubDetailList.Clone: TFhirClaimResponseItemDetailSubDetailList;
begin
  result := TFhirClaimResponseItemDetailSubDetailList(inherited Clone);
end;

function TFhirClaimResponseItemDetailSubDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseItemDetailSubDetailList.GetItemN(index: Integer): TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailSubDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseItemDetailSubDetail;
end;
function TFhirClaimResponseItemDetailSubDetailList.IndexOf(value: TFhirClaimResponseItemDetailSubDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseItemDetailSubDetailList.Insert(index: Integer): TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseItemDetailSubDetailList.InsertItem(index: Integer; value: TFhirClaimResponseItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseItemDetailSubDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseItemDetailSubDetailList.Item(index: Integer): TFhirClaimResponseItemDetailSubDetail;
begin
  result := TFhirClaimResponseItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseItemDetailSubDetailList.Link: TFhirClaimResponseItemDetailSubDetailList;
begin
  result := TFhirClaimResponseItemDetailSubDetailList(inherited Link);
end;

procedure TFhirClaimResponseItemDetailSubDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseItemDetailSubDetailList.SetItemByIndex(index: Integer; value: TFhirClaimResponseItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseItemDetailSubDetail);
  FhirClaimResponseItemDetailSubDetails[index] := value;
end;

procedure TFhirClaimResponseItemDetailSubDetailList.SetItemN(index: Integer; value: TFhirClaimResponseItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseItemDetailSubDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseAddItem }

constructor TFhirClaimResponseAddItem.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseAddItem.Destroy;
begin
  FItemSequenceList.Free;
  FDetailSequenceList.Free;
  FSubdetailSequenceList.Free;
  FProviderList.Free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FServiced.free;
  FLocation.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FBodySite.free;
  FSubSiteList.Free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirClaimResponseAddItem.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClaimResponseAddItem(oSource).FItemSequenceList = nil) then
  begin
    FItemSequenceList.free;
    FItemSequenceList := nil;
  end
  else
  begin
    if FItemSequenceList = nil then
      FItemSequenceList := TFhirPositiveIntList.Create;
    FItemSequenceList.Assign(TFhirClaimResponseAddItem(oSource).FItemSequenceList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FDetailSequenceList = nil) then
  begin
    FDetailSequenceList.free;
    FDetailSequenceList := nil;
  end
  else
  begin
    if FDetailSequenceList = nil then
      FDetailSequenceList := TFhirPositiveIntList.Create;
    FDetailSequenceList.Assign(TFhirClaimResponseAddItem(oSource).FDetailSequenceList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FSubdetailSequenceList = nil) then
  begin
    FSubdetailSequenceList.free;
    FSubdetailSequenceList := nil;
  end
  else
  begin
    if FSubdetailSequenceList = nil then
      FSubdetailSequenceList := TFhirPositiveIntList.Create;
    FSubdetailSequenceList.Assign(TFhirClaimResponseAddItem(oSource).FSubdetailSequenceList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FProviderList = nil) then
  begin
    FProviderList.free;
    FProviderList := nil;
  end
  else
  begin
    if FProviderList = nil then
      FProviderList := TFhirReferenceList{TFhirPractitioner}.Create;
    FProviderList.Assign(TFhirClaimResponseAddItem(oSource).FProviderList);
  end;
  productOrService := TFhirClaimResponseAddItem(oSource).productOrService.Clone;
  if (TFhirClaimResponseAddItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimResponseAddItem(oSource).FModifierList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirClaimResponseAddItem(oSource).FProgramCodeList);
  end;
  serviced := TFhirClaimResponseAddItem(oSource).serviced.Clone;
  location := TFhirClaimResponseAddItem(oSource).location.Clone;
  quantity := TFhirClaimResponseAddItem(oSource).quantity.Clone;
  unitPrice := TFhirClaimResponseAddItem(oSource).unitPrice.Clone;
  factorElement := TFhirClaimResponseAddItem(oSource).factorElement.Clone;
  net := TFhirClaimResponseAddItem(oSource).net.Clone;
  bodySite := TFhirClaimResponseAddItem(oSource).bodySite.Clone;
  if (TFhirClaimResponseAddItem(oSource).FSubSiteList = nil) then
  begin
    FSubSiteList.free;
    FSubSiteList := nil;
  end
  else
  begin
    if FSubSiteList = nil then
      FSubSiteList := TFhirCodeableConceptList.Create;
    FSubSiteList.Assign(TFhirClaimResponseAddItem(oSource).FSubSiteList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseAddItem(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseAddItem(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponseAddItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirClaimResponseAddItemDetailList.Create;
    FDetailList.Assign(TFhirClaimResponseAddItem(oSource).FDetailList);
  end;
end;

procedure TFhirClaimResponseAddItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'itemSequence') Then
    list.addAll(self, 'itemSequence', FItemSequenceList);
  if (child_name = 'detailSequence') Then
    list.addAll(self, 'detailSequence', FDetailSequenceList);
  if (child_name = 'subdetailSequence') Then
    list.addAll(self, 'subdetailSequence', FSubdetailSequenceList);
  if (child_name = 'provider') Then
    list.addAll(self, 'provider', FProviderList);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'subSite') Then
    list.addAll(self, 'subSite', FSubSiteList);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirClaimResponseAddItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'itemSequence', 'positiveInt', true, TFhirPositiveInt, FItemSequenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'detailSequence', 'positiveInt', true, TFhirPositiveInt, FDetailSequenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subdetailSequence', 'positiveInt', true, TFhirPositiveInt, FSubdetailSequenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', true, TFhirReference{TFhirPractitioner}, FProviderList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirType, FServiced.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location[x]', 'CodeableConcept|Address|Reference(Location)', false, TFhirType, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subSite', 'CodeableConcept', true, TFhirCodeableConcept, FSubSiteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '@ClaimResponse.item.adjudication', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'detail', '', true, TFhirClaimResponseAddItemDetail, FDetailList.Link)){3};
end;

function TFhirClaimResponseAddItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'itemSequence') then
  begin
    ItemSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'detailSequence') then
  begin
    DetailSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'subdetailSequence') then
  begin
    SubdetailSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'provider') then
  begin
    ProviderList.add(propValue as TFhirReference{TFhirPractitioner}){2a};
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then
  begin
    Location := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subSite') then
  begin
    SubSiteList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication){2a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirClaimResponseAddItemDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseAddItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'itemSequence') then ItemSequenceList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'detailSequence') then DetailSequenceList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'subdetailSequence') then SubdetailSequenceList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'provider') then ProviderList.insertItem(index, propValue as TFhirReference{TFhirPractitioner}){2a}
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'subSite') then SubSiteList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirClaimResponseAddItemDetail){2a}
  else inherited;
end;

function TFhirClaimResponseAddItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'itemSequence') then result := ItemSequenceList.new(){2}
  else if (propName = 'detailSequence') then result := DetailSequenceList.new(){2}
  else if (propName = 'subdetailSequence') then result := SubdetailSequenceList.new(){2}
  else if (propName = 'provider') then result := ProviderList.new(){2}
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'programCode') then result := ProgramCodeList.new(){2}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced'){4x}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location'){4x}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subSite') then result := SubSiteList.new(){2}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseAddItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'itemSequence') then result := 'positiveInt'
  else if (propName = 'detailSequence') then result := 'positiveInt'
  else if (propName = 'subdetailSequence') then result := 'positiveInt'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'location[x]') then result := 'CodeableConcept|Address|Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'subSite') then result := 'CodeableConcept'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := '@ClaimResponse.item.adjudication'
  else if (propName = 'detail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseAddItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'itemSequence') then deletePropertyValue('itemSequence', ItemSequenceList, value) {2}
  else if (propName = 'detailSequence') then deletePropertyValue('detailSequence', DetailSequenceList, value) {2}
  else if (propName = 'subdetailSequence') then deletePropertyValue('subdetailSequence', SubdetailSequenceList, value) {2}
  else if (propName = 'provider') then deletePropertyValue('provider', ProviderList, value) {2}
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {2}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil{4x}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := nil{4x}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'subSite') then deletePropertyValue('subSite', SubSiteList, value) {2}
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseAddItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'itemSequence') then replacePropertyValue('itemSequence', ItemSequenceList, existing, new) {2}
  else if (propName = 'detailSequence') then replacePropertyValue('detailSequence', DetailSequenceList, existing, new) {2}
  else if (propName = 'subdetailSequence') then replacePropertyValue('subdetailSequence', SubdetailSequenceList, existing, new) {2}
  else if (propName = 'provider') then replacePropertyValue('provider', ProviderList, existing, new) {2}
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {2}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := new as TFhirType{4x}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subSite') then replacePropertyValue('subSite', SubSiteList, existing, new) {2}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseAddItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'itemSequence') then ItemSequenceList.move(source, destination){2}
  else if (propName = 'detailSequence') then DetailSequenceList.move(source, destination){2}
  else if (propName = 'subdetailSequence') then SubdetailSequenceList.move(source, destination){2}
  else if (propName = 'provider') then ProviderList.move(source, destination){2a}
  else if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination){2a}
  else if (propName = 'subSite') then SubSiteList.move(source, destination){2a}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseAddItem.fhirType : string;
begin
  result := 'addItem';
end;

function TFhirClaimResponseAddItem.Link : TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem(inherited Link);
end;

function TFhirClaimResponseAddItem.Clone : TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem(inherited Clone);
end;

function TFhirClaimResponseAddItem.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseAddItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseAddItem)) then
    result := false
  else
  begin
    o := TFhirClaimResponseAddItem(other);
    result := compareDeep(itemSequenceList, o.itemSequenceList, true) and compareDeep(detailSequenceList, o.detailSequenceList, true) and 
      compareDeep(subdetailSequenceList, o.subdetailSequenceList, true) and compareDeep(providerList, o.providerList, true) and 
      compareDeep(productOrServiceElement, o.productOrServiceElement, true) and compareDeep(modifierList, o.modifierList, true) and 
      compareDeep(programCodeList, o.programCodeList, true) and compareDeep(servicedElement, o.servicedElement, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(netElement, o.netElement, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and 
      compareDeep(subSiteList, o.subSiteList, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true) and compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirClaimResponseAddItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FitemSequenceList) and isEmptyProp(FdetailSequenceList) and isEmptyProp(FsubdetailSequenceList) and isEmptyProp(FproviderList) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FServiced) and isEmptyProp(FLocation) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FBodySite) and isEmptyProp(FsubSiteList) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FdetailList);
end;

procedure TFhirClaimResponseAddItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('itemSequence');
  fields.add('detailSequence');
  fields.add('subdetailSequence');
  fields.add('provider');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('serviced[x]');
  fields.add('location[x]');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('bodySite');
  fields.add('subSite');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('detail');
end;

{ TFhirClaimResponseAddItem }

Function TFhirClaimResponseAddItem.GetItemSequenceList : TFhirPositiveIntList;
begin
  if FItemSequenceList = nil then
    FItemSequenceList := TFhirPositiveIntList.Create;
  result := FItemSequenceList;
end;

Function TFhirClaimResponseAddItem.GetHasItemSequenceList : boolean;
begin
  result := (FItemSequenceList <> nil) and (FItemSequenceList.count > 0);
end;

Function TFhirClaimResponseAddItem.GetDetailSequenceList : TFhirPositiveIntList;
begin
  if FDetailSequenceList = nil then
    FDetailSequenceList := TFhirPositiveIntList.Create;
  result := FDetailSequenceList;
end;

Function TFhirClaimResponseAddItem.GetHasDetailSequenceList : boolean;
begin
  result := (FDetailSequenceList <> nil) and (FDetailSequenceList.count > 0);
end;

Function TFhirClaimResponseAddItem.GetSubdetailSequenceList : TFhirPositiveIntList;
begin
  if FSubdetailSequenceList = nil then
    FSubdetailSequenceList := TFhirPositiveIntList.Create;
  result := FSubdetailSequenceList;
end;

Function TFhirClaimResponseAddItem.GetHasSubdetailSequenceList : boolean;
begin
  result := (FSubdetailSequenceList <> nil) and (FSubdetailSequenceList.count > 0);
end;

Function TFhirClaimResponseAddItem.GetProviderList : TFhirReferenceList{TFhirPractitioner};
begin
  if FProviderList = nil then
    FProviderList := TFhirReferenceList{TFhirPractitioner}.Create;
  result := FProviderList;
end;

Function TFhirClaimResponseAddItem.GetHasProviderList : boolean;
begin
  result := (FProviderList <> nil) and (FProviderList.count > 0);
end;

Procedure TFhirClaimResponseAddItem.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

Function TFhirClaimResponseAddItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirClaimResponseAddItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Function TFhirClaimResponseAddItem.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

Function TFhirClaimResponseAddItem.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

Procedure TFhirClaimResponseAddItem.SetServiced(value : TFhirType);
begin
  FServiced.free;
  FServiced := value;
end;

Procedure TFhirClaimResponseAddItem.SetLocation(value : TFhirType);
begin
  FLocation.free;
  FLocation := value;
end;

Procedure TFhirClaimResponseAddItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirClaimResponseAddItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirClaimResponseAddItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirClaimResponseAddItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirClaimResponseAddItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirClaimResponseAddItem.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

Procedure TFhirClaimResponseAddItem.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

Function TFhirClaimResponseAddItem.GetSubSiteList : TFhirCodeableConceptList;
begin
  if FSubSiteList = nil then
    FSubSiteList := TFhirCodeableConceptList.Create;
  result := FSubSiteList;
end;

Function TFhirClaimResponseAddItem.GetHasSubSiteList : boolean;
begin
  result := (FSubSiteList <> nil) and (FSubSiteList.count > 0);
end;

Function TFhirClaimResponseAddItem.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirClaimResponseAddItem.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirClaimResponseAddItem.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirClaimResponseAddItem.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

Function TFhirClaimResponseAddItem.GetDetailList : TFhirClaimResponseAddItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirClaimResponseAddItemDetailList.Create;
  result := FDetailList;
end;

Function TFhirClaimResponseAddItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirClaimResponseAddItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FitemSequenceList.sizeInBytes);
  inc(result, FdetailSequenceList.sizeInBytes);
  inc(result, FsubdetailSequenceList.sizeInBytes);
  inc(result, FproviderList.sizeInBytes);
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FServiced.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FsubSiteList.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemListEnumerator }

Constructor TFhirClaimResponseAddItemListEnumerator.Create(list : TFhirClaimResponseAddItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseAddItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseAddItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseAddItemListEnumerator.GetCurrent : TFhirClaimResponseAddItem;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseAddItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemList }
procedure TFhirClaimResponseAddItemList.AddItem(value: TFhirClaimResponseAddItem);
begin
  assert(value.ClassName = 'TFhirClaimResponseAddItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseAddItem');
  add(value);
end;

function TFhirClaimResponseAddItemList.Append: TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseAddItemList.GetEnumerator : TFhirClaimResponseAddItemListEnumerator;
begin
  result := TFhirClaimResponseAddItemListEnumerator.Create(self.link);
end;

function TFhirClaimResponseAddItemList.Clone: TFhirClaimResponseAddItemList;
begin
  result := TFhirClaimResponseAddItemList(inherited Clone);
end;

function TFhirClaimResponseAddItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseAddItemList.GetItemN(index: Integer): TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseAddItem;
end;
function TFhirClaimResponseAddItemList.IndexOf(value: TFhirClaimResponseAddItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseAddItemList.Insert(index: Integer): TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemList.InsertItem(index: Integer; value: TFhirClaimResponseAddItem);
begin
  assert(value is TFhirClaimResponseAddItem);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseAddItemList.Item(index: Integer): TFhirClaimResponseAddItem;
begin
  result := TFhirClaimResponseAddItem(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemList.Link: TFhirClaimResponseAddItemList;
begin
  result := TFhirClaimResponseAddItemList(inherited Link);
end;

procedure TFhirClaimResponseAddItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseAddItemList.SetItemByIndex(index: Integer; value: TFhirClaimResponseAddItem);
begin
  assert(value is TFhirClaimResponseAddItem);
  FhirClaimResponseAddItems[index] := value;
end;

procedure TFhirClaimResponseAddItemList.SetItemN(index: Integer; value: TFhirClaimResponseAddItem);
begin
  assert(value is TFhirClaimResponseAddItem);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseAddItemDetail }

constructor TFhirClaimResponseAddItemDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseAddItemDetail.Destroy;
begin
  FProductOrService.free;
  FModifierList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FSubDetailList.Free;
  inherited;
end;

procedure TFhirClaimResponseAddItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  productOrService := TFhirClaimResponseAddItemDetail(oSource).productOrService.Clone;
  if (TFhirClaimResponseAddItemDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimResponseAddItemDetail(oSource).FModifierList);
  end;
  quantity := TFhirClaimResponseAddItemDetail(oSource).quantity.Clone;
  unitPrice := TFhirClaimResponseAddItemDetail(oSource).unitPrice.Clone;
  factorElement := TFhirClaimResponseAddItemDetail(oSource).factorElement.Clone;
  net := TFhirClaimResponseAddItemDetail(oSource).net.Clone;
  if (TFhirClaimResponseAddItemDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseAddItemDetail(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseAddItemDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseAddItemDetail(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponseAddItemDetail(oSource).FSubDetailList = nil) then
  begin
    FSubDetailList.free;
    FSubDetailList := nil;
  end
  else
  begin
    if FSubDetailList = nil then
      FSubDetailList := TFhirClaimResponseAddItemDetailSubDetailList.Create;
    FSubDetailList.Assign(TFhirClaimResponseAddItemDetail(oSource).FSubDetailList);
  end;
end;

procedure TFhirClaimResponseAddItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'subDetail') Then
    list.addAll(self, 'subDetail', FSubDetailList);
end;

procedure TFhirClaimResponseAddItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '@ClaimResponse.item.adjudication', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subDetail', '', true, TFhirClaimResponseAddItemDetailSubDetail, FSubDetailList.Link)){3};
end;

function TFhirClaimResponseAddItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication){2a};
    result := propValue;
  end
  else if (propName = 'subDetail') then
  begin
    SubDetailList.add(propValue as TFhirClaimResponseAddItemDetailSubDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseAddItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication){2a}
  else if (propName = 'subDetail') then SubDetailList.insertItem(index, propValue as TFhirClaimResponseAddItemDetailSubDetail){2a}
  else inherited;
end;

function TFhirClaimResponseAddItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'productOrService') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else if (propName = 'subDetail') then result := SubDetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseAddItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := '@ClaimResponse.item.adjudication'
  else if (propName = 'subDetail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseAddItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else if (propName = 'subDetail') then deletePropertyValue('subDetail', SubDetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseAddItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else if (propName = 'subDetail') then replacePropertyValue('subDetail', SubDetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseAddItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else if (propName = 'subDetail') then SubDetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseAddItemDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirClaimResponseAddItemDetail.Link : TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail(inherited Link);
end;

function TFhirClaimResponseAddItemDetail.Clone : TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail(inherited Clone);
end;

function TFhirClaimResponseAddItemDetail.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseAddItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseAddItemDetail)) then
    result := false
  else
  begin
    o := TFhirClaimResponseAddItemDetail(other);
    result := compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(netElement, o.netElement, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true) and compareDeep(subDetailList, o.subDetailList, true);
  end;
end;

function TFhirClaimResponseAddItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FsubDetailList);
end;

procedure TFhirClaimResponseAddItemDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('subDetail');
end;

{ TFhirClaimResponseAddItemDetail }

Procedure TFhirClaimResponseAddItemDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

Function TFhirClaimResponseAddItemDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirClaimResponseAddItemDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Procedure TFhirClaimResponseAddItemDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirClaimResponseAddItemDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirClaimResponseAddItemDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirClaimResponseAddItemDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirClaimResponseAddItemDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirClaimResponseAddItemDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

Function TFhirClaimResponseAddItemDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirClaimResponseAddItemDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirClaimResponseAddItemDetail.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirClaimResponseAddItemDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

Function TFhirClaimResponseAddItemDetail.GetSubDetailList : TFhirClaimResponseAddItemDetailSubDetailList;
begin
  if FSubDetailList = nil then
    FSubDetailList := TFhirClaimResponseAddItemDetailSubDetailList.Create;
  result := FSubDetailList;
end;

Function TFhirClaimResponseAddItemDetail.GetHasSubDetailList : boolean;
begin
  result := (FSubDetailList <> nil) and (FSubDetailList.count > 0);
end;

function TFhirClaimResponseAddItemDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FsubDetailList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemDetailListEnumerator }

Constructor TFhirClaimResponseAddItemDetailListEnumerator.Create(list : TFhirClaimResponseAddItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseAddItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseAddItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseAddItemDetailListEnumerator.GetCurrent : TFhirClaimResponseAddItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseAddItemDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemDetailList }
procedure TFhirClaimResponseAddItemDetailList.AddItem(value: TFhirClaimResponseAddItemDetail);
begin
  assert(value.ClassName = 'TFhirClaimResponseAddItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseAddItemDetail');
  add(value);
end;

function TFhirClaimResponseAddItemDetailList.Append: TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseAddItemDetailList.GetEnumerator : TFhirClaimResponseAddItemDetailListEnumerator;
begin
  result := TFhirClaimResponseAddItemDetailListEnumerator.Create(self.link);
end;

function TFhirClaimResponseAddItemDetailList.Clone: TFhirClaimResponseAddItemDetailList;
begin
  result := TFhirClaimResponseAddItemDetailList(inherited Clone);
end;

function TFhirClaimResponseAddItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseAddItemDetailList.GetItemN(index: Integer): TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseAddItemDetail;
end;
function TFhirClaimResponseAddItemDetailList.IndexOf(value: TFhirClaimResponseAddItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseAddItemDetailList.Insert(index: Integer): TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemDetailList.InsertItem(index: Integer; value: TFhirClaimResponseAddItemDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseAddItemDetailList.Item(index: Integer): TFhirClaimResponseAddItemDetail;
begin
  result := TFhirClaimResponseAddItemDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemDetailList.Link: TFhirClaimResponseAddItemDetailList;
begin
  result := TFhirClaimResponseAddItemDetailList(inherited Link);
end;

procedure TFhirClaimResponseAddItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseAddItemDetailList.SetItemByIndex(index: Integer; value: TFhirClaimResponseAddItemDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetail);
  FhirClaimResponseAddItemDetails[index] := value;
end;

procedure TFhirClaimResponseAddItemDetailList.SetItemN(index: Integer; value: TFhirClaimResponseAddItemDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseAddItemDetailSubDetail }

constructor TFhirClaimResponseAddItemDetailSubDetail.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseAddItemDetailSubDetail.Destroy;
begin
  FProductOrService.free;
  FModifierList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  inherited;
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.Assign(oSource : TFslObject);
begin
  inherited;
  productOrService := TFhirClaimResponseAddItemDetailSubDetail(oSource).productOrService.Clone;
  if (TFhirClaimResponseAddItemDetailSubDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirClaimResponseAddItemDetailSubDetail(oSource).FModifierList);
  end;
  quantity := TFhirClaimResponseAddItemDetailSubDetail(oSource).quantity.Clone;
  unitPrice := TFhirClaimResponseAddItemDetailSubDetail(oSource).unitPrice.Clone;
  factorElement := TFhirClaimResponseAddItemDetailSubDetail(oSource).factorElement.Clone;
  net := TFhirClaimResponseAddItemDetailSubDetail(oSource).net.Clone;
  if (TFhirClaimResponseAddItemDetailSubDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirClaimResponseAddItemDetailSubDetail(oSource).FNoteNumberList);
  end;
  if (TFhirClaimResponseAddItemDetailSubDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponseAddItemDetailSubDetail(oSource).FAdjudicationList);
  end;
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '@ClaimResponse.item.adjudication', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link)){3};
end;

function TFhirClaimResponseAddItemDetailSubDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication){2a}
  else inherited;
end;

function TFhirClaimResponseAddItemDetailSubDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'productOrService') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseAddItemDetailSubDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := '@ClaimResponse.item.adjudication'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseAddItemDetailSubDetail.fhirType : string;
begin
  result := 'subDetail';
end;

function TFhirClaimResponseAddItemDetailSubDetail.Link : TFhirClaimResponseAddItemDetailSubDetail;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail(inherited Link);
end;

function TFhirClaimResponseAddItemDetailSubDetail.Clone : TFhirClaimResponseAddItemDetailSubDetail;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail(inherited Clone);
end;

function TFhirClaimResponseAddItemDetailSubDetail.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseAddItemDetailSubDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseAddItemDetailSubDetail)) then
    result := false
  else
  begin
    o := TFhirClaimResponseAddItemDetailSubDetail(other);
    result := compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(netElement, o.netElement, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true);
  end;
end;

function TFhirClaimResponseAddItemDetailSubDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList);
end;

procedure TFhirClaimResponseAddItemDetailSubDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('noteNumber');
  fields.add('adjudication');
end;

{ TFhirClaimResponseAddItemDetailSubDetail }

Procedure TFhirClaimResponseAddItemDetailSubDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

Function TFhirClaimResponseAddItemDetailSubDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirClaimResponseAddItemDetailSubDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Procedure TFhirClaimResponseAddItemDetailSubDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirClaimResponseAddItemDetailSubDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirClaimResponseAddItemDetailSubDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirClaimResponseAddItemDetailSubDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirClaimResponseAddItemDetailSubDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirClaimResponseAddItemDetailSubDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

Function TFhirClaimResponseAddItemDetailSubDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirClaimResponseAddItemDetailSubDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirClaimResponseAddItemDetailSubDetail.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirClaimResponseAddItemDetailSubDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirClaimResponseAddItemDetailSubDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemDetailSubDetailListEnumerator }

Constructor TFhirClaimResponseAddItemDetailSubDetailListEnumerator.Create(list : TFhirClaimResponseAddItemDetailSubDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseAddItemDetailSubDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseAddItemDetailSubDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseAddItemDetailSubDetailListEnumerator.GetCurrent : TFhirClaimResponseAddItemDetailSubDetail;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseAddItemDetailSubDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseAddItemDetailSubDetailList }
procedure TFhirClaimResponseAddItemDetailSubDetailList.AddItem(value: TFhirClaimResponseAddItemDetailSubDetail);
begin
  assert(value.ClassName = 'TFhirClaimResponseAddItemDetailSubDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseAddItemDetailSubDetail');
  add(value);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.Append: TFhirClaimResponseAddItemDetailSubDetail;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemDetailSubDetailList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseAddItemDetailSubDetailList.GetEnumerator : TFhirClaimResponseAddItemDetailSubDetailListEnumerator;
begin
  result := TFhirClaimResponseAddItemDetailSubDetailListEnumerator.Create(self.link);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.Clone: TFhirClaimResponseAddItemDetailSubDetailList;
begin
  result := TFhirClaimResponseAddItemDetailSubDetailList(inherited Clone);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseAddItemDetailSubDetailList.GetItemN(index: Integer): TFhirClaimResponseAddItemDetailSubDetail;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail;
end;
function TFhirClaimResponseAddItemDetailSubDetailList.IndexOf(value: TFhirClaimResponseAddItemDetailSubDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.Insert(index: Integer): TFhirClaimResponseAddItemDetailSubDetail;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseAddItemDetailSubDetailList.InsertItem(index: Integer; value: TFhirClaimResponseAddItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetailSubDetail);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.Item(index: Integer): TFhirClaimResponseAddItemDetailSubDetail;
begin
  result := TFhirClaimResponseAddItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirClaimResponseAddItemDetailSubDetailList.Link: TFhirClaimResponseAddItemDetailSubDetailList;
begin
  result := TFhirClaimResponseAddItemDetailSubDetailList(inherited Link);
end;

procedure TFhirClaimResponseAddItemDetailSubDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseAddItemDetailSubDetailList.SetItemByIndex(index: Integer; value: TFhirClaimResponseAddItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetailSubDetail);
  FhirClaimResponseAddItemDetailSubDetails[index] := value;
end;

procedure TFhirClaimResponseAddItemDetailSubDetailList.SetItemN(index: Integer; value: TFhirClaimResponseAddItemDetailSubDetail);
begin
  assert(value is TFhirClaimResponseAddItemDetailSubDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseTotal }

constructor TFhirClaimResponseTotal.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseTotal.Destroy;
begin
  FCategory.free;
  FAmount.free;
  inherited;
end;

procedure TFhirClaimResponseTotal.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirClaimResponseTotal(oSource).category.Clone;
  amount := TFhirClaimResponseTotal(oSource).amount.Clone;
end;

procedure TFhirClaimResponseTotal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirClaimResponseTotal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));{2}
end;

function TFhirClaimResponseTotal.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseTotal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseTotal.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'amount') then result := TFhirMoney.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseTotal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseTotal.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseTotal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseTotal.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseTotal.fhirType : string;
begin
  result := 'total';
end;

function TFhirClaimResponseTotal.Link : TFhirClaimResponseTotal;
begin
  result := TFhirClaimResponseTotal(inherited Link);
end;

function TFhirClaimResponseTotal.Clone : TFhirClaimResponseTotal;
begin
  result := TFhirClaimResponseTotal(inherited Clone);
end;

function TFhirClaimResponseTotal.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseTotal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseTotal)) then
    result := false
  else
  begin
    o := TFhirClaimResponseTotal(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirClaimResponseTotal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FAmount);
end;

procedure TFhirClaimResponseTotal.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('amount');
end;

{ TFhirClaimResponseTotal }

Procedure TFhirClaimResponseTotal.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirClaimResponseTotal.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirClaimResponseTotal.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirClaimResponseTotalListEnumerator }

Constructor TFhirClaimResponseTotalListEnumerator.Create(list : TFhirClaimResponseTotalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseTotalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseTotalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseTotalListEnumerator.GetCurrent : TFhirClaimResponseTotal;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseTotalListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseTotalList }
procedure TFhirClaimResponseTotalList.AddItem(value: TFhirClaimResponseTotal);
begin
  assert(value.ClassName = 'TFhirClaimResponseTotal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseTotal');
  add(value);
end;

function TFhirClaimResponseTotalList.Append: TFhirClaimResponseTotal;
begin
  result := TFhirClaimResponseTotal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseTotalList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseTotalList.GetEnumerator : TFhirClaimResponseTotalListEnumerator;
begin
  result := TFhirClaimResponseTotalListEnumerator.Create(self.link);
end;

function TFhirClaimResponseTotalList.Clone: TFhirClaimResponseTotalList;
begin
  result := TFhirClaimResponseTotalList(inherited Clone);
end;

function TFhirClaimResponseTotalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseTotalList.GetItemN(index: Integer): TFhirClaimResponseTotal;
begin
  result := TFhirClaimResponseTotal(ObjectByIndex[index]);
end;

function TFhirClaimResponseTotalList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseTotal;
end;
function TFhirClaimResponseTotalList.IndexOf(value: TFhirClaimResponseTotal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseTotalList.Insert(index: Integer): TFhirClaimResponseTotal;
begin
  result := TFhirClaimResponseTotal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseTotalList.InsertItem(index: Integer; value: TFhirClaimResponseTotal);
begin
  assert(value is TFhirClaimResponseTotal);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseTotalList.Item(index: Integer): TFhirClaimResponseTotal;
begin
  result := TFhirClaimResponseTotal(ObjectByIndex[index]);
end;

function TFhirClaimResponseTotalList.Link: TFhirClaimResponseTotalList;
begin
  result := TFhirClaimResponseTotalList(inherited Link);
end;

procedure TFhirClaimResponseTotalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseTotalList.SetItemByIndex(index: Integer; value: TFhirClaimResponseTotal);
begin
  assert(value is TFhirClaimResponseTotal);
  FhirClaimResponseTotals[index] := value;
end;

procedure TFhirClaimResponseTotalList.SetItemN(index: Integer; value: TFhirClaimResponseTotal);
begin
  assert(value is TFhirClaimResponseTotal);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponsePayment }

constructor TFhirClaimResponsePayment.Create;
begin
  inherited;
end;

destructor TFhirClaimResponsePayment.Destroy;
begin
  FType_.free;
  FAdjustment.free;
  FAdjustmentReason.free;
  FDate.free;
  FAmount.free;
  FIdentifier.free;
  inherited;
end;

procedure TFhirClaimResponsePayment.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirClaimResponsePayment(oSource).type_.Clone;
  adjustment := TFhirClaimResponsePayment(oSource).adjustment.Clone;
  adjustmentReason := TFhirClaimResponsePayment(oSource).adjustmentReason.Clone;
  dateElement := TFhirClaimResponsePayment(oSource).dateElement.Clone;
  amount := TFhirClaimResponsePayment(oSource).amount.Clone;
  identifier := TFhirClaimResponsePayment(oSource).identifier.Clone;
end;

procedure TFhirClaimResponsePayment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'adjustment') Then
     list.add(self.link, 'adjustment', FAdjustment.Link);
  if (child_name = 'adjustmentReason') Then
     list.add(self.link, 'adjustmentReason', FAdjustmentReason.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
end;

procedure TFhirClaimResponsePayment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'adjustment', 'Money', false, TFhirMoney, FAdjustment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'adjustmentReason', 'CodeableConcept', false, TFhirCodeableConcept, FAdjustmentReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
end;

function TFhirClaimResponsePayment.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'adjustment') then
  begin
    Adjustment := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'adjustmentReason') then
  begin
    AdjustmentReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponsePayment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponsePayment.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'adjustment') then result := TFhirMoney.create(){4b}
  else if (propName = 'adjustmentReason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'date') then result := TFhirDate.create() {5b}
  else if (propName = 'amount') then result := TFhirMoney.create(){4b}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponsePayment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'adjustment') then result := 'Money'
  else if (propName = 'adjustmentReason') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'date'
  else if (propName = 'amount') then result := 'Money'
  else if (propName = 'identifier') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponsePayment.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'adjustment') then AdjustmentElement := nil
  else if (propName = 'adjustmentReason') then AdjustmentReasonElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponsePayment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'adjustment') then AdjustmentElement := new as TFhirMoney{4}
  else if (propName = 'adjustmentReason') then AdjustmentReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'date') then DateElement := asDate(new){5b}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney{4}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponsePayment.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponsePayment.fhirType : string;
begin
  result := 'payment';
end;

function TFhirClaimResponsePayment.Link : TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment(inherited Link);
end;

function TFhirClaimResponsePayment.Clone : TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment(inherited Clone);
end;

function TFhirClaimResponsePayment.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponsePayment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponsePayment)) then
    result := false
  else
  begin
    o := TFhirClaimResponsePayment(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(adjustmentElement, o.adjustmentElement, true) and 
      compareDeep(adjustmentReasonElement, o.adjustmentReasonElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(identifierElement, o.identifierElement, true);
  end;
end;

function TFhirClaimResponsePayment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAdjustment) and isEmptyProp(FAdjustmentReason) and isEmptyProp(FDate) and isEmptyProp(FAmount) and isEmptyProp(FIdentifier);
end;

procedure TFhirClaimResponsePayment.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('adjustment');
  fields.add('adjustmentReason');
  fields.add('date');
  fields.add('amount');
  fields.add('identifier');
end;

{ TFhirClaimResponsePayment }

Procedure TFhirClaimResponsePayment.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirClaimResponsePayment.SetAdjustment(value : TFhirMoney);
begin
  FAdjustment.free;
  FAdjustment := value;
end;

Procedure TFhirClaimResponsePayment.SetAdjustmentReason(value : TFhirCodeableConcept);
begin
  FAdjustmentReason.free;
  FAdjustmentReason := value;
end;

Procedure TFhirClaimResponsePayment.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirClaimResponsePayment.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirClaimResponsePayment.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

Procedure TFhirClaimResponsePayment.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

Procedure TFhirClaimResponsePayment.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

function TFhirClaimResponsePayment.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FAdjustment.sizeInBytes);
  inc(result, FAdjustmentReason.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
end;

{ TFhirClaimResponsePaymentListEnumerator }

Constructor TFhirClaimResponsePaymentListEnumerator.Create(list : TFhirClaimResponsePaymentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponsePaymentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponsePaymentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponsePaymentListEnumerator.GetCurrent : TFhirClaimResponsePayment;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponsePaymentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponsePaymentList }
procedure TFhirClaimResponsePaymentList.AddItem(value: TFhirClaimResponsePayment);
begin
  assert(value.ClassName = 'TFhirClaimResponsePayment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponsePayment');
  add(value);
end;

function TFhirClaimResponsePaymentList.Append: TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponsePaymentList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponsePaymentList.GetEnumerator : TFhirClaimResponsePaymentListEnumerator;
begin
  result := TFhirClaimResponsePaymentListEnumerator.Create(self.link);
end;

function TFhirClaimResponsePaymentList.Clone: TFhirClaimResponsePaymentList;
begin
  result := TFhirClaimResponsePaymentList(inherited Clone);
end;

function TFhirClaimResponsePaymentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponsePaymentList.GetItemN(index: Integer): TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment(ObjectByIndex[index]);
end;

function TFhirClaimResponsePaymentList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponsePayment;
end;
function TFhirClaimResponsePaymentList.IndexOf(value: TFhirClaimResponsePayment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponsePaymentList.Insert(index: Integer): TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponsePaymentList.InsertItem(index: Integer; value: TFhirClaimResponsePayment);
begin
  assert(value is TFhirClaimResponsePayment);
  Inherited Insert(index, value);
end;

function TFhirClaimResponsePaymentList.Item(index: Integer): TFhirClaimResponsePayment;
begin
  result := TFhirClaimResponsePayment(ObjectByIndex[index]);
end;

function TFhirClaimResponsePaymentList.Link: TFhirClaimResponsePaymentList;
begin
  result := TFhirClaimResponsePaymentList(inherited Link);
end;

procedure TFhirClaimResponsePaymentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponsePaymentList.SetItemByIndex(index: Integer; value: TFhirClaimResponsePayment);
begin
  assert(value is TFhirClaimResponsePayment);
  FhirClaimResponsePayments[index] := value;
end;

procedure TFhirClaimResponsePaymentList.SetItemN(index: Integer; value: TFhirClaimResponsePayment);
begin
  assert(value is TFhirClaimResponsePayment);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseProcessNote }

constructor TFhirClaimResponseProcessNote.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseProcessNote.Destroy;
begin
  FNumber.free;
  FType_.free;
  FText.free;
  FLanguage.free;
  inherited;
end;

procedure TFhirClaimResponseProcessNote.Assign(oSource : TFslObject);
begin
  inherited;
  numberElement := TFhirClaimResponseProcessNote(oSource).numberElement.Clone;
  FType_ := TFhirClaimResponseProcessNote(oSource).FType_.Link;
  textElement := TFhirClaimResponseProcessNote(oSource).textElement.Clone;
  language := TFhirClaimResponseProcessNote(oSource).language.Clone;
end;

procedure TFhirClaimResponseProcessNote.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'number') Then
     list.add(self.link, 'number', FNumber.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
end;

procedure TFhirClaimResponseProcessNote.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'positiveInt', false, TFhirPositiveInt, FNumber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link));{2}
end;

function TFhirClaimResponseProcessNote.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'number') then
  begin
    NumberElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirNoteTypeEnum, CODES_TFhirNoteTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseProcessNote.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseProcessNote.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'number') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'language') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseProcessNote.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'number') then result := 'positiveInt'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'language') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseProcessNote.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseProcessNote.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := asPositiveInt(new){5b}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirNoteTypeEnum, CODES_TFhirNoteTypeEnum, new){4}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseProcessNote.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseProcessNote.fhirType : string;
begin
  result := 'processNote';
end;

function TFhirClaimResponseProcessNote.Link : TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote(inherited Link);
end;

function TFhirClaimResponseProcessNote.Clone : TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote(inherited Clone);
end;

function TFhirClaimResponseProcessNote.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseProcessNote;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseProcessNote)) then
    result := false
  else
  begin
    o := TFhirClaimResponseProcessNote(other);
    result := compareDeep(numberElement, o.numberElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(languageElement, o.languageElement, true);
  end;
end;

function TFhirClaimResponseProcessNote.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FNumber) and isEmptyProp(FType_) and isEmptyProp(FText) and isEmptyProp(FLanguage);
end;

procedure TFhirClaimResponseProcessNote.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('number');
  fields.add('type');
  fields.add('text');
  fields.add('language');
end;

{ TFhirClaimResponseProcessNote }

Procedure TFhirClaimResponseProcessNote.SetNumber(value : TFhirPositiveInt);
begin
  FNumber.free;
  FNumber := value;
end;

Function TFhirClaimResponseProcessNote.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := FNumber.value;
end;

Procedure TFhirClaimResponseProcessNote.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirPositiveInt.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

Procedure TFhirClaimResponseProcessNote.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirClaimResponseProcessNote.GetType_ST : TFhirNoteTypeEnum;
begin
  if FType_ = nil then
    result := TFhirNoteTypeEnum(0)
  else
    result := TFhirNoteTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirNoteTypeEnum, FType_.value));
end;

Procedure TFhirClaimResponseProcessNote.SetType_ST(value : TFhirNoteTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirNoteTypeEnum[value], CODES_TFhirNoteTypeEnum[value]);
end;

Procedure TFhirClaimResponseProcessNote.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirClaimResponseProcessNote.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirClaimResponseProcessNote.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirClaimResponseProcessNote.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value;
end;

function TFhirClaimResponseProcessNote.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FNumber.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FLanguage.sizeInBytes);
end;

{ TFhirClaimResponseProcessNoteListEnumerator }

Constructor TFhirClaimResponseProcessNoteListEnumerator.Create(list : TFhirClaimResponseProcessNoteList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseProcessNoteListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseProcessNoteListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseProcessNoteListEnumerator.GetCurrent : TFhirClaimResponseProcessNote;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseProcessNoteListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseProcessNoteList }
procedure TFhirClaimResponseProcessNoteList.AddItem(value: TFhirClaimResponseProcessNote);
begin
  assert(value.ClassName = 'TFhirClaimResponseProcessNote', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseProcessNote');
  add(value);
end;

function TFhirClaimResponseProcessNoteList.Append: TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseProcessNoteList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseProcessNoteList.GetEnumerator : TFhirClaimResponseProcessNoteListEnumerator;
begin
  result := TFhirClaimResponseProcessNoteListEnumerator.Create(self.link);
end;

function TFhirClaimResponseProcessNoteList.Clone: TFhirClaimResponseProcessNoteList;
begin
  result := TFhirClaimResponseProcessNoteList(inherited Clone);
end;

function TFhirClaimResponseProcessNoteList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseProcessNoteList.GetItemN(index: Integer): TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote(ObjectByIndex[index]);
end;

function TFhirClaimResponseProcessNoteList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseProcessNote;
end;
function TFhirClaimResponseProcessNoteList.IndexOf(value: TFhirClaimResponseProcessNote): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseProcessNoteList.Insert(index: Integer): TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseProcessNoteList.InsertItem(index: Integer; value: TFhirClaimResponseProcessNote);
begin
  assert(value is TFhirClaimResponseProcessNote);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseProcessNoteList.Item(index: Integer): TFhirClaimResponseProcessNote;
begin
  result := TFhirClaimResponseProcessNote(ObjectByIndex[index]);
end;

function TFhirClaimResponseProcessNoteList.Link: TFhirClaimResponseProcessNoteList;
begin
  result := TFhirClaimResponseProcessNoteList(inherited Link);
end;

procedure TFhirClaimResponseProcessNoteList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseProcessNoteList.SetItemByIndex(index: Integer; value: TFhirClaimResponseProcessNote);
begin
  assert(value is TFhirClaimResponseProcessNote);
  FhirClaimResponseProcessNotes[index] := value;
end;

procedure TFhirClaimResponseProcessNoteList.SetItemN(index: Integer; value: TFhirClaimResponseProcessNote);
begin
  assert(value is TFhirClaimResponseProcessNote);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseInsurance }

constructor TFhirClaimResponseInsurance.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseInsurance.Destroy;
begin
  FSequence.free;
  FFocal.free;
  FCoverage.free;
  FBusinessArrangement.free;
  FClaimResponse.free;
  inherited;
end;

procedure TFhirClaimResponseInsurance.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirClaimResponseInsurance(oSource).sequenceElement.Clone;
  focalElement := TFhirClaimResponseInsurance(oSource).focalElement.Clone;
  coverage := TFhirClaimResponseInsurance(oSource).coverage.Clone;
  businessArrangementElement := TFhirClaimResponseInsurance(oSource).businessArrangementElement.Clone;
  claimResponse := TFhirClaimResponseInsurance(oSource).claimResponse.Clone;
end;

procedure TFhirClaimResponseInsurance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'focal') Then
     list.add(self.link, 'focal', FFocal.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'businessArrangement') Then
     list.add(self.link, 'businessArrangement', FBusinessArrangement.Link);
  if (child_name = 'claimResponse') Then
     list.add(self.link, 'claimResponse', FClaimResponse.Link);
end;

procedure TFhirClaimResponseInsurance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'focal', 'boolean', false, TFhirBoolean, FFocal.Link));{2}
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference(Coverage)', false, TFhirReference{TFhirCoverage}, FCoverage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'businessArrangement', 'string', false, TFhirString, FBusinessArrangement.Link));{2}
  oList.add(TFHIRProperty.create(self, 'claimResponse', 'Reference(ClaimResponse)', false, TFhirReference{TFhirClaimResponse}, FClaimResponse.Link));{2}
end;

function TFhirClaimResponseInsurance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'focal') then
  begin
    FocalElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference{TFhirCoverage}{4b};
    result := propValue;
  end
  else if (propName = 'businessArrangement') then
  begin
    BusinessArrangementElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'claimResponse') then
  begin
    ClaimResponse := propValue as TFhirReference{TFhirClaimResponse}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseInsurance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseInsurance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'focal') then result := TFhirBoolean.create() {5b}
  else if (propName = 'coverage') then result := TFhirReference{TFhirCoverage}.create(){4b}
  else if (propName = 'businessArrangement') then result := TFhirString.create() {5b}
  else if (propName = 'claimResponse') then result := TFhirReference{TFhirClaimResponse}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseInsurance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'focal') then result := 'boolean'
  else if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'businessArrangement') then result := 'string'
  else if (propName = 'claimResponse') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseInsurance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'focal') then FocalElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'businessArrangement') then BusinessArrangementElement := nil
  else if (propName = 'claimResponse') then ClaimResponseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseInsurance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'focal') then FocalElement := asBoolean(new){5b}
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference{TFhirCoverage}{4}
  else if (propName = 'businessArrangement') then BusinessArrangementElement := asString(new){5b}
  else if (propName = 'claimResponse') then ClaimResponseElement := new as TFhirReference{TFhirClaimResponse}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseInsurance.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseInsurance.fhirType : string;
begin
  result := 'insurance';
end;

function TFhirClaimResponseInsurance.Link : TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance(inherited Link);
end;

function TFhirClaimResponseInsurance.Clone : TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance(inherited Clone);
end;

function TFhirClaimResponseInsurance.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseInsurance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseInsurance)) then
    result := false
  else
  begin
    o := TFhirClaimResponseInsurance(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(focalElement, o.focalElement, true) and 
      compareDeep(coverageElement, o.coverageElement, true) and compareDeep(businessArrangementElement, o.businessArrangementElement, true) and 
      compareDeep(claimResponseElement, o.claimResponseElement, true);
  end;
end;

function TFhirClaimResponseInsurance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FFocal) and isEmptyProp(FCoverage) and isEmptyProp(FBusinessArrangement) and isEmptyProp(FClaimResponse);
end;

procedure TFhirClaimResponseInsurance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('focal');
  fields.add('coverage');
  fields.add('businessArrangement');
  fields.add('claimResponse');
end;

{ TFhirClaimResponseInsurance }

Procedure TFhirClaimResponseInsurance.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirClaimResponseInsurance.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirClaimResponseInsurance.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirClaimResponseInsurance.SetFocal(value : TFhirBoolean);
begin
  FFocal.free;
  FFocal := value;
end;

Function TFhirClaimResponseInsurance.GetFocalST : Boolean;
begin
  if FFocal = nil then
    result := false
  else
    result := FFocal.value;
end;

Procedure TFhirClaimResponseInsurance.SetFocalST(value : Boolean);
begin
  if FFocal = nil then
    FFocal := TFhirBoolean.create;
  FFocal.value := value
end;

Procedure TFhirClaimResponseInsurance.SetCoverage(value : TFhirReference{TFhirCoverage});
begin
  FCoverage.free;
  FCoverage := value;
end;

Procedure TFhirClaimResponseInsurance.SetBusinessArrangement(value : TFhirString);
begin
  FBusinessArrangement.free;
  FBusinessArrangement := value;
end;

Function TFhirClaimResponseInsurance.GetBusinessArrangementST : String;
begin
  if FBusinessArrangement = nil then
    result := ''
  else
    result := FBusinessArrangement.value;
end;

Procedure TFhirClaimResponseInsurance.SetBusinessArrangementST(value : String);
begin
  if value <> '' then
  begin
    if FBusinessArrangement = nil then
      FBusinessArrangement := TFhirString.create;
    FBusinessArrangement.value := value
  end
  else if FBusinessArrangement <> nil then
    FBusinessArrangement.value := '';
end;

Procedure TFhirClaimResponseInsurance.SetClaimResponse(value : TFhirReference{TFhirClaimResponse});
begin
  FClaimResponse.free;
  FClaimResponse := value;
end;

function TFhirClaimResponseInsurance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FFocal.sizeInBytes);
  inc(result, FCoverage.sizeInBytes);
  inc(result, FBusinessArrangement.sizeInBytes);
  inc(result, FClaimResponse.sizeInBytes);
end;

{ TFhirClaimResponseInsuranceListEnumerator }

Constructor TFhirClaimResponseInsuranceListEnumerator.Create(list : TFhirClaimResponseInsuranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseInsuranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseInsuranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseInsuranceListEnumerator.GetCurrent : TFhirClaimResponseInsurance;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseInsuranceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseInsuranceList }
procedure TFhirClaimResponseInsuranceList.AddItem(value: TFhirClaimResponseInsurance);
begin
  assert(value.ClassName = 'TFhirClaimResponseInsurance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseInsurance');
  add(value);
end;

function TFhirClaimResponseInsuranceList.Append: TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseInsuranceList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseInsuranceList.GetEnumerator : TFhirClaimResponseInsuranceListEnumerator;
begin
  result := TFhirClaimResponseInsuranceListEnumerator.Create(self.link);
end;

function TFhirClaimResponseInsuranceList.Clone: TFhirClaimResponseInsuranceList;
begin
  result := TFhirClaimResponseInsuranceList(inherited Clone);
end;

function TFhirClaimResponseInsuranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseInsuranceList.GetItemN(index: Integer): TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance(ObjectByIndex[index]);
end;

function TFhirClaimResponseInsuranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseInsurance;
end;
function TFhirClaimResponseInsuranceList.IndexOf(value: TFhirClaimResponseInsurance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseInsuranceList.Insert(index: Integer): TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseInsuranceList.InsertItem(index: Integer; value: TFhirClaimResponseInsurance);
begin
  assert(value is TFhirClaimResponseInsurance);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseInsuranceList.Item(index: Integer): TFhirClaimResponseInsurance;
begin
  result := TFhirClaimResponseInsurance(ObjectByIndex[index]);
end;

function TFhirClaimResponseInsuranceList.Link: TFhirClaimResponseInsuranceList;
begin
  result := TFhirClaimResponseInsuranceList(inherited Link);
end;

procedure TFhirClaimResponseInsuranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseInsuranceList.SetItemByIndex(index: Integer; value: TFhirClaimResponseInsurance);
begin
  assert(value is TFhirClaimResponseInsurance);
  FhirClaimResponseInsurances[index] := value;
end;

procedure TFhirClaimResponseInsuranceList.SetItemN(index: Integer; value: TFhirClaimResponseInsurance);
begin
  assert(value is TFhirClaimResponseInsurance);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponseError }

constructor TFhirClaimResponseError.Create;
begin
  inherited;
end;

destructor TFhirClaimResponseError.Destroy;
begin
  FItemSequence.free;
  FDetailSequence.free;
  FSubDetailSequence.free;
  FCode.free;
  inherited;
end;

procedure TFhirClaimResponseError.Assign(oSource : TFslObject);
begin
  inherited;
  itemSequenceElement := TFhirClaimResponseError(oSource).itemSequenceElement.Clone;
  detailSequenceElement := TFhirClaimResponseError(oSource).detailSequenceElement.Clone;
  subDetailSequenceElement := TFhirClaimResponseError(oSource).subDetailSequenceElement.Clone;
  code := TFhirClaimResponseError(oSource).code.Clone;
end;

procedure TFhirClaimResponseError.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'itemSequence') Then
     list.add(self.link, 'itemSequence', FItemSequence.Link);
  if (child_name = 'detailSequence') Then
     list.add(self.link, 'detailSequence', FDetailSequence.Link);
  if (child_name = 'subDetailSequence') Then
     list.add(self.link, 'subDetailSequence', FSubDetailSequence.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
end;

procedure TFhirClaimResponseError.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'itemSequence', 'positiveInt', false, TFhirPositiveInt, FItemSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detailSequence', 'positiveInt', false, TFhirPositiveInt, FDetailSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subDetailSequence', 'positiveInt', false, TFhirPositiveInt, FSubDetailSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
end;

function TFhirClaimResponseError.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'itemSequence') then
  begin
    ItemSequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'detailSequence') then
  begin
    DetailSequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subDetailSequence') then
  begin
    SubDetailSequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClaimResponseError.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClaimResponseError.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'itemSequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'detailSequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'subDetailSequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponseError.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'itemSequence') then result := 'positiveInt'
  else if (propName = 'detailSequence') then result := 'positiveInt'
  else if (propName = 'subDetailSequence') then result := 'positiveInt'
  else if (propName = 'code') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponseError.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'itemSequence') then ItemSequenceElement := nil
  else if (propName = 'detailSequence') then DetailSequenceElement := nil
  else if (propName = 'subDetailSequence') then SubDetailSequenceElement := nil
  else if (propName = 'code') then CodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponseError.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'itemSequence') then ItemSequenceElement := asPositiveInt(new){5b}
  else if (propName = 'detailSequence') then DetailSequenceElement := asPositiveInt(new){5b}
  else if (propName = 'subDetailSequence') then SubDetailSequenceElement := asPositiveInt(new){5b}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponseError.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponseError.fhirType : string;
begin
  result := 'error';
end;

function TFhirClaimResponseError.Link : TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError(inherited Link);
end;

function TFhirClaimResponseError.Clone : TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError(inherited Clone);
end;

function TFhirClaimResponseError.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponseError;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponseError)) then
    result := false
  else
  begin
    o := TFhirClaimResponseError(other);
    result := compareDeep(itemSequenceElement, o.itemSequenceElement, true) and 
      compareDeep(detailSequenceElement, o.detailSequenceElement, true) and compareDeep(subDetailSequenceElement, o.subDetailSequenceElement, true) and 
      compareDeep(codeElement, o.codeElement, true);
  end;
end;

function TFhirClaimResponseError.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItemSequence) and isEmptyProp(FDetailSequence) and isEmptyProp(FSubDetailSequence) and isEmptyProp(FCode);
end;

procedure TFhirClaimResponseError.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('itemSequence');
  fields.add('detailSequence');
  fields.add('subDetailSequence');
  fields.add('code');
end;

{ TFhirClaimResponseError }

Procedure TFhirClaimResponseError.SetItemSequence(value : TFhirPositiveInt);
begin
  FItemSequence.free;
  FItemSequence := value;
end;

Function TFhirClaimResponseError.GetItemSequenceST : String;
begin
  if FItemSequence = nil then
    result := ''
  else
    result := FItemSequence.value;
end;

Procedure TFhirClaimResponseError.SetItemSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FItemSequence = nil then
      FItemSequence := TFhirPositiveInt.create;
    FItemSequence.value := value
  end
  else if FItemSequence <> nil then
    FItemSequence.value := '';
end;

Procedure TFhirClaimResponseError.SetDetailSequence(value : TFhirPositiveInt);
begin
  FDetailSequence.free;
  FDetailSequence := value;
end;

Function TFhirClaimResponseError.GetDetailSequenceST : String;
begin
  if FDetailSequence = nil then
    result := ''
  else
    result := FDetailSequence.value;
end;

Procedure TFhirClaimResponseError.SetDetailSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FDetailSequence = nil then
      FDetailSequence := TFhirPositiveInt.create;
    FDetailSequence.value := value
  end
  else if FDetailSequence <> nil then
    FDetailSequence.value := '';
end;

Procedure TFhirClaimResponseError.SetSubDetailSequence(value : TFhirPositiveInt);
begin
  FSubDetailSequence.free;
  FSubDetailSequence := value;
end;

Function TFhirClaimResponseError.GetSubDetailSequenceST : String;
begin
  if FSubDetailSequence = nil then
    result := ''
  else
    result := FSubDetailSequence.value;
end;

Procedure TFhirClaimResponseError.SetSubDetailSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSubDetailSequence = nil then
      FSubDetailSequence := TFhirPositiveInt.create;
    FSubDetailSequence.value := value
  end
  else if FSubDetailSequence <> nil then
    FSubDetailSequence.value := '';
end;

Procedure TFhirClaimResponseError.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirClaimResponseError.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItemSequence.sizeInBytes);
  inc(result, FDetailSequence.sizeInBytes);
  inc(result, FSubDetailSequence.sizeInBytes);
  inc(result, FCode.sizeInBytes);
end;

{ TFhirClaimResponseErrorListEnumerator }

Constructor TFhirClaimResponseErrorListEnumerator.Create(list : TFhirClaimResponseErrorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseErrorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseErrorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseErrorListEnumerator.GetCurrent : TFhirClaimResponseError;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseErrorListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseErrorList }
procedure TFhirClaimResponseErrorList.AddItem(value: TFhirClaimResponseError);
begin
  assert(value.ClassName = 'TFhirClaimResponseError', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponseError');
  add(value);
end;

function TFhirClaimResponseErrorList.Append: TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseErrorList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseErrorList.GetEnumerator : TFhirClaimResponseErrorListEnumerator;
begin
  result := TFhirClaimResponseErrorListEnumerator.Create(self.link);
end;

function TFhirClaimResponseErrorList.Clone: TFhirClaimResponseErrorList;
begin
  result := TFhirClaimResponseErrorList(inherited Clone);
end;

function TFhirClaimResponseErrorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseErrorList.GetItemN(index: Integer): TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError(ObjectByIndex[index]);
end;

function TFhirClaimResponseErrorList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponseError;
end;
function TFhirClaimResponseErrorList.IndexOf(value: TFhirClaimResponseError): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseErrorList.Insert(index: Integer): TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseErrorList.InsertItem(index: Integer; value: TFhirClaimResponseError);
begin
  assert(value is TFhirClaimResponseError);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseErrorList.Item(index: Integer): TFhirClaimResponseError;
begin
  result := TFhirClaimResponseError(ObjectByIndex[index]);
end;

function TFhirClaimResponseErrorList.Link: TFhirClaimResponseErrorList;
begin
  result := TFhirClaimResponseErrorList(inherited Link);
end;

procedure TFhirClaimResponseErrorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseErrorList.SetItemByIndex(index: Integer; value: TFhirClaimResponseError);
begin
  assert(value is TFhirClaimResponseError);
  FhirClaimResponseErrors[index] := value;
end;

procedure TFhirClaimResponseErrorList.SetItemN(index: Integer; value: TFhirClaimResponseError);
begin
  assert(value is TFhirClaimResponseError);
  ObjectByIndex[index] := value;
end;

{ TFhirClaimResponse }

constructor TFhirClaimResponse.Create;
begin
  inherited;
end;

destructor TFhirClaimResponse.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FSubType.free;
  FUse.free;
  FPatient.free;
  FCreated.free;
  FInsurer.free;
  FRequestor.free;
  FRequest.free;
  FOutcome.free;
  FDisposition.free;
  FPreAuthRef.free;
  FPreAuthPeriod.free;
  FPayeeType.free;
  FItemList.Free;
  FAddItemList.Free;
  FAdjudicationList.Free;
  FTotalList.Free;
  FPayment.free;
  FFundsReserve.free;
  FFormCode.free;
  FForm.free;
  FProcessNoteList.Free;
  FCommunicationRequestList.Free;
  FInsuranceList.Free;
  FErrorList.Free;
  inherited;
end;

function TFhirClaimResponse.GetResourceType : TFhirResourceType;
begin
  result := frtClaimResponse;
end;

procedure TFhirClaimResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClaimResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirClaimResponse(oSource).FIdentifierList);
  end;
  FStatus := TFhirClaimResponse(oSource).FStatus.Link;
  type_ := TFhirClaimResponse(oSource).type_.Clone;
  subType := TFhirClaimResponse(oSource).subType.Clone;
  FUse := TFhirClaimResponse(oSource).FUse.Link;
  patient := TFhirClaimResponse(oSource).patient.Clone;
  createdElement := TFhirClaimResponse(oSource).createdElement.Clone;
  insurer := TFhirClaimResponse(oSource).insurer.Clone;
  requestor := TFhirClaimResponse(oSource).requestor.Clone;
  request := TFhirClaimResponse(oSource).request.Clone;
  FOutcome := TFhirClaimResponse(oSource).FOutcome.Link;
  dispositionElement := TFhirClaimResponse(oSource).dispositionElement.Clone;
  preAuthRefElement := TFhirClaimResponse(oSource).preAuthRefElement.Clone;
  preAuthPeriod := TFhirClaimResponse(oSource).preAuthPeriod.Clone;
  payeeType := TFhirClaimResponse(oSource).payeeType.Clone;
  if (TFhirClaimResponse(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirClaimResponseItemList.Create;
    FItemList.Assign(TFhirClaimResponse(oSource).FItemList);
  end;
  if (TFhirClaimResponse(oSource).FAddItemList = nil) then
  begin
    FAddItemList.free;
    FAddItemList := nil;
  end
  else
  begin
    if FAddItemList = nil then
      FAddItemList := TFhirClaimResponseAddItemList.Create;
    FAddItemList.Assign(TFhirClaimResponse(oSource).FAddItemList);
  end;
  if (TFhirClaimResponse(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirClaimResponse(oSource).FAdjudicationList);
  end;
  if (TFhirClaimResponse(oSource).FTotalList = nil) then
  begin
    FTotalList.free;
    FTotalList := nil;
  end
  else
  begin
    if FTotalList = nil then
      FTotalList := TFhirClaimResponseTotalList.Create;
    FTotalList.Assign(TFhirClaimResponse(oSource).FTotalList);
  end;
  payment := TFhirClaimResponse(oSource).payment.Clone;
  fundsReserve := TFhirClaimResponse(oSource).fundsReserve.Clone;
  formCode := TFhirClaimResponse(oSource).formCode.Clone;
  form := TFhirClaimResponse(oSource).form.Clone;
  if (TFhirClaimResponse(oSource).FProcessNoteList = nil) then
  begin
    FProcessNoteList.free;
    FProcessNoteList := nil;
  end
  else
  begin
    if FProcessNoteList = nil then
      FProcessNoteList := TFhirClaimResponseProcessNoteList.Create;
    FProcessNoteList.Assign(TFhirClaimResponse(oSource).FProcessNoteList);
  end;
  if (TFhirClaimResponse(oSource).FCommunicationRequestList = nil) then
  begin
    FCommunicationRequestList.free;
    FCommunicationRequestList := nil;
  end
  else
  begin
    if FCommunicationRequestList = nil then
      FCommunicationRequestList := TFhirReferenceList{TFhirCommunicationRequest}.Create;
    FCommunicationRequestList.Assign(TFhirClaimResponse(oSource).FCommunicationRequestList);
  end;
  if (TFhirClaimResponse(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirClaimResponseInsuranceList.Create;
    FInsuranceList.Assign(TFhirClaimResponse(oSource).FInsuranceList);
  end;
  if (TFhirClaimResponse(oSource).FErrorList = nil) then
  begin
    FErrorList.free;
    FErrorList := nil;
  end
  else
  begin
    if FErrorList = nil then
      FErrorList := TFhirClaimResponseErrorList.Create;
    FErrorList.Assign(TFhirClaimResponse(oSource).FErrorList);
  end;
end;

procedure TFhirClaimResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
     list.add(self.link, 'subType', FSubType.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'requestor') Then
     list.add(self.link, 'requestor', FRequestor.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'preAuthRef') Then
     list.add(self.link, 'preAuthRef', FPreAuthRef.Link);
  if (child_name = 'preAuthPeriod') Then
     list.add(self.link, 'preAuthPeriod', FPreAuthPeriod.Link);
  if (child_name = 'payeeType') Then
     list.add(self.link, 'payeeType', FPayeeType.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
  if (child_name = 'addItem') Then
    list.addAll(self, 'addItem', FAddItemList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'total') Then
    list.addAll(self, 'total', FTotalList);
  if (child_name = 'payment') Then
     list.add(self.link, 'payment', FPayment.Link);
  if (child_name = 'fundsReserve') Then
     list.add(self.link, 'fundsReserve', FFundsReserve.Link);
  if (child_name = 'formCode') Then
     list.add(self.link, 'formCode', FFormCode.Link);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'processNote') Then
    list.addAll(self, 'processNote', FProcessNoteList);
  if (child_name = 'communicationRequest') Then
    list.addAll(self, 'communicationRequest', FCommunicationRequestList);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'error') Then
    list.addAll(self, 'error', FErrorList);
end;

procedure TFhirClaimResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', false, TFhirCodeableConcept, FSubType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'use', 'code', false, TFHIREnum, FUse.Link));{1}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FInsurer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestor', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FRequestor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(Claim)', false, TFhirReference{TFhirClaim}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFHIREnum, FOutcome.Link));{1}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'preAuthRef', 'string', false, TFhirString, FPreAuthRef.Link));{2}
  oList.add(TFHIRProperty.create(self, 'preAuthPeriod', 'Period', false, TFhirPeriod, FPreAuthPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payeeType', 'CodeableConcept', false, TFhirCodeableConcept, FPayeeType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirClaimResponseItem, FItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'addItem', '', true, TFhirClaimResponseAddItem, FAddItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '@ClaimResponse.item.adjudication', true, TFhirClaimResponseItemAdjudication, FAdjudicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'total', '', true, TFhirClaimResponseTotal, FTotalList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'payment', '', false, TFhirClaimResponsePayment, FPayment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'fundsReserve', 'CodeableConcept', false, TFhirCodeableConcept, FFundsReserve.Link));{2}
  oList.add(TFHIRProperty.create(self, 'formCode', 'CodeableConcept', false, TFhirCodeableConcept, FFormCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'form', 'Attachment', false, TFhirAttachment, FForm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'processNote', '', true, TFhirClaimResponseProcessNote, FProcessNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'communicationRequest', 'Reference(CommunicationRequest)', true, TFhirReference{TFhirCommunicationRequest}, FCommunicationRequestList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'insurance', '', true, TFhirClaimResponseInsurance, FInsuranceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'error', '', true, TFhirClaimResponseError, FErrorList.Link)){3};
end;

function TFhirClaimResponse.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    UseElement := asEnum(SYSTEMS_TFhirClaimUseEnum, CODES_TFhirClaimUseEnum, propValue);
    result := propValue
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'requestor') then
  begin
    Requestor := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirClaim}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirRemittanceOutcomeEnum, CODES_TFhirRemittanceOutcomeEnum, propValue);
    result := propValue
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'preAuthRef') then
  begin
    PreAuthRefElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'preAuthPeriod') then
  begin
    PreAuthPeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'payeeType') then
  begin
    PayeeType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirClaimResponseItem){2a};
    result := propValue;
  end
  else if (propName = 'addItem') then
  begin
    AddItemList.add(propValue as TFhirClaimResponseAddItem){2a};
    result := propValue;
  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirClaimResponseItemAdjudication){2a};
    result := propValue;
  end
  else if (propName = 'total') then
  begin
    TotalList.add(propValue as TFhirClaimResponseTotal){2a};
    result := propValue;
  end
  else if (propName = 'payment') then
  begin
    Payment := propValue as TFhirClaimResponsePayment{4b};
    result := propValue;
  end
  else if (propName = 'fundsReserve') then
  begin
    FundsReserve := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'formCode') then
  begin
    FormCode := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirAttachment{4b};
    result := propValue;
  end
  else if (propName = 'processNote') then
  begin
    ProcessNoteList.add(propValue as TFhirClaimResponseProcessNote){2a};
    result := propValue;
  end
  else if (propName = 'communicationRequest') then
  begin
    CommunicationRequestList.add(propValue as TFhirReference{TFhirCommunicationRequest}){2a};
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirClaimResponseInsurance){2a};
    result := propValue;
  end
  else if (propName = 'error') then
  begin
    ErrorList.add(propValue as TFhirClaimResponseError){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirClaimResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirClaimResponseItem){2a}
  else if (propName = 'addItem') then AddItemList.insertItem(index, propValue as TFhirClaimResponseAddItem){2a}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirClaimResponseItemAdjudication){2a}
  else if (propName = 'total') then TotalList.insertItem(index, propValue as TFhirClaimResponseTotal){2a}
  else if (propName = 'processNote') then ProcessNoteList.insertItem(index, propValue as TFhirClaimResponseProcessNote){2a}
  else if (propName = 'communicationRequest') then CommunicationRequestList.insertItem(index, propValue as TFhirReference{TFhirCommunicationRequest}){2a}
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirClaimResponseInsurance){2a}
  else if (propName = 'error') then ErrorList.insertItem(index, propValue as TFhirClaimResponseError){2a}
  else inherited;
end;

function TFhirClaimResponse.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'insurer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'requestor') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'request') then result := TFhirReference{TFhirClaim}.create(){4b}
  else if (propName = 'disposition') then result := TFhirString.create() {5b}
  else if (propName = 'preAuthRef') then result := TFhirString.create() {5b}
  else if (propName = 'preAuthPeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'payeeType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'item') then result := ItemList.new(){2}
  else if (propName = 'addItem') then result := AddItemList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else if (propName = 'total') then result := TotalList.new(){2}
  else if (propName = 'payment') then result := TFhirClaimResponsePayment.create(){4b}
  else if (propName = 'fundsReserve') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'formCode') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'form') then result := TFhirAttachment.create(){4b}
  else if (propName = 'processNote') then result := ProcessNoteList.new(){2}
  else if (propName = 'communicationRequest') then result := CommunicationRequestList.new(){2}
  else if (propName = 'insurance') then result := InsuranceList.new(){2}
  else if (propName = 'error') then result := ErrorList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClaimResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'use') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'requestor') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'preAuthRef') then result := 'string'
  else if (propName = 'preAuthPeriod') then result := 'Period'
  else if (propName = 'payeeType') then result := 'CodeableConcept'
  else if (propName = 'item') then result := ''
  else if (propName = 'addItem') then result := ''
  else if (propName = 'adjudication') then result := '@ClaimResponse.item.adjudication'
  else if (propName = 'total') then result := ''
  else if (propName = 'payment') then result := ''
  else if (propName = 'fundsReserve') then result := 'CodeableConcept'
  else if (propName = 'formCode') then result := 'CodeableConcept'
  else if (propName = 'form') then result := 'Attachment'
  else if (propName = 'processNote') then result := ''
  else if (propName = 'communicationRequest') then result := 'Reference'
  else if (propName = 'insurance') then result := ''
  else if (propName = 'error') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClaimResponse.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then SubTypeElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'requestor') then RequestorElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'preAuthRef') then PreAuthRefElement := nil
  else if (propName = 'preAuthPeriod') then PreAuthPeriodElement := nil
  else if (propName = 'payeeType') then PayeeTypeElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else if (propName = 'addItem') then deletePropertyValue('addItem', AddItemList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else if (propName = 'total') then deletePropertyValue('total', TotalList, value) {2}
  else if (propName = 'payment') then PaymentElement := nil
  else if (propName = 'fundsReserve') then FundsReserveElement := nil
  else if (propName = 'formCode') then FormCodeElement := nil
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'processNote') then deletePropertyValue('processNote', ProcessNoteList, value) {2}
  else if (propName = 'communicationRequest') then deletePropertyValue('communicationRequest', CommunicationRequestList, value) {2}
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value) {2}
  else if (propName = 'error') then deletePropertyValue('error', ErrorList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClaimResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'subType') then SubTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'use') then UseElement := asEnum(SYSTEMS_TFhirClaimUseEnum, CODES_TFhirClaimUseEnum, new){4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'requestor') then RequestorElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirClaim}{4}
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirRemittanceOutcomeEnum, CODES_TFhirRemittanceOutcomeEnum, new){4}
  else if (propName = 'disposition') then DispositionElement := asString(new){5b}
  else if (propName = 'preAuthRef') then PreAuthRefElement := asString(new){5b}
  else if (propName = 'preAuthPeriod') then PreAuthPeriodElement := new as TFhirPeriod{4}
  else if (propName = 'payeeType') then PayeeTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else if (propName = 'addItem') then replacePropertyValue('addItem', AddItemList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else if (propName = 'total') then replacePropertyValue('total', TotalList, existing, new) {2}
  else if (propName = 'payment') then PaymentElement := new as TFhirClaimResponsePayment{4}
  else if (propName = 'fundsReserve') then FundsReserveElement := new as TFhirCodeableConcept{4}
  else if (propName = 'formCode') then FormCodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'form') then FormElement := new as TFhirAttachment{4}
  else if (propName = 'processNote') then replacePropertyValue('processNote', ProcessNoteList, existing, new) {2}
  else if (propName = 'communicationRequest') then replacePropertyValue('communicationRequest', CommunicationRequestList, existing, new) {2}
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new) {2}
  else if (propName = 'error') then replacePropertyValue('error', ErrorList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClaimResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'item') then ItemList.move(source, destination){2a}
  else if (propName = 'addItem') then AddItemList.move(source, destination){2a}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else if (propName = 'total') then TotalList.move(source, destination){2a}
  else if (propName = 'processNote') then ProcessNoteList.move(source, destination){2a}
  else if (propName = 'communicationRequest') then CommunicationRequestList.move(source, destination){2a}
  else if (propName = 'insurance') then InsuranceList.move(source, destination){2a}
  else if (propName = 'error') then ErrorList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClaimResponse.fhirType : string;
begin
  result := 'ClaimResponse';
end;

function TFhirClaimResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FSubType) and isEmptyProp(FUse) and isEmptyProp(FPatient) and isEmptyProp(FCreated) and isEmptyProp(FInsurer) and isEmptyProp(FRequestor) and isEmptyProp(FRequest) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FPreAuthRef) and isEmptyProp(FPreAuthPeriod) and isEmptyProp(FPayeeType) and isEmptyProp(FitemList) and isEmptyProp(FaddItemList) and isEmptyProp(FadjudicationList) and isEmptyProp(FtotalList) and isEmptyProp(FPayment) and isEmptyProp(FFundsReserve) and isEmptyProp(FFormCode) and isEmptyProp(FForm) and isEmptyProp(FprocessNoteList) and isEmptyProp(FcommunicationRequestList) and isEmptyProp(FinsuranceList) and isEmptyProp(FerrorList);
end;

function TFhirClaimResponse.equals(other : TObject) : boolean; 
var
  o : TFhirClaimResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClaimResponse)) then
    result := false
  else
  begin
    o := TFhirClaimResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeElement, o.subTypeElement, true) and 
      compareDeep(useElement, o.useElement, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(createdElement, o.createdElement, true) and compareDeep(insurerElement, o.insurerElement, true) and 
      compareDeep(requestorElement, o.requestorElement, true) and compareDeep(requestElement, o.requestElement, true) and 
      compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(dispositionElement, o.dispositionElement, true) and 
      compareDeep(preAuthRefElement, o.preAuthRefElement, true) and compareDeep(preAuthPeriodElement, o.preAuthPeriodElement, true) and 
      compareDeep(payeeTypeElement, o.payeeTypeElement, true) and compareDeep(itemList, o.itemList, true) and 
      compareDeep(addItemList, o.addItemList, true) and compareDeep(adjudicationList, o.adjudicationList, true) and 
      compareDeep(totalList, o.totalList, true) and compareDeep(paymentElement, o.paymentElement, true) and 
      compareDeep(fundsReserveElement, o.fundsReserveElement, true) and compareDeep(formCodeElement, o.formCodeElement, true) and 
      compareDeep(formElement, o.formElement, true) and compareDeep(processNoteList, o.processNoteList, true) and 
      compareDeep(communicationRequestList, o.communicationRequestList, true) and compareDeep(insuranceList, o.insuranceList, true) and 
      compareDeep(errorList, o.errorList, true);
  end;
end;

function TFhirClaimResponse.Link : TFhirClaimResponse;
begin
  result := TFhirClaimResponse(inherited Link);
end;

function TFhirClaimResponse.Clone : TFhirClaimResponse;
begin
  result := TFhirClaimResponse(inherited Clone);
end;

procedure TFhirClaimResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('subType');
  fields.add('use');
  fields.add('patient');
  fields.add('created');
  fields.add('insurer');
  fields.add('requestor');
  fields.add('request');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('preAuthRef');
  fields.add('preAuthPeriod');
  fields.add('payeeType');
  fields.add('item');
  fields.add('addItem');
  fields.add('adjudication');
  fields.add('total');
  fields.add('payment');
  fields.add('fundsReserve');
  fields.add('formCode');
  fields.add('form');
  fields.add('processNote');
  fields.add('communicationRequest');
  fields.add('insurance');
  fields.add('error');
end;

{ TFhirClaimResponse }

Function TFhirClaimResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirClaimResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirClaimResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirClaimResponse.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirClaimResponse.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Procedure TFhirClaimResponse.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirClaimResponse.SetSubType(value : TFhirCodeableConcept);
begin
  FSubType.free;
  FSubType := value;
end;

Procedure TFhirClaimResponse.SetUse(value : TFhirEnum);
begin
  FUse.free;
  FUse := value;
end;

Function TFhirClaimResponse.GetUseST : TFhirClaimUseEnum;
begin
  if FUse = nil then
    result := TFhirClaimUseEnum(0)
  else
    result := TFhirClaimUseEnum(StringArrayIndexOfSensitive(CODES_TFhirClaimUseEnum, FUse.value));
end;

Procedure TFhirClaimResponse.SetUseST(value : TFhirClaimUseEnum);
begin
  if ord(value) = 0 then
    UseElement := nil
  else
    UseElement := TFhirEnum.create(SYSTEMS_TFhirClaimUseEnum[value], CODES_TFhirClaimUseEnum[value]);
end;

Procedure TFhirClaimResponse.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirClaimResponse.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirClaimResponse.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirClaimResponse.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirClaimResponse.SetInsurer(value : TFhirReference{TFhirOrganization});
begin
  FInsurer.free;
  FInsurer := value;
end;

Procedure TFhirClaimResponse.SetRequestor(value : TFhirReference{TFhirPractitioner});
begin
  FRequestor.free;
  FRequestor := value;
end;

Procedure TFhirClaimResponse.SetRequest(value : TFhirReference{TFhirClaim});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirClaimResponse.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirClaimResponse.GetOutcomeST : TFhirRemittanceOutcomeEnum;
begin
  if FOutcome = nil then
    result := TFhirRemittanceOutcomeEnum(0)
  else
    result := TFhirRemittanceOutcomeEnum(StringArrayIndexOfSensitive(CODES_TFhirRemittanceOutcomeEnum, FOutcome.value));
end;

Procedure TFhirClaimResponse.SetOutcomeST(value : TFhirRemittanceOutcomeEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirRemittanceOutcomeEnum[value], CODES_TFhirRemittanceOutcomeEnum[value]);
end;

Procedure TFhirClaimResponse.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

Function TFhirClaimResponse.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

Procedure TFhirClaimResponse.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

Procedure TFhirClaimResponse.SetPreAuthRef(value : TFhirString);
begin
  FPreAuthRef.free;
  FPreAuthRef := value;
end;

Function TFhirClaimResponse.GetPreAuthRefST : String;
begin
  if FPreAuthRef = nil then
    result := ''
  else
    result := FPreAuthRef.value;
end;

Procedure TFhirClaimResponse.SetPreAuthRefST(value : String);
begin
  if value <> '' then
  begin
    if FPreAuthRef = nil then
      FPreAuthRef := TFhirString.create;
    FPreAuthRef.value := value
  end
  else if FPreAuthRef <> nil then
    FPreAuthRef.value := '';
end;

Procedure TFhirClaimResponse.SetPreAuthPeriod(value : TFhirPeriod);
begin
  FPreAuthPeriod.free;
  FPreAuthPeriod := value;
end;

Procedure TFhirClaimResponse.SetPayeeType(value : TFhirCodeableConcept);
begin
  FPayeeType.free;
  FPayeeType := value;
end;

Function TFhirClaimResponse.GetItemList : TFhirClaimResponseItemList;
begin
  if FItemList = nil then
    FItemList := TFhirClaimResponseItemList.Create;
  result := FItemList;
end;

Function TFhirClaimResponse.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

Function TFhirClaimResponse.GetAddItemList : TFhirClaimResponseAddItemList;
begin
  if FAddItemList = nil then
    FAddItemList := TFhirClaimResponseAddItemList.Create;
  result := FAddItemList;
end;

Function TFhirClaimResponse.GetHasAddItemList : boolean;
begin
  result := (FAddItemList <> nil) and (FAddItemList.count > 0);
end;

Function TFhirClaimResponse.GetAdjudicationList : TFhirClaimResponseItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirClaimResponseItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirClaimResponse.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

Function TFhirClaimResponse.GetTotalList : TFhirClaimResponseTotalList;
begin
  if FTotalList = nil then
    FTotalList := TFhirClaimResponseTotalList.Create;
  result := FTotalList;
end;

Function TFhirClaimResponse.GetHasTotalList : boolean;
begin
  result := (FTotalList <> nil) and (FTotalList.count > 0);
end;

Procedure TFhirClaimResponse.SetPayment(value : TFhirClaimResponsePayment);
begin
  FPayment.free;
  FPayment := value;
end;

Procedure TFhirClaimResponse.SetFundsReserve(value : TFhirCodeableConcept);
begin
  FFundsReserve.free;
  FFundsReserve := value;
end;

Procedure TFhirClaimResponse.SetFormCode(value : TFhirCodeableConcept);
begin
  FFormCode.free;
  FFormCode := value;
end;

Procedure TFhirClaimResponse.SetForm(value : TFhirAttachment);
begin
  FForm.free;
  FForm := value;
end;

Function TFhirClaimResponse.GetProcessNoteList : TFhirClaimResponseProcessNoteList;
begin
  if FProcessNoteList = nil then
    FProcessNoteList := TFhirClaimResponseProcessNoteList.Create;
  result := FProcessNoteList;
end;

Function TFhirClaimResponse.GetHasProcessNoteList : boolean;
begin
  result := (FProcessNoteList <> nil) and (FProcessNoteList.count > 0);
end;

Function TFhirClaimResponse.GetCommunicationRequestList : TFhirReferenceList{TFhirCommunicationRequest};
begin
  if FCommunicationRequestList = nil then
    FCommunicationRequestList := TFhirReferenceList{TFhirCommunicationRequest}.Create;
  result := FCommunicationRequestList;
end;

Function TFhirClaimResponse.GetHasCommunicationRequestList : boolean;
begin
  result := (FCommunicationRequestList <> nil) and (FCommunicationRequestList.count > 0);
end;

Function TFhirClaimResponse.GetInsuranceList : TFhirClaimResponseInsuranceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirClaimResponseInsuranceList.Create;
  result := FInsuranceList;
end;

Function TFhirClaimResponse.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

Function TFhirClaimResponse.GetErrorList : TFhirClaimResponseErrorList;
begin
  if FErrorList = nil then
    FErrorList := TFhirClaimResponseErrorList.Create;
  result := FErrorList;
end;

Function TFhirClaimResponse.GetHasErrorList : boolean;
begin
  result := (FErrorList <> nil) and (FErrorList.count > 0);
end;

function TFhirClaimResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSubType.sizeInBytes);
  inc(result, FUse.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FInsurer.sizeInBytes);
  inc(result, FRequestor.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FPreAuthRef.sizeInBytes);
  inc(result, FPreAuthPeriod.sizeInBytes);
  inc(result, FPayeeType.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
  inc(result, FaddItemList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FtotalList.sizeInBytes);
  inc(result, FPayment.sizeInBytes);
  inc(result, FFundsReserve.sizeInBytes);
  inc(result, FFormCode.sizeInBytes);
  inc(result, FForm.sizeInBytes);
  inc(result, FprocessNoteList.sizeInBytes);
  inc(result, FcommunicationRequestList.sizeInBytes);
  inc(result, FinsuranceList.sizeInBytes);
  inc(result, FerrorList.sizeInBytes);
end;

{ TFhirClaimResponseListEnumerator }

Constructor TFhirClaimResponseListEnumerator.Create(list : TFhirClaimResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClaimResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClaimResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClaimResponseListEnumerator.GetCurrent : TFhirClaimResponse;
begin
  Result := FList[FIndex];
end;

function TFhirClaimResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClaimResponseList }
procedure TFhirClaimResponseList.AddItem(value: TFhirClaimResponse);
begin
  assert(value.ClassName = 'TFhirClaimResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClaimResponse');
  add(value);
end;

function TFhirClaimResponseList.Append: TFhirClaimResponse;
begin
  result := TFhirClaimResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseList.ClearItems;
begin
  Clear;
end;

function TFhirClaimResponseList.GetEnumerator : TFhirClaimResponseListEnumerator;
begin
  result := TFhirClaimResponseListEnumerator.Create(self.link);
end;

function TFhirClaimResponseList.Clone: TFhirClaimResponseList;
begin
  result := TFhirClaimResponseList(inherited Clone);
end;

function TFhirClaimResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClaimResponseList.GetItemN(index: Integer): TFhirClaimResponse;
begin
  result := TFhirClaimResponse(ObjectByIndex[index]);
end;

function TFhirClaimResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirClaimResponse;
end;
function TFhirClaimResponseList.IndexOf(value: TFhirClaimResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClaimResponseList.Insert(index: Integer): TFhirClaimResponse;
begin
  result := TFhirClaimResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClaimResponseList.InsertItem(index: Integer; value: TFhirClaimResponse);
begin
  assert(value is TFhirClaimResponse);
  Inherited Insert(index, value);
end;

function TFhirClaimResponseList.Item(index: Integer): TFhirClaimResponse;
begin
  result := TFhirClaimResponse(ObjectByIndex[index]);
end;

function TFhirClaimResponseList.Link: TFhirClaimResponseList;
begin
  result := TFhirClaimResponseList(inherited Link);
end;

procedure TFhirClaimResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClaimResponseList.SetItemByIndex(index: Integer; value: TFhirClaimResponse);
begin
  assert(value is TFhirClaimResponse);
  FhirClaimResponses[index] := value;
end;

procedure TFhirClaimResponseList.SetItemN(index: Integer; value: TFhirClaimResponse);
begin
  assert(value is TFhirClaimResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CLAIMRESPONSE}

{$IFDEF FHIR_COVERAGE}

{ TFhirCoverageClass }

constructor TFhirCoverageClass.Create;
begin
  inherited;
end;

destructor TFhirCoverageClass.Destroy;
begin
  FType_.free;
  FValue.free;
  FName.free;
  inherited;
end;

procedure TFhirCoverageClass.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCoverageClass(oSource).type_.Clone;
  valueElement := TFhirCoverageClass(oSource).valueElement.Clone;
  nameElement := TFhirCoverageClass(oSource).nameElement.Clone;
end;

procedure TFhirCoverageClass.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
end;

procedure TFhirCoverageClass.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
end;

function TFhirCoverageClass.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageClass.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageClass.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'value') then result := TFhirString.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageClass.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageClass.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'name') then NameElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageClass.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'value') then ValueElement := asString(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageClass.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageClass.fhirType : string;
begin
  result := 'class';
end;

function TFhirCoverageClass.Link : TFhirCoverageClass;
begin
  result := TFhirCoverageClass(inherited Link);
end;

function TFhirCoverageClass.Clone : TFhirCoverageClass;
begin
  result := TFhirCoverageClass(inherited Clone);
end;

function TFhirCoverageClass.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageClass;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageClass)) then
    result := false
  else
  begin
    o := TFhirCoverageClass(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(nameElement, o.nameElement, true);
  end;
end;

function TFhirCoverageClass.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue) and isEmptyProp(FName);
end;

procedure TFhirCoverageClass.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value');
  fields.add('name');
end;

{ TFhirCoverageClass }

Procedure TFhirCoverageClass.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirCoverageClass.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirCoverageClass.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirCoverageClass.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

Procedure TFhirCoverageClass.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirCoverageClass.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirCoverageClass.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

function TFhirCoverageClass.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FName.sizeInBytes);
end;

{ TFhirCoverageClassListEnumerator }

Constructor TFhirCoverageClassListEnumerator.Create(list : TFhirCoverageClassList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageClassListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageClassListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageClassListEnumerator.GetCurrent : TFhirCoverageClass;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageClassListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageClassList }
procedure TFhirCoverageClassList.AddItem(value: TFhirCoverageClass);
begin
  assert(value.ClassName = 'TFhirCoverageClass', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageClass');
  add(value);
end;

function TFhirCoverageClassList.Append: TFhirCoverageClass;
begin
  result := TFhirCoverageClass.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageClassList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageClassList.GetEnumerator : TFhirCoverageClassListEnumerator;
begin
  result := TFhirCoverageClassListEnumerator.Create(self.link);
end;

function TFhirCoverageClassList.Clone: TFhirCoverageClassList;
begin
  result := TFhirCoverageClassList(inherited Clone);
end;

function TFhirCoverageClassList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageClassList.GetItemN(index: Integer): TFhirCoverageClass;
begin
  result := TFhirCoverageClass(ObjectByIndex[index]);
end;

function TFhirCoverageClassList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageClass;
end;
function TFhirCoverageClassList.IndexOf(value: TFhirCoverageClass): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageClassList.Insert(index: Integer): TFhirCoverageClass;
begin
  result := TFhirCoverageClass.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageClassList.InsertItem(index: Integer; value: TFhirCoverageClass);
begin
  assert(value is TFhirCoverageClass);
  Inherited Insert(index, value);
end;

function TFhirCoverageClassList.Item(index: Integer): TFhirCoverageClass;
begin
  result := TFhirCoverageClass(ObjectByIndex[index]);
end;

function TFhirCoverageClassList.Link: TFhirCoverageClassList;
begin
  result := TFhirCoverageClassList(inherited Link);
end;

procedure TFhirCoverageClassList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageClassList.SetItemByIndex(index: Integer; value: TFhirCoverageClass);
begin
  assert(value is TFhirCoverageClass);
  FhirCoverageClasses[index] := value;
end;

procedure TFhirCoverageClassList.SetItemN(index: Integer; value: TFhirCoverageClass);
begin
  assert(value is TFhirCoverageClass);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageCostToBeneficiary }

constructor TFhirCoverageCostToBeneficiary.Create;
begin
  inherited;
end;

destructor TFhirCoverageCostToBeneficiary.Destroy;
begin
  FType_.free;
  FValue.free;
  FExceptionList.Free;
  inherited;
end;

procedure TFhirCoverageCostToBeneficiary.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCoverageCostToBeneficiary(oSource).type_.Clone;
  value := TFhirCoverageCostToBeneficiary(oSource).value.Clone;
  if (TFhirCoverageCostToBeneficiary(oSource).FExceptionList = nil) then
  begin
    FExceptionList.free;
    FExceptionList := nil;
  end
  else
  begin
    if FExceptionList = nil then
      FExceptionList := TFhirCoverageCostToBeneficiaryExceptionList.Create;
    FExceptionList.Assign(TFhirCoverageCostToBeneficiary(oSource).FExceptionList);
  end;
end;

procedure TFhirCoverageCostToBeneficiary.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'exception') Then
    list.addAll(self, 'exception', FExceptionList);
end;

procedure TFhirCoverageCostToBeneficiary.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'Quantity|Money', false, TFhirType, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'exception', '', true, TFhirCoverageCostToBeneficiaryException, FExceptionList.Link)){3};
end;

function TFhirCoverageCostToBeneficiary.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Quantity', 'Money'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'exception') then
  begin
    ExceptionList.add(propValue as TFhirCoverageCostToBeneficiaryException){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageCostToBeneficiary.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'exception') then ExceptionList.insertItem(index, propValue as TFhirCoverageCostToBeneficiaryException){2a}
  else inherited;
end;

function TFhirCoverageCostToBeneficiary.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'value', ['Quantity', 'Money'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else if (propName = 'exception') then result := ExceptionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageCostToBeneficiary.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'Quantity|Money'
  else if (propName = 'exception') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageCostToBeneficiary.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['Quantity', 'Money'])) then ValueElement := nil{4x}
  else if (propName = 'exception') then deletePropertyValue('exception', ExceptionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageCostToBeneficiary.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'value', ['Quantity', 'Money'])) then ValueElement := new as TFhirType{4x}
  else if (propName = 'exception') then replacePropertyValue('exception', ExceptionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageCostToBeneficiary.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'exception') then ExceptionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageCostToBeneficiary.fhirType : string;
begin
  result := 'costToBeneficiary';
end;

function TFhirCoverageCostToBeneficiary.Link : TFhirCoverageCostToBeneficiary;
begin
  result := TFhirCoverageCostToBeneficiary(inherited Link);
end;

function TFhirCoverageCostToBeneficiary.Clone : TFhirCoverageCostToBeneficiary;
begin
  result := TFhirCoverageCostToBeneficiary(inherited Clone);
end;

function TFhirCoverageCostToBeneficiary.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageCostToBeneficiary;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageCostToBeneficiary)) then
    result := false
  else
  begin
    o := TFhirCoverageCostToBeneficiary(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(exceptionList, o.exceptionList, true);
  end;
end;

function TFhirCoverageCostToBeneficiary.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue) and isEmptyProp(FexceptionList);
end;

procedure TFhirCoverageCostToBeneficiary.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
  fields.add('exception');
end;

{ TFhirCoverageCostToBeneficiary }

Procedure TFhirCoverageCostToBeneficiary.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirCoverageCostToBeneficiary.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirCoverageCostToBeneficiary.GetExceptionList : TFhirCoverageCostToBeneficiaryExceptionList;
begin
  if FExceptionList = nil then
    FExceptionList := TFhirCoverageCostToBeneficiaryExceptionList.Create;
  result := FExceptionList;
end;

Function TFhirCoverageCostToBeneficiary.GetHasExceptionList : boolean;
begin
  result := (FExceptionList <> nil) and (FExceptionList.count > 0);
end;

function TFhirCoverageCostToBeneficiary.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FexceptionList.sizeInBytes);
end;

{ TFhirCoverageCostToBeneficiaryListEnumerator }

Constructor TFhirCoverageCostToBeneficiaryListEnumerator.Create(list : TFhirCoverageCostToBeneficiaryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageCostToBeneficiaryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageCostToBeneficiaryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageCostToBeneficiaryListEnumerator.GetCurrent : TFhirCoverageCostToBeneficiary;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageCostToBeneficiaryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageCostToBeneficiaryList }
procedure TFhirCoverageCostToBeneficiaryList.AddItem(value: TFhirCoverageCostToBeneficiary);
begin
  assert(value.ClassName = 'TFhirCoverageCostToBeneficiary', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageCostToBeneficiary');
  add(value);
end;

function TFhirCoverageCostToBeneficiaryList.Append: TFhirCoverageCostToBeneficiary;
begin
  result := TFhirCoverageCostToBeneficiary.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageCostToBeneficiaryList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageCostToBeneficiaryList.GetEnumerator : TFhirCoverageCostToBeneficiaryListEnumerator;
begin
  result := TFhirCoverageCostToBeneficiaryListEnumerator.Create(self.link);
end;

function TFhirCoverageCostToBeneficiaryList.Clone: TFhirCoverageCostToBeneficiaryList;
begin
  result := TFhirCoverageCostToBeneficiaryList(inherited Clone);
end;

function TFhirCoverageCostToBeneficiaryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageCostToBeneficiaryList.GetItemN(index: Integer): TFhirCoverageCostToBeneficiary;
begin
  result := TFhirCoverageCostToBeneficiary(ObjectByIndex[index]);
end;

function TFhirCoverageCostToBeneficiaryList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageCostToBeneficiary;
end;
function TFhirCoverageCostToBeneficiaryList.IndexOf(value: TFhirCoverageCostToBeneficiary): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageCostToBeneficiaryList.Insert(index: Integer): TFhirCoverageCostToBeneficiary;
begin
  result := TFhirCoverageCostToBeneficiary.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageCostToBeneficiaryList.InsertItem(index: Integer; value: TFhirCoverageCostToBeneficiary);
begin
  assert(value is TFhirCoverageCostToBeneficiary);
  Inherited Insert(index, value);
end;

function TFhirCoverageCostToBeneficiaryList.Item(index: Integer): TFhirCoverageCostToBeneficiary;
begin
  result := TFhirCoverageCostToBeneficiary(ObjectByIndex[index]);
end;

function TFhirCoverageCostToBeneficiaryList.Link: TFhirCoverageCostToBeneficiaryList;
begin
  result := TFhirCoverageCostToBeneficiaryList(inherited Link);
end;

procedure TFhirCoverageCostToBeneficiaryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageCostToBeneficiaryList.SetItemByIndex(index: Integer; value: TFhirCoverageCostToBeneficiary);
begin
  assert(value is TFhirCoverageCostToBeneficiary);
  FhirCoverageCostToBeneficiaries[index] := value;
end;

procedure TFhirCoverageCostToBeneficiaryList.SetItemN(index: Integer; value: TFhirCoverageCostToBeneficiary);
begin
  assert(value is TFhirCoverageCostToBeneficiary);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageCostToBeneficiaryException }

constructor TFhirCoverageCostToBeneficiaryException.Create;
begin
  inherited;
end;

destructor TFhirCoverageCostToBeneficiaryException.Destroy;
begin
  FType_.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirCoverageCostToBeneficiaryException.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCoverageCostToBeneficiaryException(oSource).type_.Clone;
  period := TFhirCoverageCostToBeneficiaryException(oSource).period.Clone;
end;

procedure TFhirCoverageCostToBeneficiaryException.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirCoverageCostToBeneficiaryException.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
end;

function TFhirCoverageCostToBeneficiaryException.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageCostToBeneficiaryException.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageCostToBeneficiaryException.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageCostToBeneficiaryException.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageCostToBeneficiaryException.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageCostToBeneficiaryException.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageCostToBeneficiaryException.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageCostToBeneficiaryException.fhirType : string;
begin
  result := 'exception';
end;

function TFhirCoverageCostToBeneficiaryException.Link : TFhirCoverageCostToBeneficiaryException;
begin
  result := TFhirCoverageCostToBeneficiaryException(inherited Link);
end;

function TFhirCoverageCostToBeneficiaryException.Clone : TFhirCoverageCostToBeneficiaryException;
begin
  result := TFhirCoverageCostToBeneficiaryException(inherited Clone);
end;

function TFhirCoverageCostToBeneficiaryException.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageCostToBeneficiaryException;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageCostToBeneficiaryException)) then
    result := false
  else
  begin
    o := TFhirCoverageCostToBeneficiaryException(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirCoverageCostToBeneficiaryException.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FPeriod);
end;

procedure TFhirCoverageCostToBeneficiaryException.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('period');
end;

{ TFhirCoverageCostToBeneficiaryException }

Procedure TFhirCoverageCostToBeneficiaryException.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirCoverageCostToBeneficiaryException.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirCoverageCostToBeneficiaryException.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirCoverageCostToBeneficiaryExceptionListEnumerator }

Constructor TFhirCoverageCostToBeneficiaryExceptionListEnumerator.Create(list : TFhirCoverageCostToBeneficiaryExceptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageCostToBeneficiaryExceptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageCostToBeneficiaryExceptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageCostToBeneficiaryExceptionListEnumerator.GetCurrent : TFhirCoverageCostToBeneficiaryException;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageCostToBeneficiaryExceptionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageCostToBeneficiaryExceptionList }
procedure TFhirCoverageCostToBeneficiaryExceptionList.AddItem(value: TFhirCoverageCostToBeneficiaryException);
begin
  assert(value.ClassName = 'TFhirCoverageCostToBeneficiaryException', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageCostToBeneficiaryException');
  add(value);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.Append: TFhirCoverageCostToBeneficiaryException;
begin
  result := TFhirCoverageCostToBeneficiaryException.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageCostToBeneficiaryExceptionList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageCostToBeneficiaryExceptionList.GetEnumerator : TFhirCoverageCostToBeneficiaryExceptionListEnumerator;
begin
  result := TFhirCoverageCostToBeneficiaryExceptionListEnumerator.Create(self.link);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.Clone: TFhirCoverageCostToBeneficiaryExceptionList;
begin
  result := TFhirCoverageCostToBeneficiaryExceptionList(inherited Clone);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageCostToBeneficiaryExceptionList.GetItemN(index: Integer): TFhirCoverageCostToBeneficiaryException;
begin
  result := TFhirCoverageCostToBeneficiaryException(ObjectByIndex[index]);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageCostToBeneficiaryException;
end;
function TFhirCoverageCostToBeneficiaryExceptionList.IndexOf(value: TFhirCoverageCostToBeneficiaryException): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.Insert(index: Integer): TFhirCoverageCostToBeneficiaryException;
begin
  result := TFhirCoverageCostToBeneficiaryException.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageCostToBeneficiaryExceptionList.InsertItem(index: Integer; value: TFhirCoverageCostToBeneficiaryException);
begin
  assert(value is TFhirCoverageCostToBeneficiaryException);
  Inherited Insert(index, value);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.Item(index: Integer): TFhirCoverageCostToBeneficiaryException;
begin
  result := TFhirCoverageCostToBeneficiaryException(ObjectByIndex[index]);
end;

function TFhirCoverageCostToBeneficiaryExceptionList.Link: TFhirCoverageCostToBeneficiaryExceptionList;
begin
  result := TFhirCoverageCostToBeneficiaryExceptionList(inherited Link);
end;

procedure TFhirCoverageCostToBeneficiaryExceptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageCostToBeneficiaryExceptionList.SetItemByIndex(index: Integer; value: TFhirCoverageCostToBeneficiaryException);
begin
  assert(value is TFhirCoverageCostToBeneficiaryException);
  FhirCoverageCostToBeneficiaryExceptions[index] := value;
end;

procedure TFhirCoverageCostToBeneficiaryExceptionList.SetItemN(index: Integer; value: TFhirCoverageCostToBeneficiaryException);
begin
  assert(value is TFhirCoverageCostToBeneficiaryException);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverage }

constructor TFhirCoverage.Create;
begin
  inherited;
end;

destructor TFhirCoverage.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FPolicyHolder.free;
  FSubscriber.free;
  FSubscriberId.free;
  FBeneficiary.free;
  FDependent.free;
  FRelationship.free;
  FPeriod.free;
  FPayorList.Free;
  FClass_List.Free;
  FOrder.free;
  FNetwork.free;
  FCostToBeneficiaryList.Free;
  FSubrogation.free;
  FContractList.Free;
  inherited;
end;

function TFhirCoverage.GetResourceType : TFhirResourceType;
begin
  result := frtCoverage;
end;

procedure TFhirCoverage.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCoverage(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCoverage(oSource).FIdentifierList);
  end;
  FStatus := TFhirCoverage(oSource).FStatus.Link;
  type_ := TFhirCoverage(oSource).type_.Clone;
  policyHolder := TFhirCoverage(oSource).policyHolder.Clone;
  subscriber := TFhirCoverage(oSource).subscriber.Clone;
  subscriberIdElement := TFhirCoverage(oSource).subscriberIdElement.Clone;
  beneficiary := TFhirCoverage(oSource).beneficiary.Clone;
  dependentElement := TFhirCoverage(oSource).dependentElement.Clone;
  relationship := TFhirCoverage(oSource).relationship.Clone;
  period := TFhirCoverage(oSource).period.Clone;
  if (TFhirCoverage(oSource).FPayorList = nil) then
  begin
    FPayorList.free;
    FPayorList := nil;
  end
  else
  begin
    if FPayorList = nil then
      FPayorList := TFhirReferenceList{TFhirOrganization}.Create;
    FPayorList.Assign(TFhirCoverage(oSource).FPayorList);
  end;
  if (TFhirCoverage(oSource).FClass_List = nil) then
  begin
    FClass_List.free;
    FClass_List := nil;
  end
  else
  begin
    if FClass_List = nil then
      FClass_List := TFhirCoverageClassList.Create;
    FClass_List.Assign(TFhirCoverage(oSource).FClass_List);
  end;
  orderElement := TFhirCoverage(oSource).orderElement.Clone;
  networkElement := TFhirCoverage(oSource).networkElement.Clone;
  if (TFhirCoverage(oSource).FCostToBeneficiaryList = nil) then
  begin
    FCostToBeneficiaryList.free;
    FCostToBeneficiaryList := nil;
  end
  else
  begin
    if FCostToBeneficiaryList = nil then
      FCostToBeneficiaryList := TFhirCoverageCostToBeneficiaryList.Create;
    FCostToBeneficiaryList.Assign(TFhirCoverage(oSource).FCostToBeneficiaryList);
  end;
  subrogationElement := TFhirCoverage(oSource).subrogationElement.Clone;
  if (TFhirCoverage(oSource).FContractList = nil) then
  begin
    FContractList.free;
    FContractList := nil;
  end
  else
  begin
    if FContractList = nil then
      FContractList := TFhirReferenceList{TFhirContract}.Create;
    FContractList.Assign(TFhirCoverage(oSource).FContractList);
  end;
end;

procedure TFhirCoverage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'policyHolder') Then
     list.add(self.link, 'policyHolder', FPolicyHolder.Link);
  if (child_name = 'subscriber') Then
     list.add(self.link, 'subscriber', FSubscriber.Link);
  if (child_name = 'subscriberId') Then
     list.add(self.link, 'subscriberId', FSubscriberId.Link);
  if (child_name = 'beneficiary') Then
     list.add(self.link, 'beneficiary', FBeneficiary.Link);
  if (child_name = 'dependent') Then
     list.add(self.link, 'dependent', FDependent.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'payor') Then
    list.addAll(self, 'payor', FPayorList);
  if (child_name = 'class') Then
    list.addAll(self, 'class', FClass_List);
  if (child_name = 'order') Then
     list.add(self.link, 'order', FOrder.Link);
  if (child_name = 'network') Then
     list.add(self.link, 'network', FNetwork.Link);
  if (child_name = 'costToBeneficiary') Then
    list.addAll(self, 'costToBeneficiary', FCostToBeneficiaryList);
  if (child_name = 'subrogation') Then
     list.add(self.link, 'subrogation', FSubrogation.Link);
  if (child_name = 'contract') Then
    list.addAll(self, 'contract', FContractList);
end;

procedure TFhirCoverage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'policyHolder', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPolicyHolder.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subscriber', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FSubscriber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subscriberId', 'string', false, TFhirString, FSubscriberId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'beneficiary', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FBeneficiary.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dependent', 'string', false, TFhirString, FDependent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', false, TFhirCodeableConcept, FRelationship.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payor', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FPayorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'class', '', true, TFhirCoverageClass, FClass_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'order', 'positiveInt', false, TFhirPositiveInt, FOrder.Link));{2}
  oList.add(TFHIRProperty.create(self, 'network', 'string', false, TFhirString, FNetwork.Link));{2}
  oList.add(TFHIRProperty.create(self, 'costToBeneficiary', '', true, TFhirCoverageCostToBeneficiary, FCostToBeneficiaryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subrogation', 'boolean', false, TFhirBoolean, FSubrogation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contract', 'Reference(Contract)', true, TFhirReference{TFhirContract}, FContractList.Link)){3};
end;

function TFhirCoverage.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'policyHolder') then
  begin
    PolicyHolder := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'subscriber') then
  begin
    Subscriber := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'subscriberId') then
  begin
    SubscriberIdElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'beneficiary') then
  begin
    Beneficiary := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'dependent') then
  begin
    DependentElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'payor') then
  begin
    PayorList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_List.add(propValue as TFhirCoverageClass){2a};
    result := propValue;
  end
  else if (propName = 'order') then
  begin
    OrderElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    NetworkElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'costToBeneficiary') then
  begin
    CostToBeneficiaryList.add(propValue as TFhirCoverageCostToBeneficiary){2a};
    result := propValue;
  end
  else if (propName = 'subrogation') then
  begin
    SubrogationElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contract') then
  begin
    ContractList.add(propValue as TFhirReference{TFhirContract}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirCoverage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'payor') then PayorList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else if (propName = 'class') then Class_List.insertItem(index, propValue as TFhirCoverageClass){2a}
  else if (propName = 'costToBeneficiary') then CostToBeneficiaryList.insertItem(index, propValue as TFhirCoverageCostToBeneficiary){2a}
  else if (propName = 'contract') then ContractList.insertItem(index, propValue as TFhirReference{TFhirContract}){2a}
  else inherited;
end;

function TFhirCoverage.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'policyHolder') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'subscriber') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'subscriberId') then result := TFhirString.create() {5b}
  else if (propName = 'beneficiary') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'dependent') then result := TFhirString.create() {5b}
  else if (propName = 'relationship') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'payor') then result := PayorList.new(){2}
  else if (propName = 'class') then result := Class_List.new(){2}
  else if (propName = 'order') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'network') then result := TFhirString.create() {5b}
  else if (propName = 'costToBeneficiary') then result := CostToBeneficiaryList.new(){2}
  else if (propName = 'subrogation') then result := TFhirBoolean.create() {5b}
  else if (propName = 'contract') then result := ContractList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'policyHolder') then result := 'Reference'
  else if (propName = 'subscriber') then result := 'Reference'
  else if (propName = 'subscriberId') then result := 'string'
  else if (propName = 'beneficiary') then result := 'Reference'
  else if (propName = 'dependent') then result := 'string'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'payor') then result := 'Reference'
  else if (propName = 'class') then result := ''
  else if (propName = 'order') then result := 'positiveInt'
  else if (propName = 'network') then result := 'string'
  else if (propName = 'costToBeneficiary') then result := ''
  else if (propName = 'subrogation') then result := 'boolean'
  else if (propName = 'contract') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverage.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'policyHolder') then PolicyHolderElement := nil
  else if (propName = 'subscriber') then SubscriberElement := nil
  else if (propName = 'subscriberId') then SubscriberIdElement := nil
  else if (propName = 'beneficiary') then BeneficiaryElement := nil
  else if (propName = 'dependent') then DependentElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'payor') then deletePropertyValue('payor', PayorList, value) {2}
  else if (propName = 'class') then deletePropertyValue('class', Class_List, value) {2}
  else if (propName = 'order') then OrderElement := nil
  else if (propName = 'network') then NetworkElement := nil
  else if (propName = 'costToBeneficiary') then deletePropertyValue('costToBeneficiary', CostToBeneficiaryList, value) {2}
  else if (propName = 'subrogation') then SubrogationElement := nil
  else if (propName = 'contract') then deletePropertyValue('contract', ContractList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'policyHolder') then PolicyHolderElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'subscriber') then SubscriberElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'subscriberId') then SubscriberIdElement := asString(new){5b}
  else if (propName = 'beneficiary') then BeneficiaryElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'dependent') then DependentElement := asString(new){5b}
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCodeableConcept{4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'payor') then replacePropertyValue('payor', PayorList, existing, new) {2}
  else if (propName = 'class') then replacePropertyValue('class', Class_List, existing, new) {2}
  else if (propName = 'order') then OrderElement := asPositiveInt(new){5b}
  else if (propName = 'network') then NetworkElement := asString(new){5b}
  else if (propName = 'costToBeneficiary') then replacePropertyValue('costToBeneficiary', CostToBeneficiaryList, existing, new) {2}
  else if (propName = 'subrogation') then SubrogationElement := asBoolean(new){5b}
  else if (propName = 'contract') then replacePropertyValue('contract', ContractList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'payor') then PayorList.move(source, destination){2a}
  else if (propName = 'class') then Class_List.move(source, destination){2a}
  else if (propName = 'costToBeneficiary') then CostToBeneficiaryList.move(source, destination){2a}
  else if (propName = 'contract') then ContractList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverage.fhirType : string;
begin
  result := 'Coverage';
end;

function TFhirCoverage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FPolicyHolder) and isEmptyProp(FSubscriber) and isEmptyProp(FSubscriberId) and isEmptyProp(FBeneficiary) and isEmptyProp(FDependent) and isEmptyProp(FRelationship) and isEmptyProp(FPeriod) and isEmptyProp(FpayorList) and isEmptyProp(Fclass_List) and isEmptyProp(FOrder) and isEmptyProp(FNetwork) and isEmptyProp(FcostToBeneficiaryList) and isEmptyProp(FSubrogation) and isEmptyProp(FcontractList);
end;

function TFhirCoverage.equals(other : TObject) : boolean; 
var
  o : TFhirCoverage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverage)) then
    result := false
  else
  begin
    o := TFhirCoverage(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(policyHolderElement, o.policyHolderElement, true) and 
      compareDeep(subscriberElement, o.subscriberElement, true) and compareDeep(subscriberIdElement, o.subscriberIdElement, true) and 
      compareDeep(beneficiaryElement, o.beneficiaryElement, true) and compareDeep(dependentElement, o.dependentElement, true) and 
      compareDeep(relationshipElement, o.relationshipElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(payorList, o.payorList, true) and compareDeep(class_List, o.class_List, true) and 
      compareDeep(orderElement, o.orderElement, true) and compareDeep(networkElement, o.networkElement, true) and 
      compareDeep(costToBeneficiaryList, o.costToBeneficiaryList, true) and compareDeep(subrogationElement, o.subrogationElement, true) and 
      compareDeep(contractList, o.contractList, true);
  end;
end;

function TFhirCoverage.Link : TFhirCoverage;
begin
  result := TFhirCoverage(inherited Link);
end;

function TFhirCoverage.Clone : TFhirCoverage;
begin
  result := TFhirCoverage(inherited Clone);
end;

procedure TFhirCoverage.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('policyHolder');
  fields.add('subscriber');
  fields.add('subscriberId');
  fields.add('beneficiary');
  fields.add('dependent');
  fields.add('relationship');
  fields.add('period');
  fields.add('payor');
  fields.add('class');
  fields.add('order');
  fields.add('network');
  fields.add('costToBeneficiary');
  fields.add('subrogation');
  fields.add('contract');
end;

{ TFhirCoverage }

Function TFhirCoverage.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirCoverage.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirCoverage.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirCoverage.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirCoverage.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Procedure TFhirCoverage.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirCoverage.SetPolicyHolder(value : TFhirReference{TFhirPatient});
begin
  FPolicyHolder.free;
  FPolicyHolder := value;
end;

Procedure TFhirCoverage.SetSubscriber(value : TFhirReference{TFhirPatient});
begin
  FSubscriber.free;
  FSubscriber := value;
end;

Procedure TFhirCoverage.SetSubscriberId(value : TFhirString);
begin
  FSubscriberId.free;
  FSubscriberId := value;
end;

Function TFhirCoverage.GetSubscriberIdST : String;
begin
  if FSubscriberId = nil then
    result := ''
  else
    result := FSubscriberId.value;
end;

Procedure TFhirCoverage.SetSubscriberIdST(value : String);
begin
  if value <> '' then
  begin
    if FSubscriberId = nil then
      FSubscriberId := TFhirString.create;
    FSubscriberId.value := value
  end
  else if FSubscriberId <> nil then
    FSubscriberId.value := '';
end;

Procedure TFhirCoverage.SetBeneficiary(value : TFhirReference{TFhirPatient});
begin
  FBeneficiary.free;
  FBeneficiary := value;
end;

Procedure TFhirCoverage.SetDependent(value : TFhirString);
begin
  FDependent.free;
  FDependent := value;
end;

Function TFhirCoverage.GetDependentST : String;
begin
  if FDependent = nil then
    result := ''
  else
    result := FDependent.value;
end;

Procedure TFhirCoverage.SetDependentST(value : String);
begin
  if value <> '' then
  begin
    if FDependent = nil then
      FDependent := TFhirString.create;
    FDependent.value := value
  end
  else if FDependent <> nil then
    FDependent.value := '';
end;

Procedure TFhirCoverage.SetRelationship(value : TFhirCodeableConcept);
begin
  FRelationship.free;
  FRelationship := value;
end;

Procedure TFhirCoverage.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Function TFhirCoverage.GetPayorList : TFhirReferenceList{TFhirOrganization};
begin
  if FPayorList = nil then
    FPayorList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FPayorList;
end;

Function TFhirCoverage.GetHasPayorList : boolean;
begin
  result := (FPayorList <> nil) and (FPayorList.count > 0);
end;

Function TFhirCoverage.GetClass_List : TFhirCoverageClassList;
begin
  if FClass_List = nil then
    FClass_List := TFhirCoverageClassList.Create;
  result := FClass_List;
end;

Function TFhirCoverage.GetHasClass_List : boolean;
begin
  result := (FClass_List <> nil) and (FClass_List.count > 0);
end;

Procedure TFhirCoverage.SetOrder(value : TFhirPositiveInt);
begin
  FOrder.free;
  FOrder := value;
end;

Function TFhirCoverage.GetOrderST : String;
begin
  if FOrder = nil then
    result := ''
  else
    result := FOrder.value;
end;

Procedure TFhirCoverage.SetOrderST(value : String);
begin
  if value <> '' then
  begin
    if FOrder = nil then
      FOrder := TFhirPositiveInt.create;
    FOrder.value := value
  end
  else if FOrder <> nil then
    FOrder.value := '';
end;

Procedure TFhirCoverage.SetNetwork(value : TFhirString);
begin
  FNetwork.free;
  FNetwork := value;
end;

Function TFhirCoverage.GetNetworkST : String;
begin
  if FNetwork = nil then
    result := ''
  else
    result := FNetwork.value;
end;

Procedure TFhirCoverage.SetNetworkST(value : String);
begin
  if value <> '' then
  begin
    if FNetwork = nil then
      FNetwork := TFhirString.create;
    FNetwork.value := value
  end
  else if FNetwork <> nil then
    FNetwork.value := '';
end;

Function TFhirCoverage.GetCostToBeneficiaryList : TFhirCoverageCostToBeneficiaryList;
begin
  if FCostToBeneficiaryList = nil then
    FCostToBeneficiaryList := TFhirCoverageCostToBeneficiaryList.Create;
  result := FCostToBeneficiaryList;
end;

Function TFhirCoverage.GetHasCostToBeneficiaryList : boolean;
begin
  result := (FCostToBeneficiaryList <> nil) and (FCostToBeneficiaryList.count > 0);
end;

Procedure TFhirCoverage.SetSubrogation(value : TFhirBoolean);
begin
  FSubrogation.free;
  FSubrogation := value;
end;

Function TFhirCoverage.GetSubrogationST : Boolean;
begin
  if FSubrogation = nil then
    result := false
  else
    result := FSubrogation.value;
end;

Procedure TFhirCoverage.SetSubrogationST(value : Boolean);
begin
  if FSubrogation = nil then
    FSubrogation := TFhirBoolean.create;
  FSubrogation.value := value
end;

Function TFhirCoverage.GetContractList : TFhirReferenceList{TFhirContract};
begin
  if FContractList = nil then
    FContractList := TFhirReferenceList{TFhirContract}.Create;
  result := FContractList;
end;

Function TFhirCoverage.GetHasContractList : boolean;
begin
  result := (FContractList <> nil) and (FContractList.count > 0);
end;

function TFhirCoverage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FPolicyHolder.sizeInBytes);
  inc(result, FSubscriber.sizeInBytes);
  inc(result, FSubscriberId.sizeInBytes);
  inc(result, FBeneficiary.sizeInBytes);
  inc(result, FDependent.sizeInBytes);
  inc(result, FRelationship.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FpayorList.sizeInBytes);
  inc(result, Fclass_List.sizeInBytes);
  inc(result, FOrder.sizeInBytes);
  inc(result, FNetwork.sizeInBytes);
  inc(result, FcostToBeneficiaryList.sizeInBytes);
  inc(result, FSubrogation.sizeInBytes);
  inc(result, FcontractList.sizeInBytes);
end;

{ TFhirCoverageListEnumerator }

Constructor TFhirCoverageListEnumerator.Create(list : TFhirCoverageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageListEnumerator.GetCurrent : TFhirCoverage;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageList }
procedure TFhirCoverageList.AddItem(value: TFhirCoverage);
begin
  assert(value.ClassName = 'TFhirCoverage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverage');
  add(value);
end;

function TFhirCoverageList.Append: TFhirCoverage;
begin
  result := TFhirCoverage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageList.GetEnumerator : TFhirCoverageListEnumerator;
begin
  result := TFhirCoverageListEnumerator.Create(self.link);
end;

function TFhirCoverageList.Clone: TFhirCoverageList;
begin
  result := TFhirCoverageList(inherited Clone);
end;

function TFhirCoverageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageList.GetItemN(index: Integer): TFhirCoverage;
begin
  result := TFhirCoverage(ObjectByIndex[index]);
end;

function TFhirCoverageList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverage;
end;
function TFhirCoverageList.IndexOf(value: TFhirCoverage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageList.Insert(index: Integer): TFhirCoverage;
begin
  result := TFhirCoverage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageList.InsertItem(index: Integer; value: TFhirCoverage);
begin
  assert(value is TFhirCoverage);
  Inherited Insert(index, value);
end;

function TFhirCoverageList.Item(index: Integer): TFhirCoverage;
begin
  result := TFhirCoverage(ObjectByIndex[index]);
end;

function TFhirCoverageList.Link: TFhirCoverageList;
begin
  result := TFhirCoverageList(inherited Link);
end;

procedure TFhirCoverageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageList.SetItemByIndex(index: Integer; value: TFhirCoverage);
begin
  assert(value is TFhirCoverage);
  FhirCoverages[index] := value;
end;

procedure TFhirCoverageList.SetItemN(index: Integer; value: TFhirCoverage);
begin
  assert(value is TFhirCoverage);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COVERAGE}

{$IFDEF FHIR_COVERAGEELIGIBILITYREQUEST}

{ TFhirCoverageEligibilityRequestSupportingInfo }

constructor TFhirCoverageEligibilityRequestSupportingInfo.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityRequestSupportingInfo.Destroy;
begin
  FSequence.free;
  FInformation.free;
  FAppliesToAll.free;
  inherited;
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirCoverageEligibilityRequestSupportingInfo(oSource).sequenceElement.Clone;
  information := TFhirCoverageEligibilityRequestSupportingInfo(oSource).information.Clone;
  appliesToAllElement := TFhirCoverageEligibilityRequestSupportingInfo(oSource).appliesToAllElement.Clone;
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'information') Then
     list.add(self.link, 'information', FInformation.Link);
  if (child_name = 'appliesToAll') Then
     list.add(self.link, 'appliesToAll', FAppliesToAll.Link);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'information', 'Reference(Any)', false, TFhirReference{TFhirReference}, FInformation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'appliesToAll', 'boolean', false, TFhirBoolean, FAppliesToAll.Link));{2}
end;

function TFhirCoverageEligibilityRequestSupportingInfo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'information') then
  begin
    Information := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'appliesToAll') then
  begin
    AppliesToAllElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageEligibilityRequestSupportingInfo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'information') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'appliesToAll') then result := TFhirBoolean.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityRequestSupportingInfo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'information') then result := 'Reference'
  else if (propName = 'appliesToAll') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'information') then InformationElement := nil
  else if (propName = 'appliesToAll') then AppliesToAllElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'information') then InformationElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'appliesToAll') then AppliesToAllElement := asBoolean(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityRequestSupportingInfo.fhirType : string;
begin
  result := 'supportingInfo';
end;

function TFhirCoverageEligibilityRequestSupportingInfo.Link : TFhirCoverageEligibilityRequestSupportingInfo;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo(inherited Link);
end;

function TFhirCoverageEligibilityRequestSupportingInfo.Clone : TFhirCoverageEligibilityRequestSupportingInfo;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo(inherited Clone);
end;

function TFhirCoverageEligibilityRequestSupportingInfo.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityRequestSupportingInfo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityRequestSupportingInfo)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityRequestSupportingInfo(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(informationElement, o.informationElement, true) and 
      compareDeep(appliesToAllElement, o.appliesToAllElement, true);
  end;
end;

function TFhirCoverageEligibilityRequestSupportingInfo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FInformation) and isEmptyProp(FAppliesToAll);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfo.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('information');
  fields.add('appliesToAll');
end;

{ TFhirCoverageEligibilityRequestSupportingInfo }

Procedure TFhirCoverageEligibilityRequestSupportingInfo.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirCoverageEligibilityRequestSupportingInfo.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirCoverageEligibilityRequestSupportingInfo.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirCoverageEligibilityRequestSupportingInfo.SetInformation(value : TFhirReference{TFhirReference});
begin
  FInformation.free;
  FInformation := value;
end;

Procedure TFhirCoverageEligibilityRequestSupportingInfo.SetAppliesToAll(value : TFhirBoolean);
begin
  FAppliesToAll.free;
  FAppliesToAll := value;
end;

Function TFhirCoverageEligibilityRequestSupportingInfo.GetAppliesToAllST : Boolean;
begin
  if FAppliesToAll = nil then
    result := false
  else
    result := FAppliesToAll.value;
end;

Procedure TFhirCoverageEligibilityRequestSupportingInfo.SetAppliesToAllST(value : Boolean);
begin
  if FAppliesToAll = nil then
    FAppliesToAll := TFhirBoolean.create;
  FAppliesToAll.value := value
end;

function TFhirCoverageEligibilityRequestSupportingInfo.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FInformation.sizeInBytes);
  inc(result, FAppliesToAll.sizeInBytes);
end;

{ TFhirCoverageEligibilityRequestSupportingInfoListEnumerator }

Constructor TFhirCoverageEligibilityRequestSupportingInfoListEnumerator.Create(list : TFhirCoverageEligibilityRequestSupportingInfoList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityRequestSupportingInfoListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityRequestSupportingInfoListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityRequestSupportingInfoListEnumerator.GetCurrent : TFhirCoverageEligibilityRequestSupportingInfo;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityRequestSupportingInfoListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageEligibilityRequestSupportingInfoList }
procedure TFhirCoverageEligibilityRequestSupportingInfoList.AddItem(value: TFhirCoverageEligibilityRequestSupportingInfo);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityRequestSupportingInfo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityRequestSupportingInfo');
  add(value);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.Append: TFhirCoverageEligibilityRequestSupportingInfo;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestSupportingInfoList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.GetEnumerator : TFhirCoverageEligibilityRequestSupportingInfoListEnumerator;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfoListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.Clone: TFhirCoverageEligibilityRequestSupportingInfoList;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfoList(inherited Clone);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.GetItemN(index: Integer): TFhirCoverageEligibilityRequestSupportingInfo;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo;
end;
function TFhirCoverageEligibilityRequestSupportingInfoList.IndexOf(value: TFhirCoverageEligibilityRequestSupportingInfo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.Insert(index: Integer): TFhirCoverageEligibilityRequestSupportingInfo;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestSupportingInfoList.InsertItem(index: Integer; value: TFhirCoverageEligibilityRequestSupportingInfo);
begin
  assert(value is TFhirCoverageEligibilityRequestSupportingInfo);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.Item(index: Integer): TFhirCoverageEligibilityRequestSupportingInfo;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfo(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestSupportingInfoList.Link: TFhirCoverageEligibilityRequestSupportingInfoList;
begin
  result := TFhirCoverageEligibilityRequestSupportingInfoList(inherited Link);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfoList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityRequestSupportingInfoList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityRequestSupportingInfo);
begin
  assert(value is TFhirCoverageEligibilityRequestSupportingInfo);
  FhirCoverageEligibilityRequestSupportingInfos[index] := value;
end;

procedure TFhirCoverageEligibilityRequestSupportingInfoList.SetItemN(index: Integer; value: TFhirCoverageEligibilityRequestSupportingInfo);
begin
  assert(value is TFhirCoverageEligibilityRequestSupportingInfo);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityRequestInsurance }

constructor TFhirCoverageEligibilityRequestInsurance.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityRequestInsurance.Destroy;
begin
  FFocal.free;
  FCoverage.free;
  FBusinessArrangement.free;
  inherited;
end;

procedure TFhirCoverageEligibilityRequestInsurance.Assign(oSource : TFslObject);
begin
  inherited;
  focalElement := TFhirCoverageEligibilityRequestInsurance(oSource).focalElement.Clone;
  coverage := TFhirCoverageEligibilityRequestInsurance(oSource).coverage.Clone;
  businessArrangementElement := TFhirCoverageEligibilityRequestInsurance(oSource).businessArrangementElement.Clone;
end;

procedure TFhirCoverageEligibilityRequestInsurance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'focal') Then
     list.add(self.link, 'focal', FFocal.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'businessArrangement') Then
     list.add(self.link, 'businessArrangement', FBusinessArrangement.Link);
end;

procedure TFhirCoverageEligibilityRequestInsurance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'focal', 'boolean', false, TFhirBoolean, FFocal.Link));{2}
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference(Coverage)', false, TFhirReference{TFhirCoverage}, FCoverage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'businessArrangement', 'string', false, TFhirString, FBusinessArrangement.Link));{2}
end;

function TFhirCoverageEligibilityRequestInsurance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'focal') then
  begin
    FocalElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference{TFhirCoverage}{4b};
    result := propValue;
  end
  else if (propName = 'businessArrangement') then
  begin
    BusinessArrangementElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityRequestInsurance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageEligibilityRequestInsurance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'focal') then result := TFhirBoolean.create() {5b}
  else if (propName = 'coverage') then result := TFhirReference{TFhirCoverage}.create(){4b}
  else if (propName = 'businessArrangement') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityRequestInsurance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'focal') then result := 'boolean'
  else if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'businessArrangement') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityRequestInsurance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'focal') then FocalElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'businessArrangement') then BusinessArrangementElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityRequestInsurance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'focal') then FocalElement := asBoolean(new){5b}
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference{TFhirCoverage}{4}
  else if (propName = 'businessArrangement') then BusinessArrangementElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityRequestInsurance.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityRequestInsurance.fhirType : string;
begin
  result := 'insurance';
end;

function TFhirCoverageEligibilityRequestInsurance.Link : TFhirCoverageEligibilityRequestInsurance;
begin
  result := TFhirCoverageEligibilityRequestInsurance(inherited Link);
end;

function TFhirCoverageEligibilityRequestInsurance.Clone : TFhirCoverageEligibilityRequestInsurance;
begin
  result := TFhirCoverageEligibilityRequestInsurance(inherited Clone);
end;

function TFhirCoverageEligibilityRequestInsurance.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityRequestInsurance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityRequestInsurance)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityRequestInsurance(other);
    result := compareDeep(focalElement, o.focalElement, true) and compareDeep(coverageElement, o.coverageElement, true) and 
      compareDeep(businessArrangementElement, o.businessArrangementElement, true);
  end;
end;

function TFhirCoverageEligibilityRequestInsurance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFocal) and isEmptyProp(FCoverage) and isEmptyProp(FBusinessArrangement);
end;

procedure TFhirCoverageEligibilityRequestInsurance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('focal');
  fields.add('coverage');
  fields.add('businessArrangement');
end;

{ TFhirCoverageEligibilityRequestInsurance }

Procedure TFhirCoverageEligibilityRequestInsurance.SetFocal(value : TFhirBoolean);
begin
  FFocal.free;
  FFocal := value;
end;

Function TFhirCoverageEligibilityRequestInsurance.GetFocalST : Boolean;
begin
  if FFocal = nil then
    result := false
  else
    result := FFocal.value;
end;

Procedure TFhirCoverageEligibilityRequestInsurance.SetFocalST(value : Boolean);
begin
  if FFocal = nil then
    FFocal := TFhirBoolean.create;
  FFocal.value := value
end;

Procedure TFhirCoverageEligibilityRequestInsurance.SetCoverage(value : TFhirReference{TFhirCoverage});
begin
  FCoverage.free;
  FCoverage := value;
end;

Procedure TFhirCoverageEligibilityRequestInsurance.SetBusinessArrangement(value : TFhirString);
begin
  FBusinessArrangement.free;
  FBusinessArrangement := value;
end;

Function TFhirCoverageEligibilityRequestInsurance.GetBusinessArrangementST : String;
begin
  if FBusinessArrangement = nil then
    result := ''
  else
    result := FBusinessArrangement.value;
end;

Procedure TFhirCoverageEligibilityRequestInsurance.SetBusinessArrangementST(value : String);
begin
  if value <> '' then
  begin
    if FBusinessArrangement = nil then
      FBusinessArrangement := TFhirString.create;
    FBusinessArrangement.value := value
  end
  else if FBusinessArrangement <> nil then
    FBusinessArrangement.value := '';
end;

function TFhirCoverageEligibilityRequestInsurance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FFocal.sizeInBytes);
  inc(result, FCoverage.sizeInBytes);
  inc(result, FBusinessArrangement.sizeInBytes);
end;

{ TFhirCoverageEligibilityRequestInsuranceListEnumerator }

Constructor TFhirCoverageEligibilityRequestInsuranceListEnumerator.Create(list : TFhirCoverageEligibilityRequestInsuranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityRequestInsuranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityRequestInsuranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityRequestInsuranceListEnumerator.GetCurrent : TFhirCoverageEligibilityRequestInsurance;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityRequestInsuranceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageEligibilityRequestInsuranceList }
procedure TFhirCoverageEligibilityRequestInsuranceList.AddItem(value: TFhirCoverageEligibilityRequestInsurance);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityRequestInsurance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityRequestInsurance');
  add(value);
end;

function TFhirCoverageEligibilityRequestInsuranceList.Append: TFhirCoverageEligibilityRequestInsurance;
begin
  result := TFhirCoverageEligibilityRequestInsurance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestInsuranceList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityRequestInsuranceList.GetEnumerator : TFhirCoverageEligibilityRequestInsuranceListEnumerator;
begin
  result := TFhirCoverageEligibilityRequestInsuranceListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityRequestInsuranceList.Clone: TFhirCoverageEligibilityRequestInsuranceList;
begin
  result := TFhirCoverageEligibilityRequestInsuranceList(inherited Clone);
end;

function TFhirCoverageEligibilityRequestInsuranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityRequestInsuranceList.GetItemN(index: Integer): TFhirCoverageEligibilityRequestInsurance;
begin
  result := TFhirCoverageEligibilityRequestInsurance(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestInsuranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityRequestInsurance;
end;
function TFhirCoverageEligibilityRequestInsuranceList.IndexOf(value: TFhirCoverageEligibilityRequestInsurance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityRequestInsuranceList.Insert(index: Integer): TFhirCoverageEligibilityRequestInsurance;
begin
  result := TFhirCoverageEligibilityRequestInsurance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestInsuranceList.InsertItem(index: Integer; value: TFhirCoverageEligibilityRequestInsurance);
begin
  assert(value is TFhirCoverageEligibilityRequestInsurance);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityRequestInsuranceList.Item(index: Integer): TFhirCoverageEligibilityRequestInsurance;
begin
  result := TFhirCoverageEligibilityRequestInsurance(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestInsuranceList.Link: TFhirCoverageEligibilityRequestInsuranceList;
begin
  result := TFhirCoverageEligibilityRequestInsuranceList(inherited Link);
end;

procedure TFhirCoverageEligibilityRequestInsuranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityRequestInsuranceList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityRequestInsurance);
begin
  assert(value is TFhirCoverageEligibilityRequestInsurance);
  FhirCoverageEligibilityRequestInsurances[index] := value;
end;

procedure TFhirCoverageEligibilityRequestInsuranceList.SetItemN(index: Integer; value: TFhirCoverageEligibilityRequestInsurance);
begin
  assert(value is TFhirCoverageEligibilityRequestInsurance);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityRequestItem }

constructor TFhirCoverageEligibilityRequestItem.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityRequestItem.Destroy;
begin
  FSupportingInfoSequenceList.Free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProvider.free;
  FQuantity.free;
  FUnitPrice.free;
  FFacility.free;
  FDiagnosisList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirCoverageEligibilityRequestItem.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCoverageEligibilityRequestItem(oSource).FSupportingInfoSequenceList = nil) then
  begin
    FSupportingInfoSequenceList.free;
    FSupportingInfoSequenceList := nil;
  end
  else
  begin
    if FSupportingInfoSequenceList = nil then
      FSupportingInfoSequenceList := TFhirPositiveIntList.Create;
    FSupportingInfoSequenceList.Assign(TFhirCoverageEligibilityRequestItem(oSource).FSupportingInfoSequenceList);
  end;
  category := TFhirCoverageEligibilityRequestItem(oSource).category.Clone;
  productOrService := TFhirCoverageEligibilityRequestItem(oSource).productOrService.Clone;
  if (TFhirCoverageEligibilityRequestItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirCoverageEligibilityRequestItem(oSource).FModifierList);
  end;
  provider := TFhirCoverageEligibilityRequestItem(oSource).provider.Clone;
  quantity := TFhirCoverageEligibilityRequestItem(oSource).quantity.Clone;
  unitPrice := TFhirCoverageEligibilityRequestItem(oSource).unitPrice.Clone;
  facility := TFhirCoverageEligibilityRequestItem(oSource).facility.Clone;
  if (TFhirCoverageEligibilityRequestItem(oSource).FDiagnosisList = nil) then
  begin
    FDiagnosisList.free;
    FDiagnosisList := nil;
  end
  else
  begin
    if FDiagnosisList = nil then
      FDiagnosisList := TFhirCoverageEligibilityRequestItemDiagnosisList.Create;
    FDiagnosisList.Assign(TFhirCoverageEligibilityRequestItem(oSource).FDiagnosisList);
  end;
  if (TFhirCoverageEligibilityRequestItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirReferenceList{TFhirReference}.Create;
    FDetailList.Assign(TFhirCoverageEligibilityRequestItem(oSource).FDetailList);
  end;
end;

procedure TFhirCoverageEligibilityRequestItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'supportingInfoSequence') Then
    list.addAll(self, 'supportingInfoSequence', FSupportingInfoSequenceList);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'facility') Then
     list.add(self.link, 'facility', FFacility.Link);
  if (child_name = 'diagnosis') Then
    list.addAll(self, 'diagnosis', FDiagnosisList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirCoverageEligibilityRequestItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'supportingInfoSequence', 'positiveInt', true, TFhirPositiveInt, FSupportingInfoSequenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'facility', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FFacility.Link));{2}
  oList.add(TFHIRProperty.create(self, 'diagnosis', '', true, TFhirCoverageEligibilityRequestItemDiagnosis, FDiagnosisList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'detail', 'Reference(Any)', true, TFhirReference{TFhirReference}, FDetailList.Link)){3};
end;

function TFhirCoverageEligibilityRequestItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'supportingInfoSequence') then
  begin
    SupportingInfoSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'facility') then
  begin
    Facility := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'diagnosis') then
  begin
    DiagnosisList.add(propValue as TFhirCoverageEligibilityRequestItemDiagnosis){2a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityRequestItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'supportingInfoSequence') then SupportingInfoSequenceList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'diagnosis') then DiagnosisList.insertItem(index, propValue as TFhirCoverageEligibilityRequestItemDiagnosis){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else inherited;
end;

function TFhirCoverageEligibilityRequestItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'supportingInfoSequence') then result := SupportingInfoSequenceList.new(){2}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'facility') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'diagnosis') then result := DiagnosisList.new(){2}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityRequestItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'supportingInfoSequence') then result := 'positiveInt'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'facility') then result := 'Reference'
  else if (propName = 'diagnosis') then result := ''
  else if (propName = 'detail') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityRequestItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'supportingInfoSequence') then deletePropertyValue('supportingInfoSequence', SupportingInfoSequenceList, value) {2}
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'facility') then FacilityElement := nil
  else if (propName = 'diagnosis') then deletePropertyValue('diagnosis', DiagnosisList, value) {2}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityRequestItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'supportingInfoSequence') then replacePropertyValue('supportingInfoSequence', SupportingInfoSequenceList, existing, new) {2}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'facility') then FacilityElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'diagnosis') then replacePropertyValue('diagnosis', DiagnosisList, existing, new) {2}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityRequestItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'supportingInfoSequence') then SupportingInfoSequenceList.move(source, destination){2}
  else if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'diagnosis') then DiagnosisList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityRequestItem.fhirType : string;
begin
  result := 'item';
end;

function TFhirCoverageEligibilityRequestItem.Link : TFhirCoverageEligibilityRequestItem;
begin
  result := TFhirCoverageEligibilityRequestItem(inherited Link);
end;

function TFhirCoverageEligibilityRequestItem.Clone : TFhirCoverageEligibilityRequestItem;
begin
  result := TFhirCoverageEligibilityRequestItem(inherited Clone);
end;

function TFhirCoverageEligibilityRequestItem.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityRequestItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityRequestItem)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityRequestItem(other);
    result := compareDeep(supportingInfoSequenceList, o.supportingInfoSequenceList, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(providerElement, o.providerElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(facilityElement, o.facilityElement, true) and compareDeep(diagnosisList, o.diagnosisList, true) and 
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirCoverageEligibilityRequestItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FsupportingInfoSequenceList) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FProvider) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFacility) and isEmptyProp(FdiagnosisList) and isEmptyProp(FdetailList);
end;

procedure TFhirCoverageEligibilityRequestItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('supportingInfoSequence');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('provider');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('facility');
  fields.add('diagnosis');
  fields.add('detail');
end;

{ TFhirCoverageEligibilityRequestItem }

Function TFhirCoverageEligibilityRequestItem.GetSupportingInfoSequenceList : TFhirPositiveIntList;
begin
  if FSupportingInfoSequenceList = nil then
    FSupportingInfoSequenceList := TFhirPositiveIntList.Create;
  result := FSupportingInfoSequenceList;
end;

Function TFhirCoverageEligibilityRequestItem.GetHasSupportingInfoSequenceList : boolean;
begin
  result := (FSupportingInfoSequenceList <> nil) and (FSupportingInfoSequenceList.count > 0);
end;

Procedure TFhirCoverageEligibilityRequestItem.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirCoverageEligibilityRequestItem.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

Function TFhirCoverageEligibilityRequestItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirCoverageEligibilityRequestItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Procedure TFhirCoverageEligibilityRequestItem.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirCoverageEligibilityRequestItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirCoverageEligibilityRequestItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirCoverageEligibilityRequestItem.SetFacility(value : TFhirReference{TFhirLocation});
begin
  FFacility.free;
  FFacility := value;
end;

Function TFhirCoverageEligibilityRequestItem.GetDiagnosisList : TFhirCoverageEligibilityRequestItemDiagnosisList;
begin
  if FDiagnosisList = nil then
    FDiagnosisList := TFhirCoverageEligibilityRequestItemDiagnosisList.Create;
  result := FDiagnosisList;
end;

Function TFhirCoverageEligibilityRequestItem.GetHasDiagnosisList : boolean;
begin
  result := (FDiagnosisList <> nil) and (FDiagnosisList.count > 0);
end;

Function TFhirCoverageEligibilityRequestItem.GetDetailList : TFhirReferenceList{TFhirReference};
begin
  if FDetailList = nil then
    FDetailList := TFhirReferenceList{TFhirReference}.Create;
  result := FDetailList;
end;

Function TFhirCoverageEligibilityRequestItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirCoverageEligibilityRequestItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FsupportingInfoSequenceList.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFacility.sizeInBytes);
  inc(result, FdiagnosisList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirCoverageEligibilityRequestItemListEnumerator }

Constructor TFhirCoverageEligibilityRequestItemListEnumerator.Create(list : TFhirCoverageEligibilityRequestItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityRequestItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityRequestItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityRequestItemListEnumerator.GetCurrent : TFhirCoverageEligibilityRequestItem;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityRequestItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageEligibilityRequestItemList }
procedure TFhirCoverageEligibilityRequestItemList.AddItem(value: TFhirCoverageEligibilityRequestItem);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityRequestItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityRequestItem');
  add(value);
end;

function TFhirCoverageEligibilityRequestItemList.Append: TFhirCoverageEligibilityRequestItem;
begin
  result := TFhirCoverageEligibilityRequestItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestItemList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityRequestItemList.GetEnumerator : TFhirCoverageEligibilityRequestItemListEnumerator;
begin
  result := TFhirCoverageEligibilityRequestItemListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityRequestItemList.Clone: TFhirCoverageEligibilityRequestItemList;
begin
  result := TFhirCoverageEligibilityRequestItemList(inherited Clone);
end;

function TFhirCoverageEligibilityRequestItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityRequestItemList.GetItemN(index: Integer): TFhirCoverageEligibilityRequestItem;
begin
  result := TFhirCoverageEligibilityRequestItem(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityRequestItem;
end;
function TFhirCoverageEligibilityRequestItemList.IndexOf(value: TFhirCoverageEligibilityRequestItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityRequestItemList.Insert(index: Integer): TFhirCoverageEligibilityRequestItem;
begin
  result := TFhirCoverageEligibilityRequestItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestItemList.InsertItem(index: Integer; value: TFhirCoverageEligibilityRequestItem);
begin
  assert(value is TFhirCoverageEligibilityRequestItem);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityRequestItemList.Item(index: Integer): TFhirCoverageEligibilityRequestItem;
begin
  result := TFhirCoverageEligibilityRequestItem(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestItemList.Link: TFhirCoverageEligibilityRequestItemList;
begin
  result := TFhirCoverageEligibilityRequestItemList(inherited Link);
end;

procedure TFhirCoverageEligibilityRequestItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityRequestItemList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityRequestItem);
begin
  assert(value is TFhirCoverageEligibilityRequestItem);
  FhirCoverageEligibilityRequestItems[index] := value;
end;

procedure TFhirCoverageEligibilityRequestItemList.SetItemN(index: Integer; value: TFhirCoverageEligibilityRequestItem);
begin
  assert(value is TFhirCoverageEligibilityRequestItem);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityRequestItemDiagnosis }

constructor TFhirCoverageEligibilityRequestItemDiagnosis.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityRequestItemDiagnosis.Destroy;
begin
  FDiagnosis.free;
  inherited;
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.Assign(oSource : TFslObject);
begin
  inherited;
  diagnosis := TFhirCoverageEligibilityRequestItemDiagnosis(oSource).diagnosis.Clone;
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'diagnosis[x]') or (child_name = 'diagnosis') Then
     list.add(self.link, 'diagnosis[x]', FDiagnosis.Link);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'diagnosis[x]', 'CodeableConcept|Reference(Condition)', false, TFhirType, FDiagnosis.Link));{2}
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then
  begin
    Diagnosis := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Diagnosis'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'diagnosis[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.fhirType : string;
begin
  result := 'diagnosis';
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.Link : TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis(inherited Link);
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.Clone : TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis(inherited Clone);
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityRequestItemDiagnosis)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityRequestItemDiagnosis(other);
    result := compareDeep(diagnosisElement, o.diagnosisElement, true);
  end;
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDiagnosis);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosis.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('diagnosis[x]');
end;

{ TFhirCoverageEligibilityRequestItemDiagnosis }

Procedure TFhirCoverageEligibilityRequestItemDiagnosis.SetDiagnosis(value : TFhirType);
begin
  FDiagnosis.free;
  FDiagnosis := value;
end;

function TFhirCoverageEligibilityRequestItemDiagnosis.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDiagnosis.sizeInBytes);
end;

{ TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator }

Constructor TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator.Create(list : TFhirCoverageEligibilityRequestItemDiagnosisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator.GetCurrent : TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageEligibilityRequestItemDiagnosisList }
procedure TFhirCoverageEligibilityRequestItemDiagnosisList.AddItem(value: TFhirCoverageEligibilityRequestItemDiagnosis);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityRequestItemDiagnosis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityRequestItemDiagnosis');
  add(value);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.Append: TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosisList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.GetEnumerator : TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosisListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.Clone: TFhirCoverageEligibilityRequestItemDiagnosisList;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosisList(inherited Clone);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.GetItemN(index: Integer): TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis;
end;
function TFhirCoverageEligibilityRequestItemDiagnosisList.IndexOf(value: TFhirCoverageEligibilityRequestItemDiagnosis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.Insert(index: Integer): TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosisList.InsertItem(index: Integer; value: TFhirCoverageEligibilityRequestItemDiagnosis);
begin
  assert(value is TFhirCoverageEligibilityRequestItemDiagnosis);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.Item(index: Integer): TFhirCoverageEligibilityRequestItemDiagnosis;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosis(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestItemDiagnosisList.Link: TFhirCoverageEligibilityRequestItemDiagnosisList;
begin
  result := TFhirCoverageEligibilityRequestItemDiagnosisList(inherited Link);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosisList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityRequestItemDiagnosis);
begin
  assert(value is TFhirCoverageEligibilityRequestItemDiagnosis);
  FhirCoverageEligibilityRequestItemDiagnoses[index] := value;
end;

procedure TFhirCoverageEligibilityRequestItemDiagnosisList.SetItemN(index: Integer; value: TFhirCoverageEligibilityRequestItemDiagnosis);
begin
  assert(value is TFhirCoverageEligibilityRequestItemDiagnosis);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityRequest }

constructor TFhirCoverageEligibilityRequest.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityRequest.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FPriority.free;
  FPurpose.Free;
  FPatient.free;
  FServiced.free;
  FCreated.free;
  FEnterer.free;
  FProvider.free;
  FInsurer.free;
  FFacility.free;
  FSupportingInfoList.Free;
  FInsuranceList.Free;
  FItemList.Free;
  inherited;
end;

function TFhirCoverageEligibilityRequest.GetResourceType : TFhirResourceType;
begin
  result := frtCoverageEligibilityRequest;
end;

procedure TFhirCoverageEligibilityRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCoverageEligibilityRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCoverageEligibilityRequest(oSource).FIdentifierList);
  end;
  FStatus := TFhirCoverageEligibilityRequest(oSource).FStatus.Link;
  priority := TFhirCoverageEligibilityRequest(oSource).priority.Clone;
  if (TFhirCoverageEligibilityRequest(oSource).FPurpose = nil) then
  begin
    FPurpose.free;
    FPurpose := nil;
  end
  else
  begin
    FPurpose := TFHIREnumList.Create(SYSTEMS_TFhirEligibilityrequestPurposeEnum, CODES_TFhirEligibilityrequestPurposeEnum);
    FPurpose.Assign(TFhirCoverageEligibilityRequest(oSource).FPurpose);
  end;
  patient := TFhirCoverageEligibilityRequest(oSource).patient.Clone;
  serviced := TFhirCoverageEligibilityRequest(oSource).serviced.Clone;
  createdElement := TFhirCoverageEligibilityRequest(oSource).createdElement.Clone;
  enterer := TFhirCoverageEligibilityRequest(oSource).enterer.Clone;
  provider := TFhirCoverageEligibilityRequest(oSource).provider.Clone;
  insurer := TFhirCoverageEligibilityRequest(oSource).insurer.Clone;
  facility := TFhirCoverageEligibilityRequest(oSource).facility.Clone;
  if (TFhirCoverageEligibilityRequest(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirCoverageEligibilityRequestSupportingInfoList.Create;
    FSupportingInfoList.Assign(TFhirCoverageEligibilityRequest(oSource).FSupportingInfoList);
  end;
  if (TFhirCoverageEligibilityRequest(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirCoverageEligibilityRequestInsuranceList.Create;
    FInsuranceList.Assign(TFhirCoverageEligibilityRequest(oSource).FInsuranceList);
  end;
  if (TFhirCoverageEligibilityRequest(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirCoverageEligibilityRequestItemList.Create;
    FItemList.Assign(TFhirCoverageEligibilityRequest(oSource).FItemList);
  end;
end;

procedure TFhirCoverageEligibilityRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'purpose') Then
     list.addAll(self, 'purpose', FPurpose);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'facility') Then
     list.add(self.link, 'facility', FFacility.Link);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirCoverageEligibilityRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'purpose', 'code', true, TFHIREnum, FPurpose.Link)){3};
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirType, FServiced.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FEnterer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FInsurer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'facility', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FFacility.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supportingInfo', '', true, TFhirCoverageEligibilityRequestSupportingInfo, FSupportingInfoList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'insurance', '', true, TFhirCoverageEligibilityRequestInsurance, FInsuranceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirCoverageEligibilityRequestItem, FItemList.Link)){3};
end;

function TFhirCoverageEligibilityRequest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeList.add(asEnum(SYSTEMS_TFhirEligibilityrequestPurposeEnum, CODES_TFhirEligibilityrequestPurposeEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'facility') then
  begin
    Facility := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirCoverageEligibilityRequestSupportingInfo){2a};
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirCoverageEligibilityRequestInsurance){2a};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirCoverageEligibilityRequestItem){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirCoverageEligibilityRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'purpose') then FPurpose.insertItem(index, asEnum(SYSTEMS_TFhirEligibilityrequestPurposeEnum, CODES_TFhirEligibilityrequestPurposeEnum, propValue)) {1}
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirCoverageEligibilityRequestSupportingInfo){2a}
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirCoverageEligibilityRequestInsurance){2a}
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirCoverageEligibilityRequestItem){2a}
  else inherited;
end;

function TFhirCoverageEligibilityRequest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'priority') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced'){4x}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'enterer') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'insurer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'facility') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new(){2}
  else if (propName = 'insurance') then result := InsuranceList.new(){2}
  else if (propName = 'item') then result := ItemList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'facility') then result := 'Reference'
  else if (propName = 'supportingInfo') then result := ''
  else if (propName = 'insurance') then result := ''
  else if (propName = 'item') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityRequest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil{4x}
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'facility') then FacilityElement := nil
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value) {2}
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value) {2}
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept{4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirType{4x}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'enterer') then EntererElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'facility') then FacilityElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new) {2}
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new) {2}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'purpose') then FPurpose.move(source, destination) {1}
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination){2a}
  else if (propName = 'insurance') then InsuranceList.move(source, destination){2a}
  else if (propName = 'item') then ItemList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityRequest.fhirType : string;
begin
  result := 'CoverageEligibilityRequest';
end;

function TFhirCoverageEligibilityRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FPriority) and isEmptyProp(FPurpose) and isEmptyProp(FPatient) and isEmptyProp(FServiced) and isEmptyProp(FCreated) and isEmptyProp(FEnterer) and isEmptyProp(FProvider) and isEmptyProp(FInsurer) and isEmptyProp(FFacility) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FinsuranceList) and isEmptyProp(FitemList);
end;

function TFhirCoverageEligibilityRequest.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityRequest)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(purposeList, o.purposeList, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(servicedElement, o.servicedElement, true) and 
      compareDeep(createdElement, o.createdElement, true) and compareDeep(entererElement, o.entererElement, true) and 
      compareDeep(providerElement, o.providerElement, true) and compareDeep(insurerElement, o.insurerElement, true) and 
      compareDeep(facilityElement, o.facilityElement, true) and compareDeep(supportingInfoList, o.supportingInfoList, true) and 
      compareDeep(insuranceList, o.insuranceList, true) and compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirCoverageEligibilityRequest.Link : TFhirCoverageEligibilityRequest;
begin
  result := TFhirCoverageEligibilityRequest(inherited Link);
end;

function TFhirCoverageEligibilityRequest.Clone : TFhirCoverageEligibilityRequest;
begin
  result := TFhirCoverageEligibilityRequest(inherited Clone);
end;

procedure TFhirCoverageEligibilityRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('priority');
  fields.add('purpose');
  fields.add('patient');
  fields.add('serviced[x]');
  fields.add('created');
  fields.add('enterer');
  fields.add('provider');
  fields.add('insurer');
  fields.add('facility');
  fields.add('supportingInfo');
  fields.add('insurance');
  fields.add('item');
end;

{ TFhirCoverageEligibilityRequest }

Function TFhirCoverageEligibilityRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirCoverageEligibilityRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirCoverageEligibilityRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirCoverageEligibilityRequest.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirCoverageEligibilityRequest.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Procedure TFhirCoverageEligibilityRequest.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value;
end;

Function TFhirCoverageEligibilityRequest.GetPurpose : TFhirEnumList;
begin
  if FPurpose = nil then
    FPurpose := TFHIREnumList.Create(SYSTEMS_TFhirEligibilityrequestPurposeEnum, CODES_TFhirEligibilityrequestPurposeEnum);
  result := FPurpose;
end;

Function TFhirCoverageEligibilityRequest.GetHasPurpose : boolean;
begin
  result := (FPurpose <> nil) and (FPurpose.count > 0);
end;

Function TFhirCoverageEligibilityRequest.GetPurposeST : TFhirEligibilityrequestPurposeEnumList;
  var i : integer;
begin
  result := [];
  if Fpurpose <> nil then
    for i := 0 to Fpurpose.count - 1 do
      result := result + [TFhirEligibilityrequestPurposeEnum(StringArrayIndexOfSensitive(CODES_TFhirEligibilityrequestPurposeEnum, Fpurpose[i].value))];
end;

Procedure TFhirCoverageEligibilityRequest.SetPurposeST(value : TFhirEligibilityrequestPurposeEnumList);
var a : TFhirEligibilityrequestPurposeEnum;
begin
  if Fpurpose = nil then
    Fpurpose := TFhirEnumList.create(SYSTEMS_TFhirEligibilityrequestPurposeEnum, CODES_TFhirEligibilityrequestPurposeEnum);
  Fpurpose.clear;
  for a := low(TFhirEligibilityrequestPurposeEnum) to high(TFhirEligibilityrequestPurposeEnum) do
    if a in value then
      begin
         if Fpurpose = nil then
           Fpurpose := TFhirEnumList.create(SYSTEMS_TFhirEligibilityrequestPurposeEnum, CODES_TFhirEligibilityrequestPurposeEnum);
         Fpurpose.add(TFhirEnum.create(SYSTEMS_TFhirEligibilityrequestPurposeEnum[a], CODES_TFhirEligibilityrequestPurposeEnum[a]));
      end;
end;

Procedure TFhirCoverageEligibilityRequest.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirCoverageEligibilityRequest.SetServiced(value : TFhirType);
begin
  FServiced.free;
  FServiced := value;
end;

Procedure TFhirCoverageEligibilityRequest.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirCoverageEligibilityRequest.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirCoverageEligibilityRequest.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirCoverageEligibilityRequest.SetEnterer(value : TFhirReference{TFhirPractitioner});
begin
  FEnterer.free;
  FEnterer := value;
end;

Procedure TFhirCoverageEligibilityRequest.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirCoverageEligibilityRequest.SetInsurer(value : TFhirReference{TFhirOrganization});
begin
  FInsurer.free;
  FInsurer := value;
end;

Procedure TFhirCoverageEligibilityRequest.SetFacility(value : TFhirReference{TFhirLocation});
begin
  FFacility.free;
  FFacility := value;
end;

Function TFhirCoverageEligibilityRequest.GetSupportingInfoList : TFhirCoverageEligibilityRequestSupportingInfoList;
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirCoverageEligibilityRequestSupportingInfoList.Create;
  result := FSupportingInfoList;
end;

Function TFhirCoverageEligibilityRequest.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

Function TFhirCoverageEligibilityRequest.GetInsuranceList : TFhirCoverageEligibilityRequestInsuranceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirCoverageEligibilityRequestInsuranceList.Create;
  result := FInsuranceList;
end;

Function TFhirCoverageEligibilityRequest.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

Function TFhirCoverageEligibilityRequest.GetItemList : TFhirCoverageEligibilityRequestItemList;
begin
  if FItemList = nil then
    FItemList := TFhirCoverageEligibilityRequestItemList.Create;
  result := FItemList;
end;

Function TFhirCoverageEligibilityRequest.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

function TFhirCoverageEligibilityRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FPurpose.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FServiced.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FEnterer.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FInsurer.sizeInBytes);
  inc(result, FFacility.sizeInBytes);
  inc(result, FsupportingInfoList.sizeInBytes);
  inc(result, FinsuranceList.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
end;

{ TFhirCoverageEligibilityRequestListEnumerator }

Constructor TFhirCoverageEligibilityRequestListEnumerator.Create(list : TFhirCoverageEligibilityRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityRequestListEnumerator.GetCurrent : TFhirCoverageEligibilityRequest;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageEligibilityRequestList }
procedure TFhirCoverageEligibilityRequestList.AddItem(value: TFhirCoverageEligibilityRequest);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityRequest');
  add(value);
end;

function TFhirCoverageEligibilityRequestList.Append: TFhirCoverageEligibilityRequest;
begin
  result := TFhirCoverageEligibilityRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityRequestList.GetEnumerator : TFhirCoverageEligibilityRequestListEnumerator;
begin
  result := TFhirCoverageEligibilityRequestListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityRequestList.Clone: TFhirCoverageEligibilityRequestList;
begin
  result := TFhirCoverageEligibilityRequestList(inherited Clone);
end;

function TFhirCoverageEligibilityRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityRequestList.GetItemN(index: Integer): TFhirCoverageEligibilityRequest;
begin
  result := TFhirCoverageEligibilityRequest(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityRequest;
end;
function TFhirCoverageEligibilityRequestList.IndexOf(value: TFhirCoverageEligibilityRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityRequestList.Insert(index: Integer): TFhirCoverageEligibilityRequest;
begin
  result := TFhirCoverageEligibilityRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityRequestList.InsertItem(index: Integer; value: TFhirCoverageEligibilityRequest);
begin
  assert(value is TFhirCoverageEligibilityRequest);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityRequestList.Item(index: Integer): TFhirCoverageEligibilityRequest;
begin
  result := TFhirCoverageEligibilityRequest(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityRequestList.Link: TFhirCoverageEligibilityRequestList;
begin
  result := TFhirCoverageEligibilityRequestList(inherited Link);
end;

procedure TFhirCoverageEligibilityRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityRequestList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityRequest);
begin
  assert(value is TFhirCoverageEligibilityRequest);
  FhirCoverageEligibilityRequests[index] := value;
end;

procedure TFhirCoverageEligibilityRequestList.SetItemN(index: Integer; value: TFhirCoverageEligibilityRequest);
begin
  assert(value is TFhirCoverageEligibilityRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COVERAGEELIGIBILITYREQUEST}

{$IFDEF FHIR_COVERAGEELIGIBILITYRESPONSE}

{ TFhirCoverageEligibilityResponseInsurance }

constructor TFhirCoverageEligibilityResponseInsurance.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityResponseInsurance.Destroy;
begin
  FCoverage.free;
  FInforce.free;
  FBenefitPeriod.free;
  FItemList.Free;
  inherited;
end;

procedure TFhirCoverageEligibilityResponseInsurance.Assign(oSource : TFslObject);
begin
  inherited;
  coverage := TFhirCoverageEligibilityResponseInsurance(oSource).coverage.Clone;
  inforceElement := TFhirCoverageEligibilityResponseInsurance(oSource).inforceElement.Clone;
  benefitPeriod := TFhirCoverageEligibilityResponseInsurance(oSource).benefitPeriod.Clone;
  if (TFhirCoverageEligibilityResponseInsurance(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirCoverageEligibilityResponseInsuranceItemList.Create;
    FItemList.Assign(TFhirCoverageEligibilityResponseInsurance(oSource).FItemList);
  end;
end;

procedure TFhirCoverageEligibilityResponseInsurance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'inforce') Then
     list.add(self.link, 'inforce', FInforce.Link);
  if (child_name = 'benefitPeriod') Then
     list.add(self.link, 'benefitPeriod', FBenefitPeriod.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirCoverageEligibilityResponseInsurance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference(Coverage)', false, TFhirReference{TFhirCoverage}, FCoverage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'inforce', 'boolean', false, TFhirBoolean, FInforce.Link));{2}
  oList.add(TFHIRProperty.create(self, 'benefitPeriod', 'Period', false, TFhirPeriod, FBenefitPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirCoverageEligibilityResponseInsuranceItem, FItemList.Link)){3};
end;

function TFhirCoverageEligibilityResponseInsurance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference{TFhirCoverage}{4b};
    result := propValue;
  end
  else if (propName = 'inforce') then
  begin
    InforceElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'benefitPeriod') then
  begin
    BenefitPeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirCoverageEligibilityResponseInsuranceItem){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityResponseInsurance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirCoverageEligibilityResponseInsuranceItem){2a}
  else inherited;
end;

function TFhirCoverageEligibilityResponseInsurance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'coverage') then result := TFhirReference{TFhirCoverage}.create(){4b}
  else if (propName = 'inforce') then result := TFhirBoolean.create() {5b}
  else if (propName = 'benefitPeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'item') then result := ItemList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityResponseInsurance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'inforce') then result := 'boolean'
  else if (propName = 'benefitPeriod') then result := 'Period'
  else if (propName = 'item') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityResponseInsurance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'inforce') then InforceElement := nil
  else if (propName = 'benefitPeriod') then BenefitPeriodElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityResponseInsurance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'coverage') then CoverageElement := new as TFhirReference{TFhirCoverage}{4}
  else if (propName = 'inforce') then InforceElement := asBoolean(new){5b}
  else if (propName = 'benefitPeriod') then BenefitPeriodElement := new as TFhirPeriod{4}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityResponseInsurance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'item') then ItemList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityResponseInsurance.fhirType : string;
begin
  result := 'insurance';
end;

function TFhirCoverageEligibilityResponseInsurance.Link : TFhirCoverageEligibilityResponseInsurance;
begin
  result := TFhirCoverageEligibilityResponseInsurance(inherited Link);
end;

function TFhirCoverageEligibilityResponseInsurance.Clone : TFhirCoverageEligibilityResponseInsurance;
begin
  result := TFhirCoverageEligibilityResponseInsurance(inherited Clone);
end;

function TFhirCoverageEligibilityResponseInsurance.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityResponseInsurance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityResponseInsurance)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityResponseInsurance(other);
    result := compareDeep(coverageElement, o.coverageElement, true) and compareDeep(inforceElement, o.inforceElement, true) and 
      compareDeep(benefitPeriodElement, o.benefitPeriodElement, true) and compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirCoverageEligibilityResponseInsurance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCoverage) and isEmptyProp(FInforce) and isEmptyProp(FBenefitPeriod) and isEmptyProp(FitemList);
end;

procedure TFhirCoverageEligibilityResponseInsurance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('coverage');
  fields.add('inforce');
  fields.add('benefitPeriod');
  fields.add('item');
end;

{ TFhirCoverageEligibilityResponseInsurance }

Procedure TFhirCoverageEligibilityResponseInsurance.SetCoverage(value : TFhirReference{TFhirCoverage});
begin
  FCoverage.free;
  FCoverage := value;
end;

Procedure TFhirCoverageEligibilityResponseInsurance.SetInforce(value : TFhirBoolean);
begin
  FInforce.free;
  FInforce := value;
end;

Function TFhirCoverageEligibilityResponseInsurance.GetInforceST : Boolean;
begin
  if FInforce = nil then
    result := false
  else
    result := FInforce.value;
end;

Procedure TFhirCoverageEligibilityResponseInsurance.SetInforceST(value : Boolean);
begin
  if FInforce = nil then
    FInforce := TFhirBoolean.create;
  FInforce.value := value
end;

Procedure TFhirCoverageEligibilityResponseInsurance.SetBenefitPeriod(value : TFhirPeriod);
begin
  FBenefitPeriod.free;
  FBenefitPeriod := value;
end;

Function TFhirCoverageEligibilityResponseInsurance.GetItemList : TFhirCoverageEligibilityResponseInsuranceItemList;
begin
  if FItemList = nil then
    FItemList := TFhirCoverageEligibilityResponseInsuranceItemList.Create;
  result := FItemList;
end;

Function TFhirCoverageEligibilityResponseInsurance.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

function TFhirCoverageEligibilityResponseInsurance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCoverage.sizeInBytes);
  inc(result, FInforce.sizeInBytes);
  inc(result, FBenefitPeriod.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
end;

{ TFhirCoverageEligibilityResponseInsuranceListEnumerator }

Constructor TFhirCoverageEligibilityResponseInsuranceListEnumerator.Create(list : TFhirCoverageEligibilityResponseInsuranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityResponseInsuranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityResponseInsuranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityResponseInsuranceListEnumerator.GetCurrent : TFhirCoverageEligibilityResponseInsurance;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityResponseInsuranceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageEligibilityResponseInsuranceList }
procedure TFhirCoverageEligibilityResponseInsuranceList.AddItem(value: TFhirCoverageEligibilityResponseInsurance);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityResponseInsurance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityResponseInsurance');
  add(value);
end;

function TFhirCoverageEligibilityResponseInsuranceList.Append: TFhirCoverageEligibilityResponseInsurance;
begin
  result := TFhirCoverageEligibilityResponseInsurance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseInsuranceList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityResponseInsuranceList.GetEnumerator : TFhirCoverageEligibilityResponseInsuranceListEnumerator;
begin
  result := TFhirCoverageEligibilityResponseInsuranceListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityResponseInsuranceList.Clone: TFhirCoverageEligibilityResponseInsuranceList;
begin
  result := TFhirCoverageEligibilityResponseInsuranceList(inherited Clone);
end;

function TFhirCoverageEligibilityResponseInsuranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityResponseInsuranceList.GetItemN(index: Integer): TFhirCoverageEligibilityResponseInsurance;
begin
  result := TFhirCoverageEligibilityResponseInsurance(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseInsuranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityResponseInsurance;
end;
function TFhirCoverageEligibilityResponseInsuranceList.IndexOf(value: TFhirCoverageEligibilityResponseInsurance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityResponseInsuranceList.Insert(index: Integer): TFhirCoverageEligibilityResponseInsurance;
begin
  result := TFhirCoverageEligibilityResponseInsurance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseInsuranceList.InsertItem(index: Integer; value: TFhirCoverageEligibilityResponseInsurance);
begin
  assert(value is TFhirCoverageEligibilityResponseInsurance);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityResponseInsuranceList.Item(index: Integer): TFhirCoverageEligibilityResponseInsurance;
begin
  result := TFhirCoverageEligibilityResponseInsurance(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseInsuranceList.Link: TFhirCoverageEligibilityResponseInsuranceList;
begin
  result := TFhirCoverageEligibilityResponseInsuranceList(inherited Link);
end;

procedure TFhirCoverageEligibilityResponseInsuranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityResponseInsuranceList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityResponseInsurance);
begin
  assert(value is TFhirCoverageEligibilityResponseInsurance);
  FhirCoverageEligibilityResponseInsurances[index] := value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceList.SetItemN(index: Integer; value: TFhirCoverageEligibilityResponseInsurance);
begin
  assert(value is TFhirCoverageEligibilityResponseInsurance);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityResponseInsuranceItem }

constructor TFhirCoverageEligibilityResponseInsuranceItem.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityResponseInsuranceItem.Destroy;
begin
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProvider.free;
  FExcluded.free;
  FName.free;
  FDescription.free;
  FNetwork.free;
  FUnit_.free;
  FTerm.free;
  FBenefitList.Free;
  FAuthorizationRequired.free;
  FAuthorizationSupportingList.Free;
  FAuthorizationUrl.free;
  inherited;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirCoverageEligibilityResponseInsuranceItem(oSource).category.Clone;
  productOrService := TFhirCoverageEligibilityResponseInsuranceItem(oSource).productOrService.Clone;
  if (TFhirCoverageEligibilityResponseInsuranceItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirCoverageEligibilityResponseInsuranceItem(oSource).FModifierList);
  end;
  provider := TFhirCoverageEligibilityResponseInsuranceItem(oSource).provider.Clone;
  excludedElement := TFhirCoverageEligibilityResponseInsuranceItem(oSource).excludedElement.Clone;
  nameElement := TFhirCoverageEligibilityResponseInsuranceItem(oSource).nameElement.Clone;
  descriptionElement := TFhirCoverageEligibilityResponseInsuranceItem(oSource).descriptionElement.Clone;
  network := TFhirCoverageEligibilityResponseInsuranceItem(oSource).network.Clone;
  unit_ := TFhirCoverageEligibilityResponseInsuranceItem(oSource).unit_.Clone;
  term := TFhirCoverageEligibilityResponseInsuranceItem(oSource).term.Clone;
  if (TFhirCoverageEligibilityResponseInsuranceItem(oSource).FBenefitList = nil) then
  begin
    FBenefitList.free;
    FBenefitList := nil;
  end
  else
  begin
    if FBenefitList = nil then
      FBenefitList := TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Create;
    FBenefitList.Assign(TFhirCoverageEligibilityResponseInsuranceItem(oSource).FBenefitList);
  end;
  authorizationRequiredElement := TFhirCoverageEligibilityResponseInsuranceItem(oSource).authorizationRequiredElement.Clone;
  if (TFhirCoverageEligibilityResponseInsuranceItem(oSource).FAuthorizationSupportingList = nil) then
  begin
    FAuthorizationSupportingList.free;
    FAuthorizationSupportingList := nil;
  end
  else
  begin
    if FAuthorizationSupportingList = nil then
      FAuthorizationSupportingList := TFhirCodeableConceptList.Create;
    FAuthorizationSupportingList.Assign(TFhirCoverageEligibilityResponseInsuranceItem(oSource).FAuthorizationSupportingList);
  end;
  authorizationUrlElement := TFhirCoverageEligibilityResponseInsuranceItem(oSource).authorizationUrlElement.Clone;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'excluded') Then
     list.add(self.link, 'excluded', FExcluded.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'network') Then
     list.add(self.link, 'network', FNetwork.Link);
  if (child_name = 'unit') Then
     list.add(self.link, 'unit', FUnit_.Link);
  if (child_name = 'term') Then
     list.add(self.link, 'term', FTerm.Link);
  if (child_name = 'benefit') Then
    list.addAll(self, 'benefit', FBenefitList);
  if (child_name = 'authorizationRequired') Then
     list.add(self.link, 'authorizationRequired', FAuthorizationRequired.Link);
  if (child_name = 'authorizationSupporting') Then
    list.addAll(self, 'authorizationSupporting', FAuthorizationSupportingList);
  if (child_name = 'authorizationUrl') Then
     list.add(self.link, 'authorizationUrl', FAuthorizationUrl.Link);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'excluded', 'boolean', false, TFhirBoolean, FExcluded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'network', 'CodeableConcept', false, TFhirCodeableConcept, FNetwork.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unit', 'CodeableConcept', false, TFhirCodeableConcept, FUnit_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'term', 'CodeableConcept', false, TFhirCodeableConcept, FTerm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'benefit', '', true, TFhirCoverageEligibilityResponseInsuranceItemBenefit, FBenefitList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'authorizationRequired', 'boolean', false, TFhirBoolean, FAuthorizationRequired.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authorizationSupporting', 'CodeableConcept', true, TFhirCodeableConcept, FAuthorizationSupportingList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'authorizationUrl', 'uri', false, TFhirUri, FAuthorizationUrl.Link));{2}
end;

function TFhirCoverageEligibilityResponseInsuranceItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'excluded') then
  begin
    ExcludedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    Network := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'unit') then
  begin
    Unit_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'term') then
  begin
    Term := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'benefit') then
  begin
    BenefitList.add(propValue as TFhirCoverageEligibilityResponseInsuranceItemBenefit){2a};
    result := propValue;
  end
  else if (propName = 'authorizationRequired') then
  begin
    AuthorizationRequiredElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'authorizationSupporting') then
  begin
    AuthorizationSupportingList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'authorizationUrl') then
  begin
    AuthorizationUrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'benefit') then BenefitList.insertItem(index, propValue as TFhirCoverageEligibilityResponseInsuranceItemBenefit){2a}
  else if (propName = 'authorizationSupporting') then AuthorizationSupportingList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirCoverageEligibilityResponseInsuranceItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'excluded') then result := TFhirBoolean.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'network') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'unit') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'term') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'benefit') then result := BenefitList.new(){2}
  else if (propName = 'authorizationRequired') then result := TFhirBoolean.create() {5b}
  else if (propName = 'authorizationSupporting') then result := AuthorizationSupportingList.new(){2}
  else if (propName = 'authorizationUrl') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityResponseInsuranceItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'excluded') then result := 'boolean'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'network') then result := 'CodeableConcept'
  else if (propName = 'unit') then result := 'CodeableConcept'
  else if (propName = 'term') then result := 'CodeableConcept'
  else if (propName = 'benefit') then result := ''
  else if (propName = 'authorizationRequired') then result := 'boolean'
  else if (propName = 'authorizationSupporting') then result := 'CodeableConcept'
  else if (propName = 'authorizationUrl') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'excluded') then ExcludedElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'network') then NetworkElement := nil
  else if (propName = 'unit') then Unit_Element := nil
  else if (propName = 'term') then TermElement := nil
  else if (propName = 'benefit') then deletePropertyValue('benefit', BenefitList, value) {2}
  else if (propName = 'authorizationRequired') then AuthorizationRequiredElement := nil
  else if (propName = 'authorizationSupporting') then deletePropertyValue('authorizationSupporting', AuthorizationSupportingList, value) {2}
  else if (propName = 'authorizationUrl') then AuthorizationUrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'excluded') then ExcludedElement := asBoolean(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'network') then NetworkElement := new as TFhirCodeableConcept{4}
  else if (propName = 'unit') then Unit_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'term') then TermElement := new as TFhirCodeableConcept{4}
  else if (propName = 'benefit') then replacePropertyValue('benefit', BenefitList, existing, new) {2}
  else if (propName = 'authorizationRequired') then AuthorizationRequiredElement := asBoolean(new){5b}
  else if (propName = 'authorizationSupporting') then replacePropertyValue('authorizationSupporting', AuthorizationSupportingList, existing, new) {2}
  else if (propName = 'authorizationUrl') then AuthorizationUrlElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'benefit') then BenefitList.move(source, destination){2a}
  else if (propName = 'authorizationSupporting') then AuthorizationSupportingList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityResponseInsuranceItem.fhirType : string;
begin
  result := 'item';
end;

function TFhirCoverageEligibilityResponseInsuranceItem.Link : TFhirCoverageEligibilityResponseInsuranceItem;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem(inherited Link);
end;

function TFhirCoverageEligibilityResponseInsuranceItem.Clone : TFhirCoverageEligibilityResponseInsuranceItem;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem(inherited Clone);
end;

function TFhirCoverageEligibilityResponseInsuranceItem.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityResponseInsuranceItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityResponseInsuranceItem)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityResponseInsuranceItem(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(providerElement, o.providerElement, true) and 
      compareDeep(excludedElement, o.excludedElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(networkElement, o.networkElement, true) and 
      compareDeep(unit_Element, o.unit_Element, true) and compareDeep(termElement, o.termElement, true) and 
      compareDeep(benefitList, o.benefitList, true) and compareDeep(authorizationRequiredElement, o.authorizationRequiredElement, true) and 
      compareDeep(authorizationSupportingList, o.authorizationSupportingList, true) and 
      compareDeep(authorizationUrlElement, o.authorizationUrlElement, true);
  end;
end;

function TFhirCoverageEligibilityResponseInsuranceItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FProvider) and isEmptyProp(FExcluded) and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FNetwork) and isEmptyProp(FUnit_) and isEmptyProp(FTerm) and isEmptyProp(FbenefitList) and isEmptyProp(FAuthorizationRequired) and isEmptyProp(FauthorizationSupportingList) and isEmptyProp(FAuthorizationUrl);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('provider');
  fields.add('excluded');
  fields.add('name');
  fields.add('description');
  fields.add('network');
  fields.add('unit');
  fields.add('term');
  fields.add('benefit');
  fields.add('authorizationRequired');
  fields.add('authorizationSupporting');
  fields.add('authorizationUrl');
end;

{ TFhirCoverageEligibilityResponseInsuranceItem }

Procedure TFhirCoverageEligibilityResponseInsuranceItem.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirCoverageEligibilityResponseInsuranceItem.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

Function TFhirCoverageEligibilityResponseInsuranceItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirCoverageEligibilityResponseInsuranceItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Procedure TFhirCoverageEligibilityResponseInsuranceItem.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirCoverageEligibilityResponseInsuranceItem.SetExcluded(value : TFhirBoolean);
begin
  FExcluded.free;
  FExcluded := value;
end;

Function TFhirCoverageEligibilityResponseInsuranceItem.GetExcludedST : Boolean;
begin
  if FExcluded = nil then
    result := false
  else
    result := FExcluded.value;
end;

Procedure TFhirCoverageEligibilityResponseInsuranceItem.SetExcludedST(value : Boolean);
begin
  if FExcluded = nil then
    FExcluded := TFhirBoolean.create;
  FExcluded.value := value
end;

Procedure TFhirCoverageEligibilityResponseInsuranceItem.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirCoverageEligibilityResponseInsuranceItem.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirCoverageEligibilityResponseInsuranceItem.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirCoverageEligibilityResponseInsuranceItem.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirCoverageEligibilityResponseInsuranceItem.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirCoverageEligibilityResponseInsuranceItem.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirCoverageEligibilityResponseInsuranceItem.SetNetwork(value : TFhirCodeableConcept);
begin
  FNetwork.free;
  FNetwork := value;
end;

Procedure TFhirCoverageEligibilityResponseInsuranceItem.SetUnit_(value : TFhirCodeableConcept);
begin
  FUnit_.free;
  FUnit_ := value;
end;

Procedure TFhirCoverageEligibilityResponseInsuranceItem.SetTerm(value : TFhirCodeableConcept);
begin
  FTerm.free;
  FTerm := value;
end;

Function TFhirCoverageEligibilityResponseInsuranceItem.GetBenefitList : TFhirCoverageEligibilityResponseInsuranceItemBenefitList;
begin
  if FBenefitList = nil then
    FBenefitList := TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Create;
  result := FBenefitList;
end;

Function TFhirCoverageEligibilityResponseInsuranceItem.GetHasBenefitList : boolean;
begin
  result := (FBenefitList <> nil) and (FBenefitList.count > 0);
end;

Procedure TFhirCoverageEligibilityResponseInsuranceItem.SetAuthorizationRequired(value : TFhirBoolean);
begin
  FAuthorizationRequired.free;
  FAuthorizationRequired := value;
end;

Function TFhirCoverageEligibilityResponseInsuranceItem.GetAuthorizationRequiredST : Boolean;
begin
  if FAuthorizationRequired = nil then
    result := false
  else
    result := FAuthorizationRequired.value;
end;

Procedure TFhirCoverageEligibilityResponseInsuranceItem.SetAuthorizationRequiredST(value : Boolean);
begin
  if FAuthorizationRequired = nil then
    FAuthorizationRequired := TFhirBoolean.create;
  FAuthorizationRequired.value := value
end;

Function TFhirCoverageEligibilityResponseInsuranceItem.GetAuthorizationSupportingList : TFhirCodeableConceptList;
begin
  if FAuthorizationSupportingList = nil then
    FAuthorizationSupportingList := TFhirCodeableConceptList.Create;
  result := FAuthorizationSupportingList;
end;

Function TFhirCoverageEligibilityResponseInsuranceItem.GetHasAuthorizationSupportingList : boolean;
begin
  result := (FAuthorizationSupportingList <> nil) and (FAuthorizationSupportingList.count > 0);
end;

Procedure TFhirCoverageEligibilityResponseInsuranceItem.SetAuthorizationUrl(value : TFhirUri);
begin
  FAuthorizationUrl.free;
  FAuthorizationUrl := value;
end;

Function TFhirCoverageEligibilityResponseInsuranceItem.GetAuthorizationUrlST : String;
begin
  if FAuthorizationUrl = nil then
    result := ''
  else
    result := FAuthorizationUrl.value;
end;

Procedure TFhirCoverageEligibilityResponseInsuranceItem.SetAuthorizationUrlST(value : String);
begin
  if value <> '' then
  begin
    if FAuthorizationUrl = nil then
      FAuthorizationUrl := TFhirUri.create;
    FAuthorizationUrl.value := value
  end
  else if FAuthorizationUrl <> nil then
    FAuthorizationUrl.value := '';
end;

function TFhirCoverageEligibilityResponseInsuranceItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FExcluded.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FNetwork.sizeInBytes);
  inc(result, FUnit_.sizeInBytes);
  inc(result, FTerm.sizeInBytes);
  inc(result, FbenefitList.sizeInBytes);
  inc(result, FAuthorizationRequired.sizeInBytes);
  inc(result, FauthorizationSupportingList.sizeInBytes);
  inc(result, FAuthorizationUrl.sizeInBytes);
end;

{ TFhirCoverageEligibilityResponseInsuranceItemListEnumerator }

Constructor TFhirCoverageEligibilityResponseInsuranceItemListEnumerator.Create(list : TFhirCoverageEligibilityResponseInsuranceItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityResponseInsuranceItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityResponseInsuranceItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityResponseInsuranceItemListEnumerator.GetCurrent : TFhirCoverageEligibilityResponseInsuranceItem;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityResponseInsuranceItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageEligibilityResponseInsuranceItemList }
procedure TFhirCoverageEligibilityResponseInsuranceItemList.AddItem(value: TFhirCoverageEligibilityResponseInsuranceItem);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityResponseInsuranceItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityResponseInsuranceItem');
  add(value);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.Append: TFhirCoverageEligibilityResponseInsuranceItem;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.GetEnumerator : TFhirCoverageEligibilityResponseInsuranceItemListEnumerator;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.Clone: TFhirCoverageEligibilityResponseInsuranceItemList;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemList(inherited Clone);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.GetItemN(index: Integer): TFhirCoverageEligibilityResponseInsuranceItem;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem;
end;
function TFhirCoverageEligibilityResponseInsuranceItemList.IndexOf(value: TFhirCoverageEligibilityResponseInsuranceItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.Insert(index: Integer): TFhirCoverageEligibilityResponseInsuranceItem;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemList.InsertItem(index: Integer; value: TFhirCoverageEligibilityResponseInsuranceItem);
begin
  assert(value is TFhirCoverageEligibilityResponseInsuranceItem);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.Item(index: Integer): TFhirCoverageEligibilityResponseInsuranceItem;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItem(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseInsuranceItemList.Link: TFhirCoverageEligibilityResponseInsuranceItemList;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemList(inherited Link);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityResponseInsuranceItem);
begin
  assert(value is TFhirCoverageEligibilityResponseInsuranceItem);
  FhirCoverageEligibilityResponseInsuranceItems[index] := value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemList.SetItemN(index: Integer; value: TFhirCoverageEligibilityResponseInsuranceItem);
begin
  assert(value is TFhirCoverageEligibilityResponseInsuranceItem);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityResponseInsuranceItemBenefit }

constructor TFhirCoverageEligibilityResponseInsuranceItemBenefit.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityResponseInsuranceItemBenefit.Destroy;
begin
  FType_.free;
  FAllowed.free;
  FUsed.free;
  inherited;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirCoverageEligibilityResponseInsuranceItemBenefit(oSource).type_.Clone;
  allowed := TFhirCoverageEligibilityResponseInsuranceItemBenefit(oSource).allowed.Clone;
  used := TFhirCoverageEligibilityResponseInsuranceItemBenefit(oSource).used.Clone;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'allowed[x]') or (child_name = 'allowed') Then
     list.add(self.link, 'allowed[x]', FAllowed.Link);
  if (child_name = 'used[x]') or (child_name = 'used') Then
     list.add(self.link, 'used[x]', FUsed.Link);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'allowed[x]', 'unsignedInt|string|Money', false, TFhirType, FAllowed.Link));{2}
  oList.add(TFHIRProperty.create(self, 'used[x]', 'unsignedInt|string|Money', false, TFhirType, FUsed.Link));{2}
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then
  begin
    Allowed := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'String', 'Money'])) then
  begin
    Used := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then raise EFHIRException.create('Cannot make property Allowed'){4x}
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'String', 'Money'])) then raise EFHIRException.create('Cannot make property Used'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'allowed[x]') then result := 'unsignedInt|string|Money'
  else if (propName = 'used[x]') then result := 'unsignedInt|string|Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then AllowedElement := nil{4x}
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'String', 'Money'])) then UsedElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then AllowedElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'String', 'Money'])) then UsedElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.fhirType : string;
begin
  result := 'benefit';
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.Link : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit(inherited Link);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.Clone : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit(inherited Clone);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityResponseInsuranceItemBenefit)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityResponseInsuranceItemBenefit(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(allowedElement, o.allowedElement, true) and 
      compareDeep(usedElement, o.usedElement, true);
  end;
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAllowed) and isEmptyProp(FUsed);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('allowed[x]');
  fields.add('used[x]');
end;

{ TFhirCoverageEligibilityResponseInsuranceItemBenefit }

Procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.SetAllowed(value : TFhirType);
begin
  FAllowed.free;
  FAllowed := value;
end;

Procedure TFhirCoverageEligibilityResponseInsuranceItemBenefit.SetUsed(value : TFhirType);
begin
  FUsed.free;
  FUsed := value;
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefit.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FAllowed.sizeInBytes);
  inc(result, FUsed.sizeInBytes);
end;

{ TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator }

Constructor TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator.Create(list : TFhirCoverageEligibilityResponseInsuranceItemBenefitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator.GetCurrent : TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageEligibilityResponseInsuranceItemBenefitList }
procedure TFhirCoverageEligibilityResponseInsuranceItemBenefitList.AddItem(value: TFhirCoverageEligibilityResponseInsuranceItemBenefit);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityResponseInsuranceItemBenefit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityResponseInsuranceItemBenefit');
  add(value);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Append: TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefitList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.GetEnumerator : TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefitListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Clone: TFhirCoverageEligibilityResponseInsuranceItemBenefitList;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefitList(inherited Clone);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.GetItemN(index: Integer): TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit;
end;
function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.IndexOf(value: TFhirCoverageEligibilityResponseInsuranceItemBenefit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Insert(index: Integer): TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefitList.InsertItem(index: Integer; value: TFhirCoverageEligibilityResponseInsuranceItemBenefit);
begin
  assert(value is TFhirCoverageEligibilityResponseInsuranceItemBenefit);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Item(index: Integer): TFhirCoverageEligibilityResponseInsuranceItemBenefit;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefit(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Link: TFhirCoverageEligibilityResponseInsuranceItemBenefitList;
begin
  result := TFhirCoverageEligibilityResponseInsuranceItemBenefitList(inherited Link);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefitList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityResponseInsuranceItemBenefit);
begin
  assert(value is TFhirCoverageEligibilityResponseInsuranceItemBenefit);
  FhirCoverageEligibilityResponseInsuranceItemBenefits[index] := value;
end;

procedure TFhirCoverageEligibilityResponseInsuranceItemBenefitList.SetItemN(index: Integer; value: TFhirCoverageEligibilityResponseInsuranceItemBenefit);
begin
  assert(value is TFhirCoverageEligibilityResponseInsuranceItemBenefit);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityResponseError }

constructor TFhirCoverageEligibilityResponseError.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityResponseError.Destroy;
begin
  FCode.free;
  inherited;
end;

procedure TFhirCoverageEligibilityResponseError.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirCoverageEligibilityResponseError(oSource).code.Clone;
end;

procedure TFhirCoverageEligibilityResponseError.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
end;

procedure TFhirCoverageEligibilityResponseError.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
end;

function TFhirCoverageEligibilityResponseError.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageEligibilityResponseError.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageEligibilityResponseError.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityResponseError.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityResponseError.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityResponseError.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityResponseError.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityResponseError.fhirType : string;
begin
  result := 'error';
end;

function TFhirCoverageEligibilityResponseError.Link : TFhirCoverageEligibilityResponseError;
begin
  result := TFhirCoverageEligibilityResponseError(inherited Link);
end;

function TFhirCoverageEligibilityResponseError.Clone : TFhirCoverageEligibilityResponseError;
begin
  result := TFhirCoverageEligibilityResponseError(inherited Clone);
end;

function TFhirCoverageEligibilityResponseError.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityResponseError;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityResponseError)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityResponseError(other);
    result := compareDeep(codeElement, o.codeElement, true);
  end;
end;

function TFhirCoverageEligibilityResponseError.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode);
end;

procedure TFhirCoverageEligibilityResponseError.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
end;

{ TFhirCoverageEligibilityResponseError }

Procedure TFhirCoverageEligibilityResponseError.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirCoverageEligibilityResponseError.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
end;

{ TFhirCoverageEligibilityResponseErrorListEnumerator }

Constructor TFhirCoverageEligibilityResponseErrorListEnumerator.Create(list : TFhirCoverageEligibilityResponseErrorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityResponseErrorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityResponseErrorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityResponseErrorListEnumerator.GetCurrent : TFhirCoverageEligibilityResponseError;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityResponseErrorListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageEligibilityResponseErrorList }
procedure TFhirCoverageEligibilityResponseErrorList.AddItem(value: TFhirCoverageEligibilityResponseError);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityResponseError', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityResponseError');
  add(value);
end;

function TFhirCoverageEligibilityResponseErrorList.Append: TFhirCoverageEligibilityResponseError;
begin
  result := TFhirCoverageEligibilityResponseError.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseErrorList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityResponseErrorList.GetEnumerator : TFhirCoverageEligibilityResponseErrorListEnumerator;
begin
  result := TFhirCoverageEligibilityResponseErrorListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityResponseErrorList.Clone: TFhirCoverageEligibilityResponseErrorList;
begin
  result := TFhirCoverageEligibilityResponseErrorList(inherited Clone);
end;

function TFhirCoverageEligibilityResponseErrorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityResponseErrorList.GetItemN(index: Integer): TFhirCoverageEligibilityResponseError;
begin
  result := TFhirCoverageEligibilityResponseError(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseErrorList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityResponseError;
end;
function TFhirCoverageEligibilityResponseErrorList.IndexOf(value: TFhirCoverageEligibilityResponseError): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityResponseErrorList.Insert(index: Integer): TFhirCoverageEligibilityResponseError;
begin
  result := TFhirCoverageEligibilityResponseError.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseErrorList.InsertItem(index: Integer; value: TFhirCoverageEligibilityResponseError);
begin
  assert(value is TFhirCoverageEligibilityResponseError);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityResponseErrorList.Item(index: Integer): TFhirCoverageEligibilityResponseError;
begin
  result := TFhirCoverageEligibilityResponseError(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseErrorList.Link: TFhirCoverageEligibilityResponseErrorList;
begin
  result := TFhirCoverageEligibilityResponseErrorList(inherited Link);
end;

procedure TFhirCoverageEligibilityResponseErrorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityResponseErrorList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityResponseError);
begin
  assert(value is TFhirCoverageEligibilityResponseError);
  FhirCoverageEligibilityResponseErrors[index] := value;
end;

procedure TFhirCoverageEligibilityResponseErrorList.SetItemN(index: Integer; value: TFhirCoverageEligibilityResponseError);
begin
  assert(value is TFhirCoverageEligibilityResponseError);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverageEligibilityResponse }

constructor TFhirCoverageEligibilityResponse.Create;
begin
  inherited;
end;

destructor TFhirCoverageEligibilityResponse.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FPurpose.Free;
  FPatient.free;
  FServiced.free;
  FCreated.free;
  FRequestor.free;
  FRequest.free;
  FOutcome.free;
  FDisposition.free;
  FInsurer.free;
  FInsuranceList.Free;
  FPreAuthRef.free;
  FForm.free;
  FErrorList.Free;
  inherited;
end;

function TFhirCoverageEligibilityResponse.GetResourceType : TFhirResourceType;
begin
  result := frtCoverageEligibilityResponse;
end;

procedure TFhirCoverageEligibilityResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCoverageEligibilityResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCoverageEligibilityResponse(oSource).FIdentifierList);
  end;
  FStatus := TFhirCoverageEligibilityResponse(oSource).FStatus.Link;
  if (TFhirCoverageEligibilityResponse(oSource).FPurpose = nil) then
  begin
    FPurpose.free;
    FPurpose := nil;
  end
  else
  begin
    FPurpose := TFHIREnumList.Create(SYSTEMS_TFhirEligibilityresponsePurposeEnum, CODES_TFhirEligibilityresponsePurposeEnum);
    FPurpose.Assign(TFhirCoverageEligibilityResponse(oSource).FPurpose);
  end;
  patient := TFhirCoverageEligibilityResponse(oSource).patient.Clone;
  serviced := TFhirCoverageEligibilityResponse(oSource).serviced.Clone;
  createdElement := TFhirCoverageEligibilityResponse(oSource).createdElement.Clone;
  requestor := TFhirCoverageEligibilityResponse(oSource).requestor.Clone;
  request := TFhirCoverageEligibilityResponse(oSource).request.Clone;
  FOutcome := TFhirCoverageEligibilityResponse(oSource).FOutcome.Link;
  dispositionElement := TFhirCoverageEligibilityResponse(oSource).dispositionElement.Clone;
  insurer := TFhirCoverageEligibilityResponse(oSource).insurer.Clone;
  if (TFhirCoverageEligibilityResponse(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirCoverageEligibilityResponseInsuranceList.Create;
    FInsuranceList.Assign(TFhirCoverageEligibilityResponse(oSource).FInsuranceList);
  end;
  preAuthRefElement := TFhirCoverageEligibilityResponse(oSource).preAuthRefElement.Clone;
  form := TFhirCoverageEligibilityResponse(oSource).form.Clone;
  if (TFhirCoverageEligibilityResponse(oSource).FErrorList = nil) then
  begin
    FErrorList.free;
    FErrorList := nil;
  end
  else
  begin
    if FErrorList = nil then
      FErrorList := TFhirCoverageEligibilityResponseErrorList.Create;
    FErrorList.Assign(TFhirCoverageEligibilityResponse(oSource).FErrorList);
  end;
end;

procedure TFhirCoverageEligibilityResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'purpose') Then
     list.addAll(self, 'purpose', FPurpose);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'requestor') Then
     list.add(self.link, 'requestor', FRequestor.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'preAuthRef') Then
     list.add(self.link, 'preAuthRef', FPreAuthRef.Link);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'error') Then
    list.addAll(self, 'error', FErrorList);
end;

procedure TFhirCoverageEligibilityResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'purpose', 'code', true, TFHIREnum, FPurpose.Link)){3};
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirType, FServiced.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestor', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FRequestor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(CoverageEligibilityRequest)', false, TFhirReference{TFhirCoverageEligibilityRequest}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFHIREnum, FOutcome.Link));{1}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FInsurer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'insurance', '', true, TFhirCoverageEligibilityResponseInsurance, FInsuranceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'preAuthRef', 'string', false, TFhirString, FPreAuthRef.Link));{2}
  oList.add(TFHIRProperty.create(self, 'form', 'CodeableConcept', false, TFhirCodeableConcept, FForm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'error', '', true, TFhirCoverageEligibilityResponseError, FErrorList.Link)){3};
end;

function TFhirCoverageEligibilityResponse.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'purpose') then
  begin
    PurposeList.add(asEnum(SYSTEMS_TFhirEligibilityresponsePurposeEnum, CODES_TFhirEligibilityresponsePurposeEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requestor') then
  begin
    Requestor := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirCoverageEligibilityRequest}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirRemittanceOutcomeEnum, CODES_TFhirRemittanceOutcomeEnum, propValue);
    result := propValue
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirCoverageEligibilityResponseInsurance){2a};
    result := propValue;
  end
  else if (propName = 'preAuthRef') then
  begin
    PreAuthRefElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'error') then
  begin
    ErrorList.add(propValue as TFhirCoverageEligibilityResponseError){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirCoverageEligibilityResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'purpose') then FPurpose.insertItem(index, asEnum(SYSTEMS_TFhirEligibilityresponsePurposeEnum, CODES_TFhirEligibilityresponsePurposeEnum, propValue)) {1}
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirCoverageEligibilityResponseInsurance){2a}
  else if (propName = 'error') then ErrorList.insertItem(index, propValue as TFhirCoverageEligibilityResponseError){2a}
  else inherited;
end;

function TFhirCoverageEligibilityResponse.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced'){4x}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'requestor') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'request') then result := TFhirReference{TFhirCoverageEligibilityRequest}.create(){4b}
  else if (propName = 'disposition') then result := TFhirString.create() {5b}
  else if (propName = 'insurer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'insurance') then result := InsuranceList.new(){2}
  else if (propName = 'preAuthRef') then result := TFhirString.create() {5b}
  else if (propName = 'form') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'error') then result := ErrorList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageEligibilityResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'purpose') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'requestor') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'insurance') then result := ''
  else if (propName = 'preAuthRef') then result := 'string'
  else if (propName = 'form') then result := 'CodeableConcept'
  else if (propName = 'error') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageEligibilityResponse.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil{4x}
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'requestor') then RequestorElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value) {2}
  else if (propName = 'preAuthRef') then PreAuthRefElement := nil
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'error') then deletePropertyValue('error', ErrorList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageEligibilityResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirType{4x}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'requestor') then RequestorElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirCoverageEligibilityRequest}{4}
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirRemittanceOutcomeEnum, CODES_TFhirRemittanceOutcomeEnum, new){4}
  else if (propName = 'disposition') then DispositionElement := asString(new){5b}
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new) {2}
  else if (propName = 'preAuthRef') then PreAuthRefElement := asString(new){5b}
  else if (propName = 'form') then FormElement := new as TFhirCodeableConcept{4}
  else if (propName = 'error') then replacePropertyValue('error', ErrorList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageEligibilityResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'purpose') then FPurpose.move(source, destination) {1}
  else if (propName = 'insurance') then InsuranceList.move(source, destination){2a}
  else if (propName = 'error') then ErrorList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageEligibilityResponse.fhirType : string;
begin
  result := 'CoverageEligibilityResponse';
end;

function TFhirCoverageEligibilityResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FPurpose) and isEmptyProp(FPatient) and isEmptyProp(FServiced) and isEmptyProp(FCreated) and isEmptyProp(FRequestor) and isEmptyProp(FRequest) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FInsurer) and isEmptyProp(FinsuranceList) and isEmptyProp(FPreAuthRef) and isEmptyProp(FForm) and isEmptyProp(FerrorList);
end;

function TFhirCoverageEligibilityResponse.equals(other : TObject) : boolean; 
var
  o : TFhirCoverageEligibilityResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageEligibilityResponse)) then
    result := false
  else
  begin
    o := TFhirCoverageEligibilityResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(purposeList, o.purposeList, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(servicedElement, o.servicedElement, true) and compareDeep(createdElement, o.createdElement, true) and 
      compareDeep(requestorElement, o.requestorElement, true) and compareDeep(requestElement, o.requestElement, true) and 
      compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(dispositionElement, o.dispositionElement, true) and 
      compareDeep(insurerElement, o.insurerElement, true) and compareDeep(insuranceList, o.insuranceList, true) and 
      compareDeep(preAuthRefElement, o.preAuthRefElement, true) and compareDeep(formElement, o.formElement, true) and 
      compareDeep(errorList, o.errorList, true);
  end;
end;

function TFhirCoverageEligibilityResponse.Link : TFhirCoverageEligibilityResponse;
begin
  result := TFhirCoverageEligibilityResponse(inherited Link);
end;

function TFhirCoverageEligibilityResponse.Clone : TFhirCoverageEligibilityResponse;
begin
  result := TFhirCoverageEligibilityResponse(inherited Clone);
end;

procedure TFhirCoverageEligibilityResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('purpose');
  fields.add('patient');
  fields.add('serviced[x]');
  fields.add('created');
  fields.add('requestor');
  fields.add('request');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('insurer');
  fields.add('insurance');
  fields.add('preAuthRef');
  fields.add('form');
  fields.add('error');
end;

{ TFhirCoverageEligibilityResponse }

Function TFhirCoverageEligibilityResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirCoverageEligibilityResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirCoverageEligibilityResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirCoverageEligibilityResponse.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirCoverageEligibilityResponse.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Function TFhirCoverageEligibilityResponse.GetPurpose : TFhirEnumList;
begin
  if FPurpose = nil then
    FPurpose := TFHIREnumList.Create(SYSTEMS_TFhirEligibilityresponsePurposeEnum, CODES_TFhirEligibilityresponsePurposeEnum);
  result := FPurpose;
end;

Function TFhirCoverageEligibilityResponse.GetHasPurpose : boolean;
begin
  result := (FPurpose <> nil) and (FPurpose.count > 0);
end;

Function TFhirCoverageEligibilityResponse.GetPurposeST : TFhirEligibilityresponsePurposeEnumList;
  var i : integer;
begin
  result := [];
  if Fpurpose <> nil then
    for i := 0 to Fpurpose.count - 1 do
      result := result + [TFhirEligibilityresponsePurposeEnum(StringArrayIndexOfSensitive(CODES_TFhirEligibilityresponsePurposeEnum, Fpurpose[i].value))];
end;

Procedure TFhirCoverageEligibilityResponse.SetPurposeST(value : TFhirEligibilityresponsePurposeEnumList);
var a : TFhirEligibilityresponsePurposeEnum;
begin
  if Fpurpose = nil then
    Fpurpose := TFhirEnumList.create(SYSTEMS_TFhirEligibilityresponsePurposeEnum, CODES_TFhirEligibilityresponsePurposeEnum);
  Fpurpose.clear;
  for a := low(TFhirEligibilityresponsePurposeEnum) to high(TFhirEligibilityresponsePurposeEnum) do
    if a in value then
      begin
         if Fpurpose = nil then
           Fpurpose := TFhirEnumList.create(SYSTEMS_TFhirEligibilityresponsePurposeEnum, CODES_TFhirEligibilityresponsePurposeEnum);
         Fpurpose.add(TFhirEnum.create(SYSTEMS_TFhirEligibilityresponsePurposeEnum[a], CODES_TFhirEligibilityresponsePurposeEnum[a]));
      end;
end;

Procedure TFhirCoverageEligibilityResponse.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirCoverageEligibilityResponse.SetServiced(value : TFhirType);
begin
  FServiced.free;
  FServiced := value;
end;

Procedure TFhirCoverageEligibilityResponse.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirCoverageEligibilityResponse.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirCoverageEligibilityResponse.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirCoverageEligibilityResponse.SetRequestor(value : TFhirReference{TFhirPractitioner});
begin
  FRequestor.free;
  FRequestor := value;
end;

Procedure TFhirCoverageEligibilityResponse.SetRequest(value : TFhirReference{TFhirCoverageEligibilityRequest});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirCoverageEligibilityResponse.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirCoverageEligibilityResponse.GetOutcomeST : TFhirRemittanceOutcomeEnum;
begin
  if FOutcome = nil then
    result := TFhirRemittanceOutcomeEnum(0)
  else
    result := TFhirRemittanceOutcomeEnum(StringArrayIndexOfSensitive(CODES_TFhirRemittanceOutcomeEnum, FOutcome.value));
end;

Procedure TFhirCoverageEligibilityResponse.SetOutcomeST(value : TFhirRemittanceOutcomeEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirRemittanceOutcomeEnum[value], CODES_TFhirRemittanceOutcomeEnum[value]);
end;

Procedure TFhirCoverageEligibilityResponse.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

Function TFhirCoverageEligibilityResponse.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

Procedure TFhirCoverageEligibilityResponse.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

Procedure TFhirCoverageEligibilityResponse.SetInsurer(value : TFhirReference{TFhirOrganization});
begin
  FInsurer.free;
  FInsurer := value;
end;

Function TFhirCoverageEligibilityResponse.GetInsuranceList : TFhirCoverageEligibilityResponseInsuranceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirCoverageEligibilityResponseInsuranceList.Create;
  result := FInsuranceList;
end;

Function TFhirCoverageEligibilityResponse.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

Procedure TFhirCoverageEligibilityResponse.SetPreAuthRef(value : TFhirString);
begin
  FPreAuthRef.free;
  FPreAuthRef := value;
end;

Function TFhirCoverageEligibilityResponse.GetPreAuthRefST : String;
begin
  if FPreAuthRef = nil then
    result := ''
  else
    result := FPreAuthRef.value;
end;

Procedure TFhirCoverageEligibilityResponse.SetPreAuthRefST(value : String);
begin
  if value <> '' then
  begin
    if FPreAuthRef = nil then
      FPreAuthRef := TFhirString.create;
    FPreAuthRef.value := value
  end
  else if FPreAuthRef <> nil then
    FPreAuthRef.value := '';
end;

Procedure TFhirCoverageEligibilityResponse.SetForm(value : TFhirCodeableConcept);
begin
  FForm.free;
  FForm := value;
end;

Function TFhirCoverageEligibilityResponse.GetErrorList : TFhirCoverageEligibilityResponseErrorList;
begin
  if FErrorList = nil then
    FErrorList := TFhirCoverageEligibilityResponseErrorList.Create;
  result := FErrorList;
end;

Function TFhirCoverageEligibilityResponse.GetHasErrorList : boolean;
begin
  result := (FErrorList <> nil) and (FErrorList.count > 0);
end;

function TFhirCoverageEligibilityResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPurpose.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FServiced.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FRequestor.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FInsurer.sizeInBytes);
  inc(result, FinsuranceList.sizeInBytes);
  inc(result, FPreAuthRef.sizeInBytes);
  inc(result, FForm.sizeInBytes);
  inc(result, FerrorList.sizeInBytes);
end;

{ TFhirCoverageEligibilityResponseListEnumerator }

Constructor TFhirCoverageEligibilityResponseListEnumerator.Create(list : TFhirCoverageEligibilityResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageEligibilityResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageEligibilityResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageEligibilityResponseListEnumerator.GetCurrent : TFhirCoverageEligibilityResponse;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageEligibilityResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageEligibilityResponseList }
procedure TFhirCoverageEligibilityResponseList.AddItem(value: TFhirCoverageEligibilityResponse);
begin
  assert(value.ClassName = 'TFhirCoverageEligibilityResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageEligibilityResponse');
  add(value);
end;

function TFhirCoverageEligibilityResponseList.Append: TFhirCoverageEligibilityResponse;
begin
  result := TFhirCoverageEligibilityResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageEligibilityResponseList.GetEnumerator : TFhirCoverageEligibilityResponseListEnumerator;
begin
  result := TFhirCoverageEligibilityResponseListEnumerator.Create(self.link);
end;

function TFhirCoverageEligibilityResponseList.Clone: TFhirCoverageEligibilityResponseList;
begin
  result := TFhirCoverageEligibilityResponseList(inherited Clone);
end;

function TFhirCoverageEligibilityResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageEligibilityResponseList.GetItemN(index: Integer): TFhirCoverageEligibilityResponse;
begin
  result := TFhirCoverageEligibilityResponse(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageEligibilityResponse;
end;
function TFhirCoverageEligibilityResponseList.IndexOf(value: TFhirCoverageEligibilityResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageEligibilityResponseList.Insert(index: Integer): TFhirCoverageEligibilityResponse;
begin
  result := TFhirCoverageEligibilityResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageEligibilityResponseList.InsertItem(index: Integer; value: TFhirCoverageEligibilityResponse);
begin
  assert(value is TFhirCoverageEligibilityResponse);
  Inherited Insert(index, value);
end;

function TFhirCoverageEligibilityResponseList.Item(index: Integer): TFhirCoverageEligibilityResponse;
begin
  result := TFhirCoverageEligibilityResponse(ObjectByIndex[index]);
end;

function TFhirCoverageEligibilityResponseList.Link: TFhirCoverageEligibilityResponseList;
begin
  result := TFhirCoverageEligibilityResponseList(inherited Link);
end;

procedure TFhirCoverageEligibilityResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageEligibilityResponseList.SetItemByIndex(index: Integer; value: TFhirCoverageEligibilityResponse);
begin
  assert(value is TFhirCoverageEligibilityResponse);
  FhirCoverageEligibilityResponses[index] := value;
end;

procedure TFhirCoverageEligibilityResponseList.SetItemN(index: Integer; value: TFhirCoverageEligibilityResponse);
begin
  assert(value is TFhirCoverageEligibilityResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COVERAGEELIGIBILITYRESPONSE}

{$IFDEF FHIR_ENROLLMENTREQUEST}

{ TFhirEnrollmentRequest }

constructor TFhirEnrollmentRequest.Create;
begin
  inherited;
end;

destructor TFhirEnrollmentRequest.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCreated.free;
  FInsurer.free;
  FProvider.free;
  FCandidate.free;
  FCoverage.free;
  inherited;
end;

function TFhirEnrollmentRequest.GetResourceType : TFhirResourceType;
begin
  result := frtEnrollmentRequest;
end;

procedure TFhirEnrollmentRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEnrollmentRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEnrollmentRequest(oSource).FIdentifierList);
  end;
  FStatus := TFhirEnrollmentRequest(oSource).FStatus.Link;
  createdElement := TFhirEnrollmentRequest(oSource).createdElement.Clone;
  insurer := TFhirEnrollmentRequest(oSource).insurer.Clone;
  provider := TFhirEnrollmentRequest(oSource).provider.Clone;
  candidate := TFhirEnrollmentRequest(oSource).candidate.Clone;
  coverage := TFhirEnrollmentRequest(oSource).coverage.Clone;
end;

procedure TFhirEnrollmentRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'candidate') Then
     list.add(self.link, 'candidate', FCandidate.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
end;

procedure TFhirEnrollmentRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FInsurer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'candidate', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FCandidate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference(Coverage)', false, TFhirReference{TFhirCoverage}, FCoverage.Link));{2}
end;

function TFhirEnrollmentRequest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'candidate') then
  begin
    Candidate := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference{TFhirCoverage}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirEnrollmentRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirEnrollmentRequest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'insurer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'candidate') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'coverage') then result := TFhirReference{TFhirCoverage}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEnrollmentRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'candidate') then result := 'Reference'
  else if (propName = 'coverage') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEnrollmentRequest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'candidate') then CandidateElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEnrollmentRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'candidate') then CandidateElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference{TFhirCoverage}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEnrollmentRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEnrollmentRequest.fhirType : string;
begin
  result := 'EnrollmentRequest';
end;

function TFhirEnrollmentRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCreated) and isEmptyProp(FInsurer) and isEmptyProp(FProvider) and isEmptyProp(FCandidate) and isEmptyProp(FCoverage);
end;

function TFhirEnrollmentRequest.equals(other : TObject) : boolean; 
var
  o : TFhirEnrollmentRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEnrollmentRequest)) then
    result := false
  else
  begin
    o := TFhirEnrollmentRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(createdElement, o.createdElement, true) and compareDeep(insurerElement, o.insurerElement, true) and 
      compareDeep(providerElement, o.providerElement, true) and compareDeep(candidateElement, o.candidateElement, true) and 
      compareDeep(coverageElement, o.coverageElement, true);
  end;
end;

function TFhirEnrollmentRequest.Link : TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest(inherited Link);
end;

function TFhirEnrollmentRequest.Clone : TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest(inherited Clone);
end;

procedure TFhirEnrollmentRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('created');
  fields.add('insurer');
  fields.add('provider');
  fields.add('candidate');
  fields.add('coverage');
end;

{ TFhirEnrollmentRequest }

Function TFhirEnrollmentRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirEnrollmentRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirEnrollmentRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirEnrollmentRequest.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirEnrollmentRequest.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Procedure TFhirEnrollmentRequest.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirEnrollmentRequest.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirEnrollmentRequest.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirEnrollmentRequest.SetInsurer(value : TFhirReference{TFhirOrganization});
begin
  FInsurer.free;
  FInsurer := value;
end;

Procedure TFhirEnrollmentRequest.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirEnrollmentRequest.SetCandidate(value : TFhirReference{TFhirPatient});
begin
  FCandidate.free;
  FCandidate := value;
end;

Procedure TFhirEnrollmentRequest.SetCoverage(value : TFhirReference{TFhirCoverage});
begin
  FCoverage.free;
  FCoverage := value;
end;

function TFhirEnrollmentRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FInsurer.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FCandidate.sizeInBytes);
  inc(result, FCoverage.sizeInBytes);
end;

{ TFhirEnrollmentRequestListEnumerator }

Constructor TFhirEnrollmentRequestListEnumerator.Create(list : TFhirEnrollmentRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEnrollmentRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEnrollmentRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEnrollmentRequestListEnumerator.GetCurrent : TFhirEnrollmentRequest;
begin
  Result := FList[FIndex];
end;

function TFhirEnrollmentRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEnrollmentRequestList }
procedure TFhirEnrollmentRequestList.AddItem(value: TFhirEnrollmentRequest);
begin
  assert(value.ClassName = 'TFhirEnrollmentRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEnrollmentRequest');
  add(value);
end;

function TFhirEnrollmentRequestList.Append: TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnrollmentRequestList.ClearItems;
begin
  Clear;
end;

function TFhirEnrollmentRequestList.GetEnumerator : TFhirEnrollmentRequestListEnumerator;
begin
  result := TFhirEnrollmentRequestListEnumerator.Create(self.link);
end;

function TFhirEnrollmentRequestList.Clone: TFhirEnrollmentRequestList;
begin
  result := TFhirEnrollmentRequestList(inherited Clone);
end;

function TFhirEnrollmentRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEnrollmentRequestList.GetItemN(index: Integer): TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest(ObjectByIndex[index]);
end;

function TFhirEnrollmentRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirEnrollmentRequest;
end;
function TFhirEnrollmentRequestList.IndexOf(value: TFhirEnrollmentRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEnrollmentRequestList.Insert(index: Integer): TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnrollmentRequestList.InsertItem(index: Integer; value: TFhirEnrollmentRequest);
begin
  assert(value is TFhirEnrollmentRequest);
  Inherited Insert(index, value);
end;

function TFhirEnrollmentRequestList.Item(index: Integer): TFhirEnrollmentRequest;
begin
  result := TFhirEnrollmentRequest(ObjectByIndex[index]);
end;

function TFhirEnrollmentRequestList.Link: TFhirEnrollmentRequestList;
begin
  result := TFhirEnrollmentRequestList(inherited Link);
end;

procedure TFhirEnrollmentRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEnrollmentRequestList.SetItemByIndex(index: Integer; value: TFhirEnrollmentRequest);
begin
  assert(value is TFhirEnrollmentRequest);
  FhirEnrollmentRequests[index] := value;
end;

procedure TFhirEnrollmentRequestList.SetItemN(index: Integer; value: TFhirEnrollmentRequest);
begin
  assert(value is TFhirEnrollmentRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ENROLLMENTREQUEST}

{$IFDEF FHIR_ENROLLMENTRESPONSE}

{ TFhirEnrollmentResponse }

constructor TFhirEnrollmentResponse.Create;
begin
  inherited;
end;

destructor TFhirEnrollmentResponse.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FRequest.free;
  FOutcome.free;
  FDisposition.free;
  FCreated.free;
  FOrganization.free;
  FRequestProvider.free;
  inherited;
end;

function TFhirEnrollmentResponse.GetResourceType : TFhirResourceType;
begin
  result := frtEnrollmentResponse;
end;

procedure TFhirEnrollmentResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEnrollmentResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEnrollmentResponse(oSource).FIdentifierList);
  end;
  FStatus := TFhirEnrollmentResponse(oSource).FStatus.Link;
  request := TFhirEnrollmentResponse(oSource).request.Clone;
  FOutcome := TFhirEnrollmentResponse(oSource).FOutcome.Link;
  dispositionElement := TFhirEnrollmentResponse(oSource).dispositionElement.Clone;
  createdElement := TFhirEnrollmentResponse(oSource).createdElement.Clone;
  organization := TFhirEnrollmentResponse(oSource).organization.Clone;
  requestProvider := TFhirEnrollmentResponse(oSource).requestProvider.Clone;
end;

procedure TFhirEnrollmentResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'requestProvider') Then
     list.add(self.link, 'requestProvider', FRequestProvider.Link);
end;

procedure TFhirEnrollmentResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(EnrollmentRequest)', false, TFhirReference{TFhirEnrollmentRequest}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFHIREnum, FOutcome.Link));{1}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestProvider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FRequestProvider.Link));{2}
end;

function TFhirEnrollmentResponse.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirEnrollmentRequest}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirRemittanceOutcomeEnum, CODES_TFhirRemittanceOutcomeEnum, propValue);
    result := propValue
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'requestProvider') then
  begin
    RequestProvider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirEnrollmentResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirEnrollmentResponse.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'request') then result := TFhirReference{TFhirEnrollmentRequest}.create(){4b}
  else if (propName = 'disposition') then result := TFhirString.create() {5b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'requestProvider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEnrollmentResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'requestProvider') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEnrollmentResponse.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'requestProvider') then RequestProviderElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEnrollmentResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirEnrollmentRequest}{4}
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirRemittanceOutcomeEnum, CODES_TFhirRemittanceOutcomeEnum, new){4}
  else if (propName = 'disposition') then DispositionElement := asString(new){5b}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'requestProvider') then RequestProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEnrollmentResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEnrollmentResponse.fhirType : string;
begin
  result := 'EnrollmentResponse';
end;

function TFhirEnrollmentResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FRequest) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FCreated) and isEmptyProp(FOrganization) and isEmptyProp(FRequestProvider);
end;

function TFhirEnrollmentResponse.equals(other : TObject) : boolean; 
var
  o : TFhirEnrollmentResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEnrollmentResponse)) then
    result := false
  else
  begin
    o := TFhirEnrollmentResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(requestElement, o.requestElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and 
      compareDeep(dispositionElement, o.dispositionElement, true) and compareDeep(createdElement, o.createdElement, true) and 
      compareDeep(organizationElement, o.organizationElement, true) and compareDeep(requestProviderElement, o.requestProviderElement, true);
  end;
end;

function TFhirEnrollmentResponse.Link : TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse(inherited Link);
end;

function TFhirEnrollmentResponse.Clone : TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse(inherited Clone);
end;

procedure TFhirEnrollmentResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('request');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('created');
  fields.add('organization');
  fields.add('requestProvider');
end;

{ TFhirEnrollmentResponse }

Function TFhirEnrollmentResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirEnrollmentResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirEnrollmentResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirEnrollmentResponse.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirEnrollmentResponse.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Procedure TFhirEnrollmentResponse.SetRequest(value : TFhirReference{TFhirEnrollmentRequest});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirEnrollmentResponse.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirEnrollmentResponse.GetOutcomeST : TFhirRemittanceOutcomeEnum;
begin
  if FOutcome = nil then
    result := TFhirRemittanceOutcomeEnum(0)
  else
    result := TFhirRemittanceOutcomeEnum(StringArrayIndexOfSensitive(CODES_TFhirRemittanceOutcomeEnum, FOutcome.value));
end;

Procedure TFhirEnrollmentResponse.SetOutcomeST(value : TFhirRemittanceOutcomeEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirRemittanceOutcomeEnum[value], CODES_TFhirRemittanceOutcomeEnum[value]);
end;

Procedure TFhirEnrollmentResponse.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

Function TFhirEnrollmentResponse.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

Procedure TFhirEnrollmentResponse.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

Procedure TFhirEnrollmentResponse.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirEnrollmentResponse.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirEnrollmentResponse.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirEnrollmentResponse.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirEnrollmentResponse.SetRequestProvider(value : TFhirReference{TFhirPractitioner});
begin
  FRequestProvider.free;
  FRequestProvider := value;
end;

function TFhirEnrollmentResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FOrganization.sizeInBytes);
  inc(result, FRequestProvider.sizeInBytes);
end;

{ TFhirEnrollmentResponseListEnumerator }

Constructor TFhirEnrollmentResponseListEnumerator.Create(list : TFhirEnrollmentResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEnrollmentResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEnrollmentResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEnrollmentResponseListEnumerator.GetCurrent : TFhirEnrollmentResponse;
begin
  Result := FList[FIndex];
end;

function TFhirEnrollmentResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEnrollmentResponseList }
procedure TFhirEnrollmentResponseList.AddItem(value: TFhirEnrollmentResponse);
begin
  assert(value.ClassName = 'TFhirEnrollmentResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEnrollmentResponse');
  add(value);
end;

function TFhirEnrollmentResponseList.Append: TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnrollmentResponseList.ClearItems;
begin
  Clear;
end;

function TFhirEnrollmentResponseList.GetEnumerator : TFhirEnrollmentResponseListEnumerator;
begin
  result := TFhirEnrollmentResponseListEnumerator.Create(self.link);
end;

function TFhirEnrollmentResponseList.Clone: TFhirEnrollmentResponseList;
begin
  result := TFhirEnrollmentResponseList(inherited Clone);
end;

function TFhirEnrollmentResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEnrollmentResponseList.GetItemN(index: Integer): TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse(ObjectByIndex[index]);
end;

function TFhirEnrollmentResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirEnrollmentResponse;
end;
function TFhirEnrollmentResponseList.IndexOf(value: TFhirEnrollmentResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEnrollmentResponseList.Insert(index: Integer): TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnrollmentResponseList.InsertItem(index: Integer; value: TFhirEnrollmentResponse);
begin
  assert(value is TFhirEnrollmentResponse);
  Inherited Insert(index, value);
end;

function TFhirEnrollmentResponseList.Item(index: Integer): TFhirEnrollmentResponse;
begin
  result := TFhirEnrollmentResponse(ObjectByIndex[index]);
end;

function TFhirEnrollmentResponseList.Link: TFhirEnrollmentResponseList;
begin
  result := TFhirEnrollmentResponseList(inherited Link);
end;

procedure TFhirEnrollmentResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEnrollmentResponseList.SetItemByIndex(index: Integer; value: TFhirEnrollmentResponse);
begin
  assert(value is TFhirEnrollmentResponse);
  FhirEnrollmentResponses[index] := value;
end;

procedure TFhirEnrollmentResponseList.SetItemN(index: Integer; value: TFhirEnrollmentResponse);
begin
  assert(value is TFhirEnrollmentResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ENROLLMENTRESPONSE}

{$IFDEF FHIR_EXPLANATIONOFBENEFIT}

{ TFhirExplanationOfBenefitRelated }

constructor TFhirExplanationOfBenefitRelated.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitRelated.Destroy;
begin
  FClaim.free;
  FRelationship.free;
  FReference.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitRelated.Assign(oSource : TFslObject);
begin
  inherited;
  claim := TFhirExplanationOfBenefitRelated(oSource).claim.Clone;
  relationship := TFhirExplanationOfBenefitRelated(oSource).relationship.Clone;
  reference := TFhirExplanationOfBenefitRelated(oSource).reference.Clone;
end;

procedure TFhirExplanationOfBenefitRelated.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'claim') Then
     list.add(self.link, 'claim', FClaim.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirExplanationOfBenefitRelated.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'claim', 'Reference(Claim)', false, TFhirReference{TFhirClaim}, FClaim.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', false, TFhirCodeableConcept, FRelationship.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'Identifier', false, TFhirIdentifier, FReference.Link));{2}
end;

function TFhirExplanationOfBenefitRelated.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'claim') then
  begin
    Claim := propValue as TFhirReference{TFhirClaim}{4b};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitRelated.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitRelated.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'claim') then result := TFhirReference{TFhirClaim}.create(){4b}
  else if (propName = 'relationship') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reference') then result := TFhirIdentifier.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitRelated.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'claim') then result := 'Reference'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'reference') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitRelated.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'claim') then ClaimElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitRelated.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'claim') then ClaimElement := new as TFhirReference{TFhirClaim}{4}
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCodeableConcept{4}
  else if (propName = 'reference') then ReferenceElement := new as TFhirIdentifier{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitRelated.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitRelated.fhirType : string;
begin
  result := 'related';
end;

function TFhirExplanationOfBenefitRelated.Link : TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated(inherited Link);
end;

function TFhirExplanationOfBenefitRelated.Clone : TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated(inherited Clone);
end;

function TFhirExplanationOfBenefitRelated.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitRelated;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitRelated)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitRelated(other);
    result := compareDeep(claimElement, o.claimElement, true) and compareDeep(relationshipElement, o.relationshipElement, true) and 
      compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirExplanationOfBenefitRelated.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FClaim) and isEmptyProp(FRelationship) and isEmptyProp(FReference);
end;

procedure TFhirExplanationOfBenefitRelated.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('claim');
  fields.add('relationship');
  fields.add('reference');
end;

{ TFhirExplanationOfBenefitRelated }

Procedure TFhirExplanationOfBenefitRelated.SetClaim(value : TFhirReference{TFhirClaim});
begin
  FClaim.free;
  FClaim := value;
end;

Procedure TFhirExplanationOfBenefitRelated.SetRelationship(value : TFhirCodeableConcept);
begin
  FRelationship.free;
  FRelationship := value;
end;

Procedure TFhirExplanationOfBenefitRelated.SetReference(value : TFhirIdentifier);
begin
  FReference.free;
  FReference := value;
end;

function TFhirExplanationOfBenefitRelated.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FClaim.sizeInBytes);
  inc(result, FRelationship.sizeInBytes);
  inc(result, FReference.sizeInBytes);
end;

{ TFhirExplanationOfBenefitRelatedListEnumerator }

Constructor TFhirExplanationOfBenefitRelatedListEnumerator.Create(list : TFhirExplanationOfBenefitRelatedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitRelatedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitRelatedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitRelatedListEnumerator.GetCurrent : TFhirExplanationOfBenefitRelated;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitRelatedListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitRelatedList }
procedure TFhirExplanationOfBenefitRelatedList.AddItem(value: TFhirExplanationOfBenefitRelated);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitRelated', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitRelated');
  add(value);
end;

function TFhirExplanationOfBenefitRelatedList.Append: TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitRelatedList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitRelatedList.GetEnumerator : TFhirExplanationOfBenefitRelatedListEnumerator;
begin
  result := TFhirExplanationOfBenefitRelatedListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitRelatedList.Clone: TFhirExplanationOfBenefitRelatedList;
begin
  result := TFhirExplanationOfBenefitRelatedList(inherited Clone);
end;

function TFhirExplanationOfBenefitRelatedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitRelatedList.GetItemN(index: Integer): TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitRelatedList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitRelated;
end;
function TFhirExplanationOfBenefitRelatedList.IndexOf(value: TFhirExplanationOfBenefitRelated): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitRelatedList.Insert(index: Integer): TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitRelatedList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitRelated);
begin
  assert(value is TFhirExplanationOfBenefitRelated);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitRelatedList.Item(index: Integer): TFhirExplanationOfBenefitRelated;
begin
  result := TFhirExplanationOfBenefitRelated(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitRelatedList.Link: TFhirExplanationOfBenefitRelatedList;
begin
  result := TFhirExplanationOfBenefitRelatedList(inherited Link);
end;

procedure TFhirExplanationOfBenefitRelatedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitRelatedList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitRelated);
begin
  assert(value is TFhirExplanationOfBenefitRelated);
  FhirExplanationOfBenefitRelateds[index] := value;
end;

procedure TFhirExplanationOfBenefitRelatedList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitRelated);
begin
  assert(value is TFhirExplanationOfBenefitRelated);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitPayee }

constructor TFhirExplanationOfBenefitPayee.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitPayee.Destroy;
begin
  FType_.free;
  FParty.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitPayee.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirExplanationOfBenefitPayee(oSource).type_.Clone;
  party := TFhirExplanationOfBenefitPayee(oSource).party.Clone;
end;

procedure TFhirExplanationOfBenefitPayee.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
end;

procedure TFhirExplanationOfBenefitPayee.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'party', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FParty.Link));{2}
end;

function TFhirExplanationOfBenefitPayee.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    Party := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitPayee.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitPayee.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'party') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitPayee.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'party') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitPayee.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'party') then PartyElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitPayee.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'party') then PartyElement := new as TFhirReference{TFhirPractitioner}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitPayee.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitPayee.fhirType : string;
begin
  result := 'payee';
end;

function TFhirExplanationOfBenefitPayee.Link : TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee(inherited Link);
end;

function TFhirExplanationOfBenefitPayee.Clone : TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee(inherited Clone);
end;

function TFhirExplanationOfBenefitPayee.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitPayee;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitPayee)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitPayee(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(partyElement, o.partyElement, true);
  end;
end;

function TFhirExplanationOfBenefitPayee.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FParty);
end;

procedure TFhirExplanationOfBenefitPayee.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('party');
end;

{ TFhirExplanationOfBenefitPayee }

Procedure TFhirExplanationOfBenefitPayee.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirExplanationOfBenefitPayee.SetParty(value : TFhirReference{TFhirPractitioner});
begin
  FParty.free;
  FParty := value;
end;

function TFhirExplanationOfBenefitPayee.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FParty.sizeInBytes);
end;

{ TFhirExplanationOfBenefitPayeeListEnumerator }

Constructor TFhirExplanationOfBenefitPayeeListEnumerator.Create(list : TFhirExplanationOfBenefitPayeeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitPayeeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitPayeeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitPayeeListEnumerator.GetCurrent : TFhirExplanationOfBenefitPayee;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitPayeeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitPayeeList }
procedure TFhirExplanationOfBenefitPayeeList.AddItem(value: TFhirExplanationOfBenefitPayee);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitPayee', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitPayee');
  add(value);
end;

function TFhirExplanationOfBenefitPayeeList.Append: TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitPayeeList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitPayeeList.GetEnumerator : TFhirExplanationOfBenefitPayeeListEnumerator;
begin
  result := TFhirExplanationOfBenefitPayeeListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitPayeeList.Clone: TFhirExplanationOfBenefitPayeeList;
begin
  result := TFhirExplanationOfBenefitPayeeList(inherited Clone);
end;

function TFhirExplanationOfBenefitPayeeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitPayeeList.GetItemN(index: Integer): TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitPayeeList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitPayee;
end;
function TFhirExplanationOfBenefitPayeeList.IndexOf(value: TFhirExplanationOfBenefitPayee): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitPayeeList.Insert(index: Integer): TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitPayeeList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitPayee);
begin
  assert(value is TFhirExplanationOfBenefitPayee);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitPayeeList.Item(index: Integer): TFhirExplanationOfBenefitPayee;
begin
  result := TFhirExplanationOfBenefitPayee(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitPayeeList.Link: TFhirExplanationOfBenefitPayeeList;
begin
  result := TFhirExplanationOfBenefitPayeeList(inherited Link);
end;

procedure TFhirExplanationOfBenefitPayeeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitPayeeList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitPayee);
begin
  assert(value is TFhirExplanationOfBenefitPayee);
  FhirExplanationOfBenefitPayees[index] := value;
end;

procedure TFhirExplanationOfBenefitPayeeList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitPayee);
begin
  assert(value is TFhirExplanationOfBenefitPayee);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitCareTeam }

constructor TFhirExplanationOfBenefitCareTeam.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitCareTeam.Destroy;
begin
  FSequence.free;
  FProvider.free;
  FResponsible.free;
  FRole.free;
  FQualification.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitCareTeam.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitCareTeam(oSource).sequenceElement.Clone;
  provider := TFhirExplanationOfBenefitCareTeam(oSource).provider.Clone;
  responsibleElement := TFhirExplanationOfBenefitCareTeam(oSource).responsibleElement.Clone;
  role := TFhirExplanationOfBenefitCareTeam(oSource).role.Clone;
  qualification := TFhirExplanationOfBenefitCareTeam(oSource).qualification.Clone;
end;

procedure TFhirExplanationOfBenefitCareTeam.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'qualification') Then
     list.add(self.link, 'qualification', FQualification.Link);
end;

procedure TFhirExplanationOfBenefitCareTeam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'responsible', 'boolean', false, TFhirBoolean, FResponsible.Link));{2}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'qualification', 'CodeableConcept', false, TFhirCodeableConcept, FQualification.Link));{2}
end;

function TFhirExplanationOfBenefitCareTeam.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    ResponsibleElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'qualification') then
  begin
    Qualification := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitCareTeam.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitCareTeam.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'responsible') then result := TFhirBoolean.create() {5b}
  else if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'qualification') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitCareTeam.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'responsible') then result := 'boolean'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'qualification') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitCareTeam.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'qualification') then QualificationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitCareTeam.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'responsible') then ResponsibleElement := asBoolean(new){5b}
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else if (propName = 'qualification') then QualificationElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitCareTeam.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitCareTeam.fhirType : string;
begin
  result := 'careTeam';
end;

function TFhirExplanationOfBenefitCareTeam.Link : TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam(inherited Link);
end;

function TFhirExplanationOfBenefitCareTeam.Clone : TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam(inherited Clone);
end;

function TFhirExplanationOfBenefitCareTeam.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitCareTeam;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitCareTeam)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitCareTeam(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(providerElement, o.providerElement, true) and 
      compareDeep(responsibleElement, o.responsibleElement, true) and compareDeep(roleElement, o.roleElement, true) and 
      compareDeep(qualificationElement, o.qualificationElement, true);
  end;
end;

function TFhirExplanationOfBenefitCareTeam.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FProvider) and isEmptyProp(FResponsible) and isEmptyProp(FRole) and isEmptyProp(FQualification);
end;

procedure TFhirExplanationOfBenefitCareTeam.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('provider');
  fields.add('responsible');
  fields.add('role');
  fields.add('qualification');
end;

{ TFhirExplanationOfBenefitCareTeam }

Procedure TFhirExplanationOfBenefitCareTeam.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirExplanationOfBenefitCareTeam.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirExplanationOfBenefitCareTeam.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirExplanationOfBenefitCareTeam.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirExplanationOfBenefitCareTeam.SetResponsible(value : TFhirBoolean);
begin
  FResponsible.free;
  FResponsible := value;
end;

Function TFhirExplanationOfBenefitCareTeam.GetResponsibleST : Boolean;
begin
  if FResponsible = nil then
    result := false
  else
    result := FResponsible.value;
end;

Procedure TFhirExplanationOfBenefitCareTeam.SetResponsibleST(value : Boolean);
begin
  if FResponsible = nil then
    FResponsible := TFhirBoolean.create;
  FResponsible.value := value
end;

Procedure TFhirExplanationOfBenefitCareTeam.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirExplanationOfBenefitCareTeam.SetQualification(value : TFhirCodeableConcept);
begin
  FQualification.free;
  FQualification := value;
end;

function TFhirExplanationOfBenefitCareTeam.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FResponsible.sizeInBytes);
  inc(result, FRole.sizeInBytes);
  inc(result, FQualification.sizeInBytes);
end;

{ TFhirExplanationOfBenefitCareTeamListEnumerator }

Constructor TFhirExplanationOfBenefitCareTeamListEnumerator.Create(list : TFhirExplanationOfBenefitCareTeamList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitCareTeamListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitCareTeamListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitCareTeamListEnumerator.GetCurrent : TFhirExplanationOfBenefitCareTeam;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitCareTeamListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitCareTeamList }
procedure TFhirExplanationOfBenefitCareTeamList.AddItem(value: TFhirExplanationOfBenefitCareTeam);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitCareTeam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitCareTeam');
  add(value);
end;

function TFhirExplanationOfBenefitCareTeamList.Append: TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitCareTeamList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitCareTeamList.GetEnumerator : TFhirExplanationOfBenefitCareTeamListEnumerator;
begin
  result := TFhirExplanationOfBenefitCareTeamListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitCareTeamList.Clone: TFhirExplanationOfBenefitCareTeamList;
begin
  result := TFhirExplanationOfBenefitCareTeamList(inherited Clone);
end;

function TFhirExplanationOfBenefitCareTeamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitCareTeamList.GetItemN(index: Integer): TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitCareTeamList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitCareTeam;
end;
function TFhirExplanationOfBenefitCareTeamList.IndexOf(value: TFhirExplanationOfBenefitCareTeam): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitCareTeamList.Insert(index: Integer): TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitCareTeamList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitCareTeam);
begin
  assert(value is TFhirExplanationOfBenefitCareTeam);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitCareTeamList.Item(index: Integer): TFhirExplanationOfBenefitCareTeam;
begin
  result := TFhirExplanationOfBenefitCareTeam(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitCareTeamList.Link: TFhirExplanationOfBenefitCareTeamList;
begin
  result := TFhirExplanationOfBenefitCareTeamList(inherited Link);
end;

procedure TFhirExplanationOfBenefitCareTeamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitCareTeamList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitCareTeam);
begin
  assert(value is TFhirExplanationOfBenefitCareTeam);
  FhirExplanationOfBenefitCareTeams[index] := value;
end;

procedure TFhirExplanationOfBenefitCareTeamList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitCareTeam);
begin
  assert(value is TFhirExplanationOfBenefitCareTeam);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitSupportingInfo }

constructor TFhirExplanationOfBenefitSupportingInfo.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitSupportingInfo.Destroy;
begin
  FSequence.free;
  FCategory.free;
  FCode.free;
  FTiming.free;
  FValue.free;
  FReason.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitSupportingInfo.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitSupportingInfo(oSource).sequenceElement.Clone;
  category := TFhirExplanationOfBenefitSupportingInfo(oSource).category.Clone;
  code := TFhirExplanationOfBenefitSupportingInfo(oSource).code.Clone;
  timing := TFhirExplanationOfBenefitSupportingInfo(oSource).timing.Clone;
  value := TFhirExplanationOfBenefitSupportingInfo(oSource).value.Clone;
  reason := TFhirExplanationOfBenefitSupportingInfo(oSource).reason.Clone;
end;

procedure TFhirExplanationOfBenefitSupportingInfo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
end;

procedure TFhirExplanationOfBenefitSupportingInfo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'date|Period', false, TFhirType, FTiming.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'boolean|string|Quantity|Attachment|Reference(Any)', false, TFhirType, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'Coding', false, TFhirCoding, FReason.Link));{2}
end;

function TFhirExplanationOfBenefitSupportingInfo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then
  begin
    Timing := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitSupportingInfo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitSupportingInfo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Timing'){4x}
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else if (propName = 'reason') then result := TFhirCoding.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitSupportingInfo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'timing[x]') then result := 'date|Period'
  else if (propName = 'value[x]') then result := 'boolean|string|Quantity|Attachment|Reference'
  else if (propName = 'reason') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitSupportingInfo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then TimingElement := nil{4x}
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then ValueElement := nil{4x}
  else if (propName = 'reason') then ReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitSupportingInfo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'timing', ['Date', 'Period'])) then TimingElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'value', ['Boolean', 'String', 'Quantity', 'Attachment', 'Reference'])) then ValueElement := new as TFhirType{4x}
  else if (propName = 'reason') then ReasonElement := new as TFhirCoding{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitSupportingInfo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitSupportingInfo.fhirType : string;
begin
  result := 'supportingInfo';
end;

function TFhirExplanationOfBenefitSupportingInfo.Link : TFhirExplanationOfBenefitSupportingInfo;
begin
  result := TFhirExplanationOfBenefitSupportingInfo(inherited Link);
end;

function TFhirExplanationOfBenefitSupportingInfo.Clone : TFhirExplanationOfBenefitSupportingInfo;
begin
  result := TFhirExplanationOfBenefitSupportingInfo(inherited Clone);
end;

function TFhirExplanationOfBenefitSupportingInfo.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitSupportingInfo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitSupportingInfo)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitSupportingInfo(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(categoryElement, o.categoryElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(timingElement, o.timingElement, true) and 
      compareDeep(valueElement, o.valueElement, true) and compareDeep(reasonElement, o.reasonElement, true);
  end;
end;

function TFhirExplanationOfBenefitSupportingInfo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FCategory) and isEmptyProp(FCode) and isEmptyProp(FTiming) and isEmptyProp(FValue) and isEmptyProp(FReason);
end;

procedure TFhirExplanationOfBenefitSupportingInfo.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('category');
  fields.add('code');
  fields.add('timing[x]');
  fields.add('value[x]');
  fields.add('reason');
end;

{ TFhirExplanationOfBenefitSupportingInfo }

Procedure TFhirExplanationOfBenefitSupportingInfo.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirExplanationOfBenefitSupportingInfo.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirExplanationOfBenefitSupportingInfo.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirExplanationOfBenefitSupportingInfo.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirExplanationOfBenefitSupportingInfo.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirExplanationOfBenefitSupportingInfo.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirExplanationOfBenefitSupportingInfo.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Procedure TFhirExplanationOfBenefitSupportingInfo.SetReason(value : TFhirCoding);
begin
  FReason.free;
  FReason := value;
end;

function TFhirExplanationOfBenefitSupportingInfo.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FTiming.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FReason.sizeInBytes);
end;

{ TFhirExplanationOfBenefitSupportingInfoListEnumerator }

Constructor TFhirExplanationOfBenefitSupportingInfoListEnumerator.Create(list : TFhirExplanationOfBenefitSupportingInfoList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitSupportingInfoListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitSupportingInfoListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitSupportingInfoListEnumerator.GetCurrent : TFhirExplanationOfBenefitSupportingInfo;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitSupportingInfoListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitSupportingInfoList }
procedure TFhirExplanationOfBenefitSupportingInfoList.AddItem(value: TFhirExplanationOfBenefitSupportingInfo);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitSupportingInfo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitSupportingInfo');
  add(value);
end;

function TFhirExplanationOfBenefitSupportingInfoList.Append: TFhirExplanationOfBenefitSupportingInfo;
begin
  result := TFhirExplanationOfBenefitSupportingInfo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitSupportingInfoList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitSupportingInfoList.GetEnumerator : TFhirExplanationOfBenefitSupportingInfoListEnumerator;
begin
  result := TFhirExplanationOfBenefitSupportingInfoListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitSupportingInfoList.Clone: TFhirExplanationOfBenefitSupportingInfoList;
begin
  result := TFhirExplanationOfBenefitSupportingInfoList(inherited Clone);
end;

function TFhirExplanationOfBenefitSupportingInfoList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitSupportingInfoList.GetItemN(index: Integer): TFhirExplanationOfBenefitSupportingInfo;
begin
  result := TFhirExplanationOfBenefitSupportingInfo(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitSupportingInfoList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitSupportingInfo;
end;
function TFhirExplanationOfBenefitSupportingInfoList.IndexOf(value: TFhirExplanationOfBenefitSupportingInfo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitSupportingInfoList.Insert(index: Integer): TFhirExplanationOfBenefitSupportingInfo;
begin
  result := TFhirExplanationOfBenefitSupportingInfo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitSupportingInfoList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitSupportingInfo);
begin
  assert(value is TFhirExplanationOfBenefitSupportingInfo);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitSupportingInfoList.Item(index: Integer): TFhirExplanationOfBenefitSupportingInfo;
begin
  result := TFhirExplanationOfBenefitSupportingInfo(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitSupportingInfoList.Link: TFhirExplanationOfBenefitSupportingInfoList;
begin
  result := TFhirExplanationOfBenefitSupportingInfoList(inherited Link);
end;

procedure TFhirExplanationOfBenefitSupportingInfoList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitSupportingInfoList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitSupportingInfo);
begin
  assert(value is TFhirExplanationOfBenefitSupportingInfo);
  FhirExplanationOfBenefitSupportingInfos[index] := value;
end;

procedure TFhirExplanationOfBenefitSupportingInfoList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitSupportingInfo);
begin
  assert(value is TFhirExplanationOfBenefitSupportingInfo);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitDiagnosis }

constructor TFhirExplanationOfBenefitDiagnosis.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitDiagnosis.Destroy;
begin
  FSequence.free;
  FDiagnosis.free;
  FType_List.Free;
  FOnAdmission.free;
  FPackageCode.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitDiagnosis.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitDiagnosis(oSource).sequenceElement.Clone;
  diagnosis := TFhirExplanationOfBenefitDiagnosis(oSource).diagnosis.Clone;
  if (TFhirExplanationOfBenefitDiagnosis(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirExplanationOfBenefitDiagnosis(oSource).FType_List);
  end;
  onAdmission := TFhirExplanationOfBenefitDiagnosis(oSource).onAdmission.Clone;
  packageCode := TFhirExplanationOfBenefitDiagnosis(oSource).packageCode.Clone;
end;

procedure TFhirExplanationOfBenefitDiagnosis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'diagnosis[x]') or (child_name = 'diagnosis') Then
     list.add(self.link, 'diagnosis[x]', FDiagnosis.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'onAdmission') Then
     list.add(self.link, 'onAdmission', FOnAdmission.Link);
  if (child_name = 'packageCode') Then
     list.add(self.link, 'packageCode', FPackageCode.Link);
end;

procedure TFhirExplanationOfBenefitDiagnosis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'diagnosis[x]', 'CodeableConcept|Reference(Condition)', false, TFhirType, FDiagnosis.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'onAdmission', 'CodeableConcept', false, TFhirCodeableConcept, FOnAdmission.Link));{2}
  oList.add(TFHIRProperty.create(self, 'packageCode', 'CodeableConcept', false, TFhirCodeableConcept, FPackageCode.Link));{2}
end;

function TFhirExplanationOfBenefitDiagnosis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then
  begin
    Diagnosis := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'onAdmission') then
  begin
    OnAdmission := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'packageCode') then
  begin
    PackageCode := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitDiagnosis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirExplanationOfBenefitDiagnosis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Diagnosis'){4x}
  else if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'onAdmission') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'packageCode') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitDiagnosis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'diagnosis[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'onAdmission') then result := 'CodeableConcept'
  else if (propName = 'packageCode') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitDiagnosis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := nil{4x}
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'onAdmission') then OnAdmissionElement := nil
  else if (propName = 'packageCode') then PackageCodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitDiagnosis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (isMatchingName(propName, 'diagnosis', ['CodeableConcept', 'Reference'])) then DiagnosisElement := new as TFhirType{4x}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'onAdmission') then OnAdmissionElement := new as TFhirCodeableConcept{4}
  else if (propName = 'packageCode') then PackageCodeElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitDiagnosis.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitDiagnosis.fhirType : string;
begin
  result := 'diagnosis';
end;

function TFhirExplanationOfBenefitDiagnosis.Link : TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis(inherited Link);
end;

function TFhirExplanationOfBenefitDiagnosis.Clone : TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis(inherited Clone);
end;

function TFhirExplanationOfBenefitDiagnosis.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitDiagnosis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitDiagnosis)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitDiagnosis(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(diagnosisElement, o.diagnosisElement, true) and 
      compareDeep(type_List, o.type_List, true) and compareDeep(onAdmissionElement, o.onAdmissionElement, true) and 
      compareDeep(packageCodeElement, o.packageCodeElement, true);
  end;
end;

function TFhirExplanationOfBenefitDiagnosis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FDiagnosis) and isEmptyProp(Ftype_List) and isEmptyProp(FOnAdmission) and isEmptyProp(FPackageCode);
end;

procedure TFhirExplanationOfBenefitDiagnosis.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('diagnosis[x]');
  fields.add('type');
  fields.add('onAdmission');
  fields.add('packageCode');
end;

{ TFhirExplanationOfBenefitDiagnosis }

Procedure TFhirExplanationOfBenefitDiagnosis.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirExplanationOfBenefitDiagnosis.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirExplanationOfBenefitDiagnosis.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirExplanationOfBenefitDiagnosis.SetDiagnosis(value : TFhirType);
begin
  FDiagnosis.free;
  FDiagnosis := value;
end;

Function TFhirExplanationOfBenefitDiagnosis.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

Function TFhirExplanationOfBenefitDiagnosis.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Procedure TFhirExplanationOfBenefitDiagnosis.SetOnAdmission(value : TFhirCodeableConcept);
begin
  FOnAdmission.free;
  FOnAdmission := value;
end;

Procedure TFhirExplanationOfBenefitDiagnosis.SetPackageCode(value : TFhirCodeableConcept);
begin
  FPackageCode.free;
  FPackageCode := value;
end;

function TFhirExplanationOfBenefitDiagnosis.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FDiagnosis.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FOnAdmission.sizeInBytes);
  inc(result, FPackageCode.sizeInBytes);
end;

{ TFhirExplanationOfBenefitDiagnosisListEnumerator }

Constructor TFhirExplanationOfBenefitDiagnosisListEnumerator.Create(list : TFhirExplanationOfBenefitDiagnosisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitDiagnosisListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitDiagnosisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitDiagnosisListEnumerator.GetCurrent : TFhirExplanationOfBenefitDiagnosis;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitDiagnosisListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitDiagnosisList }
procedure TFhirExplanationOfBenefitDiagnosisList.AddItem(value: TFhirExplanationOfBenefitDiagnosis);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitDiagnosis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitDiagnosis');
  add(value);
end;

function TFhirExplanationOfBenefitDiagnosisList.Append: TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitDiagnosisList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitDiagnosisList.GetEnumerator : TFhirExplanationOfBenefitDiagnosisListEnumerator;
begin
  result := TFhirExplanationOfBenefitDiagnosisListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitDiagnosisList.Clone: TFhirExplanationOfBenefitDiagnosisList;
begin
  result := TFhirExplanationOfBenefitDiagnosisList(inherited Clone);
end;

function TFhirExplanationOfBenefitDiagnosisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitDiagnosisList.GetItemN(index: Integer): TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitDiagnosisList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitDiagnosis;
end;
function TFhirExplanationOfBenefitDiagnosisList.IndexOf(value: TFhirExplanationOfBenefitDiagnosis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitDiagnosisList.Insert(index: Integer): TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitDiagnosisList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitDiagnosis);
begin
  assert(value is TFhirExplanationOfBenefitDiagnosis);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitDiagnosisList.Item(index: Integer): TFhirExplanationOfBenefitDiagnosis;
begin
  result := TFhirExplanationOfBenefitDiagnosis(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitDiagnosisList.Link: TFhirExplanationOfBenefitDiagnosisList;
begin
  result := TFhirExplanationOfBenefitDiagnosisList(inherited Link);
end;

procedure TFhirExplanationOfBenefitDiagnosisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitDiagnosisList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitDiagnosis);
begin
  assert(value is TFhirExplanationOfBenefitDiagnosis);
  FhirExplanationOfBenefitDiagnoses[index] := value;
end;

procedure TFhirExplanationOfBenefitDiagnosisList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitDiagnosis);
begin
  assert(value is TFhirExplanationOfBenefitDiagnosis);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitProcedure }

constructor TFhirExplanationOfBenefitProcedure.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitProcedure.Destroy;
begin
  FSequence.free;
  FType_List.Free;
  FDate.free;
  FProcedure_.free;
  FUdiList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitProcedure.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitProcedure(oSource).sequenceElement.Clone;
  if (TFhirExplanationOfBenefitProcedure(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirExplanationOfBenefitProcedure(oSource).FType_List);
  end;
  dateElement := TFhirExplanationOfBenefitProcedure(oSource).dateElement.Clone;
  procedure_ := TFhirExplanationOfBenefitProcedure(oSource).procedure_.Clone;
  if (TFhirExplanationOfBenefitProcedure(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList{TFhirDevice}.Create;
    FUdiList.Assign(TFhirExplanationOfBenefitProcedure(oSource).FUdiList);
  end;
end;

procedure TFhirExplanationOfBenefitProcedure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'procedure[x]') or (child_name = 'procedure') Then
     list.add(self.link, 'procedure[x]', FProcedure_.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
end;

procedure TFhirExplanationOfBenefitProcedure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'procedure[x]', 'CodeableConcept|Reference(Procedure)', false, TFhirType, FProcedure_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference(Device)', true, TFhirReference{TFhirDevice}, FUdiList.Link)){3};
end;

function TFhirExplanationOfBenefitProcedure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then
  begin
    Procedure_ := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference{TFhirDevice}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitProcedure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference{TFhirDevice}){2a}
  else inherited;
end;

function TFhirExplanationOfBenefitProcedure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Procedure_'){4x}
  else if (propName = 'udi') then result := UdiList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitProcedure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'procedure[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'udi') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitProcedure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'date') then DateElement := nil
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then Procedure_Element := nil{4x}
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitProcedure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (isMatchingName(propName, 'procedure', ['CodeableConcept', 'Reference'])) then Procedure_Element := new as TFhirType{4x}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitProcedure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination){2a}
  else if (propName = 'udi') then UdiList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitProcedure.fhirType : string;
begin
  result := 'procedure';
end;

function TFhirExplanationOfBenefitProcedure.Link : TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure(inherited Link);
end;

function TFhirExplanationOfBenefitProcedure.Clone : TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure(inherited Clone);
end;

function TFhirExplanationOfBenefitProcedure.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitProcedure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitProcedure)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitProcedure(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(procedure_Element, o.procedure_Element, true) and 
      compareDeep(udiList, o.udiList, true);
  end;
end;

function TFhirExplanationOfBenefitProcedure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(Ftype_List) and isEmptyProp(FDate) and isEmptyProp(FProcedure_) and isEmptyProp(FudiList);
end;

procedure TFhirExplanationOfBenefitProcedure.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('type');
  fields.add('date');
  fields.add('procedure[x]');
  fields.add('udi');
end;

{ TFhirExplanationOfBenefitProcedure }

Procedure TFhirExplanationOfBenefitProcedure.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirExplanationOfBenefitProcedure.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirExplanationOfBenefitProcedure.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Function TFhirExplanationOfBenefitProcedure.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

Function TFhirExplanationOfBenefitProcedure.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Procedure TFhirExplanationOfBenefitProcedure.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirExplanationOfBenefitProcedure.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirExplanationOfBenefitProcedure.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirExplanationOfBenefitProcedure.SetProcedure_(value : TFhirType);
begin
  FProcedure_.free;
  FProcedure_ := value;
end;

Function TFhirExplanationOfBenefitProcedure.GetUdiList : TFhirReferenceList{TFhirDevice};
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList{TFhirDevice}.Create;
  result := FUdiList;
end;

Function TFhirExplanationOfBenefitProcedure.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

function TFhirExplanationOfBenefitProcedure.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FProcedure_.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitProcedureListEnumerator }

Constructor TFhirExplanationOfBenefitProcedureListEnumerator.Create(list : TFhirExplanationOfBenefitProcedureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitProcedureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitProcedureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitProcedureListEnumerator.GetCurrent : TFhirExplanationOfBenefitProcedure;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitProcedureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitProcedureList }
procedure TFhirExplanationOfBenefitProcedureList.AddItem(value: TFhirExplanationOfBenefitProcedure);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitProcedure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitProcedure');
  add(value);
end;

function TFhirExplanationOfBenefitProcedureList.Append: TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitProcedureList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitProcedureList.GetEnumerator : TFhirExplanationOfBenefitProcedureListEnumerator;
begin
  result := TFhirExplanationOfBenefitProcedureListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitProcedureList.Clone: TFhirExplanationOfBenefitProcedureList;
begin
  result := TFhirExplanationOfBenefitProcedureList(inherited Clone);
end;

function TFhirExplanationOfBenefitProcedureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitProcedureList.GetItemN(index: Integer): TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitProcedureList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitProcedure;
end;
function TFhirExplanationOfBenefitProcedureList.IndexOf(value: TFhirExplanationOfBenefitProcedure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitProcedureList.Insert(index: Integer): TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitProcedureList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitProcedure);
begin
  assert(value is TFhirExplanationOfBenefitProcedure);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitProcedureList.Item(index: Integer): TFhirExplanationOfBenefitProcedure;
begin
  result := TFhirExplanationOfBenefitProcedure(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitProcedureList.Link: TFhirExplanationOfBenefitProcedureList;
begin
  result := TFhirExplanationOfBenefitProcedureList(inherited Link);
end;

procedure TFhirExplanationOfBenefitProcedureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitProcedureList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitProcedure);
begin
  assert(value is TFhirExplanationOfBenefitProcedure);
  FhirExplanationOfBenefitProcedures[index] := value;
end;

procedure TFhirExplanationOfBenefitProcedureList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitProcedure);
begin
  assert(value is TFhirExplanationOfBenefitProcedure);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitInsurance }

constructor TFhirExplanationOfBenefitInsurance.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitInsurance.Destroy;
begin
  FFocal.free;
  FCoverage.free;
  FPreAuthRefList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitInsurance.Assign(oSource : TFslObject);
begin
  inherited;
  focalElement := TFhirExplanationOfBenefitInsurance(oSource).focalElement.Clone;
  coverage := TFhirExplanationOfBenefitInsurance(oSource).coverage.Clone;
  if (TFhirExplanationOfBenefitInsurance(oSource).FPreAuthRefList = nil) then
  begin
    FPreAuthRefList.free;
    FPreAuthRefList := nil;
  end
  else
  begin
    if FPreAuthRefList = nil then
      FPreAuthRefList := TFhirStringList.Create;
    FPreAuthRefList.Assign(TFhirExplanationOfBenefitInsurance(oSource).FPreAuthRefList);
  end;
end;

procedure TFhirExplanationOfBenefitInsurance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'focal') Then
     list.add(self.link, 'focal', FFocal.Link);
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'preAuthRef') Then
    list.addAll(self, 'preAuthRef', FPreAuthRefList);
end;

procedure TFhirExplanationOfBenefitInsurance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'focal', 'boolean', false, TFhirBoolean, FFocal.Link));{2}
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference(Coverage)', false, TFhirReference{TFhirCoverage}, FCoverage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'preAuthRef', 'string', true, TFhirString, FPreAuthRefList.Link)){3};
end;

function TFhirExplanationOfBenefitInsurance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'focal') then
  begin
    FocalElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference{TFhirCoverage}{4b};
    result := propValue;
  end
  else if (propName = 'preAuthRef') then
  begin
    PreAuthRefList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitInsurance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirExplanationOfBenefitInsurance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'focal') then result := TFhirBoolean.create() {5b}
  else if (propName = 'coverage') then result := TFhirReference{TFhirCoverage}.create(){4b}
  else if (propName = 'preAuthRef') then result := PreAuthRefList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitInsurance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'focal') then result := 'boolean'
  else if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'preAuthRef') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitInsurance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'focal') then FocalElement := nil
  else if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'preAuthRef') then deletePropertyValue('preAuthRef', PreAuthRefList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitInsurance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'focal') then FocalElement := asBoolean(new){5b}
  else if (propName = 'coverage') then CoverageElement := new as TFhirReference{TFhirCoverage}{4}
  else if (propName = 'preAuthRef') then replacePropertyValue('preAuthRef', PreAuthRefList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitInsurance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'preAuthRef') then PreAuthRefList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitInsurance.fhirType : string;
begin
  result := 'insurance';
end;

function TFhirExplanationOfBenefitInsurance.Link : TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance(inherited Link);
end;

function TFhirExplanationOfBenefitInsurance.Clone : TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance(inherited Clone);
end;

function TFhirExplanationOfBenefitInsurance.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitInsurance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitInsurance)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitInsurance(other);
    result := compareDeep(focalElement, o.focalElement, true) and compareDeep(coverageElement, o.coverageElement, true) and 
      compareDeep(preAuthRefList, o.preAuthRefList, true);
  end;
end;

function TFhirExplanationOfBenefitInsurance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFocal) and isEmptyProp(FCoverage) and isEmptyProp(FpreAuthRefList);
end;

procedure TFhirExplanationOfBenefitInsurance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('focal');
  fields.add('coverage');
  fields.add('preAuthRef');
end;

{ TFhirExplanationOfBenefitInsurance }

Procedure TFhirExplanationOfBenefitInsurance.SetFocal(value : TFhirBoolean);
begin
  FFocal.free;
  FFocal := value;
end;

Function TFhirExplanationOfBenefitInsurance.GetFocalST : Boolean;
begin
  if FFocal = nil then
    result := false
  else
    result := FFocal.value;
end;

Procedure TFhirExplanationOfBenefitInsurance.SetFocalST(value : Boolean);
begin
  if FFocal = nil then
    FFocal := TFhirBoolean.create;
  FFocal.value := value
end;

Procedure TFhirExplanationOfBenefitInsurance.SetCoverage(value : TFhirReference{TFhirCoverage});
begin
  FCoverage.free;
  FCoverage := value;
end;

Function TFhirExplanationOfBenefitInsurance.GetPreAuthRefList : TFhirStringList;
begin
  if FPreAuthRefList = nil then
    FPreAuthRefList := TFhirStringList.Create;
  result := FPreAuthRefList;
end;

Function TFhirExplanationOfBenefitInsurance.GetHasPreAuthRefList : boolean;
begin
  result := (FPreAuthRefList <> nil) and (FPreAuthRefList.count > 0);
end;

function TFhirExplanationOfBenefitInsurance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FFocal.sizeInBytes);
  inc(result, FCoverage.sizeInBytes);
  inc(result, FpreAuthRefList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitInsuranceListEnumerator }

Constructor TFhirExplanationOfBenefitInsuranceListEnumerator.Create(list : TFhirExplanationOfBenefitInsuranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitInsuranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitInsuranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitInsuranceListEnumerator.GetCurrent : TFhirExplanationOfBenefitInsurance;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitInsuranceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitInsuranceList }
procedure TFhirExplanationOfBenefitInsuranceList.AddItem(value: TFhirExplanationOfBenefitInsurance);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitInsurance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitInsurance');
  add(value);
end;

function TFhirExplanationOfBenefitInsuranceList.Append: TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitInsuranceList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitInsuranceList.GetEnumerator : TFhirExplanationOfBenefitInsuranceListEnumerator;
begin
  result := TFhirExplanationOfBenefitInsuranceListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitInsuranceList.Clone: TFhirExplanationOfBenefitInsuranceList;
begin
  result := TFhirExplanationOfBenefitInsuranceList(inherited Clone);
end;

function TFhirExplanationOfBenefitInsuranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitInsuranceList.GetItemN(index: Integer): TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitInsuranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitInsurance;
end;
function TFhirExplanationOfBenefitInsuranceList.IndexOf(value: TFhirExplanationOfBenefitInsurance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitInsuranceList.Insert(index: Integer): TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitInsuranceList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitInsurance);
begin
  assert(value is TFhirExplanationOfBenefitInsurance);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitInsuranceList.Item(index: Integer): TFhirExplanationOfBenefitInsurance;
begin
  result := TFhirExplanationOfBenefitInsurance(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitInsuranceList.Link: TFhirExplanationOfBenefitInsuranceList;
begin
  result := TFhirExplanationOfBenefitInsuranceList(inherited Link);
end;

procedure TFhirExplanationOfBenefitInsuranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitInsuranceList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitInsurance);
begin
  assert(value is TFhirExplanationOfBenefitInsurance);
  FhirExplanationOfBenefitInsurances[index] := value;
end;

procedure TFhirExplanationOfBenefitInsuranceList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitInsurance);
begin
  assert(value is TFhirExplanationOfBenefitInsurance);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitAccident }

constructor TFhirExplanationOfBenefitAccident.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitAccident.Destroy;
begin
  FDate.free;
  FType_.free;
  FLocation.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitAccident.Assign(oSource : TFslObject);
begin
  inherited;
  dateElement := TFhirExplanationOfBenefitAccident(oSource).dateElement.Clone;
  type_ := TFhirExplanationOfBenefitAccident(oSource).type_.Clone;
  location := TFhirExplanationOfBenefitAccident(oSource).location.Clone;
end;

procedure TFhirExplanationOfBenefitAccident.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
end;

procedure TFhirExplanationOfBenefitAccident.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location[x]', 'Address|Reference(Location)', false, TFhirType, FLocation.Link));{2}
end;

function TFhirExplanationOfBenefitAccident.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'date') then
  begin
    DateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then
  begin
    Location := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitAccident.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitAccident.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'date') then result := TFhirDate.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitAccident.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'date') then result := 'date'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'location[x]') then result := 'Address|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitAccident.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'date') then DateElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then LocationElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitAccident.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'date') then DateElement := asDate(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'location', ['Address', 'Reference'])) then LocationElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitAccident.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitAccident.fhirType : string;
begin
  result := 'accident';
end;

function TFhirExplanationOfBenefitAccident.Link : TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident(inherited Link);
end;

function TFhirExplanationOfBenefitAccident.Clone : TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident(inherited Clone);
end;

function TFhirExplanationOfBenefitAccident.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitAccident;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitAccident)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitAccident(other);
    result := compareDeep(dateElement, o.dateElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(locationElement, o.locationElement, true);
  end;
end;

function TFhirExplanationOfBenefitAccident.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDate) and isEmptyProp(FType_) and isEmptyProp(FLocation);
end;

procedure TFhirExplanationOfBenefitAccident.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('date');
  fields.add('type');
  fields.add('location[x]');
end;

{ TFhirExplanationOfBenefitAccident }

Procedure TFhirExplanationOfBenefitAccident.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirExplanationOfBenefitAccident.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirExplanationOfBenefitAccident.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

Procedure TFhirExplanationOfBenefitAccident.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirExplanationOfBenefitAccident.SetLocation(value : TFhirType);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirExplanationOfBenefitAccident.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDate.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAccidentListEnumerator }

Constructor TFhirExplanationOfBenefitAccidentListEnumerator.Create(list : TFhirExplanationOfBenefitAccidentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitAccidentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitAccidentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitAccidentListEnumerator.GetCurrent : TFhirExplanationOfBenefitAccident;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitAccidentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAccidentList }
procedure TFhirExplanationOfBenefitAccidentList.AddItem(value: TFhirExplanationOfBenefitAccident);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitAccident', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitAccident');
  add(value);
end;

function TFhirExplanationOfBenefitAccidentList.Append: TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAccidentList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitAccidentList.GetEnumerator : TFhirExplanationOfBenefitAccidentListEnumerator;
begin
  result := TFhirExplanationOfBenefitAccidentListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitAccidentList.Clone: TFhirExplanationOfBenefitAccidentList;
begin
  result := TFhirExplanationOfBenefitAccidentList(inherited Clone);
end;

function TFhirExplanationOfBenefitAccidentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitAccidentList.GetItemN(index: Integer): TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAccidentList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitAccident;
end;
function TFhirExplanationOfBenefitAccidentList.IndexOf(value: TFhirExplanationOfBenefitAccident): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitAccidentList.Insert(index: Integer): TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAccidentList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitAccident);
begin
  assert(value is TFhirExplanationOfBenefitAccident);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitAccidentList.Item(index: Integer): TFhirExplanationOfBenefitAccident;
begin
  result := TFhirExplanationOfBenefitAccident(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAccidentList.Link: TFhirExplanationOfBenefitAccidentList;
begin
  result := TFhirExplanationOfBenefitAccidentList(inherited Link);
end;

procedure TFhirExplanationOfBenefitAccidentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitAccidentList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitAccident);
begin
  assert(value is TFhirExplanationOfBenefitAccident);
  FhirExplanationOfBenefitAccidents[index] := value;
end;

procedure TFhirExplanationOfBenefitAccidentList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitAccident);
begin
  assert(value is TFhirExplanationOfBenefitAccident);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitItem }

constructor TFhirExplanationOfBenefitItem.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitItem.Destroy;
begin
  FSequence.free;
  FCareTeamSequenceList.Free;
  FDiagnosisSequenceList.Free;
  FProcedureSequenceList.Free;
  FInformationSequenceList.Free;
  FRevenue.free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FServiced.free;
  FLocation.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  FBodySite.free;
  FSubSiteList.Free;
  FEncounterList.Free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitItem.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitItem(oSource).sequenceElement.Clone;
  if (TFhirExplanationOfBenefitItem(oSource).FCareTeamSequenceList = nil) then
  begin
    FCareTeamSequenceList.free;
    FCareTeamSequenceList := nil;
  end
  else
  begin
    if FCareTeamSequenceList = nil then
      FCareTeamSequenceList := TFhirPositiveIntList.Create;
    FCareTeamSequenceList.Assign(TFhirExplanationOfBenefitItem(oSource).FCareTeamSequenceList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FDiagnosisSequenceList = nil) then
  begin
    FDiagnosisSequenceList.free;
    FDiagnosisSequenceList := nil;
  end
  else
  begin
    if FDiagnosisSequenceList = nil then
      FDiagnosisSequenceList := TFhirPositiveIntList.Create;
    FDiagnosisSequenceList.Assign(TFhirExplanationOfBenefitItem(oSource).FDiagnosisSequenceList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FProcedureSequenceList = nil) then
  begin
    FProcedureSequenceList.free;
    FProcedureSequenceList := nil;
  end
  else
  begin
    if FProcedureSequenceList = nil then
      FProcedureSequenceList := TFhirPositiveIntList.Create;
    FProcedureSequenceList.Assign(TFhirExplanationOfBenefitItem(oSource).FProcedureSequenceList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FInformationSequenceList = nil) then
  begin
    FInformationSequenceList.free;
    FInformationSequenceList := nil;
  end
  else
  begin
    if FInformationSequenceList = nil then
      FInformationSequenceList := TFhirPositiveIntList.Create;
    FInformationSequenceList.Assign(TFhirExplanationOfBenefitItem(oSource).FInformationSequenceList);
  end;
  revenue := TFhirExplanationOfBenefitItem(oSource).revenue.Clone;
  category := TFhirExplanationOfBenefitItem(oSource).category.Clone;
  productOrService := TFhirExplanationOfBenefitItem(oSource).productOrService.Clone;
  if (TFhirExplanationOfBenefitItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitItem(oSource).FModifierList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirExplanationOfBenefitItem(oSource).FProgramCodeList);
  end;
  serviced := TFhirExplanationOfBenefitItem(oSource).serviced.Clone;
  location := TFhirExplanationOfBenefitItem(oSource).location.Clone;
  quantity := TFhirExplanationOfBenefitItem(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitItem(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitItem(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitItem(oSource).net.Clone;
  if (TFhirExplanationOfBenefitItem(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList{TFhirDevice}.Create;
    FUdiList.Assign(TFhirExplanationOfBenefitItem(oSource).FUdiList);
  end;
  bodySite := TFhirExplanationOfBenefitItem(oSource).bodySite.Clone;
  if (TFhirExplanationOfBenefitItem(oSource).FSubSiteList = nil) then
  begin
    FSubSiteList.free;
    FSubSiteList := nil;
  end
  else
  begin
    if FSubSiteList = nil then
      FSubSiteList := TFhirCodeableConceptList.Create;
    FSubSiteList.Assign(TFhirExplanationOfBenefitItem(oSource).FSubSiteList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FEncounterList = nil) then
  begin
    FEncounterList.free;
    FEncounterList := nil;
  end
  else
  begin
    if FEncounterList = nil then
      FEncounterList := TFhirReferenceList{TFhirEncounter}.Create;
    FEncounterList.Assign(TFhirExplanationOfBenefitItem(oSource).FEncounterList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitItem(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitItem(oSource).FAdjudicationList);
  end;
  if (TFhirExplanationOfBenefitItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirExplanationOfBenefitItemDetailList.Create;
    FDetailList.Assign(TFhirExplanationOfBenefitItem(oSource).FDetailList);
  end;
end;

procedure TFhirExplanationOfBenefitItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'careTeamSequence') Then
    list.addAll(self, 'careTeamSequence', FCareTeamSequenceList);
  if (child_name = 'diagnosisSequence') Then
    list.addAll(self, 'diagnosisSequence', FDiagnosisSequenceList);
  if (child_name = 'procedureSequence') Then
    list.addAll(self, 'procedureSequence', FProcedureSequenceList);
  if (child_name = 'informationSequence') Then
    list.addAll(self, 'informationSequence', FInformationSequenceList);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'subSite') Then
    list.addAll(self, 'subSite', FSubSiteList);
  if (child_name = 'encounter') Then
    list.addAll(self, 'encounter', FEncounterList);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirExplanationOfBenefitItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'careTeamSequence', 'positiveInt', true, TFhirPositiveInt, FCareTeamSequenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'diagnosisSequence', 'positiveInt', true, TFhirPositiveInt, FDiagnosisSequenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'procedureSequence', 'positiveInt', true, TFhirPositiveInt, FProcedureSequenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'informationSequence', 'positiveInt', true, TFhirPositiveInt, FInformationSequenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirType, FServiced.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location[x]', 'CodeableConcept|Address|Reference(Location)', false, TFhirType, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference(Device)', true, TFhirReference{TFhirDevice}, FUdiList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subSite', 'CodeableConcept', true, TFhirCodeableConcept, FSubSiteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', true, TFhirReference{TFhirEncounter}, FEncounterList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'detail', '', true, TFhirExplanationOfBenefitItemDetail, FDetailList.Link)){3};
end;

function TFhirExplanationOfBenefitItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'careTeamSequence') then
  begin
    CareTeamSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'diagnosisSequence') then
  begin
    DiagnosisSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'procedureSequence') then
  begin
    ProcedureSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'informationSequence') then
  begin
    InformationSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then
  begin
    Location := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference{TFhirDevice}){2a};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subSite') then
  begin
    SubSiteList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    EncounterList.add(propValue as TFhirReference{TFhirEncounter}){2a};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication){2a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirExplanationOfBenefitItemDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'careTeamSequence') then CareTeamSequenceList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'diagnosisSequence') then DiagnosisSequenceList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'procedureSequence') then ProcedureSequenceList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'informationSequence') then InformationSequenceList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference{TFhirDevice}){2a}
  else if (propName = 'subSite') then SubSiteList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'encounter') then EncounterList.insertItem(index, propValue as TFhirReference{TFhirEncounter}){2a}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirExplanationOfBenefitItemDetail){2a}
  else inherited;
end;

function TFhirExplanationOfBenefitItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'careTeamSequence') then result := CareTeamSequenceList.new(){2}
  else if (propName = 'diagnosisSequence') then result := DiagnosisSequenceList.new(){2}
  else if (propName = 'procedureSequence') then result := ProcedureSequenceList.new(){2}
  else if (propName = 'informationSequence') then result := InformationSequenceList.new(){2}
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'programCode') then result := ProgramCodeList.new(){2}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced'){4x}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location'){4x}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else if (propName = 'udi') then result := UdiList.new(){2}
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subSite') then result := SubSiteList.new(){2}
  else if (propName = 'encounter') then result := EncounterList.new(){2}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'careTeamSequence') then result := 'positiveInt'
  else if (propName = 'diagnosisSequence') then result := 'positiveInt'
  else if (propName = 'procedureSequence') then result := 'positiveInt'
  else if (propName = 'informationSequence') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'location[x]') then result := 'CodeableConcept|Address|Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'subSite') then result := 'CodeableConcept'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := ''
  else if (propName = 'detail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'careTeamSequence') then deletePropertyValue('careTeamSequence', CareTeamSequenceList, value) {2}
  else if (propName = 'diagnosisSequence') then deletePropertyValue('diagnosisSequence', DiagnosisSequenceList, value) {2}
  else if (propName = 'procedureSequence') then deletePropertyValue('procedureSequence', ProcedureSequenceList, value) {2}
  else if (propName = 'informationSequence') then deletePropertyValue('informationSequence', InformationSequenceList, value) {2}
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {2}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil{4x}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := nil{4x}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {2}
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'subSite') then deletePropertyValue('subSite', SubSiteList, value) {2}
  else if (propName = 'encounter') then deletePropertyValue('encounter', EncounterList, value) {2}
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'careTeamSequence') then replacePropertyValue('careTeamSequence', CareTeamSequenceList, existing, new) {2}
  else if (propName = 'diagnosisSequence') then replacePropertyValue('diagnosisSequence', DiagnosisSequenceList, existing, new) {2}
  else if (propName = 'procedureSequence') then replacePropertyValue('procedureSequence', ProcedureSequenceList, existing, new) {2}
  else if (propName = 'informationSequence') then replacePropertyValue('informationSequence', InformationSequenceList, existing, new) {2}
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {2}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := new as TFhirType{4x}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {2}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subSite') then replacePropertyValue('subSite', SubSiteList, existing, new) {2}
  else if (propName = 'encounter') then replacePropertyValue('encounter', EncounterList, existing, new) {2}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'careTeamSequence') then CareTeamSequenceList.move(source, destination){2}
  else if (propName = 'diagnosisSequence') then DiagnosisSequenceList.move(source, destination){2}
  else if (propName = 'procedureSequence') then ProcedureSequenceList.move(source, destination){2}
  else if (propName = 'informationSequence') then InformationSequenceList.move(source, destination){2}
  else if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination){2a}
  else if (propName = 'udi') then UdiList.move(source, destination){2a}
  else if (propName = 'subSite') then SubSiteList.move(source, destination){2a}
  else if (propName = 'encounter') then EncounterList.move(source, destination){2a}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitItem.fhirType : string;
begin
  result := 'item';
end;

function TFhirExplanationOfBenefitItem.Link : TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem(inherited Link);
end;

function TFhirExplanationOfBenefitItem.Clone : TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem(inherited Clone);
end;

function TFhirExplanationOfBenefitItem.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitItem)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitItem(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(careTeamSequenceList, o.careTeamSequenceList, true) and 
      compareDeep(diagnosisSequenceList, o.diagnosisSequenceList, true) and compareDeep(procedureSequenceList, o.procedureSequenceList, true) and 
      compareDeep(informationSequenceList, o.informationSequenceList, true) and compareDeep(revenueElement, o.revenueElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and 
      compareDeep(servicedElement, o.servicedElement, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(udiList, o.udiList, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and 
      compareDeep(subSiteList, o.subSiteList, true) and compareDeep(encounterList, o.encounterList, true) and 
      compareDeep(noteNumberList, o.noteNumberList, true) and compareDeep(adjudicationList, o.adjudicationList, true) and 
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirExplanationOfBenefitItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FcareTeamSequenceList) and isEmptyProp(FdiagnosisSequenceList) and isEmptyProp(FprocedureSequenceList) and isEmptyProp(FinformationSequenceList) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FServiced) and isEmptyProp(FLocation) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList) and isEmptyProp(FBodySite) and isEmptyProp(FsubSiteList) and isEmptyProp(FencounterList) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FdetailList);
end;

procedure TFhirExplanationOfBenefitItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('careTeamSequence');
  fields.add('diagnosisSequence');
  fields.add('procedureSequence');
  fields.add('informationSequence');
  fields.add('revenue');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('serviced[x]');
  fields.add('location[x]');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
  fields.add('bodySite');
  fields.add('subSite');
  fields.add('encounter');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('detail');
end;

{ TFhirExplanationOfBenefitItem }

Procedure TFhirExplanationOfBenefitItem.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirExplanationOfBenefitItem.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirExplanationOfBenefitItem.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Function TFhirExplanationOfBenefitItem.GetCareTeamSequenceList : TFhirPositiveIntList;
begin
  if FCareTeamSequenceList = nil then
    FCareTeamSequenceList := TFhirPositiveIntList.Create;
  result := FCareTeamSequenceList;
end;

Function TFhirExplanationOfBenefitItem.GetHasCareTeamSequenceList : boolean;
begin
  result := (FCareTeamSequenceList <> nil) and (FCareTeamSequenceList.count > 0);
end;

Function TFhirExplanationOfBenefitItem.GetDiagnosisSequenceList : TFhirPositiveIntList;
begin
  if FDiagnosisSequenceList = nil then
    FDiagnosisSequenceList := TFhirPositiveIntList.Create;
  result := FDiagnosisSequenceList;
end;

Function TFhirExplanationOfBenefitItem.GetHasDiagnosisSequenceList : boolean;
begin
  result := (FDiagnosisSequenceList <> nil) and (FDiagnosisSequenceList.count > 0);
end;

Function TFhirExplanationOfBenefitItem.GetProcedureSequenceList : TFhirPositiveIntList;
begin
  if FProcedureSequenceList = nil then
    FProcedureSequenceList := TFhirPositiveIntList.Create;
  result := FProcedureSequenceList;
end;

Function TFhirExplanationOfBenefitItem.GetHasProcedureSequenceList : boolean;
begin
  result := (FProcedureSequenceList <> nil) and (FProcedureSequenceList.count > 0);
end;

Function TFhirExplanationOfBenefitItem.GetInformationSequenceList : TFhirPositiveIntList;
begin
  if FInformationSequenceList = nil then
    FInformationSequenceList := TFhirPositiveIntList.Create;
  result := FInformationSequenceList;
end;

Function TFhirExplanationOfBenefitItem.GetHasInformationSequenceList : boolean;
begin
  result := (FInformationSequenceList <> nil) and (FInformationSequenceList.count > 0);
end;

Procedure TFhirExplanationOfBenefitItem.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

Procedure TFhirExplanationOfBenefitItem.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirExplanationOfBenefitItem.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

Function TFhirExplanationOfBenefitItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirExplanationOfBenefitItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Function TFhirExplanationOfBenefitItem.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

Function TFhirExplanationOfBenefitItem.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

Procedure TFhirExplanationOfBenefitItem.SetServiced(value : TFhirType);
begin
  FServiced.free;
  FServiced := value;
end;

Procedure TFhirExplanationOfBenefitItem.SetLocation(value : TFhirType);
begin
  FLocation.free;
  FLocation := value;
end;

Procedure TFhirExplanationOfBenefitItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirExplanationOfBenefitItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirExplanationOfBenefitItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirExplanationOfBenefitItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirExplanationOfBenefitItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirExplanationOfBenefitItem.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

Function TFhirExplanationOfBenefitItem.GetUdiList : TFhirReferenceList{TFhirDevice};
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList{TFhirDevice}.Create;
  result := FUdiList;
end;

Function TFhirExplanationOfBenefitItem.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

Procedure TFhirExplanationOfBenefitItem.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

Function TFhirExplanationOfBenefitItem.GetSubSiteList : TFhirCodeableConceptList;
begin
  if FSubSiteList = nil then
    FSubSiteList := TFhirCodeableConceptList.Create;
  result := FSubSiteList;
end;

Function TFhirExplanationOfBenefitItem.GetHasSubSiteList : boolean;
begin
  result := (FSubSiteList <> nil) and (FSubSiteList.count > 0);
end;

Function TFhirExplanationOfBenefitItem.GetEncounterList : TFhirReferenceList{TFhirEncounter};
begin
  if FEncounterList = nil then
    FEncounterList := TFhirReferenceList{TFhirEncounter}.Create;
  result := FEncounterList;
end;

Function TFhirExplanationOfBenefitItem.GetHasEncounterList : boolean;
begin
  result := (FEncounterList <> nil) and (FEncounterList.count > 0);
end;

Function TFhirExplanationOfBenefitItem.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirExplanationOfBenefitItem.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirExplanationOfBenefitItem.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirExplanationOfBenefitItem.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

Function TFhirExplanationOfBenefitItem.GetDetailList : TFhirExplanationOfBenefitItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirExplanationOfBenefitItemDetailList.Create;
  result := FDetailList;
end;

Function TFhirExplanationOfBenefitItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirExplanationOfBenefitItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FcareTeamSequenceList.sizeInBytes);
  inc(result, FdiagnosisSequenceList.sizeInBytes);
  inc(result, FprocedureSequenceList.sizeInBytes);
  inc(result, FinformationSequenceList.sizeInBytes);
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FServiced.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FsubSiteList.sizeInBytes);
  inc(result, FencounterList.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemListEnumerator }

Constructor TFhirExplanationOfBenefitItemListEnumerator.Create(list : TFhirExplanationOfBenefitItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitItemListEnumerator.GetCurrent : TFhirExplanationOfBenefitItem;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemList }
procedure TFhirExplanationOfBenefitItemList.AddItem(value: TFhirExplanationOfBenefitItem);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitItem');
  add(value);
end;

function TFhirExplanationOfBenefitItemList.Append: TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitItemList.GetEnumerator : TFhirExplanationOfBenefitItemListEnumerator;
begin
  result := TFhirExplanationOfBenefitItemListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitItemList.Clone: TFhirExplanationOfBenefitItemList;
begin
  result := TFhirExplanationOfBenefitItemList(inherited Clone);
end;

function TFhirExplanationOfBenefitItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitItemList.GetItemN(index: Integer): TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitItem;
end;
function TFhirExplanationOfBenefitItemList.IndexOf(value: TFhirExplanationOfBenefitItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitItemList.Insert(index: Integer): TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitItem);
begin
  assert(value is TFhirExplanationOfBenefitItem);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitItemList.Item(index: Integer): TFhirExplanationOfBenefitItem;
begin
  result := TFhirExplanationOfBenefitItem(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemList.Link: TFhirExplanationOfBenefitItemList;
begin
  result := TFhirExplanationOfBenefitItemList(inherited Link);
end;

procedure TFhirExplanationOfBenefitItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitItemList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitItem);
begin
  assert(value is TFhirExplanationOfBenefitItem);
  FhirExplanationOfBenefitItems[index] := value;
end;

procedure TFhirExplanationOfBenefitItemList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitItem);
begin
  assert(value is TFhirExplanationOfBenefitItem);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitItemAdjudication }

constructor TFhirExplanationOfBenefitItemAdjudication.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitItemAdjudication.Destroy;
begin
  FCategory.free;
  FReason.free;
  FAmount.free;
  FValue.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitItemAdjudication.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirExplanationOfBenefitItemAdjudication(oSource).category.Clone;
  reason := TFhirExplanationOfBenefitItemAdjudication(oSource).reason.Clone;
  amount := TFhirExplanationOfBenefitItemAdjudication(oSource).amount.Clone;
  valueElement := TFhirExplanationOfBenefitItemAdjudication(oSource).valueElement.Clone;
end;

procedure TFhirExplanationOfBenefitItemAdjudication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'decimal', false, TFhirDecimal, FValue.Link));{2}
end;

function TFhirExplanationOfBenefitItemAdjudication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitItemAdjudication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'amount') then result := TFhirMoney.create(){4b}
  else if (propName = 'value') then result := TFhirDecimal.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitItemAdjudication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Money'
  else if (propName = 'value') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney{4}
  else if (propName = 'value') then ValueElement := asDecimal(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitItemAdjudication.fhirType : string;
begin
  result := 'adjudication';
end;

function TFhirExplanationOfBenefitItemAdjudication.Link : TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication(inherited Link);
end;

function TFhirExplanationOfBenefitItemAdjudication.Clone : TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication(inherited Clone);
end;

function TFhirExplanationOfBenefitItemAdjudication.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitItemAdjudication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitItemAdjudication)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitItemAdjudication(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(reasonElement, o.reasonElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirExplanationOfBenefitItemAdjudication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FReason) and isEmptyProp(FAmount) and isEmptyProp(FValue);
end;

procedure TFhirExplanationOfBenefitItemAdjudication.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('reason');
  fields.add('amount');
  fields.add('value');
end;

{ TFhirExplanationOfBenefitItemAdjudication }

Procedure TFhirExplanationOfBenefitItemAdjudication.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirExplanationOfBenefitItemAdjudication.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

Procedure TFhirExplanationOfBenefitItemAdjudication.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

Procedure TFhirExplanationOfBenefitItemAdjudication.SetValue(value : TFhirDecimal);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirExplanationOfBenefitItemAdjudication.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirExplanationOfBenefitItemAdjudication.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirDecimal.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirExplanationOfBenefitItemAdjudication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemAdjudicationListEnumerator }

Constructor TFhirExplanationOfBenefitItemAdjudicationListEnumerator.Create(list : TFhirExplanationOfBenefitItemAdjudicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitItemAdjudicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitItemAdjudicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitItemAdjudicationListEnumerator.GetCurrent : TFhirExplanationOfBenefitItemAdjudication;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitItemAdjudicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemAdjudicationList }
procedure TFhirExplanationOfBenefitItemAdjudicationList.AddItem(value: TFhirExplanationOfBenefitItemAdjudication);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitItemAdjudication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitItemAdjudication');
  add(value);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Append: TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemAdjudicationList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitItemAdjudicationList.GetEnumerator : TFhirExplanationOfBenefitItemAdjudicationListEnumerator;
begin
  result := TFhirExplanationOfBenefitItemAdjudicationListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Clone: TFhirExplanationOfBenefitItemAdjudicationList;
begin
  result := TFhirExplanationOfBenefitItemAdjudicationList(inherited Clone);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitItemAdjudicationList.GetItemN(index: Integer): TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitItemAdjudication;
end;
function TFhirExplanationOfBenefitItemAdjudicationList.IndexOf(value: TFhirExplanationOfBenefitItemAdjudication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Insert(index: Integer): TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemAdjudicationList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitItemAdjudication);
begin
  assert(value is TFhirExplanationOfBenefitItemAdjudication);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Item(index: Integer): TFhirExplanationOfBenefitItemAdjudication;
begin
  result := TFhirExplanationOfBenefitItemAdjudication(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemAdjudicationList.Link: TFhirExplanationOfBenefitItemAdjudicationList;
begin
  result := TFhirExplanationOfBenefitItemAdjudicationList(inherited Link);
end;

procedure TFhirExplanationOfBenefitItemAdjudicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitItemAdjudicationList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitItemAdjudication);
begin
  assert(value is TFhirExplanationOfBenefitItemAdjudication);
  FhirExplanationOfBenefitItemAdjudications[index] := value;
end;

procedure TFhirExplanationOfBenefitItemAdjudicationList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitItemAdjudication);
begin
  assert(value is TFhirExplanationOfBenefitItemAdjudication);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitItemDetail }

constructor TFhirExplanationOfBenefitItemDetail.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitItemDetail.Destroy;
begin
  FSequence.free;
  FRevenue.free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FSubDetailList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitItemDetail(oSource).sequenceElement.Clone;
  revenue := TFhirExplanationOfBenefitItemDetail(oSource).revenue.Clone;
  category := TFhirExplanationOfBenefitItemDetail(oSource).category.Clone;
  productOrService := TFhirExplanationOfBenefitItemDetail(oSource).productOrService.Clone;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FModifierList);
  end;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FProgramCodeList);
  end;
  quantity := TFhirExplanationOfBenefitItemDetail(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitItemDetail(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitItemDetail(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitItemDetail(oSource).net.Clone;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList{TFhirDevice}.Create;
    FUdiList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FUdiList);
  end;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FAdjudicationList);
  end;
  if (TFhirExplanationOfBenefitItemDetail(oSource).FSubDetailList = nil) then
  begin
    FSubDetailList.free;
    FSubDetailList := nil;
  end
  else
  begin
    if FSubDetailList = nil then
      FSubDetailList := TFhirExplanationOfBenefitItemDetailSubDetailList.Create;
    FSubDetailList.Assign(TFhirExplanationOfBenefitItemDetail(oSource).FSubDetailList);
  end;
end;

procedure TFhirExplanationOfBenefitItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'subDetail') Then
    list.addAll(self, 'subDetail', FSubDetailList);
end;

procedure TFhirExplanationOfBenefitItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference(Device)', true, TFhirReference{TFhirDevice}, FUdiList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '@ExplanationOfBenefit.item.adjudication', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subDetail', '', true, TFhirExplanationOfBenefitItemDetailSubDetail, FSubDetailList.Link)){3};
end;

function TFhirExplanationOfBenefitItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference{TFhirDevice}){2a};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication){2a};
    result := propValue;
  end
  else if (propName = 'subDetail') then
  begin
    SubDetailList.add(propValue as TFhirExplanationOfBenefitItemDetailSubDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference{TFhirDevice}){2a}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication){2a}
  else if (propName = 'subDetail') then SubDetailList.insertItem(index, propValue as TFhirExplanationOfBenefitItemDetailSubDetail){2a}
  else inherited;
end;

function TFhirExplanationOfBenefitItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'programCode') then result := ProgramCodeList.new(){2}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else if (propName = 'udi') then result := UdiList.new(){2}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else if (propName = 'subDetail') then result := SubDetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := '@ExplanationOfBenefit.item.adjudication'
  else if (propName = 'subDetail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {2}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {2}
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else if (propName = 'subDetail') then deletePropertyValue('subDetail', SubDetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {2}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {2}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else if (propName = 'subDetail') then replacePropertyValue('subDetail', SubDetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination){2a}
  else if (propName = 'udi') then UdiList.move(source, destination){2a}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else if (propName = 'subDetail') then SubDetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitItemDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirExplanationOfBenefitItemDetail.Link : TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail(inherited Link);
end;

function TFhirExplanationOfBenefitItemDetail.Clone : TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail(inherited Clone);
end;

function TFhirExplanationOfBenefitItemDetail.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitItemDetail)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitItemDetail(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(revenueElement, o.revenueElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(udiList, o.udiList, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true) and compareDeep(subDetailList, o.subDetailList, true);
  end;
end;

function TFhirExplanationOfBenefitItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FsubDetailList);
end;

procedure TFhirExplanationOfBenefitItemDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('revenue');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('subDetail');
end;

{ TFhirExplanationOfBenefitItemDetail }

Procedure TFhirExplanationOfBenefitItemDetail.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirExplanationOfBenefitItemDetail.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirExplanationOfBenefitItemDetail.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirExplanationOfBenefitItemDetail.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

Procedure TFhirExplanationOfBenefitItemDetail.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirExplanationOfBenefitItemDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

Function TFhirExplanationOfBenefitItemDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirExplanationOfBenefitItemDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Function TFhirExplanationOfBenefitItemDetail.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

Function TFhirExplanationOfBenefitItemDetail.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

Procedure TFhirExplanationOfBenefitItemDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirExplanationOfBenefitItemDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirExplanationOfBenefitItemDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirExplanationOfBenefitItemDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirExplanationOfBenefitItemDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirExplanationOfBenefitItemDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

Function TFhirExplanationOfBenefitItemDetail.GetUdiList : TFhirReferenceList{TFhirDevice};
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList{TFhirDevice}.Create;
  result := FUdiList;
end;

Function TFhirExplanationOfBenefitItemDetail.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

Function TFhirExplanationOfBenefitItemDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirExplanationOfBenefitItemDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirExplanationOfBenefitItemDetail.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirExplanationOfBenefitItemDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

Function TFhirExplanationOfBenefitItemDetail.GetSubDetailList : TFhirExplanationOfBenefitItemDetailSubDetailList;
begin
  if FSubDetailList = nil then
    FSubDetailList := TFhirExplanationOfBenefitItemDetailSubDetailList.Create;
  result := FSubDetailList;
end;

Function TFhirExplanationOfBenefitItemDetail.GetHasSubDetailList : boolean;
begin
  result := (FSubDetailList <> nil) and (FSubDetailList.count > 0);
end;

function TFhirExplanationOfBenefitItemDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FsubDetailList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemDetailListEnumerator }

Constructor TFhirExplanationOfBenefitItemDetailListEnumerator.Create(list : TFhirExplanationOfBenefitItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitItemDetailListEnumerator.GetCurrent : TFhirExplanationOfBenefitItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitItemDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemDetailList }
procedure TFhirExplanationOfBenefitItemDetailList.AddItem(value: TFhirExplanationOfBenefitItemDetail);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitItemDetail');
  add(value);
end;

function TFhirExplanationOfBenefitItemDetailList.Append: TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitItemDetailList.GetEnumerator : TFhirExplanationOfBenefitItemDetailListEnumerator;
begin
  result := TFhirExplanationOfBenefitItemDetailListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitItemDetailList.Clone: TFhirExplanationOfBenefitItemDetailList;
begin
  result := TFhirExplanationOfBenefitItemDetailList(inherited Clone);
end;

function TFhirExplanationOfBenefitItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitItemDetailList.GetItemN(index: Integer): TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitItemDetail;
end;
function TFhirExplanationOfBenefitItemDetailList.IndexOf(value: TFhirExplanationOfBenefitItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitItemDetailList.Insert(index: Integer): TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemDetailList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetail);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitItemDetailList.Item(index: Integer): TFhirExplanationOfBenefitItemDetail;
begin
  result := TFhirExplanationOfBenefitItemDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemDetailList.Link: TFhirExplanationOfBenefitItemDetailList;
begin
  result := TFhirExplanationOfBenefitItemDetailList(inherited Link);
end;

procedure TFhirExplanationOfBenefitItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitItemDetailList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetail);
  FhirExplanationOfBenefitItemDetails[index] := value;
end;

procedure TFhirExplanationOfBenefitItemDetailList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitItemDetailSubDetail }

constructor TFhirExplanationOfBenefitItemDetailSubDetail.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitItemDetailSubDetail.Destroy;
begin
  FSequence.free;
  FRevenue.free;
  FCategory.free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FUdiList.Free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).sequenceElement.Clone;
  revenue := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).revenue.Clone;
  category := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).category.Clone;
  productOrService := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).productOrService.Clone;
  if (TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FModifierList);
  end;
  if (TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FProgramCodeList);
  end;
  quantity := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitItemDetailSubDetail(oSource).net.Clone;
  if (TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FUdiList = nil) then
  begin
    FUdiList.free;
    FUdiList := nil;
  end
  else
  begin
    if FUdiList = nil then
      FUdiList := TFhirReferenceList{TFhirDevice}.Create;
    FUdiList.Assign(TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FUdiList);
  end;
  if (TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitItemDetailSubDetail(oSource).FAdjudicationList);
  end;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'revenue') Then
     list.add(self.link, 'revenue', FRevenue.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'udi') Then
    list.addAll(self, 'udi', FUdiList);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'revenue', 'CodeableConcept', false, TFhirCodeableConcept, FRevenue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'udi', 'Reference(Device)', true, TFhirReference{TFhirDevice}, FUdiList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '@ExplanationOfBenefit.item.adjudication', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link)){3};
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'revenue') then
  begin
    Revenue := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'udi') then
  begin
    UdiList.add(propValue as TFhirReference{TFhirDevice}){2a};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'udi') then UdiList.insertItem(index, propValue as TFhirReference{TFhirDevice}){2a}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication){2a}
  else inherited;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'revenue') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'programCode') then result := ProgramCodeList.new(){2}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else if (propName = 'udi') then result := UdiList.new(){2}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'revenue') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'udi') then result := 'Reference'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := '@ExplanationOfBenefit.item.adjudication'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'revenue') then RevenueElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {2}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'udi') then deletePropertyValue('udi', UdiList, value) {2}
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (propName = 'revenue') then RevenueElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {2}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else if (propName = 'udi') then replacePropertyValue('udi', UdiList, existing, new) {2}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination){2a}
  else if (propName = 'udi') then UdiList.move(source, destination){2a}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.fhirType : string;
begin
  result := 'subDetail';
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.Link : TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail(inherited Link);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.Clone : TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail(inherited Clone);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitItemDetailSubDetail)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitItemDetailSubDetail(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(revenueElement, o.revenueElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(programCodeList, o.programCodeList, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(unitPriceElement, o.unitPriceElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(udiList, o.udiList, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true);
  end;
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FRevenue) and isEmptyProp(FCategory) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FudiList) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('revenue');
  fields.add('category');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('udi');
  fields.add('noteNumber');
  fields.add('adjudication');
end;

{ TFhirExplanationOfBenefitItemDetailSubDetail }

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetRevenue(value : TFhirCodeableConcept);
begin
  FRevenue.free;
  FRevenue := value;
end;

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirExplanationOfBenefitItemDetailSubDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetUdiList : TFhirReferenceList{TFhirDevice};
begin
  if FUdiList = nil then
    FUdiList := TFhirReferenceList{TFhirDevice}.Create;
  result := FUdiList;
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetHasUdiList : boolean;
begin
  result := (FUdiList <> nil) and (FUdiList.count > 0);
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirExplanationOfBenefitItemDetailSubDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirExplanationOfBenefitItemDetailSubDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FRevenue.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FudiList.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator }

Constructor TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.Create(list : TFhirExplanationOfBenefitItemDetailSubDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.GetCurrent : TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitItemDetailSubDetailList }
procedure TFhirExplanationOfBenefitItemDetailSubDetailList.AddItem(value: TFhirExplanationOfBenefitItemDetailSubDetail);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitItemDetailSubDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitItemDetailSubDetail');
  add(value);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Append: TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.GetEnumerator : TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetailListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Clone: TFhirExplanationOfBenefitItemDetailSubDetailList;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetailList(inherited Clone);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.GetItemN(index: Integer): TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail;
end;
function TFhirExplanationOfBenefitItemDetailSubDetailList.IndexOf(value: TFhirExplanationOfBenefitItemDetailSubDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Insert(index: Integer): TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetailSubDetail);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Item(index: Integer): TFhirExplanationOfBenefitItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitItemDetailSubDetailList.Link: TFhirExplanationOfBenefitItemDetailSubDetailList;
begin
  result := TFhirExplanationOfBenefitItemDetailSubDetailList(inherited Link);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetailSubDetail);
  FhirExplanationOfBenefitItemDetailSubDetails[index] := value;
end;

procedure TFhirExplanationOfBenefitItemDetailSubDetailList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitItemDetailSubDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitAddItem }

constructor TFhirExplanationOfBenefitAddItem.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitAddItem.Destroy;
begin
  FItemSequenceList.Free;
  FDetailSequenceList.Free;
  FSubDetailSequenceList.Free;
  FProviderList.Free;
  FProductOrService.free;
  FModifierList.Free;
  FProgramCodeList.Free;
  FServiced.free;
  FLocation.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FBodySite.free;
  FSubSiteList.Free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitAddItem.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirExplanationOfBenefitAddItem(oSource).FItemSequenceList = nil) then
  begin
    FItemSequenceList.free;
    FItemSequenceList := nil;
  end
  else
  begin
    if FItemSequenceList = nil then
      FItemSequenceList := TFhirPositiveIntList.Create;
    FItemSequenceList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FItemSequenceList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FDetailSequenceList = nil) then
  begin
    FDetailSequenceList.free;
    FDetailSequenceList := nil;
  end
  else
  begin
    if FDetailSequenceList = nil then
      FDetailSequenceList := TFhirPositiveIntList.Create;
    FDetailSequenceList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FDetailSequenceList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FSubDetailSequenceList = nil) then
  begin
    FSubDetailSequenceList.free;
    FSubDetailSequenceList := nil;
  end
  else
  begin
    if FSubDetailSequenceList = nil then
      FSubDetailSequenceList := TFhirPositiveIntList.Create;
    FSubDetailSequenceList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FSubDetailSequenceList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FProviderList = nil) then
  begin
    FProviderList.free;
    FProviderList := nil;
  end
  else
  begin
    if FProviderList = nil then
      FProviderList := TFhirReferenceList{TFhirPractitioner}.Create;
    FProviderList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FProviderList);
  end;
  productOrService := TFhirExplanationOfBenefitAddItem(oSource).productOrService.Clone;
  if (TFhirExplanationOfBenefitAddItem(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FModifierList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FProgramCodeList = nil) then
  begin
    FProgramCodeList.free;
    FProgramCodeList := nil;
  end
  else
  begin
    if FProgramCodeList = nil then
      FProgramCodeList := TFhirCodeableConceptList.Create;
    FProgramCodeList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FProgramCodeList);
  end;
  serviced := TFhirExplanationOfBenefitAddItem(oSource).serviced.Clone;
  location := TFhirExplanationOfBenefitAddItem(oSource).location.Clone;
  quantity := TFhirExplanationOfBenefitAddItem(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitAddItem(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitAddItem(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitAddItem(oSource).net.Clone;
  bodySite := TFhirExplanationOfBenefitAddItem(oSource).bodySite.Clone;
  if (TFhirExplanationOfBenefitAddItem(oSource).FSubSiteList = nil) then
  begin
    FSubSiteList.free;
    FSubSiteList := nil;
  end
  else
  begin
    if FSubSiteList = nil then
      FSubSiteList := TFhirCodeableConceptList.Create;
    FSubSiteList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FSubSiteList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FAdjudicationList);
  end;
  if (TFhirExplanationOfBenefitAddItem(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirExplanationOfBenefitAddItemDetailList.Create;
    FDetailList.Assign(TFhirExplanationOfBenefitAddItem(oSource).FDetailList);
  end;
end;

procedure TFhirExplanationOfBenefitAddItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'itemSequence') Then
    list.addAll(self, 'itemSequence', FItemSequenceList);
  if (child_name = 'detailSequence') Then
    list.addAll(self, 'detailSequence', FDetailSequenceList);
  if (child_name = 'subDetailSequence') Then
    list.addAll(self, 'subDetailSequence', FSubDetailSequenceList);
  if (child_name = 'provider') Then
    list.addAll(self, 'provider', FProviderList);
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'programCode') Then
    list.addAll(self, 'programCode', FProgramCodeList);
  if (child_name = 'serviced[x]') or (child_name = 'serviced') Then
     list.add(self.link, 'serviced[x]', FServiced.Link);
  if (child_name = 'location[x]') or (child_name = 'location') Then
     list.add(self.link, 'location[x]', FLocation.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'subSite') Then
    list.addAll(self, 'subSite', FSubSiteList);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirExplanationOfBenefitAddItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'itemSequence', 'positiveInt', true, TFhirPositiveInt, FItemSequenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'detailSequence', 'positiveInt', true, TFhirPositiveInt, FDetailSequenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subDetailSequence', 'positiveInt', true, TFhirPositiveInt, FSubDetailSequenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', true, TFhirReference{TFhirPractitioner}, FProviderList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'programCode', 'CodeableConcept', true, TFhirCodeableConcept, FProgramCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'serviced[x]', 'date|Period', false, TFhirType, FServiced.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location[x]', 'CodeableConcept|Address|Reference(Location)', false, TFhirType, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subSite', 'CodeableConcept', true, TFhirCodeableConcept, FSubSiteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '@ExplanationOfBenefit.item.adjudication', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'detail', '', true, TFhirExplanationOfBenefitAddItemDetail, FDetailList.Link)){3};
end;

function TFhirExplanationOfBenefitAddItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'itemSequence') then
  begin
    ItemSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'detailSequence') then
  begin
    DetailSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'subDetailSequence') then
  begin
    SubDetailSequenceList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'provider') then
  begin
    ProviderList.add(propValue as TFhirReference{TFhirPractitioner}){2a};
    result := propValue;
  end
  else if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'programCode') then
  begin
    ProgramCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then
  begin
    Serviced := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then
  begin
    Location := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subSite') then
  begin
    SubSiteList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication){2a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirExplanationOfBenefitAddItemDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitAddItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'itemSequence') then ItemSequenceList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'detailSequence') then DetailSequenceList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'subDetailSequence') then SubDetailSequenceList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'provider') then ProviderList.insertItem(index, propValue as TFhirReference{TFhirPractitioner}){2a}
  else if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'programCode') then ProgramCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'subSite') then SubSiteList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirExplanationOfBenefitAddItemDetail){2a}
  else inherited;
end;

function TFhirExplanationOfBenefitAddItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'itemSequence') then result := ItemSequenceList.new(){2}
  else if (propName = 'detailSequence') then result := DetailSequenceList.new(){2}
  else if (propName = 'subDetailSequence') then result := SubDetailSequenceList.new(){2}
  else if (propName = 'provider') then result := ProviderList.new(){2}
  else if (propName = 'productOrService') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'programCode') then result := ProgramCodeList.new(){2}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then raise EFHIRException.create('Cannot make property Serviced'){4x}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then raise EFHIRException.create('Cannot make property Location'){4x}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subSite') then result := SubSiteList.new(){2}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitAddItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'itemSequence') then result := 'positiveInt'
  else if (propName = 'detailSequence') then result := 'positiveInt'
  else if (propName = 'subDetailSequence') then result := 'positiveInt'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'programCode') then result := 'CodeableConcept'
  else if (propName = 'serviced[x]') then result := 'date|Period'
  else if (propName = 'location[x]') then result := 'CodeableConcept|Address|Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'subSite') then result := 'CodeableConcept'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := '@ExplanationOfBenefit.item.adjudication'
  else if (propName = 'detail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitAddItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'itemSequence') then deletePropertyValue('itemSequence', ItemSequenceList, value) {2}
  else if (propName = 'detailSequence') then deletePropertyValue('detailSequence', DetailSequenceList, value) {2}
  else if (propName = 'subDetailSequence') then deletePropertyValue('subDetailSequence', SubDetailSequenceList, value) {2}
  else if (propName = 'provider') then deletePropertyValue('provider', ProviderList, value) {2}
  else if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'programCode') then deletePropertyValue('programCode', ProgramCodeList, value) {2}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := nil{4x}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := nil{4x}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'subSite') then deletePropertyValue('subSite', SubSiteList, value) {2}
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitAddItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'itemSequence') then replacePropertyValue('itemSequence', ItemSequenceList, existing, new) {2}
  else if (propName = 'detailSequence') then replacePropertyValue('detailSequence', DetailSequenceList, existing, new) {2}
  else if (propName = 'subDetailSequence') then replacePropertyValue('subDetailSequence', SubDetailSequenceList, existing, new) {2}
  else if (propName = 'provider') then replacePropertyValue('provider', ProviderList, existing, new) {2}
  else if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'programCode') then replacePropertyValue('programCode', ProgramCodeList, existing, new) {2}
  else if (isMatchingName(propName, 'serviced', ['Date', 'Period'])) then ServicedElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'location', ['CodeableConcept', 'Address', 'Reference'])) then LocationElement := new as TFhirType{4x}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subSite') then replacePropertyValue('subSite', SubSiteList, existing, new) {2}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitAddItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'itemSequence') then ItemSequenceList.move(source, destination){2}
  else if (propName = 'detailSequence') then DetailSequenceList.move(source, destination){2}
  else if (propName = 'subDetailSequence') then SubDetailSequenceList.move(source, destination){2}
  else if (propName = 'provider') then ProviderList.move(source, destination){2a}
  else if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'programCode') then ProgramCodeList.move(source, destination){2a}
  else if (propName = 'subSite') then SubSiteList.move(source, destination){2a}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitAddItem.fhirType : string;
begin
  result := 'addItem';
end;

function TFhirExplanationOfBenefitAddItem.Link : TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem(inherited Link);
end;

function TFhirExplanationOfBenefitAddItem.Clone : TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItem.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitAddItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitAddItem)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitAddItem(other);
    result := compareDeep(itemSequenceList, o.itemSequenceList, true) and compareDeep(detailSequenceList, o.detailSequenceList, true) and 
      compareDeep(subDetailSequenceList, o.subDetailSequenceList, true) and compareDeep(providerList, o.providerList, true) and 
      compareDeep(productOrServiceElement, o.productOrServiceElement, true) and compareDeep(modifierList, o.modifierList, true) and 
      compareDeep(programCodeList, o.programCodeList, true) and compareDeep(servicedElement, o.servicedElement, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(netElement, o.netElement, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and 
      compareDeep(subSiteList, o.subSiteList, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true) and compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirExplanationOfBenefitAddItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FitemSequenceList) and isEmptyProp(FdetailSequenceList) and isEmptyProp(FsubDetailSequenceList) and isEmptyProp(FproviderList) and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FprogramCodeList) and isEmptyProp(FServiced) and isEmptyProp(FLocation) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FBodySite) and isEmptyProp(FsubSiteList) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FdetailList);
end;

procedure TFhirExplanationOfBenefitAddItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('itemSequence');
  fields.add('detailSequence');
  fields.add('subDetailSequence');
  fields.add('provider');
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('programCode');
  fields.add('serviced[x]');
  fields.add('location[x]');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('bodySite');
  fields.add('subSite');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('detail');
end;

{ TFhirExplanationOfBenefitAddItem }

Function TFhirExplanationOfBenefitAddItem.GetItemSequenceList : TFhirPositiveIntList;
begin
  if FItemSequenceList = nil then
    FItemSequenceList := TFhirPositiveIntList.Create;
  result := FItemSequenceList;
end;

Function TFhirExplanationOfBenefitAddItem.GetHasItemSequenceList : boolean;
begin
  result := (FItemSequenceList <> nil) and (FItemSequenceList.count > 0);
end;

Function TFhirExplanationOfBenefitAddItem.GetDetailSequenceList : TFhirPositiveIntList;
begin
  if FDetailSequenceList = nil then
    FDetailSequenceList := TFhirPositiveIntList.Create;
  result := FDetailSequenceList;
end;

Function TFhirExplanationOfBenefitAddItem.GetHasDetailSequenceList : boolean;
begin
  result := (FDetailSequenceList <> nil) and (FDetailSequenceList.count > 0);
end;

Function TFhirExplanationOfBenefitAddItem.GetSubDetailSequenceList : TFhirPositiveIntList;
begin
  if FSubDetailSequenceList = nil then
    FSubDetailSequenceList := TFhirPositiveIntList.Create;
  result := FSubDetailSequenceList;
end;

Function TFhirExplanationOfBenefitAddItem.GetHasSubDetailSequenceList : boolean;
begin
  result := (FSubDetailSequenceList <> nil) and (FSubDetailSequenceList.count > 0);
end;

Function TFhirExplanationOfBenefitAddItem.GetProviderList : TFhirReferenceList{TFhirPractitioner};
begin
  if FProviderList = nil then
    FProviderList := TFhirReferenceList{TFhirPractitioner}.Create;
  result := FProviderList;
end;

Function TFhirExplanationOfBenefitAddItem.GetHasProviderList : boolean;
begin
  result := (FProviderList <> nil) and (FProviderList.count > 0);
end;

Procedure TFhirExplanationOfBenefitAddItem.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

Function TFhirExplanationOfBenefitAddItem.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirExplanationOfBenefitAddItem.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Function TFhirExplanationOfBenefitAddItem.GetProgramCodeList : TFhirCodeableConceptList;
begin
  if FProgramCodeList = nil then
    FProgramCodeList := TFhirCodeableConceptList.Create;
  result := FProgramCodeList;
end;

Function TFhirExplanationOfBenefitAddItem.GetHasProgramCodeList : boolean;
begin
  result := (FProgramCodeList <> nil) and (FProgramCodeList.count > 0);
end;

Procedure TFhirExplanationOfBenefitAddItem.SetServiced(value : TFhirType);
begin
  FServiced.free;
  FServiced := value;
end;

Procedure TFhirExplanationOfBenefitAddItem.SetLocation(value : TFhirType);
begin
  FLocation.free;
  FLocation := value;
end;

Procedure TFhirExplanationOfBenefitAddItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirExplanationOfBenefitAddItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirExplanationOfBenefitAddItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirExplanationOfBenefitAddItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirExplanationOfBenefitAddItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirExplanationOfBenefitAddItem.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

Procedure TFhirExplanationOfBenefitAddItem.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

Function TFhirExplanationOfBenefitAddItem.GetSubSiteList : TFhirCodeableConceptList;
begin
  if FSubSiteList = nil then
    FSubSiteList := TFhirCodeableConceptList.Create;
  result := FSubSiteList;
end;

Function TFhirExplanationOfBenefitAddItem.GetHasSubSiteList : boolean;
begin
  result := (FSubSiteList <> nil) and (FSubSiteList.count > 0);
end;

Function TFhirExplanationOfBenefitAddItem.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirExplanationOfBenefitAddItem.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirExplanationOfBenefitAddItem.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirExplanationOfBenefitAddItem.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

Function TFhirExplanationOfBenefitAddItem.GetDetailList : TFhirExplanationOfBenefitAddItemDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirExplanationOfBenefitAddItemDetailList.Create;
  result := FDetailList;
end;

Function TFhirExplanationOfBenefitAddItem.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirExplanationOfBenefitAddItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FitemSequenceList.sizeInBytes);
  inc(result, FdetailSequenceList.sizeInBytes);
  inc(result, FsubDetailSequenceList.sizeInBytes);
  inc(result, FproviderList.sizeInBytes);
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FprogramCodeList.sizeInBytes);
  inc(result, FServiced.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FsubSiteList.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAddItemListEnumerator }

Constructor TFhirExplanationOfBenefitAddItemListEnumerator.Create(list : TFhirExplanationOfBenefitAddItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitAddItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitAddItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitAddItemListEnumerator.GetCurrent : TFhirExplanationOfBenefitAddItem;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitAddItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAddItemList }
procedure TFhirExplanationOfBenefitAddItemList.AddItem(value: TFhirExplanationOfBenefitAddItem);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitAddItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitAddItem');
  add(value);
end;

function TFhirExplanationOfBenefitAddItemList.Append: TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitAddItemList.GetEnumerator : TFhirExplanationOfBenefitAddItemListEnumerator;
begin
  result := TFhirExplanationOfBenefitAddItemListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitAddItemList.Clone: TFhirExplanationOfBenefitAddItemList;
begin
  result := TFhirExplanationOfBenefitAddItemList(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitAddItemList.GetItemN(index: Integer): TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitAddItem;
end;
function TFhirExplanationOfBenefitAddItemList.IndexOf(value: TFhirExplanationOfBenefitAddItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitAddItemList.Insert(index: Integer): TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitAddItem);
begin
  assert(value is TFhirExplanationOfBenefitAddItem);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitAddItemList.Item(index: Integer): TFhirExplanationOfBenefitAddItem;
begin
  result := TFhirExplanationOfBenefitAddItem(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemList.Link: TFhirExplanationOfBenefitAddItemList;
begin
  result := TFhirExplanationOfBenefitAddItemList(inherited Link);
end;

procedure TFhirExplanationOfBenefitAddItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitAddItemList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitAddItem);
begin
  assert(value is TFhirExplanationOfBenefitAddItem);
  FhirExplanationOfBenefitAddItems[index] := value;
end;

procedure TFhirExplanationOfBenefitAddItemList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitAddItem);
begin
  assert(value is TFhirExplanationOfBenefitAddItem);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitAddItemDetail }

constructor TFhirExplanationOfBenefitAddItemDetail.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitAddItemDetail.Destroy;
begin
  FProductOrService.free;
  FModifierList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  FSubDetailList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitAddItemDetail.Assign(oSource : TFslObject);
begin
  inherited;
  productOrService := TFhirExplanationOfBenefitAddItemDetail(oSource).productOrService.Clone;
  if (TFhirExplanationOfBenefitAddItemDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitAddItemDetail(oSource).FModifierList);
  end;
  quantity := TFhirExplanationOfBenefitAddItemDetail(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitAddItemDetail(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitAddItemDetail(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitAddItemDetail(oSource).net.Clone;
  if (TFhirExplanationOfBenefitAddItemDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitAddItemDetail(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitAddItemDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitAddItemDetail(oSource).FAdjudicationList);
  end;
  if (TFhirExplanationOfBenefitAddItemDetail(oSource).FSubDetailList = nil) then
  begin
    FSubDetailList.free;
    FSubDetailList := nil;
  end
  else
  begin
    if FSubDetailList = nil then
      FSubDetailList := TFhirExplanationOfBenefitAddItemDetailSubDetailList.Create;
    FSubDetailList.Assign(TFhirExplanationOfBenefitAddItemDetail(oSource).FSubDetailList);
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'subDetail') Then
    list.addAll(self, 'subDetail', FSubDetailList);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '@ExplanationOfBenefit.item.adjudication', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subDetail', '', true, TFhirExplanationOfBenefitAddItemDetailSubDetail, FSubDetailList.Link)){3};
end;

function TFhirExplanationOfBenefitAddItemDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication){2a};
    result := propValue;
  end
  else if (propName = 'subDetail') then
  begin
    SubDetailList.add(propValue as TFhirExplanationOfBenefitAddItemDetailSubDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication){2a}
  else if (propName = 'subDetail') then SubDetailList.insertItem(index, propValue as TFhirExplanationOfBenefitAddItemDetailSubDetail){2a}
  else inherited;
end;

function TFhirExplanationOfBenefitAddItemDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'productOrService') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else if (propName = 'subDetail') then result := SubDetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitAddItemDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := '@ExplanationOfBenefit.item.adjudication'
  else if (propName = 'subDetail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else if (propName = 'subDetail') then deletePropertyValue('subDetail', SubDetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else if (propName = 'subDetail') then replacePropertyValue('subDetail', SubDetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else if (propName = 'subDetail') then SubDetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitAddItemDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirExplanationOfBenefitAddItemDetail.Link : TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail(inherited Link);
end;

function TFhirExplanationOfBenefitAddItemDetail.Clone : TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItemDetail.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitAddItemDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitAddItemDetail)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitAddItemDetail(other);
    result := compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(netElement, o.netElement, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true) and compareDeep(subDetailList, o.subDetailList, true);
  end;
end;

function TFhirExplanationOfBenefitAddItemDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList) and isEmptyProp(FsubDetailList);
end;

procedure TFhirExplanationOfBenefitAddItemDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('noteNumber');
  fields.add('adjudication');
  fields.add('subDetail');
end;

{ TFhirExplanationOfBenefitAddItemDetail }

Procedure TFhirExplanationOfBenefitAddItemDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

Function TFhirExplanationOfBenefitAddItemDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirExplanationOfBenefitAddItemDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Procedure TFhirExplanationOfBenefitAddItemDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirExplanationOfBenefitAddItemDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirExplanationOfBenefitAddItemDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirExplanationOfBenefitAddItemDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirExplanationOfBenefitAddItemDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirExplanationOfBenefitAddItemDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

Function TFhirExplanationOfBenefitAddItemDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirExplanationOfBenefitAddItemDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirExplanationOfBenefitAddItemDetail.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirExplanationOfBenefitAddItemDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

Function TFhirExplanationOfBenefitAddItemDetail.GetSubDetailList : TFhirExplanationOfBenefitAddItemDetailSubDetailList;
begin
  if FSubDetailList = nil then
    FSubDetailList := TFhirExplanationOfBenefitAddItemDetailSubDetailList.Create;
  result := FSubDetailList;
end;

Function TFhirExplanationOfBenefitAddItemDetail.GetHasSubDetailList : boolean;
begin
  result := (FSubDetailList <> nil) and (FSubDetailList.count > 0);
end;

function TFhirExplanationOfBenefitAddItemDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FsubDetailList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAddItemDetailListEnumerator }

Constructor TFhirExplanationOfBenefitAddItemDetailListEnumerator.Create(list : TFhirExplanationOfBenefitAddItemDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitAddItemDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitAddItemDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitAddItemDetailListEnumerator.GetCurrent : TFhirExplanationOfBenefitAddItemDetail;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitAddItemDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAddItemDetailList }
procedure TFhirExplanationOfBenefitAddItemDetailList.AddItem(value: TFhirExplanationOfBenefitAddItemDetail);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitAddItemDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitAddItemDetail');
  add(value);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Append: TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetailList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitAddItemDetailList.GetEnumerator : TFhirExplanationOfBenefitAddItemDetailListEnumerator;
begin
  result := TFhirExplanationOfBenefitAddItemDetailListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Clone: TFhirExplanationOfBenefitAddItemDetailList;
begin
  result := TFhirExplanationOfBenefitAddItemDetailList(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitAddItemDetailList.GetItemN(index: Integer): TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitAddItemDetail;
end;
function TFhirExplanationOfBenefitAddItemDetailList.IndexOf(value: TFhirExplanationOfBenefitAddItemDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Insert(index: Integer): TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetailList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitAddItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetail);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Item(index: Integer): TFhirExplanationOfBenefitAddItemDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemDetailList.Link: TFhirExplanationOfBenefitAddItemDetailList;
begin
  result := TFhirExplanationOfBenefitAddItemDetailList(inherited Link);
end;

procedure TFhirExplanationOfBenefitAddItemDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitAddItemDetailList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitAddItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetail);
  FhirExplanationOfBenefitAddItemDetails[index] := value;
end;

procedure TFhirExplanationOfBenefitAddItemDetailList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitAddItemDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitAddItemDetailSubDetail }

constructor TFhirExplanationOfBenefitAddItemDetailSubDetail.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitAddItemDetailSubDetail.Destroy;
begin
  FProductOrService.free;
  FModifierList.Free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FNet.free;
  FNoteNumberList.Free;
  FAdjudicationList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.Assign(oSource : TFslObject);
begin
  inherited;
  productOrService := TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).productOrService.Clone;
  if (TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).FModifierList = nil) then
  begin
    FModifierList.free;
    FModifierList := nil;
  end
  else
  begin
    if FModifierList = nil then
      FModifierList := TFhirCodeableConceptList.Create;
    FModifierList.Assign(TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).FModifierList);
  end;
  quantity := TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).quantity.Clone;
  unitPrice := TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).unitPrice.Clone;
  factorElement := TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).factorElement.Clone;
  net := TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).net.Clone;
  if (TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).FNoteNumberList = nil) then
  begin
    FNoteNumberList.free;
    FNoteNumberList := nil;
  end
  else
  begin
    if FNoteNumberList = nil then
      FNoteNumberList := TFhirPositiveIntList.Create;
    FNoteNumberList.Assign(TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).FNoteNumberList);
  end;
  if (TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefitAddItemDetailSubDetail(oSource).FAdjudicationList);
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'productOrService') Then
     list.add(self.link, 'productOrService', FProductOrService.Link);
  if (child_name = 'modifier') Then
    list.addAll(self, 'modifier', FModifierList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'noteNumber') Then
    list.addAll(self, 'noteNumber', FNoteNumberList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'productOrService', 'CodeableConcept', false, TFhirCodeableConcept, FProductOrService.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', true, TFhirCodeableConcept, FModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'noteNumber', 'positiveInt', true, TFhirPositiveInt, FNoteNumberList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '@ExplanationOfBenefit.item.adjudication', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link)){3};
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'productOrService') then
  begin
    ProductOrService := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'noteNumber') then
  begin
    NoteNumberList.add(asPositiveInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then ModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'noteNumber') then NoteNumberList.insertItem(index, asPositiveInt(propValue)){2}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication){2a}
  else inherited;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'productOrService') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'modifier') then result := ModifierList.new(){2}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'unitPrice') then result := TFhirMoney.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'net') then result := TFhirMoney.create(){4b}
  else if (propName = 'noteNumber') then result := NoteNumberList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'productOrService') then result := 'CodeableConcept'
  else if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'noteNumber') then result := 'positiveInt'
  else if (propName = 'adjudication') then result := '@ExplanationOfBenefit.item.adjudication'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := nil
  else if (propName = 'modifier') then deletePropertyValue('modifier', ModifierList, value) {2}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'noteNumber') then deletePropertyValue('noteNumber', NoteNumberList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'productOrService') then ProductOrServiceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'modifier') then replacePropertyValue('modifier', ModifierList, existing, new) {2}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'net') then NetElement := new as TFhirMoney{4}
  else if (propName = 'noteNumber') then replacePropertyValue('noteNumber', NoteNumberList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then ModifierList.move(source, destination){2a}
  else if (propName = 'noteNumber') then NoteNumberList.move(source, destination){2}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.fhirType : string;
begin
  result := 'subDetail';
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.Link : TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail(inherited Link);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.Clone : TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitAddItemDetailSubDetail)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitAddItemDetailSubDetail(other);
    result := compareDeep(productOrServiceElement, o.productOrServiceElement, true) and 
      compareDeep(modifierList, o.modifierList, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(netElement, o.netElement, true) and compareDeep(noteNumberList, o.noteNumberList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true);
  end;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProductOrService) and isEmptyProp(FmodifierList) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FNet) and isEmptyProp(FnoteNumberList) and isEmptyProp(FadjudicationList);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('productOrService');
  fields.add('modifier');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('net');
  fields.add('noteNumber');
  fields.add('adjudication');
end;

{ TFhirExplanationOfBenefitAddItemDetailSubDetail }

Procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.SetProductOrService(value : TFhirCodeableConcept);
begin
  FProductOrService.free;
  FProductOrService := value;
end;

Function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetModifierList : TFhirCodeableConceptList;
begin
  if FModifierList = nil then
    FModifierList := TFhirCodeableConceptList.Create;
  result := FModifierList;
end;

Function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetHasModifierList : boolean;
begin
  result := (FModifierList <> nil) and (FModifierList.count > 0);
end;

Procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

Procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirExplanationOfBenefitAddItemDetailSubDetail.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

Function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetNoteNumberList : TFhirPositiveIntList;
begin
  if FNoteNumberList = nil then
    FNoteNumberList := TFhirPositiveIntList.Create;
  result := FNoteNumberList;
end;

Function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetHasNoteNumberList : boolean;
begin
  result := (FNoteNumberList <> nil) and (FNoteNumberList.count > 0);
end;

Function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirExplanationOfBenefitAddItemDetailSubDetail.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FProductOrService.sizeInBytes);
  inc(result, FmodifierList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FUnitPrice.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FNet.sizeInBytes);
  inc(result, FnoteNumberList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator }

Constructor TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator.Create(list : TFhirExplanationOfBenefitAddItemDetailSubDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator.GetCurrent : TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitAddItemDetailSubDetailList }
procedure TFhirExplanationOfBenefitAddItemDetailSubDetailList.AddItem(value: TFhirExplanationOfBenefitAddItemDetailSubDetail);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitAddItemDetailSubDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitAddItemDetailSubDetail');
  add(value);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.Append: TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetailList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.GetEnumerator : TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetailListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.Clone: TFhirExplanationOfBenefitAddItemDetailSubDetailList;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetailList(inherited Clone);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.GetItemN(index: Integer): TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail;
end;
function TFhirExplanationOfBenefitAddItemDetailSubDetailList.IndexOf(value: TFhirExplanationOfBenefitAddItemDetailSubDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.Insert(index: Integer): TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetailList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitAddItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetailSubDetail);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.Item(index: Integer): TFhirExplanationOfBenefitAddItemDetailSubDetail;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetail(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitAddItemDetailSubDetailList.Link: TFhirExplanationOfBenefitAddItemDetailSubDetailList;
begin
  result := TFhirExplanationOfBenefitAddItemDetailSubDetailList(inherited Link);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetailList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitAddItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetailSubDetail);
  FhirExplanationOfBenefitAddItemDetailSubDetails[index] := value;
end;

procedure TFhirExplanationOfBenefitAddItemDetailSubDetailList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitAddItemDetailSubDetail);
begin
  assert(value is TFhirExplanationOfBenefitAddItemDetailSubDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitTotal }

constructor TFhirExplanationOfBenefitTotal.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitTotal.Destroy;
begin
  FCategory.free;
  FAmount.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitTotal.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirExplanationOfBenefitTotal(oSource).category.Clone;
  amount := TFhirExplanationOfBenefitTotal(oSource).amount.Clone;
end;

procedure TFhirExplanationOfBenefitTotal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirExplanationOfBenefitTotal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));{2}
end;

function TFhirExplanationOfBenefitTotal.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitTotal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitTotal.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'amount') then result := TFhirMoney.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitTotal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitTotal.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitTotal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitTotal.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitTotal.fhirType : string;
begin
  result := 'total';
end;

function TFhirExplanationOfBenefitTotal.Link : TFhirExplanationOfBenefitTotal;
begin
  result := TFhirExplanationOfBenefitTotal(inherited Link);
end;

function TFhirExplanationOfBenefitTotal.Clone : TFhirExplanationOfBenefitTotal;
begin
  result := TFhirExplanationOfBenefitTotal(inherited Clone);
end;

function TFhirExplanationOfBenefitTotal.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitTotal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitTotal)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitTotal(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirExplanationOfBenefitTotal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FAmount);
end;

procedure TFhirExplanationOfBenefitTotal.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('amount');
end;

{ TFhirExplanationOfBenefitTotal }

Procedure TFhirExplanationOfBenefitTotal.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirExplanationOfBenefitTotal.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirExplanationOfBenefitTotal.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirExplanationOfBenefitTotalListEnumerator }

Constructor TFhirExplanationOfBenefitTotalListEnumerator.Create(list : TFhirExplanationOfBenefitTotalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitTotalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitTotalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitTotalListEnumerator.GetCurrent : TFhirExplanationOfBenefitTotal;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitTotalListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitTotalList }
procedure TFhirExplanationOfBenefitTotalList.AddItem(value: TFhirExplanationOfBenefitTotal);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitTotal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitTotal');
  add(value);
end;

function TFhirExplanationOfBenefitTotalList.Append: TFhirExplanationOfBenefitTotal;
begin
  result := TFhirExplanationOfBenefitTotal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitTotalList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitTotalList.GetEnumerator : TFhirExplanationOfBenefitTotalListEnumerator;
begin
  result := TFhirExplanationOfBenefitTotalListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitTotalList.Clone: TFhirExplanationOfBenefitTotalList;
begin
  result := TFhirExplanationOfBenefitTotalList(inherited Clone);
end;

function TFhirExplanationOfBenefitTotalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitTotalList.GetItemN(index: Integer): TFhirExplanationOfBenefitTotal;
begin
  result := TFhirExplanationOfBenefitTotal(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitTotalList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitTotal;
end;
function TFhirExplanationOfBenefitTotalList.IndexOf(value: TFhirExplanationOfBenefitTotal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitTotalList.Insert(index: Integer): TFhirExplanationOfBenefitTotal;
begin
  result := TFhirExplanationOfBenefitTotal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitTotalList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitTotal);
begin
  assert(value is TFhirExplanationOfBenefitTotal);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitTotalList.Item(index: Integer): TFhirExplanationOfBenefitTotal;
begin
  result := TFhirExplanationOfBenefitTotal(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitTotalList.Link: TFhirExplanationOfBenefitTotalList;
begin
  result := TFhirExplanationOfBenefitTotalList(inherited Link);
end;

procedure TFhirExplanationOfBenefitTotalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitTotalList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitTotal);
begin
  assert(value is TFhirExplanationOfBenefitTotal);
  FhirExplanationOfBenefitTotals[index] := value;
end;

procedure TFhirExplanationOfBenefitTotalList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitTotal);
begin
  assert(value is TFhirExplanationOfBenefitTotal);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitPayment }

constructor TFhirExplanationOfBenefitPayment.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitPayment.Destroy;
begin
  FType_.free;
  FAdjustment.free;
  FAdjustmentReason.free;
  FDate.free;
  FAmount.free;
  FIdentifier.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitPayment.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirExplanationOfBenefitPayment(oSource).type_.Clone;
  adjustment := TFhirExplanationOfBenefitPayment(oSource).adjustment.Clone;
  adjustmentReason := TFhirExplanationOfBenefitPayment(oSource).adjustmentReason.Clone;
  dateElement := TFhirExplanationOfBenefitPayment(oSource).dateElement.Clone;
  amount := TFhirExplanationOfBenefitPayment(oSource).amount.Clone;
  identifier := TFhirExplanationOfBenefitPayment(oSource).identifier.Clone;
end;

procedure TFhirExplanationOfBenefitPayment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'adjustment') Then
     list.add(self.link, 'adjustment', FAdjustment.Link);
  if (child_name = 'adjustmentReason') Then
     list.add(self.link, 'adjustmentReason', FAdjustmentReason.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
end;

procedure TFhirExplanationOfBenefitPayment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'adjustment', 'Money', false, TFhirMoney, FAdjustment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'adjustmentReason', 'CodeableConcept', false, TFhirCodeableConcept, FAdjustmentReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
end;

function TFhirExplanationOfBenefitPayment.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'adjustment') then
  begin
    Adjustment := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'adjustmentReason') then
  begin
    AdjustmentReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitPayment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitPayment.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'adjustment') then result := TFhirMoney.create(){4b}
  else if (propName = 'adjustmentReason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'date') then result := TFhirDate.create() {5b}
  else if (propName = 'amount') then result := TFhirMoney.create(){4b}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitPayment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'adjustment') then result := 'Money'
  else if (propName = 'adjustmentReason') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'date'
  else if (propName = 'amount') then result := 'Money'
  else if (propName = 'identifier') then result := 'Identifier'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitPayment.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'adjustment') then AdjustmentElement := nil
  else if (propName = 'adjustmentReason') then AdjustmentReasonElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitPayment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'adjustment') then AdjustmentElement := new as TFhirMoney{4}
  else if (propName = 'adjustmentReason') then AdjustmentReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'date') then DateElement := asDate(new){5b}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney{4}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitPayment.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitPayment.fhirType : string;
begin
  result := 'payment';
end;

function TFhirExplanationOfBenefitPayment.Link : TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment(inherited Link);
end;

function TFhirExplanationOfBenefitPayment.Clone : TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment(inherited Clone);
end;

function TFhirExplanationOfBenefitPayment.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitPayment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitPayment)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitPayment(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(adjustmentElement, o.adjustmentElement, true) and 
      compareDeep(adjustmentReasonElement, o.adjustmentReasonElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(identifierElement, o.identifierElement, true);
  end;
end;

function TFhirExplanationOfBenefitPayment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAdjustment) and isEmptyProp(FAdjustmentReason) and isEmptyProp(FDate) and isEmptyProp(FAmount) and isEmptyProp(FIdentifier);
end;

procedure TFhirExplanationOfBenefitPayment.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('adjustment');
  fields.add('adjustmentReason');
  fields.add('date');
  fields.add('amount');
  fields.add('identifier');
end;

{ TFhirExplanationOfBenefitPayment }

Procedure TFhirExplanationOfBenefitPayment.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirExplanationOfBenefitPayment.SetAdjustment(value : TFhirMoney);
begin
  FAdjustment.free;
  FAdjustment := value;
end;

Procedure TFhirExplanationOfBenefitPayment.SetAdjustmentReason(value : TFhirCodeableConcept);
begin
  FAdjustmentReason.free;
  FAdjustmentReason := value;
end;

Procedure TFhirExplanationOfBenefitPayment.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirExplanationOfBenefitPayment.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirExplanationOfBenefitPayment.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

Procedure TFhirExplanationOfBenefitPayment.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

Procedure TFhirExplanationOfBenefitPayment.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

function TFhirExplanationOfBenefitPayment.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FAdjustment.sizeInBytes);
  inc(result, FAdjustmentReason.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
end;

{ TFhirExplanationOfBenefitPaymentListEnumerator }

Constructor TFhirExplanationOfBenefitPaymentListEnumerator.Create(list : TFhirExplanationOfBenefitPaymentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitPaymentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitPaymentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitPaymentListEnumerator.GetCurrent : TFhirExplanationOfBenefitPayment;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitPaymentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitPaymentList }
procedure TFhirExplanationOfBenefitPaymentList.AddItem(value: TFhirExplanationOfBenefitPayment);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitPayment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitPayment');
  add(value);
end;

function TFhirExplanationOfBenefitPaymentList.Append: TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitPaymentList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitPaymentList.GetEnumerator : TFhirExplanationOfBenefitPaymentListEnumerator;
begin
  result := TFhirExplanationOfBenefitPaymentListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitPaymentList.Clone: TFhirExplanationOfBenefitPaymentList;
begin
  result := TFhirExplanationOfBenefitPaymentList(inherited Clone);
end;

function TFhirExplanationOfBenefitPaymentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitPaymentList.GetItemN(index: Integer): TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitPaymentList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitPayment;
end;
function TFhirExplanationOfBenefitPaymentList.IndexOf(value: TFhirExplanationOfBenefitPayment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitPaymentList.Insert(index: Integer): TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitPaymentList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitPayment);
begin
  assert(value is TFhirExplanationOfBenefitPayment);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitPaymentList.Item(index: Integer): TFhirExplanationOfBenefitPayment;
begin
  result := TFhirExplanationOfBenefitPayment(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitPaymentList.Link: TFhirExplanationOfBenefitPaymentList;
begin
  result := TFhirExplanationOfBenefitPaymentList(inherited Link);
end;

procedure TFhirExplanationOfBenefitPaymentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitPaymentList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitPayment);
begin
  assert(value is TFhirExplanationOfBenefitPayment);
  FhirExplanationOfBenefitPayments[index] := value;
end;

procedure TFhirExplanationOfBenefitPaymentList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitPayment);
begin
  assert(value is TFhirExplanationOfBenefitPayment);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitProcessNote }

constructor TFhirExplanationOfBenefitProcessNote.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitProcessNote.Destroy;
begin
  FNumber.free;
  FType_.free;
  FText.free;
  FLanguage.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitProcessNote.Assign(oSource : TFslObject);
begin
  inherited;
  numberElement := TFhirExplanationOfBenefitProcessNote(oSource).numberElement.Clone;
  FType_ := TFhirExplanationOfBenefitProcessNote(oSource).FType_.Link;
  textElement := TFhirExplanationOfBenefitProcessNote(oSource).textElement.Clone;
  language := TFhirExplanationOfBenefitProcessNote(oSource).language.Clone;
end;

procedure TFhirExplanationOfBenefitProcessNote.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'number') Then
     list.add(self.link, 'number', FNumber.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
end;

procedure TFhirExplanationOfBenefitProcessNote.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'positiveInt', false, TFhirPositiveInt, FNumber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link));{2}
end;

function TFhirExplanationOfBenefitProcessNote.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'number') then
  begin
    NumberElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirNoteTypeEnum, CODES_TFhirNoteTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitProcessNote.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitProcessNote.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'number') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'language') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitProcessNote.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'number') then result := 'positiveInt'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'language') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitProcessNote.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitProcessNote.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'number') then NumberElement := asPositiveInt(new){5b}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirNoteTypeEnum, CODES_TFhirNoteTypeEnum, new){4}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitProcessNote.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitProcessNote.fhirType : string;
begin
  result := 'processNote';
end;

function TFhirExplanationOfBenefitProcessNote.Link : TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote(inherited Link);
end;

function TFhirExplanationOfBenefitProcessNote.Clone : TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote(inherited Clone);
end;

function TFhirExplanationOfBenefitProcessNote.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitProcessNote;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitProcessNote)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitProcessNote(other);
    result := compareDeep(numberElement, o.numberElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(languageElement, o.languageElement, true);
  end;
end;

function TFhirExplanationOfBenefitProcessNote.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FNumber) and isEmptyProp(FType_) and isEmptyProp(FText) and isEmptyProp(FLanguage);
end;

procedure TFhirExplanationOfBenefitProcessNote.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('number');
  fields.add('type');
  fields.add('text');
  fields.add('language');
end;

{ TFhirExplanationOfBenefitProcessNote }

Procedure TFhirExplanationOfBenefitProcessNote.SetNumber(value : TFhirPositiveInt);
begin
  FNumber.free;
  FNumber := value;
end;

Function TFhirExplanationOfBenefitProcessNote.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := FNumber.value;
end;

Procedure TFhirExplanationOfBenefitProcessNote.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirPositiveInt.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

Procedure TFhirExplanationOfBenefitProcessNote.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirExplanationOfBenefitProcessNote.GetType_ST : TFhirNoteTypeEnum;
begin
  if FType_ = nil then
    result := TFhirNoteTypeEnum(0)
  else
    result := TFhirNoteTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirNoteTypeEnum, FType_.value));
end;

Procedure TFhirExplanationOfBenefitProcessNote.SetType_ST(value : TFhirNoteTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirNoteTypeEnum[value], CODES_TFhirNoteTypeEnum[value]);
end;

Procedure TFhirExplanationOfBenefitProcessNote.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirExplanationOfBenefitProcessNote.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirExplanationOfBenefitProcessNote.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirExplanationOfBenefitProcessNote.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value;
end;

function TFhirExplanationOfBenefitProcessNote.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FNumber.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FLanguage.sizeInBytes);
end;

{ TFhirExplanationOfBenefitProcessNoteListEnumerator }

Constructor TFhirExplanationOfBenefitProcessNoteListEnumerator.Create(list : TFhirExplanationOfBenefitProcessNoteList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitProcessNoteListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitProcessNoteListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitProcessNoteListEnumerator.GetCurrent : TFhirExplanationOfBenefitProcessNote;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitProcessNoteListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitProcessNoteList }
procedure TFhirExplanationOfBenefitProcessNoteList.AddItem(value: TFhirExplanationOfBenefitProcessNote);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitProcessNote', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitProcessNote');
  add(value);
end;

function TFhirExplanationOfBenefitProcessNoteList.Append: TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitProcessNoteList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitProcessNoteList.GetEnumerator : TFhirExplanationOfBenefitProcessNoteListEnumerator;
begin
  result := TFhirExplanationOfBenefitProcessNoteListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitProcessNoteList.Clone: TFhirExplanationOfBenefitProcessNoteList;
begin
  result := TFhirExplanationOfBenefitProcessNoteList(inherited Clone);
end;

function TFhirExplanationOfBenefitProcessNoteList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitProcessNoteList.GetItemN(index: Integer): TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitProcessNoteList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitProcessNote;
end;
function TFhirExplanationOfBenefitProcessNoteList.IndexOf(value: TFhirExplanationOfBenefitProcessNote): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitProcessNoteList.Insert(index: Integer): TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitProcessNoteList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitProcessNote);
begin
  assert(value is TFhirExplanationOfBenefitProcessNote);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitProcessNoteList.Item(index: Integer): TFhirExplanationOfBenefitProcessNote;
begin
  result := TFhirExplanationOfBenefitProcessNote(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitProcessNoteList.Link: TFhirExplanationOfBenefitProcessNoteList;
begin
  result := TFhirExplanationOfBenefitProcessNoteList(inherited Link);
end;

procedure TFhirExplanationOfBenefitProcessNoteList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitProcessNoteList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitProcessNote);
begin
  assert(value is TFhirExplanationOfBenefitProcessNote);
  FhirExplanationOfBenefitProcessNotes[index] := value;
end;

procedure TFhirExplanationOfBenefitProcessNoteList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitProcessNote);
begin
  assert(value is TFhirExplanationOfBenefitProcessNote);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitBenefitBalance }

constructor TFhirExplanationOfBenefitBenefitBalance.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitBenefitBalance.Destroy;
begin
  FCategory.free;
  FExcluded.free;
  FName.free;
  FDescription.free;
  FNetwork.free;
  FUnit_.free;
  FTerm.free;
  FFinancialList.Free;
  inherited;
end;

procedure TFhirExplanationOfBenefitBenefitBalance.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirExplanationOfBenefitBenefitBalance(oSource).category.Clone;
  excludedElement := TFhirExplanationOfBenefitBenefitBalance(oSource).excludedElement.Clone;
  nameElement := TFhirExplanationOfBenefitBenefitBalance(oSource).nameElement.Clone;
  descriptionElement := TFhirExplanationOfBenefitBenefitBalance(oSource).descriptionElement.Clone;
  network := TFhirExplanationOfBenefitBenefitBalance(oSource).network.Clone;
  unit_ := TFhirExplanationOfBenefitBenefitBalance(oSource).unit_.Clone;
  term := TFhirExplanationOfBenefitBenefitBalance(oSource).term.Clone;
  if (TFhirExplanationOfBenefitBenefitBalance(oSource).FFinancialList = nil) then
  begin
    FFinancialList.free;
    FFinancialList := nil;
  end
  else
  begin
    if FFinancialList = nil then
      FFinancialList := TFhirExplanationOfBenefitBenefitBalanceFinancialList.Create;
    FFinancialList.Assign(TFhirExplanationOfBenefitBenefitBalance(oSource).FFinancialList);
  end;
end;

procedure TFhirExplanationOfBenefitBenefitBalance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'excluded') Then
     list.add(self.link, 'excluded', FExcluded.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'network') Then
     list.add(self.link, 'network', FNetwork.Link);
  if (child_name = 'unit') Then
     list.add(self.link, 'unit', FUnit_.Link);
  if (child_name = 'term') Then
     list.add(self.link, 'term', FTerm.Link);
  if (child_name = 'financial') Then
    list.addAll(self, 'financial', FFinancialList);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'excluded', 'boolean', false, TFhirBoolean, FExcluded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'network', 'CodeableConcept', false, TFhirCodeableConcept, FNetwork.Link));{2}
  oList.add(TFHIRProperty.create(self, 'unit', 'CodeableConcept', false, TFhirCodeableConcept, FUnit_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'term', 'CodeableConcept', false, TFhirCodeableConcept, FTerm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'financial', '', true, TFhirExplanationOfBenefitBenefitBalanceFinancial, FFinancialList.Link)){3};
end;

function TFhirExplanationOfBenefitBenefitBalance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'excluded') then
  begin
    ExcludedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    Network := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'unit') then
  begin
    Unit_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'term') then
  begin
    Term := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'financial') then
  begin
    FinancialList.add(propValue as TFhirExplanationOfBenefitBenefitBalanceFinancial){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'financial') then FinancialList.insertItem(index, propValue as TFhirExplanationOfBenefitBenefitBalanceFinancial){2a}
  else inherited;
end;

function TFhirExplanationOfBenefitBenefitBalance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'excluded') then result := TFhirBoolean.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'network') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'unit') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'term') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'financial') then result := FinancialList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitBenefitBalance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'excluded') then result := 'boolean'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'network') then result := 'CodeableConcept'
  else if (propName = 'unit') then result := 'CodeableConcept'
  else if (propName = 'term') then result := 'CodeableConcept'
  else if (propName = 'financial') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'excluded') then ExcludedElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'network') then NetworkElement := nil
  else if (propName = 'unit') then Unit_Element := nil
  else if (propName = 'term') then TermElement := nil
  else if (propName = 'financial') then deletePropertyValue('financial', FinancialList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'excluded') then ExcludedElement := asBoolean(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'network') then NetworkElement := new as TFhirCodeableConcept{4}
  else if (propName = 'unit') then Unit_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'term') then TermElement := new as TFhirCodeableConcept{4}
  else if (propName = 'financial') then replacePropertyValue('financial', FinancialList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'financial') then FinancialList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitBenefitBalance.fhirType : string;
begin
  result := 'benefitBalance';
end;

function TFhirExplanationOfBenefitBenefitBalance.Link : TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance(inherited Link);
end;

function TFhirExplanationOfBenefitBenefitBalance.Clone : TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance(inherited Clone);
end;

function TFhirExplanationOfBenefitBenefitBalance.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitBenefitBalance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitBenefitBalance)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitBenefitBalance(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(excludedElement, o.excludedElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(networkElement, o.networkElement, true) and compareDeep(unit_Element, o.unit_Element, true) and 
      compareDeep(termElement, o.termElement, true) and compareDeep(financialList, o.financialList, true);
  end;
end;

function TFhirExplanationOfBenefitBenefitBalance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FExcluded) and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FNetwork) and isEmptyProp(FUnit_) and isEmptyProp(FTerm) and isEmptyProp(FfinancialList);
end;

procedure TFhirExplanationOfBenefitBenefitBalance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('excluded');
  fields.add('name');
  fields.add('description');
  fields.add('network');
  fields.add('unit');
  fields.add('term');
  fields.add('financial');
end;

{ TFhirExplanationOfBenefitBenefitBalance }

Procedure TFhirExplanationOfBenefitBenefitBalance.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirExplanationOfBenefitBenefitBalance.SetExcluded(value : TFhirBoolean);
begin
  FExcluded.free;
  FExcluded := value;
end;

Function TFhirExplanationOfBenefitBenefitBalance.GetExcludedST : Boolean;
begin
  if FExcluded = nil then
    result := false
  else
    result := FExcluded.value;
end;

Procedure TFhirExplanationOfBenefitBenefitBalance.SetExcludedST(value : Boolean);
begin
  if FExcluded = nil then
    FExcluded := TFhirBoolean.create;
  FExcluded.value := value
end;

Procedure TFhirExplanationOfBenefitBenefitBalance.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirExplanationOfBenefitBenefitBalance.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirExplanationOfBenefitBenefitBalance.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirExplanationOfBenefitBenefitBalance.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirExplanationOfBenefitBenefitBalance.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirExplanationOfBenefitBenefitBalance.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirExplanationOfBenefitBenefitBalance.SetNetwork(value : TFhirCodeableConcept);
begin
  FNetwork.free;
  FNetwork := value;
end;

Procedure TFhirExplanationOfBenefitBenefitBalance.SetUnit_(value : TFhirCodeableConcept);
begin
  FUnit_.free;
  FUnit_ := value;
end;

Procedure TFhirExplanationOfBenefitBenefitBalance.SetTerm(value : TFhirCodeableConcept);
begin
  FTerm.free;
  FTerm := value;
end;

Function TFhirExplanationOfBenefitBenefitBalance.GetFinancialList : TFhirExplanationOfBenefitBenefitBalanceFinancialList;
begin
  if FFinancialList = nil then
    FFinancialList := TFhirExplanationOfBenefitBenefitBalanceFinancialList.Create;
  result := FFinancialList;
end;

Function TFhirExplanationOfBenefitBenefitBalance.GetHasFinancialList : boolean;
begin
  result := (FFinancialList <> nil) and (FFinancialList.count > 0);
end;

function TFhirExplanationOfBenefitBenefitBalance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FExcluded.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FNetwork.sizeInBytes);
  inc(result, FUnit_.sizeInBytes);
  inc(result, FTerm.sizeInBytes);
  inc(result, FfinancialList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitBenefitBalanceListEnumerator }

Constructor TFhirExplanationOfBenefitBenefitBalanceListEnumerator.Create(list : TFhirExplanationOfBenefitBenefitBalanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitBenefitBalanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitBenefitBalanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitBenefitBalanceListEnumerator.GetCurrent : TFhirExplanationOfBenefitBenefitBalance;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitBenefitBalanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitBenefitBalanceList }
procedure TFhirExplanationOfBenefitBenefitBalanceList.AddItem(value: TFhirExplanationOfBenefitBenefitBalance);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitBenefitBalance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitBenefitBalance');
  add(value);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Append: TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitBenefitBalanceList.GetEnumerator : TFhirExplanationOfBenefitBenefitBalanceListEnumerator;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Clone: TFhirExplanationOfBenefitBenefitBalanceList;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceList(inherited Clone);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitBenefitBalanceList.GetItemN(index: Integer): TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitBenefitBalance;
end;
function TFhirExplanationOfBenefitBenefitBalanceList.IndexOf(value: TFhirExplanationOfBenefitBenefitBalance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Insert(index: Integer): TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitBenefitBalance);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalance);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Item(index: Integer): TFhirExplanationOfBenefitBenefitBalance;
begin
  result := TFhirExplanationOfBenefitBenefitBalance(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitBenefitBalanceList.Link: TFhirExplanationOfBenefitBenefitBalanceList;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceList(inherited Link);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitBenefitBalance);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalance);
  FhirExplanationOfBenefitBenefitBalances[index] := value;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitBenefitBalance);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalance);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefitBenefitBalanceFinancial }

constructor TFhirExplanationOfBenefitBenefitBalanceFinancial.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefitBenefitBalanceFinancial.Destroy;
begin
  FType_.free;
  FAllowed.free;
  FUsed.free;
  inherited;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirExplanationOfBenefitBenefitBalanceFinancial(oSource).type_.Clone;
  allowed := TFhirExplanationOfBenefitBenefitBalanceFinancial(oSource).allowed.Clone;
  used := TFhirExplanationOfBenefitBenefitBalanceFinancial(oSource).used.Clone;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'allowed[x]') or (child_name = 'allowed') Then
     list.add(self.link, 'allowed[x]', FAllowed.Link);
  if (child_name = 'used[x]') or (child_name = 'used') Then
     list.add(self.link, 'used[x]', FUsed.Link);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'allowed[x]', 'unsignedInt|string|Money', false, TFhirType, FAllowed.Link));{2}
  oList.add(TFHIRProperty.create(self, 'used[x]', 'unsignedInt|Money', false, TFhirType, FUsed.Link));{2}
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then
  begin
    Allowed := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'Money'])) then
  begin
    Used := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then raise EFHIRException.create('Cannot make property Allowed'){4x}
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'Money'])) then raise EFHIRException.create('Cannot make property Used'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'allowed[x]') then result := 'unsignedInt|string|Money'
  else if (propName = 'used[x]') then result := 'unsignedInt|Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then AllowedElement := nil{4x}
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'Money'])) then UsedElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'allowed', ['UnsignedInt', 'String', 'Money'])) then AllowedElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'used', ['UnsignedInt', 'Money'])) then UsedElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.fhirType : string;
begin
  result := 'financial';
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.Link : TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial(inherited Link);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.Clone : TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial(inherited Clone);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefitBenefitBalanceFinancial)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefitBenefitBalanceFinancial(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(allowedElement, o.allowedElement, true) and 
      compareDeep(usedElement, o.usedElement, true);
  end;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAllowed) and isEmptyProp(FUsed);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('allowed[x]');
  fields.add('used[x]');
end;

{ TFhirExplanationOfBenefitBenefitBalanceFinancial }

Procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.SetAllowed(value : TFhirType);
begin
  FAllowed.free;
  FAllowed := value;
end;

Procedure TFhirExplanationOfBenefitBenefitBalanceFinancial.SetUsed(value : TFhirType);
begin
  FUsed.free;
  FUsed := value;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancial.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FAllowed.sizeInBytes);
  inc(result, FUsed.sizeInBytes);
end;

{ TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator }

Constructor TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.Create(list : TFhirExplanationOfBenefitBenefitBalanceFinancialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.GetCurrent : TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitBenefitBalanceFinancialList }
procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.AddItem(value: TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefitBenefitBalanceFinancial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefitBenefitBalanceFinancial');
  add(value);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Append: TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.GetEnumerator : TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancialListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Clone: TFhirExplanationOfBenefitBenefitBalanceFinancialList;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancialList(inherited Clone);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.GetItemN(index: Integer): TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial;
end;
function TFhirExplanationOfBenefitBenefitBalanceFinancialList.IndexOf(value: TFhirExplanationOfBenefitBenefitBalanceFinancial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Insert(index: Integer): TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.InsertItem(index: Integer; value: TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalanceFinancial);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Item(index: Integer): TFhirExplanationOfBenefitBenefitBalanceFinancial;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancial(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitBenefitBalanceFinancialList.Link: TFhirExplanationOfBenefitBenefitBalanceFinancialList;
begin
  result := TFhirExplanationOfBenefitBenefitBalanceFinancialList(inherited Link);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalanceFinancial);
  FhirExplanationOfBenefitBenefitBalanceFinancials[index] := value;
end;

procedure TFhirExplanationOfBenefitBenefitBalanceFinancialList.SetItemN(index: Integer; value: TFhirExplanationOfBenefitBenefitBalanceFinancial);
begin
  assert(value is TFhirExplanationOfBenefitBenefitBalanceFinancial);
  ObjectByIndex[index] := value;
end;

{ TFhirExplanationOfBenefit }

constructor TFhirExplanationOfBenefit.Create;
begin
  inherited;
end;

destructor TFhirExplanationOfBenefit.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FSubType.free;
  FUse.free;
  FPatient.free;
  FBillablePeriod.free;
  FCreated.free;
  FEnterer.free;
  FInsurer.free;
  FProvider.free;
  FPriority.free;
  FFundsReserveRequested.free;
  FFundsReserve.free;
  FRelatedList.Free;
  FPrescription.free;
  FOriginalPrescription.free;
  FPayee.free;
  FReferral.free;
  FFacility.free;
  FClaim.free;
  FClaimResponse.free;
  FOutcome.free;
  FDisposition.free;
  FPreAuthRefList.Free;
  FPreAuthRefPeriodList.Free;
  FCareTeamList.Free;
  FSupportingInfoList.Free;
  FDiagnosisList.Free;
  FProcedure_List.Free;
  FPrecedence.free;
  FInsuranceList.Free;
  FAccident.free;
  FItemList.Free;
  FAddItemList.Free;
  FAdjudicationList.Free;
  FTotalList.Free;
  FPayment.free;
  FFormCode.free;
  FForm.free;
  FProcessNoteList.Free;
  FBenefitPeriod.free;
  FBenefitBalanceList.Free;
  inherited;
end;

function TFhirExplanationOfBenefit.GetResourceType : TFhirResourceType;
begin
  result := frtExplanationOfBenefit;
end;

procedure TFhirExplanationOfBenefit.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirExplanationOfBenefit(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirExplanationOfBenefit(oSource).FIdentifierList);
  end;
  FStatus := TFhirExplanationOfBenefit(oSource).FStatus.Link;
  type_ := TFhirExplanationOfBenefit(oSource).type_.Clone;
  subType := TFhirExplanationOfBenefit(oSource).subType.Clone;
  FUse := TFhirExplanationOfBenefit(oSource).FUse.Link;
  patient := TFhirExplanationOfBenefit(oSource).patient.Clone;
  billablePeriod := TFhirExplanationOfBenefit(oSource).billablePeriod.Clone;
  createdElement := TFhirExplanationOfBenefit(oSource).createdElement.Clone;
  enterer := TFhirExplanationOfBenefit(oSource).enterer.Clone;
  insurer := TFhirExplanationOfBenefit(oSource).insurer.Clone;
  provider := TFhirExplanationOfBenefit(oSource).provider.Clone;
  priority := TFhirExplanationOfBenefit(oSource).priority.Clone;
  fundsReserveRequested := TFhirExplanationOfBenefit(oSource).fundsReserveRequested.Clone;
  fundsReserve := TFhirExplanationOfBenefit(oSource).fundsReserve.Clone;
  if (TFhirExplanationOfBenefit(oSource).FRelatedList = nil) then
  begin
    FRelatedList.free;
    FRelatedList := nil;
  end
  else
  begin
    if FRelatedList = nil then
      FRelatedList := TFhirExplanationOfBenefitRelatedList.Create;
    FRelatedList.Assign(TFhirExplanationOfBenefit(oSource).FRelatedList);
  end;
  prescription := TFhirExplanationOfBenefit(oSource).prescription.Clone;
  originalPrescription := TFhirExplanationOfBenefit(oSource).originalPrescription.Clone;
  payee := TFhirExplanationOfBenefit(oSource).payee.Clone;
  referral := TFhirExplanationOfBenefit(oSource).referral.Clone;
  facility := TFhirExplanationOfBenefit(oSource).facility.Clone;
  claim := TFhirExplanationOfBenefit(oSource).claim.Clone;
  claimResponse := TFhirExplanationOfBenefit(oSource).claimResponse.Clone;
  FOutcome := TFhirExplanationOfBenefit(oSource).FOutcome.Link;
  dispositionElement := TFhirExplanationOfBenefit(oSource).dispositionElement.Clone;
  if (TFhirExplanationOfBenefit(oSource).FPreAuthRefList = nil) then
  begin
    FPreAuthRefList.free;
    FPreAuthRefList := nil;
  end
  else
  begin
    if FPreAuthRefList = nil then
      FPreAuthRefList := TFhirStringList.Create;
    FPreAuthRefList.Assign(TFhirExplanationOfBenefit(oSource).FPreAuthRefList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FPreAuthRefPeriodList = nil) then
  begin
    FPreAuthRefPeriodList.free;
    FPreAuthRefPeriodList := nil;
  end
  else
  begin
    if FPreAuthRefPeriodList = nil then
      FPreAuthRefPeriodList := TFhirPeriodList.Create;
    FPreAuthRefPeriodList.Assign(TFhirExplanationOfBenefit(oSource).FPreAuthRefPeriodList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FCareTeamList = nil) then
  begin
    FCareTeamList.free;
    FCareTeamList := nil;
  end
  else
  begin
    if FCareTeamList = nil then
      FCareTeamList := TFhirExplanationOfBenefitCareTeamList.Create;
    FCareTeamList.Assign(TFhirExplanationOfBenefit(oSource).FCareTeamList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirExplanationOfBenefitSupportingInfoList.Create;
    FSupportingInfoList.Assign(TFhirExplanationOfBenefit(oSource).FSupportingInfoList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FDiagnosisList = nil) then
  begin
    FDiagnosisList.free;
    FDiagnosisList := nil;
  end
  else
  begin
    if FDiagnosisList = nil then
      FDiagnosisList := TFhirExplanationOfBenefitDiagnosisList.Create;
    FDiagnosisList.Assign(TFhirExplanationOfBenefit(oSource).FDiagnosisList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FProcedure_List = nil) then
  begin
    FProcedure_List.free;
    FProcedure_List := nil;
  end
  else
  begin
    if FProcedure_List = nil then
      FProcedure_List := TFhirExplanationOfBenefitProcedureList.Create;
    FProcedure_List.Assign(TFhirExplanationOfBenefit(oSource).FProcedure_List);
  end;
  precedenceElement := TFhirExplanationOfBenefit(oSource).precedenceElement.Clone;
  if (TFhirExplanationOfBenefit(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirExplanationOfBenefitInsuranceList.Create;
    FInsuranceList.Assign(TFhirExplanationOfBenefit(oSource).FInsuranceList);
  end;
  accident := TFhirExplanationOfBenefit(oSource).accident.Clone;
  if (TFhirExplanationOfBenefit(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirExplanationOfBenefitItemList.Create;
    FItemList.Assign(TFhirExplanationOfBenefit(oSource).FItemList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FAddItemList = nil) then
  begin
    FAddItemList.free;
    FAddItemList := nil;
  end
  else
  begin
    if FAddItemList = nil then
      FAddItemList := TFhirExplanationOfBenefitAddItemList.Create;
    FAddItemList.Assign(TFhirExplanationOfBenefit(oSource).FAddItemList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FAdjudicationList = nil) then
  begin
    FAdjudicationList.free;
    FAdjudicationList := nil;
  end
  else
  begin
    if FAdjudicationList = nil then
      FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
    FAdjudicationList.Assign(TFhirExplanationOfBenefit(oSource).FAdjudicationList);
  end;
  if (TFhirExplanationOfBenefit(oSource).FTotalList = nil) then
  begin
    FTotalList.free;
    FTotalList := nil;
  end
  else
  begin
    if FTotalList = nil then
      FTotalList := TFhirExplanationOfBenefitTotalList.Create;
    FTotalList.Assign(TFhirExplanationOfBenefit(oSource).FTotalList);
  end;
  payment := TFhirExplanationOfBenefit(oSource).payment.Clone;
  formCode := TFhirExplanationOfBenefit(oSource).formCode.Clone;
  form := TFhirExplanationOfBenefit(oSource).form.Clone;
  if (TFhirExplanationOfBenefit(oSource).FProcessNoteList = nil) then
  begin
    FProcessNoteList.free;
    FProcessNoteList := nil;
  end
  else
  begin
    if FProcessNoteList = nil then
      FProcessNoteList := TFhirExplanationOfBenefitProcessNoteList.Create;
    FProcessNoteList.Assign(TFhirExplanationOfBenefit(oSource).FProcessNoteList);
  end;
  benefitPeriod := TFhirExplanationOfBenefit(oSource).benefitPeriod.Clone;
  if (TFhirExplanationOfBenefit(oSource).FBenefitBalanceList = nil) then
  begin
    FBenefitBalanceList.free;
    FBenefitBalanceList := nil;
  end
  else
  begin
    if FBenefitBalanceList = nil then
      FBenefitBalanceList := TFhirExplanationOfBenefitBenefitBalanceList.Create;
    FBenefitBalanceList.Assign(TFhirExplanationOfBenefit(oSource).FBenefitBalanceList);
  end;
end;

procedure TFhirExplanationOfBenefit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
     list.add(self.link, 'subType', FSubType.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'billablePeriod') Then
     list.add(self.link, 'billablePeriod', FBillablePeriod.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'insurer') Then
     list.add(self.link, 'insurer', FInsurer.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'fundsReserveRequested') Then
     list.add(self.link, 'fundsReserveRequested', FFundsReserveRequested.Link);
  if (child_name = 'fundsReserve') Then
     list.add(self.link, 'fundsReserve', FFundsReserve.Link);
  if (child_name = 'related') Then
    list.addAll(self, 'related', FRelatedList);
  if (child_name = 'prescription') Then
     list.add(self.link, 'prescription', FPrescription.Link);
  if (child_name = 'originalPrescription') Then
     list.add(self.link, 'originalPrescription', FOriginalPrescription.Link);
  if (child_name = 'payee') Then
     list.add(self.link, 'payee', FPayee.Link);
  if (child_name = 'referral') Then
     list.add(self.link, 'referral', FReferral.Link);
  if (child_name = 'facility') Then
     list.add(self.link, 'facility', FFacility.Link);
  if (child_name = 'claim') Then
     list.add(self.link, 'claim', FClaim.Link);
  if (child_name = 'claimResponse') Then
     list.add(self.link, 'claimResponse', FClaimResponse.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'preAuthRef') Then
    list.addAll(self, 'preAuthRef', FPreAuthRefList);
  if (child_name = 'preAuthRefPeriod') Then
    list.addAll(self, 'preAuthRefPeriod', FPreAuthRefPeriodList);
  if (child_name = 'careTeam') Then
    list.addAll(self, 'careTeam', FCareTeamList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'diagnosis') Then
    list.addAll(self, 'diagnosis', FDiagnosisList);
  if (child_name = 'procedure') Then
    list.addAll(self, 'procedure', FProcedure_List);
  if (child_name = 'precedence') Then
     list.add(self.link, 'precedence', FPrecedence.Link);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'accident') Then
     list.add(self.link, 'accident', FAccident.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
  if (child_name = 'addItem') Then
    list.addAll(self, 'addItem', FAddItemList);
  if (child_name = 'adjudication') Then
    list.addAll(self, 'adjudication', FAdjudicationList);
  if (child_name = 'total') Then
    list.addAll(self, 'total', FTotalList);
  if (child_name = 'payment') Then
     list.add(self.link, 'payment', FPayment.Link);
  if (child_name = 'formCode') Then
     list.add(self.link, 'formCode', FFormCode.Link);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'processNote') Then
    list.addAll(self, 'processNote', FProcessNoteList);
  if (child_name = 'benefitPeriod') Then
     list.add(self.link, 'benefitPeriod', FBenefitPeriod.Link);
  if (child_name = 'benefitBalance') Then
    list.addAll(self, 'benefitBalance', FBenefitBalanceList);
end;

procedure TFhirExplanationOfBenefit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', false, TFhirCodeableConcept, FSubType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'use', 'code', false, TFHIREnum, FUse.Link));{1}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'billablePeriod', 'Period', false, TFhirPeriod, FBillablePeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FEnterer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'insurer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FInsurer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'fundsReserveRequested', 'CodeableConcept', false, TFhirCodeableConcept, FFundsReserveRequested.Link));{2}
  oList.add(TFHIRProperty.create(self, 'fundsReserve', 'CodeableConcept', false, TFhirCodeableConcept, FFundsReserve.Link));{2}
  oList.add(TFHIRProperty.create(self, 'related', '', true, TFhirExplanationOfBenefitRelated, FRelatedList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'prescription', 'Reference(MedicationRequest)', false, TFhirReference{TFhirMedicationRequest}, FPrescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'originalPrescription', 'Reference(MedicationRequest)', false, TFhirReference{TFhirMedicationRequest}, FOriginalPrescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payee', '', false, TFhirExplanationOfBenefitPayee, FPayee.Link));{2}
  oList.add(TFHIRProperty.create(self, 'referral', 'Reference(ServiceRequest)', false, TFhirReference{TFhirServiceRequest}, FReferral.Link));{2}
  oList.add(TFHIRProperty.create(self, 'facility', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FFacility.Link));{2}
  oList.add(TFHIRProperty.create(self, 'claim', 'Reference(Claim)', false, TFhirReference{TFhirClaim}, FClaim.Link));{2}
  oList.add(TFHIRProperty.create(self, 'claimResponse', 'Reference(ClaimResponse)', false, TFhirReference{TFhirClaimResponse}, FClaimResponse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFHIREnum, FOutcome.Link));{1}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'preAuthRef', 'string', true, TFhirString, FPreAuthRefList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'preAuthRefPeriod', 'Period', true, TFhirPeriod, FPreAuthRefPeriodList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'careTeam', '', true, TFhirExplanationOfBenefitCareTeam, FCareTeamList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'supportingInfo', '', true, TFhirExplanationOfBenefitSupportingInfo, FSupportingInfoList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'diagnosis', '', true, TFhirExplanationOfBenefitDiagnosis, FDiagnosisList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'procedure', '', true, TFhirExplanationOfBenefitProcedure, FProcedure_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'precedence', 'positiveInt', false, TFhirPositiveInt, FPrecedence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'insurance', '', true, TFhirExplanationOfBenefitInsurance, FInsuranceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'accident', '', false, TFhirExplanationOfBenefitAccident, FAccident.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirExplanationOfBenefitItem, FItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'addItem', '', true, TFhirExplanationOfBenefitAddItem, FAddItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'adjudication', '@ExplanationOfBenefit.item.adjudication', true, TFhirExplanationOfBenefitItemAdjudication, FAdjudicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'total', '', true, TFhirExplanationOfBenefitTotal, FTotalList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'payment', '', false, TFhirExplanationOfBenefitPayment, FPayment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'formCode', 'CodeableConcept', false, TFhirCodeableConcept, FFormCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'form', 'Attachment', false, TFhirAttachment, FForm.Link));{2}
  oList.add(TFHIRProperty.create(self, 'processNote', '', true, TFhirExplanationOfBenefitProcessNote, FProcessNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'benefitPeriod', 'Period', false, TFhirPeriod, FBenefitPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'benefitBalance', '', true, TFhirExplanationOfBenefitBenefitBalance, FBenefitBalanceList.Link)){3};
end;

function TFhirExplanationOfBenefit.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirExplanationofbenefitStatusEnum, CODES_TFhirExplanationofbenefitStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    UseElement := asEnum(SYSTEMS_TFhirClaimUseEnum, CODES_TFhirClaimUseEnum, propValue);
    result := propValue
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'billablePeriod') then
  begin
    BillablePeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'insurer') then
  begin
    Insurer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'fundsReserveRequested') then
  begin
    FundsReserveRequested := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'fundsReserve') then
  begin
    FundsReserve := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'related') then
  begin
    RelatedList.add(propValue as TFhirExplanationOfBenefitRelated){2a};
    result := propValue;
  end
  else if (propName = 'prescription') then
  begin
    Prescription := propValue as TFhirReference{TFhirMedicationRequest}{4b};
    result := propValue;
  end
  else if (propName = 'originalPrescription') then
  begin
    OriginalPrescription := propValue as TFhirReference{TFhirMedicationRequest}{4b};
    result := propValue;
  end
  else if (propName = 'payee') then
  begin
    Payee := propValue as TFhirExplanationOfBenefitPayee{4b};
    result := propValue;
  end
  else if (propName = 'referral') then
  begin
    Referral := propValue as TFhirReference{TFhirServiceRequest}{4b};
    result := propValue;
  end
  else if (propName = 'facility') then
  begin
    Facility := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'claim') then
  begin
    Claim := propValue as TFhirReference{TFhirClaim}{4b};
    result := propValue;
  end
  else if (propName = 'claimResponse') then
  begin
    ClaimResponse := propValue as TFhirReference{TFhirClaimResponse}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirRemittanceOutcomeEnum, CODES_TFhirRemittanceOutcomeEnum, propValue);
    result := propValue
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'preAuthRef') then
  begin
    PreAuthRefList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'preAuthRefPeriod') then
  begin
    PreAuthRefPeriodList.add(propValue as TFhirPeriod){2a};
    result := propValue;
  end
  else if (propName = 'careTeam') then
  begin
    CareTeamList.add(propValue as TFhirExplanationOfBenefitCareTeam){2a};
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirExplanationOfBenefitSupportingInfo){2a};
    result := propValue;
  end
  else if (propName = 'diagnosis') then
  begin
    DiagnosisList.add(propValue as TFhirExplanationOfBenefitDiagnosis){2a};
    result := propValue;
  end
  else if (propName = 'procedure') then
  begin
    Procedure_List.add(propValue as TFhirExplanationOfBenefitProcedure){2a};
    result := propValue;
  end
  else if (propName = 'precedence') then
  begin
    PrecedenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirExplanationOfBenefitInsurance){2a};
    result := propValue;
  end
  else if (propName = 'accident') then
  begin
    Accident := propValue as TFhirExplanationOfBenefitAccident{4b};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirExplanationOfBenefitItem){2a};
    result := propValue;
  end
  else if (propName = 'addItem') then
  begin
    AddItemList.add(propValue as TFhirExplanationOfBenefitAddItem){2a};
    result := propValue;
  end
  else if (propName = 'adjudication') then
  begin
    AdjudicationList.add(propValue as TFhirExplanationOfBenefitItemAdjudication){2a};
    result := propValue;
  end
  else if (propName = 'total') then
  begin
    TotalList.add(propValue as TFhirExplanationOfBenefitTotal){2a};
    result := propValue;
  end
  else if (propName = 'payment') then
  begin
    Payment := propValue as TFhirExplanationOfBenefitPayment{4b};
    result := propValue;
  end
  else if (propName = 'formCode') then
  begin
    FormCode := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirAttachment{4b};
    result := propValue;
  end
  else if (propName = 'processNote') then
  begin
    ProcessNoteList.add(propValue as TFhirExplanationOfBenefitProcessNote){2a};
    result := propValue;
  end
  else if (propName = 'benefitPeriod') then
  begin
    BenefitPeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'benefitBalance') then
  begin
    BenefitBalanceList.add(propValue as TFhirExplanationOfBenefitBenefitBalance){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirExplanationOfBenefit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'related') then RelatedList.insertItem(index, propValue as TFhirExplanationOfBenefitRelated){2a}
  else if (propName = 'preAuthRef') then PreAuthRefList.insertItem(index, asString(propValue)){2}
  else if (propName = 'preAuthRefPeriod') then PreAuthRefPeriodList.insertItem(index, propValue as TFhirPeriod){2a}
  else if (propName = 'careTeam') then CareTeamList.insertItem(index, propValue as TFhirExplanationOfBenefitCareTeam){2a}
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirExplanationOfBenefitSupportingInfo){2a}
  else if (propName = 'diagnosis') then DiagnosisList.insertItem(index, propValue as TFhirExplanationOfBenefitDiagnosis){2a}
  else if (propName = 'procedure') then Procedure_List.insertItem(index, propValue as TFhirExplanationOfBenefitProcedure){2a}
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirExplanationOfBenefitInsurance){2a}
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirExplanationOfBenefitItem){2a}
  else if (propName = 'addItem') then AddItemList.insertItem(index, propValue as TFhirExplanationOfBenefitAddItem){2a}
  else if (propName = 'adjudication') then AdjudicationList.insertItem(index, propValue as TFhirExplanationOfBenefitItemAdjudication){2a}
  else if (propName = 'total') then TotalList.insertItem(index, propValue as TFhirExplanationOfBenefitTotal){2a}
  else if (propName = 'processNote') then ProcessNoteList.insertItem(index, propValue as TFhirExplanationOfBenefitProcessNote){2a}
  else if (propName = 'benefitBalance') then BenefitBalanceList.insertItem(index, propValue as TFhirExplanationOfBenefitBenefitBalance){2a}
  else inherited;
end;

function TFhirExplanationOfBenefit.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'billablePeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'enterer') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'insurer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'priority') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'fundsReserveRequested') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'fundsReserve') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'related') then result := RelatedList.new(){2}
  else if (propName = 'prescription') then result := TFhirReference{TFhirMedicationRequest}.create(){4b}
  else if (propName = 'originalPrescription') then result := TFhirReference{TFhirMedicationRequest}.create(){4b}
  else if (propName = 'payee') then result := TFhirExplanationOfBenefitPayee.create(){4b}
  else if (propName = 'referral') then result := TFhirReference{TFhirServiceRequest}.create(){4b}
  else if (propName = 'facility') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'claim') then result := TFhirReference{TFhirClaim}.create(){4b}
  else if (propName = 'claimResponse') then result := TFhirReference{TFhirClaimResponse}.create(){4b}
  else if (propName = 'disposition') then result := TFhirString.create() {5b}
  else if (propName = 'preAuthRef') then result := PreAuthRefList.new(){2}
  else if (propName = 'preAuthRefPeriod') then result := PreAuthRefPeriodList.new(){2}
  else if (propName = 'careTeam') then result := CareTeamList.new(){2}
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new(){2}
  else if (propName = 'diagnosis') then result := DiagnosisList.new(){2}
  else if (propName = 'procedure') then result := Procedure_List.new(){2}
  else if (propName = 'precedence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'insurance') then result := InsuranceList.new(){2}
  else if (propName = 'accident') then result := TFhirExplanationOfBenefitAccident.create(){4b}
  else if (propName = 'item') then result := ItemList.new(){2}
  else if (propName = 'addItem') then result := AddItemList.new(){2}
  else if (propName = 'adjudication') then result := AdjudicationList.new(){2}
  else if (propName = 'total') then result := TotalList.new(){2}
  else if (propName = 'payment') then result := TFhirExplanationOfBenefitPayment.create(){4b}
  else if (propName = 'formCode') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'form') then result := TFhirAttachment.create(){4b}
  else if (propName = 'processNote') then result := ProcessNoteList.new(){2}
  else if (propName = 'benefitPeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'benefitBalance') then result := BenefitBalanceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExplanationOfBenefit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'use') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'billablePeriod') then result := 'Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'insurer') then result := 'Reference'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'fundsReserveRequested') then result := 'CodeableConcept'
  else if (propName = 'fundsReserve') then result := 'CodeableConcept'
  else if (propName = 'related') then result := ''
  else if (propName = 'prescription') then result := 'Reference'
  else if (propName = 'originalPrescription') then result := 'Reference'
  else if (propName = 'payee') then result := ''
  else if (propName = 'referral') then result := 'Reference'
  else if (propName = 'facility') then result := 'Reference'
  else if (propName = 'claim') then result := 'Reference'
  else if (propName = 'claimResponse') then result := 'Reference'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'preAuthRef') then result := 'string'
  else if (propName = 'preAuthRefPeriod') then result := 'Period'
  else if (propName = 'careTeam') then result := ''
  else if (propName = 'supportingInfo') then result := ''
  else if (propName = 'diagnosis') then result := ''
  else if (propName = 'procedure') then result := ''
  else if (propName = 'precedence') then result := 'positiveInt'
  else if (propName = 'insurance') then result := ''
  else if (propName = 'accident') then result := ''
  else if (propName = 'item') then result := ''
  else if (propName = 'addItem') then result := ''
  else if (propName = 'adjudication') then result := '@ExplanationOfBenefit.item.adjudication'
  else if (propName = 'total') then result := ''
  else if (propName = 'payment') then result := ''
  else if (propName = 'formCode') then result := 'CodeableConcept'
  else if (propName = 'form') then result := 'Attachment'
  else if (propName = 'processNote') then result := ''
  else if (propName = 'benefitPeriod') then result := 'Period'
  else if (propName = 'benefitBalance') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExplanationOfBenefit.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then SubTypeElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'billablePeriod') then BillablePeriodElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'insurer') then InsurerElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'fundsReserveRequested') then FundsReserveRequestedElement := nil
  else if (propName = 'fundsReserve') then FundsReserveElement := nil
  else if (propName = 'related') then deletePropertyValue('related', RelatedList, value) {2}
  else if (propName = 'prescription') then PrescriptionElement := nil
  else if (propName = 'originalPrescription') then OriginalPrescriptionElement := nil
  else if (propName = 'payee') then PayeeElement := nil
  else if (propName = 'referral') then ReferralElement := nil
  else if (propName = 'facility') then FacilityElement := nil
  else if (propName = 'claim') then ClaimElement := nil
  else if (propName = 'claimResponse') then ClaimResponseElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'preAuthRef') then deletePropertyValue('preAuthRef', PreAuthRefList, value) {2}
  else if (propName = 'preAuthRefPeriod') then deletePropertyValue('preAuthRefPeriod', PreAuthRefPeriodList, value) {2}
  else if (propName = 'careTeam') then deletePropertyValue('careTeam', CareTeamList, value) {2}
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value) {2}
  else if (propName = 'diagnosis') then deletePropertyValue('diagnosis', DiagnosisList, value) {2}
  else if (propName = 'procedure') then deletePropertyValue('procedure', Procedure_List, value) {2}
  else if (propName = 'precedence') then PrecedenceElement := nil
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value) {2}
  else if (propName = 'accident') then AccidentElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else if (propName = 'addItem') then deletePropertyValue('addItem', AddItemList, value) {2}
  else if (propName = 'adjudication') then deletePropertyValue('adjudication', AdjudicationList, value) {2}
  else if (propName = 'total') then deletePropertyValue('total', TotalList, value) {2}
  else if (propName = 'payment') then PaymentElement := nil
  else if (propName = 'formCode') then FormCodeElement := nil
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'processNote') then deletePropertyValue('processNote', ProcessNoteList, value) {2}
  else if (propName = 'benefitPeriod') then BenefitPeriodElement := nil
  else if (propName = 'benefitBalance') then deletePropertyValue('benefitBalance', BenefitBalanceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExplanationOfBenefit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirExplanationofbenefitStatusEnum, CODES_TFhirExplanationofbenefitStatusEnum, new){4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'subType') then SubTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'use') then UseElement := asEnum(SYSTEMS_TFhirClaimUseEnum, CODES_TFhirClaimUseEnum, new){4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'billablePeriod') then BillablePeriodElement := new as TFhirPeriod{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'enterer') then EntererElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'insurer') then InsurerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept{4}
  else if (propName = 'fundsReserveRequested') then FundsReserveRequestedElement := new as TFhirCodeableConcept{4}
  else if (propName = 'fundsReserve') then FundsReserveElement := new as TFhirCodeableConcept{4}
  else if (propName = 'related') then replacePropertyValue('related', RelatedList, existing, new) {2}
  else if (propName = 'prescription') then PrescriptionElement := new as TFhirReference{TFhirMedicationRequest}{4}
  else if (propName = 'originalPrescription') then OriginalPrescriptionElement := new as TFhirReference{TFhirMedicationRequest}{4}
  else if (propName = 'payee') then PayeeElement := new as TFhirExplanationOfBenefitPayee{4}
  else if (propName = 'referral') then ReferralElement := new as TFhirReference{TFhirServiceRequest}{4}
  else if (propName = 'facility') then FacilityElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'claim') then ClaimElement := new as TFhirReference{TFhirClaim}{4}
  else if (propName = 'claimResponse') then ClaimResponseElement := new as TFhirReference{TFhirClaimResponse}{4}
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirRemittanceOutcomeEnum, CODES_TFhirRemittanceOutcomeEnum, new){4}
  else if (propName = 'disposition') then DispositionElement := asString(new){5b}
  else if (propName = 'preAuthRef') then replacePropertyValue('preAuthRef', PreAuthRefList, existing, new) {2}
  else if (propName = 'preAuthRefPeriod') then replacePropertyValue('preAuthRefPeriod', PreAuthRefPeriodList, existing, new) {2}
  else if (propName = 'careTeam') then replacePropertyValue('careTeam', CareTeamList, existing, new) {2}
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new) {2}
  else if (propName = 'diagnosis') then replacePropertyValue('diagnosis', DiagnosisList, existing, new) {2}
  else if (propName = 'procedure') then replacePropertyValue('procedure', Procedure_List, existing, new) {2}
  else if (propName = 'precedence') then PrecedenceElement := asPositiveInt(new){5b}
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new) {2}
  else if (propName = 'accident') then AccidentElement := new as TFhirExplanationOfBenefitAccident{4}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else if (propName = 'addItem') then replacePropertyValue('addItem', AddItemList, existing, new) {2}
  else if (propName = 'adjudication') then replacePropertyValue('adjudication', AdjudicationList, existing, new) {2}
  else if (propName = 'total') then replacePropertyValue('total', TotalList, existing, new) {2}
  else if (propName = 'payment') then PaymentElement := new as TFhirExplanationOfBenefitPayment{4}
  else if (propName = 'formCode') then FormCodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'form') then FormElement := new as TFhirAttachment{4}
  else if (propName = 'processNote') then replacePropertyValue('processNote', ProcessNoteList, existing, new) {2}
  else if (propName = 'benefitPeriod') then BenefitPeriodElement := new as TFhirPeriod{4}
  else if (propName = 'benefitBalance') then replacePropertyValue('benefitBalance', BenefitBalanceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExplanationOfBenefit.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'related') then RelatedList.move(source, destination){2a}
  else if (propName = 'preAuthRef') then PreAuthRefList.move(source, destination){2}
  else if (propName = 'preAuthRefPeriod') then PreAuthRefPeriodList.move(source, destination){2a}
  else if (propName = 'careTeam') then CareTeamList.move(source, destination){2a}
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination){2a}
  else if (propName = 'diagnosis') then DiagnosisList.move(source, destination){2a}
  else if (propName = 'procedure') then Procedure_List.move(source, destination){2a}
  else if (propName = 'insurance') then InsuranceList.move(source, destination){2a}
  else if (propName = 'item') then ItemList.move(source, destination){2a}
  else if (propName = 'addItem') then AddItemList.move(source, destination){2a}
  else if (propName = 'adjudication') then AdjudicationList.move(source, destination){2a}
  else if (propName = 'total') then TotalList.move(source, destination){2a}
  else if (propName = 'processNote') then ProcessNoteList.move(source, destination){2a}
  else if (propName = 'benefitBalance') then BenefitBalanceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExplanationOfBenefit.fhirType : string;
begin
  result := 'ExplanationOfBenefit';
end;

function TFhirExplanationOfBenefit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FSubType) and isEmptyProp(FUse) and isEmptyProp(FPatient) and isEmptyProp(FBillablePeriod) and isEmptyProp(FCreated) and isEmptyProp(FEnterer) and isEmptyProp(FInsurer) and isEmptyProp(FProvider) and isEmptyProp(FPriority) and isEmptyProp(FFundsReserveRequested) and isEmptyProp(FFundsReserve) and isEmptyProp(FrelatedList) and isEmptyProp(FPrescription) and isEmptyProp(FOriginalPrescription) and isEmptyProp(FPayee) and isEmptyProp(FReferral) and isEmptyProp(FFacility) and isEmptyProp(FClaim) and isEmptyProp(FClaimResponse) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FpreAuthRefList) and isEmptyProp(FpreAuthRefPeriodList) and isEmptyProp(FcareTeamList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FdiagnosisList) and isEmptyProp(Fprocedure_List) and isEmptyProp(FPrecedence) and isEmptyProp(FinsuranceList) and isEmptyProp(FAccident) and
    isEmptyProp(FitemList) and isEmptyProp(FaddItemList) and isEmptyProp(FadjudicationList) and isEmptyProp(FtotalList) and isEmptyProp(FPayment) and isEmptyProp(FFormCode) and isEmptyProp(FForm) and isEmptyProp(FprocessNoteList) and isEmptyProp(FBenefitPeriod) and isEmptyProp(FbenefitBalanceList);
end;

function TFhirExplanationOfBenefit.equals(other : TObject) : boolean; 
var
  o : TFhirExplanationOfBenefit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExplanationOfBenefit)) then
    result := false
  else
  begin
    o := TFhirExplanationOfBenefit(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeElement, o.subTypeElement, true) and 
      compareDeep(useElement, o.useElement, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(billablePeriodElement, o.billablePeriodElement, true) and compareDeep(createdElement, o.createdElement, true) and 
      compareDeep(entererElement, o.entererElement, true) and compareDeep(insurerElement, o.insurerElement, true) and 
      compareDeep(providerElement, o.providerElement, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(fundsReserveRequestedElement, o.fundsReserveRequestedElement, true) and 
      compareDeep(fundsReserveElement, o.fundsReserveElement, true) and compareDeep(relatedList, o.relatedList, true) and 
      compareDeep(prescriptionElement, o.prescriptionElement, true) and compareDeep(originalPrescriptionElement, o.originalPrescriptionElement, true) and 
      compareDeep(payeeElement, o.payeeElement, true) and compareDeep(referralElement, o.referralElement, true) and 
      compareDeep(facilityElement, o.facilityElement, true) and compareDeep(claimElement, o.claimElement, true) and 
      compareDeep(claimResponseElement, o.claimResponseElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and 
      compareDeep(dispositionElement, o.dispositionElement, true) and compareDeep(preAuthRefList, o.preAuthRefList, true) and 
      compareDeep(preAuthRefPeriodList, o.preAuthRefPeriodList, true) and compareDeep(careTeamList, o.careTeamList, true) and 
      compareDeep(supportingInfoList, o.supportingInfoList, true) and compareDeep(diagnosisList, o.diagnosisList, true) and 
      compareDeep(procedure_List, o.procedure_List, true) and compareDeep(precedenceElement, o.precedenceElement, true) and 
      compareDeep(insuranceList, o.insuranceList, true) and compareDeep(accidentElement, o.accidentElement, true) and 
      compareDeep(itemList, o.itemList, true) and compareDeep(addItemList, o.addItemList, true) and 
      compareDeep(adjudicationList, o.adjudicationList, true) and compareDeep(totalList, o.totalList, true) and 
      compareDeep(paymentElement, o.paymentElement, true) and compareDeep(formCodeElement, o.formCodeElement, true) and 
      compareDeep(formElement, o.formElement, true) and compareDeep(processNoteList, o.processNoteList, true) and 
      compareDeep(benefitPeriodElement, o.benefitPeriodElement, true) and compareDeep(benefitBalanceList, o.benefitBalanceList, true);
  end;
end;

function TFhirExplanationOfBenefit.Link : TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit(inherited Link);
end;

function TFhirExplanationOfBenefit.Clone : TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit(inherited Clone);
end;

procedure TFhirExplanationOfBenefit.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('subType');
  fields.add('use');
  fields.add('patient');
  fields.add('billablePeriod');
  fields.add('created');
  fields.add('enterer');
  fields.add('insurer');
  fields.add('provider');
  fields.add('priority');
  fields.add('fundsReserveRequested');
  fields.add('fundsReserve');
  fields.add('related');
  fields.add('prescription');
  fields.add('originalPrescription');
  fields.add('payee');
  fields.add('referral');
  fields.add('facility');
  fields.add('claim');
  fields.add('claimResponse');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('preAuthRef');
  fields.add('preAuthRefPeriod');
  fields.add('careTeam');
  fields.add('supportingInfo');
  fields.add('diagnosis');
  fields.add('procedure');
  fields.add('precedence');
  fields.add('insurance');
  fields.add('accident');
  fields.add('item');
  fields.add('addItem');
  fields.add('adjudication');
  fields.add('total');
  fields.add('payment');
  fields.add('formCode');
  fields.add('form');
  fields.add('processNote');
  fields.add('benefitPeriod');
  fields.add('benefitBalance');
end;

{ TFhirExplanationOfBenefit }

Function TFhirExplanationOfBenefit.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirExplanationOfBenefit.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirExplanationOfBenefit.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirExplanationOfBenefit.GetStatusST : TFhirExplanationofbenefitStatusEnum;
begin
  if FStatus = nil then
    result := TFhirExplanationofbenefitStatusEnum(0)
  else
    result := TFhirExplanationofbenefitStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirExplanationofbenefitStatusEnum, FStatus.value));
end;

Procedure TFhirExplanationOfBenefit.SetStatusST(value : TFhirExplanationofbenefitStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirExplanationofbenefitStatusEnum[value], CODES_TFhirExplanationofbenefitStatusEnum[value]);
end;

Procedure TFhirExplanationOfBenefit.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirExplanationOfBenefit.SetSubType(value : TFhirCodeableConcept);
begin
  FSubType.free;
  FSubType := value;
end;

Procedure TFhirExplanationOfBenefit.SetUse(value : TFhirEnum);
begin
  FUse.free;
  FUse := value;
end;

Function TFhirExplanationOfBenefit.GetUseST : TFhirClaimUseEnum;
begin
  if FUse = nil then
    result := TFhirClaimUseEnum(0)
  else
    result := TFhirClaimUseEnum(StringArrayIndexOfSensitive(CODES_TFhirClaimUseEnum, FUse.value));
end;

Procedure TFhirExplanationOfBenefit.SetUseST(value : TFhirClaimUseEnum);
begin
  if ord(value) = 0 then
    UseElement := nil
  else
    UseElement := TFhirEnum.create(SYSTEMS_TFhirClaimUseEnum[value], CODES_TFhirClaimUseEnum[value]);
end;

Procedure TFhirExplanationOfBenefit.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirExplanationOfBenefit.SetBillablePeriod(value : TFhirPeriod);
begin
  FBillablePeriod.free;
  FBillablePeriod := value;
end;

Procedure TFhirExplanationOfBenefit.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirExplanationOfBenefit.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirExplanationOfBenefit.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirExplanationOfBenefit.SetEnterer(value : TFhirReference{TFhirPractitioner});
begin
  FEnterer.free;
  FEnterer := value;
end;

Procedure TFhirExplanationOfBenefit.SetInsurer(value : TFhirReference{TFhirOrganization});
begin
  FInsurer.free;
  FInsurer := value;
end;

Procedure TFhirExplanationOfBenefit.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirExplanationOfBenefit.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value;
end;

Procedure TFhirExplanationOfBenefit.SetFundsReserveRequested(value : TFhirCodeableConcept);
begin
  FFundsReserveRequested.free;
  FFundsReserveRequested := value;
end;

Procedure TFhirExplanationOfBenefit.SetFundsReserve(value : TFhirCodeableConcept);
begin
  FFundsReserve.free;
  FFundsReserve := value;
end;

Function TFhirExplanationOfBenefit.GetRelatedList : TFhirExplanationOfBenefitRelatedList;
begin
  if FRelatedList = nil then
    FRelatedList := TFhirExplanationOfBenefitRelatedList.Create;
  result := FRelatedList;
end;

Function TFhirExplanationOfBenefit.GetHasRelatedList : boolean;
begin
  result := (FRelatedList <> nil) and (FRelatedList.count > 0);
end;

Procedure TFhirExplanationOfBenefit.SetPrescription(value : TFhirReference{TFhirMedicationRequest});
begin
  FPrescription.free;
  FPrescription := value;
end;

Procedure TFhirExplanationOfBenefit.SetOriginalPrescription(value : TFhirReference{TFhirMedicationRequest});
begin
  FOriginalPrescription.free;
  FOriginalPrescription := value;
end;

Procedure TFhirExplanationOfBenefit.SetPayee(value : TFhirExplanationOfBenefitPayee);
begin
  FPayee.free;
  FPayee := value;
end;

Procedure TFhirExplanationOfBenefit.SetReferral(value : TFhirReference{TFhirServiceRequest});
begin
  FReferral.free;
  FReferral := value;
end;

Procedure TFhirExplanationOfBenefit.SetFacility(value : TFhirReference{TFhirLocation});
begin
  FFacility.free;
  FFacility := value;
end;

Procedure TFhirExplanationOfBenefit.SetClaim(value : TFhirReference{TFhirClaim});
begin
  FClaim.free;
  FClaim := value;
end;

Procedure TFhirExplanationOfBenefit.SetClaimResponse(value : TFhirReference{TFhirClaimResponse});
begin
  FClaimResponse.free;
  FClaimResponse := value;
end;

Procedure TFhirExplanationOfBenefit.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirExplanationOfBenefit.GetOutcomeST : TFhirRemittanceOutcomeEnum;
begin
  if FOutcome = nil then
    result := TFhirRemittanceOutcomeEnum(0)
  else
    result := TFhirRemittanceOutcomeEnum(StringArrayIndexOfSensitive(CODES_TFhirRemittanceOutcomeEnum, FOutcome.value));
end;

Procedure TFhirExplanationOfBenefit.SetOutcomeST(value : TFhirRemittanceOutcomeEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirRemittanceOutcomeEnum[value], CODES_TFhirRemittanceOutcomeEnum[value]);
end;

Procedure TFhirExplanationOfBenefit.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

Function TFhirExplanationOfBenefit.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

Procedure TFhirExplanationOfBenefit.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

Function TFhirExplanationOfBenefit.GetPreAuthRefList : TFhirStringList;
begin
  if FPreAuthRefList = nil then
    FPreAuthRefList := TFhirStringList.Create;
  result := FPreAuthRefList;
end;

Function TFhirExplanationOfBenefit.GetHasPreAuthRefList : boolean;
begin
  result := (FPreAuthRefList <> nil) and (FPreAuthRefList.count > 0);
end;

Function TFhirExplanationOfBenefit.GetPreAuthRefPeriodList : TFhirPeriodList;
begin
  if FPreAuthRefPeriodList = nil then
    FPreAuthRefPeriodList := TFhirPeriodList.Create;
  result := FPreAuthRefPeriodList;
end;

Function TFhirExplanationOfBenefit.GetHasPreAuthRefPeriodList : boolean;
begin
  result := (FPreAuthRefPeriodList <> nil) and (FPreAuthRefPeriodList.count > 0);
end;

Function TFhirExplanationOfBenefit.GetCareTeamList : TFhirExplanationOfBenefitCareTeamList;
begin
  if FCareTeamList = nil then
    FCareTeamList := TFhirExplanationOfBenefitCareTeamList.Create;
  result := FCareTeamList;
end;

Function TFhirExplanationOfBenefit.GetHasCareTeamList : boolean;
begin
  result := (FCareTeamList <> nil) and (FCareTeamList.count > 0);
end;

Function TFhirExplanationOfBenefit.GetSupportingInfoList : TFhirExplanationOfBenefitSupportingInfoList;
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirExplanationOfBenefitSupportingInfoList.Create;
  result := FSupportingInfoList;
end;

Function TFhirExplanationOfBenefit.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

Function TFhirExplanationOfBenefit.GetDiagnosisList : TFhirExplanationOfBenefitDiagnosisList;
begin
  if FDiagnosisList = nil then
    FDiagnosisList := TFhirExplanationOfBenefitDiagnosisList.Create;
  result := FDiagnosisList;
end;

Function TFhirExplanationOfBenefit.GetHasDiagnosisList : boolean;
begin
  result := (FDiagnosisList <> nil) and (FDiagnosisList.count > 0);
end;

Function TFhirExplanationOfBenefit.GetProcedure_List : TFhirExplanationOfBenefitProcedureList;
begin
  if FProcedure_List = nil then
    FProcedure_List := TFhirExplanationOfBenefitProcedureList.Create;
  result := FProcedure_List;
end;

Function TFhirExplanationOfBenefit.GetHasProcedure_List : boolean;
begin
  result := (FProcedure_List <> nil) and (FProcedure_List.count > 0);
end;

Procedure TFhirExplanationOfBenefit.SetPrecedence(value : TFhirPositiveInt);
begin
  FPrecedence.free;
  FPrecedence := value;
end;

Function TFhirExplanationOfBenefit.GetPrecedenceST : String;
begin
  if FPrecedence = nil then
    result := ''
  else
    result := FPrecedence.value;
end;

Procedure TFhirExplanationOfBenefit.SetPrecedenceST(value : String);
begin
  if value <> '' then
  begin
    if FPrecedence = nil then
      FPrecedence := TFhirPositiveInt.create;
    FPrecedence.value := value
  end
  else if FPrecedence <> nil then
    FPrecedence.value := '';
end;

Function TFhirExplanationOfBenefit.GetInsuranceList : TFhirExplanationOfBenefitInsuranceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirExplanationOfBenefitInsuranceList.Create;
  result := FInsuranceList;
end;

Function TFhirExplanationOfBenefit.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

Procedure TFhirExplanationOfBenefit.SetAccident(value : TFhirExplanationOfBenefitAccident);
begin
  FAccident.free;
  FAccident := value;
end;

Function TFhirExplanationOfBenefit.GetItemList : TFhirExplanationOfBenefitItemList;
begin
  if FItemList = nil then
    FItemList := TFhirExplanationOfBenefitItemList.Create;
  result := FItemList;
end;

Function TFhirExplanationOfBenefit.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

Function TFhirExplanationOfBenefit.GetAddItemList : TFhirExplanationOfBenefitAddItemList;
begin
  if FAddItemList = nil then
    FAddItemList := TFhirExplanationOfBenefitAddItemList.Create;
  result := FAddItemList;
end;

Function TFhirExplanationOfBenefit.GetHasAddItemList : boolean;
begin
  result := (FAddItemList <> nil) and (FAddItemList.count > 0);
end;

Function TFhirExplanationOfBenefit.GetAdjudicationList : TFhirExplanationOfBenefitItemAdjudicationList;
begin
  if FAdjudicationList = nil then
    FAdjudicationList := TFhirExplanationOfBenefitItemAdjudicationList.Create;
  result := FAdjudicationList;
end;

Function TFhirExplanationOfBenefit.GetHasAdjudicationList : boolean;
begin
  result := (FAdjudicationList <> nil) and (FAdjudicationList.count > 0);
end;

Function TFhirExplanationOfBenefit.GetTotalList : TFhirExplanationOfBenefitTotalList;
begin
  if FTotalList = nil then
    FTotalList := TFhirExplanationOfBenefitTotalList.Create;
  result := FTotalList;
end;

Function TFhirExplanationOfBenefit.GetHasTotalList : boolean;
begin
  result := (FTotalList <> nil) and (FTotalList.count > 0);
end;

Procedure TFhirExplanationOfBenefit.SetPayment(value : TFhirExplanationOfBenefitPayment);
begin
  FPayment.free;
  FPayment := value;
end;

Procedure TFhirExplanationOfBenefit.SetFormCode(value : TFhirCodeableConcept);
begin
  FFormCode.free;
  FFormCode := value;
end;

Procedure TFhirExplanationOfBenefit.SetForm(value : TFhirAttachment);
begin
  FForm.free;
  FForm := value;
end;

Function TFhirExplanationOfBenefit.GetProcessNoteList : TFhirExplanationOfBenefitProcessNoteList;
begin
  if FProcessNoteList = nil then
    FProcessNoteList := TFhirExplanationOfBenefitProcessNoteList.Create;
  result := FProcessNoteList;
end;

Function TFhirExplanationOfBenefit.GetHasProcessNoteList : boolean;
begin
  result := (FProcessNoteList <> nil) and (FProcessNoteList.count > 0);
end;

Procedure TFhirExplanationOfBenefit.SetBenefitPeriod(value : TFhirPeriod);
begin
  FBenefitPeriod.free;
  FBenefitPeriod := value;
end;

Function TFhirExplanationOfBenefit.GetBenefitBalanceList : TFhirExplanationOfBenefitBenefitBalanceList;
begin
  if FBenefitBalanceList = nil then
    FBenefitBalanceList := TFhirExplanationOfBenefitBenefitBalanceList.Create;
  result := FBenefitBalanceList;
end;

Function TFhirExplanationOfBenefit.GetHasBenefitBalanceList : boolean;
begin
  result := (FBenefitBalanceList <> nil) and (FBenefitBalanceList.count > 0);
end;

function TFhirExplanationOfBenefit.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSubType.sizeInBytes);
  inc(result, FUse.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FBillablePeriod.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FEnterer.sizeInBytes);
  inc(result, FInsurer.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FFundsReserveRequested.sizeInBytes);
  inc(result, FFundsReserve.sizeInBytes);
  inc(result, FrelatedList.sizeInBytes);
  inc(result, FPrescription.sizeInBytes);
  inc(result, FOriginalPrescription.sizeInBytes);
  inc(result, FPayee.sizeInBytes);
  inc(result, FReferral.sizeInBytes);
  inc(result, FFacility.sizeInBytes);
  inc(result, FClaim.sizeInBytes);
  inc(result, FClaimResponse.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FpreAuthRefList.sizeInBytes);
  inc(result, FpreAuthRefPeriodList.sizeInBytes);
  inc(result, FcareTeamList.sizeInBytes);
  inc(result, FsupportingInfoList.sizeInBytes);
  inc(result, FdiagnosisList.sizeInBytes);
  inc(result, Fprocedure_List.sizeInBytes);
  inc(result, FPrecedence.sizeInBytes);
  inc(result, FinsuranceList.sizeInBytes);
  inc(result, FAccident.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
  inc(result, FaddItemList.sizeInBytes);
  inc(result, FadjudicationList.sizeInBytes);
  inc(result, FtotalList.sizeInBytes);
  inc(result, FPayment.sizeInBytes);
  inc(result, FFormCode.sizeInBytes);
  inc(result, FForm.sizeInBytes);
  inc(result, FprocessNoteList.sizeInBytes);
  inc(result, FBenefitPeriod.sizeInBytes);
  inc(result, FbenefitBalanceList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitListEnumerator }

Constructor TFhirExplanationOfBenefitListEnumerator.Create(list : TFhirExplanationOfBenefitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExplanationOfBenefitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExplanationOfBenefitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExplanationOfBenefitListEnumerator.GetCurrent : TFhirExplanationOfBenefit;
begin
  Result := FList[FIndex];
end;

function TFhirExplanationOfBenefitListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExplanationOfBenefitList }
procedure TFhirExplanationOfBenefitList.AddItem(value: TFhirExplanationOfBenefit);
begin
  assert(value.ClassName = 'TFhirExplanationOfBenefit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExplanationOfBenefit');
  add(value);
end;

function TFhirExplanationOfBenefitList.Append: TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitList.ClearItems;
begin
  Clear;
end;

function TFhirExplanationOfBenefitList.GetEnumerator : TFhirExplanationOfBenefitListEnumerator;
begin
  result := TFhirExplanationOfBenefitListEnumerator.Create(self.link);
end;

function TFhirExplanationOfBenefitList.Clone: TFhirExplanationOfBenefitList;
begin
  result := TFhirExplanationOfBenefitList(inherited Clone);
end;

function TFhirExplanationOfBenefitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExplanationOfBenefitList.GetItemN(index: Integer): TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitList.ItemClass: TFslObjectClass;
begin
  result := TFhirExplanationOfBenefit;
end;
function TFhirExplanationOfBenefitList.IndexOf(value: TFhirExplanationOfBenefit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExplanationOfBenefitList.Insert(index: Integer): TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExplanationOfBenefitList.InsertItem(index: Integer; value: TFhirExplanationOfBenefit);
begin
  assert(value is TFhirExplanationOfBenefit);
  Inherited Insert(index, value);
end;

function TFhirExplanationOfBenefitList.Item(index: Integer): TFhirExplanationOfBenefit;
begin
  result := TFhirExplanationOfBenefit(ObjectByIndex[index]);
end;

function TFhirExplanationOfBenefitList.Link: TFhirExplanationOfBenefitList;
begin
  result := TFhirExplanationOfBenefitList(inherited Link);
end;

procedure TFhirExplanationOfBenefitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExplanationOfBenefitList.SetItemByIndex(index: Integer; value: TFhirExplanationOfBenefit);
begin
  assert(value is TFhirExplanationOfBenefit);
  FhirExplanationOfBenefits[index] := value;
end;

procedure TFhirExplanationOfBenefitList.SetItemN(index: Integer; value: TFhirExplanationOfBenefit);
begin
  assert(value is TFhirExplanationOfBenefit);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_EXPLANATIONOFBENEFIT}

{$IFDEF FHIR_INSURANCEPLAN}

{ TFhirInsurancePlanContact }

constructor TFhirInsurancePlanContact.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanContact.Destroy;
begin
  FPurpose.free;
  FName.free;
  FTelecomList.Free;
  FAddress.free;
  inherited;
end;

procedure TFhirInsurancePlanContact.Assign(oSource : TFslObject);
begin
  inherited;
  purpose := TFhirInsurancePlanContact(oSource).purpose.Clone;
  name := TFhirInsurancePlanContact(oSource).name.Clone;
  if (TFhirInsurancePlanContact(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirInsurancePlanContact(oSource).FTelecomList);
  end;
  address := TFhirInsurancePlanContact(oSource).address.Clone;
end;

procedure TFhirInsurancePlanContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
end;

procedure TFhirInsurancePlanContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'purpose', 'CodeableConcept', false, TFhirCodeableConcept, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'HumanName', false, TFhirHumanName, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'address', 'Address', false, TFhirAddress, FAddress.Link));{2}
end;

function TFhirInsurancePlanContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'purpose') then
  begin
    Purpose := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    Name := propValue as TFhirHumanName{4b};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    Address := propValue as TFhirAddress{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else inherited;
end;

function TFhirInsurancePlanContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'purpose') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'name') then result := TFhirHumanName.create(){4b}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else if (propName = 'address') then result := TFhirAddress.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'purpose') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'address') then result := 'Address'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else if (propName = 'address') then AddressElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'name') then NameElement := new as TFhirHumanName{4}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else if (propName = 'address') then AddressElement := new as TFhirAddress{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanContact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanContact.fhirType : string;
begin
  result := 'contact';
end;

function TFhirInsurancePlanContact.Link : TFhirInsurancePlanContact;
begin
  result := TFhirInsurancePlanContact(inherited Link);
end;

function TFhirInsurancePlanContact.Clone : TFhirInsurancePlanContact;
begin
  result := TFhirInsurancePlanContact(inherited Clone);
end;

function TFhirInsurancePlanContact.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanContact)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanContact(other);
    result := compareDeep(purposeElement, o.purposeElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(telecomList, o.telecomList, true) and compareDeep(addressElement, o.addressElement, true);
  end;
end;

function TFhirInsurancePlanContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPurpose) and isEmptyProp(FName) and isEmptyProp(FtelecomList) and isEmptyProp(FAddress);
end;

procedure TFhirInsurancePlanContact.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('purpose');
  fields.add('name');
  fields.add('telecom');
  fields.add('address');
end;

{ TFhirInsurancePlanContact }

Procedure TFhirInsurancePlanContact.SetPurpose(value : TFhirCodeableConcept);
begin
  FPurpose.free;
  FPurpose := value;
end;

Procedure TFhirInsurancePlanContact.SetName(value : TFhirHumanName);
begin
  FName.free;
  FName := value;
end;

Function TFhirInsurancePlanContact.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirInsurancePlanContact.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

Procedure TFhirInsurancePlanContact.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value;
end;

function TFhirInsurancePlanContact.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPurpose.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
  inc(result, FAddress.sizeInBytes);
end;

{ TFhirInsurancePlanContactListEnumerator }

Constructor TFhirInsurancePlanContactListEnumerator.Create(list : TFhirInsurancePlanContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanContactListEnumerator.GetCurrent : TFhirInsurancePlanContact;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanContactListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInsurancePlanContactList }
procedure TFhirInsurancePlanContactList.AddItem(value: TFhirInsurancePlanContact);
begin
  assert(value.ClassName = 'TFhirInsurancePlanContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanContact');
  add(value);
end;

function TFhirInsurancePlanContactList.Append: TFhirInsurancePlanContact;
begin
  result := TFhirInsurancePlanContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanContactList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanContactList.GetEnumerator : TFhirInsurancePlanContactListEnumerator;
begin
  result := TFhirInsurancePlanContactListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanContactList.Clone: TFhirInsurancePlanContactList;
begin
  result := TFhirInsurancePlanContactList(inherited Clone);
end;

function TFhirInsurancePlanContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanContactList.GetItemN(index: Integer): TFhirInsurancePlanContact;
begin
  result := TFhirInsurancePlanContact(ObjectByIndex[index]);
end;

function TFhirInsurancePlanContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanContact;
end;
function TFhirInsurancePlanContactList.IndexOf(value: TFhirInsurancePlanContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanContactList.Insert(index: Integer): TFhirInsurancePlanContact;
begin
  result := TFhirInsurancePlanContact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanContactList.InsertItem(index: Integer; value: TFhirInsurancePlanContact);
begin
  assert(value is TFhirInsurancePlanContact);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanContactList.Item(index: Integer): TFhirInsurancePlanContact;
begin
  result := TFhirInsurancePlanContact(ObjectByIndex[index]);
end;

function TFhirInsurancePlanContactList.Link: TFhirInsurancePlanContactList;
begin
  result := TFhirInsurancePlanContactList(inherited Link);
end;

procedure TFhirInsurancePlanContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanContactList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanContact);
begin
  assert(value is TFhirInsurancePlanContact);
  FhirInsurancePlanContacts[index] := value;
end;

procedure TFhirInsurancePlanContactList.SetItemN(index: Integer; value: TFhirInsurancePlanContact);
begin
  assert(value is TFhirInsurancePlanContact);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanCoverage }

constructor TFhirInsurancePlanCoverage.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanCoverage.Destroy;
begin
  FType_.free;
  FNetworkList.Free;
  FBenefitList.Free;
  inherited;
end;

procedure TFhirInsurancePlanCoverage.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirInsurancePlanCoverage(oSource).type_.Clone;
  if (TFhirInsurancePlanCoverage(oSource).FNetworkList = nil) then
  begin
    FNetworkList.free;
    FNetworkList := nil;
  end
  else
  begin
    if FNetworkList = nil then
      FNetworkList := TFhirReferenceList{TFhirOrganization}.Create;
    FNetworkList.Assign(TFhirInsurancePlanCoverage(oSource).FNetworkList);
  end;
  if (TFhirInsurancePlanCoverage(oSource).FBenefitList = nil) then
  begin
    FBenefitList.free;
    FBenefitList := nil;
  end
  else
  begin
    if FBenefitList = nil then
      FBenefitList := TFhirInsurancePlanCoverageBenefitList.Create;
    FBenefitList.Assign(TFhirInsurancePlanCoverage(oSource).FBenefitList);
  end;
end;

procedure TFhirInsurancePlanCoverage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'network') Then
    list.addAll(self, 'network', FNetworkList);
  if (child_name = 'benefit') Then
    list.addAll(self, 'benefit', FBenefitList);
end;

procedure TFhirInsurancePlanCoverage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'network', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FNetworkList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'benefit', '', true, TFhirInsurancePlanCoverageBenefit, FBenefitList.Link)){3};
end;

function TFhirInsurancePlanCoverage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    NetworkList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else if (propName = 'benefit') then
  begin
    BenefitList.add(propValue as TFhirInsurancePlanCoverageBenefit){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanCoverage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'network') then NetworkList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else if (propName = 'benefit') then BenefitList.insertItem(index, propValue as TFhirInsurancePlanCoverageBenefit){2a}
  else inherited;
end;

function TFhirInsurancePlanCoverage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'network') then result := NetworkList.new(){2}
  else if (propName = 'benefit') then result := BenefitList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanCoverage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'network') then result := 'Reference'
  else if (propName = 'benefit') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanCoverage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'network') then deletePropertyValue('network', NetworkList, value) {2}
  else if (propName = 'benefit') then deletePropertyValue('benefit', BenefitList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanCoverage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'network') then replacePropertyValue('network', NetworkList, existing, new) {2}
  else if (propName = 'benefit') then replacePropertyValue('benefit', BenefitList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanCoverage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'network') then NetworkList.move(source, destination){2a}
  else if (propName = 'benefit') then BenefitList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanCoverage.fhirType : string;
begin
  result := 'coverage';
end;

function TFhirInsurancePlanCoverage.Link : TFhirInsurancePlanCoverage;
begin
  result := TFhirInsurancePlanCoverage(inherited Link);
end;

function TFhirInsurancePlanCoverage.Clone : TFhirInsurancePlanCoverage;
begin
  result := TFhirInsurancePlanCoverage(inherited Clone);
end;

function TFhirInsurancePlanCoverage.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanCoverage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanCoverage)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanCoverage(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(networkList, o.networkList, true) and 
      compareDeep(benefitList, o.benefitList, true);
  end;
end;

function TFhirInsurancePlanCoverage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FnetworkList) and isEmptyProp(FbenefitList);
end;

procedure TFhirInsurancePlanCoverage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('network');
  fields.add('benefit');
end;

{ TFhirInsurancePlanCoverage }

Procedure TFhirInsurancePlanCoverage.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirInsurancePlanCoverage.GetNetworkList : TFhirReferenceList{TFhirOrganization};
begin
  if FNetworkList = nil then
    FNetworkList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FNetworkList;
end;

Function TFhirInsurancePlanCoverage.GetHasNetworkList : boolean;
begin
  result := (FNetworkList <> nil) and (FNetworkList.count > 0);
end;

Function TFhirInsurancePlanCoverage.GetBenefitList : TFhirInsurancePlanCoverageBenefitList;
begin
  if FBenefitList = nil then
    FBenefitList := TFhirInsurancePlanCoverageBenefitList.Create;
  result := FBenefitList;
end;

Function TFhirInsurancePlanCoverage.GetHasBenefitList : boolean;
begin
  result := (FBenefitList <> nil) and (FBenefitList.count > 0);
end;

function TFhirInsurancePlanCoverage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FnetworkList.sizeInBytes);
  inc(result, FbenefitList.sizeInBytes);
end;

{ TFhirInsurancePlanCoverageListEnumerator }

Constructor TFhirInsurancePlanCoverageListEnumerator.Create(list : TFhirInsurancePlanCoverageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanCoverageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanCoverageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanCoverageListEnumerator.GetCurrent : TFhirInsurancePlanCoverage;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanCoverageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInsurancePlanCoverageList }
procedure TFhirInsurancePlanCoverageList.AddItem(value: TFhirInsurancePlanCoverage);
begin
  assert(value.ClassName = 'TFhirInsurancePlanCoverage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanCoverage');
  add(value);
end;

function TFhirInsurancePlanCoverageList.Append: TFhirInsurancePlanCoverage;
begin
  result := TFhirInsurancePlanCoverage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanCoverageList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanCoverageList.GetEnumerator : TFhirInsurancePlanCoverageListEnumerator;
begin
  result := TFhirInsurancePlanCoverageListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanCoverageList.Clone: TFhirInsurancePlanCoverageList;
begin
  result := TFhirInsurancePlanCoverageList(inherited Clone);
end;

function TFhirInsurancePlanCoverageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanCoverageList.GetItemN(index: Integer): TFhirInsurancePlanCoverage;
begin
  result := TFhirInsurancePlanCoverage(ObjectByIndex[index]);
end;

function TFhirInsurancePlanCoverageList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanCoverage;
end;
function TFhirInsurancePlanCoverageList.IndexOf(value: TFhirInsurancePlanCoverage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanCoverageList.Insert(index: Integer): TFhirInsurancePlanCoverage;
begin
  result := TFhirInsurancePlanCoverage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanCoverageList.InsertItem(index: Integer; value: TFhirInsurancePlanCoverage);
begin
  assert(value is TFhirInsurancePlanCoverage);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanCoverageList.Item(index: Integer): TFhirInsurancePlanCoverage;
begin
  result := TFhirInsurancePlanCoverage(ObjectByIndex[index]);
end;

function TFhirInsurancePlanCoverageList.Link: TFhirInsurancePlanCoverageList;
begin
  result := TFhirInsurancePlanCoverageList(inherited Link);
end;

procedure TFhirInsurancePlanCoverageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanCoverageList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanCoverage);
begin
  assert(value is TFhirInsurancePlanCoverage);
  FhirInsurancePlanCoverages[index] := value;
end;

procedure TFhirInsurancePlanCoverageList.SetItemN(index: Integer; value: TFhirInsurancePlanCoverage);
begin
  assert(value is TFhirInsurancePlanCoverage);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanCoverageBenefit }

constructor TFhirInsurancePlanCoverageBenefit.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanCoverageBenefit.Destroy;
begin
  FType_.free;
  FRequirement.free;
  FLimitList.Free;
  inherited;
end;

procedure TFhirInsurancePlanCoverageBenefit.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirInsurancePlanCoverageBenefit(oSource).type_.Clone;
  requirementElement := TFhirInsurancePlanCoverageBenefit(oSource).requirementElement.Clone;
  if (TFhirInsurancePlanCoverageBenefit(oSource).FLimitList = nil) then
  begin
    FLimitList.free;
    FLimitList := nil;
  end
  else
  begin
    if FLimitList = nil then
      FLimitList := TFhirInsurancePlanCoverageBenefitLimitList.Create;
    FLimitList.Assign(TFhirInsurancePlanCoverageBenefit(oSource).FLimitList);
  end;
end;

procedure TFhirInsurancePlanCoverageBenefit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'requirement') Then
     list.add(self.link, 'requirement', FRequirement.Link);
  if (child_name = 'limit') Then
    list.addAll(self, 'limit', FLimitList);
end;

procedure TFhirInsurancePlanCoverageBenefit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requirement', 'string', false, TFhirString, FRequirement.Link));{2}
  oList.add(TFHIRProperty.create(self, 'limit', '', true, TFhirInsurancePlanCoverageBenefitLimit, FLimitList.Link)){3};
end;

function TFhirInsurancePlanCoverageBenefit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'requirement') then
  begin
    RequirementElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'limit') then
  begin
    LimitList.add(propValue as TFhirInsurancePlanCoverageBenefitLimit){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanCoverageBenefit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'limit') then LimitList.insertItem(index, propValue as TFhirInsurancePlanCoverageBenefitLimit){2a}
  else inherited;
end;

function TFhirInsurancePlanCoverageBenefit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'requirement') then result := TFhirString.create() {5b}
  else if (propName = 'limit') then result := LimitList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanCoverageBenefit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'requirement') then result := 'string'
  else if (propName = 'limit') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanCoverageBenefit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'requirement') then RequirementElement := nil
  else if (propName = 'limit') then deletePropertyValue('limit', LimitList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanCoverageBenefit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'requirement') then RequirementElement := asString(new){5b}
  else if (propName = 'limit') then replacePropertyValue('limit', LimitList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanCoverageBenefit.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'limit') then LimitList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanCoverageBenefit.fhirType : string;
begin
  result := 'benefit';
end;

function TFhirInsurancePlanCoverageBenefit.Link : TFhirInsurancePlanCoverageBenefit;
begin
  result := TFhirInsurancePlanCoverageBenefit(inherited Link);
end;

function TFhirInsurancePlanCoverageBenefit.Clone : TFhirInsurancePlanCoverageBenefit;
begin
  result := TFhirInsurancePlanCoverageBenefit(inherited Clone);
end;

function TFhirInsurancePlanCoverageBenefit.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanCoverageBenefit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanCoverageBenefit)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanCoverageBenefit(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(requirementElement, o.requirementElement, true) and 
      compareDeep(limitList, o.limitList, true);
  end;
end;

function TFhirInsurancePlanCoverageBenefit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FRequirement) and isEmptyProp(FlimitList);
end;

procedure TFhirInsurancePlanCoverageBenefit.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('requirement');
  fields.add('limit');
end;

{ TFhirInsurancePlanCoverageBenefit }

Procedure TFhirInsurancePlanCoverageBenefit.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirInsurancePlanCoverageBenefit.SetRequirement(value : TFhirString);
begin
  FRequirement.free;
  FRequirement := value;
end;

Function TFhirInsurancePlanCoverageBenefit.GetRequirementST : String;
begin
  if FRequirement = nil then
    result := ''
  else
    result := FRequirement.value;
end;

Procedure TFhirInsurancePlanCoverageBenefit.SetRequirementST(value : String);
begin
  if value <> '' then
  begin
    if FRequirement = nil then
      FRequirement := TFhirString.create;
    FRequirement.value := value
  end
  else if FRequirement <> nil then
    FRequirement.value := '';
end;

Function TFhirInsurancePlanCoverageBenefit.GetLimitList : TFhirInsurancePlanCoverageBenefitLimitList;
begin
  if FLimitList = nil then
    FLimitList := TFhirInsurancePlanCoverageBenefitLimitList.Create;
  result := FLimitList;
end;

Function TFhirInsurancePlanCoverageBenefit.GetHasLimitList : boolean;
begin
  result := (FLimitList <> nil) and (FLimitList.count > 0);
end;

function TFhirInsurancePlanCoverageBenefit.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FRequirement.sizeInBytes);
  inc(result, FlimitList.sizeInBytes);
end;

{ TFhirInsurancePlanCoverageBenefitListEnumerator }

Constructor TFhirInsurancePlanCoverageBenefitListEnumerator.Create(list : TFhirInsurancePlanCoverageBenefitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanCoverageBenefitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanCoverageBenefitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanCoverageBenefitListEnumerator.GetCurrent : TFhirInsurancePlanCoverageBenefit;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanCoverageBenefitListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInsurancePlanCoverageBenefitList }
procedure TFhirInsurancePlanCoverageBenefitList.AddItem(value: TFhirInsurancePlanCoverageBenefit);
begin
  assert(value.ClassName = 'TFhirInsurancePlanCoverageBenefit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanCoverageBenefit');
  add(value);
end;

function TFhirInsurancePlanCoverageBenefitList.Append: TFhirInsurancePlanCoverageBenefit;
begin
  result := TFhirInsurancePlanCoverageBenefit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanCoverageBenefitList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanCoverageBenefitList.GetEnumerator : TFhirInsurancePlanCoverageBenefitListEnumerator;
begin
  result := TFhirInsurancePlanCoverageBenefitListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanCoverageBenefitList.Clone: TFhirInsurancePlanCoverageBenefitList;
begin
  result := TFhirInsurancePlanCoverageBenefitList(inherited Clone);
end;

function TFhirInsurancePlanCoverageBenefitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanCoverageBenefitList.GetItemN(index: Integer): TFhirInsurancePlanCoverageBenefit;
begin
  result := TFhirInsurancePlanCoverageBenefit(ObjectByIndex[index]);
end;

function TFhirInsurancePlanCoverageBenefitList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanCoverageBenefit;
end;
function TFhirInsurancePlanCoverageBenefitList.IndexOf(value: TFhirInsurancePlanCoverageBenefit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanCoverageBenefitList.Insert(index: Integer): TFhirInsurancePlanCoverageBenefit;
begin
  result := TFhirInsurancePlanCoverageBenefit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanCoverageBenefitList.InsertItem(index: Integer; value: TFhirInsurancePlanCoverageBenefit);
begin
  assert(value is TFhirInsurancePlanCoverageBenefit);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanCoverageBenefitList.Item(index: Integer): TFhirInsurancePlanCoverageBenefit;
begin
  result := TFhirInsurancePlanCoverageBenefit(ObjectByIndex[index]);
end;

function TFhirInsurancePlanCoverageBenefitList.Link: TFhirInsurancePlanCoverageBenefitList;
begin
  result := TFhirInsurancePlanCoverageBenefitList(inherited Link);
end;

procedure TFhirInsurancePlanCoverageBenefitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanCoverageBenefitList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanCoverageBenefit);
begin
  assert(value is TFhirInsurancePlanCoverageBenefit);
  FhirInsurancePlanCoverageBenefits[index] := value;
end;

procedure TFhirInsurancePlanCoverageBenefitList.SetItemN(index: Integer; value: TFhirInsurancePlanCoverageBenefit);
begin
  assert(value is TFhirInsurancePlanCoverageBenefit);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanCoverageBenefitLimit }

constructor TFhirInsurancePlanCoverageBenefitLimit.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanCoverageBenefitLimit.Destroy;
begin
  FValue.free;
  FCode.free;
  inherited;
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirInsurancePlanCoverageBenefitLimit(oSource).value.Clone;
  code := TFhirInsurancePlanCoverageBenefitLimit(oSource).code.Clone;
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value', 'Quantity', false, TFhirQuantity, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
end;

function TFhirInsurancePlanCoverageBenefitLimit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'value') then
  begin
    Value := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirInsurancePlanCoverageBenefitLimit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'value') then result := TFhirQuantity.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanCoverageBenefitLimit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value') then result := 'Quantity'
  else if (propName = 'code') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := nil
  else if (propName = 'code') then CodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := new as TFhirQuantity{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanCoverageBenefitLimit.fhirType : string;
begin
  result := 'limit';
end;

function TFhirInsurancePlanCoverageBenefitLimit.Link : TFhirInsurancePlanCoverageBenefitLimit;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit(inherited Link);
end;

function TFhirInsurancePlanCoverageBenefitLimit.Clone : TFhirInsurancePlanCoverageBenefitLimit;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit(inherited Clone);
end;

function TFhirInsurancePlanCoverageBenefitLimit.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanCoverageBenefitLimit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanCoverageBenefitLimit)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanCoverageBenefitLimit(other);
    result := compareDeep(valueElement, o.valueElement, true) and compareDeep(codeElement, o.codeElement, true);
  end;
end;

function TFhirInsurancePlanCoverageBenefitLimit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue) and isEmptyProp(FCode);
end;

procedure TFhirInsurancePlanCoverageBenefitLimit.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('value');
  fields.add('code');
end;

{ TFhirInsurancePlanCoverageBenefitLimit }

Procedure TFhirInsurancePlanCoverageBenefitLimit.SetValue(value : TFhirQuantity);
begin
  FValue.free;
  FValue := value;
end;

Procedure TFhirInsurancePlanCoverageBenefitLimit.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirInsurancePlanCoverageBenefitLimit.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FValue.sizeInBytes);
  inc(result, FCode.sizeInBytes);
end;

{ TFhirInsurancePlanCoverageBenefitLimitListEnumerator }

Constructor TFhirInsurancePlanCoverageBenefitLimitListEnumerator.Create(list : TFhirInsurancePlanCoverageBenefitLimitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanCoverageBenefitLimitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanCoverageBenefitLimitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanCoverageBenefitLimitListEnumerator.GetCurrent : TFhirInsurancePlanCoverageBenefitLimit;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanCoverageBenefitLimitListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInsurancePlanCoverageBenefitLimitList }
procedure TFhirInsurancePlanCoverageBenefitLimitList.AddItem(value: TFhirInsurancePlanCoverageBenefitLimit);
begin
  assert(value.ClassName = 'TFhirInsurancePlanCoverageBenefitLimit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanCoverageBenefitLimit');
  add(value);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.Append: TFhirInsurancePlanCoverageBenefitLimit;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanCoverageBenefitLimitList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanCoverageBenefitLimitList.GetEnumerator : TFhirInsurancePlanCoverageBenefitLimitListEnumerator;
begin
  result := TFhirInsurancePlanCoverageBenefitLimitListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.Clone: TFhirInsurancePlanCoverageBenefitLimitList;
begin
  result := TFhirInsurancePlanCoverageBenefitLimitList(inherited Clone);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanCoverageBenefitLimitList.GetItemN(index: Integer): TFhirInsurancePlanCoverageBenefitLimit;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit(ObjectByIndex[index]);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit;
end;
function TFhirInsurancePlanCoverageBenefitLimitList.IndexOf(value: TFhirInsurancePlanCoverageBenefitLimit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.Insert(index: Integer): TFhirInsurancePlanCoverageBenefitLimit;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanCoverageBenefitLimitList.InsertItem(index: Integer; value: TFhirInsurancePlanCoverageBenefitLimit);
begin
  assert(value is TFhirInsurancePlanCoverageBenefitLimit);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.Item(index: Integer): TFhirInsurancePlanCoverageBenefitLimit;
begin
  result := TFhirInsurancePlanCoverageBenefitLimit(ObjectByIndex[index]);
end;

function TFhirInsurancePlanCoverageBenefitLimitList.Link: TFhirInsurancePlanCoverageBenefitLimitList;
begin
  result := TFhirInsurancePlanCoverageBenefitLimitList(inherited Link);
end;

procedure TFhirInsurancePlanCoverageBenefitLimitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanCoverageBenefitLimitList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanCoverageBenefitLimit);
begin
  assert(value is TFhirInsurancePlanCoverageBenefitLimit);
  FhirInsurancePlanCoverageBenefitLimits[index] := value;
end;

procedure TFhirInsurancePlanCoverageBenefitLimitList.SetItemN(index: Integer; value: TFhirInsurancePlanCoverageBenefitLimit);
begin
  assert(value is TFhirInsurancePlanCoverageBenefitLimit);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanPlan }

constructor TFhirInsurancePlanPlan.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanPlan.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FCoverageAreaList.Free;
  FNetworkList.Free;
  FGeneralCostList.Free;
  FSpecificCostList.Free;
  inherited;
end;

procedure TFhirInsurancePlanPlan.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirInsurancePlanPlan(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirInsurancePlanPlan(oSource).FIdentifierList);
  end;
  type_ := TFhirInsurancePlanPlan(oSource).type_.Clone;
  if (TFhirInsurancePlanPlan(oSource).FCoverageAreaList = nil) then
  begin
    FCoverageAreaList.free;
    FCoverageAreaList := nil;
  end
  else
  begin
    if FCoverageAreaList = nil then
      FCoverageAreaList := TFhirReferenceList{TFhirLocation}.Create;
    FCoverageAreaList.Assign(TFhirInsurancePlanPlan(oSource).FCoverageAreaList);
  end;
  if (TFhirInsurancePlanPlan(oSource).FNetworkList = nil) then
  begin
    FNetworkList.free;
    FNetworkList := nil;
  end
  else
  begin
    if FNetworkList = nil then
      FNetworkList := TFhirReferenceList{TFhirOrganization}.Create;
    FNetworkList.Assign(TFhirInsurancePlanPlan(oSource).FNetworkList);
  end;
  if (TFhirInsurancePlanPlan(oSource).FGeneralCostList = nil) then
  begin
    FGeneralCostList.free;
    FGeneralCostList := nil;
  end
  else
  begin
    if FGeneralCostList = nil then
      FGeneralCostList := TFhirInsurancePlanPlanGeneralCostList.Create;
    FGeneralCostList.Assign(TFhirInsurancePlanPlan(oSource).FGeneralCostList);
  end;
  if (TFhirInsurancePlanPlan(oSource).FSpecificCostList = nil) then
  begin
    FSpecificCostList.free;
    FSpecificCostList := nil;
  end
  else
  begin
    if FSpecificCostList = nil then
      FSpecificCostList := TFhirInsurancePlanPlanSpecificCostList.Create;
    FSpecificCostList.Assign(TFhirInsurancePlanPlan(oSource).FSpecificCostList);
  end;
end;

procedure TFhirInsurancePlanPlan.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'coverageArea') Then
    list.addAll(self, 'coverageArea', FCoverageAreaList);
  if (child_name = 'network') Then
    list.addAll(self, 'network', FNetworkList);
  if (child_name = 'generalCost') Then
    list.addAll(self, 'generalCost', FGeneralCostList);
  if (child_name = 'specificCost') Then
    list.addAll(self, 'specificCost', FSpecificCostList);
end;

procedure TFhirInsurancePlanPlan.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'coverageArea', 'Reference(Location)', true, TFhirReference{TFhirLocation}, FCoverageAreaList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'network', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FNetworkList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'generalCost', '', true, TFhirInsurancePlanPlanGeneralCost, FGeneralCostList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'specificCost', '', true, TFhirInsurancePlanPlanSpecificCost, FSpecificCostList.Link)){3};
end;

function TFhirInsurancePlanPlan.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'coverageArea') then
  begin
    CoverageAreaList.add(propValue as TFhirReference{TFhirLocation}){2a};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    NetworkList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else if (propName = 'generalCost') then
  begin
    GeneralCostList.add(propValue as TFhirInsurancePlanPlanGeneralCost){2a};
    result := propValue;
  end
  else if (propName = 'specificCost') then
  begin
    SpecificCostList.add(propValue as TFhirInsurancePlanPlanSpecificCost){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanPlan.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'coverageArea') then CoverageAreaList.insertItem(index, propValue as TFhirReference{TFhirLocation}){2a}
  else if (propName = 'network') then NetworkList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else if (propName = 'generalCost') then GeneralCostList.insertItem(index, propValue as TFhirInsurancePlanPlanGeneralCost){2a}
  else if (propName = 'specificCost') then SpecificCostList.insertItem(index, propValue as TFhirInsurancePlanPlanSpecificCost){2a}
  else inherited;
end;

function TFhirInsurancePlanPlan.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'coverageArea') then result := CoverageAreaList.new(){2}
  else if (propName = 'network') then result := NetworkList.new(){2}
  else if (propName = 'generalCost') then result := GeneralCostList.new(){2}
  else if (propName = 'specificCost') then result := SpecificCostList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanPlan.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'coverageArea') then result := 'Reference'
  else if (propName = 'network') then result := 'Reference'
  else if (propName = 'generalCost') then result := ''
  else if (propName = 'specificCost') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanPlan.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'coverageArea') then deletePropertyValue('coverageArea', CoverageAreaList, value) {2}
  else if (propName = 'network') then deletePropertyValue('network', NetworkList, value) {2}
  else if (propName = 'generalCost') then deletePropertyValue('generalCost', GeneralCostList, value) {2}
  else if (propName = 'specificCost') then deletePropertyValue('specificCost', SpecificCostList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanPlan.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'coverageArea') then replacePropertyValue('coverageArea', CoverageAreaList, existing, new) {2}
  else if (propName = 'network') then replacePropertyValue('network', NetworkList, existing, new) {2}
  else if (propName = 'generalCost') then replacePropertyValue('generalCost', GeneralCostList, existing, new) {2}
  else if (propName = 'specificCost') then replacePropertyValue('specificCost', SpecificCostList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanPlan.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'coverageArea') then CoverageAreaList.move(source, destination){2a}
  else if (propName = 'network') then NetworkList.move(source, destination){2a}
  else if (propName = 'generalCost') then GeneralCostList.move(source, destination){2a}
  else if (propName = 'specificCost') then SpecificCostList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanPlan.fhirType : string;
begin
  result := 'plan';
end;

function TFhirInsurancePlanPlan.Link : TFhirInsurancePlanPlan;
begin
  result := TFhirInsurancePlanPlan(inherited Link);
end;

function TFhirInsurancePlanPlan.Clone : TFhirInsurancePlanPlan;
begin
  result := TFhirInsurancePlanPlan(inherited Clone);
end;

function TFhirInsurancePlanPlan.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanPlan;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanPlan)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanPlan(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(coverageAreaList, o.coverageAreaList, true) and compareDeep(networkList, o.networkList, true) and 
      compareDeep(generalCostList, o.generalCostList, true) and compareDeep(specificCostList, o.specificCostList, true);
  end;
end;

function TFhirInsurancePlanPlan.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FcoverageAreaList) and isEmptyProp(FnetworkList) and isEmptyProp(FgeneralCostList) and isEmptyProp(FspecificCostList);
end;

procedure TFhirInsurancePlanPlan.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('coverageArea');
  fields.add('network');
  fields.add('generalCost');
  fields.add('specificCost');
end;

{ TFhirInsurancePlanPlan }

Function TFhirInsurancePlanPlan.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirInsurancePlanPlan.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirInsurancePlanPlan.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirInsurancePlanPlan.GetCoverageAreaList : TFhirReferenceList{TFhirLocation};
begin
  if FCoverageAreaList = nil then
    FCoverageAreaList := TFhirReferenceList{TFhirLocation}.Create;
  result := FCoverageAreaList;
end;

Function TFhirInsurancePlanPlan.GetHasCoverageAreaList : boolean;
begin
  result := (FCoverageAreaList <> nil) and (FCoverageAreaList.count > 0);
end;

Function TFhirInsurancePlanPlan.GetNetworkList : TFhirReferenceList{TFhirOrganization};
begin
  if FNetworkList = nil then
    FNetworkList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FNetworkList;
end;

Function TFhirInsurancePlanPlan.GetHasNetworkList : boolean;
begin
  result := (FNetworkList <> nil) and (FNetworkList.count > 0);
end;

Function TFhirInsurancePlanPlan.GetGeneralCostList : TFhirInsurancePlanPlanGeneralCostList;
begin
  if FGeneralCostList = nil then
    FGeneralCostList := TFhirInsurancePlanPlanGeneralCostList.Create;
  result := FGeneralCostList;
end;

Function TFhirInsurancePlanPlan.GetHasGeneralCostList : boolean;
begin
  result := (FGeneralCostList <> nil) and (FGeneralCostList.count > 0);
end;

Function TFhirInsurancePlanPlan.GetSpecificCostList : TFhirInsurancePlanPlanSpecificCostList;
begin
  if FSpecificCostList = nil then
    FSpecificCostList := TFhirInsurancePlanPlanSpecificCostList.Create;
  result := FSpecificCostList;
end;

Function TFhirInsurancePlanPlan.GetHasSpecificCostList : boolean;
begin
  result := (FSpecificCostList <> nil) and (FSpecificCostList.count > 0);
end;

function TFhirInsurancePlanPlan.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FcoverageAreaList.sizeInBytes);
  inc(result, FnetworkList.sizeInBytes);
  inc(result, FgeneralCostList.sizeInBytes);
  inc(result, FspecificCostList.sizeInBytes);
end;

{ TFhirInsurancePlanPlanListEnumerator }

Constructor TFhirInsurancePlanPlanListEnumerator.Create(list : TFhirInsurancePlanPlanList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanPlanListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanPlanListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanPlanListEnumerator.GetCurrent : TFhirInsurancePlanPlan;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanPlanListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInsurancePlanPlanList }
procedure TFhirInsurancePlanPlanList.AddItem(value: TFhirInsurancePlanPlan);
begin
  assert(value.ClassName = 'TFhirInsurancePlanPlan', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanPlan');
  add(value);
end;

function TFhirInsurancePlanPlanList.Append: TFhirInsurancePlanPlan;
begin
  result := TFhirInsurancePlanPlan.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanPlanList.GetEnumerator : TFhirInsurancePlanPlanListEnumerator;
begin
  result := TFhirInsurancePlanPlanListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanPlanList.Clone: TFhirInsurancePlanPlanList;
begin
  result := TFhirInsurancePlanPlanList(inherited Clone);
end;

function TFhirInsurancePlanPlanList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanPlanList.GetItemN(index: Integer): TFhirInsurancePlanPlan;
begin
  result := TFhirInsurancePlanPlan(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanPlan;
end;
function TFhirInsurancePlanPlanList.IndexOf(value: TFhirInsurancePlanPlan): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanPlanList.Insert(index: Integer): TFhirInsurancePlanPlan;
begin
  result := TFhirInsurancePlanPlan.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanList.InsertItem(index: Integer; value: TFhirInsurancePlanPlan);
begin
  assert(value is TFhirInsurancePlanPlan);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanPlanList.Item(index: Integer): TFhirInsurancePlanPlan;
begin
  result := TFhirInsurancePlanPlan(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanList.Link: TFhirInsurancePlanPlanList;
begin
  result := TFhirInsurancePlanPlanList(inherited Link);
end;

procedure TFhirInsurancePlanPlanList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanPlanList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanPlan);
begin
  assert(value is TFhirInsurancePlanPlan);
  FhirInsurancePlanPlans[index] := value;
end;

procedure TFhirInsurancePlanPlanList.SetItemN(index: Integer; value: TFhirInsurancePlanPlan);
begin
  assert(value is TFhirInsurancePlanPlan);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanPlanGeneralCost }

constructor TFhirInsurancePlanPlanGeneralCost.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanPlanGeneralCost.Destroy;
begin
  FType_.free;
  FGroupSize.free;
  FCost.free;
  FComment.free;
  inherited;
end;

procedure TFhirInsurancePlanPlanGeneralCost.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirInsurancePlanPlanGeneralCost(oSource).type_.Clone;
  groupSizeElement := TFhirInsurancePlanPlanGeneralCost(oSource).groupSizeElement.Clone;
  cost := TFhirInsurancePlanPlanGeneralCost(oSource).cost.Clone;
  commentElement := TFhirInsurancePlanPlanGeneralCost(oSource).commentElement.Clone;
end;

procedure TFhirInsurancePlanPlanGeneralCost.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'groupSize') Then
     list.add(self.link, 'groupSize', FGroupSize.Link);
  if (child_name = 'cost') Then
     list.add(self.link, 'cost', FCost.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirInsurancePlanPlanGeneralCost.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'groupSize', 'positiveInt', false, TFhirPositiveInt, FGroupSize.Link));{2}
  oList.add(TFHIRProperty.create(self, 'cost', 'Money', false, TFhirMoney, FCost.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
end;

function TFhirInsurancePlanPlanGeneralCost.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'groupSize') then
  begin
    GroupSizeElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'cost') then
  begin
    Cost := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanPlanGeneralCost.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirInsurancePlanPlanGeneralCost.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'groupSize') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'cost') then result := TFhirMoney.create(){4b}
  else if (propName = 'comment') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanPlanGeneralCost.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'groupSize') then result := 'positiveInt'
  else if (propName = 'cost') then result := 'Money'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanPlanGeneralCost.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'groupSize') then GroupSizeElement := nil
  else if (propName = 'cost') then CostElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanPlanGeneralCost.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'groupSize') then GroupSizeElement := asPositiveInt(new){5b}
  else if (propName = 'cost') then CostElement := new as TFhirMoney{4}
  else if (propName = 'comment') then CommentElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanPlanGeneralCost.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanPlanGeneralCost.fhirType : string;
begin
  result := 'generalCost';
end;

function TFhirInsurancePlanPlanGeneralCost.Link : TFhirInsurancePlanPlanGeneralCost;
begin
  result := TFhirInsurancePlanPlanGeneralCost(inherited Link);
end;

function TFhirInsurancePlanPlanGeneralCost.Clone : TFhirInsurancePlanPlanGeneralCost;
begin
  result := TFhirInsurancePlanPlanGeneralCost(inherited Clone);
end;

function TFhirInsurancePlanPlanGeneralCost.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanPlanGeneralCost;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanPlanGeneralCost)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanPlanGeneralCost(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(groupSizeElement, o.groupSizeElement, true) and 
      compareDeep(costElement, o.costElement, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirInsurancePlanPlanGeneralCost.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FGroupSize) and isEmptyProp(FCost) and isEmptyProp(FComment);
end;

procedure TFhirInsurancePlanPlanGeneralCost.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('groupSize');
  fields.add('cost');
  fields.add('comment');
end;

{ TFhirInsurancePlanPlanGeneralCost }

Procedure TFhirInsurancePlanPlanGeneralCost.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirInsurancePlanPlanGeneralCost.SetGroupSize(value : TFhirPositiveInt);
begin
  FGroupSize.free;
  FGroupSize := value;
end;

Function TFhirInsurancePlanPlanGeneralCost.GetGroupSizeST : String;
begin
  if FGroupSize = nil then
    result := ''
  else
    result := FGroupSize.value;
end;

Procedure TFhirInsurancePlanPlanGeneralCost.SetGroupSizeST(value : String);
begin
  if value <> '' then
  begin
    if FGroupSize = nil then
      FGroupSize := TFhirPositiveInt.create;
    FGroupSize.value := value
  end
  else if FGroupSize <> nil then
    FGroupSize.value := '';
end;

Procedure TFhirInsurancePlanPlanGeneralCost.SetCost(value : TFhirMoney);
begin
  FCost.free;
  FCost := value;
end;

Procedure TFhirInsurancePlanPlanGeneralCost.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirInsurancePlanPlanGeneralCost.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirInsurancePlanPlanGeneralCost.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

function TFhirInsurancePlanPlanGeneralCost.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FGroupSize.sizeInBytes);
  inc(result, FCost.sizeInBytes);
  inc(result, FComment.sizeInBytes);
end;

{ TFhirInsurancePlanPlanGeneralCostListEnumerator }

Constructor TFhirInsurancePlanPlanGeneralCostListEnumerator.Create(list : TFhirInsurancePlanPlanGeneralCostList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanPlanGeneralCostListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanPlanGeneralCostListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanPlanGeneralCostListEnumerator.GetCurrent : TFhirInsurancePlanPlanGeneralCost;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanPlanGeneralCostListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInsurancePlanPlanGeneralCostList }
procedure TFhirInsurancePlanPlanGeneralCostList.AddItem(value: TFhirInsurancePlanPlanGeneralCost);
begin
  assert(value.ClassName = 'TFhirInsurancePlanPlanGeneralCost', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanPlanGeneralCost');
  add(value);
end;

function TFhirInsurancePlanPlanGeneralCostList.Append: TFhirInsurancePlanPlanGeneralCost;
begin
  result := TFhirInsurancePlanPlanGeneralCost.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanGeneralCostList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanPlanGeneralCostList.GetEnumerator : TFhirInsurancePlanPlanGeneralCostListEnumerator;
begin
  result := TFhirInsurancePlanPlanGeneralCostListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanPlanGeneralCostList.Clone: TFhirInsurancePlanPlanGeneralCostList;
begin
  result := TFhirInsurancePlanPlanGeneralCostList(inherited Clone);
end;

function TFhirInsurancePlanPlanGeneralCostList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanPlanGeneralCostList.GetItemN(index: Integer): TFhirInsurancePlanPlanGeneralCost;
begin
  result := TFhirInsurancePlanPlanGeneralCost(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanGeneralCostList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanPlanGeneralCost;
end;
function TFhirInsurancePlanPlanGeneralCostList.IndexOf(value: TFhirInsurancePlanPlanGeneralCost): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanPlanGeneralCostList.Insert(index: Integer): TFhirInsurancePlanPlanGeneralCost;
begin
  result := TFhirInsurancePlanPlanGeneralCost.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanGeneralCostList.InsertItem(index: Integer; value: TFhirInsurancePlanPlanGeneralCost);
begin
  assert(value is TFhirInsurancePlanPlanGeneralCost);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanPlanGeneralCostList.Item(index: Integer): TFhirInsurancePlanPlanGeneralCost;
begin
  result := TFhirInsurancePlanPlanGeneralCost(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanGeneralCostList.Link: TFhirInsurancePlanPlanGeneralCostList;
begin
  result := TFhirInsurancePlanPlanGeneralCostList(inherited Link);
end;

procedure TFhirInsurancePlanPlanGeneralCostList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanPlanGeneralCostList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanPlanGeneralCost);
begin
  assert(value is TFhirInsurancePlanPlanGeneralCost);
  FhirInsurancePlanPlanGeneralCosts[index] := value;
end;

procedure TFhirInsurancePlanPlanGeneralCostList.SetItemN(index: Integer; value: TFhirInsurancePlanPlanGeneralCost);
begin
  assert(value is TFhirInsurancePlanPlanGeneralCost);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanPlanSpecificCost }

constructor TFhirInsurancePlanPlanSpecificCost.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanPlanSpecificCost.Destroy;
begin
  FCategory.free;
  FBenefitList.Free;
  inherited;
end;

procedure TFhirInsurancePlanPlanSpecificCost.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirInsurancePlanPlanSpecificCost(oSource).category.Clone;
  if (TFhirInsurancePlanPlanSpecificCost(oSource).FBenefitList = nil) then
  begin
    FBenefitList.free;
    FBenefitList := nil;
  end
  else
  begin
    if FBenefitList = nil then
      FBenefitList := TFhirInsurancePlanPlanSpecificCostBenefitList.Create;
    FBenefitList.Assign(TFhirInsurancePlanPlanSpecificCost(oSource).FBenefitList);
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCost.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'benefit') Then
    list.addAll(self, 'benefit', FBenefitList);
end;

procedure TFhirInsurancePlanPlanSpecificCost.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'benefit', '', true, TFhirInsurancePlanPlanSpecificCostBenefit, FBenefitList.Link)){3};
end;

function TFhirInsurancePlanPlanSpecificCost.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'benefit') then
  begin
    BenefitList.add(propValue as TFhirInsurancePlanPlanSpecificCostBenefit){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanPlanSpecificCost.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'benefit') then BenefitList.insertItem(index, propValue as TFhirInsurancePlanPlanSpecificCostBenefit){2a}
  else inherited;
end;

function TFhirInsurancePlanPlanSpecificCost.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'benefit') then result := BenefitList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanPlanSpecificCost.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'benefit') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanPlanSpecificCost.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'benefit') then deletePropertyValue('benefit', BenefitList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanPlanSpecificCost.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'benefit') then replacePropertyValue('benefit', BenefitList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanPlanSpecificCost.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'benefit') then BenefitList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanPlanSpecificCost.fhirType : string;
begin
  result := 'specificCost';
end;

function TFhirInsurancePlanPlanSpecificCost.Link : TFhirInsurancePlanPlanSpecificCost;
begin
  result := TFhirInsurancePlanPlanSpecificCost(inherited Link);
end;

function TFhirInsurancePlanPlanSpecificCost.Clone : TFhirInsurancePlanPlanSpecificCost;
begin
  result := TFhirInsurancePlanPlanSpecificCost(inherited Clone);
end;

function TFhirInsurancePlanPlanSpecificCost.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanPlanSpecificCost;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanPlanSpecificCost)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanPlanSpecificCost(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(benefitList, o.benefitList, true);
  end;
end;

function TFhirInsurancePlanPlanSpecificCost.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FbenefitList);
end;

procedure TFhirInsurancePlanPlanSpecificCost.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('benefit');
end;

{ TFhirInsurancePlanPlanSpecificCost }

Procedure TFhirInsurancePlanPlanSpecificCost.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Function TFhirInsurancePlanPlanSpecificCost.GetBenefitList : TFhirInsurancePlanPlanSpecificCostBenefitList;
begin
  if FBenefitList = nil then
    FBenefitList := TFhirInsurancePlanPlanSpecificCostBenefitList.Create;
  result := FBenefitList;
end;

Function TFhirInsurancePlanPlanSpecificCost.GetHasBenefitList : boolean;
begin
  result := (FBenefitList <> nil) and (FBenefitList.count > 0);
end;

function TFhirInsurancePlanPlanSpecificCost.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FbenefitList.sizeInBytes);
end;

{ TFhirInsurancePlanPlanSpecificCostListEnumerator }

Constructor TFhirInsurancePlanPlanSpecificCostListEnumerator.Create(list : TFhirInsurancePlanPlanSpecificCostList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanPlanSpecificCostListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanPlanSpecificCostListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanPlanSpecificCostListEnumerator.GetCurrent : TFhirInsurancePlanPlanSpecificCost;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanPlanSpecificCostListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInsurancePlanPlanSpecificCostList }
procedure TFhirInsurancePlanPlanSpecificCostList.AddItem(value: TFhirInsurancePlanPlanSpecificCost);
begin
  assert(value.ClassName = 'TFhirInsurancePlanPlanSpecificCost', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanPlanSpecificCost');
  add(value);
end;

function TFhirInsurancePlanPlanSpecificCostList.Append: TFhirInsurancePlanPlanSpecificCost;
begin
  result := TFhirInsurancePlanPlanSpecificCost.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanPlanSpecificCostList.GetEnumerator : TFhirInsurancePlanPlanSpecificCostListEnumerator;
begin
  result := TFhirInsurancePlanPlanSpecificCostListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanPlanSpecificCostList.Clone: TFhirInsurancePlanPlanSpecificCostList;
begin
  result := TFhirInsurancePlanPlanSpecificCostList(inherited Clone);
end;

function TFhirInsurancePlanPlanSpecificCostList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanPlanSpecificCostList.GetItemN(index: Integer): TFhirInsurancePlanPlanSpecificCost;
begin
  result := TFhirInsurancePlanPlanSpecificCost(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanSpecificCostList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanPlanSpecificCost;
end;
function TFhirInsurancePlanPlanSpecificCostList.IndexOf(value: TFhirInsurancePlanPlanSpecificCost): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanPlanSpecificCostList.Insert(index: Integer): TFhirInsurancePlanPlanSpecificCost;
begin
  result := TFhirInsurancePlanPlanSpecificCost.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostList.InsertItem(index: Integer; value: TFhirInsurancePlanPlanSpecificCost);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCost);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanPlanSpecificCostList.Item(index: Integer): TFhirInsurancePlanPlanSpecificCost;
begin
  result := TFhirInsurancePlanPlanSpecificCost(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanSpecificCostList.Link: TFhirInsurancePlanPlanSpecificCostList;
begin
  result := TFhirInsurancePlanPlanSpecificCostList(inherited Link);
end;

procedure TFhirInsurancePlanPlanSpecificCostList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanPlanSpecificCostList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanPlanSpecificCost);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCost);
  FhirInsurancePlanPlanSpecificCosts[index] := value;
end;

procedure TFhirInsurancePlanPlanSpecificCostList.SetItemN(index: Integer; value: TFhirInsurancePlanPlanSpecificCost);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCost);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanPlanSpecificCostBenefit }

constructor TFhirInsurancePlanPlanSpecificCostBenefit.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanPlanSpecificCostBenefit.Destroy;
begin
  FType_.free;
  FCostList.Free;
  inherited;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirInsurancePlanPlanSpecificCostBenefit(oSource).type_.Clone;
  if (TFhirInsurancePlanPlanSpecificCostBenefit(oSource).FCostList = nil) then
  begin
    FCostList.free;
    FCostList := nil;
  end
  else
  begin
    if FCostList = nil then
      FCostList := TFhirInsurancePlanPlanSpecificCostBenefitCostList.Create;
    FCostList.Assign(TFhirInsurancePlanPlanSpecificCostBenefit(oSource).FCostList);
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'cost') Then
    list.addAll(self, 'cost', FCostList);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'cost', '', true, TFhirInsurancePlanPlanSpecificCostBenefitCost, FCostList.Link)){3};
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'cost') then
  begin
    CostList.add(propValue as TFhirInsurancePlanPlanSpecificCostBenefitCost){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'cost') then CostList.insertItem(index, propValue as TFhirInsurancePlanPlanSpecificCostBenefitCost){2a}
  else inherited;
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'cost') then result := CostList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'cost') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'cost') then deletePropertyValue('cost', CostList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'cost') then replacePropertyValue('cost', CostList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'cost') then CostList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.fhirType : string;
begin
  result := 'benefit';
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.Link : TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit(inherited Link);
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.Clone : TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit(inherited Clone);
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanPlanSpecificCostBenefit)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanPlanSpecificCostBenefit(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(costList, o.costList, true);
  end;
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FcostList);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefit.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('cost');
end;

{ TFhirInsurancePlanPlanSpecificCostBenefit }

Procedure TFhirInsurancePlanPlanSpecificCostBenefit.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirInsurancePlanPlanSpecificCostBenefit.GetCostList : TFhirInsurancePlanPlanSpecificCostBenefitCostList;
begin
  if FCostList = nil then
    FCostList := TFhirInsurancePlanPlanSpecificCostBenefitCostList.Create;
  result := FCostList;
end;

Function TFhirInsurancePlanPlanSpecificCostBenefit.GetHasCostList : boolean;
begin
  result := (FCostList <> nil) and (FCostList.count > 0);
end;

function TFhirInsurancePlanPlanSpecificCostBenefit.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FcostList.sizeInBytes);
end;

{ TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator }

Constructor TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator.Create(list : TFhirInsurancePlanPlanSpecificCostBenefitList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator.GetCurrent : TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInsurancePlanPlanSpecificCostBenefitList }
procedure TFhirInsurancePlanPlanSpecificCostBenefitList.AddItem(value: TFhirInsurancePlanPlanSpecificCostBenefit);
begin
  assert(value.ClassName = 'TFhirInsurancePlanPlanSpecificCostBenefit', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanPlanSpecificCostBenefit');
  add(value);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.Append: TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.GetEnumerator : TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.Clone: TFhirInsurancePlanPlanSpecificCostBenefitList;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitList(inherited Clone);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.GetItemN(index: Integer): TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit;
end;
function TFhirInsurancePlanPlanSpecificCostBenefitList.IndexOf(value: TFhirInsurancePlanPlanSpecificCostBenefit): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.Insert(index: Integer): TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitList.InsertItem(index: Integer; value: TFhirInsurancePlanPlanSpecificCostBenefit);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCostBenefit);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.Item(index: Integer): TFhirInsurancePlanPlanSpecificCostBenefit;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefit(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitList.Link: TFhirInsurancePlanPlanSpecificCostBenefitList;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitList(inherited Link);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanPlanSpecificCostBenefit);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCostBenefit);
  FhirInsurancePlanPlanSpecificCostBenefits[index] := value;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitList.SetItemN(index: Integer; value: TFhirInsurancePlanPlanSpecificCostBenefit);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCostBenefit);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlanPlanSpecificCostBenefitCost }

constructor TFhirInsurancePlanPlanSpecificCostBenefitCost.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlanPlanSpecificCostBenefitCost.Destroy;
begin
  FType_.free;
  FApplicability.free;
  FQualifiersList.Free;
  FValue.free;
  inherited;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirInsurancePlanPlanSpecificCostBenefitCost(oSource).type_.Clone;
  applicability := TFhirInsurancePlanPlanSpecificCostBenefitCost(oSource).applicability.Clone;
  if (TFhirInsurancePlanPlanSpecificCostBenefitCost(oSource).FQualifiersList = nil) then
  begin
    FQualifiersList.free;
    FQualifiersList := nil;
  end
  else
  begin
    if FQualifiersList = nil then
      FQualifiersList := TFhirCodeableConceptList.Create;
    FQualifiersList.Assign(TFhirInsurancePlanPlanSpecificCostBenefitCost(oSource).FQualifiersList);
  end;
  value := TFhirInsurancePlanPlanSpecificCostBenefitCost(oSource).value.Clone;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'applicability') Then
     list.add(self.link, 'applicability', FApplicability.Link);
  if (child_name = 'qualifiers') Then
    list.addAll(self, 'qualifiers', FQualifiersList);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'applicability', 'CodeableConcept', false, TFhirCodeableConcept, FApplicability.Link));{2}
  oList.add(TFHIRProperty.create(self, 'qualifiers', 'CodeableConcept', true, TFhirCodeableConcept, FQualifiersList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'value', 'Quantity', false, TFhirQuantity, FValue.Link));{2}
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'applicability') then
  begin
    Applicability := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'qualifiers') then
  begin
    QualifiersList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    Value := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'qualifiers') then QualifiersList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'applicability') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'qualifiers') then result := QualifiersList.new(){2}
  else if (propName = 'value') then result := TFhirQuantity.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'applicability') then result := 'CodeableConcept'
  else if (propName = 'qualifiers') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'applicability') then ApplicabilityElement := nil
  else if (propName = 'qualifiers') then deletePropertyValue('qualifiers', QualifiersList, value) {2}
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'applicability') then ApplicabilityElement := new as TFhirCodeableConcept{4}
  else if (propName = 'qualifiers') then replacePropertyValue('qualifiers', QualifiersList, existing, new) {2}
  else if (propName = 'value') then ValueElement := new as TFhirQuantity{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'qualifiers') then QualifiersList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.fhirType : string;
begin
  result := 'cost';
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.Link : TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost(inherited Link);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.Clone : TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost(inherited Clone);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlanPlanSpecificCostBenefitCost)) then
    result := false
  else
  begin
    o := TFhirInsurancePlanPlanSpecificCostBenefitCost(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(applicabilityElement, o.applicabilityElement, true) and 
      compareDeep(qualifiersList, o.qualifiersList, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FApplicability) and isEmptyProp(FqualifiersList) and isEmptyProp(FValue);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('applicability');
  fields.add('qualifiers');
  fields.add('value');
end;

{ TFhirInsurancePlanPlanSpecificCostBenefitCost }

Procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.SetApplicability(value : TFhirCodeableConcept);
begin
  FApplicability.free;
  FApplicability := value;
end;

Function TFhirInsurancePlanPlanSpecificCostBenefitCost.GetQualifiersList : TFhirCodeableConceptList;
begin
  if FQualifiersList = nil then
    FQualifiersList := TFhirCodeableConceptList.Create;
  result := FQualifiersList;
end;

Function TFhirInsurancePlanPlanSpecificCostBenefitCost.GetHasQualifiersList : boolean;
begin
  result := (FQualifiersList <> nil) and (FQualifiersList.count > 0);
end;

Procedure TFhirInsurancePlanPlanSpecificCostBenefitCost.SetValue(value : TFhirQuantity);
begin
  FValue.free;
  FValue := value;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCost.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FApplicability.sizeInBytes);
  inc(result, FqualifiersList.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator }

Constructor TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator.Create(list : TFhirInsurancePlanPlanSpecificCostBenefitCostList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator.GetCurrent : TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInsurancePlanPlanSpecificCostBenefitCostList }
procedure TFhirInsurancePlanPlanSpecificCostBenefitCostList.AddItem(value: TFhirInsurancePlanPlanSpecificCostBenefitCost);
begin
  assert(value.ClassName = 'TFhirInsurancePlanPlanSpecificCostBenefitCost', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlanPlanSpecificCostBenefitCost');
  add(value);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.Append: TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCostList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.GetEnumerator : TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCostListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.Clone: TFhirInsurancePlanPlanSpecificCostBenefitCostList;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCostList(inherited Clone);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.GetItemN(index: Integer): TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost;
end;
function TFhirInsurancePlanPlanSpecificCostBenefitCostList.IndexOf(value: TFhirInsurancePlanPlanSpecificCostBenefitCost): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.Insert(index: Integer): TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCostList.InsertItem(index: Integer; value: TFhirInsurancePlanPlanSpecificCostBenefitCost);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCostBenefitCost);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.Item(index: Integer): TFhirInsurancePlanPlanSpecificCostBenefitCost;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCost(ObjectByIndex[index]);
end;

function TFhirInsurancePlanPlanSpecificCostBenefitCostList.Link: TFhirInsurancePlanPlanSpecificCostBenefitCostList;
begin
  result := TFhirInsurancePlanPlanSpecificCostBenefitCostList(inherited Link);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCostList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCostList.SetItemByIndex(index: Integer; value: TFhirInsurancePlanPlanSpecificCostBenefitCost);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCostBenefitCost);
  FhirInsurancePlanPlanSpecificCostBenefitCosts[index] := value;
end;

procedure TFhirInsurancePlanPlanSpecificCostBenefitCostList.SetItemN(index: Integer; value: TFhirInsurancePlanPlanSpecificCostBenefitCost);
begin
  assert(value is TFhirInsurancePlanPlanSpecificCostBenefitCost);
  ObjectByIndex[index] := value;
end;

{ TFhirInsurancePlan }

constructor TFhirInsurancePlan.Create;
begin
  inherited;
end;

destructor TFhirInsurancePlan.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_List.Free;
  FName.free;
  FAliasList.Free;
  FPeriod.free;
  FOwnedBy.free;
  FAdministeredBy.free;
  FCoverageAreaList.Free;
  FContactList.Free;
  FEndpointList.Free;
  FNetworkList.Free;
  FCoverageList.Free;
  FPlanList.Free;
  inherited;
end;

function TFhirInsurancePlan.GetResourceType : TFhirResourceType;
begin
  result := frtInsurancePlan;
end;

procedure TFhirInsurancePlan.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirInsurancePlan(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirInsurancePlan(oSource).FIdentifierList);
  end;
  FStatus := TFhirInsurancePlan(oSource).FStatus.Link;
  if (TFhirInsurancePlan(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirInsurancePlan(oSource).FType_List);
  end;
  nameElement := TFhirInsurancePlan(oSource).nameElement.Clone;
  if (TFhirInsurancePlan(oSource).FAliasList = nil) then
  begin
    FAliasList.free;
    FAliasList := nil;
  end
  else
  begin
    if FAliasList = nil then
      FAliasList := TFhirStringList.Create;
    FAliasList.Assign(TFhirInsurancePlan(oSource).FAliasList);
  end;
  period := TFhirInsurancePlan(oSource).period.Clone;
  ownedBy := TFhirInsurancePlan(oSource).ownedBy.Clone;
  administeredBy := TFhirInsurancePlan(oSource).administeredBy.Clone;
  if (TFhirInsurancePlan(oSource).FCoverageAreaList = nil) then
  begin
    FCoverageAreaList.free;
    FCoverageAreaList := nil;
  end
  else
  begin
    if FCoverageAreaList = nil then
      FCoverageAreaList := TFhirReferenceList{TFhirLocation}.Create;
    FCoverageAreaList.Assign(TFhirInsurancePlan(oSource).FCoverageAreaList);
  end;
  if (TFhirInsurancePlan(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirInsurancePlanContactList.Create;
    FContactList.Assign(TFhirInsurancePlan(oSource).FContactList);
  end;
  if (TFhirInsurancePlan(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList{TFhirEndpoint}.Create;
    FEndpointList.Assign(TFhirInsurancePlan(oSource).FEndpointList);
  end;
  if (TFhirInsurancePlan(oSource).FNetworkList = nil) then
  begin
    FNetworkList.free;
    FNetworkList := nil;
  end
  else
  begin
    if FNetworkList = nil then
      FNetworkList := TFhirReferenceList{TFhirOrganization}.Create;
    FNetworkList.Assign(TFhirInsurancePlan(oSource).FNetworkList);
  end;
  if (TFhirInsurancePlan(oSource).FCoverageList = nil) then
  begin
    FCoverageList.free;
    FCoverageList := nil;
  end
  else
  begin
    if FCoverageList = nil then
      FCoverageList := TFhirInsurancePlanCoverageList.Create;
    FCoverageList.Assign(TFhirInsurancePlan(oSource).FCoverageList);
  end;
  if (TFhirInsurancePlan(oSource).FPlanList = nil) then
  begin
    FPlanList.free;
    FPlanList := nil;
  end
  else
  begin
    if FPlanList = nil then
      FPlanList := TFhirInsurancePlanPlanList.Create;
    FPlanList.Assign(TFhirInsurancePlan(oSource).FPlanList);
  end;
end;

procedure TFhirInsurancePlan.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'alias') Then
    list.addAll(self, 'alias', FAliasList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'ownedBy') Then
     list.add(self.link, 'ownedBy', FOwnedBy.Link);
  if (child_name = 'administeredBy') Then
     list.add(self.link, 'administeredBy', FAdministeredBy.Link);
  if (child_name = 'coverageArea') Then
    list.addAll(self, 'coverageArea', FCoverageAreaList);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
  if (child_name = 'network') Then
    list.addAll(self, 'network', FNetworkList);
  if (child_name = 'coverage') Then
    list.addAll(self, 'coverage', FCoverageList);
  if (child_name = 'plan') Then
    list.addAll(self, 'plan', FPlanList);
end;

procedure TFhirInsurancePlan.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'alias', 'string', true, TFhirString, FAliasList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ownedBy', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOwnedBy.Link));{2}
  oList.add(TFHIRProperty.create(self, 'administeredBy', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FAdministeredBy.Link));{2}
  oList.add(TFHIRProperty.create(self, 'coverageArea', 'Reference(Location)', true, TFhirReference{TFhirLocation}, FCoverageAreaList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'contact', '', true, TFhirInsurancePlanContact, FContactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference(Endpoint)', true, TFhirReference{TFhirEndpoint}, FEndpointList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'network', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FNetworkList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'coverage', '', true, TFhirInsurancePlanCoverage, FCoverageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'plan', '', true, TFhirInsurancePlanPlan, FPlanList.Link)){3};
end;

function TFhirInsurancePlan.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'alias') then
  begin
    AliasList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'ownedBy') then
  begin
    OwnedBy := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'administeredBy') then
  begin
    AdministeredBy := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'coverageArea') then
  begin
    CoverageAreaList.add(propValue as TFhirReference{TFhirLocation}){2a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirInsurancePlanContact){2a};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference{TFhirEndpoint}){2a};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    NetworkList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    CoverageList.add(propValue as TFhirInsurancePlanCoverage){2a};
    result := propValue;
  end
  else if (propName = 'plan') then
  begin
    PlanList.add(propValue as TFhirInsurancePlanPlan){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirInsurancePlan.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'alias') then AliasList.insertItem(index, asString(propValue)){2}
  else if (propName = 'coverageArea') then CoverageAreaList.insertItem(index, propValue as TFhirReference{TFhirLocation}){2a}
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirInsurancePlanContact){2a}
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference{TFhirEndpoint}){2a}
  else if (propName = 'network') then NetworkList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else if (propName = 'coverage') then CoverageList.insertItem(index, propValue as TFhirInsurancePlanCoverage){2a}
  else if (propName = 'plan') then PlanList.insertItem(index, propValue as TFhirInsurancePlanPlan){2a}
  else inherited;
end;

function TFhirInsurancePlan.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'alias') then result := AliasList.new(){2}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'ownedBy') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'administeredBy') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'coverageArea') then result := CoverageAreaList.new(){2}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'endpoint') then result := EndpointList.new(){2}
  else if (propName = 'network') then result := NetworkList.new(){2}
  else if (propName = 'coverage') then result := CoverageList.new(){2}
  else if (propName = 'plan') then result := PlanList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInsurancePlan.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'alias') then result := 'string'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'ownedBy') then result := 'Reference'
  else if (propName = 'administeredBy') then result := 'Reference'
  else if (propName = 'coverageArea') then result := 'Reference'
  else if (propName = 'contact') then result := ''
  else if (propName = 'endpoint') then result := 'Reference'
  else if (propName = 'network') then result := 'Reference'
  else if (propName = 'coverage') then result := ''
  else if (propName = 'plan') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInsurancePlan.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'alias') then deletePropertyValue('alias', AliasList, value) {2}
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'ownedBy') then OwnedByElement := nil
  else if (propName = 'administeredBy') then AdministeredByElement := nil
  else if (propName = 'coverageArea') then deletePropertyValue('coverageArea', CoverageAreaList, value) {2}
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value) {2}
  else if (propName = 'network') then deletePropertyValue('network', NetworkList, value) {2}
  else if (propName = 'coverage') then deletePropertyValue('coverage', CoverageList, value) {2}
  else if (propName = 'plan') then deletePropertyValue('plan', PlanList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInsurancePlan.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new){4}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'alias') then replacePropertyValue('alias', AliasList, existing, new) {2}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'ownedBy') then OwnedByElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'administeredBy') then AdministeredByElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'coverageArea') then replacePropertyValue('coverageArea', CoverageAreaList, existing, new) {2}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new) {2}
  else if (propName = 'network') then replacePropertyValue('network', NetworkList, existing, new) {2}
  else if (propName = 'coverage') then replacePropertyValue('coverage', CoverageList, existing, new) {2}
  else if (propName = 'plan') then replacePropertyValue('plan', PlanList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInsurancePlan.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'type') then Type_List.move(source, destination){2a}
  else if (propName = 'alias') then AliasList.move(source, destination){2}
  else if (propName = 'coverageArea') then CoverageAreaList.move(source, destination){2a}
  else if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'endpoint') then EndpointList.move(source, destination){2a}
  else if (propName = 'network') then NetworkList.move(source, destination){2a}
  else if (propName = 'coverage') then CoverageList.move(source, destination){2a}
  else if (propName = 'plan') then PlanList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInsurancePlan.fhirType : string;
begin
  result := 'InsurancePlan';
end;

function TFhirInsurancePlan.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(Ftype_List) and isEmptyProp(FName) and isEmptyProp(FaliasList) and isEmptyProp(FPeriod) and isEmptyProp(FOwnedBy) and isEmptyProp(FAdministeredBy) and isEmptyProp(FcoverageAreaList) and isEmptyProp(FcontactList) and isEmptyProp(FendpointList) and isEmptyProp(FnetworkList) and isEmptyProp(FcoverageList) and isEmptyProp(FplanList);
end;

function TFhirInsurancePlan.equals(other : TObject) : boolean; 
var
  o : TFhirInsurancePlan;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInsurancePlan)) then
    result := false
  else
  begin
    o := TFhirInsurancePlan(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_List, o.type_List, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(aliasList, o.aliasList, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(ownedByElement, o.ownedByElement, true) and compareDeep(administeredByElement, o.administeredByElement, true) and 
      compareDeep(coverageAreaList, o.coverageAreaList, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(endpointList, o.endpointList, true) and compareDeep(networkList, o.networkList, true) and 
      compareDeep(coverageList, o.coverageList, true) and compareDeep(planList, o.planList, true);
  end;
end;

function TFhirInsurancePlan.Link : TFhirInsurancePlan;
begin
  result := TFhirInsurancePlan(inherited Link);
end;

function TFhirInsurancePlan.Clone : TFhirInsurancePlan;
begin
  result := TFhirInsurancePlan(inherited Clone);
end;

procedure TFhirInsurancePlan.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('name');
  fields.add('alias');
  fields.add('period');
  fields.add('ownedBy');
  fields.add('administeredBy');
  fields.add('coverageArea');
  fields.add('contact');
  fields.add('endpoint');
  fields.add('network');
  fields.add('coverage');
  fields.add('plan');
end;

{ TFhirInsurancePlan }

Function TFhirInsurancePlan.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirInsurancePlan.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirInsurancePlan.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirInsurancePlan.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

Procedure TFhirInsurancePlan.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

Function TFhirInsurancePlan.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

Function TFhirInsurancePlan.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Procedure TFhirInsurancePlan.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirInsurancePlan.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirInsurancePlan.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Function TFhirInsurancePlan.GetAliasList : TFhirStringList;
begin
  if FAliasList = nil then
    FAliasList := TFhirStringList.Create;
  result := FAliasList;
end;

Function TFhirInsurancePlan.GetHasAliasList : boolean;
begin
  result := (FAliasList <> nil) and (FAliasList.count > 0);
end;

Procedure TFhirInsurancePlan.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirInsurancePlan.SetOwnedBy(value : TFhirReference{TFhirOrganization});
begin
  FOwnedBy.free;
  FOwnedBy := value;
end;

Procedure TFhirInsurancePlan.SetAdministeredBy(value : TFhirReference{TFhirOrganization});
begin
  FAdministeredBy.free;
  FAdministeredBy := value;
end;

Function TFhirInsurancePlan.GetCoverageAreaList : TFhirReferenceList{TFhirLocation};
begin
  if FCoverageAreaList = nil then
    FCoverageAreaList := TFhirReferenceList{TFhirLocation}.Create;
  result := FCoverageAreaList;
end;

Function TFhirInsurancePlan.GetHasCoverageAreaList : boolean;
begin
  result := (FCoverageAreaList <> nil) and (FCoverageAreaList.count > 0);
end;

Function TFhirInsurancePlan.GetContactList : TFhirInsurancePlanContactList;
begin
  if FContactList = nil then
    FContactList := TFhirInsurancePlanContactList.Create;
  result := FContactList;
end;

Function TFhirInsurancePlan.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Function TFhirInsurancePlan.GetEndpointList : TFhirReferenceList{TFhirEndpoint};
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList{TFhirEndpoint}.Create;
  result := FEndpointList;
end;

Function TFhirInsurancePlan.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

Function TFhirInsurancePlan.GetNetworkList : TFhirReferenceList{TFhirOrganization};
begin
  if FNetworkList = nil then
    FNetworkList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FNetworkList;
end;

Function TFhirInsurancePlan.GetHasNetworkList : boolean;
begin
  result := (FNetworkList <> nil) and (FNetworkList.count > 0);
end;

Function TFhirInsurancePlan.GetCoverageList : TFhirInsurancePlanCoverageList;
begin
  if FCoverageList = nil then
    FCoverageList := TFhirInsurancePlanCoverageList.Create;
  result := FCoverageList;
end;

Function TFhirInsurancePlan.GetHasCoverageList : boolean;
begin
  result := (FCoverageList <> nil) and (FCoverageList.count > 0);
end;

Function TFhirInsurancePlan.GetPlanList : TFhirInsurancePlanPlanList;
begin
  if FPlanList = nil then
    FPlanList := TFhirInsurancePlanPlanList.Create;
  result := FPlanList;
end;

Function TFhirInsurancePlan.GetHasPlanList : boolean;
begin
  result := (FPlanList <> nil) and (FPlanList.count > 0);
end;

function TFhirInsurancePlan.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FaliasList.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FOwnedBy.sizeInBytes);
  inc(result, FAdministeredBy.sizeInBytes);
  inc(result, FcoverageAreaList.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
  inc(result, FendpointList.sizeInBytes);
  inc(result, FnetworkList.sizeInBytes);
  inc(result, FcoverageList.sizeInBytes);
  inc(result, FplanList.sizeInBytes);
end;

{ TFhirInsurancePlanListEnumerator }

Constructor TFhirInsurancePlanListEnumerator.Create(list : TFhirInsurancePlanList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInsurancePlanListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInsurancePlanListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInsurancePlanListEnumerator.GetCurrent : TFhirInsurancePlan;
begin
  Result := FList[FIndex];
end;

function TFhirInsurancePlanListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInsurancePlanList }
procedure TFhirInsurancePlanList.AddItem(value: TFhirInsurancePlan);
begin
  assert(value.ClassName = 'TFhirInsurancePlan', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInsurancePlan');
  add(value);
end;

function TFhirInsurancePlanList.Append: TFhirInsurancePlan;
begin
  result := TFhirInsurancePlan.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanList.ClearItems;
begin
  Clear;
end;

function TFhirInsurancePlanList.GetEnumerator : TFhirInsurancePlanListEnumerator;
begin
  result := TFhirInsurancePlanListEnumerator.Create(self.link);
end;

function TFhirInsurancePlanList.Clone: TFhirInsurancePlanList;
begin
  result := TFhirInsurancePlanList(inherited Clone);
end;

function TFhirInsurancePlanList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInsurancePlanList.GetItemN(index: Integer): TFhirInsurancePlan;
begin
  result := TFhirInsurancePlan(ObjectByIndex[index]);
end;

function TFhirInsurancePlanList.ItemClass: TFslObjectClass;
begin
  result := TFhirInsurancePlan;
end;
function TFhirInsurancePlanList.IndexOf(value: TFhirInsurancePlan): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInsurancePlanList.Insert(index: Integer): TFhirInsurancePlan;
begin
  result := TFhirInsurancePlan.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInsurancePlanList.InsertItem(index: Integer; value: TFhirInsurancePlan);
begin
  assert(value is TFhirInsurancePlan);
  Inherited Insert(index, value);
end;

function TFhirInsurancePlanList.Item(index: Integer): TFhirInsurancePlan;
begin
  result := TFhirInsurancePlan(ObjectByIndex[index]);
end;

function TFhirInsurancePlanList.Link: TFhirInsurancePlanList;
begin
  result := TFhirInsurancePlanList(inherited Link);
end;

procedure TFhirInsurancePlanList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInsurancePlanList.SetItemByIndex(index: Integer; value: TFhirInsurancePlan);
begin
  assert(value is TFhirInsurancePlan);
  FhirInsurancePlans[index] := value;
end;

procedure TFhirInsurancePlanList.SetItemN(index: Integer; value: TFhirInsurancePlan);
begin
  assert(value is TFhirInsurancePlan);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_INSURANCEPLAN}

{$IFDEF FHIR_INVOICE}

{ TFhirInvoiceParticipant }

constructor TFhirInvoiceParticipant.Create;
begin
  inherited;
end;

destructor TFhirInvoiceParticipant.Destroy;
begin
  FRole.free;
  FActor.free;
  inherited;
end;

procedure TFhirInvoiceParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirInvoiceParticipant(oSource).role.Clone;
  actor := TFhirInvoiceParticipant(oSource).actor.Clone;
end;

procedure TFhirInvoiceParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirInvoiceParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FActor.Link));{2}
end;

function TFhirInvoiceParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInvoiceParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirInvoiceParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'actor') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInvoiceParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInvoiceParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInvoiceParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else if (propName = 'actor') then ActorElement := new as TFhirReference{TFhirPractitioner}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInvoiceParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirInvoiceParticipant.fhirType : string;
begin
  result := 'participant';
end;

function TFhirInvoiceParticipant.Link : TFhirInvoiceParticipant;
begin
  result := TFhirInvoiceParticipant(inherited Link);
end;

function TFhirInvoiceParticipant.Clone : TFhirInvoiceParticipant;
begin
  result := TFhirInvoiceParticipant(inherited Clone);
end;

function TFhirInvoiceParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirInvoiceParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInvoiceParticipant)) then
    result := false
  else
  begin
    o := TFhirInvoiceParticipant(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirInvoiceParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FActor);
end;

procedure TFhirInvoiceParticipant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('actor');
end;

{ TFhirInvoiceParticipant }

Procedure TFhirInvoiceParticipant.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirInvoiceParticipant.SetActor(value : TFhirReference{TFhirPractitioner});
begin
  FActor.free;
  FActor := value;
end;

function TFhirInvoiceParticipant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRole.sizeInBytes);
  inc(result, FActor.sizeInBytes);
end;

{ TFhirInvoiceParticipantListEnumerator }

Constructor TFhirInvoiceParticipantListEnumerator.Create(list : TFhirInvoiceParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInvoiceParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInvoiceParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInvoiceParticipantListEnumerator.GetCurrent : TFhirInvoiceParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirInvoiceParticipantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInvoiceParticipantList }
procedure TFhirInvoiceParticipantList.AddItem(value: TFhirInvoiceParticipant);
begin
  assert(value.ClassName = 'TFhirInvoiceParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInvoiceParticipant');
  add(value);
end;

function TFhirInvoiceParticipantList.Append: TFhirInvoiceParticipant;
begin
  result := TFhirInvoiceParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirInvoiceParticipantList.GetEnumerator : TFhirInvoiceParticipantListEnumerator;
begin
  result := TFhirInvoiceParticipantListEnumerator.Create(self.link);
end;

function TFhirInvoiceParticipantList.Clone: TFhirInvoiceParticipantList;
begin
  result := TFhirInvoiceParticipantList(inherited Clone);
end;

function TFhirInvoiceParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInvoiceParticipantList.GetItemN(index: Integer): TFhirInvoiceParticipant;
begin
  result := TFhirInvoiceParticipant(ObjectByIndex[index]);
end;

function TFhirInvoiceParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirInvoiceParticipant;
end;
function TFhirInvoiceParticipantList.IndexOf(value: TFhirInvoiceParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInvoiceParticipantList.Insert(index: Integer): TFhirInvoiceParticipant;
begin
  result := TFhirInvoiceParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceParticipantList.InsertItem(index: Integer; value: TFhirInvoiceParticipant);
begin
  assert(value is TFhirInvoiceParticipant);
  Inherited Insert(index, value);
end;

function TFhirInvoiceParticipantList.Item(index: Integer): TFhirInvoiceParticipant;
begin
  result := TFhirInvoiceParticipant(ObjectByIndex[index]);
end;

function TFhirInvoiceParticipantList.Link: TFhirInvoiceParticipantList;
begin
  result := TFhirInvoiceParticipantList(inherited Link);
end;

procedure TFhirInvoiceParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInvoiceParticipantList.SetItemByIndex(index: Integer; value: TFhirInvoiceParticipant);
begin
  assert(value is TFhirInvoiceParticipant);
  FhirInvoiceParticipants[index] := value;
end;

procedure TFhirInvoiceParticipantList.SetItemN(index: Integer; value: TFhirInvoiceParticipant);
begin
  assert(value is TFhirInvoiceParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirInvoiceLineItem }

constructor TFhirInvoiceLineItem.Create;
begin
  inherited;
end;

destructor TFhirInvoiceLineItem.Destroy;
begin
  FSequence.free;
  FChargeItem.free;
  FPriceComponentList.Free;
  inherited;
end;

procedure TFhirInvoiceLineItem.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirInvoiceLineItem(oSource).sequenceElement.Clone;
  chargeItem := TFhirInvoiceLineItem(oSource).chargeItem.Clone;
  if (TFhirInvoiceLineItem(oSource).FPriceComponentList = nil) then
  begin
    FPriceComponentList.free;
    FPriceComponentList := nil;
  end
  else
  begin
    if FPriceComponentList = nil then
      FPriceComponentList := TFhirInvoiceLineItemPriceComponentList.Create;
    FPriceComponentList.Assign(TFhirInvoiceLineItem(oSource).FPriceComponentList);
  end;
end;

procedure TFhirInvoiceLineItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'chargeItem[x]') or (child_name = 'chargeItem') Then
     list.add(self.link, 'chargeItem[x]', FChargeItem.Link);
  if (child_name = 'priceComponent') Then
    list.addAll(self, 'priceComponent', FPriceComponentList);
end;

procedure TFhirInvoiceLineItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'positiveInt', false, TFhirPositiveInt, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'chargeItem[x]', 'Reference(ChargeItem)|CodeableConcept', false, TFhirType, FChargeItem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priceComponent', '', true, TFhirInvoiceLineItemPriceComponent, FPriceComponentList.Link)){3};
end;

function TFhirInvoiceLineItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'chargeItem', ['Reference', 'CodeableConcept'])) then
  begin
    ChargeItem := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'priceComponent') then
  begin
    PriceComponentList.add(propValue as TFhirInvoiceLineItemPriceComponent){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInvoiceLineItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'priceComponent') then PriceComponentList.insertItem(index, propValue as TFhirInvoiceLineItemPriceComponent){2a}
  else inherited;
end;

function TFhirInvoiceLineItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirPositiveInt.create() {5b}
  else if (isMatchingName(propName, 'chargeItem', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property ChargeItem'){4x}
  else if (propName = 'priceComponent') then result := PriceComponentList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInvoiceLineItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'positiveInt'
  else if (propName = 'chargeItem[x]') then result := 'Reference|CodeableConcept'
  else if (propName = 'priceComponent') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInvoiceLineItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (isMatchingName(propName, 'chargeItem', ['Reference', 'CodeableConcept'])) then ChargeItemElement := nil{4x}
  else if (propName = 'priceComponent') then deletePropertyValue('priceComponent', PriceComponentList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInvoiceLineItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asPositiveInt(new){5b}
  else if (isMatchingName(propName, 'chargeItem', ['Reference', 'CodeableConcept'])) then ChargeItemElement := new as TFhirType{4x}
  else if (propName = 'priceComponent') then replacePropertyValue('priceComponent', PriceComponentList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInvoiceLineItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'priceComponent') then PriceComponentList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInvoiceLineItem.fhirType : string;
begin
  result := 'lineItem';
end;

function TFhirInvoiceLineItem.Link : TFhirInvoiceLineItem;
begin
  result := TFhirInvoiceLineItem(inherited Link);
end;

function TFhirInvoiceLineItem.Clone : TFhirInvoiceLineItem;
begin
  result := TFhirInvoiceLineItem(inherited Clone);
end;

function TFhirInvoiceLineItem.equals(other : TObject) : boolean; 
var
  o : TFhirInvoiceLineItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInvoiceLineItem)) then
    result := false
  else
  begin
    o := TFhirInvoiceLineItem(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(chargeItemElement, o.chargeItemElement, true) and 
      compareDeep(priceComponentList, o.priceComponentList, true);
  end;
end;

function TFhirInvoiceLineItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FChargeItem) and isEmptyProp(FpriceComponentList);
end;

procedure TFhirInvoiceLineItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('chargeItem[x]');
  fields.add('priceComponent');
end;

{ TFhirInvoiceLineItem }

Procedure TFhirInvoiceLineItem.SetSequence(value : TFhirPositiveInt);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirInvoiceLineItem.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirInvoiceLineItem.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirPositiveInt.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirInvoiceLineItem.SetChargeItem(value : TFhirType);
begin
  FChargeItem.free;
  FChargeItem := value;
end;

Function TFhirInvoiceLineItem.GetPriceComponentList : TFhirInvoiceLineItemPriceComponentList;
begin
  if FPriceComponentList = nil then
    FPriceComponentList := TFhirInvoiceLineItemPriceComponentList.Create;
  result := FPriceComponentList;
end;

Function TFhirInvoiceLineItem.GetHasPriceComponentList : boolean;
begin
  result := (FPriceComponentList <> nil) and (FPriceComponentList.count > 0);
end;

function TFhirInvoiceLineItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FChargeItem.sizeInBytes);
  inc(result, FpriceComponentList.sizeInBytes);
end;

{ TFhirInvoiceLineItemListEnumerator }

Constructor TFhirInvoiceLineItemListEnumerator.Create(list : TFhirInvoiceLineItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInvoiceLineItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInvoiceLineItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInvoiceLineItemListEnumerator.GetCurrent : TFhirInvoiceLineItem;
begin
  Result := FList[FIndex];
end;

function TFhirInvoiceLineItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInvoiceLineItemList }
procedure TFhirInvoiceLineItemList.AddItem(value: TFhirInvoiceLineItem);
begin
  assert(value.ClassName = 'TFhirInvoiceLineItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInvoiceLineItem');
  add(value);
end;

function TFhirInvoiceLineItemList.Append: TFhirInvoiceLineItem;
begin
  result := TFhirInvoiceLineItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceLineItemList.ClearItems;
begin
  Clear;
end;

function TFhirInvoiceLineItemList.GetEnumerator : TFhirInvoiceLineItemListEnumerator;
begin
  result := TFhirInvoiceLineItemListEnumerator.Create(self.link);
end;

function TFhirInvoiceLineItemList.Clone: TFhirInvoiceLineItemList;
begin
  result := TFhirInvoiceLineItemList(inherited Clone);
end;

function TFhirInvoiceLineItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInvoiceLineItemList.GetItemN(index: Integer): TFhirInvoiceLineItem;
begin
  result := TFhirInvoiceLineItem(ObjectByIndex[index]);
end;

function TFhirInvoiceLineItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirInvoiceLineItem;
end;
function TFhirInvoiceLineItemList.IndexOf(value: TFhirInvoiceLineItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInvoiceLineItemList.Insert(index: Integer): TFhirInvoiceLineItem;
begin
  result := TFhirInvoiceLineItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceLineItemList.InsertItem(index: Integer; value: TFhirInvoiceLineItem);
begin
  assert(value is TFhirInvoiceLineItem);
  Inherited Insert(index, value);
end;

function TFhirInvoiceLineItemList.Item(index: Integer): TFhirInvoiceLineItem;
begin
  result := TFhirInvoiceLineItem(ObjectByIndex[index]);
end;

function TFhirInvoiceLineItemList.Link: TFhirInvoiceLineItemList;
begin
  result := TFhirInvoiceLineItemList(inherited Link);
end;

procedure TFhirInvoiceLineItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInvoiceLineItemList.SetItemByIndex(index: Integer; value: TFhirInvoiceLineItem);
begin
  assert(value is TFhirInvoiceLineItem);
  FhirInvoiceLineItems[index] := value;
end;

procedure TFhirInvoiceLineItemList.SetItemN(index: Integer; value: TFhirInvoiceLineItem);
begin
  assert(value is TFhirInvoiceLineItem);
  ObjectByIndex[index] := value;
end;

{ TFhirInvoiceLineItemPriceComponent }

constructor TFhirInvoiceLineItemPriceComponent.Create;
begin
  inherited;
end;

destructor TFhirInvoiceLineItemPriceComponent.Destroy;
begin
  FType_.free;
  FCode.free;
  FFactor.free;
  FAmount.free;
  inherited;
end;

procedure TFhirInvoiceLineItemPriceComponent.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirInvoiceLineItemPriceComponent(oSource).FType_.Link;
  code := TFhirInvoiceLineItemPriceComponent(oSource).code.Clone;
  factorElement := TFhirInvoiceLineItemPriceComponent(oSource).factorElement.Clone;
  amount := TFhirInvoiceLineItemPriceComponent(oSource).amount.Clone;
end;

procedure TFhirInvoiceLineItemPriceComponent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirInvoiceLineItemPriceComponent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));{2}
end;

function TFhirInvoiceLineItemPriceComponent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirInvoicePriceComponentTypeEnum, CODES_TFhirInvoicePriceComponentTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirInvoiceLineItemPriceComponent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirInvoiceLineItemPriceComponent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'amount') then result := TFhirMoney.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInvoiceLineItemPriceComponent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'amount') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInvoiceLineItemPriceComponent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInvoiceLineItemPriceComponent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirInvoicePriceComponentTypeEnum, CODES_TFhirInvoicePriceComponentTypeEnum, new){4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInvoiceLineItemPriceComponent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirInvoiceLineItemPriceComponent.fhirType : string;
begin
  result := 'priceComponent';
end;

function TFhirInvoiceLineItemPriceComponent.Link : TFhirInvoiceLineItemPriceComponent;
begin
  result := TFhirInvoiceLineItemPriceComponent(inherited Link);
end;

function TFhirInvoiceLineItemPriceComponent.Clone : TFhirInvoiceLineItemPriceComponent;
begin
  result := TFhirInvoiceLineItemPriceComponent(inherited Clone);
end;

function TFhirInvoiceLineItemPriceComponent.equals(other : TObject) : boolean; 
var
  o : TFhirInvoiceLineItemPriceComponent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInvoiceLineItemPriceComponent)) then
    result := false
  else
  begin
    o := TFhirInvoiceLineItemPriceComponent(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirInvoiceLineItemPriceComponent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FCode) and isEmptyProp(FFactor) and isEmptyProp(FAmount);
end;

procedure TFhirInvoiceLineItemPriceComponent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('code');
  fields.add('factor');
  fields.add('amount');
end;

{ TFhirInvoiceLineItemPriceComponent }

Procedure TFhirInvoiceLineItemPriceComponent.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirInvoiceLineItemPriceComponent.GetType_ST : TFhirInvoicePriceComponentTypeEnum;
begin
  if FType_ = nil then
    result := TFhirInvoicePriceComponentTypeEnum(0)
  else
    result := TFhirInvoicePriceComponentTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirInvoicePriceComponentTypeEnum, FType_.value));
end;

Procedure TFhirInvoiceLineItemPriceComponent.SetType_ST(value : TFhirInvoicePriceComponentTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirInvoicePriceComponentTypeEnum[value], CODES_TFhirInvoicePriceComponentTypeEnum[value]);
end;

Procedure TFhirInvoiceLineItemPriceComponent.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirInvoiceLineItemPriceComponent.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirInvoiceLineItemPriceComponent.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirInvoiceLineItemPriceComponent.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirInvoiceLineItemPriceComponent.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirInvoiceLineItemPriceComponent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirInvoiceLineItemPriceComponentListEnumerator }

Constructor TFhirInvoiceLineItemPriceComponentListEnumerator.Create(list : TFhirInvoiceLineItemPriceComponentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInvoiceLineItemPriceComponentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInvoiceLineItemPriceComponentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInvoiceLineItemPriceComponentListEnumerator.GetCurrent : TFhirInvoiceLineItemPriceComponent;
begin
  Result := FList[FIndex];
end;

function TFhirInvoiceLineItemPriceComponentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInvoiceLineItemPriceComponentList }
procedure TFhirInvoiceLineItemPriceComponentList.AddItem(value: TFhirInvoiceLineItemPriceComponent);
begin
  assert(value.ClassName = 'TFhirInvoiceLineItemPriceComponent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInvoiceLineItemPriceComponent');
  add(value);
end;

function TFhirInvoiceLineItemPriceComponentList.Append: TFhirInvoiceLineItemPriceComponent;
begin
  result := TFhirInvoiceLineItemPriceComponent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceLineItemPriceComponentList.ClearItems;
begin
  Clear;
end;

function TFhirInvoiceLineItemPriceComponentList.GetEnumerator : TFhirInvoiceLineItemPriceComponentListEnumerator;
begin
  result := TFhirInvoiceLineItemPriceComponentListEnumerator.Create(self.link);
end;

function TFhirInvoiceLineItemPriceComponentList.Clone: TFhirInvoiceLineItemPriceComponentList;
begin
  result := TFhirInvoiceLineItemPriceComponentList(inherited Clone);
end;

function TFhirInvoiceLineItemPriceComponentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInvoiceLineItemPriceComponentList.GetItemN(index: Integer): TFhirInvoiceLineItemPriceComponent;
begin
  result := TFhirInvoiceLineItemPriceComponent(ObjectByIndex[index]);
end;

function TFhirInvoiceLineItemPriceComponentList.ItemClass: TFslObjectClass;
begin
  result := TFhirInvoiceLineItemPriceComponent;
end;
function TFhirInvoiceLineItemPriceComponentList.IndexOf(value: TFhirInvoiceLineItemPriceComponent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInvoiceLineItemPriceComponentList.Insert(index: Integer): TFhirInvoiceLineItemPriceComponent;
begin
  result := TFhirInvoiceLineItemPriceComponent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceLineItemPriceComponentList.InsertItem(index: Integer; value: TFhirInvoiceLineItemPriceComponent);
begin
  assert(value is TFhirInvoiceLineItemPriceComponent);
  Inherited Insert(index, value);
end;

function TFhirInvoiceLineItemPriceComponentList.Item(index: Integer): TFhirInvoiceLineItemPriceComponent;
begin
  result := TFhirInvoiceLineItemPriceComponent(ObjectByIndex[index]);
end;

function TFhirInvoiceLineItemPriceComponentList.Link: TFhirInvoiceLineItemPriceComponentList;
begin
  result := TFhirInvoiceLineItemPriceComponentList(inherited Link);
end;

procedure TFhirInvoiceLineItemPriceComponentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInvoiceLineItemPriceComponentList.SetItemByIndex(index: Integer; value: TFhirInvoiceLineItemPriceComponent);
begin
  assert(value is TFhirInvoiceLineItemPriceComponent);
  FhirInvoiceLineItemPriceComponents[index] := value;
end;

procedure TFhirInvoiceLineItemPriceComponentList.SetItemN(index: Integer; value: TFhirInvoiceLineItemPriceComponent);
begin
  assert(value is TFhirInvoiceLineItemPriceComponent);
  ObjectByIndex[index] := value;
end;

{ TFhirInvoice }

constructor TFhirInvoice.Create;
begin
  inherited;
end;

destructor TFhirInvoice.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCancelledReason.free;
  FType_.free;
  FSubject.free;
  FRecipient.free;
  FDate.free;
  FParticipantList.Free;
  FIssuer.free;
  FAccount.free;
  FLineItemList.Free;
  FTotalPriceComponentList.Free;
  FTotalNet.free;
  FTotalGross.free;
  FPaymentTerms.free;
  FNoteList.Free;
  inherited;
end;

function TFhirInvoice.GetResourceType : TFhirResourceType;
begin
  result := frtInvoice;
end;

procedure TFhirInvoice.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirInvoice(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirInvoice(oSource).FIdentifierList);
  end;
  FStatus := TFhirInvoice(oSource).FStatus.Link;
  cancelledReasonElement := TFhirInvoice(oSource).cancelledReasonElement.Clone;
  type_ := TFhirInvoice(oSource).type_.Clone;
  subject := TFhirInvoice(oSource).subject.Clone;
  recipient := TFhirInvoice(oSource).recipient.Clone;
  dateElement := TFhirInvoice(oSource).dateElement.Clone;
  if (TFhirInvoice(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirInvoiceParticipantList.Create;
    FParticipantList.Assign(TFhirInvoice(oSource).FParticipantList);
  end;
  issuer := TFhirInvoice(oSource).issuer.Clone;
  account := TFhirInvoice(oSource).account.Clone;
  if (TFhirInvoice(oSource).FLineItemList = nil) then
  begin
    FLineItemList.free;
    FLineItemList := nil;
  end
  else
  begin
    if FLineItemList = nil then
      FLineItemList := TFhirInvoiceLineItemList.Create;
    FLineItemList.Assign(TFhirInvoice(oSource).FLineItemList);
  end;
  if (TFhirInvoice(oSource).FTotalPriceComponentList = nil) then
  begin
    FTotalPriceComponentList.free;
    FTotalPriceComponentList := nil;
  end
  else
  begin
    if FTotalPriceComponentList = nil then
      FTotalPriceComponentList := TFhirInvoiceLineItemPriceComponentList.Create;
    FTotalPriceComponentList.Assign(TFhirInvoice(oSource).FTotalPriceComponentList);
  end;
  totalNet := TFhirInvoice(oSource).totalNet.Clone;
  totalGross := TFhirInvoice(oSource).totalGross.Clone;
  paymentTermsElement := TFhirInvoice(oSource).paymentTermsElement.Clone;
  if (TFhirInvoice(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirInvoice(oSource).FNoteList);
  end;
end;

procedure TFhirInvoice.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'cancelledReason') Then
     list.add(self.link, 'cancelledReason', FCancelledReason.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'recipient') Then
     list.add(self.link, 'recipient', FRecipient.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'issuer') Then
     list.add(self.link, 'issuer', FIssuer.Link);
  if (child_name = 'account') Then
     list.add(self.link, 'account', FAccount.Link);
  if (child_name = 'lineItem') Then
    list.addAll(self, 'lineItem', FLineItemList);
  if (child_name = 'totalPriceComponent') Then
    list.addAll(self, 'totalPriceComponent', FTotalPriceComponentList);
  if (child_name = 'totalNet') Then
     list.add(self.link, 'totalNet', FTotalNet.Link);
  if (child_name = 'totalGross') Then
     list.add(self.link, 'totalGross', FTotalGross.Link);
  if (child_name = 'paymentTerms') Then
     list.add(self.link, 'paymentTerms', FPaymentTerms.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirInvoice.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'cancelledReason', 'string', false, TFhirString, FCancelledReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FRecipient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'participant', '', true, TFhirInvoiceParticipant, FParticipantList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'issuer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FIssuer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'account', 'Reference(Account)', false, TFhirReference{TFhirAccount}, FAccount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lineItem', '', true, TFhirInvoiceLineItem, FLineItemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'totalPriceComponent', '@Invoice.lineItem.priceComponent', true, TFhirInvoiceLineItemPriceComponent, FTotalPriceComponentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'totalNet', 'Money', false, TFhirMoney, FTotalNet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'totalGross', 'Money', false, TFhirMoney, FTotalGross.Link));{2}
  oList.add(TFHIRProperty.create(self, 'paymentTerms', 'markdown', false, TFhirMarkdown, FPaymentTerms.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
end;

function TFhirInvoice.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirInvoiceStatusEnum, CODES_TFhirInvoiceStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'cancelledReason') then
  begin
    CancelledReasonElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    Recipient := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirInvoiceParticipant){2a};
    result := propValue;
  end
  else if (propName = 'issuer') then
  begin
    Issuer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'account') then
  begin
    Account := propValue as TFhirReference{TFhirAccount}{4b};
    result := propValue;
  end
  else if (propName = 'lineItem') then
  begin
    LineItemList.add(propValue as TFhirInvoiceLineItem){2a};
    result := propValue;
  end
  else if (propName = 'totalPriceComponent') then
  begin
    TotalPriceComponentList.add(propValue as TFhirInvoiceLineItemPriceComponent){2a};
    result := propValue;
  end
  else if (propName = 'totalNet') then
  begin
    TotalNet := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'totalGross') then
  begin
    TotalGross := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'paymentTerms') then
  begin
    PaymentTermsElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirInvoice.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirInvoiceParticipant){2a}
  else if (propName = 'lineItem') then LineItemList.insertItem(index, propValue as TFhirInvoiceLineItem){2a}
  else if (propName = 'totalPriceComponent') then TotalPriceComponentList.insertItem(index, propValue as TFhirInvoiceLineItemPriceComponent){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else inherited;
end;

function TFhirInvoice.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'cancelledReason') then result := TFhirString.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'recipient') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'participant') then result := ParticipantList.new(){2}
  else if (propName = 'issuer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'account') then result := TFhirReference{TFhirAccount}.create(){4b}
  else if (propName = 'lineItem') then result := LineItemList.new(){2}
  else if (propName = 'totalPriceComponent') then result := TotalPriceComponentList.new(){2}
  else if (propName = 'totalNet') then result := TFhirMoney.create(){4b}
  else if (propName = 'totalGross') then result := TFhirMoney.create(){4b}
  else if (propName = 'paymentTerms') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'note') then result := NoteList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirInvoice.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'cancelledReason') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'participant') then result := ''
  else if (propName = 'issuer') then result := 'Reference'
  else if (propName = 'account') then result := 'Reference'
  else if (propName = 'lineItem') then result := ''
  else if (propName = 'totalPriceComponent') then result := '@Invoice.lineItem.priceComponent'
  else if (propName = 'totalNet') then result := 'Money'
  else if (propName = 'totalGross') then result := 'Money'
  else if (propName = 'paymentTerms') then result := 'markdown'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirInvoice.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'cancelledReason') then CancelledReasonElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'recipient') then RecipientElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value) {2}
  else if (propName = 'issuer') then IssuerElement := nil
  else if (propName = 'account') then AccountElement := nil
  else if (propName = 'lineItem') then deletePropertyValue('lineItem', LineItemList, value) {2}
  else if (propName = 'totalPriceComponent') then deletePropertyValue('totalPriceComponent', TotalPriceComponentList, value) {2}
  else if (propName = 'totalNet') then TotalNetElement := nil
  else if (propName = 'totalGross') then TotalGrossElement := nil
  else if (propName = 'paymentTerms') then PaymentTermsElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirInvoice.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirInvoiceStatusEnum, CODES_TFhirInvoiceStatusEnum, new){4}
  else if (propName = 'cancelledReason') then CancelledReasonElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'recipient') then RecipientElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new) {2}
  else if (propName = 'issuer') then IssuerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'account') then AccountElement := new as TFhirReference{TFhirAccount}{4}
  else if (propName = 'lineItem') then replacePropertyValue('lineItem', LineItemList, existing, new) {2}
  else if (propName = 'totalPriceComponent') then replacePropertyValue('totalPriceComponent', TotalPriceComponentList, existing, new) {2}
  else if (propName = 'totalNet') then TotalNetElement := new as TFhirMoney{4}
  else if (propName = 'totalGross') then TotalGrossElement := new as TFhirMoney{4}
  else if (propName = 'paymentTerms') then PaymentTermsElement := asMarkdown(new){5b}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirInvoice.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'participant') then ParticipantList.move(source, destination){2a}
  else if (propName = 'lineItem') then LineItemList.move(source, destination){2a}
  else if (propName = 'totalPriceComponent') then TotalPriceComponentList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirInvoice.fhirType : string;
begin
  result := 'Invoice';
end;

function TFhirInvoice.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCancelledReason) and isEmptyProp(FType_) and isEmptyProp(FSubject) and isEmptyProp(FRecipient) and isEmptyProp(FDate) and isEmptyProp(FparticipantList) and isEmptyProp(FIssuer) and isEmptyProp(FAccount) and isEmptyProp(FlineItemList) and isEmptyProp(FtotalPriceComponentList) and isEmptyProp(FTotalNet) and isEmptyProp(FTotalGross) and isEmptyProp(FPaymentTerms) and isEmptyProp(FnoteList);
end;

function TFhirInvoice.equals(other : TObject) : boolean; 
var
  o : TFhirInvoice;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInvoice)) then
    result := false
  else
  begin
    o := TFhirInvoice(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(cancelledReasonElement, o.cancelledReasonElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(recipientElement, o.recipientElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(participantList, o.participantList, true) and 
      compareDeep(issuerElement, o.issuerElement, true) and compareDeep(accountElement, o.accountElement, true) and 
      compareDeep(lineItemList, o.lineItemList, true) and compareDeep(totalPriceComponentList, o.totalPriceComponentList, true) and 
      compareDeep(totalNetElement, o.totalNetElement, true) and compareDeep(totalGrossElement, o.totalGrossElement, true) and 
      compareDeep(paymentTermsElement, o.paymentTermsElement, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirInvoice.Link : TFhirInvoice;
begin
  result := TFhirInvoice(inherited Link);
end;

function TFhirInvoice.Clone : TFhirInvoice;
begin
  result := TFhirInvoice(inherited Clone);
end;

procedure TFhirInvoice.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('cancelledReason');
  fields.add('type');
  fields.add('subject');
  fields.add('recipient');
  fields.add('date');
  fields.add('participant');
  fields.add('issuer');
  fields.add('account');
  fields.add('lineItem');
  fields.add('totalPriceComponent');
  fields.add('totalNet');
  fields.add('totalGross');
  fields.add('paymentTerms');
  fields.add('note');
end;

{ TFhirInvoice }

Function TFhirInvoice.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirInvoice.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirInvoice.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirInvoice.GetStatusST : TFhirInvoiceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirInvoiceStatusEnum(0)
  else
    result := TFhirInvoiceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirInvoiceStatusEnum, FStatus.value));
end;

Procedure TFhirInvoice.SetStatusST(value : TFhirInvoiceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirInvoiceStatusEnum[value], CODES_TFhirInvoiceStatusEnum[value]);
end;

Procedure TFhirInvoice.SetCancelledReason(value : TFhirString);
begin
  FCancelledReason.free;
  FCancelledReason := value;
end;

Function TFhirInvoice.GetCancelledReasonST : String;
begin
  if FCancelledReason = nil then
    result := ''
  else
    result := FCancelledReason.value;
end;

Procedure TFhirInvoice.SetCancelledReasonST(value : String);
begin
  if value <> '' then
  begin
    if FCancelledReason = nil then
      FCancelledReason := TFhirString.create;
    FCancelledReason.value := value
  end
  else if FCancelledReason <> nil then
    FCancelledReason.value := '';
end;

Procedure TFhirInvoice.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirInvoice.SetSubject(value : TFhirReference{TFhirPatient});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirInvoice.SetRecipient(value : TFhirReference{TFhirOrganization});
begin
  FRecipient.free;
  FRecipient := value;
end;

Procedure TFhirInvoice.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirInvoice.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirInvoice.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Function TFhirInvoice.GetParticipantList : TFhirInvoiceParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirInvoiceParticipantList.Create;
  result := FParticipantList;
end;

Function TFhirInvoice.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

Procedure TFhirInvoice.SetIssuer(value : TFhirReference{TFhirOrganization});
begin
  FIssuer.free;
  FIssuer := value;
end;

Procedure TFhirInvoice.SetAccount(value : TFhirReference{TFhirAccount});
begin
  FAccount.free;
  FAccount := value;
end;

Function TFhirInvoice.GetLineItemList : TFhirInvoiceLineItemList;
begin
  if FLineItemList = nil then
    FLineItemList := TFhirInvoiceLineItemList.Create;
  result := FLineItemList;
end;

Function TFhirInvoice.GetHasLineItemList : boolean;
begin
  result := (FLineItemList <> nil) and (FLineItemList.count > 0);
end;

Function TFhirInvoice.GetTotalPriceComponentList : TFhirInvoiceLineItemPriceComponentList;
begin
  if FTotalPriceComponentList = nil then
    FTotalPriceComponentList := TFhirInvoiceLineItemPriceComponentList.Create;
  result := FTotalPriceComponentList;
end;

Function TFhirInvoice.GetHasTotalPriceComponentList : boolean;
begin
  result := (FTotalPriceComponentList <> nil) and (FTotalPriceComponentList.count > 0);
end;

Procedure TFhirInvoice.SetTotalNet(value : TFhirMoney);
begin
  FTotalNet.free;
  FTotalNet := value;
end;

Procedure TFhirInvoice.SetTotalGross(value : TFhirMoney);
begin
  FTotalGross.free;
  FTotalGross := value;
end;

Procedure TFhirInvoice.SetPaymentTerms(value : TFhirMarkdown);
begin
  FPaymentTerms.free;
  FPaymentTerms := value;
end;

Function TFhirInvoice.GetPaymentTermsST : String;
begin
  if FPaymentTerms = nil then
    result := ''
  else
    result := FPaymentTerms.value;
end;

Procedure TFhirInvoice.SetPaymentTermsST(value : String);
begin
  if value <> '' then
  begin
    if FPaymentTerms = nil then
      FPaymentTerms := TFhirMarkdown.create;
    FPaymentTerms.value := value
  end
  else if FPaymentTerms <> nil then
    FPaymentTerms.value := '';
end;

Function TFhirInvoice.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirInvoice.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirInvoice.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCancelledReason.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FRecipient.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FparticipantList.sizeInBytes);
  inc(result, FIssuer.sizeInBytes);
  inc(result, FAccount.sizeInBytes);
  inc(result, FlineItemList.sizeInBytes);
  inc(result, FtotalPriceComponentList.sizeInBytes);
  inc(result, FTotalNet.sizeInBytes);
  inc(result, FTotalGross.sizeInBytes);
  inc(result, FPaymentTerms.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirInvoiceListEnumerator }

Constructor TFhirInvoiceListEnumerator.Create(list : TFhirInvoiceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInvoiceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInvoiceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInvoiceListEnumerator.GetCurrent : TFhirInvoice;
begin
  Result := FList[FIndex];
end;

function TFhirInvoiceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInvoiceList }
procedure TFhirInvoiceList.AddItem(value: TFhirInvoice);
begin
  assert(value.ClassName = 'TFhirInvoice', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInvoice');
  add(value);
end;

function TFhirInvoiceList.Append: TFhirInvoice;
begin
  result := TFhirInvoice.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceList.ClearItems;
begin
  Clear;
end;

function TFhirInvoiceList.GetEnumerator : TFhirInvoiceListEnumerator;
begin
  result := TFhirInvoiceListEnumerator.Create(self.link);
end;

function TFhirInvoiceList.Clone: TFhirInvoiceList;
begin
  result := TFhirInvoiceList(inherited Clone);
end;

function TFhirInvoiceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInvoiceList.GetItemN(index: Integer): TFhirInvoice;
begin
  result := TFhirInvoice(ObjectByIndex[index]);
end;

function TFhirInvoiceList.ItemClass: TFslObjectClass;
begin
  result := TFhirInvoice;
end;
function TFhirInvoiceList.IndexOf(value: TFhirInvoice): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInvoiceList.Insert(index: Integer): TFhirInvoice;
begin
  result := TFhirInvoice.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInvoiceList.InsertItem(index: Integer; value: TFhirInvoice);
begin
  assert(value is TFhirInvoice);
  Inherited Insert(index, value);
end;

function TFhirInvoiceList.Item(index: Integer): TFhirInvoice;
begin
  result := TFhirInvoice(ObjectByIndex[index]);
end;

function TFhirInvoiceList.Link: TFhirInvoiceList;
begin
  result := TFhirInvoiceList(inherited Link);
end;

procedure TFhirInvoiceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInvoiceList.SetItemByIndex(index: Integer; value: TFhirInvoice);
begin
  assert(value is TFhirInvoice);
  FhirInvoices[index] := value;
end;

procedure TFhirInvoiceList.SetItemN(index: Integer; value: TFhirInvoice);
begin
  assert(value is TFhirInvoice);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_INVOICE}

{$IFDEF FHIR_PAYMENTNOTICE}

{ TFhirPaymentNotice }

constructor TFhirPaymentNotice.Create;
begin
  inherited;
end;

destructor TFhirPaymentNotice.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FRequest.free;
  FResponse.free;
  FCreated.free;
  FProvider.free;
  FPayment.free;
  FPaymentDate.free;
  FPayee.free;
  FRecipient.free;
  FAmount.free;
  FPaymentStatus.free;
  inherited;
end;

function TFhirPaymentNotice.GetResourceType : TFhirResourceType;
begin
  result := frtPaymentNotice;
end;

procedure TFhirPaymentNotice.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPaymentNotice(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPaymentNotice(oSource).FIdentifierList);
  end;
  FStatus := TFhirPaymentNotice(oSource).FStatus.Link;
  request := TFhirPaymentNotice(oSource).request.Clone;
  response := TFhirPaymentNotice(oSource).response.Clone;
  createdElement := TFhirPaymentNotice(oSource).createdElement.Clone;
  provider := TFhirPaymentNotice(oSource).provider.Clone;
  payment := TFhirPaymentNotice(oSource).payment.Clone;
  paymentDateElement := TFhirPaymentNotice(oSource).paymentDateElement.Clone;
  payee := TFhirPaymentNotice(oSource).payee.Clone;
  recipient := TFhirPaymentNotice(oSource).recipient.Clone;
  amount := TFhirPaymentNotice(oSource).amount.Clone;
  paymentStatus := TFhirPaymentNotice(oSource).paymentStatus.Clone;
end;

procedure TFhirPaymentNotice.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'provider') Then
     list.add(self.link, 'provider', FProvider.Link);
  if (child_name = 'payment') Then
     list.add(self.link, 'payment', FPayment.Link);
  if (child_name = 'paymentDate') Then
     list.add(self.link, 'paymentDate', FPaymentDate.Link);
  if (child_name = 'payee') Then
     list.add(self.link, 'payee', FPayee.Link);
  if (child_name = 'recipient') Then
     list.add(self.link, 'recipient', FRecipient.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'paymentStatus') Then
     list.add(self.link, 'paymentStatus', FPaymentStatus.Link);
end;

procedure TFhirPaymentNotice.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(Any)', false, TFhirReference{TFhirReference}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'response', 'Reference(Any)', false, TFhirReference{TFhirReference}, FResponse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'provider', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FProvider.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payment', 'Reference(PaymentReconciliation)', false, TFhirReference{TFhirPaymentReconciliation}, FPayment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'paymentDate', 'date', false, TFhirDate, FPaymentDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payee', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FPayee.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FRecipient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'paymentStatus', 'CodeableConcept', false, TFhirCodeableConcept, FPaymentStatus.Link));{2}
end;

function TFhirPaymentNotice.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'provider') then
  begin
    Provider := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'payment') then
  begin
    Payment := propValue as TFhirReference{TFhirPaymentReconciliation}{4b};
    result := propValue;
  end
  else if (propName = 'paymentDate') then
  begin
    PaymentDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'payee') then
  begin
    Payee := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    Recipient := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'paymentStatus') then
  begin
    PaymentStatus := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirPaymentNotice.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirPaymentNotice.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'request') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'response') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'provider') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'payment') then result := TFhirReference{TFhirPaymentReconciliation}.create(){4b}
  else if (propName = 'paymentDate') then result := TFhirDate.create() {5b}
  else if (propName = 'payee') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'recipient') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'amount') then result := TFhirMoney.create(){4b}
  else if (propName = 'paymentStatus') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPaymentNotice.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'response') then result := 'Reference'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'provider') then result := 'Reference'
  else if (propName = 'payment') then result := 'Reference'
  else if (propName = 'paymentDate') then result := 'date'
  else if (propName = 'payee') then result := 'Reference'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'amount') then result := 'Money'
  else if (propName = 'paymentStatus') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPaymentNotice.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'provider') then ProviderElement := nil
  else if (propName = 'payment') then PaymentElement := nil
  else if (propName = 'paymentDate') then PaymentDateElement := nil
  else if (propName = 'payee') then PayeeElement := nil
  else if (propName = 'recipient') then RecipientElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'paymentStatus') then PaymentStatusElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPaymentNotice.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'response') then ResponseElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'provider') then ProviderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'payment') then PaymentElement := new as TFhirReference{TFhirPaymentReconciliation}{4}
  else if (propName = 'paymentDate') then PaymentDateElement := asDate(new){5b}
  else if (propName = 'payee') then PayeeElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'recipient') then RecipientElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney{4}
  else if (propName = 'paymentStatus') then PaymentStatusElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPaymentNotice.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPaymentNotice.fhirType : string;
begin
  result := 'PaymentNotice';
end;

function TFhirPaymentNotice.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FRequest) and isEmptyProp(FResponse) and isEmptyProp(FCreated) and isEmptyProp(FProvider) and isEmptyProp(FPayment) and isEmptyProp(FPaymentDate) and isEmptyProp(FPayee) and isEmptyProp(FRecipient) and isEmptyProp(FAmount) and isEmptyProp(FPaymentStatus);
end;

function TFhirPaymentNotice.equals(other : TObject) : boolean; 
var
  o : TFhirPaymentNotice;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPaymentNotice)) then
    result := false
  else
  begin
    o := TFhirPaymentNotice(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(requestElement, o.requestElement, true) and compareDeep(responseElement, o.responseElement, true) and 
      compareDeep(createdElement, o.createdElement, true) and compareDeep(providerElement, o.providerElement, true) and 
      compareDeep(paymentElement, o.paymentElement, true) and compareDeep(paymentDateElement, o.paymentDateElement, true) and 
      compareDeep(payeeElement, o.payeeElement, true) and compareDeep(recipientElement, o.recipientElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(paymentStatusElement, o.paymentStatusElement, true);
  end;
end;

function TFhirPaymentNotice.Link : TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice(inherited Link);
end;

function TFhirPaymentNotice.Clone : TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice(inherited Clone);
end;

procedure TFhirPaymentNotice.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('request');
  fields.add('response');
  fields.add('created');
  fields.add('provider');
  fields.add('payment');
  fields.add('paymentDate');
  fields.add('payee');
  fields.add('recipient');
  fields.add('amount');
  fields.add('paymentStatus');
end;

{ TFhirPaymentNotice }

Function TFhirPaymentNotice.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirPaymentNotice.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirPaymentNotice.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirPaymentNotice.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirPaymentNotice.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Procedure TFhirPaymentNotice.SetRequest(value : TFhirReference{TFhirReference});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirPaymentNotice.SetResponse(value : TFhirReference{TFhirReference});
begin
  FResponse.free;
  FResponse := value;
end;

Procedure TFhirPaymentNotice.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirPaymentNotice.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirPaymentNotice.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirPaymentNotice.SetProvider(value : TFhirReference{TFhirPractitioner});
begin
  FProvider.free;
  FProvider := value;
end;

Procedure TFhirPaymentNotice.SetPayment(value : TFhirReference{TFhirPaymentReconciliation});
begin
  FPayment.free;
  FPayment := value;
end;

Procedure TFhirPaymentNotice.SetPaymentDate(value : TFhirDate);
begin
  FPaymentDate.free;
  FPaymentDate := value;
end;

Function TFhirPaymentNotice.GetPaymentDateST : TFslDateTime;
begin
  if FPaymentDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FPaymentDate.value;
end;

Procedure TFhirPaymentNotice.SetPaymentDateST(value : TFslDateTime);
begin
  if FPaymentDate = nil then
    FPaymentDate := TFhirDate.create;
  FPaymentDate.value := value
end;

Procedure TFhirPaymentNotice.SetPayee(value : TFhirReference{TFhirPractitioner});
begin
  FPayee.free;
  FPayee := value;
end;

Procedure TFhirPaymentNotice.SetRecipient(value : TFhirReference{TFhirOrganization});
begin
  FRecipient.free;
  FRecipient := value;
end;

Procedure TFhirPaymentNotice.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

Procedure TFhirPaymentNotice.SetPaymentStatus(value : TFhirCodeableConcept);
begin
  FPaymentStatus.free;
  FPaymentStatus := value;
end;

function TFhirPaymentNotice.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FResponse.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FProvider.sizeInBytes);
  inc(result, FPayment.sizeInBytes);
  inc(result, FPaymentDate.sizeInBytes);
  inc(result, FPayee.sizeInBytes);
  inc(result, FRecipient.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
  inc(result, FPaymentStatus.sizeInBytes);
end;

{ TFhirPaymentNoticeListEnumerator }

Constructor TFhirPaymentNoticeListEnumerator.Create(list : TFhirPaymentNoticeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPaymentNoticeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPaymentNoticeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPaymentNoticeListEnumerator.GetCurrent : TFhirPaymentNotice;
begin
  Result := FList[FIndex];
end;

function TFhirPaymentNoticeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPaymentNoticeList }
procedure TFhirPaymentNoticeList.AddItem(value: TFhirPaymentNotice);
begin
  assert(value.ClassName = 'TFhirPaymentNotice', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPaymentNotice');
  add(value);
end;

function TFhirPaymentNoticeList.Append: TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentNoticeList.ClearItems;
begin
  Clear;
end;

function TFhirPaymentNoticeList.GetEnumerator : TFhirPaymentNoticeListEnumerator;
begin
  result := TFhirPaymentNoticeListEnumerator.Create(self.link);
end;

function TFhirPaymentNoticeList.Clone: TFhirPaymentNoticeList;
begin
  result := TFhirPaymentNoticeList(inherited Clone);
end;

function TFhirPaymentNoticeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPaymentNoticeList.GetItemN(index: Integer): TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice(ObjectByIndex[index]);
end;

function TFhirPaymentNoticeList.ItemClass: TFslObjectClass;
begin
  result := TFhirPaymentNotice;
end;
function TFhirPaymentNoticeList.IndexOf(value: TFhirPaymentNotice): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPaymentNoticeList.Insert(index: Integer): TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentNoticeList.InsertItem(index: Integer; value: TFhirPaymentNotice);
begin
  assert(value is TFhirPaymentNotice);
  Inherited Insert(index, value);
end;

function TFhirPaymentNoticeList.Item(index: Integer): TFhirPaymentNotice;
begin
  result := TFhirPaymentNotice(ObjectByIndex[index]);
end;

function TFhirPaymentNoticeList.Link: TFhirPaymentNoticeList;
begin
  result := TFhirPaymentNoticeList(inherited Link);
end;

procedure TFhirPaymentNoticeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPaymentNoticeList.SetItemByIndex(index: Integer; value: TFhirPaymentNotice);
begin
  assert(value is TFhirPaymentNotice);
  FhirPaymentNotices[index] := value;
end;

procedure TFhirPaymentNoticeList.SetItemN(index: Integer; value: TFhirPaymentNotice);
begin
  assert(value is TFhirPaymentNotice);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PAYMENTNOTICE}

{$IFDEF FHIR_PAYMENTRECONCILIATION}

{ TFhirPaymentReconciliationDetail }

constructor TFhirPaymentReconciliationDetail.Create;
begin
  inherited;
end;

destructor TFhirPaymentReconciliationDetail.Destroy;
begin
  FIdentifier.free;
  FPredecessor.free;
  FType_.free;
  FRequest.free;
  FSubmitter.free;
  FResponse.free;
  FDate.free;
  FResponsible.free;
  FPayee.free;
  FAmount.free;
  inherited;
end;

procedure TFhirPaymentReconciliationDetail.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirPaymentReconciliationDetail(oSource).identifier.Clone;
  predecessor := TFhirPaymentReconciliationDetail(oSource).predecessor.Clone;
  type_ := TFhirPaymentReconciliationDetail(oSource).type_.Clone;
  request := TFhirPaymentReconciliationDetail(oSource).request.Clone;
  submitter := TFhirPaymentReconciliationDetail(oSource).submitter.Clone;
  response := TFhirPaymentReconciliationDetail(oSource).response.Clone;
  dateElement := TFhirPaymentReconciliationDetail(oSource).dateElement.Clone;
  responsible := TFhirPaymentReconciliationDetail(oSource).responsible.Clone;
  payee := TFhirPaymentReconciliationDetail(oSource).payee.Clone;
  amount := TFhirPaymentReconciliationDetail(oSource).amount.Clone;
end;

procedure TFhirPaymentReconciliationDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'predecessor') Then
     list.add(self.link, 'predecessor', FPredecessor.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'submitter') Then
     list.add(self.link, 'submitter', FSubmitter.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'payee') Then
     list.add(self.link, 'payee', FPayee.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirPaymentReconciliationDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'predecessor', 'Identifier', false, TFhirIdentifier, FPredecessor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(Any)', false, TFhirReference{TFhirReference}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'submitter', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FSubmitter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'response', 'Reference(Any)', false, TFhirReference{TFhirReference}, FResponse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'responsible', 'Reference(PractitionerRole)', false, TFhirReference{TFhirPractitionerRole}, FResponsible.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payee', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FPayee.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Money', false, TFhirMoney, FAmount.Link));{2}
end;

function TFhirPaymentReconciliationDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'predecessor') then
  begin
    Predecessor := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'submitter') then
  begin
    Submitter := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    Responsible := propValue as TFhirReference{TFhirPractitionerRole}{4b};
    result := propValue;
  end
  else if (propName = 'payee') then
  begin
    Payee := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPaymentReconciliationDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPaymentReconciliationDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'predecessor') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'request') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'submitter') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'response') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'date') then result := TFhirDate.create() {5b}
  else if (propName = 'responsible') then result := TFhirReference{TFhirPractitionerRole}.create(){4b}
  else if (propName = 'payee') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'amount') then result := TFhirMoney.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPaymentReconciliationDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'predecessor') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'submitter') then result := 'Reference'
  else if (propName = 'response') then result := 'Reference'
  else if (propName = 'date') then result := 'date'
  else if (propName = 'responsible') then result := 'Reference'
  else if (propName = 'payee') then result := 'Reference'
  else if (propName = 'amount') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPaymentReconciliationDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'predecessor') then PredecessorElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'submitter') then SubmitterElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'payee') then PayeeElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPaymentReconciliationDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'predecessor') then PredecessorElement := new as TFhirIdentifier{4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'submitter') then SubmitterElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'response') then ResponseElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'date') then DateElement := asDate(new){5b}
  else if (propName = 'responsible') then ResponsibleElement := new as TFhirReference{TFhirPractitionerRole}{4}
  else if (propName = 'payee') then PayeeElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'amount') then AmountElement := new as TFhirMoney{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPaymentReconciliationDetail.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPaymentReconciliationDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirPaymentReconciliationDetail.Link : TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail(inherited Link);
end;

function TFhirPaymentReconciliationDetail.Clone : TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail(inherited Clone);
end;

function TFhirPaymentReconciliationDetail.equals(other : TObject) : boolean; 
var
  o : TFhirPaymentReconciliationDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPaymentReconciliationDetail)) then
    result := false
  else
  begin
    o := TFhirPaymentReconciliationDetail(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(predecessorElement, o.predecessorElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(requestElement, o.requestElement, true) and 
      compareDeep(submitterElement, o.submitterElement, true) and compareDeep(responseElement, o.responseElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(responsibleElement, o.responsibleElement, true) and 
      compareDeep(payeeElement, o.payeeElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirPaymentReconciliationDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FPredecessor) and isEmptyProp(FType_) and isEmptyProp(FRequest) and isEmptyProp(FSubmitter) and isEmptyProp(FResponse) and isEmptyProp(FDate) and isEmptyProp(FResponsible) and isEmptyProp(FPayee) and isEmptyProp(FAmount);
end;

procedure TFhirPaymentReconciliationDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('predecessor');
  fields.add('type');
  fields.add('request');
  fields.add('submitter');
  fields.add('response');
  fields.add('date');
  fields.add('responsible');
  fields.add('payee');
  fields.add('amount');
end;

{ TFhirPaymentReconciliationDetail }

Procedure TFhirPaymentReconciliationDetail.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirPaymentReconciliationDetail.SetPredecessor(value : TFhirIdentifier);
begin
  FPredecessor.free;
  FPredecessor := value;
end;

Procedure TFhirPaymentReconciliationDetail.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirPaymentReconciliationDetail.SetRequest(value : TFhirReference{TFhirReference});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirPaymentReconciliationDetail.SetSubmitter(value : TFhirReference{TFhirPractitioner});
begin
  FSubmitter.free;
  FSubmitter := value;
end;

Procedure TFhirPaymentReconciliationDetail.SetResponse(value : TFhirReference{TFhirReference});
begin
  FResponse.free;
  FResponse := value;
end;

Procedure TFhirPaymentReconciliationDetail.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirPaymentReconciliationDetail.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirPaymentReconciliationDetail.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

Procedure TFhirPaymentReconciliationDetail.SetResponsible(value : TFhirReference{TFhirPractitionerRole});
begin
  FResponsible.free;
  FResponsible := value;
end;

Procedure TFhirPaymentReconciliationDetail.SetPayee(value : TFhirReference{TFhirPractitioner});
begin
  FPayee.free;
  FPayee := value;
end;

Procedure TFhirPaymentReconciliationDetail.SetAmount(value : TFhirMoney);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirPaymentReconciliationDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FPredecessor.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FSubmitter.sizeInBytes);
  inc(result, FResponse.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FResponsible.sizeInBytes);
  inc(result, FPayee.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirPaymentReconciliationDetailListEnumerator }

Constructor TFhirPaymentReconciliationDetailListEnumerator.Create(list : TFhirPaymentReconciliationDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPaymentReconciliationDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPaymentReconciliationDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPaymentReconciliationDetailListEnumerator.GetCurrent : TFhirPaymentReconciliationDetail;
begin
  Result := FList[FIndex];
end;

function TFhirPaymentReconciliationDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPaymentReconciliationDetailList }
procedure TFhirPaymentReconciliationDetailList.AddItem(value: TFhirPaymentReconciliationDetail);
begin
  assert(value.ClassName = 'TFhirPaymentReconciliationDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPaymentReconciliationDetail');
  add(value);
end;

function TFhirPaymentReconciliationDetailList.Append: TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationDetailList.ClearItems;
begin
  Clear;
end;

function TFhirPaymentReconciliationDetailList.GetEnumerator : TFhirPaymentReconciliationDetailListEnumerator;
begin
  result := TFhirPaymentReconciliationDetailListEnumerator.Create(self.link);
end;

function TFhirPaymentReconciliationDetailList.Clone: TFhirPaymentReconciliationDetailList;
begin
  result := TFhirPaymentReconciliationDetailList(inherited Clone);
end;

function TFhirPaymentReconciliationDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPaymentReconciliationDetailList.GetItemN(index: Integer): TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirPaymentReconciliationDetail;
end;
function TFhirPaymentReconciliationDetailList.IndexOf(value: TFhirPaymentReconciliationDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPaymentReconciliationDetailList.Insert(index: Integer): TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationDetailList.InsertItem(index: Integer; value: TFhirPaymentReconciliationDetail);
begin
  assert(value is TFhirPaymentReconciliationDetail);
  Inherited Insert(index, value);
end;

function TFhirPaymentReconciliationDetailList.Item(index: Integer): TFhirPaymentReconciliationDetail;
begin
  result := TFhirPaymentReconciliationDetail(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationDetailList.Link: TFhirPaymentReconciliationDetailList;
begin
  result := TFhirPaymentReconciliationDetailList(inherited Link);
end;

procedure TFhirPaymentReconciliationDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPaymentReconciliationDetailList.SetItemByIndex(index: Integer; value: TFhirPaymentReconciliationDetail);
begin
  assert(value is TFhirPaymentReconciliationDetail);
  FhirPaymentReconciliationDetails[index] := value;
end;

procedure TFhirPaymentReconciliationDetailList.SetItemN(index: Integer; value: TFhirPaymentReconciliationDetail);
begin
  assert(value is TFhirPaymentReconciliationDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirPaymentReconciliationProcessNote }

constructor TFhirPaymentReconciliationProcessNote.Create;
begin
  inherited;
end;

destructor TFhirPaymentReconciliationProcessNote.Destroy;
begin
  FType_.free;
  FText.free;
  inherited;
end;

procedure TFhirPaymentReconciliationProcessNote.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirPaymentReconciliationProcessNote(oSource).FType_.Link;
  textElement := TFhirPaymentReconciliationProcessNote(oSource).textElement.Clone;
end;

procedure TFhirPaymentReconciliationProcessNote.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirPaymentReconciliationProcessNote.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
end;

function TFhirPaymentReconciliationProcessNote.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirNoteTypeEnum, CODES_TFhirNoteTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPaymentReconciliationProcessNote.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPaymentReconciliationProcessNote.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'text') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPaymentReconciliationProcessNote.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'text') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPaymentReconciliationProcessNote.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPaymentReconciliationProcessNote.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirNoteTypeEnum, CODES_TFhirNoteTypeEnum, new){4}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPaymentReconciliationProcessNote.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPaymentReconciliationProcessNote.fhirType : string;
begin
  result := 'processNote';
end;

function TFhirPaymentReconciliationProcessNote.Link : TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote(inherited Link);
end;

function TFhirPaymentReconciliationProcessNote.Clone : TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote(inherited Clone);
end;

function TFhirPaymentReconciliationProcessNote.equals(other : TObject) : boolean; 
var
  o : TFhirPaymentReconciliationProcessNote;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPaymentReconciliationProcessNote)) then
    result := false
  else
  begin
    o := TFhirPaymentReconciliationProcessNote(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirPaymentReconciliationProcessNote.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FText);
end;

procedure TFhirPaymentReconciliationProcessNote.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('text');
end;

{ TFhirPaymentReconciliationProcessNote }

Procedure TFhirPaymentReconciliationProcessNote.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirPaymentReconciliationProcessNote.GetType_ST : TFhirNoteTypeEnum;
begin
  if FType_ = nil then
    result := TFhirNoteTypeEnum(0)
  else
    result := TFhirNoteTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirNoteTypeEnum, FType_.value));
end;

Procedure TFhirPaymentReconciliationProcessNote.SetType_ST(value : TFhirNoteTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirNoteTypeEnum[value], CODES_TFhirNoteTypeEnum[value]);
end;

Procedure TFhirPaymentReconciliationProcessNote.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirPaymentReconciliationProcessNote.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirPaymentReconciliationProcessNote.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

function TFhirPaymentReconciliationProcessNote.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FText.sizeInBytes);
end;

{ TFhirPaymentReconciliationProcessNoteListEnumerator }

Constructor TFhirPaymentReconciliationProcessNoteListEnumerator.Create(list : TFhirPaymentReconciliationProcessNoteList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPaymentReconciliationProcessNoteListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPaymentReconciliationProcessNoteListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPaymentReconciliationProcessNoteListEnumerator.GetCurrent : TFhirPaymentReconciliationProcessNote;
begin
  Result := FList[FIndex];
end;

function TFhirPaymentReconciliationProcessNoteListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPaymentReconciliationProcessNoteList }
procedure TFhirPaymentReconciliationProcessNoteList.AddItem(value: TFhirPaymentReconciliationProcessNote);
begin
  assert(value.ClassName = 'TFhirPaymentReconciliationProcessNote', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPaymentReconciliationProcessNote');
  add(value);
end;

function TFhirPaymentReconciliationProcessNoteList.Append: TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationProcessNoteList.ClearItems;
begin
  Clear;
end;

function TFhirPaymentReconciliationProcessNoteList.GetEnumerator : TFhirPaymentReconciliationProcessNoteListEnumerator;
begin
  result := TFhirPaymentReconciliationProcessNoteListEnumerator.Create(self.link);
end;

function TFhirPaymentReconciliationProcessNoteList.Clone: TFhirPaymentReconciliationProcessNoteList;
begin
  result := TFhirPaymentReconciliationProcessNoteList(inherited Clone);
end;

function TFhirPaymentReconciliationProcessNoteList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPaymentReconciliationProcessNoteList.GetItemN(index: Integer): TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationProcessNoteList.ItemClass: TFslObjectClass;
begin
  result := TFhirPaymentReconciliationProcessNote;
end;
function TFhirPaymentReconciliationProcessNoteList.IndexOf(value: TFhirPaymentReconciliationProcessNote): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPaymentReconciliationProcessNoteList.Insert(index: Integer): TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationProcessNoteList.InsertItem(index: Integer; value: TFhirPaymentReconciliationProcessNote);
begin
  assert(value is TFhirPaymentReconciliationProcessNote);
  Inherited Insert(index, value);
end;

function TFhirPaymentReconciliationProcessNoteList.Item(index: Integer): TFhirPaymentReconciliationProcessNote;
begin
  result := TFhirPaymentReconciliationProcessNote(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationProcessNoteList.Link: TFhirPaymentReconciliationProcessNoteList;
begin
  result := TFhirPaymentReconciliationProcessNoteList(inherited Link);
end;

procedure TFhirPaymentReconciliationProcessNoteList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPaymentReconciliationProcessNoteList.SetItemByIndex(index: Integer; value: TFhirPaymentReconciliationProcessNote);
begin
  assert(value is TFhirPaymentReconciliationProcessNote);
  FhirPaymentReconciliationProcessNotes[index] := value;
end;

procedure TFhirPaymentReconciliationProcessNoteList.SetItemN(index: Integer; value: TFhirPaymentReconciliationProcessNote);
begin
  assert(value is TFhirPaymentReconciliationProcessNote);
  ObjectByIndex[index] := value;
end;

{ TFhirPaymentReconciliation }

constructor TFhirPaymentReconciliation.Create;
begin
  inherited;
end;

destructor TFhirPaymentReconciliation.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FPeriod.free;
  FCreated.free;
  FPaymentIssuer.free;
  FRequest.free;
  FRequestor.free;
  FOutcome.free;
  FDisposition.free;
  FPaymentDate.free;
  FPaymentAmount.free;
  FPaymentIdentifier.free;
  FDetailList.Free;
  FFormCode.free;
  FProcessNoteList.Free;
  inherited;
end;

function TFhirPaymentReconciliation.GetResourceType : TFhirResourceType;
begin
  result := frtPaymentReconciliation;
end;

procedure TFhirPaymentReconciliation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPaymentReconciliation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPaymentReconciliation(oSource).FIdentifierList);
  end;
  FStatus := TFhirPaymentReconciliation(oSource).FStatus.Link;
  period := TFhirPaymentReconciliation(oSource).period.Clone;
  createdElement := TFhirPaymentReconciliation(oSource).createdElement.Clone;
  paymentIssuer := TFhirPaymentReconciliation(oSource).paymentIssuer.Clone;
  request := TFhirPaymentReconciliation(oSource).request.Clone;
  requestor := TFhirPaymentReconciliation(oSource).requestor.Clone;
  FOutcome := TFhirPaymentReconciliation(oSource).FOutcome.Link;
  dispositionElement := TFhirPaymentReconciliation(oSource).dispositionElement.Clone;
  paymentDateElement := TFhirPaymentReconciliation(oSource).paymentDateElement.Clone;
  paymentAmount := TFhirPaymentReconciliation(oSource).paymentAmount.Clone;
  paymentIdentifier := TFhirPaymentReconciliation(oSource).paymentIdentifier.Clone;
  if (TFhirPaymentReconciliation(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirPaymentReconciliationDetailList.Create;
    FDetailList.Assign(TFhirPaymentReconciliation(oSource).FDetailList);
  end;
  formCode := TFhirPaymentReconciliation(oSource).formCode.Clone;
  if (TFhirPaymentReconciliation(oSource).FProcessNoteList = nil) then
  begin
    FProcessNoteList.free;
    FProcessNoteList := nil;
  end
  else
  begin
    if FProcessNoteList = nil then
      FProcessNoteList := TFhirPaymentReconciliationProcessNoteList.Create;
    FProcessNoteList.Assign(TFhirPaymentReconciliation(oSource).FProcessNoteList);
  end;
end;

procedure TFhirPaymentReconciliation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'paymentIssuer') Then
     list.add(self.link, 'paymentIssuer', FPaymentIssuer.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'requestor') Then
     list.add(self.link, 'requestor', FRequestor.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'disposition') Then
     list.add(self.link, 'disposition', FDisposition.Link);
  if (child_name = 'paymentDate') Then
     list.add(self.link, 'paymentDate', FPaymentDate.Link);
  if (child_name = 'paymentAmount') Then
     list.add(self.link, 'paymentAmount', FPaymentAmount.Link);
  if (child_name = 'paymentIdentifier') Then
     list.add(self.link, 'paymentIdentifier', FPaymentIdentifier.Link);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
  if (child_name = 'formCode') Then
     list.add(self.link, 'formCode', FFormCode.Link);
  if (child_name = 'processNote') Then
    list.addAll(self, 'processNote', FProcessNoteList);
end;

procedure TFhirPaymentReconciliation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'paymentIssuer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FPaymentIssuer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(Task)', false, TFhirReference{TFhirTask}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestor', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FRequestor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFHIREnum, FOutcome.Link));{1}
  oList.add(TFHIRProperty.create(self, 'disposition', 'string', false, TFhirString, FDisposition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'paymentDate', 'date', false, TFhirDate, FPaymentDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'paymentAmount', 'Money', false, TFhirMoney, FPaymentAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'paymentIdentifier', 'Identifier', false, TFhirIdentifier, FPaymentIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', '', true, TFhirPaymentReconciliationDetail, FDetailList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'formCode', 'CodeableConcept', false, TFhirCodeableConcept, FFormCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'processNote', '', true, TFhirPaymentReconciliationProcessNote, FProcessNoteList.Link)){3};
end;

function TFhirPaymentReconciliation.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'paymentIssuer') then
  begin
    PaymentIssuer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirTask}{4b};
    result := propValue;
  end
  else if (propName = 'requestor') then
  begin
    Requestor := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirRemittanceOutcomeEnum, CODES_TFhirRemittanceOutcomeEnum, propValue);
    result := propValue
  end
  else if (propName = 'disposition') then
  begin
    DispositionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'paymentDate') then
  begin
    PaymentDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'paymentAmount') then
  begin
    PaymentAmount := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'paymentIdentifier') then
  begin
    PaymentIdentifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirPaymentReconciliationDetail){2a};
    result := propValue;
  end
  else if (propName = 'formCode') then
  begin
    FormCode := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'processNote') then
  begin
    ProcessNoteList.add(propValue as TFhirPaymentReconciliationProcessNote){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirPaymentReconciliation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirPaymentReconciliationDetail){2a}
  else if (propName = 'processNote') then ProcessNoteList.insertItem(index, propValue as TFhirPaymentReconciliationProcessNote){2a}
  else inherited;
end;

function TFhirPaymentReconciliation.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'paymentIssuer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'request') then result := TFhirReference{TFhirTask}.create(){4b}
  else if (propName = 'requestor') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'disposition') then result := TFhirString.create() {5b}
  else if (propName = 'paymentDate') then result := TFhirDate.create() {5b}
  else if (propName = 'paymentAmount') then result := TFhirMoney.create(){4b}
  else if (propName = 'paymentIdentifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else if (propName = 'formCode') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'processNote') then result := ProcessNoteList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPaymentReconciliation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'paymentIssuer') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'requestor') then result := 'Reference'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'disposition') then result := 'string'
  else if (propName = 'paymentDate') then result := 'date'
  else if (propName = 'paymentAmount') then result := 'Money'
  else if (propName = 'paymentIdentifier') then result := 'Identifier'
  else if (propName = 'detail') then result := ''
  else if (propName = 'formCode') then result := 'CodeableConcept'
  else if (propName = 'processNote') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPaymentReconciliation.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'paymentIssuer') then PaymentIssuerElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'requestor') then RequestorElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'disposition') then DispositionElement := nil
  else if (propName = 'paymentDate') then PaymentDateElement := nil
  else if (propName = 'paymentAmount') then PaymentAmountElement := nil
  else if (propName = 'paymentIdentifier') then PaymentIdentifierElement := nil
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else if (propName = 'formCode') then FormCodeElement := nil
  else if (propName = 'processNote') then deletePropertyValue('processNote', ProcessNoteList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPaymentReconciliation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'paymentIssuer') then PaymentIssuerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirTask}{4}
  else if (propName = 'requestor') then RequestorElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirRemittanceOutcomeEnum, CODES_TFhirRemittanceOutcomeEnum, new){4}
  else if (propName = 'disposition') then DispositionElement := asString(new){5b}
  else if (propName = 'paymentDate') then PaymentDateElement := asDate(new){5b}
  else if (propName = 'paymentAmount') then PaymentAmountElement := new as TFhirMoney{4}
  else if (propName = 'paymentIdentifier') then PaymentIdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else if (propName = 'formCode') then FormCodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'processNote') then replacePropertyValue('processNote', ProcessNoteList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPaymentReconciliation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else if (propName = 'processNote') then ProcessNoteList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPaymentReconciliation.fhirType : string;
begin
  result := 'PaymentReconciliation';
end;

function TFhirPaymentReconciliation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FPeriod) and isEmptyProp(FCreated) and isEmptyProp(FPaymentIssuer) and isEmptyProp(FRequest) and isEmptyProp(FRequestor) and isEmptyProp(FOutcome) and isEmptyProp(FDisposition) and isEmptyProp(FPaymentDate) and isEmptyProp(FPaymentAmount) and isEmptyProp(FPaymentIdentifier) and isEmptyProp(FdetailList) and isEmptyProp(FFormCode) and isEmptyProp(FprocessNoteList);
end;

function TFhirPaymentReconciliation.equals(other : TObject) : boolean; 
var
  o : TFhirPaymentReconciliation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPaymentReconciliation)) then
    result := false
  else
  begin
    o := TFhirPaymentReconciliation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(createdElement, o.createdElement, true) and 
      compareDeep(paymentIssuerElement, o.paymentIssuerElement, true) and compareDeep(requestElement, o.requestElement, true) and 
      compareDeep(requestorElement, o.requestorElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and 
      compareDeep(dispositionElement, o.dispositionElement, true) and compareDeep(paymentDateElement, o.paymentDateElement, true) and 
      compareDeep(paymentAmountElement, o.paymentAmountElement, true) and compareDeep(paymentIdentifierElement, o.paymentIdentifierElement, true) and 
      compareDeep(detailList, o.detailList, true) and compareDeep(formCodeElement, o.formCodeElement, true) and 
      compareDeep(processNoteList, o.processNoteList, true);
  end;
end;

function TFhirPaymentReconciliation.Link : TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation(inherited Link);
end;

function TFhirPaymentReconciliation.Clone : TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation(inherited Clone);
end;

procedure TFhirPaymentReconciliation.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('period');
  fields.add('created');
  fields.add('paymentIssuer');
  fields.add('request');
  fields.add('requestor');
  fields.add('outcome');
  fields.add('disposition');
  fields.add('paymentDate');
  fields.add('paymentAmount');
  fields.add('paymentIdentifier');
  fields.add('detail');
  fields.add('formCode');
  fields.add('processNote');
end;

{ TFhirPaymentReconciliation }

Function TFhirPaymentReconciliation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirPaymentReconciliation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirPaymentReconciliation.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirPaymentReconciliation.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirPaymentReconciliation.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Procedure TFhirPaymentReconciliation.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirPaymentReconciliation.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirPaymentReconciliation.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirPaymentReconciliation.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirPaymentReconciliation.SetPaymentIssuer(value : TFhirReference{TFhirOrganization});
begin
  FPaymentIssuer.free;
  FPaymentIssuer := value;
end;

Procedure TFhirPaymentReconciliation.SetRequest(value : TFhirReference{TFhirTask});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirPaymentReconciliation.SetRequestor(value : TFhirReference{TFhirPractitioner});
begin
  FRequestor.free;
  FRequestor := value;
end;

Procedure TFhirPaymentReconciliation.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirPaymentReconciliation.GetOutcomeST : TFhirRemittanceOutcomeEnum;
begin
  if FOutcome = nil then
    result := TFhirRemittanceOutcomeEnum(0)
  else
    result := TFhirRemittanceOutcomeEnum(StringArrayIndexOfSensitive(CODES_TFhirRemittanceOutcomeEnum, FOutcome.value));
end;

Procedure TFhirPaymentReconciliation.SetOutcomeST(value : TFhirRemittanceOutcomeEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirRemittanceOutcomeEnum[value], CODES_TFhirRemittanceOutcomeEnum[value]);
end;

Procedure TFhirPaymentReconciliation.SetDisposition(value : TFhirString);
begin
  FDisposition.free;
  FDisposition := value;
end;

Function TFhirPaymentReconciliation.GetDispositionST : String;
begin
  if FDisposition = nil then
    result := ''
  else
    result := FDisposition.value;
end;

Procedure TFhirPaymentReconciliation.SetDispositionST(value : String);
begin
  if value <> '' then
  begin
    if FDisposition = nil then
      FDisposition := TFhirString.create;
    FDisposition.value := value
  end
  else if FDisposition <> nil then
    FDisposition.value := '';
end;

Procedure TFhirPaymentReconciliation.SetPaymentDate(value : TFhirDate);
begin
  FPaymentDate.free;
  FPaymentDate := value;
end;

Function TFhirPaymentReconciliation.GetPaymentDateST : TFslDateTime;
begin
  if FPaymentDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FPaymentDate.value;
end;

Procedure TFhirPaymentReconciliation.SetPaymentDateST(value : TFslDateTime);
begin
  if FPaymentDate = nil then
    FPaymentDate := TFhirDate.create;
  FPaymentDate.value := value
end;

Procedure TFhirPaymentReconciliation.SetPaymentAmount(value : TFhirMoney);
begin
  FPaymentAmount.free;
  FPaymentAmount := value;
end;

Procedure TFhirPaymentReconciliation.SetPaymentIdentifier(value : TFhirIdentifier);
begin
  FPaymentIdentifier.free;
  FPaymentIdentifier := value;
end;

Function TFhirPaymentReconciliation.GetDetailList : TFhirPaymentReconciliationDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirPaymentReconciliationDetailList.Create;
  result := FDetailList;
end;

Function TFhirPaymentReconciliation.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

Procedure TFhirPaymentReconciliation.SetFormCode(value : TFhirCodeableConcept);
begin
  FFormCode.free;
  FFormCode := value;
end;

Function TFhirPaymentReconciliation.GetProcessNoteList : TFhirPaymentReconciliationProcessNoteList;
begin
  if FProcessNoteList = nil then
    FProcessNoteList := TFhirPaymentReconciliationProcessNoteList.Create;
  result := FProcessNoteList;
end;

Function TFhirPaymentReconciliation.GetHasProcessNoteList : boolean;
begin
  result := (FProcessNoteList <> nil) and (FProcessNoteList.count > 0);
end;

function TFhirPaymentReconciliation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FPaymentIssuer.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FRequestor.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FDisposition.sizeInBytes);
  inc(result, FPaymentDate.sizeInBytes);
  inc(result, FPaymentAmount.sizeInBytes);
  inc(result, FPaymentIdentifier.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
  inc(result, FFormCode.sizeInBytes);
  inc(result, FprocessNoteList.sizeInBytes);
end;

{ TFhirPaymentReconciliationListEnumerator }

Constructor TFhirPaymentReconciliationListEnumerator.Create(list : TFhirPaymentReconciliationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPaymentReconciliationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPaymentReconciliationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPaymentReconciliationListEnumerator.GetCurrent : TFhirPaymentReconciliation;
begin
  Result := FList[FIndex];
end;

function TFhirPaymentReconciliationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPaymentReconciliationList }
procedure TFhirPaymentReconciliationList.AddItem(value: TFhirPaymentReconciliation);
begin
  assert(value.ClassName = 'TFhirPaymentReconciliation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPaymentReconciliation');
  add(value);
end;

function TFhirPaymentReconciliationList.Append: TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationList.ClearItems;
begin
  Clear;
end;

function TFhirPaymentReconciliationList.GetEnumerator : TFhirPaymentReconciliationListEnumerator;
begin
  result := TFhirPaymentReconciliationListEnumerator.Create(self.link);
end;

function TFhirPaymentReconciliationList.Clone: TFhirPaymentReconciliationList;
begin
  result := TFhirPaymentReconciliationList(inherited Clone);
end;

function TFhirPaymentReconciliationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPaymentReconciliationList.GetItemN(index: Integer): TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationList.ItemClass: TFslObjectClass;
begin
  result := TFhirPaymentReconciliation;
end;
function TFhirPaymentReconciliationList.IndexOf(value: TFhirPaymentReconciliation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPaymentReconciliationList.Insert(index: Integer): TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPaymentReconciliationList.InsertItem(index: Integer; value: TFhirPaymentReconciliation);
begin
  assert(value is TFhirPaymentReconciliation);
  Inherited Insert(index, value);
end;

function TFhirPaymentReconciliationList.Item(index: Integer): TFhirPaymentReconciliation;
begin
  result := TFhirPaymentReconciliation(ObjectByIndex[index]);
end;

function TFhirPaymentReconciliationList.Link: TFhirPaymentReconciliationList;
begin
  result := TFhirPaymentReconciliationList(inherited Link);
end;

procedure TFhirPaymentReconciliationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPaymentReconciliationList.SetItemByIndex(index: Integer; value: TFhirPaymentReconciliation);
begin
  assert(value is TFhirPaymentReconciliation);
  FhirPaymentReconciliations[index] := value;
end;

procedure TFhirPaymentReconciliationList.SetItemN(index: Integer; value: TFhirPaymentReconciliation);
begin
  assert(value is TFhirPaymentReconciliation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PAYMENTRECONCILIATION}

end.

