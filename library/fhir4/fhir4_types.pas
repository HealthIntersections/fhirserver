unit fhir4_types;

{$I fhir4.inc}

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

{$I fhir.inc}

interface

// FHIR v4.0.0 generated 2018-12-24T07:10:39+11:00

uses
  Classes, SysUtils,
  fsl_base, fsl_utilities, fsl_crypto, fsl_stream,
  fhir_objects, fhir_xhtml,  
  fhir4_base;

Type
  // The lifecycle status of an artifact. from http://hl7.org/fhir/ValueSet/publication-status
  TFhirPublicationStatusEnum = (
    PublicationStatusNull, // Value is missing from Instance 
    PublicationStatusDraft, 
    PublicationStatusActive, 
    PublicationStatusRetired, 
    PublicationStatusUnknown); 
  TFhirPublicationStatusEnumList = set of TFhirPublicationStatusEnum;

  // The status of a resource narrative. from http://hl7.org/fhir/ValueSet/narrative-status
  TFhirNarrativeStatusEnum = (
    NarrativeStatusNull, // Value is missing from Instance 
    NarrativeStatusGenerated, 
    NarrativeStatusExtensions, 
    NarrativeStatusAdditional, 
    NarrativeStatusEmpty); 
  TFhirNarrativeStatusEnumList = set of TFhirNarrativeStatusEnum;

  // The type of contributor. from http://hl7.org/fhir/ValueSet/contributor-type
  TFhirContributorTypeEnum = (
    ContributorTypeNull, // Value is missing from Instance 
    ContributorTypeAuthor, 
    ContributorTypeEditor, 
    ContributorTypeReviewer, 
    ContributorTypeEndorser); 
  TFhirContributorTypeEnumList = set of TFhirContributorTypeEnum;

  // A list of all the concrete types defined in this version of the FHIR specification - Abstract Types, Data Types and Resource Types. from http://hl7.org/fhir/ValueSet/all-types
  TFhirAllTypesEnum = (
    AllTypesNull, // Value is missing from Instance 
    AllTypesAddress, 
    AllTypesAge, 
    AllTypesAnnotation, 
    AllTypesAttachment, 
    AllTypesBackboneElement, 
    AllTypesCodeableConcept, 
    AllTypesCoding, 
    AllTypesContactDetail, 
    AllTypesContactPoint, 
    AllTypesContributor, 
    AllTypesCount, 
    AllTypesDataRequirement, 
    AllTypesDistance, 
    AllTypesDosage, 
    AllTypesDuration, 
    AllTypesElement, 
    AllTypesElementDefinition, 
    AllTypesExpression, 
    AllTypesExtension, 
    AllTypesHumanName, 
    AllTypesIdentifier, 
    AllTypesMarketingStatus, 
    AllTypesMeta, 
    AllTypesMoney, 
    AllTypesMoneyQuantity, 
    AllTypesNarrative, 
    AllTypesParameterDefinition, 
    AllTypesPeriod, 
    AllTypesPopulation, 
    AllTypesProdCharacteristic, 
    AllTypesProductShelfLife, 
    AllTypesQuantity, 
    AllTypesRange, 
    AllTypesRatio, 
    AllTypesReference, 
    AllTypesRelatedArtifact, 
    AllTypesSampledData, 
    AllTypesSignature, 
    AllTypesSimpleQuantity, 
    AllTypesSubstanceAmount, 
    AllTypesTiming, 
    AllTypesTriggerDefinition, 
    AllTypesUsageContext, 
    AllTypesBase64Binary, 
    AllTypesBoolean, 
    AllTypesCanonical, 
    AllTypesCode, 
    AllTypesDate, 
    AllTypesDateTime, 
    AllTypesDecimal, 
    AllTypesId, 
    AllTypesInstant, 
    AllTypesInteger, 
    AllTypesMarkdown, 
    AllTypesOid, 
    AllTypesPositiveInt, 
    AllTypesString, 
    AllTypesTime, 
    AllTypesUnsignedInt, 
    AllTypesUri, 
    AllTypesUrl, 
    AllTypesUuid, 
    AllTypesXhtml, 
    AllTypesAccount, 
    AllTypesActivityDefinition, 
    AllTypesAdverseEvent, 
    AllTypesAllergyIntolerance, 
    AllTypesAppointment, 
    AllTypesAppointmentResponse, 
    AllTypesAuditEvent, 
    AllTypesBasic, 
    AllTypesBinary, 
    AllTypesBiologicallyDerivedProduct, 
    AllTypesBodyStructure, 
    AllTypesBundle, 
    AllTypesCapabilityStatement, 
    AllTypesCarePlan, 
    AllTypesCareTeam, 
    AllTypesCatalogEntry, 
    AllTypesChargeItem, 
    AllTypesChargeItemDefinition, 
    AllTypesClaim, 
    AllTypesClaimResponse, 
    AllTypesClinicalImpression, 
    AllTypesCodeSystem, 
    AllTypesCommunication, 
    AllTypesCommunicationRequest, 
    AllTypesCompartmentDefinition, 
    AllTypesComposition, 
    AllTypesConceptMap, 
    AllTypesCondition, 
    AllTypesConsent, 
    AllTypesContract, 
    AllTypesCoverage, 
    AllTypesCoverageEligibilityRequest, 
    AllTypesCoverageEligibilityResponse, 
    AllTypesDetectedIssue, 
    AllTypesDevice, 
    AllTypesDeviceDefinition, 
    AllTypesDeviceMetric, 
    AllTypesDeviceRequest, 
    AllTypesDeviceUseStatement, 
    AllTypesDiagnosticReport, 
    AllTypesDocumentManifest, 
    AllTypesDocumentReference, 
    AllTypesDomainResource, 
    AllTypesEffectEvidenceSynthesis, 
    AllTypesEncounter, 
    AllTypesEndpoint, 
    AllTypesEnrollmentRequest, 
    AllTypesEnrollmentResponse, 
    AllTypesEpisodeOfCare, 
    AllTypesEventDefinition, 
    AllTypesEvidence, 
    AllTypesEvidenceVariable, 
    AllTypesExampleScenario, 
    AllTypesExplanationOfBenefit, 
    AllTypesFamilyMemberHistory, 
    AllTypesFlag, 
    AllTypesGoal, 
    AllTypesGraphDefinition, 
    AllTypesGroup, 
    AllTypesGuidanceResponse, 
    AllTypesHealthcareService, 
    AllTypesImagingStudy, 
    AllTypesImmunization, 
    AllTypesImmunizationEvaluation, 
    AllTypesImmunizationRecommendation, 
    AllTypesImplementationGuide, 
    AllTypesInsurancePlan, 
    AllTypesInvoice, 
    AllTypesLibrary, 
    AllTypesLinkage, 
    AllTypesList, 
    AllTypesLocation, 
    AllTypesMeasure, 
    AllTypesMeasureReport, 
    AllTypesMedia, 
    AllTypesMedication, 
    AllTypesMedicationAdministration, 
    AllTypesMedicationDispense, 
    AllTypesMedicationKnowledge, 
    AllTypesMedicationRequest, 
    AllTypesMedicationStatement, 
    AllTypesMedicinalProduct, 
    AllTypesMedicinalProductAuthorization, 
    AllTypesMedicinalProductContraindication, 
    AllTypesMedicinalProductIndication, 
    AllTypesMedicinalProductIngredient, 
    AllTypesMedicinalProductInteraction, 
    AllTypesMedicinalProductManufactured, 
    AllTypesMedicinalProductPackaged, 
    AllTypesMedicinalProductPharmaceutical, 
    AllTypesMedicinalProductUndesirableEffect, 
    AllTypesMessageDefinition, 
    AllTypesMessageHeader, 
    AllTypesMolecularSequence, 
    AllTypesNamingSystem, 
    AllTypesNutritionOrder, 
    AllTypesObservation, 
    AllTypesObservationDefinition, 
    AllTypesOperationDefinition, 
    AllTypesOperationOutcome, 
    AllTypesOrganization, 
    AllTypesOrganizationAffiliation, 
    AllTypesParameters, 
    AllTypesPatient, 
    AllTypesPaymentNotice, 
    AllTypesPaymentReconciliation, 
    AllTypesPerson, 
    AllTypesPlanDefinition, 
    AllTypesPractitioner, 
    AllTypesPractitionerRole, 
    AllTypesProcedure, 
    AllTypesProvenance, 
    AllTypesQuestionnaire, 
    AllTypesQuestionnaireResponse, 
    AllTypesRelatedPerson, 
    AllTypesRequestGroup, 
    AllTypesResearchDefinition, 
    AllTypesResearchElementDefinition, 
    AllTypesResearchStudy, 
    AllTypesResearchSubject, 
    AllTypesResource, 
    AllTypesRiskAssessment, 
    AllTypesRiskEvidenceSynthesis, 
    AllTypesSchedule, 
    AllTypesSearchParameter, 
    AllTypesServiceRequest, 
    AllTypesSlot, 
    AllTypesSpecimen, 
    AllTypesSpecimenDefinition, 
    AllTypesStructureDefinition, 
    AllTypesStructureMap, 
    AllTypesSubscription, 
    AllTypesSubstance, 
    AllTypesSubstanceNucleicAcid, 
    AllTypesSubstancePolymer, 
    AllTypesSubstanceProtein, 
    AllTypesSubstanceReferenceInformation, 
    AllTypesSubstanceSourceMaterial, 
    AllTypesSubstanceSpecification, 
    AllTypesSupplyDelivery, 
    AllTypesSupplyRequest, 
    AllTypesTask, 
    AllTypesTerminologyCapabilities, 
    AllTypesTestReport, 
    AllTypesTestScript, 
    AllTypesValueSet, 
    AllTypesVerificationResult, 
    AllTypesVisionPrescription, 
    AllTypesType, 
    AllTypesAny); 
  TFhirAllTypesEnumList = set of TFhirAllTypesEnum;

  // The possible sort directions, ascending or descending. from http://hl7.org/fhir/ValueSet/sort-direction
  TFhirSortDirectionEnum = (
    SortDirectionNull, // Value is missing from Instance 
    SortDirectionAscending, 
    SortDirectionDescending); 
  TFhirSortDirectionEnumList = set of TFhirSortDirectionEnum;

  // Identifies the purpose for this identifier, if known . from http://hl7.org/fhir/ValueSet/identifier-use
  TFhirIdentifierUseEnum = (
    IdentifierUseNull, // Value is missing from Instance 
    IdentifierUseUsual, 
    IdentifierUseOfficial, 
    IdentifierUseTemp, 
    IdentifierUseSecondary, 
    IdentifierUseOld); 
  TFhirIdentifierUseEnumList = set of TFhirIdentifierUseEnum;

  // The type of trigger. from http://hl7.org/fhir/ValueSet/trigger-type
  TFhirTriggerTypeEnum = (
    TriggerTypeNull, // Value is missing from Instance 
    TriggerTypeNamedEvent, 
    TriggerTypePeriodic, 
    TriggerTypeDataChanged, 
    TriggerTypeDataAdded, 
    TriggerTypeDataModified, 
    TriggerTypeDataRemoved, 
    TriggerTypeDataAccessed, 
    TriggerTypeDataAccessEnded); 
  TFhirTriggerTypeEnumList = set of TFhirTriggerTypeEnum;

  // How the Quantity should be understood and represented. from http://hl7.org/fhir/ValueSet/quantity-comparator
  TFhirQuantityComparatorEnum = (
    QuantityComparatorNull, // Value is missing from Instance 
    QuantityComparatorLessThan, 
    QuantityComparatorLessOrEquals, 
    QuantityComparatorGreaterOrEquals, 
    QuantityComparatorGreaterThan); 
  TFhirQuantityComparatorEnumList = set of TFhirQuantityComparatorEnum;

  // The type of relationship to the related artifact. from http://hl7.org/fhir/ValueSet/related-artifact-type
  TFhirRelatedArtifactTypeEnum = (
    RelatedArtifactTypeNull, // Value is missing from Instance 
    RelatedArtifactTypeDocumentation, 
    RelatedArtifactTypeJustification, 
    RelatedArtifactTypeCitation, 
    RelatedArtifactTypePredecessor, 
    RelatedArtifactTypeSuccessor, 
    RelatedArtifactTypeDerivedFrom, 
    RelatedArtifactTypeDependsOn, 
    RelatedArtifactTypeComposedOf); 
  TFhirRelatedArtifactTypeEnumList = set of TFhirRelatedArtifactTypeEnum;

  // Whether the parameter is input or output. from http://hl7.org/fhir/ValueSet/operation-parameter-use
  TFhirOperationParameterUseEnum = (
    OperationParameterUseNull, // Value is missing from Instance 
    OperationParameterUseIn, 
    OperationParameterUseOut); 
  TFhirOperationParameterUseEnumList = set of TFhirOperationParameterUseEnum;

  // Telecommunications form for contact point. from http://hl7.org/fhir/ValueSet/contact-point-system
  TFhirContactPointSystemEnum = (
    ContactPointSystemNull, // Value is missing from Instance 
    ContactPointSystemPhone, 
    ContactPointSystemFax, 
    ContactPointSystemEmail, 
    ContactPointSystemPager, 
    ContactPointSystemUrl, 
    ContactPointSystemSms, 
    ContactPointSystemOther); 
  TFhirContactPointSystemEnumList = set of TFhirContactPointSystemEnum;

  // Use of contact point. from http://hl7.org/fhir/ValueSet/contact-point-use
  TFhirContactPointUseEnum = (
    ContactPointUseNull, // Value is missing from Instance 
    ContactPointUseHome, 
    ContactPointUseWork, 
    ContactPointUseTemp, 
    ContactPointUseOld, 
    ContactPointUseMobile); 
  TFhirContactPointUseEnumList = set of TFhirContactPointUseEnum;

  // The use of a human name. from http://hl7.org/fhir/ValueSet/name-use
  TFhirNameUseEnum = (
    NameUseNull, // Value is missing from Instance 
    NameUseUsual, 
    NameUseOfficial, 
    NameUseTemp, 
    NameUseNickname, 
    NameUseAnonymous, 
    NameUseOld, 
    NameUseMaiden); 
  TFhirNameUseEnumList = set of TFhirNameUseEnum;

  // The use of an address. from http://hl7.org/fhir/ValueSet/address-use
  TFhirAddressUseEnum = (
    AddressUseNull, // Value is missing from Instance 
    AddressUseHome, 
    AddressUseWork, 
    AddressUseTemp, 
    AddressUseOld, 
    AddressUseBilling); 
  TFhirAddressUseEnumList = set of TFhirAddressUseEnum;

  // The type of an address (physical / postal). from http://hl7.org/fhir/ValueSet/address-type
  TFhirAddressTypeEnum = (
    AddressTypeNull, // Value is missing from Instance 
    AddressTypePostal, 
    AddressTypePhysical, 
    AddressTypeBoth); 
  TFhirAddressTypeEnumList = set of TFhirAddressTypeEnum;

  // How a property is represented when serialized. from http://hl7.org/fhir/ValueSet/property-representation
  TFhirPropertyRepresentationEnum = (
    PropertyRepresentationNull, // Value is missing from Instance 
    PropertyRepresentationXmlAttr, 
    PropertyRepresentationXmlText, 
    PropertyRepresentationTypeAttr, 
    PropertyRepresentationCdaText, 
    PropertyRepresentationXhtml); 
  TFhirPropertyRepresentationEnumList = set of TFhirPropertyRepresentationEnum;

  // How an element value is interpreted when discrimination is evaluated. from http://hl7.org/fhir/ValueSet/discriminator-type
  TFhirDiscriminatorTypeEnum = (
    DiscriminatorTypeNull, // Value is missing from Instance 
    DiscriminatorTypeValue, 
    DiscriminatorTypeExists, 
    DiscriminatorTypePattern, 
    DiscriminatorTypeType, 
    DiscriminatorTypeProfile); 
  TFhirDiscriminatorTypeEnumList = set of TFhirDiscriminatorTypeEnum;

  // How slices are interpreted when evaluating an instance. from http://hl7.org/fhir/ValueSet/resource-slicing-rules
  TFhirResourceSlicingRulesEnum = (
    ResourceSlicingRulesNull, // Value is missing from Instance 
    ResourceSlicingRulesClosed, 
    ResourceSlicingRulesOpen, 
    ResourceSlicingRulesOpenAtEnd); 
  TFhirResourceSlicingRulesEnumList = set of TFhirResourceSlicingRulesEnum;

  // How resource references can be aggregated. from http://hl7.org/fhir/ValueSet/resource-aggregation-mode
  TFhirResourceAggregationModeEnum = (
    ResourceAggregationModeNull, // Value is missing from Instance 
    ResourceAggregationModeContained, 
    ResourceAggregationModeReferenced, 
    ResourceAggregationModeBundled); 
  TFhirResourceAggregationModeEnumList = set of TFhirResourceAggregationModeEnum;

  // Whether a reference needs to be version specific or version independent, or whether either can be used. from http://hl7.org/fhir/ValueSet/reference-version-rules
  TFhirReferenceVersionRulesEnum = (
    ReferenceVersionRulesNull, // Value is missing from Instance 
    ReferenceVersionRulesEither, 
    ReferenceVersionRulesIndependent, 
    ReferenceVersionRulesSpecific); 
  TFhirReferenceVersionRulesEnumList = set of TFhirReferenceVersionRulesEnum;

  // SHALL applications comply with this constraint? from http://hl7.org/fhir/ValueSet/constraint-severity
  TFhirConstraintSeverityEnum = (
    ConstraintSeverityNull, // Value is missing from Instance 
    ConstraintSeverityError, 
    ConstraintSeverityWarning); 
  TFhirConstraintSeverityEnumList = set of TFhirConstraintSeverityEnum;

  // Indication of the degree of conformance expectations associated with a binding. from http://hl7.org/fhir/ValueSet/binding-strength
  TFhirBindingStrengthEnum = (
    BindingStrengthNull, // Value is missing from Instance 
    BindingStrengthRequired, 
    BindingStrengthExtensible, 
    BindingStrengthPreferred, 
    BindingStrengthExample); 
  TFhirBindingStrengthEnumList = set of TFhirBindingStrengthEnum;

  // A unit of time (units from UCUM). from http://hl7.org/fhir/ValueSet/units-of-time
  TFhirUnitsOfTimeEnum = (
    UnitsOfTimeNull, // Value is missing from Instance 
    UnitsOfTimeS, 
    UnitsOfTimeMin, 
    UnitsOfTimeH, 
    UnitsOfTimeD, 
    UnitsOfTimeWk, 
    UnitsOfTimeMo, 
    UnitsOfTimeA); 
  TFhirUnitsOfTimeEnumList = set of TFhirUnitsOfTimeEnum;

  //  from http://hl7.org/fhir/ValueSet/days-of-week
  TFhirDaysOfWeekEnum = (
    DaysOfWeekNull, // Value is missing from Instance 
    DaysOfWeekMon, 
    DaysOfWeekTue, 
    DaysOfWeekWed, 
    DaysOfWeekThu, 
    DaysOfWeekFri, 
    DaysOfWeekSat, 
    DaysOfWeekSun); 
  TFhirDaysOfWeekEnumList = set of TFhirDaysOfWeekEnum;

  // Real world event relating to the schedule. from http://hl7.org/fhir/ValueSet/event-timing
  TFhirEventTimingEnum = (
    EventTimingNull, // Value is missing from Instance 
    EventTimingMORN, 
    EventTimingMORNEarly, 
    EventTimingMORNLate, 
    EventTimingNOON, 
    EventTimingAFT, 
    EventTimingAFTEarly, 
    EventTimingAFTLate, 
    EventTimingEVE, 
    EventTimingEVEEarly, 
    EventTimingEVELate, 
    EventTimingNIGHT, 
    EventTimingPHS, 
    EventTimingHS, 
    EventTimingWAKE, 
    EventTimingC, 
    EventTimingCM, 
    EventTimingCD, 
    EventTimingCV, 
    EventTimingAC, 
    EventTimingACM, 
    EventTimingACD, 
    EventTimingACV, 
    EventTimingPC, 
    EventTimingPCM, 
    EventTimingPCD, 
    EventTimingPCV); 
  TFhirEventTimingEnumList = set of TFhirEventTimingEnum;

  // Indicates whether the account is available to be used. from http://hl7.org/fhir/ValueSet/account-status
  TFhirAccountStatusEnum = (
    AccountStatusNull, // Value is missing from Instance 
    AccountStatusActive, 
    AccountStatusInactive, 
    AccountStatusEnteredInError, 
    AccountStatusOnHold, 
    AccountStatusUnknown); 
  TFhirAccountStatusEnumList = set of TFhirAccountStatusEnum;

  // The kind of activity the definition is describing. from http://hl7.org/fhir/ValueSet/request-resource-types
  TFhirRequestResourceTypesEnum = (
    RequestResourceTypesNull, // Value is missing from Instance 
    RequestResourceTypesAppointment, 
    RequestResourceTypesAppointmentResponse, 
    RequestResourceTypesCarePlan, 
    RequestResourceTypesClaim, 
    RequestResourceTypesCommunicationRequest, 
    RequestResourceTypesContract, 
    RequestResourceTypesDeviceRequest, 
    RequestResourceTypesEnrollmentRequest, 
    RequestResourceTypesImmunizationRecommendation, 
    RequestResourceTypesMedicationRequest, 
    RequestResourceTypesNutritionOrder, 
    RequestResourceTypesServiceRequest, 
    RequestResourceTypesSupplyRequest, 
    RequestResourceTypesTask, 
    RequestResourceTypesVisionPrescription); 
  TFhirRequestResourceTypesEnumList = set of TFhirRequestResourceTypesEnum;

  // Codes indicating the degree of authority/intentionality associated with a request. from http://hl7.org/fhir/ValueSet/request-intent
  TFhirRequestIntentEnum = (
    RequestIntentNull, // Value is missing from Instance 
    RequestIntentProposal, 
    RequestIntentPlan, 
    RequestIntentDirective, 
    RequestIntentOrder, 
    RequestIntentOriginalOrder, 
    RequestIntentReflexOrder, 
    RequestIntentFillerOrder, 
    RequestIntentInstanceOrder, 
    RequestIntentOption); 
  TFhirRequestIntentEnumList = set of TFhirRequestIntentEnum;

  // Identifies the level of importance to be assigned to actioning the request. from http://hl7.org/fhir/ValueSet/request-priority
  TFhirRequestPriorityEnum = (
    RequestPriorityNull, // Value is missing from Instance 
    RequestPriorityRoutine, 
    RequestPriorityUrgent, 
    RequestPriorityAsap, 
    RequestPriorityStat); 
  TFhirRequestPriorityEnumList = set of TFhirRequestPriorityEnum;

  // The type of participant in the activity. from http://hl7.org/fhir/ValueSet/action-participant-type
  TFhirActionParticipantTypeEnum = (
    ActionParticipantTypeNull, // Value is missing from Instance 
    ActionParticipantTypePatient, 
    ActionParticipantTypePractitioner, 
    ActionParticipantTypeRelatedPerson, 
    ActionParticipantTypeDevice); 
  TFhirActionParticipantTypeEnumList = set of TFhirActionParticipantTypeEnum;

  // Overall nature of the adverse event, e.g. real or potential. from http://hl7.org/fhir/ValueSet/adverse-event-actuality
  TFhirAdverseEventActualityEnum = (
    AdverseEventActualityNull, // Value is missing from Instance 
    AdverseEventActualityActual, 
    AdverseEventActualityPotential); 
  TFhirAdverseEventActualityEnumList = set of TFhirAdverseEventActualityEnum;

  // Identification of the underlying physiological mechanism for a Reaction Risk. from http://hl7.org/fhir/ValueSet/allergy-intolerance-type
  TFhirAllergyIntoleranceTypeEnum = (
    AllergyIntoleranceTypeNull, // Value is missing from Instance 
    AllergyIntoleranceTypeAllergy, 
    AllergyIntoleranceTypeIntolerance); 
  TFhirAllergyIntoleranceTypeEnumList = set of TFhirAllergyIntoleranceTypeEnum;

  // Category of an identified substance associated with allergies or intolerances. from http://hl7.org/fhir/ValueSet/allergy-intolerance-category
  TFhirAllergyIntoleranceCategoryEnum = (
    AllergyIntoleranceCategoryNull, // Value is missing from Instance 
    AllergyIntoleranceCategoryFood, 
    AllergyIntoleranceCategoryMedication, 
    AllergyIntoleranceCategoryEnvironment, 
    AllergyIntoleranceCategoryBiologic); 
  TFhirAllergyIntoleranceCategoryEnumList = set of TFhirAllergyIntoleranceCategoryEnum;

  // Estimate of the potential clinical harm, or seriousness, of a reaction to an identified substance. from http://hl7.org/fhir/ValueSet/allergy-intolerance-criticality
  TFhirAllergyIntoleranceCriticalityEnum = (
    AllergyIntoleranceCriticalityNull, // Value is missing from Instance 
    AllergyIntoleranceCriticalityLow, 
    AllergyIntoleranceCriticalityHigh, 
    AllergyIntoleranceCriticalityUnableToAssess); 
  TFhirAllergyIntoleranceCriticalityEnumList = set of TFhirAllergyIntoleranceCriticalityEnum;

  // Clinical assessment of the severity of a reaction event as a whole, potentially considering multiple different manifestations. from http://hl7.org/fhir/ValueSet/reaction-event-severity
  TFhirReactionEventSeverityEnum = (
    ReactionEventSeverityNull, // Value is missing from Instance 
    ReactionEventSeverityMild, 
    ReactionEventSeverityModerate, 
    ReactionEventSeveritySevere); 
  TFhirReactionEventSeverityEnumList = set of TFhirReactionEventSeverityEnum;

  // The free/busy status of an appointment. from http://hl7.org/fhir/ValueSet/appointmentstatus
  TFhirAppointmentstatusEnum = (
    AppointmentstatusNull, // Value is missing from Instance 
    AppointmentstatusProposed, 
    AppointmentstatusPending, 
    AppointmentstatusBooked, 
    AppointmentstatusArrived, 
    AppointmentstatusFulfilled, 
    AppointmentstatusCancelled, 
    AppointmentstatusNoshow, 
    AppointmentstatusEnteredInError, 
    AppointmentstatusCheckedIn, 
    AppointmentstatusWaitlist); 
  TFhirAppointmentstatusEnumList = set of TFhirAppointmentstatusEnum;

  // Is the Participant required to attend the appointment. from http://hl7.org/fhir/ValueSet/participantrequired
  TFhirParticipantrequiredEnum = (
    ParticipantrequiredNull, // Value is missing from Instance 
    ParticipantrequiredRequired, 
    ParticipantrequiredOptional, 
    ParticipantrequiredInformationOnly); 
  TFhirParticipantrequiredEnumList = set of TFhirParticipantrequiredEnum;

  // The Participation status of an appointment. from http://hl7.org/fhir/ValueSet/participationstatus
  TFhirParticipationstatusEnum = (
    ParticipationstatusNull, // Value is missing from Instance 
    ParticipationstatusAccepted, 
    ParticipationstatusDeclined, 
    ParticipationstatusTentative, 
    ParticipationstatusNeedsAction); 
  TFhirParticipationstatusEnumList = set of TFhirParticipationstatusEnum;

  // Indicator for type of action performed during the event that generated the event. from http://hl7.org/fhir/ValueSet/audit-event-action
  TFhirAuditEventActionEnum = (
    AuditEventActionNull, // Value is missing from Instance 
    AuditEventActionC, 
    AuditEventActionR, 
    AuditEventActionU, 
    AuditEventActionD, 
    AuditEventActionE); 
  TFhirAuditEventActionEnumList = set of TFhirAuditEventActionEnum;

  // Indicates whether the event succeeded or failed. from http://hl7.org/fhir/ValueSet/audit-event-outcome
  TFhirAuditEventOutcomeEnum = (
    AuditEventOutcomeNull, // Value is missing from Instance 
    AuditEventOutcome0, 
    AuditEventOutcome4, 
    AuditEventOutcome8, 
    AuditEventOutcome12); 
  TFhirAuditEventOutcomeEnumList = set of TFhirAuditEventOutcomeEnum;

  // The type of network access point of this agent in the audit event. from http://hl7.org/fhir/ValueSet/network-type
  TFhirNetworkTypeEnum = (
    NetworkTypeNull, // Value is missing from Instance 
    NetworkType1, 
    NetworkType2, 
    NetworkType3, 
    NetworkType4, 
    NetworkType5); 
  TFhirNetworkTypeEnumList = set of TFhirNetworkTypeEnum;

  // Biologically Derived Product Category. from http://hl7.org/fhir/ValueSet/product-category
  TFhirProductCategoryEnum = (
    ProductCategoryNull, // Value is missing from Instance 
    ProductCategoryOrgan, 
    ProductCategoryTissue, 
    ProductCategoryFluid, 
    ProductCategoryCells, 
    ProductCategoryBiologicalAgent); 
  TFhirProductCategoryEnumList = set of TFhirProductCategoryEnum;

  // Biologically Derived Product Status. from http://hl7.org/fhir/ValueSet/product-status
  TFhirProductStatusEnum = (
    ProductStatusNull, // Value is missing from Instance 
    ProductStatusAvailable, 
    ProductStatusUnavailable); 
  TFhirProductStatusEnumList = set of TFhirProductStatusEnum;

  // BiologicallyDerived Product Storage Scale. from http://hl7.org/fhir/ValueSet/product-storage-scale
  TFhirProductStorageScaleEnum = (
    ProductStorageScaleNull, // Value is missing from Instance 
    ProductStorageScaleFarenheit, 
    ProductStorageScaleCelsius, 
    ProductStorageScaleKelvin); 
  TFhirProductStorageScaleEnumList = set of TFhirProductStorageScaleEnum;

  // Indicates the purpose of a bundle - how it is intended to be used. from http://hl7.org/fhir/ValueSet/bundle-type
  TFhirBundleTypeEnum = (
    BundleTypeNull, // Value is missing from Instance 
    BundleTypeDocument, 
    BundleTypeMessage, 
    BundleTypeTransaction, 
    BundleTypeTransactionResponse, 
    BundleTypeBatch, 
    BundleTypeBatchResponse, 
    BundleTypeHistory, 
    BundleTypeSearchset, 
    BundleTypeCollection); 
  TFhirBundleTypeEnumList = set of TFhirBundleTypeEnum;

  // Why an entry is in the result set - whether it's included as a match or because of an _include requirement, or to convey information or warning information about the search process. from http://hl7.org/fhir/ValueSet/search-entry-mode
  TFhirSearchEntryModeEnum = (
    SearchEntryModeNull, // Value is missing from Instance 
    SearchEntryModeMatch, 
    SearchEntryModeInclude, 
    SearchEntryModeOutcome); 
  TFhirSearchEntryModeEnumList = set of TFhirSearchEntryModeEnum;

  // HTTP verbs (in the HTTP command line). See [HTTP rfc](https://tools.ietf.org/html/rfc7231) for details. from http://hl7.org/fhir/ValueSet/http-verb
  TFhirHttpVerbEnum = (
    HttpVerbNull, // Value is missing from Instance 
    HttpVerbGET, 
    HttpVerbHEAD, 
    HttpVerbPOST, 
    HttpVerbPUT, 
    HttpVerbDELETE, 
    HttpVerbPATCH); 
  TFhirHttpVerbEnumList = set of TFhirHttpVerbEnum;

  // How a capability statement is intended to be used. from http://hl7.org/fhir/ValueSet/capability-statement-kind
  TFhirCapabilityStatementKindEnum = (
    CapabilityStatementKindNull, // Value is missing from Instance 
    CapabilityStatementKindInstance, 
    CapabilityStatementKindCapability, 
    CapabilityStatementKindRequirements); 
  TFhirCapabilityStatementKindEnumList = set of TFhirCapabilityStatementKindEnum;

  // All {$IFNDEF FPC}Published{$ENDIF} FHIR Versions. from http://hl7.org/fhir/ValueSet/FHIR-version
  TFhirFHIRVersionEnum = (
    FHIRVersionNull, // Value is missing from Instance 
    FHIRVersion001, 
    FHIRVersion005, 
    FHIRVersion006, 
    FHIRVersion011, 
    FHIRVersion0080, 
    FHIRVersion0081, 
    FHIRVersion0082, 
    FHIRVersion040, 
    FHIRVersion050, 
    FHIRVersion100, 
    FHIRVersion101, 
    FHIRVersion102, 
    FHIRVersion110, 
    FHIRVersion140, 
    FHIRVersion160, 
    FHIRVersion180, 
    FHIRVersion300, 
    FHIRVersion301,
    FHIRVersion302,
    FHIRVersion330,
    FHIRVersion350,
    FHIRVersion400,
    FHIRVersion401);
  TFhirFHIRVersionEnumList = set of TFhirFHIRVersionEnum;

  // The mode of a RESTful capability statement. from http://hl7.org/fhir/ValueSet/restful-capability-mode
  TFhirRestfulCapabilityModeEnum = (
    RestfulCapabilityModeNull, // Value is missing from Instance 
    RestfulCapabilityModeClient, 
    RestfulCapabilityModeServer); 
  TFhirRestfulCapabilityModeEnumList = set of TFhirRestfulCapabilityModeEnum;

  // One of the resource types defined as part of this version of FHIR. from http://hl7.org/fhir/ValueSet/resource-types
  TFhirResourceTypesEnum = (
    ResourceTypesNull, // Value is missing from Instance 
    ResourceTypesAccount, 
    ResourceTypesActivityDefinition, 
    ResourceTypesAdverseEvent, 
    ResourceTypesAllergyIntolerance, 
    ResourceTypesAppointment, 
    ResourceTypesAppointmentResponse, 
    ResourceTypesAuditEvent, 
    ResourceTypesBasic, 
    ResourceTypesBinary, 
    ResourceTypesBiologicallyDerivedProduct, 
    ResourceTypesBodyStructure, 
    ResourceTypesBundle, 
    ResourceTypesCapabilityStatement, 
    ResourceTypesCarePlan, 
    ResourceTypesCareTeam, 
    ResourceTypesCatalogEntry, 
    ResourceTypesChargeItem, 
    ResourceTypesChargeItemDefinition, 
    ResourceTypesClaim, 
    ResourceTypesClaimResponse, 
    ResourceTypesClinicalImpression, 
    ResourceTypesCodeSystem, 
    ResourceTypesCommunication, 
    ResourceTypesCommunicationRequest, 
    ResourceTypesCompartmentDefinition, 
    ResourceTypesComposition, 
    ResourceTypesConceptMap, 
    ResourceTypesCondition, 
    ResourceTypesConsent, 
    ResourceTypesContract, 
    ResourceTypesCoverage, 
    ResourceTypesCoverageEligibilityRequest, 
    ResourceTypesCoverageEligibilityResponse, 
    ResourceTypesDetectedIssue, 
    ResourceTypesDevice, 
    ResourceTypesDeviceDefinition, 
    ResourceTypesDeviceMetric, 
    ResourceTypesDeviceRequest, 
    ResourceTypesDeviceUseStatement, 
    ResourceTypesDiagnosticReport, 
    ResourceTypesDocumentManifest, 
    ResourceTypesDocumentReference, 
    ResourceTypesDomainResource, 
    ResourceTypesEffectEvidenceSynthesis, 
    ResourceTypesEncounter, 
    ResourceTypesEndpoint, 
    ResourceTypesEnrollmentRequest, 
    ResourceTypesEnrollmentResponse, 
    ResourceTypesEpisodeOfCare, 
    ResourceTypesEventDefinition, 
    ResourceTypesEvidence, 
    ResourceTypesEvidenceVariable, 
    ResourceTypesExampleScenario, 
    ResourceTypesExplanationOfBenefit, 
    ResourceTypesFamilyMemberHistory, 
    ResourceTypesFlag, 
    ResourceTypesGoal, 
    ResourceTypesGraphDefinition, 
    ResourceTypesGroup, 
    ResourceTypesGuidanceResponse, 
    ResourceTypesHealthcareService, 
    ResourceTypesImagingStudy, 
    ResourceTypesImmunization, 
    ResourceTypesImmunizationEvaluation, 
    ResourceTypesImmunizationRecommendation, 
    ResourceTypesImplementationGuide, 
    ResourceTypesInsurancePlan, 
    ResourceTypesInvoice, 
    ResourceTypesLibrary, 
    ResourceTypesLinkage, 
    ResourceTypesList, 
    ResourceTypesLocation, 
    ResourceTypesMeasure, 
    ResourceTypesMeasureReport, 
    ResourceTypesMedia, 
    ResourceTypesMedication, 
    ResourceTypesMedicationAdministration, 
    ResourceTypesMedicationDispense, 
    ResourceTypesMedicationKnowledge, 
    ResourceTypesMedicationRequest, 
    ResourceTypesMedicationStatement, 
    ResourceTypesMedicinalProduct, 
    ResourceTypesMedicinalProductAuthorization, 
    ResourceTypesMedicinalProductContraindication, 
    ResourceTypesMedicinalProductIndication, 
    ResourceTypesMedicinalProductIngredient, 
    ResourceTypesMedicinalProductInteraction, 
    ResourceTypesMedicinalProductManufactured, 
    ResourceTypesMedicinalProductPackaged, 
    ResourceTypesMedicinalProductPharmaceutical, 
    ResourceTypesMedicinalProductUndesirableEffect, 
    ResourceTypesMessageDefinition, 
    ResourceTypesMessageHeader, 
    ResourceTypesMolecularSequence, 
    ResourceTypesNamingSystem, 
    ResourceTypesNutritionOrder, 
    ResourceTypesObservation, 
    ResourceTypesObservationDefinition, 
    ResourceTypesOperationDefinition, 
    ResourceTypesOperationOutcome, 
    ResourceTypesOrganization, 
    ResourceTypesOrganizationAffiliation, 
    ResourceTypesParameters, 
    ResourceTypesPatient, 
    ResourceTypesPaymentNotice, 
    ResourceTypesPaymentReconciliation, 
    ResourceTypesPerson, 
    ResourceTypesPlanDefinition, 
    ResourceTypesPractitioner, 
    ResourceTypesPractitionerRole, 
    ResourceTypesProcedure, 
    ResourceTypesProvenance, 
    ResourceTypesQuestionnaire, 
    ResourceTypesQuestionnaireResponse, 
    ResourceTypesRelatedPerson, 
    ResourceTypesRequestGroup, 
    ResourceTypesResearchDefinition, 
    ResourceTypesResearchElementDefinition, 
    ResourceTypesResearchStudy, 
    ResourceTypesResearchSubject, 
    ResourceTypesResource, 
    ResourceTypesRiskAssessment, 
    ResourceTypesRiskEvidenceSynthesis, 
    ResourceTypesSchedule, 
    ResourceTypesSearchParameter, 
    ResourceTypesServiceRequest, 
    ResourceTypesSlot, 
    ResourceTypesSpecimen, 
    ResourceTypesSpecimenDefinition, 
    ResourceTypesStructureDefinition, 
    ResourceTypesStructureMap, 
    ResourceTypesSubscription, 
    ResourceTypesSubstance, 
    ResourceTypesSubstanceNucleicAcid, 
    ResourceTypesSubstancePolymer, 
    ResourceTypesSubstanceProtein, 
    ResourceTypesSubstanceReferenceInformation, 
    ResourceTypesSubstanceSourceMaterial, 
    ResourceTypesSubstanceSpecification, 
    ResourceTypesSupplyDelivery, 
    ResourceTypesSupplyRequest, 
    ResourceTypesTask, 
    ResourceTypesTerminologyCapabilities, 
    ResourceTypesTestReport, 
    ResourceTypesTestScript, 
    ResourceTypesValueSet, 
    ResourceTypesVerificationResult, 
    ResourceTypesVisionPrescription); 
  TFhirResourceTypesEnumList = set of TFhirResourceTypesEnum;

  // Operations supported by REST at the type or instance level. from http://hl7.org/fhir/ValueSet/type-restful-interaction
  TFhirTypeRestfulInteractionEnum = (
    TypeRestfulInteractionNull, // Value is missing from Instance 
    TypeRestfulInteractionRead, 
    TypeRestfulInteractionVread, 
    TypeRestfulInteractionUpdate, 
    TypeRestfulInteractionPatch, 
    TypeRestfulInteractionDelete, 
    TypeRestfulInteractionHistoryInstance, 
    TypeRestfulInteractionHistoryType, 
    TypeRestfulInteractionCreate, 
    TypeRestfulInteractionSearchType); 
  TFhirTypeRestfulInteractionEnumList = set of TFhirTypeRestfulInteractionEnum;

  // How the system supports versioning for a resource. from http://hl7.org/fhir/ValueSet/versioning-policy
  TFhirVersioningPolicyEnum = (
    VersioningPolicyNull, // Value is missing from Instance 
    VersioningPolicyNoVersion, 
    VersioningPolicyVersioned, 
    VersioningPolicyVersionedUpdate); 
  TFhirVersioningPolicyEnumList = set of TFhirVersioningPolicyEnum;

  // A code that indicates how the server supports conditional read. from http://hl7.org/fhir/ValueSet/conditional-read-status
  TFhirConditionalReadStatusEnum = (
    ConditionalReadStatusNull, // Value is missing from Instance 
    ConditionalReadStatusNotSupported, 
    ConditionalReadStatusModifiedSince, 
    ConditionalReadStatusNotMatch, 
    ConditionalReadStatusFullSupport); 
  TFhirConditionalReadStatusEnumList = set of TFhirConditionalReadStatusEnum;

  // A code that indicates how the server supports conditional delete. from http://hl7.org/fhir/ValueSet/conditional-delete-status
  TFhirConditionalDeleteStatusEnum = (
    ConditionalDeleteStatusNull, // Value is missing from Instance 
    ConditionalDeleteStatusNotSupported, 
    ConditionalDeleteStatusSingle, 
    ConditionalDeleteStatusMultiple); 
  TFhirConditionalDeleteStatusEnumList = set of TFhirConditionalDeleteStatusEnum;

  // A set of flags that defines how references are supported. from http://hl7.org/fhir/ValueSet/reference-handling-policy
  TFhirReferenceHandlingPolicyEnum = (
    ReferenceHandlingPolicyNull, // Value is missing from Instance 
    ReferenceHandlingPolicyLiteral, 
    ReferenceHandlingPolicyLogical, 
    ReferenceHandlingPolicyResolves, 
    ReferenceHandlingPolicyEnforced, 
    ReferenceHandlingPolicyLocal); 
  TFhirReferenceHandlingPolicyEnumList = set of TFhirReferenceHandlingPolicyEnum;

  // Data types allowed to be used for search parameters. from http://hl7.org/fhir/ValueSet/search-param-type
  TFhirSearchParamTypeEnum = (
    SearchParamTypeNull, // Value is missing from Instance 
    SearchParamTypeNumber, 
    SearchParamTypeDate, 
    SearchParamTypeString, 
    SearchParamTypeToken, 
    SearchParamTypeReference, 
    SearchParamTypeComposite, 
    SearchParamTypeQuantity, 
    SearchParamTypeUri, 
    SearchParamTypeSpecial); 
  TFhirSearchParamTypeEnumList = set of TFhirSearchParamTypeEnum;

  // Operations supported by REST at the system level. from http://hl7.org/fhir/ValueSet/system-restful-interaction
  TFhirSystemRestfulInteractionEnum = (
    SystemRestfulInteractionNull, // Value is missing from Instance 
    SystemRestfulInteractionTransaction, 
    SystemRestfulInteractionBatch, 
    SystemRestfulInteractionSearchSystem, 
    SystemRestfulInteractionHistorySystem); 
  TFhirSystemRestfulInteractionEnumList = set of TFhirSystemRestfulInteractionEnum;

  // The mode of a message capability statement. from http://hl7.org/fhir/ValueSet/event-capability-mode
  TFhirEventCapabilityModeEnum = (
    EventCapabilityModeNull, // Value is missing from Instance 
    EventCapabilityModeSender, 
    EventCapabilityModeReceiver); 
  TFhirEventCapabilityModeEnumList = set of TFhirEventCapabilityModeEnum;

  // Whether the application produces or consumes documents. from http://hl7.org/fhir/ValueSet/document-mode
  TFhirDocumentModeEnum = (
    DocumentModeNull, // Value is missing from Instance 
    DocumentModeProducer, 
    DocumentModeConsumer); 
  TFhirDocumentModeEnumList = set of TFhirDocumentModeEnum;

  // Indicates whether the plan is currently being acted upon, represents future intentions or is now a historical record. from http://hl7.org/fhir/ValueSet/request-status
  TFhirRequestStatusEnum = (
    RequestStatusNull, // Value is missing from Instance 
    RequestStatusDraft, 
    RequestStatusActive, 
    RequestStatusOnHold, 
    RequestStatusRevoked, 
    RequestStatusCompleted, 
    RequestStatusEnteredInError, 
    RequestStatusUnknown); 
  TFhirRequestStatusEnumList = set of TFhirRequestStatusEnum;

  // Codes indicating the degree of authority/intentionality associated with a care plan. from http://hl7.org/fhir/ValueSet/care-plan-intent
  TFhirCarePlanIntentEnum = (
    CarePlanIntentNull, // Value is missing from Instance 
    CarePlanIntentProposal, 
    CarePlanIntentPlan, 
    CarePlanIntentOrder, 
    CarePlanIntentOption); 
  TFhirCarePlanIntentEnumList = set of TFhirCarePlanIntentEnum;

  // Resource types defined as part of FHIR that can be represented as in-line definitions of a care plan activity. from http://hl7.org/fhir/ValueSet/care-plan-activity-kind
  TFhirCarePlanActivityKindEnum = (
    CarePlanActivityKindNull, // Value is missing from Instance 
    CarePlanActivityKindAppointment, 
    CarePlanActivityKindCommunicationRequest, 
    CarePlanActivityKindDeviceRequest, 
    CarePlanActivityKindMedicationRequest, 
    CarePlanActivityKindNutritionOrder, 
    CarePlanActivityKindTask, 
    CarePlanActivityKindServiceRequest, 
    CarePlanActivityKindVisionPrescription); 
  TFhirCarePlanActivityKindEnumList = set of TFhirCarePlanActivityKindEnum;

  // Codes that reflect the current state of a care plan activity within its overall life cycle. from http://hl7.org/fhir/ValueSet/care-plan-activity-status
  TFhirCarePlanActivityStatusEnum = (
    CarePlanActivityStatusNull, // Value is missing from Instance 
    CarePlanActivityStatusNotStarted, 
    CarePlanActivityStatusScheduled, 
    CarePlanActivityStatusInProgress, 
    CarePlanActivityStatusOnHold, 
    CarePlanActivityStatusCompleted, 
    CarePlanActivityStatusCancelled, 
    CarePlanActivityStatusStopped, 
    CarePlanActivityStatusUnknown, 
    CarePlanActivityStatusEnteredInError); 
  TFhirCarePlanActivityStatusEnumList = set of TFhirCarePlanActivityStatusEnum;

  // Indicates the status of the care team. from http://hl7.org/fhir/ValueSet/care-team-status
  TFhirCareTeamStatusEnum = (
    CareTeamStatusNull, // Value is missing from Instance 
    CareTeamStatusProposed, 
    CareTeamStatusActive, 
    CareTeamStatusSuspended, 
    CareTeamStatusInactive, 
    CareTeamStatusEnteredInError); 
  TFhirCareTeamStatusEnumList = set of TFhirCareTeamStatusEnum;

  // The type of relations between entries. from http://hl7.org/fhir/ValueSet/relation-type
  TFhirRelationTypeEnum = (
    RelationTypeNull, // Value is missing from Instance 
    RelationTypeTriggers, 
    RelationTypeIsReplacedBy); 
  TFhirRelationTypeEnumList = set of TFhirRelationTypeEnum;

  // Codes identifying the lifecycle stage of a ChargeItem. from http://hl7.org/fhir/ValueSet/chargeitem-status
  TFhirChargeitemStatusEnum = (
    ChargeitemStatusNull, // Value is missing from Instance 
    ChargeitemStatusPlanned, 
    ChargeitemStatusBillable, 
    ChargeitemStatusNotBillable, 
    ChargeitemStatusAborted, 
    ChargeitemStatusBilled, 
    ChargeitemStatusEnteredInError, 
    ChargeitemStatusUnknown); 
  TFhirChargeitemStatusEnumList = set of TFhirChargeitemStatusEnum;

  // Codes indicating the kind of the price component. from http://hl7.org/fhir/ValueSet/invoice-priceComponentType
  TFhirInvoicePriceComponentTypeEnum = (
    InvoicePriceComponentTypeNull, // Value is missing from Instance 
    InvoicePriceComponentTypeBase, 
    InvoicePriceComponentTypeSurcharge, 
    InvoicePriceComponentTypeDeduction, 
    InvoicePriceComponentTypeDiscount, 
    InvoicePriceComponentTypeTax, 
    InvoicePriceComponentTypeInformational); 
  TFhirInvoicePriceComponentTypeEnumList = set of TFhirInvoicePriceComponentTypeEnum;

  // A code specifying the state of the resource instance. from http://hl7.org/fhir/ValueSet/fm-status
  TFhirFmStatusEnum = (
    FmStatusNull, // Value is missing from Instance 
    FmStatusActive, 
    FmStatusCancelled, 
    FmStatusDraft, 
    FmStatusEnteredInError); 
  TFhirFmStatusEnumList = set of TFhirFmStatusEnum;

  // The purpose of the Claim: predetermination, preauthorization, claim. from http://hl7.org/fhir/ValueSet/claim-use
  TFhirClaimUseEnum = (
    ClaimUseNull, // Value is missing from Instance 
    ClaimUseClaim, 
    ClaimUsePreauthorization, 
    ClaimUsePredetermination); 
  TFhirClaimUseEnumList = set of TFhirClaimUseEnum;

  // The result of the claim processing. from http://hl7.org/fhir/ValueSet/remittance-outcome
  TFhirRemittanceOutcomeEnum = (
    RemittanceOutcomeNull, // Value is missing from Instance 
    RemittanceOutcomeQueued, 
    RemittanceOutcomeComplete, 
    RemittanceOutcomeError, 
    RemittanceOutcomePartial); 
  TFhirRemittanceOutcomeEnumList = set of TFhirRemittanceOutcomeEnum;

  // The presentation types of notes. from http://hl7.org/fhir/ValueSet/note-type
  TFhirNoteTypeEnum = (
    NoteTypeNull, // Value is missing from Instance 
    NoteTypeDisplay, 
    NoteTypePrint, 
    NoteTypePrintoper); 
  TFhirNoteTypeEnumList = set of TFhirNoteTypeEnum;

  // The workflow state of a clinical impression. from http://hl7.org/fhir/ValueSet/clinicalimpression-status
  TFhirClinicalimpressionStatusEnum = (
    ClinicalimpressionStatusNull, // Value is missing from Instance 
    ClinicalimpressionStatusInProgress, 
    ClinicalimpressionStatusCompleted, 
    ClinicalimpressionStatusEnteredInError); 
  TFhirClinicalimpressionStatusEnumList = set of TFhirClinicalimpressionStatusEnum;

  // The meaning of the hierarchy of concepts in a code system. from http://hl7.org/fhir/ValueSet/codesystem-hierarchy-meaning
  TFhirCodesystemHierarchyMeaningEnum = (
    CodesystemHierarchyMeaningNull, // Value is missing from Instance 
    CodesystemHierarchyMeaningGroupedBy, 
    CodesystemHierarchyMeaningIsA, 
    CodesystemHierarchyMeaningPartOf, 
    CodesystemHierarchyMeaningClassifiedWith); 
  TFhirCodesystemHierarchyMeaningEnumList = set of TFhirCodesystemHierarchyMeaningEnum;

  // The extent of the content of the code system (the concepts and codes it defines) are represented in a code system resource. from http://hl7.org/fhir/ValueSet/codesystem-content-mode
  TFhirCodesystemContentModeEnum = (
    CodesystemContentModeNull, // Value is missing from Instance 
    CodesystemContentModeNotPresent, 
    CodesystemContentModeExample, 
    CodesystemContentModeFragment, 
    CodesystemContentModeComplete, 
    CodesystemContentModeSupplement); 
  TFhirCodesystemContentModeEnumList = set of TFhirCodesystemContentModeEnum;

  // The kind of operation to perform as a part of a property based filter. from http://hl7.org/fhir/ValueSet/filter-operator
  TFhirFilterOperatorEnum = (
    FilterOperatorNull, // Value is missing from Instance 
    FilterOperatorEqual, 
    FilterOperatorIsA, 
    FilterOperatorDescendentOf, 
    FilterOperatorIsNotA, 
    FilterOperatorRegex, 
    FilterOperatorIn, 
    FilterOperatorNotIn, 
    FilterOperatorGeneralizes, 
    FilterOperatorExists); 
  TFhirFilterOperatorEnumList = set of TFhirFilterOperatorEnum;

  // The type of a propertTFhirResourceTypeEnumy value. from http://hl7.org/fhir/ValueSet/concept-property-type
  TFhirConceptPropertyTypeEnum = (
    ConceptPropertyTypeNull, // Value is missing from Instance 
    ConceptPropertyTypeCode, 
    ConceptPropertyTypeCoding, 
    ConceptPropertyTypeString, 
    ConceptPropertyTypeInteger, 
    ConceptPropertyTypeBoolean, 
    ConceptPropertyTypeDateTime, 
    ConceptPropertyTypeDecimal); 
  TFhirConceptPropertyTypeEnumList = set of TFhirConceptPropertyTypeEnum;

  // The status of the communication. from http://hl7.org/fhir/ValueSet/event-status
  TFhirEventStatusEnum = (
    EventStatusNull, // Value is missing from Instance 
    EventStatusPreparation, 
    EventStatusInProgress, 
    EventStatusNotDone, 
    EventStatusOnHold, 
    EventStatusStopped, 
    EventStatusCompleted, 
    EventStatusEnteredInError, 
    EventStatusUnknown); 
  TFhirEventStatusEnumList = set of TFhirEventStatusEnum;

  // Which type a compartment definition describes. from http://hl7.org/fhir/ValueSet/compartment-type
  TFhirCompartmentTypeEnum = (
    CompartmentTypeNull, // Value is missing from Instance 
    CompartmentTypePatient, 
    CompartmentTypeEncounter, 
    CompartmentTypeRelatedPerson, 
    CompartmentTypePractitioner, 
    CompartmentTypeDevice); 
  TFhirCompartmentTypeEnumList = set of TFhirCompartmentTypeEnum;

  // The workflow/clinical status of the composition. from http://hl7.org/fhir/ValueSet/composition-status
  TFhirCompositionStatusEnum = (
    CompositionStatusNull, // Value is missing from Instance 
    CompositionStatusPreliminary, 
    CompositionStatusFinal, 
    CompositionStatusAmended, 
    CompositionStatusEnteredInError); 
  TFhirCompositionStatusEnumList = set of TFhirCompositionStatusEnum;

  // Codes specifying the level of confidentiality of the composition. from http://terminology.hl7.org/ValueSet/v3-ConfidentialityClassification
  TFhirV3ConfidentialityClassificationEnum = (
    V3ConfidentialityClassificationNull, // Value is missing from Instance 
    V3ConfidentialityClassificationU, 
    V3ConfidentialityClassificationL, 
    V3ConfidentialityClassificationM, 
    V3ConfidentialityClassificationN, 
    V3ConfidentialityClassificationR, 
    V3ConfidentialityClassificationV); 
  TFhirV3ConfidentialityClassificationEnumList = set of TFhirV3ConfidentialityClassificationEnum;

  // The way in which a person authenticated a composition. from http://hl7.org/fhir/ValueSet/composition-attestation-mode
  TFhirCompositionAttestationModeEnum = (
    CompositionAttestationModeNull, // Value is missing from Instance 
    CompositionAttestationModePersonal, 
    CompositionAttestationModeProfessional, 
    CompositionAttestationModeLegal, 
    CompositionAttestationModeOfficial); 
  TFhirCompositionAttestationModeEnumList = set of TFhirCompositionAttestationModeEnum;

  // The type of relationship between documents. from http://hl7.org/fhir/ValueSet/document-relationship-type
  TFhirDocumentRelationshipTypeEnum = (
    DocumentRelationshipTypeNull, // Value is missing from Instance 
    DocumentRelationshipTypeReplaces, 
    DocumentRelationshipTypeTransforms, 
    DocumentRelationshipTypeSigns, 
    DocumentRelationshipTypeAppends); 
  TFhirDocumentRelationshipTypeEnumList = set of TFhirDocumentRelationshipTypeEnum;

  // The processing mode that applies to this section. from http://hl7.org/fhir/ValueSet/list-mode
  TFhirListModeEnum = (
    ListModeNull, // Value is missing from Instance 
    ListModeWorking, 
    ListModeSnapshot, 
    ListModeChanges); 
  TFhirListModeEnumList = set of TFhirListModeEnum;

  // The degree of equivalence between concepts. from http://hl7.org/fhir/ValueSet/concept-map-equivalence
  TFhirConceptMapEquivalenceEnum = (
    ConceptMapEquivalenceNull, // Value is missing from Instance 
    ConceptMapEquivalenceRelatedto, 
    ConceptMapEquivalenceEquivalent, 
    ConceptMapEquivalenceEqual, 
    ConceptMapEquivalenceWider, 
    ConceptMapEquivalenceSubsumes, 
    ConceptMapEquivalenceNarrower, 
    ConceptMapEquivalenceSpecializes, 
    ConceptMapEquivalenceInexact, 
    ConceptMapEquivalenceUnmatched, 
    ConceptMapEquivalenceDisjoint); 
  TFhirConceptMapEquivalenceEnumList = set of TFhirConceptMapEquivalenceEnum;

  // Defines which action to take if there is no match in the group. from http://hl7.org/fhir/ValueSet/conceptmap-unmapped-mode
  TFhirConceptmapUnmappedModeEnum = (
    ConceptmapUnmappedModeNull, // Value is missing from Instance 
    ConceptmapUnmappedModeProvided, 
    ConceptmapUnmappedModeFixed, 
    ConceptmapUnmappedModeOtherMap); 
  TFhirConceptmapUnmappedModeEnumList = set of TFhirConceptmapUnmappedModeEnum;

  // Indicates the state of the consent. from http://hl7.org/fhir/ValueSet/consent-state-codes
  TFhirConsentStateCodesEnum = (
    ConsentStateCodesNull, // Value is missing from Instance 
    ConsentStateCodesDraft, 
    ConsentStateCodesProposed, 
    ConsentStateCodesActive, 
    ConsentStateCodesRejected, 
    ConsentStateCodesInactive, 
    ConsentStateCodesEnteredInError); 
  TFhirConsentStateCodesEnumList = set of TFhirConsentStateCodesEnum;

  // How a rule statement is applied, such as adding additional consent or removing consent. from http://hl7.org/fhir/ValueSet/consent-provision-type
  TFhirConsentProvisionTypeEnum = (
    ConsentProvisionTypeNull, // Value is missing from Instance 
    ConsentProvisionTypeDeny, 
    ConsentProvisionTypePermit); 
  TFhirConsentProvisionTypeEnumList = set of TFhirConsentProvisionTypeEnum;

  // How a resource reference is interpreted when testing consent restrictions. from http://hl7.org/fhir/ValueSet/consent-data-meaning
  TFhirConsentDataMeaningEnum = (
    ConsentDataMeaningNull, // Value is missing from Instance 
    ConsentDataMeaningInstance, 
    ConsentDataMeaningRelated, 
    ConsentDataMeaningDependents, 
    ConsentDataMeaningAuthoredby); 
  TFhirConsentDataMeaningEnumList = set of TFhirConsentDataMeaningEnum;

  // A code specifying the state of the resource instance. from http://hl7.org/fhir/ValueSet/contract-status
  TFhirContractStatusEnum = (
    ContractStatusNull, // Value is missing from Instance 
    ContractStatusAmended, 
    ContractStatusAppended, 
    ContractStatusCancelled, 
    ContractStatusDisputed, 
    ContractStatusEnteredInError, 
    ContractStatusExecutable, 
    ContractStatusExecuted, 
    ContractStatusNegotiable, 
    ContractStatusOffered, 
    ContractStatusPolicy, 
    ContractStatusRejected, 
    ContractStatusRenewed, 
    ContractStatusRevoked, 
    ContractStatusResolved, 
    ContractStatusTerminated); 
  TFhirContractStatusEnumList = set of TFhirContractStatusEnum;

  // Status of the publication of contract content. from http://hl7.org/fhir/ValueSet/contract-publicationstatus
  TFhirContractPublicationstatusEnum = (
    ContractPublicationstatusNull, // Value is missing from Instance 
    ContractPublicationstatusAmended, 
    ContractPublicationstatusAppended, 
    ContractPublicationstatusCancelled, 
    ContractPublicationstatusDisputed, 
    ContractPublicationstatusEnteredInError, 
    ContractPublicationstatusExecutable, 
    ContractPublicationstatusExecuted, 
    ContractPublicationstatusNegotiable, 
    ContractPublicationstatusOffered, 
    ContractPublicationstatusPolicy, 
    ContractPublicationstatusRejected, 
    ContractPublicationstatusRenewed, 
    ContractPublicationstatusRevoked, 
    ContractPublicationstatusResolved, 
    ContractPublicationstatusTerminated); 
  TFhirContractPublicationstatusEnumList = set of TFhirContractPublicationstatusEnum;

  // A code specifying the types of information being requested. from http://hl7.org/fhir/ValueSet/eligibilityrequest-purpose
  TFhirEligibilityrequestPurposeEnum = (
    EligibilityrequestPurposeNull, // Value is missing from Instance 
    EligibilityrequestPurposeAuthRequirements, 
    EligibilityrequestPurposeBenefits, 
    EligibilityrequestPurposeDiscovery, 
    EligibilityrequestPurposeValidation); 
  TFhirEligibilityrequestPurposeEnumList = set of TFhirEligibilityrequestPurposeEnum;

  // A code specifying the types of information being requested. from http://hl7.org/fhir/ValueSet/eligibilityresponse-purpose
  TFhirEligibilityresponsePurposeEnum = (
    EligibilityresponsePurposeNull, // Value is missing from Instance 
    EligibilityresponsePurposeAuthRequirements, 
    EligibilityresponsePurposeBenefits, 
    EligibilityresponsePurposeDiscovery, 
    EligibilityresponsePurposeValidation); 
  TFhirEligibilityresponsePurposeEnumList = set of TFhirEligibilityresponsePurposeEnum;

  // Indicates the status of the identified issue. from http://hl7.org/fhir/ValueSet/observation-status
  TFhirObservationStatusEnum = (
    ObservationStatusNull, // Value is missing from Instance 
    ObservationStatusRegistered, 
    ObservationStatusPreliminary, 
    ObservationStatusFinal, 
    ObservationStatusAmended, 
    ObservationStatusCorrected, 
    ObservationStatusCancelled, 
    ObservationStatusEnteredInError, 
    ObservationStatusUnknown); 
  TFhirObservationStatusEnumList = set of TFhirObservationStatusEnum;

  // Indicates the potential degree of impact of the identified issue on the patient. from http://hl7.org/fhir/ValueSet/detectedissue-severity
  TFhirDetectedissueSeverityEnum = (
    DetectedissueSeverityNull, // Value is missing from Instance 
    DetectedissueSeverityHigh, 
    DetectedissueSeverityModerate, 
    DetectedissueSeverityLow); 
  TFhirDetectedissueSeverityEnumList = set of TFhirDetectedissueSeverityEnum;

  // Codes to identify how UDI data was entered. from http://hl7.org/fhir/ValueSet/udi-entry-type
  TFhirUdiEntryTypeEnum = (
    UdiEntryTypeNull, // Value is missing from Instance 
    UdiEntryTypeBarcode, 
    UdiEntryTypeRfid, 
    UdiEntryTypeManual, 
    UdiEntryTypeCard, 
    UdiEntryTypeSelfReported, 
    UdiEntryTypeUnknown); 
  TFhirUdiEntryTypeEnumList = set of TFhirUdiEntryTypeEnum;

  // The availability status of the device. from http://hl7.org/fhir/ValueSet/device-status
  TFhirDeviceStatusEnum = (
    DeviceStatusNull, // Value is missing from Instance 
    DeviceStatusActive, 
    DeviceStatusInactive, 
    DeviceStatusEnteredInError, 
    DeviceStatusUnknown); 
  TFhirDeviceStatusEnumList = set of TFhirDeviceStatusEnum;

  // The type of name the device is referred by. from http://hl7.org/fhir/ValueSet/device-nametype
  TFhirDeviceNametypeEnum = (
    DeviceNametypeNull, // Value is missing from Instance 
    DeviceNametypeUdiLabelName, 
    DeviceNametypeUserFriendlyName, 
    DeviceNametypePatientReportedName, 
    DeviceNametypeManufacturerName, 
    DeviceNametypeModelName, 
    DeviceNametypeOther); 
  TFhirDeviceNametypeEnumList = set of TFhirDeviceNametypeEnum;

  // Describes the operational status of the DeviceMetric. from http://hl7.org/fhir/ValueSet/metric-operational-status
  TFhirMetricOperationalStatusEnum = (
    MetricOperationalStatusNull, // Value is missing from Instance 
    MetricOperationalStatusOn, 
    MetricOperationalStatusOff, 
    MetricOperationalStatusStandby, 
    MetricOperationalStatusEnteredInError); 
  TFhirMetricOperationalStatusEnumList = set of TFhirMetricOperationalStatusEnum;

  // Describes the typical color of representation. from http://hl7.org/fhir/ValueSet/metric-color
  TFhirMetricColorEnum = (
    MetricColorNull, // Value is missing from Instance 
    MetricColorBlack, 
    MetricColorRed, 
    MetricColorGreen, 
    MetricColorYellow, 
    MetricColorBlue, 
    MetricColorMagenta, 
    MetricColorCyan, 
    MetricColorWhite); 
  TFhirMetricColorEnumList = set of TFhirMetricColorEnum;

  // Describes the category of the metric. from http://hl7.org/fhir/ValueSet/metric-category
  TFhirMetricCategoryEnum = (
    MetricCategoryNull, // Value is missing from Instance 
    MetricCategoryMeasurement, 
    MetricCategorySetting, 
    MetricCategoryCalculation, 
    MetricCategoryUnspecified); 
  TFhirMetricCategoryEnumList = set of TFhirMetricCategoryEnum;

  // Describes the type of a metric calibration. from http://hl7.org/fhir/ValueSet/metric-calibration-type
  TFhirMetricCalibrationTypeEnum = (
    MetricCalibrationTypeNull, // Value is missing from Instance 
    MetricCalibrationTypeUnspecified, 
    MetricCalibrationTypeOffset, 
    MetricCalibrationTypeGain, 
    MetricCalibrationTypeTwoPoint); 
  TFhirMetricCalibrationTypeEnumList = set of TFhirMetricCalibrationTypeEnum;

  // Describes the state of a metric calibration. from http://hl7.org/fhir/ValueSet/metric-calibration-state
  TFhirMetricCalibrationStateEnum = (
    MetricCalibrationStateNull, // Value is missing from Instance 
    MetricCalibrationStateNotCalibrated, 
    MetricCalibrationStateCalibrationRequired, 
    MetricCalibrationStateCalibrated, 
    MetricCalibrationStateUnspecified); 
  TFhirMetricCalibrationStateEnumList = set of TFhirMetricCalibrationStateEnum;

  // A coded concept indicating the current status of the Device Usage. from http://hl7.org/fhir/ValueSet/device-statement-status
  TFhirDeviceStatementStatusEnum = (
    DeviceStatementStatusNull, // Value is missing from Instance 
    DeviceStatementStatusActive, 
    DeviceStatementStatusCompleted, 
    DeviceStatementStatusEnteredInError, 
    DeviceStatementStatusIntended, 
    DeviceStatementStatusStopped, 
    DeviceStatementStatusOnHold); 
  TFhirDeviceStatementStatusEnumList = set of TFhirDeviceStatementStatusEnum;

  // The status of the diagnostic report. from http://hl7.org/fhir/ValueSet/diagnostic-report-status
  TFhirDiagnosticReportStatusEnum = (
    DiagnosticReportStatusNull, // Value is missing from Instance 
    DiagnosticReportStatusRegistered, 
    DiagnosticReportStatusPartial, 
    DiagnosticReportStatusPreliminary, 
    DiagnosticReportStatusFinal, 
    DiagnosticReportStatusAmended, 
    DiagnosticReportStatusCorrected, 
    DiagnosticReportStatusAppended, 
    DiagnosticReportStatusCancelled, 
    DiagnosticReportStatusEnteredInError, 
    DiagnosticReportStatusUnknown); 
  TFhirDiagnosticReportStatusEnumList = set of TFhirDiagnosticReportStatusEnum;

  // The status of the document reference. from http://hl7.org/fhir/ValueSet/document-reference-status
  TFhirDocumentReferenceStatusEnum = (
    DocumentReferenceStatusNull, // Value is missing from Instance 
    DocumentReferenceStatusCurrent, 
    DocumentReferenceStatusSuperseded, 
    DocumentReferenceStatusEnteredInError); 
  TFhirDocumentReferenceStatusEnumList = set of TFhirDocumentReferenceStatusEnum;

  // Whether the results by exposure is describing the results for the primary exposure of interest (exposure) or the alternative state (exposureAlternative). from http://hl7.org/fhir/ValueSet/exposure-state
  TFhirExposureStateEnum = (
    ExposureStateNull, // Value is missing from Instance 
    ExposureStateExposure, 
    ExposureStateExposureAlternative); 
  TFhirExposureStateEnumList = set of TFhirExposureStateEnum;

  // Current state of the encounter. from http://hl7.org/fhir/ValueSet/encounter-status
  TFhirEncounterStatusEnum = (
    EncounterStatusNull, // Value is missing from Instance 
    EncounterStatusPlanned, 
    EncounterStatusArrived, 
    EncounterStatusTriaged, 
    EncounterStatusInProgress, 
    EncounterStatusOnleave, 
    EncounterStatusFinished, 
    EncounterStatusCancelled, 
    EncounterStatusEnteredInError, 
    EncounterStatusUnknown); 
  TFhirEncounterStatusEnumList = set of TFhirEncounterStatusEnum;

  // The status of the location. from http://hl7.org/fhir/ValueSet/encounter-location-status
  TFhirEncounterLocationStatusEnum = (
    EncounterLocationStatusNull, // Value is missing from Instance 
    EncounterLocationStatusPlanned, 
    EncounterLocationStatusActive, 
    EncounterLocationStatusReserved, 
    EncounterLocationStatusCompleted); 
  TFhirEncounterLocationStatusEnumList = set of TFhirEncounterLocationStatusEnum;

  // The status of the endpoint. from http://hl7.org/fhir/ValueSet/endpoint-status
  TFhirEndpointStatusEnum = (
    EndpointStatusNull, // Value is missing from Instance 
    EndpointStatusActive, 
    EndpointStatusSuspended, 
    EndpointStatusError, 
    EndpointStatusOff, 
    EndpointStatusEnteredInError, 
    EndpointStatusTest); 
  TFhirEndpointStatusEnumList = set of TFhirEndpointStatusEnum;

  // The status of the episode of care. from http://hl7.org/fhir/ValueSet/episode-of-care-status
  TFhirEpisodeOfCareStatusEnum = (
    EpisodeOfCareStatusNull, // Value is missing from Instance 
    EpisodeOfCareStatusPlanned, 
    EpisodeOfCareStatusWaitlist, 
    EpisodeOfCareStatusActive, 
    EpisodeOfCareStatusOnhold, 
    EpisodeOfCareStatusFinished, 
    EpisodeOfCareStatusCancelled, 
    EpisodeOfCareStatusEnteredInError); 
  TFhirEpisodeOfCareStatusEnumList = set of TFhirEpisodeOfCareStatusEnum;

  // The possible types of variables for exposures or outcomes (E.g. Dichotomous, Continuous, Descriptive). from http://hl7.org/fhir/ValueSet/variable-type
  TFhirVariableTypeEnum = (
    VariableTypeNull, // Value is missing from Instance 
    VariableTypeDichotomous, 
    VariableTypeContinuous, 
    VariableTypeDescriptive); 
  TFhirVariableTypeEnumList = set of TFhirVariableTypeEnum;

  // Possible group measure aggregates (E.g. Mean, Median). from http://hl7.org/fhir/ValueSet/group-measure
  TFhirGroupMeasureEnum = (
    GroupMeasureNull, // Value is missing from Instance 
    GroupMeasureMean, 
    GroupMeasureMedian, 
    GroupMeasureMeanOfMean, 
    GroupMeasureMeanOfMedian, 
    GroupMeasureMedianOfMean, 
    GroupMeasureMedianOfMedian); 
  TFhirGroupMeasureEnumList = set of TFhirGroupMeasureEnum;

  // The type of actor - system or human. from http://hl7.org/fhir/ValueSet/examplescenario-actor-type
  TFhirExamplescenarioActorTypeEnum = (
    ExamplescenarioActorTypeNull, // Value is missing from Instance 
    ExamplescenarioActorTypePerson, 
    ExamplescenarioActorTypeEntity); 
  TFhirExamplescenarioActorTypeEnumList = set of TFhirExamplescenarioActorTypeEnum;

  // A code specifying the state of the resource instance. from http://hl7.org/fhir/ValueSet/explanationofbenefit-status
  TFhirExplanationofbenefitStatusEnum = (
    ExplanationofbenefitStatusNull, // Value is missing from Instance 
    ExplanationofbenefitStatusActive, 
    ExplanationofbenefitStatusCancelled, 
    ExplanationofbenefitStatusDraft, 
    ExplanationofbenefitStatusEnteredInError); 
  TFhirExplanationofbenefitStatusEnumList = set of TFhirExplanationofbenefitStatusEnum;

  // A code that identifies the status of the family history record. from http://hl7.org/fhir/ValueSet/history-status
  TFhirHistoryStatusEnum = (
    HistoryStatusNull, // Value is missing from Instance 
    HistoryStatusPartial, 
    HistoryStatusCompleted, 
    HistoryStatusEnteredInError, 
    HistoryStatusHealthUnknown); 
  TFhirHistoryStatusEnumList = set of TFhirHistoryStatusEnum;

  // Indicates whether this flag is active and needs to be displayed to a user, or whether it is no longer needed or was entered in error. from http://hl7.org/fhir/ValueSet/flag-status
  TFhirFlagStatusEnum = (
    FlagStatusNull, // Value is missing from Instance 
    FlagStatusActive, 
    FlagStatusInactive, 
    FlagStatusEnteredInError); 
  TFhirFlagStatusEnumList = set of TFhirFlagStatusEnum;

  // Codes that reflect the current state of a goal and whether the goal is still being targeted. from http://hl7.org/fhir/ValueSet/goal-status
  TFhirGoalStatusEnum = (
    GoalStatusNull, // Value is missing from Instance 
    GoalStatusProposed, 
    GoalStatusPlanned, 
    GoalStatusAccepted, 
    GoalStatusActive, 
    GoalStatusOnHold, 
    GoalStatusCompleted, 
    GoalStatusCancelled, 
    GoalStatusEnteredInError, 
    GoalStatusRejected); 
  TFhirGoalStatusEnumList = set of TFhirGoalStatusEnum;

  // Defines how a compartment rule is used. from http://hl7.org/fhir/ValueSet/graph-compartment-use
  TFhirGraphCompartmentUseEnum = (
    GraphCompartmentUseNull, // Value is missing from Instance 
    GraphCompartmentUseCondition, 
    GraphCompartmentUseRequirement); 
  TFhirGraphCompartmentUseEnumList = set of TFhirGraphCompartmentUseEnum;

  // How a compartment must be linked. from http://hl7.org/fhir/ValueSet/graph-compartment-rule
  TFhirGraphCompartmentRuleEnum = (
    GraphCompartmentRuleNull, // Value is missing from Instance 
    GraphCompartmentRuleIdentical, 
    GraphCompartmentRuleMatching, 
    GraphCompartmentRuleDifferent, 
    GraphCompartmentRuleCustom); 
  TFhirGraphCompartmentRuleEnumList = set of TFhirGraphCompartmentRuleEnum;

  // Types of resources that are part of group. from http://hl7.org/fhir/ValueSet/group-type
  TFhirGroupTypeEnum = (
    GroupTypeNull, // Value is missing from Instance 
    GroupTypePerson, 
    GroupTypeAnimal, 
    GroupTypePractitioner, 
    GroupTypeDevice, 
    GroupTypeMedication, 
    GroupTypeSubstance); 
  TFhirGroupTypeEnumList = set of TFhirGroupTypeEnum;

  // The status of a guidance response. from http://hl7.org/fhir/ValueSet/guidance-response-status
  TFhirGuidanceResponseStatusEnum = (
    GuidanceResponseStatusNull, // Value is missing from Instance 
    GuidanceResponseStatusSuccess, 
    GuidanceResponseStatusDataRequested, 
    GuidanceResponseStatusDataRequired, 
    GuidanceResponseStatusInProgress, 
    GuidanceResponseStatusFailure, 
    GuidanceResponseStatusEnteredInError); 
  TFhirGuidanceResponseStatusEnumList = set of TFhirGuidanceResponseStatusEnum;

  // The status of the ImagingStudy. from http://hl7.org/fhir/ValueSet/imagingstudy-status
  TFhirImagingstudyStatusEnum = (
    ImagingstudyStatusNull, // Value is missing from Instance 
    ImagingstudyStatusRegistered, 
    ImagingstudyStatusAvailable, 
    ImagingstudyStatusCancelled, 
    ImagingstudyStatusEnteredInError, 
    ImagingstudyStatusUnknown); 
  TFhirImagingstudyStatusEnumList = set of TFhirImagingstudyStatusEnum;

  // A set of codes indicating the current status of an Immunization. from http://hl7.org/fhir/ValueSet/immunization-status
  TFhirImmunizationStatusEnum = (
    ImmunizationStatusNull, // Value is missing from Instance 
    ImmunizationStatusCompleted, 
    ImmunizationStatusEnteredInError, 
    ImmunizationStatusNotDone); 
  TFhirImmunizationStatusEnumList = set of TFhirImmunizationStatusEnum;

  // The status of the evaluation being done. from http://hl7.org/fhir/ValueSet/immunization-evaluation-status
  TFhirImmunizationEvaluationStatusEnum = (
    ImmunizationEvaluationStatusNull, // Value is missing from Instance 
    ImmunizationEvaluationStatusCompleted, 
    ImmunizationEvaluationStatusEnteredInError); 
  TFhirImmunizationEvaluationStatusEnumList = set of TFhirImmunizationEvaluationStatusEnum;

  // The license that applies to an Implementation Guide (using an SPDX license Identifiers, or 'not-open-source'). The binding is required but new SPDX license Identifiers are allowed to be used (https://spdx.org/licenses/). from http://hl7.org/fhir/ValueSet/spdx-license
  TFhirSpdxLicenseEnum = (
    SpdxLicenseNull, // Value is missing from Instance 
    SpdxLicenseNotOpenSource, 
    SpdxLicense0BSD, 
    SpdxLicenseAAL, 
    SpdxLicenseAbstyles, 
    SpdxLicenseAdobe2006, 
    SpdxLicenseAdobeGlyph, 
    SpdxLicenseADSL, 
    SpdxLicenseAFL11, 
    SpdxLicenseAFL12, 
    SpdxLicenseAFL20, 
    SpdxLicenseAFL21, 
    SpdxLicenseAFL30, 
    SpdxLicenseAfmparse, 
    SpdxLicenseAGPL10Only, 
    SpdxLicenseAGPL10OrLater, 
    SpdxLicenseAGPL30Only, 
    SpdxLicenseAGPL30OrLater, 
    SpdxLicenseAladdin, 
    SpdxLicenseAMDPLPA, 
    SpdxLicenseAML, 
    SpdxLicenseAMPAS, 
    SpdxLicenseANTLRPD, 
    SpdxLicenseApache10, 
    SpdxLicenseApache11, 
    SpdxLicenseApache20, 
    SpdxLicenseAPAFML, 
    SpdxLicenseAPL10, 
    SpdxLicenseAPSL10, 
    SpdxLicenseAPSL11, 
    SpdxLicenseAPSL12, 
    SpdxLicenseAPSL20, 
    SpdxLicenseArtistic10Cl8, 
    SpdxLicenseArtistic10Perl, 
    SpdxLicenseArtistic10, 
    SpdxLicenseArtistic20, 
    SpdxLicenseBahyph, 
    SpdxLicenseBarr, 
    SpdxLicenseBeerware, 
    SpdxLicenseBitTorrent10, 
    SpdxLicenseBitTorrent11, 
    SpdxLicenseBorceux, 
    SpdxLicenseBSD1Clause, 
    SpdxLicenseBSD2ClauseFreeBSD, 
    SpdxLicenseBSD2ClauseNetBSD, 
    SpdxLicenseBSD2ClausePatent, 
    SpdxLicenseBSD2Clause, 
    SpdxLicenseBSD3ClauseAttribution, 
    SpdxLicenseBSD3ClauseClear, 
    SpdxLicenseBSD3ClauseLBNL, 
    SpdxLicenseBSD3ClauseNoNuclearLicense2014, 
    SpdxLicenseBSD3ClauseNoNuclearLicense, 
    SpdxLicenseBSD3ClauseNoNuclearWarranty, 
    SpdxLicenseBSD3Clause, 
    SpdxLicenseBSD4ClauseUC, 
    SpdxLicenseBSD4Clause, 
    SpdxLicenseBSDProtection, 
    SpdxLicenseBSDSourceCode, 
    SpdxLicenseBSL10, 
    SpdxLicenseBzip2105, 
    SpdxLicenseBzip2106, 
    SpdxLicenseCaldera, 
    SpdxLicenseCATOSL11, 
    SpdxLicenseCCBY10, 
    SpdxLicenseCCBY20, 
    SpdxLicenseCCBY25, 
    SpdxLicenseCCBY30, 
    SpdxLicenseCCBY40, 
    SpdxLicenseCCBYNC10, 
    SpdxLicenseCCBYNC20, 
    SpdxLicenseCCBYNC25, 
    SpdxLicenseCCBYNC30, 
    SpdxLicenseCCBYNC40, 
    SpdxLicenseCCBYNCND10, 
    SpdxLicenseCCBYNCND20, 
    SpdxLicenseCCBYNCND25, 
    SpdxLicenseCCBYNCND30, 
    SpdxLicenseCCBYNCND40, 
    SpdxLicenseCCBYNCSA10, 
    SpdxLicenseCCBYNCSA20, 
    SpdxLicenseCCBYNCSA25, 
    SpdxLicenseCCBYNCSA30, 
    SpdxLicenseCCBYNCSA40, 
    SpdxLicenseCCBYND10, 
    SpdxLicenseCCBYND20, 
    SpdxLicenseCCBYND25, 
    SpdxLicenseCCBYND30, 
    SpdxLicenseCCBYND40, 
    SpdxLicenseCCBYSA10, 
    SpdxLicenseCCBYSA20, 
    SpdxLicenseCCBYSA25, 
    SpdxLicenseCCBYSA30, 
    SpdxLicenseCCBYSA40, 
    SpdxLicenseCC010, 
    SpdxLicenseCDDL10, 
    SpdxLicenseCDDL11, 
    SpdxLicenseCDLAPermissive10, 
    SpdxLicenseCDLASharing10, 
    SpdxLicenseCECILL10, 
    SpdxLicenseCECILL11, 
    SpdxLicenseCECILL20, 
    SpdxLicenseCECILL21, 
    SpdxLicenseCECILLB, 
    SpdxLicenseCECILLC, 
    SpdxLicenseClArtistic, 
    SpdxLicenseCNRIJython, 
    SpdxLicenseCNRIPythonGPLCompatible, 
    SpdxLicenseCNRIPython, 
    SpdxLicenseCondor11, 
    SpdxLicenseCPAL10, 
    SpdxLicenseCPL10, 
    SpdxLicenseCPOL102, 
    SpdxLicenseCrossword, 
    SpdxLicenseCrystalStacker, 
    SpdxLicenseCUAOPL10, 
    SpdxLicenseCube, 
    SpdxLicenseCurl, 
    SpdxLicenseDFSL10, 
    SpdxLicenseDiffmark, 
    SpdxLicenseDOC, 
    SpdxLicenseDotseqn, 
    SpdxLicenseDSDP, 
    SpdxLicenseDvipdfm, 
    SpdxLicenseECL10, 
    SpdxLicenseECL20, 
    SpdxLicenseEFL10, 
    SpdxLicenseEFL20, 
    SpdxLicenseEGenix, 
    SpdxLicenseEntessa, 
    SpdxLicenseEPL10, 
    SpdxLicenseEPL20, 
    SpdxLicenseErlPL11, 
    SpdxLicenseEUDatagrid, 
    SpdxLicenseEUPL10, 
    SpdxLicenseEUPL11, 
    SpdxLicenseEUPL12, 
    SpdxLicenseEurosym, 
    SpdxLicenseFair, 
    SpdxLicenseFrameworx10, 
    SpdxLicenseFreeImage, 
    SpdxLicenseFSFAP, 
    SpdxLicenseFSFUL, 
    SpdxLicenseFSFULLR, 
    SpdxLicenseFTL, 
    SpdxLicenseGFDL11Only, 
    SpdxLicenseGFDL11OrLater, 
    SpdxLicenseGFDL12Only, 
    SpdxLicenseGFDL12OrLater, 
    SpdxLicenseGFDL13Only, 
    SpdxLicenseGFDL13OrLater, 
    SpdxLicenseGiftware, 
    SpdxLicenseGL2PS, 
    SpdxLicenseGlide, 
    SpdxLicenseGlulxe, 
    SpdxLicenseGnuplot, 
    SpdxLicenseGPL10Only, 
    SpdxLicenseGPL10OrLater, 
    SpdxLicenseGPL20Only, 
    SpdxLicenseGPL20OrLater, 
    SpdxLicenseGPL30Only, 
    SpdxLicenseGPL30OrLater, 
    SpdxLicenseGSOAP13b, 
    SpdxLicenseHaskellReport, 
    SpdxLicenseHPND, 
    SpdxLicenseIBMPibs, 
    SpdxLicenseICU, 
    SpdxLicenseIJG, 
    SpdxLicenseImageMagick, 
    SpdxLicenseIMatix, 
    SpdxLicenseImlib2, 
    SpdxLicenseInfoZIP, 
    SpdxLicenseIntelACPI, 
    SpdxLicenseIntel, 
    SpdxLicenseInterbase10, 
    SpdxLicenseIPA, 
    SpdxLicenseIPL10, 
    SpdxLicenseISC, 
    SpdxLicenseJasPer20, 
    SpdxLicenseJSON, 
    SpdxLicenseLAL12, 
    SpdxLicenseLAL13, 
    SpdxLicenseLatex2e, 
    SpdxLicenseLeptonica, 
    SpdxLicenseLGPL20Only, 
    SpdxLicenseLGPL20OrLater, 
    SpdxLicenseLGPL21Only, 
    SpdxLicenseLGPL21OrLater, 
    SpdxLicenseLGPL30Only, 
    SpdxLicenseLGPL30OrLater, 
    SpdxLicenseLGPLLR, 
    SpdxLicenseLibpng, 
    SpdxLicenseLibtiff, 
    SpdxLicenseLiLiQP11, 
    SpdxLicenseLiLiQR11, 
    SpdxLicenseLiLiQRplus11, 
    SpdxLicenseLinuxOpenIB, 
    SpdxLicenseLPL10, 
    SpdxLicenseLPL102, 
    SpdxLicenseLPPL10, 
    SpdxLicenseLPPL11, 
    SpdxLicenseLPPL12, 
    SpdxLicenseLPPL13a, 
    SpdxLicenseLPPL13c, 
    SpdxLicenseMakeIndex, 
    SpdxLicenseMirOS, 
    SpdxLicenseMIT0, 
    SpdxLicenseMITAdvertising, 
    SpdxLicenseMITCMU, 
    SpdxLicenseMITEnna, 
    SpdxLicenseMITFeh, 
    SpdxLicenseMIT, 
    SpdxLicenseMITNFA, 
    SpdxLicenseMotosoto, 
    SpdxLicenseMpich2, 
    SpdxLicenseMPL10, 
    SpdxLicenseMPL11, 
    SpdxLicenseMPL20NoCopyleftException, 
    SpdxLicenseMPL20, 
    SpdxLicenseMSPL, 
    SpdxLicenseMSRL, 
    SpdxLicenseMTLL, 
    SpdxLicenseMultics, 
    SpdxLicenseMup, 
    SpdxLicenseNASA13, 
    SpdxLicenseNaumen, 
    SpdxLicenseNBPL10, 
    SpdxLicenseNCSA, 
    SpdxLicenseNetSNMP, 
    SpdxLicenseNetCDF, 
    SpdxLicenseNewsletr, 
    SpdxLicenseNGPL, 
    SpdxLicenseNLOD10, 
    SpdxLicenseNLPL, 
    SpdxLicenseNokia, 
    SpdxLicenseNOSL, 
    SpdxLicenseNoweb, 
    SpdxLicenseNPL10, 
    SpdxLicenseNPL11, 
    SpdxLicenseNPOSL30, 
    SpdxLicenseNRL, 
    SpdxLicenseNTP, 
    SpdxLicenseOCCTPL, 
    SpdxLicenseOCLC20, 
    SpdxLicenseODbL10, 
    SpdxLicenseOFL10, 
    SpdxLicenseOFL11, 
    SpdxLicenseOGTSL, 
    SpdxLicenseOLDAP11, 
    SpdxLicenseOLDAP12, 
    SpdxLicenseOLDAP13, 
    SpdxLicenseOLDAP14, 
    SpdxLicenseOLDAP201, 
    SpdxLicenseOLDAP20, 
    SpdxLicenseOLDAP21, 
    SpdxLicenseOLDAP221); 
  TFhirSpdxLicenseEnumList = set of TFhirSpdxLicenseEnum;

  // A code that indicates how the page is generated. from http://hl7.org/fhir/ValueSet/guide-page-generation
  TFhirGuidePageGenerationEnum = (
    GuidePageGenerationNull, // Value is missing from Instance 
    GuidePageGenerationHtml, 
    GuidePageGenerationMarkdown, 
    GuidePageGenerationXml, 
    GuidePageGenerationGenerated); 
  TFhirGuidePageGenerationEnumList = set of TFhirGuidePageGenerationEnum;

  // Code of parameter that is input to the guide. from http://hl7.org/fhir/ValueSet/guide-parameter-code
  TFhirGuideParameterCodeEnum = (
    GuideParameterCodeNull, // Value is missing from Instance 
    GuideParameterCodeApply, 
    GuideParameterCodePathResource, 
    GuideParameterCodePathPages, 
    GuideParameterCodePathTxCache, 
    GuideParameterCodeExpansionParameter, 
    GuideParameterCodeRuleBrokenLinks, 
    GuideParameterCodeGenerateXml, 
    GuideParameterCodeGenerateJson, 
    GuideParameterCodeGenerateTurtle, 
    GuideParameterCodeHtmlTemplate); 
  TFhirGuideParameterCodeEnumList = set of TFhirGuideParameterCodeEnum;

  // Codes identifying the lifecycle stage of an Invoice. from http://hl7.org/fhir/ValueSet/invoice-status
  TFhirInvoiceStatusEnum = (
    InvoiceStatusNull, // Value is missing from Instance 
    InvoiceStatusDraft, 
    InvoiceStatusIssued, 
    InvoiceStatusBalanced, 
    InvoiceStatusCancelled, 
    InvoiceStatusEnteredInError); 
  TFhirInvoiceStatusEnumList = set of TFhirInvoiceStatusEnum;

  // Used to distinguish different roles a resource can play within a set of linked resources. from http://hl7.org/fhir/ValueSet/linkage-type
  TFhirLinkageTypeEnum = (
    LinkageTypeNull, // Value is missing from Instance 
    LinkageTypeSource, 
    LinkageTypeAlternate, 
    LinkageTypeHistorical); 
  TFhirLinkageTypeEnumList = set of TFhirLinkageTypeEnum;

  // The current state of the list. from http://hl7.org/fhir/ValueSet/list-status
  TFhirListStatusEnum = (
    ListStatusNull, // Value is missing from Instance 
    ListStatusCurrent, 
    ListStatusRetired, 
    ListStatusEnteredInError); 
  TFhirListStatusEnumList = set of TFhirListStatusEnum;

  // Indicates whether the location is still in use. from http://hl7.org/fhir/ValueSet/location-status
  TFhirLocationStatusEnum = (
    LocationStatusNull, // Value is missing from Instance 
    LocationStatusActive, 
    LocationStatusSuspended, 
    LocationStatusInactive); 
  TFhirLocationStatusEnumList = set of TFhirLocationStatusEnum;

  // Indicates whether a resource instance represents a specific location or a class of locations. from http://hl7.org/fhir/ValueSet/location-mode
  TFhirLocationModeEnum = (
    LocationModeNull, // Value is missing from Instance 
    LocationModeInstance, 
    LocationModeKind); 
  TFhirLocationModeEnumList = set of TFhirLocationModeEnum;

  // The status of the measure report. from http://hl7.org/fhir/ValueSet/measure-report-status
  TFhirMeasureReportStatusEnum = (
    MeasureReportStatusNull, // Value is missing from Instance 
    MeasureReportStatusComplete, 
    MeasureReportStatusPending, 
    MeasureReportStatusError); 
  TFhirMeasureReportStatusEnumList = set of TFhirMeasureReportStatusEnum;

  // The type of the measure report. from http://hl7.org/fhir/ValueSet/measure-report-type
  TFhirMeasureReportTypeEnum = (
    MeasureReportTypeNull, // Value is missing from Instance 
    MeasureReportTypeIndividual, 
    MeasureReportTypeSubjectList, 
    MeasureReportTypeSummary, 
    MeasureReportTypeDataCollection); 
  TFhirMeasureReportTypeEnumList = set of TFhirMeasureReportTypeEnum;

  // A coded concept defining if the medication is in active use. from http://hl7.org/fhir/ValueSet/medication-status
  TFhirMedicationStatusEnum = (
    MedicationStatusNull, // Value is missing from Instance 
    MedicationStatusActive, 
    MedicationStatusInactive, 
    MedicationStatusEnteredInError); 
  TFhirMedicationStatusEnumList = set of TFhirMedicationStatusEnum;

  // A coded concept specifying the state of the prescribing event. Describes the lifecycle of the prescription. from http://hl7.org/fhir/ValueSet/medicationrequest-status
  TFhirMedicationrequestStatusEnum = (
    MedicationrequestStatusNull, // Value is missing from Instance 
    MedicationrequestStatusActive, 
    MedicationrequestStatusOnHold, 
    MedicationrequestStatusCancelled, 
    MedicationrequestStatusCompleted, 
    MedicationrequestStatusEnteredInError, 
    MedicationrequestStatusStopped, 
    MedicationrequestStatusDraft, 
    MedicationrequestStatusUnknown); 
  TFhirMedicationrequestStatusEnumList = set of TFhirMedicationrequestStatusEnum;

  // The kind of medication order. from http://hl7.org/fhir/ValueSet/medicationrequest-intent
  TFhirMedicationrequestIntentEnum = (
    MedicationrequestIntentNull, // Value is missing from Instance 
    MedicationrequestIntentProposal, 
    MedicationrequestIntentPlan, 
    MedicationrequestIntentOrder, 
    MedicationrequestIntentOriginalOrder, 
    MedicationrequestIntentReflexOrder, 
    MedicationrequestIntentFillerOrder, 
    MedicationrequestIntentInstanceOrder, 
    MedicationrequestIntentOption); 
  TFhirMedicationrequestIntentEnumList = set of TFhirMedicationrequestIntentEnum;

  // A coded concept indicating the current status of a MedicationStatement. from http://hl7.org/fhir/ValueSet/medication-statement-status
  TFhirMedicationStatementStatusEnum = (
    MedicationStatementStatusNull, // Value is missing from Instance 
    MedicationStatementStatusActive, 
    MedicationStatementStatusCompleted, 
    MedicationStatementStatusEnteredInError, 
    MedicationStatementStatusIntended, 
    MedicationStatementStatusStopped, 
    MedicationStatementStatusOnHold, 
    MedicationStatementStatusUnknown, 
    MedicationStatementStatusNotTaken); 
  TFhirMedicationStatementStatusEnumList = set of TFhirMedicationStatementStatusEnum;

  // The impact of the content of a message. from http://hl7.org/fhir/ValueSet/message-significance-category
  TFhirMessageSignificanceCategoryEnum = (
    MessageSignificanceCategoryNull, // Value is missing from Instance 
    MessageSignificanceCategoryConsequence, 
    MessageSignificanceCategoryCurrency, 
    MessageSignificanceCategoryNotification); 
  TFhirMessageSignificanceCategoryEnumList = set of TFhirMessageSignificanceCategoryEnum;

  // HL7-defined table of codes which identify conditions under which acknowledgments are required to be returned in response to a message. from http://hl7.org/fhir/ValueSet/messageheader-response-request
  TFhirMessageheaderResponseRequestEnum = (
    MessageheaderResponseRequestNull, // Value is missing from Instance 
    MessageheaderResponseRequestAlways, 
    MessageheaderResponseRequestOnError, 
    MessageheaderResponseRequestNever, 
    MessageheaderResponseRequestOnSuccess); 
  TFhirMessageheaderResponseRequestEnumList = set of TFhirMessageheaderResponseRequestEnum;

  // The kind of response to a message. from http://hl7.org/fhir/ValueSet/response-code
  TFhirResponseCodeEnum = (
    ResponseCodeNull, // Value is missing from Instance 
    ResponseCodeOk, 
    ResponseCodeTransientError, 
    ResponseCodeFatalError); 
  TFhirResponseCodeEnumList = set of TFhirResponseCodeEnum;

  // Type if a sequence -- DNA, RNA, or amino acid sequence. from http://hl7.org/fhir/ValueSet/sequence-type
  TFhirSequenceTypeEnum = (
    SequenceTypeNull, // Value is missing from Instance 
    SequenceTypeAa, 
    SequenceTypeDna, 
    SequenceTypeRna); 
  TFhirSequenceTypeEnumList = set of TFhirSequenceTypeEnum;

  // Type for orientation. from http://hl7.org/fhir/ValueSet/orientation-type
  TFhirOrientationTypeEnum = (
    OrientationTypeNull, // Value is missing from Instance 
    OrientationTypeSense, 
    OrientationTypeAntisense); 
  TFhirOrientationTypeEnumList = set of TFhirOrientationTypeEnum;

  // Type for strand. from http://hl7.org/fhir/ValueSet/strand-type
  TFhirStrandTypeEnum = (
    StrandTypeNull, // Value is missing from Instance 
    StrandTypeWatson, 
    StrandTypeCrick); 
  TFhirStrandTypeEnumList = set of TFhirStrandTypeEnum;

  // Type for quality report. from http://hl7.org/fhir/ValueSet/quality-type
  TFhirQualityTypeEnum = (
    QualityTypeNull, // Value is missing from Instance 
    QualityTypeIndel, 
    QualityTypeSnp, 
    QualityTypeUnknown); 
  TFhirQualityTypeEnumList = set of TFhirQualityTypeEnum;

  // Type for access of external URI. from http://hl7.org/fhir/ValueSet/repository-type
  TFhirRepositoryTypeEnum = (
    RepositoryTypeNull, // Value is missing from Instance 
    RepositoryTypeDirectlink, 
    RepositoryTypeOpenapi, 
    RepositoryTypeLogin, 
    RepositoryTypeOauth, 
    RepositoryTypeOther); 
  TFhirRepositoryTypeEnumList = set of TFhirRepositoryTypeEnum;

  // Identifies the purpose of the naming system. from http://hl7.org/fhir/ValueSet/namingsystem-type
  TFhirNamingsystemTypeEnum = (
    NamingsystemTypeNull, // Value is missing from Instance 
    NamingsystemTypeCodesystem, 
    NamingsystemTypeIdentifier, 
    NamingsystemTypeRoot); 
  TFhirNamingsystemTypeEnumList = set of TFhirNamingsystemTypeEnum;

  // Identifies the style of unique identifier used to identify a namespace. from http://hl7.org/fhir/ValueSet/namingsystem-identifier-type
  TFhirNamingsystemIdentifierTypeEnum = (
    NamingsystemIdentifierTypeNull, // Value is missing from Instance 
    NamingsystemIdentifierTypeOid, 
    NamingsystemIdentifierTypeUuid, 
    NamingsystemIdentifierTypeUri, 
    NamingsystemIdentifierTypeOther); 
  TFhirNamingsystemIdentifierTypeEnumList = set of TFhirNamingsystemIdentifierTypeEnum;

  // Permitted data type for observation value. from http://hl7.org/fhir/ValueSet/permitted-data-type
  TFhirPermittedDataTypeEnum = (
    PermittedDataTypeNull, // Value is missing from Instance 
    PermittedDataTypeQuantity, 
    PermittedDataTypeCodeableConcept, 
    PermittedDataTypeString, 
    PermittedDataTypeBoolean, 
    PermittedDataTypeInteger, 
    PermittedDataTypeRange, 
    PermittedDataTypeRatio, 
    PermittedDataTypeSampledData, 
    PermittedDataTypeTime, 
    PermittedDataTypeDateTime, 
    PermittedDataTypePeriod); 
  TFhirPermittedDataTypeEnumList = set of TFhirPermittedDataTypeEnum;

  // Codes identifying the category of observation range. from http://hl7.org/fhir/ValueSet/observation-range-category
  TFhirObservationRangeCategoryEnum = (
    ObservationRangeCategoryNull, // Value is missing from Instance 
    ObservationRangeCategoryReference, 
    ObservationRangeCategoryCritical, 
    ObservationRangeCategoryAbsolute); 
  TFhirObservationRangeCategoryEnumList = set of TFhirObservationRangeCategoryEnum;

  // The gender of a person used for administrative purposes. from http://hl7.org/fhir/ValueSet/administrative-gender
  TFhirAdministrativeGenderEnum = (
    AdministrativeGenderNull, // Value is missing from Instance 
    AdministrativeGenderMale, 
    AdministrativeGenderFemale, 
    AdministrativeGenderOther, 
    AdministrativeGenderUnknown); 
  TFhirAdministrativeGenderEnumList = set of TFhirAdministrativeGenderEnum;

  // Whether an operation is a normal operation or a query. from http://hl7.org/fhir/ValueSet/operation-kind
  TFhirOperationKindEnum = (
    OperationKindNull, // Value is missing from Instance 
    OperationKindOperation, 
    OperationKindQuery); 
  TFhirOperationKindEnumList = set of TFhirOperationKindEnum;

  // How the issue affects the success of the action. from http://hl7.org/fhir/ValueSet/issue-severity
  TFhirIssueSeverityEnum = (
    IssueSeverityNull, // Value is missing from Instance 
    IssueSeverityFatal, 
    IssueSeverityError, 
    IssueSeverityWarning, 
    IssueSeverityInformation); 
  TFhirIssueSeverityEnumList = set of TFhirIssueSeverityEnum;

  // A code that describes the type of issue. from http://hl7.org/fhir/ValueSet/issue-type
  TFhirIssueTypeEnum = (
    IssueTypeNull, // Value is missing from Instance 
    IssueTypeInvalid, 
    IssueTypeStructure, 
    IssueTypeRequired, 
    IssueTypeValue, 
    IssueTypeInvariant, 
    IssueTypeSecurity, 
    IssueTypeLogin, 
    IssueTypeUnknown, 
    IssueTypeExpired, 
    IssueTypeForbidden, 
    IssueTypeSuppressed, 
    IssueTypeProcessing, 
    IssueTypeNotSupported, 
    IssueTypeDuplicate, 
    IssueTypeMultipleMatches, 
    IssueTypeNotFound, 
    IssueTypeDeleted, 
    IssueTypeTooLong, 
    IssueTypeCodeInvalid, 
    IssueTypeExtension, 
    IssueTypeTooCostly, 
    IssueTypeBusinessRule, 
    IssueTypeConflict, 
    IssueTypeTransient, 
    IssueTypeLockError, 
    IssueTypeNoStore, 
    IssueTypeException, 
    IssueTypeTimeout, 
    IssueTypeIncomplete, 
    IssueTypeThrottled, 
    IssueTypeInformational); 
  TFhirIssueTypeEnumList = set of TFhirIssueTypeEnum;

  // The type of link between this patient resource and another patient resource. from http://hl7.org/fhir/ValueSet/link-type
  TFhirLinkTypeEnum = (
    LinkTypeNull, // Value is missing from Instance 
    LinkTypeReplacedBy, 
    LinkTypeReplaces, 
    LinkTypeRefer, 
    LinkTypeSeealso); 
  TFhirLinkTypeEnumList = set of TFhirLinkTypeEnum;

  // The level of confidence that this link represents the same actual person, based on NIST Authentication Levels. from http://hl7.org/fhir/ValueSet/identity-assuranceLevel
  TFhirIdentityAssuranceLevelEnum = (
    IdentityAssuranceLevelNull, // Value is missing from Instance 
    IdentityAssuranceLevelLevel1, 
    IdentityAssuranceLevelLevel2, 
    IdentityAssuranceLevelLevel3, 
    IdentityAssuranceLevelLevel4); 
  TFhirIdentityAssuranceLevelEnumList = set of TFhirIdentityAssuranceLevelEnum;

  // Defines the kinds of conditions that can appear on actions. from http://hl7.org/fhir/ValueSet/action-condition-kind
  TFhirActionConditionKindEnum = (
    ActionConditionKindNull, // Value is missing from Instance 
    ActionConditionKindApplicability, 
    ActionConditionKindStart, 
    ActionConditionKindStop); 
  TFhirActionConditionKindEnumList = set of TFhirActionConditionKindEnum;

  // Defines the types of relationships between actions. from http://hl7.org/fhir/ValueSet/action-relationship-type
  TFhirActionRelationshipTypeEnum = (
    ActionRelationshipTypeNull, // Value is missing from Instance 
    ActionRelationshipTypeBeforeStart, 
    ActionRelationshipTypeBefore, 
    ActionRelationshipTypeBeforeEnd, 
    ActionRelationshipTypeConcurrentWithStart, 
    ActionRelationshipTypeConcurrent, 
    ActionRelationshipTypeConcurrentWithEnd, 
    ActionRelationshipTypeAfterStart, 
    ActionRelationshipTypeAfter, 
    ActionRelationshipTypeAfterEnd); 
  TFhirActionRelationshipTypeEnumList = set of TFhirActionRelationshipTypeEnum;

  // Defines organization behavior of a group. from http://hl7.org/fhir/ValueSet/action-grouping-behavior
  TFhirActionGroupingBehaviorEnum = (
    ActionGroupingBehaviorNull, // Value is missing from Instance 
    ActionGroupingBehaviorVisualGroup, 
    ActionGroupingBehaviorLogicalGroup, 
    ActionGroupingBehaviorSentenceGroup); 
  TFhirActionGroupingBehaviorEnumList = set of TFhirActionGroupingBehaviorEnum;

  // Defines selection behavior of a group. from http://hl7.org/fhir/ValueSet/action-selection-behavior
  TFhirActionSelectionBehaviorEnum = (
    ActionSelectionBehaviorNull, // Value is missing from Instance 
    ActionSelectionBehaviorAny, 
    ActionSelectionBehaviorAll, 
    ActionSelectionBehaviorAllOrNone, 
    ActionSelectionBehaviorExactlyOne, 
    ActionSelectionBehaviorAtMostOne, 
    ActionSelectionBehaviorOneOrMore); 
  TFhirActionSelectionBehaviorEnumList = set of TFhirActionSelectionBehaviorEnum;

  // Defines expectations around whether an action or action group is required. from http://hl7.org/fhir/ValueSet/action-required-behavior
  TFhirActionRequiredBehaviorEnum = (
    ActionRequiredBehaviorNull, // Value is missing from Instance 
    ActionRequiredBehaviorMust, 
    ActionRequiredBehaviorCould, 
    ActionRequiredBehaviorMustUnlessDocumented); 
  TFhirActionRequiredBehaviorEnumList = set of TFhirActionRequiredBehaviorEnum;

  // Defines selection frequency behavior for an action or group. from http://hl7.org/fhir/ValueSet/action-precheck-behavior
  TFhirActionPrecheckBehaviorEnum = (
    ActionPrecheckBehaviorNull, // Value is missing from Instance 
    ActionPrecheckBehaviorYes, 
    ActionPrecheckBehaviorNo); 
  TFhirActionPrecheckBehaviorEnumList = set of TFhirActionPrecheckBehaviorEnum;

  // Defines behavior for an action or a group for how many times that item may be repeated. from http://hl7.org/fhir/ValueSet/action-cardinality-behavior
  TFhirActionCardinalityBehaviorEnum = (
    ActionCardinalityBehaviorNull, // Value is missing from Instance 
    ActionCardinalityBehaviorSingle, 
    ActionCardinalityBehaviorMultiple); 
  TFhirActionCardinalityBehaviorEnumList = set of TFhirActionCardinalityBehaviorEnum;

  // How an entity was used in an activity. from http://hl7.org/fhir/ValueSet/provenance-entity-role
  TFhirProvenanceEntityRoleEnum = (
    ProvenanceEntityRoleNull, // Value is missing from Instance 
    ProvenanceEntityRoleDerivation, 
    ProvenanceEntityRoleRevision, 
    ProvenanceEntityRoleQuotation, 
    ProvenanceEntityRoleSource, 
    ProvenanceEntityRoleRemoval); 
  TFhirProvenanceEntityRoleEnumList = set of TFhirProvenanceEntityRoleEnum;

  // Distinguishes groups from questions and display text and indicates data type for questions. from http://hl7.org/fhir/ValueSet/item-type
  TFhirItemTypeEnum = (
    ItemTypeNull, // Value is missing from Instance 
    ItemTypeGroup, 
    ItemTypeDisplay, 
    ItemTypeBoolean, 
    ItemTypeDecimal, 
    ItemTypeInteger, 
    ItemTypeDate, 
    ItemTypeDateTime, 
    ItemTypeTime, 
    ItemTypeString, 
    ItemTypeText, 
    ItemTypeUrl, 
    ItemTypeChoice, 
    ItemTypeOpenChoice, 
    ItemTypeAttachment, 
    ItemTypeReference, 
    ItemTypeQuantity); 
  TFhirItemTypeEnumList = set of TFhirItemTypeEnum;

  // The criteria by which a question is enabled. from http://hl7.org/fhir/ValueSet/questionnaire-enable-operator
  TFhirQuestionnaireEnableOperatorEnum = (
    QuestionnaireEnableOperatorNull, // Value is missing from Instance 
    QuestionnaireEnableOperatorExists, 
    QuestionnaireEnableOperatorEqual, 
    QuestionnaireEnableOperatorNotEqual, 
    QuestionnaireEnableOperatorGreaterThan, 
    QuestionnaireEnableOperatorLessThan, 
    QuestionnaireEnableOperatorGreaterOrEquals, 
    QuestionnaireEnableOperatorLessOrEquals); 
  TFhirQuestionnaireEnableOperatorEnumList = set of TFhirQuestionnaireEnableOperatorEnum;

  // Controls how multiple enableWhen values are interpreted -  whether all or any must be true. from http://hl7.org/fhir/ValueSet/questionnaire-enable-behavior
  TFhirQuestionnaireEnableBehaviorEnum = (
    QuestionnaireEnableBehaviorNull, // Value is missing from Instance 
    QuestionnaireEnableBehaviorAll, 
    QuestionnaireEnableBehaviorAny); 
  TFhirQuestionnaireEnableBehaviorEnumList = set of TFhirQuestionnaireEnableBehaviorEnum;

  // Lifecycle status of the questionnaire response. from http://hl7.org/fhir/ValueSet/questionnaire-answers-status
  TFhirQuestionnaireAnswersStatusEnum = (
    QuestionnaireAnswersStatusNull, // Value is missing from Instance 
    QuestionnaireAnswersStatusInProgress, 
    QuestionnaireAnswersStatusCompleted, 
    QuestionnaireAnswersStatusAmended, 
    QuestionnaireAnswersStatusEnteredInError, 
    QuestionnaireAnswersStatusStopped); 
  TFhirQuestionnaireAnswersStatusEnumList = set of TFhirQuestionnaireAnswersStatusEnum;

  // The possible types of research elements (E.g. Population, Exposure, Outcome). from http://hl7.org/fhir/ValueSet/research-element-type
  TFhirResearchElementTypeEnum = (
    ResearchElementTypeNull, // Value is missing from Instance 
    ResearchElementTypePopulation, 
    ResearchElementTypeExposure, 
    ResearchElementTypeOutcome); 
  TFhirResearchElementTypeEnumList = set of TFhirResearchElementTypeEnum;

  // Codes that convey the current status of the research study. from http://hl7.org/fhir/ValueSet/research-study-status
  TFhirResearchStudyStatusEnum = (
    ResearchStudyStatusNull, // Value is missing from Instance 
    ResearchStudyStatusActive, 
    ResearchStudyStatusAdministrativelyCompleted, 
    ResearchStudyStatusApproved, 
    ResearchStudyStatusClosedToAccrual, 
    ResearchStudyStatusClosedToAccrualAndIntervention, 
    ResearchStudyStatusCompleted, 
    ResearchStudyStatusDisapproved, 
    ResearchStudyStatusInReview, 
    ResearchStudyStatusTemporarilyClosedToAccrual, 
    ResearchStudyStatusTemporarilyClosedToAccrualAndIntervention, 
    ResearchStudyStatusWithdrawn); 
  TFhirResearchStudyStatusEnumList = set of TFhirResearchStudyStatusEnum;

  // Indicates the progression of a study subject through a study. from http://hl7.org/fhir/ValueSet/research-subject-status
  TFhirResearchSubjectStatusEnum = (
    ResearchSubjectStatusNull, // Value is missing from Instance 
    ResearchSubjectStatusCandidate, 
    ResearchSubjectStatusEligible, 
    ResearchSubjectStatusFollowUp, 
    ResearchSubjectStatusIneligible, 
    ResearchSubjectStatusNotRegistered, 
    ResearchSubjectStatusOffStudy, 
    ResearchSubjectStatusOnStudy, 
    ResearchSubjectStatusOnStudyIntervention, 
    ResearchSubjectStatusOnStudyObservation, 
    ResearchSubjectStatusPendingOnStudy, 
    ResearchSubjectStatusPotentialCandidate, 
    ResearchSubjectStatusScreening, 
    ResearchSubjectStatusWithdrawn); 
  TFhirResearchSubjectStatusEnumList = set of TFhirResearchSubjectStatusEnum;

  // How a search parameter relates to the set of elements returned by evaluating its xpath query. from http://hl7.org/fhir/ValueSet/search-xpath-usage
  TFhirSearchXpathUsageEnum = (
    SearchXpathUsageNull, // Value is missing from Instance 
    SearchXpathUsageNormal, 
    SearchXpathUsagePhonetic, 
    SearchXpathUsageNearby, 
    SearchXpathUsageDistance, 
    SearchXpathUsageOther); 
  TFhirSearchXpathUsageEnumList = set of TFhirSearchXpathUsageEnum;

  // What Search Comparator Codes are supported in search. from http://hl7.org/fhir/ValueSet/search-comparator
  TFhirSearchComparatorEnum = (
    SearchComparatorNull, // Value is missing from Instance 
    SearchComparatorEq, 
    SearchComparatorNe, 
    SearchComparatorGt, 
    SearchComparatorLt, 
    SearchComparatorGe, 
    SearchComparatorLe, 
    SearchComparatorSa, 
    SearchComparatorEb, 
    SearchComparatorAp); 
  TFhirSearchComparatorEnumList = set of TFhirSearchComparatorEnum;

  // A supported modifier for a search parameter. from http://hl7.org/fhir/ValueSet/search-modifier-code
  TFhirSearchModifierCodeEnum = (
    SearchModifierCodeNull, // Value is missing from Instance 
    SearchModifierCodeMissing, 
    SearchModifierCodeExact, 
    SearchModifierCodeContains, 
    SearchModifierCodeNot, 
    SearchModifierCodeText, 
    SearchModifierCodeIn, 
    SearchModifierCodeNotIn, 
    SearchModifierCodeBelow, 
    SearchModifierCodeAbove, 
    SearchModifierCodeType, 
    SearchModifierCodeIdentifier, 
    SearchModifierCodeOfType); 
  TFhirSearchModifierCodeEnumList = set of TFhirSearchModifierCodeEnum;

  // The free/busy status of the slot. from http://hl7.org/fhir/ValueSet/slotstatus
  TFhirSlotstatusEnum = (
    SlotstatusNull, // Value is missing from Instance 
    SlotstatusBusy, 
    SlotstatusFree, 
    SlotstatusBusyUnavailable, 
    SlotstatusBusyTentative, 
    SlotstatusEnteredInError); 
  TFhirSlotstatusEnumList = set of TFhirSlotstatusEnum;

  // Codes providing the status/availability of a specimen. from http://hl7.org/fhir/ValueSet/specimen-status
  TFhirSpecimenStatusEnum = (
    SpecimenStatusNull, // Value is missing from Instance 
    SpecimenStatusAvailable, 
    SpecimenStatusUnavailable, 
    SpecimenStatusUnsatisfactory, 
    SpecimenStatusEnteredInError); 
  TFhirSpecimenStatusEnumList = set of TFhirSpecimenStatusEnum;

  // Degree of preference of a type of conditioned specimen. from http://hl7.org/fhir/ValueSet/specimen-contained-preference
  TFhirSpecimenContainedPreferenceEnum = (
    SpecimenContainedPreferenceNull, // Value is missing from Instance 
    SpecimenContainedPreferencePreferred, 
    SpecimenContainedPreferenceAlternate); 
  TFhirSpecimenContainedPreferenceEnumList = set of TFhirSpecimenContainedPreferenceEnum;

  // Defines the type of structure that a definition is describing. from http://hl7.org/fhir/ValueSet/structure-definition-kind
  TFhirStructureDefinitionKindEnum = (
    StructureDefinitionKindNull, // Value is missing from Instance 
    StructureDefinitionKindPrimitiveType, 
    StructureDefinitionKindComplexType, 
    StructureDefinitionKindResource, 
    StructureDefinitionKindLogical); 
  TFhirStructureDefinitionKindEnumList = set of TFhirStructureDefinitionKindEnum;

  // How an extension context is interpreted. from http://hl7.org/fhir/ValueSet/extension-context-type
  TFhirExtensionContextTypeEnum = (
    ExtensionContextTypeNull, // Value is missing from Instance 
    ExtensionContextTypeFhirpath, 
    ExtensionContextTypeElement, 
    ExtensionContextTypeExtension); 
  TFhirExtensionContextTypeEnumList = set of TFhirExtensionContextTypeEnum;

  // How a type relates to its baseDefinition. from http://hl7.org/fhir/ValueSet/type-derivation-rule
  TFhirTypeDerivationRuleEnum = (
    TypeDerivationRuleNull, // Value is missing from Instance 
    TypeDerivationRuleSpecialization, 
    TypeDerivationRuleConstraint); 
  TFhirTypeDerivationRuleEnumList = set of TFhirTypeDerivationRuleEnum;

  // How the referenced structure is used in this mapping. from http://hl7.org/fhir/ValueSet/map-model-mode
  TFhirMapModelModeEnum = (
    MapModelModeNull, // Value is missing from Instance 
    MapModelModeSource, 
    MapModelModeQueried, 
    MapModelModeTarget, 
    MapModelModeProduced); 
  TFhirMapModelModeEnumList = set of TFhirMapModelModeEnum;

  // If this is the default rule set to apply for the source type, or this combination of types. from http://hl7.org/fhir/ValueSet/map-group-type-mode
  TFhirMapGroupTypeModeEnum = (
    MapGroupTypeModeNull, // Value is missing from Instance 
    MapGroupTypeModeNone, 
    MapGroupTypeModeTypes, 
    MapGroupTypeModeTypeAndTypes); 
  TFhirMapGroupTypeModeEnumList = set of TFhirMapGroupTypeModeEnum;

  // Mode for this instance of data. from http://hl7.org/fhir/ValueSet/map-input-mode
  TFhirMapInputModeEnum = (
    MapInputModeNull, // Value is missing from Instance 
    MapInputModeSource, 
    MapInputModeTarget); 
  TFhirMapInputModeEnumList = set of TFhirMapInputModeEnum;

  // If field is a list, how to manage the source. from http://hl7.org/fhir/ValueSet/map-source-list-mode
  TFhirMapSourceListModeEnum = (
    MapSourceListModeNull, // Value is missing from Instance 
    MapSourceListModeFirst, 
    MapSourceListModeNotFirst, 
    MapSourceListModeLast, 
    MapSourceListModeNotLast, 
    MapSourceListModeOnlyOne); 
  TFhirMapSourceListModeEnumList = set of TFhirMapSourceListModeEnum;

  // How to interpret the context. from http://hl7.org/fhir/ValueSet/map-context-type
  TFhirMapContextTypeEnum = (
    MapContextTypeNull, // Value is missing from Instance 
    MapContextTypeType, 
    MapContextTypeVariable); 
  TFhirMapContextTypeEnumList = set of TFhirMapContextTypeEnum;

  // If field is a list, how to manage the production. from http://hl7.org/fhir/ValueSet/map-target-list-mode
  TFhirMapTargetListModeEnum = (
    MapTargetListModeNull, // Value is missing from Instance 
    MapTargetListModeFirst, 
    MapTargetListModeShare, 
    MapTargetListModeLast, 
    MapTargetListModeCollate); 
  TFhirMapTargetListModeEnumList = set of TFhirMapTargetListModeEnum;

  // How data is copied/created. from http://hl7.org/fhir/ValueSet/map-transform
  TFhirMapTransformEnum = (
    MapTransformNull, // Value is missing from Instance 
    MapTransformCreate, 
    MapTransformCopy, 
    MapTransformTruncate, 
    MapTransformEscape, 
    MapTransformCast, 
    MapTransformAppend, 
    MapTransformTranslate, 
    MapTransformReference, 
    MapTransformDateOp, 
    MapTransformUuid, 
    MapTransformPointer, 
    MapTransformEvaluate, 
    MapTransformCc, 
    MapTransformC, 
    MapTransformQty, 
    MapTransformId, 
    MapTransformCp); 
  TFhirMapTransformEnumList = set of TFhirMapTransformEnum;

  // The status of a subscription. from http://hl7.org/fhir/ValueSet/subscription-status
  TFhirSubscriptionStatusEnum = (
    SubscriptionStatusNull, // Value is missing from Instance 
    SubscriptionStatusRequested, 
    SubscriptionStatusActive, 
    SubscriptionStatusError, 
    SubscriptionStatusOff); 
  TFhirSubscriptionStatusEnumList = set of TFhirSubscriptionStatusEnum;

  // The type of method used to execute a subscription. from http://hl7.org/fhir/ValueSet/subscription-channel-type
  TFhirSubscriptionChannelTypeEnum = (
    SubscriptionChannelTypeNull, // Value is missing from Instance 
    SubscriptionChannelTypeRestHook, 
    SubscriptionChannelTypeWebsocket, 
    SubscriptionChannelTypeEmail, 
    SubscriptionChannelTypeSms, 
    SubscriptionChannelTypeMessage); 
  TFhirSubscriptionChannelTypeEnumList = set of TFhirSubscriptionChannelTypeEnum;

  // A code to indicate if the substance is actively used. from http://hl7.org/fhir/ValueSet/substance-status
  TFhirSubstanceStatusEnum = (
    SubstanceStatusNull, // Value is missing from Instance 
    SubstanceStatusActive, 
    SubstanceStatusInactive, 
    SubstanceStatusEnteredInError); 
  TFhirSubstanceStatusEnumList = set of TFhirSubstanceStatusEnum;

  // Status of the supply delivery. from http://hl7.org/fhir/ValueSet/supplydelivery-status
  TFhirSupplydeliveryStatusEnum = (
    SupplydeliveryStatusNull, // Value is missing from Instance 
    SupplydeliveryStatusInProgress, 
    SupplydeliveryStatusCompleted, 
    SupplydeliveryStatusAbandoned, 
    SupplydeliveryStatusEnteredInError); 
  TFhirSupplydeliveryStatusEnumList = set of TFhirSupplydeliveryStatusEnum;

  // Status of the supply request. from http://hl7.org/fhir/ValueSet/supplyrequest-status
  TFhirSupplyrequestStatusEnum = (
    SupplyrequestStatusNull, // Value is missing from Instance 
    SupplyrequestStatusDraft, 
    SupplyrequestStatusActive, 
    SupplyrequestStatusSuspended, 
    SupplyrequestStatusCancelled, 
    SupplyrequestStatusCompleted, 
    SupplyrequestStatusEnteredInError, 
    SupplyrequestStatusUnknown); 
  TFhirSupplyrequestStatusEnumList = set of TFhirSupplyrequestStatusEnum;

  // The current status of the task. from http://hl7.org/fhir/ValueSet/task-status
  TFhirTaskStatusEnum = (
    TaskStatusNull, // Value is missing from Instance 
    TaskStatusDraft, 
    TaskStatusRequested, 
    TaskStatusReceived, 
    TaskStatusAccepted, 
    TaskStatusRejected, 
    TaskStatusReady, 
    TaskStatusCancelled, 
    TaskStatusInProgress, 
    TaskStatusOnHold, 
    TaskStatusFailed, 
    TaskStatusCompleted, 
    TaskStatusEnteredInError); 
  TFhirTaskStatusEnumList = set of TFhirTaskStatusEnum;

  // Distinguishes whether the task is a proposal, plan or full order. from http://hl7.org/fhir/ValueSet/task-intent
  TFhirTaskIntentEnum = (
    TaskIntentNull, // Value is missing from Instance 
    TaskIntentUnknown, 
    TaskIntentProposal, 
    TaskIntentPlan, 
    TaskIntentOrder, 
    TaskIntentOriginalOrder, 
    TaskIntentReflexOrder, 
    TaskIntentFillerOrder, 
    TaskIntentInstanceOrder, 
    TaskIntentOption); 
  TFhirTaskIntentEnumList = set of TFhirTaskIntentEnum;

  // The degree to which the server supports the code search parameter on ValueSet, if it is supported. from http://hl7.org/fhir/ValueSet/code-search-support
  TFhirCodeSearchSupportEnum = (
    CodeSearchSupportNull, // Value is missing from Instance 
    CodeSearchSupportExplicit, 
    CodeSearchSupportAll); 
  TFhirCodeSearchSupportEnumList = set of TFhirCodeSearchSupportEnum;

  // The current status of the test report. from http://hl7.org/fhir/ValueSet/report-status-codes
  TFhirReportStatusCodesEnum = (
    ReportStatusCodesNull, // Value is missing from Instance 
    ReportStatusCodesCompleted, 
    ReportStatusCodesInProgress, 
    ReportStatusCodesWaiting, 
    ReportStatusCodesStopped, 
    ReportStatusCodesEnteredInError); 
  TFhirReportStatusCodesEnumList = set of TFhirReportStatusCodesEnum;

  // The reported execution result. from http://hl7.org/fhir/ValueSet/report-result-codes
  TFhirReportResultCodesEnum = (
    ReportResultCodesNull, // Value is missing from Instance 
    ReportResultCodesPass, 
    ReportResultCodesFail, 
    ReportResultCodesPending); 
  TFhirReportResultCodesEnumList = set of TFhirReportResultCodesEnum;

  // The type of participant. from http://hl7.org/fhir/ValueSet/report-participant-type
  TFhirReportParticipantTypeEnum = (
    ReportParticipantTypeNull, // Value is missing from Instance 
    ReportParticipantTypeTestEngine, 
    ReportParticipantTypeClient, 
    ReportParticipantTypeServer); 
  TFhirReportParticipantTypeEnumList = set of TFhirReportParticipantTypeEnum;

  // The results of executing an action. from http://hl7.org/fhir/ValueSet/report-action-result-codes
  TFhirReportActionResultCodesEnum = (
    ReportActionResultCodesNull, // Value is missing from Instance 
    ReportActionResultCodesPass, 
    ReportActionResultCodesSkip, 
    ReportActionResultCodesFail, 
    ReportActionResultCodesWarning, 
    ReportActionResultCodesError); 
  TFhirReportActionResultCodesEnumList = set of TFhirReportActionResultCodesEnum;

  // The allowable request method or HTTP operation codes. from http://hl7.org/fhir/ValueSet/http-operations
  TFhirHttpOperationsEnum = (
    HttpOperationsNull, // Value is missing from Instance 
    HttpOperationsDelete, 
    HttpOperationsGet, 
    HttpOperationsOptions, 
    HttpOperationsPatch, 
    HttpOperationsPost, 
    HttpOperationsPut, 
    HttpOperationsHead); 
  TFhirHttpOperationsEnumList = set of TFhirHttpOperationsEnum;

  // The type of direction to use for assertion. from http://hl7.org/fhir/ValueSet/assert-direction-codes
  TFhirAssertDirectionCodesEnum = (
    AssertDirectionCodesNull, // Value is missing from Instance 
    AssertDirectionCodesResponse, 
    AssertDirectionCodesRequest); 
  TFhirAssertDirectionCodesEnumList = set of TFhirAssertDirectionCodesEnum;

  // The type of operator to use for assertion. from http://hl7.org/fhir/ValueSet/assert-operator-codes
  TFhirAssertOperatorCodesEnum = (
    AssertOperatorCodesNull, // Value is missing from Instance 
    AssertOperatorCodesEquals, 
    AssertOperatorCodesNotEquals, 
    AssertOperatorCodesIn, 
    AssertOperatorCodesNotIn, 
    AssertOperatorCodesGreaterThan, 
    AssertOperatorCodesLessThan, 
    AssertOperatorCodesEmpty, 
    AssertOperatorCodesNotEmpty, 
    AssertOperatorCodesContains, 
    AssertOperatorCodesNotContains, 
    AssertOperatorCodesEval); 
  TFhirAssertOperatorCodesEnumList = set of TFhirAssertOperatorCodesEnum;

  // The type of response code to use for assertion. from http://hl7.org/fhir/ValueSet/assert-response-code-types
  TFhirAssertResponseCodeTypesEnum = (
    AssertResponseCodeTypesNull, // Value is missing from Instance 
    AssertResponseCodeTypesOkay, 
    AssertResponseCodeTypesCreated, 
    AssertResponseCodeTypesNoContent, 
    AssertResponseCodeTypesNotModified, 
    AssertResponseCodeTypesBad, 
    AssertResponseCodeTypesForbidden, 
    AssertResponseCodeTypesNotFound, 
    AssertResponseCodeTypesMethodNotAllowed, 
    AssertResponseCodeTypesConflict, 
    AssertResponseCodeTypesGone, 
    AssertResponseCodeTypesPreconditionFailed, 
    AssertResponseCodeTypesUnprocessable); 
  TFhirAssertResponseCodeTypesEnumList = set of TFhirAssertResponseCodeTypesEnum;

  // The validation status of the target. from http://hl7.org/fhir/ValueSet/verificationresult-status
  TFhirVerificationresultStatusEnum = (
    VerificationresultStatusNull, // Value is missing from Instance 
    VerificationresultStatusAttested, 
    VerificationresultStatusValidated, 
    VerificationresultStatusInProcess, 
    VerificationresultStatusReqRevalid, 
    VerificationresultStatusValFail, 
    VerificationresultStatusRevalFail); 
  TFhirVerificationresultStatusEnumList = set of TFhirVerificationresultStatusEnum;

  // A coded concept listing the eye codes. from http://hl7.org/fhir/ValueSet/vision-eye-codes
  TFhirVisionEyeCodesEnum = (
    VisionEyeCodesNull, // Value is missing from Instance 
    VisionEyeCodesRight, 
    VisionEyeCodesLeft); 
  TFhirVisionEyeCodesEnumList = set of TFhirVisionEyeCodesEnum;

  // A coded concept listing the base codes. from http://hl7.org/fhir/ValueSet/vision-base-codes
  TFhirVisionBaseCodesEnum = (
    VisionBaseCodesNull, // Value is missing from Instance 
    VisionBaseCodesUp, 
    VisionBaseCodesDown, 
    VisionBaseCodesIn, 
    VisionBaseCodesOut); 
  TFhirVisionBaseCodesEnumList = set of TFhirVisionBaseCodesEnum;

Type
  TFhirElement = class;
  TFhirElementList = class;
  TFhirBackboneElement = class;
  TFhirBackboneElementList = class;
  TFhirBackboneType = class;
  TFhirBackboneTypeList = class;
  TFhirEnum = class;
  TFhirEnumList = class;
  TFhirDate = class;
  TFhirDateList = class;
  TFhirDateTime = class;
  TFhirDateTimeList = class;
  TFhirString = class;
  TFhirStringList = class;
  TFhirInteger = class;
  TFhirIntegerList = class;
  TFhirUri = class;
  TFhirUriList = class;
  TFhirInstant = class;
  TFhirInstantList = class;
  TFhirXhtml = class;
  TFhirXhtmlList = class;
  TFhirBoolean = class;
  TFhirBooleanList = class;
  TFhirBase64Binary = class;
  TFhirBase64BinaryList = class;
  TFhirTime = class;
  TFhirTimeList = class;
  TFhirDecimal = class;
  TFhirDecimalList = class;
  TFhirCode = class;
  TFhirCodeList = class;
  TFhirCanonical = class;
  TFhirCanonicalList = class;
  TFhirOid = class;
  TFhirOidList = class;
  TFhirUuid = class;
  TFhirUuidList = class;
  TFhirUrl = class;
  TFhirUrlList = class;
  TFhirMarkdown = class;
  TFhirMarkdownList = class;
  TFhirUnsignedInt = class;
  TFhirUnsignedIntList = class;
  TFhirId = class;
  TFhirIdList = class;
  TFhirPositiveInt = class;
  TFhirPositiveIntList = class;
  TFhirExtension = class;
  TFhirExtensionList = class;
  TFhirNarrative = class;
  TFhirNarrativeList = class;
  TFhirContributor = class;
  TFhirContributorList = class;
  TFhirAttachment = class;
  TFhirAttachmentList = class;
  TFhirDataRequirementCodeFilter = class;
  TFhirDataRequirementCodeFilterList = class;
  TFhirDataRequirementDateFilter = class;
  TFhirDataRequirementDateFilterList = class;
  TFhirDataRequirementSort = class;
  TFhirDataRequirementSortList = class;
  TFhirDataRequirement = class;
  TFhirDataRequirementList = class;
  TFhirDosageDoseAndRate = class;
  TFhirDosageDoseAndRateList = class;
  TFhirDosage = class;
  TFhirDosageList = class;
  TFhirMoney = class;
  TFhirMoneyList = class;
  TFhirMarketingStatus = class;
  TFhirMarketingStatusList = class;
  TFhirIdentifier = class;
  TFhirIdentifierList = class;
  TFhirSubstanceAmountReferenceRange = class;
  TFhirSubstanceAmountReferenceRangeList = class;
  TFhirSubstanceAmount = class;
  TFhirSubstanceAmountList = class;
  TFhirCoding = class;
  TFhirCodingList = class;
  TFhirSampledData = class;
  TFhirSampledDataList = class;
  TFhirPopulation = class;
  TFhirPopulationList = class;
  TFhirRatio = class;
  TFhirRatioList = class;
  TFhirReference = class;
  TFhirReferenceList = class;
  TFhirTriggerDefinition = class;
  TFhirTriggerDefinitionList = class;
  TFhirPeriod = class;
  TFhirPeriodList = class;
  TFhirQuantity = class;
  TFhirQuantityList = class;
  TFhirRange = class;
  TFhirRangeList = class;
  TFhirRelatedArtifact = class;
  TFhirRelatedArtifactList = class;
  TFhirAnnotation = class;
  TFhirAnnotationList = class;
  TFhirProductShelfLife = class;
  TFhirProductShelfLifeList = class;
  TFhirContactDetail = class;
  TFhirContactDetailList = class;
  TFhirExpression = class;
  TFhirExpressionList = class;
  TFhirUsageContext = class;
  TFhirUsageContextList = class;
  TFhirSignature = class;
  TFhirSignatureList = class;
  TFhirProdCharacteristic = class;
  TFhirProdCharacteristicList = class;
  TFhirCodeableConcept = class;
  TFhirCodeableConceptList = class;
  TFhirParameterDefinition = class;
  TFhirParameterDefinitionList = class;
  TFhirContactPoint = class;
  TFhirContactPointList = class;
  TFhirHumanName = class;
  TFhirHumanNameList = class;
  TFhirMeta = class;
  TFhirMetaList = class;
  TFhirAddress = class;
  TFhirAddressList = class;
  TFhirElementDefinitionSlicing = class;
  TFhirElementDefinitionSlicingList = class;
  TFhirElementDefinitionSlicingDiscriminator = class;
  TFhirElementDefinitionSlicingDiscriminatorList = class;
  TFhirElementDefinitionBase = class;
  TFhirElementDefinitionBaseList = class;
  TFhirElementDefinitionType = class;
  TFhirElementDefinitionTypeList = class;
  TFhirElementDefinitionExample = class;
  TFhirElementDefinitionExampleList = class;
  TFhirElementDefinitionConstraint = class;
  TFhirElementDefinitionConstraintList = class;
  TFhirElementDefinitionBinding = class;
  TFhirElementDefinitionBindingList = class;
  TFhirElementDefinitionMapping = class;
  TFhirElementDefinitionMappingList = class;
  TFhirElementDefinition = class;
  TFhirElementDefinitionList = class;
  TFhirTimingRepeat = class;
  TFhirTimingRepeatList = class;
  TFhirTiming = class;
  TFhirTimingList = class;
  TFhirCount = class;
  TFhirCountList = class;
  TFhirAge = class;
  TFhirAgeList = class;
  TFhirDistance = class;
  TFhirDistanceList = class;
  TFhirDuration = class;
  TFhirDurationList = class;

  // Base definition for all elements in a resource.
  TFhirElement = class (TFHIRObject4)
  private
    FDisallowExtensions: boolean;
  protected
    FId : TFhirId;
    FextensionList : TFhirExtensionList;
    Procedure SetId(value : TFhirId);
    Function GetIdST : String;
    Procedure SetIdST(value : String);
    function GetExtensionList : TFhirExtensionList;
    function GetHasExtensionList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    Procedure listElementFieldsInOrder(fields : TStringList);
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirElement; overload;
    function Clone : TFhirElement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
    function getId : String; override;
    procedure setIdValue(id : String); override;
    function noExtensions : TFhirElement;
    property DisallowExtensions : boolean read FDisallowExtensions write FDisallowExtensions;
    function hasExtensions : boolean; override;
    function hasExtension(url : string) : boolean; override;
    function getExtensionString(url : String) : String; override;
    function extensionCount(url : String) : integer; override;
    function extensions(url : String) : TFslList<TFHIRObject>; override;
    procedure addExtension(url : String; value : TFHIRObject); override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
    property id : String read GetIdST write SetIdST;
    // Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
    property idElement : TFhirId read FId write SetId;

    // May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
    property extensionList : TFhirExtensionList read GetExtensionList;
    property hasExtensionList : boolean read GetHasExtensionList;

  end;

  TFhirElementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirElementList;
    function GetCurrent : TFhirElement;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirElementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirElement read GetCurrent;
  end;

  TFhirElementList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirElement;
    procedure SetItemN(index : Integer; value : TFhirElement);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirElementList; Overload;
    function Clone : TFhirElementList; Overload;
    function GetEnumerator : TFhirElementListEnumerator;
    

    //  Add a FhirElement to the end of the list.
    function Append : TFhirElement;

    
    // Add an already existing FhirElement to the end of the list.
    procedure AddItem(value : TFhirElement); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirElement) : Integer;
    

    // Insert FhirElement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirElement;
    

    // Insert an existing FhirElement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirElement);
    
    // Get the iIndexth FhirElement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirElement);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirElement;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirElements[index : Integer] : TFhirElement read GetItemN write SetItemN; default;
  End;

  //  A base FHIR type - (polymorphism support)
  TFhirType = class (TFhirElement)
  Public
    Function Link : TFhirType; Overload;
    Function Clone : TFhirType; Overload;
    Function isType : boolean; Override;
    Function ToString : String; Override;
  End;
  TFHIRTypeClass = class of TFhirType;
  
  // A base FHIR type - (polymorphism support)
  TFHIRPrimitiveType = class (TFhirType)
  Private
    Function GetStringValue : String;
    Procedure SetStringValue(value : String); virtual; abstract;
    Function AsStringValue : String; Virtual; abstract;
  Public
    Function Link : TFHIRPrimitiveType; Overload;
    Function Clone : TFHIRPrimitiveType; Overload;
    Property StringValue : String read GetStringValue write SetStringValue;
    function isPrimitive : boolean; override;
    function hasPrimitiveValue : boolean; override;
    function primitiveValue : string; override;
    function setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject; override;
    function ToString : String; override;
  End;
  TFHIRPrimitiveTypeClass = class of TFHIRPrimitiveType;


  // Base definition for all elements that are defined inside a resource - but not those in a data type.
  TFhirBackboneElement = class (TFHIRElement)
  protected
    FmodifierExtensionList : TFhirExtensionList;
    function GetModifierExtensionList : TFhirExtensionList;
    function GetHasModifierExtensionList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    Procedure listBackboneElementFieldsInOrder(fields: TStringList);
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBackboneElement; overload;
    function Clone : TFhirBackboneElement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.  Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
    property modifierExtensionList : TFhirExtensionList read GetModifierExtensionList;
    property hasModifierExtensionList : boolean read GetHasModifierExtensionList;

  end;

  TFhirBackboneElementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBackboneElementList;
    function GetCurrent : TFhirBackboneElement;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBackboneElementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBackboneElement read GetCurrent;
  end;

  TFhirBackboneElementList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBackboneElement;
    procedure SetItemN(index : Integer; value : TFhirBackboneElement);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBackboneElementList; Overload;
    function Clone : TFhirBackboneElementList; Overload;
    function GetEnumerator : TFhirBackboneElementListEnumerator;


    //  Add a FhirBackboneElement to the end of the list.
    function Append : TFhirBackboneElement;


    // Add an already existing FhirBackboneElement to the end of the list.
    procedure AddItem(value : TFhirBackboneElement); overload;


    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBackboneElement) : Integer;


    // Insert FhirBackboneElement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBackboneElement;


    // Insert an existing FhirBackboneElement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBackboneElement);
    
    // Get the iIndexth FhirBackboneElement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBackboneElement);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBackboneElement;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirBackboneElements[index : Integer] : TFhirBackboneElement read GetItemN write SetItemN; default;
  End;

  // Base definition for all elements that are defined inside a resource - but not those in a data type.
  TFhirBackboneType = class (TFHIRType)
  protected
    FmodifierExtensionList : TFhirExtensionList;
    function GetModifierExtensionList : TFhirExtensionList;
    function GetHasModifierExtensionList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    Procedure listBackboneTypeFieldsInOrder(fields: TStringList);
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBackboneType; overload;
    function Clone : TFhirBackboneType; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.  Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
    property modifierExtensionList : TFhirExtensionList read GetModifierExtensionList;
    property hasModifierExtensionList : boolean read GetHasModifierExtensionList;

  end;

  TFhirBackboneTypeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBackboneTypeList;
    function GetCurrent : TFhirBackboneType;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBackboneTypeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBackboneType read GetCurrent;
  end;

  TFhirBackboneTypeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBackboneType;
    procedure SetItemN(index : Integer; value : TFhirBackboneType);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBackboneTypeList; Overload;
    function Clone : TFhirBackboneTypeList; Overload;
    function GetEnumerator : TFhirBackboneTypeListEnumerator;
    

    //  Add a FhirBackboneType to the end of the list.
    function Append : TFhirBackboneType;

    
    // Add an already existing FhirBackboneType to the end of the list.
    procedure AddItem(value : TFhirBackboneType); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBackboneType) : Integer;
    

    // Insert FhirBackboneType before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBackboneType;
    

    // Insert an existing FhirBackboneType before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBackboneType);
    
    // Get the iIndexth FhirBackboneType. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBackboneType);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBackboneType;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirBackboneTypes[index : Integer] : TFhirBackboneType read GetItemN write SetItemN; default;
  End;

  // a complex Enum - has an Id attribute, and extensions.
  //  Used where a FHIR element is a Enum, and extensions
  TFhirEnum = class (TFhirPrimitiveType)
  Private
    FValue: String;
    FSystem: String;
    procedure setValue(value: String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    function AsStringValue : String; Override;
    procedure SetStringValue(value : String); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  Public
    constructor Create(system : String; value : String); overload;
    destructor Destroy; override;
    
    Function Link : TFhirEnum; Overload;
    Function Clone : TFhirEnum; Overload;
    procedure Assign(oSource : TFslObject); override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
    function isEnum : boolean; override;
    function fhirType : string; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The actual value of the enum
    property value : String read FValue write SetValue;
    property system : String read FSystem write FSystem;
  End;    

  TFhirEnumListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEnumList;
    function GetCurrent : TFhirEnum;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirEnumList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEnum read GetCurrent;
  end;

  TFhirEnumList = class (TFHIRObjectList)
  private

    FSystems : Array Of String;

    FCodes : Array Of String;

    function GetItemN(index : Integer) : TFhirEnum;
    procedure SetItemN(index : Integer; value : TFhirEnum);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    constructor Create(Systems, Codes : Array Of String);

    function Link : TFhirEnumList; Overload;
    function Clone : TFhirEnumList; Overload;
    function GetEnumerator : TFhirEnumListEnumerator;
    

    //  Add a FhirEnum to the end of the list.
    function Append : TFhirEnum;

    
    // Add an already existing FhirEnum to the end of the list.
    procedure AddItem(value : TFhirEnum); overload;

    
    // Add an already existing FhirEnum to the end of the list.
    procedure AddItem(value : String); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEnum) : Integer;
    

    // Insert FhirEnum before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEnum;
    

    // Insert an existing FhirEnum before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEnum);
    
    // Get the iIndexth FhirEnum. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEnum);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEnum;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEnums[index : Integer] : TFhirEnum read GetItemN write SetItemN; default;
  End;

  // a complex Date - has an Id attribute, and extensions.
  //  Used where a FHIR element is a Date, and extensions
  TFhirDate = class (TFhirPrimitiveType)
  Private
    FValue: TFslDateTime;
    procedure setValue(value: TFslDateTime);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    function AsStringValue : String; Override;
    procedure SetStringValue(value : String); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  Public
    constructor Create(value : TFslDateTime); overload;
    destructor Destroy; override;
    
    Function Link : TFhirDate; Overload;
    Function Clone : TFhirDate; Overload;
    procedure Assign(oSource : TFslObject); override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
    function fhirType : string; override;
    function isDateTime : boolean; override;
    function GetDateValue : TFslDateTime; override;
    procedure SetDateValue(value : TFslDateTime); override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The actual value of the date
    property value : TFslDateTime read FValue write SetValue;
  End;    

  TFhirDateListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDateList;
    function GetCurrent : TFhirDate;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDateList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDate read GetCurrent;
  end;

  TFhirDateList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDate;
    procedure SetItemN(index : Integer; value : TFhirDate);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDateList; Overload;
    function Clone : TFhirDateList; Overload;
    function GetEnumerator : TFhirDateListEnumerator;
    

    //  Add a FhirDate to the end of the list.
    function Append : TFhirDate;

    
    // Add an already existing FhirDate to the end of the list.
    procedure AddItem(value : TFhirDate); overload;

    
    // Add an already existing FhirDate to the end of the list.
    procedure AddItem(value : TFslDateTime); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDate) : Integer;
    

    // Insert FhirDate before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDate;
    

    // Insert an existing FhirDate before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDate);
    
    // Get the iIndexth FhirDate. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDate);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDate;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDates[index : Integer] : TFhirDate read GetItemN write SetItemN; default;
  End;

  // a complex DateTime - has an Id attribute, and extensions.
  //  Used where a FHIR element is a DateTime, and extensions
  TFhirDateTime = class (TFhirPrimitiveType)
  Private
    FValue: TFslDateTime;
    procedure setValue(value: TFslDateTime);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    function AsStringValue : String; Override;
    procedure SetStringValue(value : String); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  Public
    constructor Create(value : TFslDateTime); overload;
    destructor Destroy; override;
    
    Function Link : TFhirDateTime; Overload;
    Function Clone : TFhirDateTime; Overload;
    procedure Assign(oSource : TFslObject); override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
    function fhirType : string; override;
    function isDateTime : boolean; override;
    function GetDateValue : TFslDateTime; override;
    procedure SetDateValue(value : TFslDateTime); override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The actual value of the dateTime
    property value : TFslDateTime read FValue write SetValue;
  End;    

  TFhirDateTimeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDateTimeList;
    function GetCurrent : TFhirDateTime;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDateTimeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDateTime read GetCurrent;
  end;

  TFhirDateTimeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDateTime;
    procedure SetItemN(index : Integer; value : TFhirDateTime);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDateTimeList; Overload;
    function Clone : TFhirDateTimeList; Overload;
    function GetEnumerator : TFhirDateTimeListEnumerator;
    

    //  Add a FhirDateTime to the end of the list.
    function Append : TFhirDateTime;

    
    // Add an already existing FhirDateTime to the end of the list.
    procedure AddItem(value : TFhirDateTime); overload;

    
    // Add an already existing FhirDateTime to the end of the list.
    procedure AddItem(value : TFslDateTime); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDateTime) : Integer;
    

    // Insert FhirDateTime before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDateTime;
    

    // Insert an existing FhirDateTime before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDateTime);
    
    // Get the iIndexth FhirDateTime. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDateTime);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDateTime;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDateTimes[index : Integer] : TFhirDateTime read GetItemN write SetItemN; default;
  End;

  // a complex String - has an Id attribute, and extensions.
  //  Used where a FHIR element is a String, and extensions
  TFhirString = class (TFhirPrimitiveType)
  Private
    FValue: String;
    procedure setValue(value: String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    function AsStringValue : String; Override;
    procedure SetStringValue(value : String); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  Public
    constructor Create(value : String); overload;
    destructor Destroy; override;
    
    Function Link : TFhirString; Overload;
    Function Clone : TFhirString; Overload;
    procedure Assign(oSource : TFslObject); override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
    function fhirType : string; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The actual value of the string
    property value : String read FValue write SetValue;
  End;    

  TFhirStringListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStringList;
    function GetCurrent : TFhirString;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirStringList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirString read GetCurrent;
  end;

  TFhirStringList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirString;
    procedure SetItemN(index : Integer; value : TFhirString);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirStringList; Overload;
    function Clone : TFhirStringList; Overload;
    function GetEnumerator : TFhirStringListEnumerator;
    

    //  Add a FhirString to the end of the list.
    function Append : TFhirString;

    
    // Add an already existing FhirString to the end of the list.
    procedure AddItem(value : TFhirString); overload;

    
    // Add an already existing FhirString to the end of the list.
    procedure AddItem(value : String); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirString) : Integer;
    

    // Insert FhirString before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirString;
    

    // Insert an existing FhirString before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirString);
    
    // Get the iIndexth FhirString. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirString);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirString;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirStrings[index : Integer] : TFhirString read GetItemN write SetItemN; default;
  End;

  // a complex Integer - has an Id attribute, and extensions.
  //  Used where a FHIR element is a Integer, and extensions
  TFhirInteger = class (TFhirPrimitiveType)
  Private
    FValue: String;
    procedure setValue(value: String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    function AsStringValue : String; Override;
    procedure SetStringValue(value : String); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  Public
    constructor Create(value : String); overload;
    constructor Create(value : Integer); overload;
    destructor Destroy; override;
    
    Function Link : TFhirInteger; Overload;
    Function Clone : TFhirInteger; Overload;
    procedure Assign(oSource : TFslObject); override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
    function fhirType : string; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The actual value of the integer
    property value : String read FValue write SetValue;
  End;    

  TFhirIntegerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirIntegerList;
    function GetCurrent : TFhirInteger;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirIntegerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInteger read GetCurrent;
  end;

  TFhirIntegerList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirInteger;
    procedure SetItemN(index : Integer; value : TFhirInteger);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirIntegerList; Overload;
    function Clone : TFhirIntegerList; Overload;
    function GetEnumerator : TFhirIntegerListEnumerator;
    

    //  Add a FhirInteger to the end of the list.
    function Append : TFhirInteger;

    
    // Add an already existing FhirInteger to the end of the list.
    procedure AddItem(value : TFhirInteger); overload;

    
    // Add an already existing FhirInteger to the end of the list.
    procedure AddItem(value : String); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInteger) : Integer;
    

    // Insert FhirInteger before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInteger;
    

    // Insert an existing FhirInteger before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInteger);
    
    // Get the iIndexth FhirInteger. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInteger);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInteger;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirIntegers[index : Integer] : TFhirInteger read GetItemN write SetItemN; default;
  End;

  // a complex Uri - has an Id attribute, and extensions.
  //  Used where a FHIR element is a Uri, and extensions
  TFhirUri = class (TFhirPrimitiveType)
  Private
    FValue: String;
    procedure setValue(value: String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    function AsStringValue : String; Override;
    procedure SetStringValue(value : String); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  Public
    constructor Create(value : String); overload;
    destructor Destroy; override;
    
    Function Link : TFhirUri; Overload;
    Function Clone : TFhirUri; Overload;
    procedure Assign(oSource : TFslObject); override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
    function fhirType : string; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The actual value of the uri
    property value : String read FValue write SetValue;
  End;    

  TFhirUriListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirUriList;
    function GetCurrent : TFhirUri;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirUriList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirUri read GetCurrent;
  end;

  TFhirUriList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirUri;
    procedure SetItemN(index : Integer; value : TFhirUri);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirUriList; Overload;
    function Clone : TFhirUriList; Overload;
    function GetEnumerator : TFhirUriListEnumerator;
    

    //  Add a FhirUri to the end of the list.
    function Append : TFhirUri;

    
    // Add an already existing FhirUri to the end of the list.
    procedure AddItem(value : TFhirUri); overload;

    
    // Add an already existing FhirUri to the end of the list.
    procedure AddItem(value : String); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirUri) : Integer;
    

    // Insert FhirUri before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirUri;
    

    // Insert an existing FhirUri before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirUri);
    
    // Get the iIndexth FhirUri. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirUri);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirUri;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirUris[index : Integer] : TFhirUri read GetItemN write SetItemN; default;
  End;

  // a complex Instant - has an Id attribute, and extensions.
  //  Used where a FHIR element is a Instant, and extensions
  TFhirInstant = class (TFhirPrimitiveType)
  Private
    FValue: TFslDateTime;
    procedure setValue(value: TFslDateTime);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    function AsStringValue : String; Override;
    procedure SetStringValue(value : String); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  Public
    constructor Create(value : TFslDateTime); overload;
    destructor Destroy; override;
    
    Function Link : TFhirInstant; Overload;
    Function Clone : TFhirInstant; Overload;
    procedure Assign(oSource : TFslObject); override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
    function fhirType : string; override;
    function isDateTime : boolean; override;
    function GetDateValue : TFslDateTime; override;
    procedure SetDateValue(value : TFslDateTime); override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The actual value of the instant
    property value : TFslDateTime read FValue write SetValue;
  End;    

  TFhirInstantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirInstantList;
    function GetCurrent : TFhirInstant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirInstantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirInstant read GetCurrent;
  end;

  TFhirInstantList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirInstant;
    procedure SetItemN(index : Integer; value : TFhirInstant);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirInstantList; Overload;
    function Clone : TFhirInstantList; Overload;
    function GetEnumerator : TFhirInstantListEnumerator;
    

    //  Add a FhirInstant to the end of the list.
    function Append : TFhirInstant;

    
    // Add an already existing FhirInstant to the end of the list.
    procedure AddItem(value : TFhirInstant); overload;

    
    // Add an already existing FhirInstant to the end of the list.
    procedure AddItem(value : TFslDateTime); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirInstant) : Integer;
    

    // Insert FhirInstant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirInstant;
    

    // Insert an existing FhirInstant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirInstant);
    
    // Get the iIndexth FhirInstant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirInstant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirInstant;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirInstants[index : Integer] : TFhirInstant read GetItemN write SetItemN; default;
  End;

  // a complex Xhtml - has an Id attribute, and extensions.
  //  Used where a FHIR element is a Xhtml, and extensions
  TFhirXhtml = class (TFhirPrimitiveType)
  Private
    FValue: String;
    procedure setValue(value: String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    function AsStringValue : String; Override;
    procedure SetStringValue(value : String); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  Public
    constructor Create(value : String); overload;
    destructor Destroy; override;
    
    Function Link : TFhirXhtml; Overload;
    Function Clone : TFhirXhtml; Overload;
    procedure Assign(oSource : TFslObject); override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
    function fhirType : string; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The actual value of the xhtml
    property value : String read FValue write SetValue;
  End;    

  TFhirXhtmlListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirXhtmlList;
    function GetCurrent : TFhirXhtml;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirXhtmlList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirXhtml read GetCurrent;
  end;

  TFhirXhtmlList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirXhtml;
    procedure SetItemN(index : Integer; value : TFhirXhtml);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirXhtmlList; Overload;
    function Clone : TFhirXhtmlList; Overload;
    function GetEnumerator : TFhirXhtmlListEnumerator;
    

    //  Add a FhirXhtml to the end of the list.
    function Append : TFhirXhtml;

    
    // Add an already existing FhirXhtml to the end of the list.
    procedure AddItem(value : TFhirXhtml); overload;

    
    // Add an already existing FhirXhtml to the end of the list.
    procedure AddItem(value : String); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirXhtml) : Integer;
    

    // Insert FhirXhtml before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirXhtml;
    

    // Insert an existing FhirXhtml before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirXhtml);
    
    // Get the iIndexth FhirXhtml. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirXhtml);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirXhtml;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirXhtmls[index : Integer] : TFhirXhtml read GetItemN write SetItemN; default;
  End;

  // a complex Boolean - has an Id attribute, and extensions.
  //  Used where a FHIR element is a Boolean, and extensions
  TFhirBoolean = class (TFhirPrimitiveType)
  Private
    FValue: Boolean;
    procedure setValue(value: Boolean);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    function AsStringValue : String; Override;
    procedure SetStringValue(value : String); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  Public
    constructor Create(value : Boolean); overload;
    destructor Destroy; override;
    
    Function Link : TFhirBoolean; Overload;
    Function Clone : TFhirBoolean; Overload;
    procedure Assign(oSource : TFslObject); override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
    function fhirType : string; override;
    function isBooleanPrimitive : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The actual value of the boolean
    property value : Boolean read FValue write SetValue;
  End;    

  TFhirBooleanListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBooleanList;
    function GetCurrent : TFhirBoolean;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBooleanList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBoolean read GetCurrent;
  end;

  TFhirBooleanList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBoolean;
    procedure SetItemN(index : Integer; value : TFhirBoolean);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBooleanList; Overload;
    function Clone : TFhirBooleanList; Overload;
    function GetEnumerator : TFhirBooleanListEnumerator;
    

    //  Add a FhirBoolean to the end of the list.
    function Append : TFhirBoolean;

    
    // Add an already existing FhirBoolean to the end of the list.
    procedure AddItem(value : TFhirBoolean); overload;

    
    // Add an already existing FhirBoolean to the end of the list.
    procedure AddItem(value : Boolean); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBoolean) : Integer;
    

    // Insert FhirBoolean before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBoolean;
    

    // Insert an existing FhirBoolean before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBoolean);
    
    // Get the iIndexth FhirBoolean. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBoolean);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBoolean;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirBooleans[index : Integer] : TFhirBoolean read GetItemN write SetItemN; default;
  End;

  // a complex Base64Binary - has an Id attribute, and extensions.
  //  Used where a FHIR element is a Base64Binary, and extensions
  TFhirBase64Binary = class (TFhirPrimitiveType)
  Private
    FValue: TBytes;
    procedure setValue(value: TBytes);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    function AsStringValue : String; Override;
    procedure SetStringValue(value : String); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  Public
    constructor Create(value : TBytes); overload;
    destructor Destroy; override;
    
    Function Link : TFhirBase64Binary; Overload;
    Function Clone : TFhirBase64Binary; Overload;
    procedure Assign(oSource : TFslObject); override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
    function fhirType : string; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The actual value of the base64Binary
    property value : TBytes read FValue write SetValue;
  End;    

  TFhirBase64BinaryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBase64BinaryList;
    function GetCurrent : TFhirBase64Binary;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBase64BinaryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBase64Binary read GetCurrent;
  end;

  TFhirBase64BinaryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBase64Binary;
    procedure SetItemN(index : Integer; value : TFhirBase64Binary);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBase64BinaryList; Overload;
    function Clone : TFhirBase64BinaryList; Overload;
    function GetEnumerator : TFhirBase64BinaryListEnumerator;
    

    //  Add a FhirBase64Binary to the end of the list.
    function Append : TFhirBase64Binary;

    
    // Add an already existing FhirBase64Binary to the end of the list.
    procedure AddItem(value : TFhirBase64Binary); overload;

    
    // Add an already existing FhirBase64Binary to the end of the list.
    procedure AddItem(value : TBytes); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBase64Binary) : Integer;
    

    // Insert FhirBase64Binary before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBase64Binary;
    

    // Insert an existing FhirBase64Binary before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBase64Binary);
    
    // Get the iIndexth FhirBase64Binary. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBase64Binary);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBase64Binary;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirBase64Binaries[index : Integer] : TFhirBase64Binary read GetItemN write SetItemN; default;
  End;

  // a complex Time - has an Id attribute, and extensions.
  //  Used where a FHIR element is a Time, and extensions
  TFhirTime = class (TFhirPrimitiveType)
  Private
    FValue: String;
    procedure setValue(value: String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    function AsStringValue : String; Override;
    procedure SetStringValue(value : String); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  Public
    constructor Create(value : String); overload;
    destructor Destroy; override;
    
    Function Link : TFhirTime; Overload;
    Function Clone : TFhirTime; Overload;
    procedure Assign(oSource : TFslObject); override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
    function fhirType : string; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The actual value of the time
    property value : String read FValue write SetValue;
  End;    

  TFhirTimeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTimeList;
    function GetCurrent : TFhirTime;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTimeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTime read GetCurrent;
  end;

  TFhirTimeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTime;
    procedure SetItemN(index : Integer; value : TFhirTime);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTimeList; Overload;
    function Clone : TFhirTimeList; Overload;
    function GetEnumerator : TFhirTimeListEnumerator;
    

    //  Add a FhirTime to the end of the list.
    function Append : TFhirTime;

    
    // Add an already existing FhirTime to the end of the list.
    procedure AddItem(value : TFhirTime); overload;

    
    // Add an already existing FhirTime to the end of the list.
    procedure AddItem(value : String); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTime) : Integer;
    

    // Insert FhirTime before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTime;
    

    // Insert an existing FhirTime before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTime);
    
    // Get the iIndexth FhirTime. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTime);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTime;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTimes[index : Integer] : TFhirTime read GetItemN write SetItemN; default;
  End;

  // a complex Decimal - has an Id attribute, and extensions.
  //  Used where a FHIR element is a Decimal, and extensions
  TFhirDecimal = class (TFhirPrimitiveType)
  Private
    FValue: String;
    procedure setValue(value: String);
  protected
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    function AsStringValue : String; Override;
    procedure SetStringValue(value : String); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  Public
    constructor Create(value : String); overload;
    destructor Destroy; override;
    
    Function Link : TFhirDecimal; Overload;
    Function Clone : TFhirDecimal; Overload;
    procedure Assign(oSource : TFslObject); override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
    function fhirType : string; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The actual value of the decimal
    property value : String read FValue write SetValue;
  End;    

  TFhirDecimalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDecimalList;
    function GetCurrent : TFhirDecimal;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDecimalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDecimal read GetCurrent;
  end;

  TFhirDecimalList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDecimal;
    procedure SetItemN(index : Integer; value : TFhirDecimal);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDecimalList; Overload;
    function Clone : TFhirDecimalList; Overload;
    function GetEnumerator : TFhirDecimalListEnumerator;
    

    //  Add a FhirDecimal to the end of the list.
    function Append : TFhirDecimal;

    
    // Add an already existing FhirDecimal to the end of the list.
    procedure AddItem(value : TFhirDecimal); overload;

    
    // Add an already existing FhirDecimal to the end of the list.
    procedure AddItem(value : String); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDecimal) : Integer;
    

    // Insert FhirDecimal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDecimal;
    

    // Insert an existing FhirDecimal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDecimal);
    
    // Get the iIndexth FhirDecimal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDecimal);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDecimal;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDecimals[index : Integer] : TFhirDecimal read GetItemN write SetItemN; default;
  End;

  // a complex Code - has an Id attribute, and extensions.
  //  Used where a FHIR element is a Code, and extensions
  TFhirCode = class (TFhirString)
  Private
  protected
    procedure listFieldsInOrder(fields : TStringList); override;
  Public
    constructor Create(value : String); overload;
    destructor Destroy; override;
    
    Function Link : TFhirCode; Overload;
    Function Clone : TFhirCode; Overload;
    function fhirType : string; override;
  End;    

  TFhirCodeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCodeList;
    function GetCurrent : TFhirCode;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCodeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCode read GetCurrent;
  end;

  TFhirCodeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCode;
    procedure SetItemN(index : Integer; value : TFhirCode);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCodeList; Overload;
    function Clone : TFhirCodeList; Overload;
    function GetEnumerator : TFhirCodeListEnumerator;
    

    //  Add a FhirCode to the end of the list.
    function Append : TFhirCode;

    
    // Add an already existing FhirCode to the end of the list.
    procedure AddItem(value : TFhirCode); overload;

    
    // Add an already existing FhirCode to the end of the list.
    procedure AddItem(value : String); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCode) : Integer;
    

    // Insert FhirCode before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCode;
    

    // Insert an existing FhirCode before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCode);
    
    // Get the iIndexth FhirCode. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCode);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCode;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCodes[index : Integer] : TFhirCode read GetItemN write SetItemN; default;
  End;

  // a complex Canonical - has an Id attribute, and extensions.
  //  Used where a FHIR element is a Canonical, and extensions
  TFhirCanonical = class (TFhirUri)
  Private
  protected
    procedure listFieldsInOrder(fields : TStringList); override;
  Public
    constructor Create(value : String); overload;
    destructor Destroy; override;
    
    Function Link : TFhirCanonical; Overload;
    Function Clone : TFhirCanonical; Overload;
    function fhirType : string; override;
  End;    

  TFhirCanonicalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCanonicalList;
    function GetCurrent : TFhirCanonical;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCanonicalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCanonical read GetCurrent;
  end;

  TFhirCanonicalList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCanonical;
    procedure SetItemN(index : Integer; value : TFhirCanonical);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCanonicalList; Overload;
    function Clone : TFhirCanonicalList; Overload;
    function GetEnumerator : TFhirCanonicalListEnumerator;
    

    //  Add a FhirCanonical to the end of the list.
    function Append : TFhirCanonical;

    
    // Add an already existing FhirCanonical to the end of the list.
    procedure AddItem(value : TFhirCanonical); overload;

    
    // Add an already existing FhirCanonical to the end of the list.
    procedure AddItem(value : String); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCanonical) : Integer;
    

    // Insert FhirCanonical before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCanonical;
    

    // Insert an existing FhirCanonical before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCanonical);
    
    // Get the iIndexth FhirCanonical. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCanonical);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCanonical;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCanonicals[index : Integer] : TFhirCanonical read GetItemN write SetItemN; default;
  End;

  // a complex Oid - has an Id attribute, and extensions.
  //  Used where a FHIR element is a Oid, and extensions
  TFhirOid = class (TFhirUri)
  Private
  protected
    procedure listFieldsInOrder(fields : TStringList); override;
  Public
    constructor Create(value : String); overload;
    destructor Destroy; override;
    
    Function Link : TFhirOid; Overload;
    Function Clone : TFhirOid; Overload;
    function fhirType : string; override;
  End;    

  TFhirOidListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOidList;
    function GetCurrent : TFhirOid;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOidList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOid read GetCurrent;
  end;

  TFhirOidList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOid;
    procedure SetItemN(index : Integer; value : TFhirOid);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOidList; Overload;
    function Clone : TFhirOidList; Overload;
    function GetEnumerator : TFhirOidListEnumerator;
    

    //  Add a FhirOid to the end of the list.
    function Append : TFhirOid;

    
    // Add an already existing FhirOid to the end of the list.
    procedure AddItem(value : TFhirOid); overload;

    
    // Add an already existing FhirOid to the end of the list.
    procedure AddItem(value : String); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOid) : Integer;
    

    // Insert FhirOid before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOid;
    

    // Insert an existing FhirOid before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOid);
    
    // Get the iIndexth FhirOid. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOid);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOid;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirOids[index : Integer] : TFhirOid read GetItemN write SetItemN; default;
  End;

  // a complex Uuid - has an Id attribute, and extensions.
  //  Used where a FHIR element is a Uuid, and extensions
  TFhirUuid = class (TFhirUri)
  Private
  protected
    procedure listFieldsInOrder(fields : TStringList); override;
  Public
    constructor Create(value : String); overload;
    destructor Destroy; override;
    
    Function Link : TFhirUuid; Overload;
    Function Clone : TFhirUuid; Overload;
    function fhirType : string; override;
  End;    

  TFhirUuidListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirUuidList;
    function GetCurrent : TFhirUuid;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirUuidList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirUuid read GetCurrent;
  end;

  TFhirUuidList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirUuid;
    procedure SetItemN(index : Integer; value : TFhirUuid);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirUuidList; Overload;
    function Clone : TFhirUuidList; Overload;
    function GetEnumerator : TFhirUuidListEnumerator;
    

    //  Add a FhirUuid to the end of the list.
    function Append : TFhirUuid;

    
    // Add an already existing FhirUuid to the end of the list.
    procedure AddItem(value : TFhirUuid); overload;

    
    // Add an already existing FhirUuid to the end of the list.
    procedure AddItem(value : String); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirUuid) : Integer;
    

    // Insert FhirUuid before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirUuid;
    

    // Insert an existing FhirUuid before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirUuid);
    
    // Get the iIndexth FhirUuid. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirUuid);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirUuid;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirUuids[index : Integer] : TFhirUuid read GetItemN write SetItemN; default;
  End;

  // a complex Url - has an Id attribute, and extensions.
  //  Used where a FHIR element is a Url, and extensions
  TFhirUrl = class (TFhirUri)
  Private
  protected
    procedure listFieldsInOrder(fields : TStringList); override;
  Public
    constructor Create(value : String); overload;
    destructor Destroy; override;
    
    Function Link : TFhirUrl; Overload;
    Function Clone : TFhirUrl; Overload;
    function fhirType : string; override;
  End;    

  TFhirUrlListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirUrlList;
    function GetCurrent : TFhirUrl;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirUrlList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirUrl read GetCurrent;
  end;

  TFhirUrlList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirUrl;
    procedure SetItemN(index : Integer; value : TFhirUrl);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirUrlList; Overload;
    function Clone : TFhirUrlList; Overload;
    function GetEnumerator : TFhirUrlListEnumerator;
    

    //  Add a FhirUrl to the end of the list.
    function Append : TFhirUrl;

    
    // Add an already existing FhirUrl to the end of the list.
    procedure AddItem(value : TFhirUrl); overload;

    
    // Add an already existing FhirUrl to the end of the list.
    procedure AddItem(value : String); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirUrl) : Integer;
    

    // Insert FhirUrl before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirUrl;
    

    // Insert an existing FhirUrl before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirUrl);
    
    // Get the iIndexth FhirUrl. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirUrl);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirUrl;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirUrls[index : Integer] : TFhirUrl read GetItemN write SetItemN; default;
  End;

  // a complex Markdown - has an Id attribute, and extensions.
  //  Used where a FHIR element is a Markdown, and extensions
  TFhirMarkdown = class (TFhirString)
  Private
  protected
    procedure listFieldsInOrder(fields : TStringList); override;
  Public
    constructor Create(value : String); overload;
    destructor Destroy; override;
    
    Function Link : TFhirMarkdown; Overload;
    Function Clone : TFhirMarkdown; Overload;
    function fhirType : string; override;
  End;    

  TFhirMarkdownListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMarkdownList;
    function GetCurrent : TFhirMarkdown;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMarkdownList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMarkdown read GetCurrent;
  end;

  TFhirMarkdownList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMarkdown;
    procedure SetItemN(index : Integer; value : TFhirMarkdown);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMarkdownList; Overload;
    function Clone : TFhirMarkdownList; Overload;
    function GetEnumerator : TFhirMarkdownListEnumerator;
    

    //  Add a FhirMarkdown to the end of the list.
    function Append : TFhirMarkdown;

    
    // Add an already existing FhirMarkdown to the end of the list.
    procedure AddItem(value : TFhirMarkdown); overload;

    
    // Add an already existing FhirMarkdown to the end of the list.
    procedure AddItem(value : String); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMarkdown) : Integer;
    

    // Insert FhirMarkdown before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMarkdown;
    

    // Insert an existing FhirMarkdown before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMarkdown);
    
    // Get the iIndexth FhirMarkdown. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMarkdown);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMarkdown;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMarkdowns[index : Integer] : TFhirMarkdown read GetItemN write SetItemN; default;
  End;

  // a complex UnsignedInt - has an Id attribute, and extensions.
  //  Used where a FHIR element is a UnsignedInt, and extensions
  TFhirUnsignedInt = class (TFhirInteger)
  Private
  protected
    procedure listFieldsInOrder(fields : TStringList); override;
  Public
    constructor Create(value : String); overload;
    destructor Destroy; override;
    
    Function Link : TFhirUnsignedInt; Overload;
    Function Clone : TFhirUnsignedInt; Overload;
    function fhirType : string; override;
  End;    

  TFhirUnsignedIntListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirUnsignedIntList;
    function GetCurrent : TFhirUnsignedInt;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirUnsignedIntList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirUnsignedInt read GetCurrent;
  end;

  TFhirUnsignedIntList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirUnsignedInt;
    procedure SetItemN(index : Integer; value : TFhirUnsignedInt);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirUnsignedIntList; Overload;
    function Clone : TFhirUnsignedIntList; Overload;
    function GetEnumerator : TFhirUnsignedIntListEnumerator;
    

    //  Add a FhirUnsignedInt to the end of the list.
    function Append : TFhirUnsignedInt;

    
    // Add an already existing FhirUnsignedInt to the end of the list.
    procedure AddItem(value : TFhirUnsignedInt); overload;

    
    // Add an already existing FhirUnsignedInt to the end of the list.
    procedure AddItem(value : String); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirUnsignedInt) : Integer;
    

    // Insert FhirUnsignedInt before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirUnsignedInt;
    

    // Insert an existing FhirUnsignedInt before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirUnsignedInt);
    
    // Get the iIndexth FhirUnsignedInt. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirUnsignedInt);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirUnsignedInt;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirUnsignedInts[index : Integer] : TFhirUnsignedInt read GetItemN write SetItemN; default;
  End;

  // a complex Id - has an Id attribute, and extensions.
  //  Used where a FHIR element is a Id, and extensions
  TFhirId = class (TFhirString)
  Private
  protected
    procedure listFieldsInOrder(fields : TStringList); override;
  Public
    constructor Create(value : String); overload;
    destructor Destroy; override;
    
    Function Link : TFhirId; Overload;
    Function Clone : TFhirId; Overload;
    function fhirType : string; override;
  End;    

  TFhirIdListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirIdList;
    function GetCurrent : TFhirId;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirIdList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirId read GetCurrent;
  end;

  TFhirIdList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirId;
    procedure SetItemN(index : Integer; value : TFhirId);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirIdList; Overload;
    function Clone : TFhirIdList; Overload;
    function GetEnumerator : TFhirIdListEnumerator;
    

    //  Add a FhirId to the end of the list.
    function Append : TFhirId;

    
    // Add an already existing FhirId to the end of the list.
    procedure AddItem(value : TFhirId); overload;

    
    // Add an already existing FhirId to the end of the list.
    procedure AddItem(value : String); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirId) : Integer;
    

    // Insert FhirId before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirId;
    

    // Insert an existing FhirId before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirId);
    
    // Get the iIndexth FhirId. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirId);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirId;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirIds[index : Integer] : TFhirId read GetItemN write SetItemN; default;
  End;

  // a complex PositiveInt - has an Id attribute, and extensions.
  //  Used where a FHIR element is a PositiveInt, and extensions
  TFhirPositiveInt = class (TFhirInteger)
  Private
  protected
    procedure listFieldsInOrder(fields : TStringList); override;
  Public
    constructor Create(value : String); overload;
    destructor Destroy; override;
    
    Function Link : TFhirPositiveInt; Overload;
    Function Clone : TFhirPositiveInt; Overload;
    function fhirType : string; override;
  End;    

  TFhirPositiveIntListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPositiveIntList;
    function GetCurrent : TFhirPositiveInt;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPositiveIntList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPositiveInt read GetCurrent;
  end;

  TFhirPositiveIntList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPositiveInt;
    procedure SetItemN(index : Integer; value : TFhirPositiveInt);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPositiveIntList; Overload;
    function Clone : TFhirPositiveIntList; Overload;
    function GetEnumerator : TFhirPositiveIntListEnumerator;
    

    //  Add a FhirPositiveInt to the end of the list.
    function Append : TFhirPositiveInt;

    
    // Add an already existing FhirPositiveInt to the end of the list.
    procedure AddItem(value : TFhirPositiveInt); overload;

    
    // Add an already existing FhirPositiveInt to the end of the list.
    procedure AddItem(value : String); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPositiveInt) : Integer;
    

    // Insert FhirPositiveInt before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPositiveInt;
    

    // Insert an existing FhirPositiveInt before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPositiveInt);
    
    // Get the iIndexth FhirPositiveInt. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPositiveInt);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPositiveInt;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirPositiveInts[index : Integer] : TFhirPositiveInt read GetItemN write SetItemN; default;
  End;

  // Optional Extension Element - found in all resources.
  TFhirExtension = class (TFHIRType)
  protected
    FUrl : TFhirString;
    FValue : TFhirType;
    Procedure SetUrl(value : TFhirString);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetValue(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExtension; overload;
    function Clone : TFhirExtension; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Source of the definition for the extension code - a logical name or a URL.
    property url : String read GetUrlST write SetUrlST;
    // Source of the definition for the extension code - a logical name or a URL.
    property urlElement : TFhirString read FUrl write SetUrl;

    // Typed access to Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list). (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // Value of extension - must be one of a constrained set of the data types (see [Extensibility](extensibility.html) for a list).
    property valueElement : TFhirType read FValue write SetValue;

  end;

  TFhirExtensionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExtensionList;
    function GetCurrent : TFhirExtension;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExtensionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExtension read GetCurrent;
  end;

  TFhirExtensionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExtension;
    procedure SetItemN(index : Integer; value : TFhirExtension);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExtensionList; Overload;
    function Clone : TFhirExtensionList; Overload;
    function GetEnumerator : TFhirExtensionListEnumerator;
    

    //  Add a FhirExtension to the end of the list.
    function Append : TFhirExtension;

    
    // Add an already existing FhirExtension to the end of the list.
    procedure AddItem(value : TFhirExtension); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExtension) : Integer;
    

    // Insert FhirExtension before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExtension;
    

    // Insert an existing FhirExtension before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExtension);
    
    // Get the iIndexth FhirExtension. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExtension);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExtension;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExtensions[index : Integer] : TFhirExtension read GetItemN write SetItemN; default;
  End;

  // A human-readable summary of the resource conveying the essential clinical and business information for the resource.
  TFhirNarrative = class (TFHIRType)
  protected
    FStatus : TFhirEnum;
    FDiv_ : TFhirXHtmlNode;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirNarrativeStatusEnum;
    Procedure SetStatusST(value : TFhirNarrativeStatusEnum);
    Procedure SetDiv_(value : TFhirXHtmlNode);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNarrative; overload;
    function Clone : TFhirNarrative; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The status of the narrative - whether it's entirely generated (from just the defined data or the extensions too), or whether a human authored it and it may contain additional data.
    property status : TFhirNarrativeStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The actual narrative content, a stripped down version of XHTML. (defined for API consistency)
    property div_ : TFhirXHtmlNode read FDiv_ write SetDiv_;
    // The actual narrative content, a stripped down version of XHTML.
    property div_Element : TFhirXHtmlNode read FDiv_ write SetDiv_;

  end;

  TFhirNarrativeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNarrativeList;
    function GetCurrent : TFhirNarrative;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNarrativeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNarrative read GetCurrent;
  end;

  TFhirNarrativeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirNarrative;
    procedure SetItemN(index : Integer; value : TFhirNarrative);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirNarrativeList; Overload;
    function Clone : TFhirNarrativeList; Overload;
    function GetEnumerator : TFhirNarrativeListEnumerator;
    

    //  Add a FhirNarrative to the end of the list.
    function Append : TFhirNarrative;

    
    // Add an already existing FhirNarrative to the end of the list.
    procedure AddItem(value : TFhirNarrative); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNarrative) : Integer;
    

    // Insert FhirNarrative before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNarrative;
    

    // Insert an existing FhirNarrative before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNarrative);
    
    // Get the iIndexth FhirNarrative. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNarrative);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNarrative;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirNarratives[index : Integer] : TFhirNarrative read GetItemN write SetItemN; default;
  End;

  // A contributor to the content of a knowledge asset, including authors, editors, reviewers, and endorsers.
  TFhirContributor = class (TFhirType)
  protected
    FType_ : TFhirEnum;
    FName : TFhirString;
    FcontactList : TFhirContactDetailList;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirContributorTypeEnum;
    Procedure SetType_ST(value : TFhirContributorTypeEnum);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContributor; overload;
    function Clone : TFhirContributor; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The type of contributor.
    property type_ : TFhirContributorTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The name of the individual or organization responsible for the contribution.
    property name : String read GetNameST write SetNameST;
    // The name of the individual or organization responsible for the contribution.
    property nameElement : TFhirString read FName write SetName;

    // Contact details to assist a user in finding and communicating with the contributor.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

  end;

  TFhirContributorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContributorList;
    function GetCurrent : TFhirContributor;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContributorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContributor read GetCurrent;
  end;

  TFhirContributorList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContributor;
    procedure SetItemN(index : Integer; value : TFhirContributor);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContributorList; Overload;
    function Clone : TFhirContributorList; Overload;
    function GetEnumerator : TFhirContributorListEnumerator;
    

    //  Add a FhirContributor to the end of the list.
    function Append : TFhirContributor;

    
    // Add an already existing FhirContributor to the end of the list.
    procedure AddItem(value : TFhirContributor); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContributor) : Integer;
    

    // Insert FhirContributor before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContributor;
    

    // Insert an existing FhirContributor before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContributor);
    
    // Get the iIndexth FhirContributor. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContributor);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContributor;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirContributors[index : Integer] : TFhirContributor read GetItemN write SetItemN; default;
  End;

  // For referring to data content defined in other formats.
  TFhirAttachment = class (TFhirType)
  protected
    FContentType : TFhirCode;
    FLanguage : TFhirCode;
    FData : TFhirBase64Binary;
    FUrl : TFhirUrl;
    FSize : TFhirUnsignedInt;
    FHash : TFhirBase64Binary;
    FTitle : TFhirString;
    FCreation : TFhirDateTime;
    Procedure SetContentType(value : TFhirCode);
    Function GetContentTypeST : String;
    Procedure SetContentTypeST(value : String);
    Procedure SetLanguage(value : TFhirCode);
    Function GetLanguageST : String;
    Procedure SetLanguageST(value : String);
    Procedure SetData(value : TFhirBase64Binary);
    Function GetDataST : TBytes;
    Procedure SetDataST(value : TBytes);
    Procedure SetUrl(value : TFhirUrl);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetSize(value : TFhirUnsignedInt);
    Function GetSizeST : String;
    Procedure SetSizeST(value : String);
    Procedure SetHash(value : TFhirBase64Binary);
    Function GetHashST : TBytes;
    Procedure SetHashST(value : TBytes);
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetCreation(value : TFhirDateTime);
    Function GetCreationST : TFslDateTime;
    Procedure SetCreationST(value : TFslDateTime);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAttachment; overload;
    function Clone : TFhirAttachment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Identifies the type of the data in the attachment and allows a method to be chosen to interpret or render the data. Includes mime type parameters such as charset where appropriate.
    property contentType : String read GetContentTypeST write SetContentTypeST;
    // Identifies the type of the data in the attachment and allows a method to be chosen to interpret or render the data. Includes mime type parameters such as charset where appropriate.
    property contentTypeElement : TFhirCode read FContentType write SetContentType;

    // Typed access to The human language of the content. The value can be any valid value according to BCP 47.
    property language : String read GetLanguageST write SetLanguageST;
    // The human language of the content. The value can be any valid value according to BCP 47.
    property languageElement : TFhirCode read FLanguage write SetLanguage;

    // Typed access to The actual data of the attachment - a sequence of bytes, base64 encoded.
    property data : TBytes read GetDataST write SetDataST;
    // The actual data of the attachment - a sequence of bytes, base64 encoded.
    property dataElement : TFhirBase64Binary read FData write SetData;

    // Typed access to A location where the data can be accessed.
    property url : String read GetUrlST write SetUrlST;
    // A location where the data can be accessed.
    property urlElement : TFhirUrl read FUrl write SetUrl;

    // Typed access to The number of bytes of data that make up this attachment (before base64 encoding, if that is done).
    property size : String read GetSizeST write SetSizeST;
    // The number of bytes of data that make up this attachment (before base64 encoding, if that is done).
    property sizeElement : TFhirUnsignedInt read FSize write SetSize;

    // Typed access to The calculated hash of the data using SHA-1. Represented using base64.
    property hash : TBytes read GetHashST write SetHashST;
    // The calculated hash of the data using SHA-1. Represented using base64.
    property hashElement : TFhirBase64Binary read FHash write SetHash;

    // Typed access to A label or set of text to display in place of the data.
    property title : String read GetTitleST write SetTitleST;
    // A label or set of text to display in place of the data.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to The date that the attachment was first created.
    property creation : TFslDateTime read GetCreationST write SetCreationST;
    // The date that the attachment was first created.
    property creationElement : TFhirDateTime read FCreation write SetCreation;

  end;

  TFhirAttachmentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAttachmentList;
    function GetCurrent : TFhirAttachment;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAttachmentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAttachment read GetCurrent;
  end;

  TFhirAttachmentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAttachment;
    procedure SetItemN(index : Integer; value : TFhirAttachment);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAttachmentList; Overload;
    function Clone : TFhirAttachmentList; Overload;
    function GetEnumerator : TFhirAttachmentListEnumerator;
    

    //  Add a FhirAttachment to the end of the list.
    function Append : TFhirAttachment;

    
    // Add an already existing FhirAttachment to the end of the list.
    procedure AddItem(value : TFhirAttachment); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAttachment) : Integer;
    

    // Insert FhirAttachment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAttachment;
    

    // Insert an existing FhirAttachment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAttachment);
    
    // Get the iIndexth FhirAttachment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAttachment);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAttachment;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirAttachments[index : Integer] : TFhirAttachment read GetItemN write SetItemN; default;
  End;

  // Code filters specify additional constraints on the data, specifying the value set of interest for a particular element of the data. Each code filter defines an additional constraint on the data, i.e. code filters are AND'ed, not OR'ed.
  TFhirDataRequirementCodeFilter = class (TFhirElement)
  protected
    FPath : TFhirString;
    FSearchParam : TFhirString;
    FValueSet : TFhirCanonical;
    FcodeList : TFhirCodingList;
    Procedure SetPath(value : TFhirString);
    Function GetPathST : String;
    Procedure SetPathST(value : String);
    Procedure SetSearchParam(value : TFhirString);
    Function GetSearchParamST : String;
    Procedure SetSearchParamST(value : String);
    Procedure SetValueSet(value : TFhirCanonical);
    Function GetValueSetST : String;
    Procedure SetValueSetST(value : String);
    function GetCodeList : TFhirCodingList;
    function GetHasCodeList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDataRequirementCodeFilter; overload;
    function Clone : TFhirDataRequirementCodeFilter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The code-valued attribute of the filter. The specified path SHALL be a FHIRPath resolveable on the specified type of the DataRequirement, and SHALL consist only of identifiers, constant indexers, and .resolve(). The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details). Note that the index must be an integer constant. The path must resolve to an element of type code, Coding, or CodeableConcept.
    property path : String read GetPathST write SetPathST;
    // The code-valued attribute of the filter. The specified path SHALL be a FHIRPath resolveable on the specified type of the DataRequirement, and SHALL consist only of identifiers, constant indexers, and .resolve(). The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details). Note that the index must be an integer constant. The path must resolve to an element of type code, Coding, or CodeableConcept.
    property pathElement : TFhirString read FPath write SetPath;

    // Typed access to A token parameter that refers to a search parameter defined on the specified type of the DataRequirement, and which searches on elements of type code, Coding, or CodeableConcept.
    property searchParam : String read GetSearchParamST write SetSearchParamST;
    // A token parameter that refers to a search parameter defined on the specified type of the DataRequirement, and which searches on elements of type code, Coding, or CodeableConcept.
    property searchParamElement : TFhirString read FSearchParam write SetSearchParam;

    // Typed access to The valueset for the code filter. The valueSet and code elements are additive. If valueSet is specified, the filter will return only those data items for which the value of the code-valued element specified in the path is a member of the specified valueset.
    property valueSet : String read GetValueSetST write SetValueSetST;
    // The valueset for the code filter. The valueSet and code elements are additive. If valueSet is specified, the filter will return only those data items for which the value of the code-valued element specified in the path is a member of the specified valueset.
    property valueSetElement : TFhirCanonical read FValueSet write SetValueSet;

    // The codes for the code filter. If values are given, the filter will return only those data items for which the code-valued attribute specified by the path has a value that is one of the specified codes. If codes are specified in addition to a value set, the filter returns items matching a code in the value set or one of the specified codes.
    property codeList : TFhirCodingList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

  end;

  TFhirDataRequirementCodeFilterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDataRequirementCodeFilterList;
    function GetCurrent : TFhirDataRequirementCodeFilter;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDataRequirementCodeFilterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDataRequirementCodeFilter read GetCurrent;
  end;

  TFhirDataRequirementCodeFilterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDataRequirementCodeFilter;
    procedure SetItemN(index : Integer; value : TFhirDataRequirementCodeFilter);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDataRequirementCodeFilterList; Overload;
    function Clone : TFhirDataRequirementCodeFilterList; Overload;
    function GetEnumerator : TFhirDataRequirementCodeFilterListEnumerator;
    

    //  Add a FhirDataRequirementCodeFilter to the end of the list.
    function Append : TFhirDataRequirementCodeFilter;

    
    // Add an already existing FhirDataRequirementCodeFilter to the end of the list.
    procedure AddItem(value : TFhirDataRequirementCodeFilter); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDataRequirementCodeFilter) : Integer;
    

    // Insert FhirDataRequirementCodeFilter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDataRequirementCodeFilter;
    

    // Insert an existing FhirDataRequirementCodeFilter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDataRequirementCodeFilter);
    
    // Get the iIndexth FhirDataRequirementCodeFilter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDataRequirementCodeFilter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDataRequirementCodeFilter;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDataRequirementCodeFilters[index : Integer] : TFhirDataRequirementCodeFilter read GetItemN write SetItemN; default;
  End;

  // Date filters specify additional constraints on the data in terms of the applicable date range for specific elements. Each date filter specifies an additional constraint on the data, i.e. date filters are AND'ed, not OR'ed.
  TFhirDataRequirementDateFilter = class (TFhirElement)
  protected
    FPath : TFhirString;
    FSearchParam : TFhirString;
    FValue : TFhirType;
    Procedure SetPath(value : TFhirString);
    Function GetPathST : String;
    Procedure SetPathST(value : String);
    Procedure SetSearchParam(value : TFhirString);
    Function GetSearchParamST : String;
    Procedure SetSearchParamST(value : String);
    Procedure SetValue(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDataRequirementDateFilter; overload;
    function Clone : TFhirDataRequirementDateFilter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The date-valued attribute of the filter. The specified path SHALL be a FHIRPath resolveable on the specified type of the DataRequirement, and SHALL consist only of identifiers, constant indexers, and .resolve(). The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details). Note that the index must be an integer constant. The path must resolve to an element of type date, dateTime, Period, Schedule, or Timing.
    property path : String read GetPathST write SetPathST;
    // The date-valued attribute of the filter. The specified path SHALL be a FHIRPath resolveable on the specified type of the DataRequirement, and SHALL consist only of identifiers, constant indexers, and .resolve(). The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details). Note that the index must be an integer constant. The path must resolve to an element of type date, dateTime, Period, Schedule, or Timing.
    property pathElement : TFhirString read FPath write SetPath;

    // Typed access to A date parameter that refers to a search parameter defined on the specified type of the DataRequirement, and which searches on elements of type date, dateTime, Period, Schedule, or Timing.
    property searchParam : String read GetSearchParamST write SetSearchParamST;
    // A date parameter that refers to a search parameter defined on the specified type of the DataRequirement, and which searches on elements of type date, dateTime, Period, Schedule, or Timing.
    property searchParamElement : TFhirString read FSearchParam write SetSearchParam;

    // Typed access to The value of the filter. If period is specified, the filter will return only those data items that fall within the bounds determined by the Period, inclusive of the period boundaries. If dateTime is specified, the filter will return only those data items that are equal to the specified dateTime. If a Duration is specified, the filter will return only those data items that fall within Duration before now. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // The value of the filter. If period is specified, the filter will return only those data items that fall within the bounds determined by the Period, inclusive of the period boundaries. If dateTime is specified, the filter will return only those data items that are equal to the specified dateTime. If a Duration is specified, the filter will return only those data items that fall within Duration before now.
    property valueElement : TFhirType read FValue write SetValue;

  end;

  TFhirDataRequirementDateFilterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDataRequirementDateFilterList;
    function GetCurrent : TFhirDataRequirementDateFilter;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDataRequirementDateFilterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDataRequirementDateFilter read GetCurrent;
  end;

  TFhirDataRequirementDateFilterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDataRequirementDateFilter;
    procedure SetItemN(index : Integer; value : TFhirDataRequirementDateFilter);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDataRequirementDateFilterList; Overload;
    function Clone : TFhirDataRequirementDateFilterList; Overload;
    function GetEnumerator : TFhirDataRequirementDateFilterListEnumerator;
    

    //  Add a FhirDataRequirementDateFilter to the end of the list.
    function Append : TFhirDataRequirementDateFilter;

    
    // Add an already existing FhirDataRequirementDateFilter to the end of the list.
    procedure AddItem(value : TFhirDataRequirementDateFilter); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDataRequirementDateFilter) : Integer;
    

    // Insert FhirDataRequirementDateFilter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDataRequirementDateFilter;
    

    // Insert an existing FhirDataRequirementDateFilter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDataRequirementDateFilter);
    
    // Get the iIndexth FhirDataRequirementDateFilter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDataRequirementDateFilter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDataRequirementDateFilter;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDataRequirementDateFilters[index : Integer] : TFhirDataRequirementDateFilter read GetItemN write SetItemN; default;
  End;

  // Specifies the order of the results to be returned.
  TFhirDataRequirementSort = class (TFhirElement)
  protected
    FPath : TFhirString;
    FDirection : TFhirEnum;
    Procedure SetPath(value : TFhirString);
    Function GetPathST : String;
    Procedure SetPathST(value : String);
    Procedure SetDirection(value : TFhirEnum);
    Function GetDirectionST : TFhirSortDirectionEnum;
    Procedure SetDirectionST(value : TFhirSortDirectionEnum);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDataRequirementSort; overload;
    function Clone : TFhirDataRequirementSort; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The attribute of the sort. The specified path must be resolvable from the type of the required data. The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements. Note that the index must be an integer constant.
    property path : String read GetPathST write SetPathST;
    // The attribute of the sort. The specified path must be resolvable from the type of the required data. The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements. Note that the index must be an integer constant.
    property pathElement : TFhirString read FPath write SetPath;

    // The direction of the sort, ascending or descending.
    property direction : TFhirSortDirectionEnum read GetDirectionST write SetDirectionST;
    property directionElement : TFhirEnum read FDirection write SetDirection;

  end;

  TFhirDataRequirementSortListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDataRequirementSortList;
    function GetCurrent : TFhirDataRequirementSort;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDataRequirementSortList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDataRequirementSort read GetCurrent;
  end;

  TFhirDataRequirementSortList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDataRequirementSort;
    procedure SetItemN(index : Integer; value : TFhirDataRequirementSort);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDataRequirementSortList; Overload;
    function Clone : TFhirDataRequirementSortList; Overload;
    function GetEnumerator : TFhirDataRequirementSortListEnumerator;
    

    //  Add a FhirDataRequirementSort to the end of the list.
    function Append : TFhirDataRequirementSort;

    
    // Add an already existing FhirDataRequirementSort to the end of the list.
    procedure AddItem(value : TFhirDataRequirementSort); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDataRequirementSort) : Integer;
    

    // Insert FhirDataRequirementSort before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDataRequirementSort;
    

    // Insert an existing FhirDataRequirementSort before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDataRequirementSort);
    
    // Get the iIndexth FhirDataRequirementSort. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDataRequirementSort);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDataRequirementSort;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDataRequirementSorts[index : Integer] : TFhirDataRequirementSort read GetItemN write SetItemN; default;
  End;

  // Describes a required data item for evaluation in terms of the type of data, and optional code or date-based filters of the data.
  TFhirDataRequirement = class (TFhirType)
  protected
    FType_ : TFhirEnum;
    FprofileList : TFhirCanonicalList;
    FSubject : TFhirType;
    FmustSupportList : TFhirStringList;
    FcodeFilterList : TFhirDataRequirementCodeFilterList;
    FdateFilterList : TFhirDataRequirementDateFilterList;
    FLimit : TFhirPositiveInt;
    FsortList : TFhirDataRequirementSortList;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirAllTypesEnum;
    Procedure SetType_ST(value : TFhirAllTypesEnum);
    function GetProfileList : TFhirCanonicalList;
    function GetHasProfileList : Boolean;
    Procedure SetSubject(value : TFhirType);
    function GetMustSupportList : TFhirStringList;
    function GetHasMustSupportList : Boolean;
    function GetCodeFilterList : TFhirDataRequirementCodeFilterList;
    function GetHasCodeFilterList : Boolean;
    function GetDateFilterList : TFhirDataRequirementDateFilterList;
    function GetHasDateFilterList : Boolean;
    Procedure SetLimit(value : TFhirPositiveInt);
    Function GetLimitST : String;
    Procedure SetLimitST(value : String);
    function GetSortList : TFhirDataRequirementSortList;
    function GetHasSortList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDataRequirement; overload;
    function Clone : TFhirDataRequirement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The type of the required data, specified as the type name of a resource. For profiles, this value is set to the type of the base resource of the profile.
    property type_ : TFhirAllTypesEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // The profile of the required data, specified as the uri of the profile definition.
    property profileList : TFhirCanonicalList read GetProfileList;
    property hasProfileList : boolean read GetHasProfileList;

    // Typed access to The intended subjects of the data requirement. If this element is not provided, a Patient subject is assumed. (defined for API consistency)
    property subject : TFhirType read FSubject write SetSubject;
    // The intended subjects of the data requirement. If this element is not provided, a Patient subject is assumed.
    property subjectElement : TFhirType read FSubject write SetSubject;

    // Indicates that specific elements of the type are referenced by the knowledge module and must be supported by the consumer in order to obtain an effective evaluation. This does not mean that a value is required for this element, only that the consuming system must understand the element and be able to provide values for it if they are available.   The value of mustSupport SHALL be a FHIRPath resolveable on the type of the DataRequirement. The path SHALL consist only of identifiers, constant indexers, and .resolve() (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details).
    property mustSupportList : TFhirStringList read GetMustSupportList;
    property hasMustSupportList : boolean read GetHasMustSupportList;

    // Code filters specify additional constraints on the data, specifying the value set of interest for a particular element of the data. Each code filter defines an additional constraint on the data, i.e. code filters are AND'ed, not OR'ed.
    property codeFilterList : TFhirDataRequirementCodeFilterList read GetCodeFilterList;
    property hasCodeFilterList : boolean read GetHasCodeFilterList;

    // Date filters specify additional constraints on the data in terms of the applicable date range for specific elements. Each date filter specifies an additional constraint on the data, i.e. date filters are AND'ed, not OR'ed.
    property dateFilterList : TFhirDataRequirementDateFilterList read GetDateFilterList;
    property hasDateFilterList : boolean read GetHasDateFilterList;

    // Typed access to Specifies a maximum number of results that are required (uses the _count search parameter).
    property limit : String read GetLimitST write SetLimitST;
    // Specifies a maximum number of results that are required (uses the _count search parameter).
    property limitElement : TFhirPositiveInt read FLimit write SetLimit;

    // Specifies the order of the results to be returned.
    property sortList : TFhirDataRequirementSortList read GetSortList;
    property hasSortList : boolean read GetHasSortList;

  end;

  TFhirDataRequirementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDataRequirementList;
    function GetCurrent : TFhirDataRequirement;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDataRequirementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDataRequirement read GetCurrent;
  end;

  TFhirDataRequirementList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDataRequirement;
    procedure SetItemN(index : Integer; value : TFhirDataRequirement);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDataRequirementList; Overload;
    function Clone : TFhirDataRequirementList; Overload;
    function GetEnumerator : TFhirDataRequirementListEnumerator;
    

    //  Add a FhirDataRequirement to the end of the list.
    function Append : TFhirDataRequirement;

    
    // Add an already existing FhirDataRequirement to the end of the list.
    procedure AddItem(value : TFhirDataRequirement); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDataRequirement) : Integer;
    

    // Insert FhirDataRequirement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDataRequirement;
    

    // Insert an existing FhirDataRequirement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDataRequirement);
    
    // Get the iIndexth FhirDataRequirement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDataRequirement);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDataRequirement;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDataRequirements[index : Integer] : TFhirDataRequirement read GetItemN write SetItemN; default;
  End;

  // The amount of medication administered.
  TFhirDosageDoseAndRate = class (TFhirElement)
  protected
    FType_ : TFhirCodeableConcept;
    FDose : TFhirType;
    FRate : TFhirType;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetDose(value : TFhirType);
    Procedure SetRate(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDosageDoseAndRate; overload;
    function Clone : TFhirDosageDoseAndRate; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The kind of dose or rate specified, for example, ordered or calculated. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of dose or rate specified, for example, ordered or calculated.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Amount of medication per dose. (defined for API consistency)
    property dose : TFhirType read FDose write SetDose;
    // Amount of medication per dose.
    property doseElement : TFhirType read FDose write SetDose;

    // Typed access to Amount of medication per unit of time. (defined for API consistency)
    property rate : TFhirType read FRate write SetRate;
    // Amount of medication per unit of time.
    property rateElement : TFhirType read FRate write SetRate;

  end;

  TFhirDosageDoseAndRateListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDosageDoseAndRateList;
    function GetCurrent : TFhirDosageDoseAndRate;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDosageDoseAndRateList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDosageDoseAndRate read GetCurrent;
  end;

  TFhirDosageDoseAndRateList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDosageDoseAndRate;
    procedure SetItemN(index : Integer; value : TFhirDosageDoseAndRate);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDosageDoseAndRateList; Overload;
    function Clone : TFhirDosageDoseAndRateList; Overload;
    function GetEnumerator : TFhirDosageDoseAndRateListEnumerator;
    

    //  Add a FhirDosageDoseAndRate to the end of the list.
    function Append : TFhirDosageDoseAndRate;

    
    // Add an already existing FhirDosageDoseAndRate to the end of the list.
    procedure AddItem(value : TFhirDosageDoseAndRate); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDosageDoseAndRate) : Integer;
    

    // Insert FhirDosageDoseAndRate before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDosageDoseAndRate;
    

    // Insert an existing FhirDosageDoseAndRate before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDosageDoseAndRate);
    
    // Get the iIndexth FhirDosageDoseAndRate. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDosageDoseAndRate);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDosageDoseAndRate;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDosageDoseAndRates[index : Integer] : TFhirDosageDoseAndRate read GetItemN write SetItemN; default;
  End;

  // Indicates how the medication is/was taken or should be taken by the patient.
  TFhirDosage = class (TFHIRBackboneType)
  protected
    FSequence : TFhirInteger;
    FText : TFhirString;
    FadditionalInstructionList : TFhirCodeableConceptList;
    FPatientInstruction : TFhirString;
    FTiming : TFhirTiming;
    FAsNeeded : TFhirType;
    FSite : TFhirCodeableConcept;
    FRoute : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FdoseAndRateList : TFhirDosageDoseAndRateList;
    FMaxDosePerPeriod : TFhirRatio;
    FMaxDosePerAdministration : TFhirQuantity;
    FMaxDosePerLifetime : TFhirQuantity;
    Procedure SetSequence(value : TFhirInteger);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    function GetAdditionalInstructionList : TFhirCodeableConceptList;
    function GetHasAdditionalInstructionList : Boolean;
    Procedure SetPatientInstruction(value : TFhirString);
    Function GetPatientInstructionST : String;
    Procedure SetPatientInstructionST(value : String);
    Procedure SetTiming(value : TFhirTiming);
    Procedure SetAsNeeded(value : TFhirType);
    Procedure SetSite(value : TFhirCodeableConcept);
    Procedure SetRoute(value : TFhirCodeableConcept);
    Procedure SetMethod(value : TFhirCodeableConcept);
    function GetDoseAndRateList : TFhirDosageDoseAndRateList;
    function GetHasDoseAndRateList : Boolean;
    Procedure SetMaxDosePerPeriod(value : TFhirRatio);
    Procedure SetMaxDosePerAdministration(value : TFhirQuantity);
    Procedure SetMaxDosePerLifetime(value : TFhirQuantity);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDosage; overload;
    function Clone : TFhirDosage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Indicates the order in which the dosage instructions should be applied or interpreted.
    property sequence : String read GetSequenceST write SetSequenceST;
    // Indicates the order in which the dosage instructions should be applied or interpreted.
    property sequenceElement : TFhirInteger read FSequence write SetSequence;

    // Typed access to Free text dosage instructions e.g. SIG.
    property text : String read GetTextST write SetTextST;
    // Free text dosage instructions e.g. SIG.
    property textElement : TFhirString read FText write SetText;

    // Supplemental instructions to the patient on how to take the medication  (e.g. "with meals" or"take half to one hour before food") or warnings for the patient about the medication (e.g. "may cause drowsiness" or "avoid exposure of skin to direct sunlight or sunlamps").
    property additionalInstructionList : TFhirCodeableConceptList read GetAdditionalInstructionList;
    property hasAdditionalInstructionList : boolean read GetHasAdditionalInstructionList;

    // Typed access to Instructions in terms that are understood by the patient or consumer.
    property patientInstruction : String read GetPatientInstructionST write SetPatientInstructionST;
    // Instructions in terms that are understood by the patient or consumer.
    property patientInstructionElement : TFhirString read FPatientInstruction write SetPatientInstruction;

    // Typed access to When medication should be administered. (defined for API consistency)
    property timing : TFhirTiming read FTiming write SetTiming;
    // When medication should be administered.
    property timingElement : TFhirTiming read FTiming write SetTiming;

    // Typed access to Indicates whether the Medication is only taken when needed within a specific dosing schedule (Boolean option), or it indicates the precondition for taking the Medication (CodeableConcept). (defined for API consistency)
    property asNeeded : TFhirType read FAsNeeded write SetAsNeeded;
    // Indicates whether the Medication is only taken when needed within a specific dosing schedule (Boolean option), or it indicates the precondition for taking the Medication (CodeableConcept).
    property asNeededElement : TFhirType read FAsNeeded write SetAsNeeded;

    // Typed access to Body site to administer to. (defined for API consistency)
    property site : TFhirCodeableConcept read FSite write SetSite;
    // Body site to administer to.
    property siteElement : TFhirCodeableConcept read FSite write SetSite;

    // Typed access to How drug should enter body. (defined for API consistency)
    property route : TFhirCodeableConcept read FRoute write SetRoute;
    // How drug should enter body.
    property routeElement : TFhirCodeableConcept read FRoute write SetRoute;

    // Typed access to Technique for administering medication. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // Technique for administering medication.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // The amount of medication administered.
    property doseAndRateList : TFhirDosageDoseAndRateList read GetDoseAndRateList;
    property hasDoseAndRateList : boolean read GetHasDoseAndRateList;

    // Typed access to Upper limit on medication per unit of time. (defined for API consistency)
    property maxDosePerPeriod : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;
    // Upper limit on medication per unit of time.
    property maxDosePerPeriodElement : TFhirRatio read FMaxDosePerPeriod write SetMaxDosePerPeriod;

    // Typed access to Upper limit on medication per administration. (defined for API consistency)
    property maxDosePerAdministration : TFhirQuantity read FMaxDosePerAdministration write SetMaxDosePerAdministration;
    // Upper limit on medication per administration.
    property maxDosePerAdministrationElement : TFhirQuantity read FMaxDosePerAdministration write SetMaxDosePerAdministration;

    // Typed access to Upper limit on medication per lifetime of the patient. (defined for API consistency)
    property maxDosePerLifetime : TFhirQuantity read FMaxDosePerLifetime write SetMaxDosePerLifetime;
    // Upper limit on medication per lifetime of the patient.
    property maxDosePerLifetimeElement : TFhirQuantity read FMaxDosePerLifetime write SetMaxDosePerLifetime;

  end;

  TFhirDosageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDosageList;
    function GetCurrent : TFhirDosage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDosageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDosage read GetCurrent;
  end;

  TFhirDosageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDosage;
    procedure SetItemN(index : Integer; value : TFhirDosage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDosageList; Overload;
    function Clone : TFhirDosageList; Overload;
    function GetEnumerator : TFhirDosageListEnumerator;
    

    //  Add a FhirDosage to the end of the list.
    function Append : TFhirDosage;

    
    // Add an already existing FhirDosage to the end of the list.
    procedure AddItem(value : TFhirDosage); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDosage) : Integer;
    

    // Insert FhirDosage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDosage;
    

    // Insert an existing FhirDosage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDosage);
    
    // Get the iIndexth FhirDosage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDosage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDosage;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDosages[index : Integer] : TFhirDosage read GetItemN write SetItemN; default;
  End;

  // An amount of economic utility in some recognized currency.
  TFhirMoney = class (TFhirType)
  protected
    FValue : TFhirDecimal;
    FCurrency : TFhirCode;
    Procedure SetValue(value : TFhirDecimal);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
    Procedure SetCurrency(value : TFhirCode);
    Function GetCurrencyST : String;
    Procedure SetCurrencyST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMoney; overload;
    function Clone : TFhirMoney; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Numerical value (with implicit precision).
    property value : String read GetValueST write SetValueST;
    // Numerical value (with implicit precision).
    property valueElement : TFhirDecimal read FValue write SetValue;

    // Typed access to ISO 4217 Currency Code.
    property currency : String read GetCurrencyST write SetCurrencyST;
    // ISO 4217 Currency Code.
    property currencyElement : TFhirCode read FCurrency write SetCurrency;

  end;

  TFhirMoneyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMoneyList;
    function GetCurrent : TFhirMoney;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMoneyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMoney read GetCurrent;
  end;

  TFhirMoneyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMoney;
    procedure SetItemN(index : Integer; value : TFhirMoney);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMoneyList; Overload;
    function Clone : TFhirMoneyList; Overload;
    function GetEnumerator : TFhirMoneyListEnumerator;
    

    //  Add a FhirMoney to the end of the list.
    function Append : TFhirMoney;

    
    // Add an already existing FhirMoney to the end of the list.
    procedure AddItem(value : TFhirMoney); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMoney) : Integer;
    

    // Insert FhirMoney before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMoney;
    

    // Insert an existing FhirMoney before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMoney);
    
    // Get the iIndexth FhirMoney. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMoney);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMoney;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMoneys[index : Integer] : TFhirMoney read GetItemN write SetItemN; default;
  End;

  // The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available.
  TFhirMarketingStatus = class (TFHIRBackboneType)
  protected
    FCountry : TFhirCodeableConcept;
    FJurisdiction : TFhirCodeableConcept;
    FStatus : TFhirCodeableConcept;
    FDateRange : TFhirPeriod;
    FRestoreDate : TFhirDateTime;
    Procedure SetCountry(value : TFhirCodeableConcept);
    Procedure SetJurisdiction(value : TFhirCodeableConcept);
    Procedure SetStatus(value : TFhirCodeableConcept);
    Procedure SetDateRange(value : TFhirPeriod);
    Procedure SetRestoreDate(value : TFhirDateTime);
    Function GetRestoreDateST : TFslDateTime;
    Procedure SetRestoreDateST(value : TFslDateTime);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMarketingStatus; overload;
    function Clone : TFhirMarketingStatus; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The country in which the marketing authorisation has been granted shall be specified It should be specified using the ISO 3166 ? 1 alpha-2 code elements. (defined for API consistency)
    property country : TFhirCodeableConcept read FCountry write SetCountry;
    // The country in which the marketing authorisation has been granted shall be specified It should be specified using the ISO 3166 ? 1 alpha-2 code elements.
    property countryElement : TFhirCodeableConcept read FCountry write SetCountry;

    // Typed access to Where a Medicines Regulatory Agency has granted a marketing authorisation for which specific provisions within a jurisdiction apply, the jurisdiction can be specified using an appropriate controlled terminology The controlled term and the controlled term identifier shall be specified. (defined for API consistency)
    property jurisdiction : TFhirCodeableConcept read FJurisdiction write SetJurisdiction;
    // Where a Medicines Regulatory Agency has granted a marketing authorisation for which specific provisions within a jurisdiction apply, the jurisdiction can be specified using an appropriate controlled terminology The controlled term and the controlled term identifier shall be specified.
    property jurisdictionElement : TFhirCodeableConcept read FJurisdiction write SetJurisdiction;

    // Typed access to This attribute provides information on the status of the marketing of the medicinal product See ISO/TS 20443 for more information and examples. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // This attribute provides information on the status of the marketing of the medicinal product See ISO/TS 20443 for more information and examples.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to The date when the Medicinal Product is placed on the market by the Marketing Authorisation Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE ?Placed on the market? refers to the release of the Medicinal Product into the distribution chain. (defined for API consistency)
    property dateRange : TFhirPeriod read FDateRange write SetDateRange;
    // The date when the Medicinal Product is placed on the market by the Marketing Authorisation Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE ?Placed on the market? refers to the release of the Medicinal Product into the distribution chain.
    property dateRangeElement : TFhirPeriod read FDateRange write SetDateRange;

    // Typed access to The date when the Medicinal Product is placed on the market by the Marketing Authorisation Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE ?Placed on the market? refers to the release of the Medicinal Product into the distribution chain.
    property restoreDate : TFslDateTime read GetRestoreDateST write SetRestoreDateST;
    // The date when the Medicinal Product is placed on the market by the Marketing Authorisation Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE ?Placed on the market? refers to the release of the Medicinal Product into the distribution chain.
    property restoreDateElement : TFhirDateTime read FRestoreDate write SetRestoreDate;

  end;

  TFhirMarketingStatusListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMarketingStatusList;
    function GetCurrent : TFhirMarketingStatus;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMarketingStatusList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMarketingStatus read GetCurrent;
  end;

  TFhirMarketingStatusList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMarketingStatus;
    procedure SetItemN(index : Integer; value : TFhirMarketingStatus);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMarketingStatusList; Overload;
    function Clone : TFhirMarketingStatusList; Overload;
    function GetEnumerator : TFhirMarketingStatusListEnumerator;
    

    //  Add a FhirMarketingStatus to the end of the list.
    function Append : TFhirMarketingStatus;

    
    // Add an already existing FhirMarketingStatus to the end of the list.
    procedure AddItem(value : TFhirMarketingStatus); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMarketingStatus) : Integer;
    

    // Insert FhirMarketingStatus before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMarketingStatus;
    

    // Insert an existing FhirMarketingStatus before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMarketingStatus);
    
    // Get the iIndexth FhirMarketingStatus. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMarketingStatus);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMarketingStatus;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMarketingStatuses[index : Integer] : TFhirMarketingStatus read GetItemN write SetItemN; default;
  End;

  // An identifier - identifies some entity uniquely and unambiguously. Typically this is used for business identifiers.
  TFhirIdentifier = class (TFhirType)
  protected
    FUse : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FSystem : TFhirUri;
    FValue : TFhirString;
    FPeriod : TFhirPeriod;
    FAssigner : TFhirReference{TFhirOrganization};
    Procedure SetUse(value : TFhirEnum);
    Function GetUseST : TFhirIdentifierUseEnum;
    Procedure SetUseST(value : TFhirIdentifierUseEnum);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetAssigner(value : TFhirReference{TFhirOrganization});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirIdentifier; overload;
    function Clone : TFhirIdentifier; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The purpose of this identifier.
    property use : TFhirIdentifierUseEnum read GetUseST write SetUseST;
    property useElement : TFhirEnum read FUse write SetUse;

    // Typed access to A coded type for the identifier that can be used to determine which identifier to use for a specific purpose. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A coded type for the identifier that can be used to determine which identifier to use for a specific purpose.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Establishes the namespace for the value - that is, a URL that describes a set values that are unique.
    property system : String read GetSystemST write SetSystemST;
    // Establishes the namespace for the value - that is, a URL that describes a set values that are unique.
    property systemElement : TFhirUri read FSystem write SetSystem;

    // Typed access to The portion of the identifier typically relevant to the user and which is unique within the context of the system.
    property value : String read GetValueST write SetValueST;
    // The portion of the identifier typically relevant to the user and which is unique within the context of the system.
    property valueElement : TFhirString read FValue write SetValue;

    // Typed access to Time period during which identifier is/was valid for use. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Time period during which identifier is/was valid for use.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Organization that issued/manages the identifier. (defined for API consistency)
    property assigner : TFhirReference{TFhirOrganization} read FAssigner write SetAssigner;
    // Organization that issued/manages the identifier.
    property assignerElement : TFhirReference{TFhirOrganization} read FAssigner write SetAssigner;

  end;

  TFhirIdentifierListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirIdentifierList;
    function GetCurrent : TFhirIdentifier;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirIdentifierList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirIdentifier read GetCurrent;
  end;

  TFhirIdentifierList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirIdentifier;
    procedure SetItemN(index : Integer; value : TFhirIdentifier);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirIdentifierList; Overload;
    function Clone : TFhirIdentifierList; Overload;
    function GetEnumerator : TFhirIdentifierListEnumerator;
    

    //  Add a FhirIdentifier to the end of the list.
    function Append : TFhirIdentifier;

    
    // Add an already existing FhirIdentifier to the end of the list.
    procedure AddItem(value : TFhirIdentifier); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirIdentifier) : Integer;
    

    // Insert FhirIdentifier before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirIdentifier;
    

    // Insert an existing FhirIdentifier before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirIdentifier);
    
    // Get the iIndexth FhirIdentifier. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirIdentifier);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirIdentifier;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirIdentifiers[index : Integer] : TFhirIdentifier read GetItemN write SetItemN; default;
  End;

  // Reference range of possible or expected values.
  TFhirSubstanceAmountReferenceRange = class (TFhirElement)
  protected
    FLowLimit : TFhirQuantity;
    FHighLimit : TFhirQuantity;
    Procedure SetLowLimit(value : TFhirQuantity);
    Procedure SetHighLimit(value : TFhirQuantity);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceAmountReferenceRange; overload;
    function Clone : TFhirSubstanceAmountReferenceRange; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Lower limit possible or expected. (defined for API consistency)
    property lowLimit : TFhirQuantity read FLowLimit write SetLowLimit;
    // Lower limit possible or expected.
    property lowLimitElement : TFhirQuantity read FLowLimit write SetLowLimit;

    // Typed access to Upper limit possible or expected. (defined for API consistency)
    property highLimit : TFhirQuantity read FHighLimit write SetHighLimit;
    // Upper limit possible or expected.
    property highLimitElement : TFhirQuantity read FHighLimit write SetHighLimit;

  end;

  TFhirSubstanceAmountReferenceRangeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceAmountReferenceRangeList;
    function GetCurrent : TFhirSubstanceAmountReferenceRange;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceAmountReferenceRangeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceAmountReferenceRange read GetCurrent;
  end;

  TFhirSubstanceAmountReferenceRangeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceAmountReferenceRange;
    procedure SetItemN(index : Integer; value : TFhirSubstanceAmountReferenceRange);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceAmountReferenceRangeList; Overload;
    function Clone : TFhirSubstanceAmountReferenceRangeList; Overload;
    function GetEnumerator : TFhirSubstanceAmountReferenceRangeListEnumerator;
    

    //  Add a FhirSubstanceAmountReferenceRange to the end of the list.
    function Append : TFhirSubstanceAmountReferenceRange;

    
    // Add an already existing FhirSubstanceAmountReferenceRange to the end of the list.
    procedure AddItem(value : TFhirSubstanceAmountReferenceRange); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceAmountReferenceRange) : Integer;
    

    // Insert FhirSubstanceAmountReferenceRange before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceAmountReferenceRange;
    

    // Insert an existing FhirSubstanceAmountReferenceRange before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceAmountReferenceRange);
    
    // Get the iIndexth FhirSubstanceAmountReferenceRange. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceAmountReferenceRange);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceAmountReferenceRange;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceAmountReferenceRanges[index : Integer] : TFhirSubstanceAmountReferenceRange read GetItemN write SetItemN; default;
  End;

  // Chemical substances are a single substance type whose primary defining element is the molecular structure. Chemical substances shall be defined on the basis of their complete covalent molecular structure; the presence of a salt (counter-ion) and/or solvates (water, alcohols) is also captured. Purity, grade, physical form or particle size are not taken into account in the definition of a chemical substance or in the assignment of a Substance ID.
  TFhirSubstanceAmount = class (TFHIRBackboneType)
  protected
    FAmount : TFhirType;
    FAmountType : TFhirCodeableConcept;
    FAmountText : TFhirString;
    FReferenceRange : TFhirSubstanceAmountReferenceRange;
    Procedure SetAmount(value : TFhirType);
    Procedure SetAmountType(value : TFhirCodeableConcept);
    Procedure SetAmountText(value : TFhirString);
    Function GetAmountTextST : String;
    Procedure SetAmountTextST(value : String);
    Procedure SetReferenceRange(value : TFhirSubstanceAmountReferenceRange);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceAmount; overload;
    function Clone : TFhirSubstanceAmount; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field. (defined for API consistency)
    property amount : TFhirType read FAmount write SetAmount;
    // Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.
    property amountElement : TFhirType read FAmount write SetAmount;

    // Typed access to Most elements that require a quantitative value will also have a field called amount type. Amount type should always be specified because the actual value of the amount is often dependent on it. EXAMPLE: In capturing the actual relative amounts of substances or molecular fragments it is essential to indicate whether the amount refers to a mole ratio or weight ratio. For any given element an effort should be made to use same the amount type for all related definitional elements. (defined for API consistency)
    property amountType : TFhirCodeableConcept read FAmountType write SetAmountType;
    // Most elements that require a quantitative value will also have a field called amount type. Amount type should always be specified because the actual value of the amount is often dependent on it. EXAMPLE: In capturing the actual relative amounts of substances or molecular fragments it is essential to indicate whether the amount refers to a mole ratio or weight ratio. For any given element an effort should be made to use same the amount type for all related definitional elements.
    property amountTypeElement : TFhirCodeableConcept read FAmountType write SetAmountType;

    // Typed access to A textual comment on a numeric value.
    property amountText : String read GetAmountTextST write SetAmountTextST;
    // A textual comment on a numeric value.
    property amountTextElement : TFhirString read FAmountText write SetAmountText;

    // Typed access to Reference range of possible or expected values. (defined for API consistency)
    property referenceRange : TFhirSubstanceAmountReferenceRange read FReferenceRange write SetReferenceRange;
    // Reference range of possible or expected values.
    property referenceRangeElement : TFhirSubstanceAmountReferenceRange read FReferenceRange write SetReferenceRange;

  end;

  TFhirSubstanceAmountListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceAmountList;
    function GetCurrent : TFhirSubstanceAmount;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceAmountList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceAmount read GetCurrent;
  end;

  TFhirSubstanceAmountList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSubstanceAmount;
    procedure SetItemN(index : Integer; value : TFhirSubstanceAmount);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSubstanceAmountList; Overload;
    function Clone : TFhirSubstanceAmountList; Overload;
    function GetEnumerator : TFhirSubstanceAmountListEnumerator;
    

    //  Add a FhirSubstanceAmount to the end of the list.
    function Append : TFhirSubstanceAmount;

    
    // Add an already existing FhirSubstanceAmount to the end of the list.
    procedure AddItem(value : TFhirSubstanceAmount); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceAmount) : Integer;
    

    // Insert FhirSubstanceAmount before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceAmount;
    

    // Insert an existing FhirSubstanceAmount before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceAmount);
    
    // Get the iIndexth FhirSubstanceAmount. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceAmount);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceAmount;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSubstanceAmounts[index : Integer] : TFhirSubstanceAmount read GetItemN write SetItemN; default;
  End;

  // A reference to a code defined by a terminology system.
  TFhirCoding = class (TFhirType)
  protected
    FSystem : TFhirUri;
    FVersion : TFhirString;
    FCode : TFhirCode;
    FDisplay : TFhirString;
    FUserSelected : TFhirBoolean;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    Procedure SetUserSelected(value : TFhirBoolean);
    Function GetUserSelectedST : Boolean;
    Procedure SetUserSelectedST(value : Boolean);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoding; overload;
    function Clone : TFhirCoding; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The identification of the code system that defines the meaning of the symbol in the code.
    property system : String read GetSystemST write SetSystemST;
    // The identification of the code system that defines the meaning of the symbol in the code.
    property systemElement : TFhirUri read FSystem write SetSystem;

    // Typed access to The version of the code system which was used when choosing this code. Note that a well-maintained code system does not need the version reported, because the meaning of codes is consistent across versions. However this cannot consistently be assured, and when the meaning is not guaranteed to be consistent, the version SHOULD be exchanged.
    property version : String read GetVersionST write SetVersionST;
    // The version of the code system which was used when choosing this code. Note that a well-maintained code system does not need the version reported, because the meaning of codes is consistent across versions. However this cannot consistently be assured, and when the meaning is not guaranteed to be consistent, the version SHOULD be exchanged.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A symbol in syntax defined by the system. The symbol may be a predefined code or an expression in a syntax defined by the coding system (e.g. post-coordination).
    property code : String read GetCodeST write SetCodeST;
    // A symbol in syntax defined by the system. The symbol may be a predefined code or an expression in a syntax defined by the coding system (e.g. post-coordination).
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to A representation of the meaning of the code in the system, following the rules of the system.
    property display : String read GetDisplayST write SetDisplayST;
    // A representation of the meaning of the code in the system, following the rules of the system.
    property displayElement : TFhirString read FDisplay write SetDisplay;

    // Typed access to Indicates that this coding was chosen by a user directly - e.g. off a pick list of available items (codes or displays).
    property userSelected : Boolean read GetUserSelectedST write SetUserSelectedST;
    // Indicates that this coding was chosen by a user directly - e.g. off a pick list of available items (codes or displays).
    property userSelectedElement : TFhirBoolean read FUserSelected write SetUserSelected;

  end;

  TFhirCodingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCodingList;
    function GetCurrent : TFhirCoding;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCodingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoding read GetCurrent;
  end;

  TFhirCodingList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCoding;
    procedure SetItemN(index : Integer; value : TFhirCoding);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCodingList; Overload;
    function Clone : TFhirCodingList; Overload;
    function GetEnumerator : TFhirCodingListEnumerator;
    

    //  Add a FhirCoding to the end of the list.
    function Append : TFhirCoding;

    
    // Add an already existing FhirCoding to the end of the list.
    procedure AddItem(value : TFhirCoding); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoding) : Integer;
    

    // Insert FhirCoding before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoding;
    

    // Insert an existing FhirCoding before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoding);
    
    // Get the iIndexth FhirCoding. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoding);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCoding;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCodings[index : Integer] : TFhirCoding read GetItemN write SetItemN; default;
  End;

  // A series of measurements taken by a device, with upper and lower limits. There may be more than one dimension in the data.
  TFhirSampledData = class (TFhirType)
  protected
    FOrigin : TFhirQuantity;
    FPeriod : TFhirDecimal;
    FFactor : TFhirDecimal;
    FLowerLimit : TFhirDecimal;
    FUpperLimit : TFhirDecimal;
    FDimensions : TFhirPositiveInt;
    FData : TFhirString;
    Procedure SetOrigin(value : TFhirQuantity);
    Procedure SetPeriod(value : TFhirDecimal);
    Function GetPeriodST : String;
    Procedure SetPeriodST(value : String);
    Procedure SetFactor(value : TFhirDecimal);
    Function GetFactorST : String;
    Procedure SetFactorST(value : String);
    Procedure SetLowerLimit(value : TFhirDecimal);
    Function GetLowerLimitST : String;
    Procedure SetLowerLimitST(value : String);
    Procedure SetUpperLimit(value : TFhirDecimal);
    Function GetUpperLimitST : String;
    Procedure SetUpperLimitST(value : String);
    Procedure SetDimensions(value : TFhirPositiveInt);
    Function GetDimensionsST : String;
    Procedure SetDimensionsST(value : String);
    Procedure SetData(value : TFhirString);
    Function GetDataST : String;
    Procedure SetDataST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSampledData; overload;
    function Clone : TFhirSampledData; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The base quantity that a measured value of zero represents. In addition, this provides the units of the entire measurement series. (defined for API consistency)
    property origin : TFhirQuantity read FOrigin write SetOrigin;
    // The base quantity that a measured value of zero represents. In addition, this provides the units of the entire measurement series.
    property originElement : TFhirQuantity read FOrigin write SetOrigin;

    // Typed access to The length of time between sampling times, measured in milliseconds.
    property period : String read GetPeriodST write SetPeriodST;
    // The length of time between sampling times, measured in milliseconds.
    property periodElement : TFhirDecimal read FPeriod write SetPeriod;

    // Typed access to A correction factor that is applied to the sampled data points before they are added to the origin.
    property factor : String read GetFactorST write SetFactorST;
    // A correction factor that is applied to the sampled data points before they are added to the origin.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to The lower limit of detection of the measured points. This is needed if any of the data points have the value "L" (lower than detection limit).
    property lowerLimit : String read GetLowerLimitST write SetLowerLimitST;
    // The lower limit of detection of the measured points. This is needed if any of the data points have the value "L" (lower than detection limit).
    property lowerLimitElement : TFhirDecimal read FLowerLimit write SetLowerLimit;

    // Typed access to The upper limit of detection of the measured points. This is needed if any of the data points have the value "U" (higher than detection limit).
    property upperLimit : String read GetUpperLimitST write SetUpperLimitST;
    // The upper limit of detection of the measured points. This is needed if any of the data points have the value "U" (higher than detection limit).
    property upperLimitElement : TFhirDecimal read FUpperLimit write SetUpperLimit;

    // Typed access to The number of sample points at each time point. If this value is greater than one, then the dimensions will be interlaced - all the sample points for a point in time will be recorded at once.
    property dimensions : String read GetDimensionsST write SetDimensionsST;
    // The number of sample points at each time point. If this value is greater than one, then the dimensions will be interlaced - all the sample points for a point in time will be recorded at once.
    property dimensionsElement : TFhirPositiveInt read FDimensions write SetDimensions;

    // Typed access to A series of data points which are decimal values separated by a single space (character u20). The special values "E" (error), "L" (below detection limit) and "U" (above detection limit) can also be used in place of a decimal value.
    property data : String read GetDataST write SetDataST;
    // A series of data points which are decimal values separated by a single space (character u20). The special values "E" (error), "L" (below detection limit) and "U" (above detection limit) can also be used in place of a decimal value.
    property dataElement : TFhirString read FData write SetData;

  end;

  TFhirSampledDataListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSampledDataList;
    function GetCurrent : TFhirSampledData;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSampledDataList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSampledData read GetCurrent;
  end;

  TFhirSampledDataList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSampledData;
    procedure SetItemN(index : Integer; value : TFhirSampledData);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSampledDataList; Overload;
    function Clone : TFhirSampledDataList; Overload;
    function GetEnumerator : TFhirSampledDataListEnumerator;
    

    //  Add a FhirSampledData to the end of the list.
    function Append : TFhirSampledData;

    
    // Add an already existing FhirSampledData to the end of the list.
    procedure AddItem(value : TFhirSampledData); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSampledData) : Integer;
    

    // Insert FhirSampledData before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSampledData;
    

    // Insert an existing FhirSampledData before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSampledData);
    
    // Get the iIndexth FhirSampledData. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSampledData);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSampledData;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSampledData[index : Integer] : TFhirSampledData read GetItemN write SetItemN; default;
  End;

  // A populatioof people with some set of grouping criteria.
  TFhirPopulation = class (TFHIRBackboneType)
  protected
    FAge : TFhirType;
    FGender : TFhirCodeableConcept;
    FRace : TFhirCodeableConcept;
    FPhysiologicalCondition : TFhirCodeableConcept;
    Procedure SetAge(value : TFhirType);
    Procedure SetGender(value : TFhirCodeableConcept);
    Procedure SetRace(value : TFhirCodeableConcept);
    Procedure SetPhysiologicalCondition(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPopulation; overload;
    function Clone : TFhirPopulation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The age of the specific population. (defined for API consistency)
    property age : TFhirType read FAge write SetAge;
    // The age of the specific population.
    property ageElement : TFhirType read FAge write SetAge;

    // Typed access to The gender of the specific population. (defined for API consistency)
    property gender : TFhirCodeableConcept read FGender write SetGender;
    // The gender of the specific population.
    property genderElement : TFhirCodeableConcept read FGender write SetGender;

    // Typed access to Race of the specific population. (defined for API consistency)
    property race : TFhirCodeableConcept read FRace write SetRace;
    // Race of the specific population.
    property raceElement : TFhirCodeableConcept read FRace write SetRace;

    // Typed access to The existing physiological conditions of the specific population to which this applies. (defined for API consistency)
    property physiologicalCondition : TFhirCodeableConcept read FPhysiologicalCondition write SetPhysiologicalCondition;
    // The existing physiological conditions of the specific population to which this applies.
    property physiologicalConditionElement : TFhirCodeableConcept read FPhysiologicalCondition write SetPhysiologicalCondition;

  end;

  TFhirPopulationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPopulationList;
    function GetCurrent : TFhirPopulation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPopulationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPopulation read GetCurrent;
  end;

  TFhirPopulationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPopulation;
    procedure SetItemN(index : Integer; value : TFhirPopulation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPopulationList; Overload;
    function Clone : TFhirPopulationList; Overload;
    function GetEnumerator : TFhirPopulationListEnumerator;
    

    //  Add a FhirPopulation to the end of the list.
    function Append : TFhirPopulation;

    
    // Add an already existing FhirPopulation to the end of the list.
    procedure AddItem(value : TFhirPopulation); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPopulation) : Integer;
    

    // Insert FhirPopulation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPopulation;
    

    // Insert an existing FhirPopulation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPopulation);
    
    // Get the iIndexth FhirPopulation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPopulation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPopulation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirPopulations[index : Integer] : TFhirPopulation read GetItemN write SetItemN; default;
  End;

  // A relationship of two Quantity values - expressed as a numerator and a denominator.
  TFhirRatio = class (TFhirType)
  protected
    FNumerator : TFhirQuantity;
    FDenominator : TFhirQuantity;
    Procedure SetNumerator(value : TFhirQuantity);
    Procedure SetDenominator(value : TFhirQuantity);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRatio; overload;
    function Clone : TFhirRatio; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The value of the numerator. (defined for API consistency)
    property numerator : TFhirQuantity read FNumerator write SetNumerator;
    // The value of the numerator.
    property numeratorElement : TFhirQuantity read FNumerator write SetNumerator;

    // Typed access to The value of the denominator. (defined for API consistency)
    property denominator : TFhirQuantity read FDenominator write SetDenominator;
    // The value of the denominator.
    property denominatorElement : TFhirQuantity read FDenominator write SetDenominator;

  end;

  TFhirRatioListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRatioList;
    function GetCurrent : TFhirRatio;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRatioList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRatio read GetCurrent;
  end;

  TFhirRatioList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRatio;
    procedure SetItemN(index : Integer; value : TFhirRatio);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRatioList; Overload;
    function Clone : TFhirRatioList; Overload;
    function GetEnumerator : TFhirRatioListEnumerator;
    

    //  Add a FhirRatio to the end of the list.
    function Append : TFhirRatio;

    
    // Add an already existing FhirRatio to the end of the list.
    procedure AddItem(value : TFhirRatio); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRatio) : Integer;
    

    // Insert FhirRatio before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRatio;
    

    // Insert an existing FhirRatio before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRatio);
    
    // Get the iIndexth FhirRatio. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRatio);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRatio;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirRatios[index : Integer] : TFhirRatio read GetItemN write SetItemN; default;
  End;

  // A reference from one resource to another.
  TFhirReference = class (TFhirType)
  protected
    FReference : TFhirString;
    FType_ : TFhirUri;
    FIdentifier : TFhirIdentifier;
    FDisplay : TFhirString;
    Procedure SetReference(value : TFhirString);
    Function GetReferenceST : String;
    Procedure SetReferenceST(value : String);
    Procedure SetType_(value : TFhirUri);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirReference; overload;
    function Clone : TFhirReference; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A reference to a location at which the other resource is found. The reference may be a relative reference, in which case it is relative to the service base URL, or an absolute URL that resolves to the location where the resource is found. The reference may be version specific or not. If the reference is not to a FHIR RESTful server, then it should be assumed to be version specific. Internal fragment references (start with '#') refer to contained resources.
    property reference : String read GetReferenceST write SetReferenceST;
    // A reference to a location at which the other resource is found. The reference may be a relative reference, in which case it is relative to the service base URL, or an absolute URL that resolves to the location where the resource is found. The reference may be version specific or not. If the reference is not to a FHIR RESTful server, then it should be assumed to be version specific. Internal fragment references (start with '#') refer to contained resources.
    property referenceElement : TFhirString read FReference write SetReference;

    // Typed access to The expected type of the target of the reference. If both Reference.type and Reference.reference are populated and Reference.reference is a FHIR URL, both SHALL be consistent.  The type is the Canonical URL of Resource Definition that is the type this reference refers to. References are URLs that are relative to http://hl7.org/fhir/StructureDefinition/ e.g. "Patient" is a reference to http://hl7.org/fhir/StructureDefinition/Patient. Absolute URLs are only allowed for logical models (and can only be used in references in logical models, not resources).
    property type_ : String read GetType_ST write SetType_ST;
    // The expected type of the target of the reference. If both Reference.type and Reference.reference are populated and Reference.reference is a FHIR URL, both SHALL be consistent.  The type is the Canonical URL of Resource Definition that is the type this reference refers to. References are URLs that are relative to http://hl7.org/fhir/StructureDefinition/ e.g. "Patient" is a reference to http://hl7.org/fhir/StructureDefinition/Patient. Absolute URLs are only allowed for logical models (and can only be used in references in logical models, not resources).
    property type_Element : TFhirUri read FType_ write SetType_;

    // Typed access to An identifier for the target resource. This is used when there is no way to reference the other resource directly, either because the entity it represents is not available through a FHIR server, or because there is no way for the author of the resource to convert a known identifier to an actual location. There is no requirement that a Reference.identifier point to something that is actually exposed as a FHIR instance, but it SHALL point to a business concept that would be expected to be exposed as a FHIR instance, and that instance would need to be of a FHIR resource type allowed by the reference. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // An identifier for the target resource. This is used when there is no way to reference the other resource directly, either because the entity it represents is not available through a FHIR server, or because there is no way for the author of the resource to convert a known identifier to an actual location. There is no requirement that a Reference.identifier point to something that is actually exposed as a FHIR instance, but it SHALL point to a business concept that would be expected to be exposed as a FHIR instance, and that instance would need to be of a FHIR resource type allowed by the reference.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Plain text narrative that identifies the resource in addition to the resource reference.
    property display : String read GetDisplayST write SetDisplayST;
    // Plain text narrative that identifies the resource in addition to the resource reference.
    property displayElement : TFhirString read FDisplay write SetDisplay;

  end;

  TFhirReferenceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirReferenceList;
    function GetCurrent : TFhirReference;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirReferenceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirReference read GetCurrent;
  end;

  TFhirReferenceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirReference;
    procedure SetItemN(index : Integer; value : TFhirReference);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirReferenceList; Overload;
    function Clone : TFhirReferenceList; Overload;
    function GetEnumerator : TFhirReferenceListEnumerator;
    

    //  Add a FhirReference to the end of the list.
    function Append : TFhirReference;

    
    // Add an already existing FhirReference to the end of the list.
    procedure AddItem(value : TFhirReference); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirReference) : Integer;
    

    // Insert FhirReference before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirReference;
    

    // Insert an existing FhirReference before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirReference);
    
    // Get the iIndexth FhirReference. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirReference);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirReference;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirReferences[index : Integer] : TFhirReference read GetItemN write SetItemN; default;
  End;

  // A description of a triggering event. Triggering events can be named events, data events, or periodic, as determined by the type element.
  TFhirTriggerDefinition = class (TFhirType)
  protected
    FType_ : TFhirEnum;
    FName : TFhirString;
    FTiming : TFhirType;
    FdataList : TFhirDataRequirementList;
    FCondition : TFhirExpression;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirTriggerTypeEnum;
    Procedure SetType_ST(value : TFhirTriggerTypeEnum);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetTiming(value : TFhirType);
    function GetDataList : TFhirDataRequirementList;
    function GetHasDataList : Boolean;
    Procedure SetCondition(value : TFhirExpression);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTriggerDefinition; overload;
    function Clone : TFhirTriggerDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The type of triggering event.
    property type_ : TFhirTriggerTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A formal name for the event. This may be an absolute URI that identifies the event formally (e.g. from a trigger registry), or a simple relative URI that identifies the event in a local context.
    property name : String read GetNameST write SetNameST;
    // A formal name for the event. This may be an absolute URI that identifies the event formally (e.g. from a trigger registry), or a simple relative URI that identifies the event in a local context.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The timing of the event (if this is a periodic trigger). (defined for API consistency)
    property timing : TFhirType read FTiming write SetTiming;
    // The timing of the event (if this is a periodic trigger).
    property timingElement : TFhirType read FTiming write SetTiming;

    // The triggering data of the event (if this is a data trigger). If more than one data is requirement is specified, then all the data requirements must be true.
    property dataList : TFhirDataRequirementList read GetDataList;
    property hasDataList : boolean read GetHasDataList;

    // Typed access to A boolean-valued expression that is evaluated in the context of the container of the trigger definition and returns whether or not the trigger fires. (defined for API consistency)
    property condition : TFhirExpression read FCondition write SetCondition;
    // A boolean-valued expression that is evaluated in the context of the container of the trigger definition and returns whether or not the trigger fires.
    property conditionElement : TFhirExpression read FCondition write SetCondition;

  end;

  TFhirTriggerDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTriggerDefinitionList;
    function GetCurrent : TFhirTriggerDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTriggerDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTriggerDefinition read GetCurrent;
  end;

  TFhirTriggerDefinitionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTriggerDefinition;
    procedure SetItemN(index : Integer; value : TFhirTriggerDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTriggerDefinitionList; Overload;
    function Clone : TFhirTriggerDefinitionList; Overload;
    function GetEnumerator : TFhirTriggerDefinitionListEnumerator;
    

    //  Add a FhirTriggerDefinition to the end of the list.
    function Append : TFhirTriggerDefinition;

    
    // Add an already existing FhirTriggerDefinition to the end of the list.
    procedure AddItem(value : TFhirTriggerDefinition); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTriggerDefinition) : Integer;
    

    // Insert FhirTriggerDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTriggerDefinition;
    

    // Insert an existing FhirTriggerDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTriggerDefinition);
    
    // Get the iIndexth FhirTriggerDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTriggerDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTriggerDefinition;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTriggerDefinitions[index : Integer] : TFhirTriggerDefinition read GetItemN write SetItemN; default;
  End;

  // A time period defined by a start and end date and optionally time.
  TFhirPeriod = class (TFhirType)
  protected
    FStart : TFhirDateTime;
    FEnd_ : TFhirDateTime;
    Procedure SetStart(value : TFhirDateTime);
    Function GetStartST : TFslDateTime;
    Procedure SetStartST(value : TFslDateTime);
    Procedure SetEnd_(value : TFhirDateTime);
    Function GetEnd_ST : TFslDateTime;
    Procedure SetEnd_ST(value : TFslDateTime);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPeriod; overload;
    function Clone : TFhirPeriod; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The start of the period. The boundary is inclusive.
    property start : TFslDateTime read GetStartST write SetStartST;
    // The start of the period. The boundary is inclusive.
    property startElement : TFhirDateTime read FStart write SetStart;

    // Typed access to The end of the period. If the end of the period is missing, it means no end was known or planned at the time the instance was created. The start may be in the past, and the end date in the future, which means that period is expected/planned to end at that time.
    property end_ : TFslDateTime read GetEnd_ST write SetEnd_ST;
    // The end of the period. If the end of the period is missing, it means no end was known or planned at the time the instance was created. The start may be in the past, and the end date in the future, which means that period is expected/planned to end at that time.
    property end_Element : TFhirDateTime read FEnd_ write SetEnd_;

  end;

  TFhirPeriodListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPeriodList;
    function GetCurrent : TFhirPeriod;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPeriodList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPeriod read GetCurrent;
  end;

  TFhirPeriodList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPeriod;
    procedure SetItemN(index : Integer; value : TFhirPeriod);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPeriodList; Overload;
    function Clone : TFhirPeriodList; Overload;
    function GetEnumerator : TFhirPeriodListEnumerator;
    

    //  Add a FhirPeriod to the end of the list.
    function Append : TFhirPeriod;

    
    // Add an already existing FhirPeriod to the end of the list.
    procedure AddItem(value : TFhirPeriod); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPeriod) : Integer;
    

    // Insert FhirPeriod before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPeriod;
    

    // Insert an existing FhirPeriod before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPeriod);
    
    // Get the iIndexth FhirPeriod. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPeriod);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPeriod;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirPeriods[index : Integer] : TFhirPeriod read GetItemN write SetItemN; default;
  End;

  // A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
  TFhirQuantity = class (TFhirType)
  protected
    FValue : TFhirDecimal;
    FComparator : TFhirEnum;
    FUnit_ : TFhirString;
    FSystem : TFhirUri;
    FCode : TFhirCode;
    Procedure SetValue(value : TFhirDecimal);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
    Procedure SetComparator(value : TFhirEnum);
    Function GetComparatorST : TFhirQuantityComparatorEnum;
    Procedure SetComparatorST(value : TFhirQuantityComparatorEnum);
    Procedure SetUnit_(value : TFhirString);
    Function GetUnit_ST : String;
    Procedure SetUnit_ST(value : String);
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    procedure listQuantityFieldsInOrder(fields : TStringList);
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuantity; overload;
    function Clone : TFhirQuantity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The value of the measured amount. The value includes an implicit precision in the presentation of the value.
    property value : String read GetValueST write SetValueST;
    // The value of the measured amount. The value includes an implicit precision in the presentation of the value.
    property valueElement : TFhirDecimal read FValue write SetValue;

    // How the value should be understood and represented - whether the actual value is greater or less than the stated value due to measurement issues; e.g. if the comparator is "<" , then the real value is < stated value.
    property comparator : TFhirQuantityComparatorEnum read GetComparatorST write SetComparatorST;
    property comparatorElement : TFhirEnum read FComparator write SetComparator;

    // Typed access to A human-readable form of the unit.
    property unit_ : String read GetUnit_ST write SetUnit_ST;
    // A human-readable form of the unit.
    property unit_Element : TFhirString read FUnit_ write SetUnit_;

    // Typed access to The identification of the system that provides the coded form of the unit.
    property system : String read GetSystemST write SetSystemST;
    // The identification of the system that provides the coded form of the unit.
    property systemElement : TFhirUri read FSystem write SetSystem;

    // Typed access to A computer processable form of the unit in some unit representation system.
    property code : String read GetCodeST write SetCodeST;
    // A computer processable form of the unit in some unit representation system.
    property codeElement : TFhirCode read FCode write SetCode;

  end;

  TFhirQuantityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuantityList;
    function GetCurrent : TFhirQuantity;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirQuantityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuantity read GetCurrent;
  end;

  TFhirQuantityList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirQuantity;
    procedure SetItemN(index : Integer; value : TFhirQuantity);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirQuantityList; Overload;
    function Clone : TFhirQuantityList; Overload;
    function GetEnumerator : TFhirQuantityListEnumerator;
    

    //  Add a FhirQuantity to the end of the list.
    function Append : TFhirQuantity;

    
    // Add an already existing FhirQuantity to the end of the list.
    procedure AddItem(value : TFhirQuantity); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuantity) : Integer;
    

    // Insert FhirQuantity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuantity;
    

    // Insert an existing FhirQuantity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuantity);
    
    // Get the iIndexth FhirQuantity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuantity);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirQuantity;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirQuantities[index : Integer] : TFhirQuantity read GetItemN write SetItemN; default;
  End;

  // A set of ordered Quantities defined by a low and high limit.
  TFhirRange = class (TFhirType)
  protected
    FLow : TFhirQuantity;
    FHigh : TFhirQuantity;
    Procedure SetLow(value : TFhirQuantity);
    Procedure SetHigh(value : TFhirQuantity);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRange; overload;
    function Clone : TFhirRange; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The low limit. The boundary is inclusive. (defined for API consistency)
    property low : TFhirQuantity read FLow write SetLow;
    // The low limit. The boundary is inclusive.
    property lowElement : TFhirQuantity read FLow write SetLow;

    // Typed access to The high limit. The boundary is inclusive. (defined for API consistency)
    property high : TFhirQuantity read FHigh write SetHigh;
    // The high limit. The boundary is inclusive.
    property highElement : TFhirQuantity read FHigh write SetHigh;

  end;

  TFhirRangeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRangeList;
    function GetCurrent : TFhirRange;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRangeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRange read GetCurrent;
  end;

  TFhirRangeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRange;
    procedure SetItemN(index : Integer; value : TFhirRange);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRangeList; Overload;
    function Clone : TFhirRangeList; Overload;
    function GetEnumerator : TFhirRangeListEnumerator;
    

    //  Add a FhirRange to the end of the list.
    function Append : TFhirRange;

    
    // Add an already existing FhirRange to the end of the list.
    procedure AddItem(value : TFhirRange); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRange) : Integer;
    

    // Insert FhirRange before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRange;
    

    // Insert an existing FhirRange before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRange);
    
    // Get the iIndexth FhirRange. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRange);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRange;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirRanges[index : Integer] : TFhirRange read GetItemN write SetItemN; default;
  End;

  // Related artifacts such as additional documentation, justification, or bibliographic references.
  TFhirRelatedArtifact = class (TFhirType)
  protected
    FType_ : TFhirEnum;
    FLabel_ : TFhirString;
    FDisplay : TFhirString;
    FCitation : TFhirMarkdown;
    FUrl : TFhirUrl;
    FDocument : TFhirAttachment;
    FResource : TFhirCanonical;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirRelatedArtifactTypeEnum;
    Procedure SetType_ST(value : TFhirRelatedArtifactTypeEnum);
    Procedure SetLabel_(value : TFhirString);
    Function GetLabel_ST : String;
    Procedure SetLabel_ST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    Procedure SetCitation(value : TFhirMarkdown);
    Function GetCitationST : String;
    Procedure SetCitationST(value : String);
    Procedure SetUrl(value : TFhirUrl);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetDocument(value : TFhirAttachment);
    Procedure SetResource(value : TFhirCanonical);
    Function GetResourceST : String;
    Procedure SetResourceST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRelatedArtifact; overload;
    function Clone : TFhirRelatedArtifact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The type of relationship to the related artifact.
    property type_ : TFhirRelatedArtifactTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A short label that can be used to reference the citation from elsewhere in the containing artifact, such as a footnote index.
    property label_ : String read GetLabel_ST write SetLabel_ST;
    // A short label that can be used to reference the citation from elsewhere in the containing artifact, such as a footnote index.
    property label_Element : TFhirString read FLabel_ write SetLabel_;

    // Typed access to A brief description of the document or knowledge resource being referenced, suitable for display to a consumer.
    property display : String read GetDisplayST write SetDisplayST;
    // A brief description of the document or knowledge resource being referenced, suitable for display to a consumer.
    property displayElement : TFhirString read FDisplay write SetDisplay;

    // Typed access to A bibliographic citation for the related artifact. This text SHOULD be formatted according to an accepted citation format.
    property citation : String read GetCitationST write SetCitationST;
    // A bibliographic citation for the related artifact. This text SHOULD be formatted according to an accepted citation format.
    property citationElement : TFhirMarkdown read FCitation write SetCitation;

    // Typed access to A url for the artifact that can be followed to access the actual content.
    property url : String read GetUrlST write SetUrlST;
    // A url for the artifact that can be followed to access the actual content.
    property urlElement : TFhirUrl read FUrl write SetUrl;

    // Typed access to The document being referenced, represented as an attachment. This is exclusive with the resource element. (defined for API consistency)
    property document : TFhirAttachment read FDocument write SetDocument;
    // The document being referenced, represented as an attachment. This is exclusive with the resource element.
    property documentElement : TFhirAttachment read FDocument write SetDocument;

    // Typed access to The related resource, such as a library, value set, profile, or other knowledge resource.
    property resource : String read GetResourceST write SetResourceST;
    // The related resource, such as a library, value set, profile, or other knowledge resource.
    property resourceElement : TFhirCanonical read FResource write SetResource;

  end;

  TFhirRelatedArtifactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRelatedArtifactList;
    function GetCurrent : TFhirRelatedArtifact;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRelatedArtifactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRelatedArtifact read GetCurrent;
  end;

  TFhirRelatedArtifactList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRelatedArtifact;
    procedure SetItemN(index : Integer; value : TFhirRelatedArtifact);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRelatedArtifactList; Overload;
    function Clone : TFhirRelatedArtifactList; Overload;
    function GetEnumerator : TFhirRelatedArtifactListEnumerator;
    

    //  Add a FhirRelatedArtifact to the end of the list.
    function Append : TFhirRelatedArtifact;

    
    // Add an already existing FhirRelatedArtifact to the end of the list.
    procedure AddItem(value : TFhirRelatedArtifact); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRelatedArtifact) : Integer;
    

    // Insert FhirRelatedArtifact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRelatedArtifact;
    

    // Insert an existing FhirRelatedArtifact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRelatedArtifact);
    
    // Get the iIndexth FhirRelatedArtifact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRelatedArtifact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRelatedArtifact;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirRelatedArtifacts[index : Integer] : TFhirRelatedArtifact read GetItemN write SetItemN; default;
  End;

  // A  text note which also  contains information about who made the statement and when.
  TFhirAnnotation = class (TFhirType)
  protected
    FAuthor : TFhirType;
    FTime : TFhirDateTime;
    FText : TFhirMarkdown;
    Procedure SetAuthor(value : TFhirType);
    Procedure SetTime(value : TFhirDateTime);
    Function GetTimeST : TFslDateTime;
    Procedure SetTimeST(value : TFslDateTime);
    Procedure SetText(value : TFhirMarkdown);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAnnotation; overload;
    function Clone : TFhirAnnotation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The individual responsible for making the annotation. (defined for API consistency)
    property author : TFhirType read FAuthor write SetAuthor;
    // The individual responsible for making the annotation.
    property authorElement : TFhirType read FAuthor write SetAuthor;

    // Typed access to Indicates when this particular annotation was made.
    property time : TFslDateTime read GetTimeST write SetTimeST;
    // Indicates when this particular annotation was made.
    property timeElement : TFhirDateTime read FTime write SetTime;

    // Typed access to The text of the annotation in markdown format.
    property text : String read GetTextST write SetTextST;
    // The text of the annotation in markdown format.
    property textElement : TFhirMarkdown read FText write SetText;

  end;

  TFhirAnnotationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAnnotationList;
    function GetCurrent : TFhirAnnotation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAnnotationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAnnotation read GetCurrent;
  end;

  TFhirAnnotationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAnnotation;
    procedure SetItemN(index : Integer; value : TFhirAnnotation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAnnotationList; Overload;
    function Clone : TFhirAnnotationList; Overload;
    function GetEnumerator : TFhirAnnotationListEnumerator;
    

    //  Add a FhirAnnotation to the end of the list.
    function Append : TFhirAnnotation;

    
    // Add an already existing FhirAnnotation to the end of the list.
    procedure AddItem(value : TFhirAnnotation); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAnnotation) : Integer;
    

    // Insert FhirAnnotation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAnnotation;
    

    // Insert an existing FhirAnnotation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAnnotation);
    
    // Get the iIndexth FhirAnnotation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAnnotation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAnnotation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirAnnotations[index : Integer] : TFhirAnnotation read GetItemN write SetItemN; default;
  End;

  // The shelf-life and storage information for a medicinal product item or container can be described using this class.
  TFhirProductShelfLife = class (TFHIRBackboneType)
  protected
    FIdentifier : TFhirIdentifier;
    FType_ : TFhirCodeableConcept;
    FPeriod : TFhirQuantity;
    FspecialPrecautionsForStorageList : TFhirCodeableConceptList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetPeriod(value : TFhirQuantity);
    function GetSpecialPrecautionsForStorageList : TFhirCodeableConceptList;
    function GetHasSpecialPrecautionsForStorageList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProductShelfLife; overload;
    function Clone : TFhirProductShelfLife; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Unique identifier for the packaged Medicinal Product. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Unique identifier for the packaged Medicinal Product.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to This describes the shelf life, taking into account various scenarios such as shelf life of the packaged Medicinal Product itself, shelf life after transformation where necessary and shelf life after the first opening of a bottle, etc. The shelf life type shall be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // This describes the shelf life, taking into account various scenarios such as shelf life of the packaged Medicinal Product itself, shelf life after transformation where necessary and shelf life after the first opening of a bottle, etc. The shelf life type shall be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The shelf life time period can be specified using a numerical value for the period of time and its unit of time measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used. (defined for API consistency)
    property period : TFhirQuantity read FPeriod write SetPeriod;
    // The shelf life time period can be specified using a numerical value for the period of time and its unit of time measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
    property periodElement : TFhirQuantity read FPeriod write SetPeriod;

    // Special precautions for storage, if any, can be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified.
    property specialPrecautionsForStorageList : TFhirCodeableConceptList read GetSpecialPrecautionsForStorageList;
    property hasSpecialPrecautionsForStorageList : boolean read GetHasSpecialPrecautionsForStorageList;

  end;

  TFhirProductShelfLifeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProductShelfLifeList;
    function GetCurrent : TFhirProductShelfLife;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProductShelfLifeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProductShelfLife read GetCurrent;
  end;

  TFhirProductShelfLifeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProductShelfLife;
    procedure SetItemN(index : Integer; value : TFhirProductShelfLife);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProductShelfLifeList; Overload;
    function Clone : TFhirProductShelfLifeList; Overload;
    function GetEnumerator : TFhirProductShelfLifeListEnumerator;
    

    //  Add a FhirProductShelfLife to the end of the list.
    function Append : TFhirProductShelfLife;

    
    // Add an already existing FhirProductShelfLife to the end of the list.
    procedure AddItem(value : TFhirProductShelfLife); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProductShelfLife) : Integer;
    

    // Insert FhirProductShelfLife before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProductShelfLife;
    

    // Insert an existing FhirProductShelfLife before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProductShelfLife);
    
    // Get the iIndexth FhirProductShelfLife. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProductShelfLife);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirProductShelfLife;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirProductShelfLives[index : Integer] : TFhirProductShelfLife read GetItemN write SetItemN; default;
  End;

  // Specifies contact information for a person or organization.
  TFhirContactDetail = class (TFhirType)
  protected
    FName : TFhirString;
    FtelecomList : TFhirContactPointList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContactDetail; overload;
    function Clone : TFhirContactDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The name of an individual to contact.
    property name : String read GetNameST write SetNameST;
    // The name of an individual to contact.
    property nameElement : TFhirString read FName write SetName;

    // The contact details for the individual (if a name was provided) or the organization.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

  end;

  TFhirContactDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContactDetailList;
    function GetCurrent : TFhirContactDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContactDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContactDetail read GetCurrent;
  end;

  TFhirContactDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContactDetail;
    procedure SetItemN(index : Integer; value : TFhirContactDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContactDetailList; Overload;
    function Clone : TFhirContactDetailList; Overload;
    function GetEnumerator : TFhirContactDetailListEnumerator;
    

    //  Add a FhirContactDetail to the end of the list.
    function Append : TFhirContactDetail;

    
    // Add an already existing FhirContactDetail to the end of the list.
    procedure AddItem(value : TFhirContactDetail); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContactDetail) : Integer;
    

    // Insert FhirContactDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContactDetail;
    

    // Insert an existing FhirContactDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContactDetail);
    
    // Get the iIndexth FhirContactDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContactDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContactDetail;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirContactDetails[index : Integer] : TFhirContactDetail read GetItemN write SetItemN; default;
  End;

  // A expression that is evaluated in a specified context and returns a value. The context of use of the expression must specify the context in which the expression is evaluated, and how the result of the expression is used.
  TFhirExpression = class (TFhirType)
  protected
    FDescription : TFhirString;
    FName : TFhirId;
    FLanguage : TFhirCode;
    FExpression : TFhirString;
    FReference : TFhirUri;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetName(value : TFhirId);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetLanguage(value : TFhirCode);
    Function GetLanguageST : String;
    Procedure SetLanguageST(value : String);
    Procedure SetExpression(value : TFhirString);
    Function GetExpressionST : String;
    Procedure SetExpressionST(value : String);
    Procedure SetReference(value : TFhirUri);
    Function GetReferenceST : String;
    Procedure SetReferenceST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExpression; overload;
    function Clone : TFhirExpression; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A brief, natural language description of the condition that effectively communicates the intended semantics.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A brief, natural language description of the condition that effectively communicates the intended semantics.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to A short name assigned to the expression to allow for multiple reuse of the expression in the context where it is defined.
    property name : String read GetNameST write SetNameST;
    // A short name assigned to the expression to allow for multiple reuse of the expression in the context where it is defined.
    property nameElement : TFhirId read FName write SetName;

    // Typed access to The media type of the language for the expression.
    property language : String read GetLanguageST write SetLanguageST;
    // The media type of the language for the expression.
    property languageElement : TFhirCode read FLanguage write SetLanguage;

    // Typed access to An expression in the specified language that returns a value.
    property expression : String read GetExpressionST write SetExpressionST;
    // An expression in the specified language that returns a value.
    property expressionElement : TFhirString read FExpression write SetExpression;

    // Typed access to A URI that defines where the expression is found.
    property reference : String read GetReferenceST write SetReferenceST;
    // A URI that defines where the expression is found.
    property referenceElement : TFhirUri read FReference write SetReference;

  end;

  TFhirExpressionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExpressionList;
    function GetCurrent : TFhirExpression;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExpressionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExpression read GetCurrent;
  end;

  TFhirExpressionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExpression;
    procedure SetItemN(index : Integer; value : TFhirExpression);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExpressionList; Overload;
    function Clone : TFhirExpressionList; Overload;
    function GetEnumerator : TFhirExpressionListEnumerator;
    

    //  Add a FhirExpression to the end of the list.
    function Append : TFhirExpression;

    
    // Add an already existing FhirExpression to the end of the list.
    procedure AddItem(value : TFhirExpression); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExpression) : Integer;
    

    // Insert FhirExpression before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExpression;
    

    // Insert an existing FhirExpression before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExpression);
    
    // Get the iIndexth FhirExpression. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExpression);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirExpression;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirExpressions[index : Integer] : TFhirExpression read GetItemN write SetItemN; default;
  End;

  // Specifies clinical/business/etc. metadata that can be used to retrieve, index and/or categorize an artifact. This metadata can either be specific to the applicable population (e.g., age category, DRG) or the specific context of care (e.g., venue, care setting, provider of care).
  TFhirUsageContext = class (TFhirType)
  protected
    FCode : TFhirCoding;
    FValue : TFhirType;
    Procedure SetCode(value : TFhirCoding);
    Procedure SetValue(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirUsageContext; overload;
    function Clone : TFhirUsageContext; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A code that identifies the type of context being specified by this usage context. (defined for API consistency)
    property code : TFhirCoding read FCode write SetCode;
    // A code that identifies the type of context being specified by this usage context.
    property codeElement : TFhirCoding read FCode write SetCode;

    // Typed access to A value that defines the context specified in this context of use. The interpretation of the value is defined by the code. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // A value that defines the context specified in this context of use. The interpretation of the value is defined by the code.
    property valueElement : TFhirType read FValue write SetValue;

  end;

  TFhirUsageContextListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirUsageContextList;
    function GetCurrent : TFhirUsageContext;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirUsageContextList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirUsageContext read GetCurrent;
  end;

  TFhirUsageContextList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirUsageContext;
    procedure SetItemN(index : Integer; value : TFhirUsageContext);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirUsageContextList; Overload;
    function Clone : TFhirUsageContextList; Overload;
    function GetEnumerator : TFhirUsageContextListEnumerator;
    

    //  Add a FhirUsageContext to the end of the list.
    function Append : TFhirUsageContext;

    
    // Add an already existing FhirUsageContext to the end of the list.
    procedure AddItem(value : TFhirUsageContext); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirUsageContext) : Integer;
    

    // Insert FhirUsageContext before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirUsageContext;
    

    // Insert an existing FhirUsageContext before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirUsageContext);
    
    // Get the iIndexth FhirUsageContext. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirUsageContext);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirUsageContext;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirUsageContexts[index : Integer] : TFhirUsageContext read GetItemN write SetItemN; default;
  End;

  // A signature along with supporting context. The signature may be a digital signature that is cryptographic in nature, or some other signature acceptable to the domain. This other signature may be as simple as a graphical image representing a hand-written signature, or a signature ceremony Different signature approaches have different utilities.
  TFhirSignature = class (TFhirType)
  protected
    Ftype_List : TFhirCodingList;
    FWhen : TFhirInstant;
    FWho : TFhirReference{TFhirPractitioner};
    FOnBehalfOf : TFhirReference{TFhirPractitioner};
    FTargetFormat : TFhirCode;
    FSigFormat : TFhirCode;
    FData : TFhirBase64Binary;
    function GetType_List : TFhirCodingList;
    function GetHasType_List : Boolean;
    Procedure SetWhen(value : TFhirInstant);
    Function GetWhenST : TFslDateTime;
    Procedure SetWhenST(value : TFslDateTime);
    Procedure SetWho(value : TFhirReference{TFhirPractitioner});
    Procedure SetOnBehalfOf(value : TFhirReference{TFhirPractitioner});
    Procedure SetTargetFormat(value : TFhirCode);
    Function GetTargetFormatST : String;
    Procedure SetTargetFormatST(value : String);
    Procedure SetSigFormat(value : TFhirCode);
    Function GetSigFormatST : String;
    Procedure SetSigFormatST(value : String);
    Procedure SetData(value : TFhirBase64Binary);
    Function GetDataST : TBytes;
    Procedure SetDataST(value : TBytes);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSignature; overload;
    function Clone : TFhirSignature; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // An indication of the reason that the entity signed this document. This may be explicitly included as part of the signature information and can be used when determining accountability for various actions concerning the document.
    property type_List : TFhirCodingList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to When the digital signature was signed.
    property when : TFslDateTime read GetWhenST write SetWhenST;
    // When the digital signature was signed.
    property whenElement : TFhirInstant read FWhen write SetWhen;

    // Typed access to A reference to an application-usable description of the identity that signed  (e.g. the signature used their private key). (defined for API consistency)
    property who : TFhirReference{TFhirPractitioner} read FWho write SetWho;
    // A reference to an application-usable description of the identity that signed  (e.g. the signature used their private key).
    property whoElement : TFhirReference{TFhirPractitioner} read FWho write SetWho;

    // Typed access to A reference to an application-usable description of the identity that is represented by the signature. (defined for API consistency)
    property onBehalfOf : TFhirReference{TFhirPractitioner} read FOnBehalfOf write SetOnBehalfOf;
    // A reference to an application-usable description of the identity that is represented by the signature.
    property onBehalfOfElement : TFhirReference{TFhirPractitioner} read FOnBehalfOf write SetOnBehalfOf;

    // Typed access to A mime type that indicates the technical format of the target resources signed by the signature.
    property targetFormat : String read GetTargetFormatST write SetTargetFormatST;
    // A mime type that indicates the technical format of the target resources signed by the signature.
    property targetFormatElement : TFhirCode read FTargetFormat write SetTargetFormat;

    // Typed access to A mime type that indicates the technical format of the signature. Important mime types are application/signature+xml for X ML DigSig, application/jose for JWS, and image/* for a graphical image of a signature, etc.
    property sigFormat : String read GetSigFormatST write SetSigFormatST;
    // A mime type that indicates the technical format of the signature. Important mime types are application/signature+xml for X ML DigSig, application/jose for JWS, and image/* for a graphical image of a signature, etc.
    property sigFormatElement : TFhirCode read FSigFormat write SetSigFormat;

    // Typed access to The base64 encoding of the Signature content. When signature is not recorded electronically this element would be empty.
    property data : TBytes read GetDataST write SetDataST;
    // The base64 encoding of the Signature content. When signature is not recorded electronically this element would be empty.
    property dataElement : TFhirBase64Binary read FData write SetData;

  end;

  TFhirSignatureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSignatureList;
    function GetCurrent : TFhirSignature;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSignatureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSignature read GetCurrent;
  end;

  TFhirSignatureList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSignature;
    procedure SetItemN(index : Integer; value : TFhirSignature);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSignatureList; Overload;
    function Clone : TFhirSignatureList; Overload;
    function GetEnumerator : TFhirSignatureListEnumerator;
    

    //  Add a FhirSignature to the end of the list.
    function Append : TFhirSignature;

    
    // Add an already existing FhirSignature to the end of the list.
    procedure AddItem(value : TFhirSignature); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSignature) : Integer;
    

    // Insert FhirSignature before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSignature;
    

    // Insert an existing FhirSignature before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSignature);
    
    // Get the iIndexth FhirSignature. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSignature);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSignature;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSignatures[index : Integer] : TFhirSignature read GetItemN write SetItemN; default;
  End;

  // The marketing status describes the date when a medicinal product is actually put on the market or the date as of which it is no longer available.
  TFhirProdCharacteristic = class (TFHIRBackboneType)
  protected
    FHeight : TFhirQuantity;
    FWidth : TFhirQuantity;
    FDepth : TFhirQuantity;
    FWeight : TFhirQuantity;
    FNominalVolume : TFhirQuantity;
    FExternalDiameter : TFhirQuantity;
    FShape : TFhirString;
    FcolorList : TFhirStringList;
    FimprintList : TFhirStringList;
    FimageList : TFhirAttachmentList;
    FScoring : TFhirCodeableConcept;
    Procedure SetHeight(value : TFhirQuantity);
    Procedure SetWidth(value : TFhirQuantity);
    Procedure SetDepth(value : TFhirQuantity);
    Procedure SetWeight(value : TFhirQuantity);
    Procedure SetNominalVolume(value : TFhirQuantity);
    Procedure SetExternalDiameter(value : TFhirQuantity);
    Procedure SetShape(value : TFhirString);
    Function GetShapeST : String;
    Procedure SetShapeST(value : String);
    function GetColorList : TFhirStringList;
    function GetHasColorList : Boolean;
    function GetImprintList : TFhirStringList;
    function GetHasImprintList : Boolean;
    function GetImageList : TFhirAttachmentList;
    function GetHasImageList : Boolean;
    Procedure SetScoring(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProdCharacteristic; overload;
    function Clone : TFhirProdCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Where applicable, the height can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used. (defined for API consistency)
    property height : TFhirQuantity read FHeight write SetHeight;
    // Where applicable, the height can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
    property heightElement : TFhirQuantity read FHeight write SetHeight;

    // Typed access to Where applicable, the width can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used. (defined for API consistency)
    property width : TFhirQuantity read FWidth write SetWidth;
    // Where applicable, the width can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
    property widthElement : TFhirQuantity read FWidth write SetWidth;

    // Typed access to Where applicable, the depth can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used. (defined for API consistency)
    property depth : TFhirQuantity read FDepth write SetDepth;
    // Where applicable, the depth can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
    property depthElement : TFhirQuantity read FDepth write SetDepth;

    // Typed access to Where applicable, the weight can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used. (defined for API consistency)
    property weight : TFhirQuantity read FWeight write SetWeight;
    // Where applicable, the weight can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
    property weightElement : TFhirQuantity read FWeight write SetWeight;

    // Typed access to Where applicable, the nominal volume can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used. (defined for API consistency)
    property nominalVolume : TFhirQuantity read FNominalVolume write SetNominalVolume;
    // Where applicable, the nominal volume can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
    property nominalVolumeElement : TFhirQuantity read FNominalVolume write SetNominalVolume;

    // Typed access to Where applicable, the external diameter can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used. (defined for API consistency)
    property externalDiameter : TFhirQuantity read FExternalDiameter write SetExternalDiameter;
    // Where applicable, the external diameter can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used.
    property externalDiameterElement : TFhirQuantity read FExternalDiameter write SetExternalDiameter;

    // Typed access to Where applicable, the shape can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used.
    property shape : String read GetShapeST write SetShapeST;
    // Where applicable, the shape can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used.
    property shapeElement : TFhirString read FShape write SetShape;

    // Where applicable, the color can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used.
    property colorList : TFhirStringList read GetColorList;
    property hasColorList : boolean read GetHasColorList;

    // Where applicable, the imprint can be specified as text.
    property imprintList : TFhirStringList read GetImprintList;
    property hasImprintList : boolean read GetHasImprintList;

    // Where applicable, the image can be provided The format of the image attachment shall be specified by regional implementations.
    property imageList : TFhirAttachmentList read GetImageList;
    property hasImageList : boolean read GetHasImageList;

    // Typed access to Where applicable, the scoring can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used. (defined for API consistency)
    property scoring : TFhirCodeableConcept read FScoring write SetScoring;
    // Where applicable, the scoring can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used.
    property scoringElement : TFhirCodeableConcept read FScoring write SetScoring;

  end;

  TFhirProdCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProdCharacteristicList;
    function GetCurrent : TFhirProdCharacteristic;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProdCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProdCharacteristic read GetCurrent;
  end;

  TFhirProdCharacteristicList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProdCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirProdCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProdCharacteristicList; Overload;
    function Clone : TFhirProdCharacteristicList; Overload;
    function GetEnumerator : TFhirProdCharacteristicListEnumerator;
    

    //  Add a FhirProdCharacteristic to the end of the list.
    function Append : TFhirProdCharacteristic;

    
    // Add an already existing FhirProdCharacteristic to the end of the list.
    procedure AddItem(value : TFhirProdCharacteristic); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProdCharacteristic) : Integer;
    

    // Insert FhirProdCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProdCharacteristic;
    

    // Insert an existing FhirProdCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProdCharacteristic);
    
    // Get the iIndexth FhirProdCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProdCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirProdCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirProdCharacteristics[index : Integer] : TFhirProdCharacteristic read GetItemN write SetItemN; default;
  End;

  // A concept that may be defined by a formal reference to a terminology or ontology or may be provided by text.
  TFhirCodeableConcept = class (TFhirType)
  protected
    FcodingList : TFhirCodingList;
    FText : TFhirString;
    function GetCodingList : TFhirCodingList;
    function GetHasCodingList : Boolean;
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCodeableConcept; overload;
    function Clone : TFhirCodeableConcept; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A reference to a code defined by a terminology system.
    property codingList : TFhirCodingList read GetCodingList;
    property hasCodingList : boolean read GetHasCodingList;

    // Typed access to A human language representation of the concept as seen/selected/uttered by the user who entered the data and/or which represents the intended meaning of the user.
    property text : String read GetTextST write SetTextST;
    // A human language representation of the concept as seen/selected/uttered by the user who entered the data and/or which represents the intended meaning of the user.
    property textElement : TFhirString read FText write SetText;

  end;

  TFhirCodeableConceptListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCodeableConceptList;
    function GetCurrent : TFhirCodeableConcept;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCodeableConceptList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCodeableConcept read GetCurrent;
  end;

  TFhirCodeableConceptList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCodeableConcept;
    procedure SetItemN(index : Integer; value : TFhirCodeableConcept);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCodeableConceptList; Overload;
    function Clone : TFhirCodeableConceptList; Overload;
    function GetEnumerator : TFhirCodeableConceptListEnumerator;
    

    //  Add a FhirCodeableConcept to the end of the list.
    function Append : TFhirCodeableConcept;

    
    // Add an already existing FhirCodeableConcept to the end of the list.
    procedure AddItem(value : TFhirCodeableConcept); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCodeableConcept) : Integer;
    

    // Insert FhirCodeableConcept before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCodeableConcept;
    

    // Insert an existing FhirCodeableConcept before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCodeableConcept);
    
    // Get the iIndexth FhirCodeableConcept. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCodeableConcept);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCodeableConcept;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCodeableConcepts[index : Integer] : TFhirCodeableConcept read GetItemN write SetItemN; default;
  End;

  // The parameters to the module. This collection specifies both the input and output parameters. Input parameters are provided by the caller as part of the $evaluate operation. Output parameters are included in the GuidanceResponse.
  TFhirParameterDefinition = class (TFhirType)
  protected
    FName : TFhirCode;
    FUse : TFhirEnum;
    FMin : TFhirInteger;
    FMax : TFhirString;
    FDocumentation : TFhirString;
    FType_ : TFhirEnum;
    FProfile : TFhirCanonical;
    Procedure SetName(value : TFhirCode);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetUse(value : TFhirEnum);
    Function GetUseST : TFhirOperationParameterUseEnum;
    Procedure SetUseST(value : TFhirOperationParameterUseEnum);
    Procedure SetMin(value : TFhirInteger);
    Function GetMinST : String;
    Procedure SetMinST(value : String);
    Procedure SetMax(value : TFhirString);
    Function GetMaxST : String;
    Procedure SetMaxST(value : String);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirAllTypesEnum;
    Procedure SetType_ST(value : TFhirAllTypesEnum);
    Procedure SetProfile(value : TFhirCanonical);
    Function GetProfileST : String;
    Procedure SetProfileST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirParameterDefinition; overload;
    function Clone : TFhirParameterDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The name of the parameter used to allow access to the value of the parameter in evaluation contexts.
    property name : String read GetNameST write SetNameST;
    // The name of the parameter used to allow access to the value of the parameter in evaluation contexts.
    property nameElement : TFhirCode read FName write SetName;

    // Whether the parameter is input or output for the module.
    property use : TFhirOperationParameterUseEnum read GetUseST write SetUseST;
    property useElement : TFhirEnum read FUse write SetUse;

    // Typed access to The minimum number of times this parameter SHALL appear in the request or response.
    property min : String read GetMinST write SetMinST;
    // The minimum number of times this parameter SHALL appear in the request or response.
    property minElement : TFhirInteger read FMin write SetMin;

    // Typed access to The maximum number of times this element is permitted to appear in the request or response.
    property max : String read GetMaxST write SetMaxST;
    // The maximum number of times this element is permitted to appear in the request or response.
    property maxElement : TFhirString read FMax write SetMax;

    // Typed access to A brief discussion of what the parameter is for and how it is used by the module.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // A brief discussion of what the parameter is for and how it is used by the module.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

    // The type of the parameter.
    property type_ : TFhirAllTypesEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to If specified, this indicates a profile that the input data must conform to, or that the output data will conform to.
    property profile : String read GetProfileST write SetProfileST;
    // If specified, this indicates a profile that the input data must conform to, or that the output data will conform to.
    property profileElement : TFhirCanonical read FProfile write SetProfile;

  end;

  TFhirParameterDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirParameterDefinitionList;
    function GetCurrent : TFhirParameterDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirParameterDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirParameterDefinition read GetCurrent;
  end;

  TFhirParameterDefinitionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirParameterDefinition;
    procedure SetItemN(index : Integer; value : TFhirParameterDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirParameterDefinitionList; Overload;
    function Clone : TFhirParameterDefinitionList; Overload;
    function GetEnumerator : TFhirParameterDefinitionListEnumerator;
    

    //  Add a FhirParameterDefinition to the end of the list.
    function Append : TFhirParameterDefinition;

    
    // Add an already existing FhirParameterDefinition to the end of the list.
    procedure AddItem(value : TFhirParameterDefinition); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirParameterDefinition) : Integer;
    

    // Insert FhirParameterDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirParameterDefinition;
    

    // Insert an existing FhirParameterDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirParameterDefinition);
    
    // Get the iIndexth FhirParameterDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirParameterDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirParameterDefinition;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirParameterDefinitions[index : Integer] : TFhirParameterDefinition read GetItemN write SetItemN; default;
  End;

  // Details for all kinds of technology mediated contact points for a person or organization, including telephone, email, etc.
  TFhirContactPoint = class (TFhirType)
  protected
    FSystem : TFhirEnum;
    FValue : TFhirString;
    FUse : TFhirEnum;
    FRank : TFhirPositiveInt;
    FPeriod : TFhirPeriod;
    Procedure SetSystem(value : TFhirEnum);
    Function GetSystemST : TFhirContactPointSystemEnum;
    Procedure SetSystemST(value : TFhirContactPointSystemEnum);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
    Procedure SetUse(value : TFhirEnum);
    Function GetUseST : TFhirContactPointUseEnum;
    Procedure SetUseST(value : TFhirContactPointUseEnum);
    Procedure SetRank(value : TFhirPositiveInt);
    Function GetRankST : String;
    Procedure SetRankST(value : String);
    Procedure SetPeriod(value : TFhirPeriod);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContactPoint; overload;
    function Clone : TFhirContactPoint; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Telecommunications form for contact point - what communications system is required to make use of the contact.
    property system : TFhirContactPointSystemEnum read GetSystemST write SetSystemST;
    property systemElement : TFhirEnum read FSystem write SetSystem;

    // Typed access to The actual contact point details, in a form that is meaningful to the designated communication system (i.e. phone number or email address).
    property value : String read GetValueST write SetValueST;
    // The actual contact point details, in a form that is meaningful to the designated communication system (i.e. phone number or email address).
    property valueElement : TFhirString read FValue write SetValue;

    // Identifies the purpose for the contact point.
    property use : TFhirContactPointUseEnum read GetUseST write SetUseST;
    property useElement : TFhirEnum read FUse write SetUse;

    // Typed access to Specifies a preferred order in which to use a set of contacts. ContactPoints with lower rank values are more preferred than those with higher rank values.
    property rank : String read GetRankST write SetRankST;
    // Specifies a preferred order in which to use a set of contacts. ContactPoints with lower rank values are more preferred than those with higher rank values.
    property rankElement : TFhirPositiveInt read FRank write SetRank;

    // Typed access to Time period when the contact point was/is in use. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Time period when the contact point was/is in use.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirContactPointListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContactPointList;
    function GetCurrent : TFhirContactPoint;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirContactPointList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContactPoint read GetCurrent;
  end;

  TFhirContactPointList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirContactPoint;
    procedure SetItemN(index : Integer; value : TFhirContactPoint);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirContactPointList; Overload;
    function Clone : TFhirContactPointList; Overload;
    function GetEnumerator : TFhirContactPointListEnumerator;
    

    //  Add a FhirContactPoint to the end of the list.
    function Append : TFhirContactPoint;

    
    // Add an already existing FhirContactPoint to the end of the list.
    procedure AddItem(value : TFhirContactPoint); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContactPoint) : Integer;
    

    // Insert FhirContactPoint before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContactPoint;
    

    // Insert an existing FhirContactPoint before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContactPoint);
    
    // Get the iIndexth FhirContactPoint. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContactPoint);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContactPoint;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirContactPoints[index : Integer] : TFhirContactPoint read GetItemN write SetItemN; default;
  End;

  // A human's name with the ability to identify parts and usage.
  TFhirHumanName = class (TFhirType)
  protected
    FUse : TFhirEnum;
    FText : TFhirString;
    FFamily : TFhirString;
    FgivenList : TFhirStringList;
    FprefixList : TFhirStringList;
    FsuffixList : TFhirStringList;
    FPeriod : TFhirPeriod;
    Procedure SetUse(value : TFhirEnum);
    Function GetUseST : TFhirNameUseEnum;
    Procedure SetUseST(value : TFhirNameUseEnum);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetFamily(value : TFhirString);
    Function GetFamilyST : String;
    Procedure SetFamilyST(value : String);
    function GetGivenList : TFhirStringList;
    function GetHasGivenList : Boolean;
    function GetPrefixList : TFhirStringList;
    function GetHasPrefixList : Boolean;
    function GetSuffixList : TFhirStringList;
    function GetHasSuffixList : Boolean;
    Procedure SetPeriod(value : TFhirPeriod);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirHumanName; overload;
    function Clone : TFhirHumanName; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifies the purpose for this name.
    property use : TFhirNameUseEnum read GetUseST write SetUseST;
    property useElement : TFhirEnum read FUse write SetUse;

    // Typed access to Specifies the entire name as it should be displayed e.g. on an application UI. This may be provided instead of or as well as the specific parts.
    property text : String read GetTextST write SetTextST;
    // Specifies the entire name as it should be displayed e.g. on an application UI. This may be provided instead of or as well as the specific parts.
    property textElement : TFhirString read FText write SetText;

    // Typed access to The part of a name that links to the genealogy. In some cultures (e.g. Eritrea) the family name of a son is the first name of his father.
    property family : String read GetFamilyST write SetFamilyST;
    // The part of a name that links to the genealogy. In some cultures (e.g. Eritrea) the family name of a son is the first name of his father.
    property familyElement : TFhirString read FFamily write SetFamily;

    // Given name.
    property givenList : TFhirStringList read GetGivenList;
    property hasGivenList : boolean read GetHasGivenList;

    // Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the start of the name.
    property prefixList : TFhirStringList read GetPrefixList;
    property hasPrefixList : boolean read GetHasPrefixList;

    // Part of the name that is acquired as a title due to academic, legal, employment or nobility status, etc. and that appears at the end of the name.
    property suffixList : TFhirStringList read GetSuffixList;
    property hasSuffixList : boolean read GetHasSuffixList;

    // Typed access to Indicates the period of time when this name was valid for the named person. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Indicates the period of time when this name was valid for the named person.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirHumanNameListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirHumanNameList;
    function GetCurrent : TFhirHumanName;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirHumanNameList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirHumanName read GetCurrent;
  end;

  TFhirHumanNameList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirHumanName;
    procedure SetItemN(index : Integer; value : TFhirHumanName);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirHumanNameList; Overload;
    function Clone : TFhirHumanNameList; Overload;
    function GetEnumerator : TFhirHumanNameListEnumerator;
    

    //  Add a FhirHumanName to the end of the list.
    function Append : TFhirHumanName;

    
    // Add an already existing FhirHumanName to the end of the list.
    procedure AddItem(value : TFhirHumanName); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirHumanName) : Integer;
    

    // Insert FhirHumanName before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirHumanName;
    

    // Insert an existing FhirHumanName before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirHumanName);
    
    // Get the iIndexth FhirHumanName. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirHumanName);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirHumanName;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirHumanNames[index : Integer] : TFhirHumanName read GetItemN write SetItemN; default;
  End;

  // The metadata about a resource. This is content in the resource that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.
  TFhirMeta = class (TFhirType)
  protected
    FVersionId : TFhirId;
    FLastUpdated : TFhirInstant;
    FSource : TFhirUri;
    FprofileList : TFhirCanonicalList;
    FsecurityList : TFhirCodingList;
    FtagList : TFhirCodingList;
    Procedure SetVersionId(value : TFhirId);
    Function GetVersionIdST : String;
    Procedure SetVersionIdST(value : String);
    Procedure SetLastUpdated(value : TFhirInstant);
    Function GetLastUpdatedST : TFslDateTime;
    Procedure SetLastUpdatedST(value : TFslDateTime);
    Procedure SetSource(value : TFhirUri);
    Function GetSourceST : String;
    Procedure SetSourceST(value : String);
    function GetProfileList : TFhirCanonicalList;
    function GetHasProfileList : Boolean;
    function GetSecurityList : TFhirCodingList;
    function GetHasSecurityList : Boolean;
    function GetTagList : TFhirCodingList;
    function GetHasTagList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeta; overload;
    function Clone : TFhirMeta; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The version specific identifier, as it appears in the version portion of the URL. This value changes when the resource is created, updated, or deleted.
    property versionId : String read GetVersionIdST write SetVersionIdST;
    // The version specific identifier, as it appears in the version portion of the URL. This value changes when the resource is created, updated, or deleted.
    property versionIdElement : TFhirId read FVersionId write SetVersionId;

    // Typed access to When the resource last changed - e.g. when the version changed.
    property lastUpdated : TFslDateTime read GetLastUpdatedST write SetLastUpdatedST;
    // When the resource last changed - e.g. when the version changed.
    property lastUpdatedElement : TFhirInstant read FLastUpdated write SetLastUpdated;

    // Typed access to A uri that identifies the source system of the resource. This provides a minimal amount of [Provenance](provenance.html#) information that can be used to track or differentiate the source of information in the resource. The source may identify another FHIR server, document, message, database, etc.
    property source : String read GetSourceST write SetSourceST;
    // A uri that identifies the source system of the resource. This provides a minimal amount of [Provenance](provenance.html#) information that can be used to track or differentiate the source of information in the resource. The source may identify another FHIR server, document, message, database, etc.
    property sourceElement : TFhirUri read FSource write SetSource;

    // A list of profiles (references to [StructureDefinition](structuredefinition.html#) resources) that this resource claims to conform to. The URL is a reference to [StructureDefinition.url](structuredefinition-definitions.html#StructureDefinition.url).
    property profileList : TFhirCanonicalList read GetProfileList;
    property hasProfileList : boolean read GetHasProfileList;

    // Security labels applied to this resource. These tags connect specific resources to the overall security policy and infrastructure.
    property securityList : TFhirCodingList read GetSecurityList;
    property hasSecurityList : boolean read GetHasSecurityList;

    // Tags applied to this resource. Tags are intended to be used to identify and relate resources to process and workflow, and applications are not required to consider the tags when interpreting the meaning of a resource.
    property tagList : TFhirCodingList read GetTagList;
    property hasTagList : boolean read GetHasTagList;

  end;

  TFhirMetaListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMetaList;
    function GetCurrent : TFhirMeta;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMetaList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeta read GetCurrent;
  end;

  TFhirMetaList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMeta;
    procedure SetItemN(index : Integer; value : TFhirMeta);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMetaList; Overload;
    function Clone : TFhirMetaList; Overload;
    function GetEnumerator : TFhirMetaListEnumerator;
    

    //  Add a FhirMeta to the end of the list.
    function Append : TFhirMeta;

    
    // Add an already existing FhirMeta to the end of the list.
    procedure AddItem(value : TFhirMeta); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeta) : Integer;
    

    // Insert FhirMeta before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeta;
    

    // Insert an existing FhirMeta before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeta);
    
    // Get the iIndexth FhirMeta. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeta);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeta;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirMeta[index : Integer] : TFhirMeta read GetItemN write SetItemN; default;
  End;

  // An address expressed using postal conventions (as opposed to GPS or other location definition formats).  This data type may be used to convey addresses for use in delivering mail as well as for visiting locations which might not be valid for mail delivery.  There are a variety of postal address formats defined around the world.
  TFhirAddress = class (TFhirType)
  protected
    FUse : TFhirEnum;
    FType_ : TFhirEnum;
    FText : TFhirString;
    FlineList : TFhirStringList;
    FCity : TFhirString;
    FDistrict : TFhirString;
    FState : TFhirString;
    FPostalCode : TFhirString;
    FCountry : TFhirString;
    FPeriod : TFhirPeriod;
    Procedure SetUse(value : TFhirEnum);
    Function GetUseST : TFhirAddressUseEnum;
    Procedure SetUseST(value : TFhirAddressUseEnum);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirAddressTypeEnum;
    Procedure SetType_ST(value : TFhirAddressTypeEnum);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    function GetLineList : TFhirStringList;
    function GetHasLineList : Boolean;
    Procedure SetCity(value : TFhirString);
    Function GetCityST : String;
    Procedure SetCityST(value : String);
    Procedure SetDistrict(value : TFhirString);
    Function GetDistrictST : String;
    Procedure SetDistrictST(value : String);
    Procedure SetState(value : TFhirString);
    Function GetStateST : String;
    Procedure SetStateST(value : String);
    Procedure SetPostalCode(value : TFhirString);
    Function GetPostalCodeST : String;
    Procedure SetPostalCodeST(value : String);
    Procedure SetCountry(value : TFhirString);
    Function GetCountryST : String;
    Procedure SetCountryST(value : String);
    Procedure SetPeriod(value : TFhirPeriod);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAddress; overload;
    function Clone : TFhirAddress; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The purpose of this address.
    property use : TFhirAddressUseEnum read GetUseST write SetUseST;
    property useElement : TFhirEnum read FUse write SetUse;

    // Distinguishes between physical addresses (those you can visit) and mailing addresses (e.g. PO Boxes and care-of addresses). Most addresses are both.
    property type_ : TFhirAddressTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to Specifies the entire address as it should be displayed e.g. on a postal label. This may be provided instead of or as well as the specific parts.
    property text : String read GetTextST write SetTextST;
    // Specifies the entire address as it should be displayed e.g. on a postal label. This may be provided instead of or as well as the specific parts.
    property textElement : TFhirString read FText write SetText;

    // This component contains the house number, apartment number, street name, street direction,  P.O. Box number, delivery hints, and similar address information.
    property lineList : TFhirStringList read GetLineList;
    property hasLineList : boolean read GetHasLineList;

    // Typed access to The name of the city, town, suburb, village or other community or delivery center.
    property city : String read GetCityST write SetCityST;
    // The name of the city, town, suburb, village or other community or delivery center.
    property cityElement : TFhirString read FCity write SetCity;

    // Typed access to The name of the administrative area (county).
    property district : String read GetDistrictST write SetDistrictST;
    // The name of the administrative area (county).
    property districtElement : TFhirString read FDistrict write SetDistrict;

    // Typed access to Sub-unit of a country with limited sovereignty in a federally organized country. A code may be used if codes are in common use (e.g. US 2 letter state codes).
    property state : String read GetStateST write SetStateST;
    // Sub-unit of a country with limited sovereignty in a federally organized country. A code may be used if codes are in common use (e.g. US 2 letter state codes).
    property stateElement : TFhirString read FState write SetState;

    // Typed access to A postal code designating a region defined by the postal service.
    property postalCode : String read GetPostalCodeST write SetPostalCodeST;
    // A postal code designating a region defined by the postal service.
    property postalCodeElement : TFhirString read FPostalCode write SetPostalCode;

    // Typed access to Country - a nation as commonly understood or generally accepted.
    property country : String read GetCountryST write SetCountryST;
    // Country - a nation as commonly understood or generally accepted.
    property countryElement : TFhirString read FCountry write SetCountry;

    // Typed access to Time period when address was/is in use. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Time period when address was/is in use.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirAddressListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAddressList;
    function GetCurrent : TFhirAddress;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAddressList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAddress read GetCurrent;
  end;

  TFhirAddressList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAddress;
    procedure SetItemN(index : Integer; value : TFhirAddress);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAddressList; Overload;
    function Clone : TFhirAddressList; Overload;
    function GetEnumerator : TFhirAddressListEnumerator;
    

    //  Add a FhirAddress to the end of the list.
    function Append : TFhirAddress;

    
    // Add an already existing FhirAddress to the end of the list.
    procedure AddItem(value : TFhirAddress); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAddress) : Integer;
    

    // Insert FhirAddress before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAddress;
    

    // Insert an existing FhirAddress before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAddress);
    
    // Get the iIndexth FhirAddress. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAddress);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAddress;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirAddresses[index : Integer] : TFhirAddress read GetItemN write SetItemN; default;
  End;

  // Indicates that the element is sliced into a set of alternative definitions (i.e. in a structure definition, there are multiple different constraints on a single element in the base resource). Slicing can be used in any resource that has cardinality ..* on the base resource, or any resource with a choice of types. The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
  TFhirElementDefinitionSlicing = class (TFhirElement)
  protected
    FdiscriminatorList : TFhirElementDefinitionSlicingDiscriminatorList;
    FDescription : TFhirString;
    FOrdered : TFhirBoolean;
    FRules : TFhirEnum;
    function GetDiscriminatorList : TFhirElementDefinitionSlicingDiscriminatorList;
    function GetHasDiscriminatorList : Boolean;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetOrdered(value : TFhirBoolean);
    Function GetOrderedST : Boolean;
    Procedure SetOrderedST(value : Boolean);
    Procedure SetRules(value : TFhirEnum);
    Function GetRulesST : TFhirResourceSlicingRulesEnum;
    Procedure SetRulesST(value : TFhirResourceSlicingRulesEnum);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirElementDefinitionSlicing; overload;
    function Clone : TFhirElementDefinitionSlicing; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Designates which child elements are used to discriminate between the slices when processing an instance. If one or more discriminators are provided, the value of the child elements in the instance data SHALL completely distinguish which slice the element in the resource matches based on the allowed values for those elements in each of the slices.
    property discriminatorList : TFhirElementDefinitionSlicingDiscriminatorList read GetDiscriminatorList;
    property hasDiscriminatorList : boolean read GetHasDiscriminatorList;

    // Typed access to A human-readable text description of how the slicing works. If there is no discriminator, this is required to be present to provide whatever information is possible about how the slices can be differentiated.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A human-readable text description of how the slicing works. If there is no discriminator, this is required to be present to provide whatever information is possible about how the slices can be differentiated.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to If the matching elements have to occur in the same order as defined in the profile.
    property ordered : Boolean read GetOrderedST write SetOrderedST;
    // If the matching elements have to occur in the same order as defined in the profile.
    property orderedElement : TFhirBoolean read FOrdered write SetOrdered;

    // Whether additional slices are allowed or not. When the slices are ordered, profile authors can also say that additional slices are only allowed at the end.
    property rules : TFhirResourceSlicingRulesEnum read GetRulesST write SetRulesST;
    property rulesElement : TFhirEnum read FRules write SetRules;

  end;

  TFhirElementDefinitionSlicingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirElementDefinitionSlicingList;
    function GetCurrent : TFhirElementDefinitionSlicing;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirElementDefinitionSlicingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirElementDefinitionSlicing read GetCurrent;
  end;

  TFhirElementDefinitionSlicingList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirElementDefinitionSlicing;
    procedure SetItemN(index : Integer; value : TFhirElementDefinitionSlicing);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirElementDefinitionSlicingList; Overload;
    function Clone : TFhirElementDefinitionSlicingList; Overload;
    function GetEnumerator : TFhirElementDefinitionSlicingListEnumerator;
    

    //  Add a FhirElementDefinitionSlicing to the end of the list.
    function Append : TFhirElementDefinitionSlicing;

    
    // Add an already existing FhirElementDefinitionSlicing to the end of the list.
    procedure AddItem(value : TFhirElementDefinitionSlicing); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirElementDefinitionSlicing) : Integer;
    

    // Insert FhirElementDefinitionSlicing before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirElementDefinitionSlicing;
    

    // Insert an existing FhirElementDefinitionSlicing before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirElementDefinitionSlicing);
    
    // Get the iIndexth FhirElementDefinitionSlicing. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirElementDefinitionSlicing);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirElementDefinitionSlicing;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirElementDefinitionSlicings[index : Integer] : TFhirElementDefinitionSlicing read GetItemN write SetItemN; default;
  End;

  // Designates which child elements are used to discriminate between the slices when processing an instance. If one or more discriminators are provided, the value of the child elements in the instance data SHALL completely distinguish which slice the element in the resource matches based on the allowed values for those elements in each of the slices.
  TFhirElementDefinitionSlicingDiscriminator = class (TFhirElement)
  protected
    FType_ : TFhirEnum;
    FPath : TFhirString;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirDiscriminatorTypeEnum;
    Procedure SetType_ST(value : TFhirDiscriminatorTypeEnum);
    Procedure SetPath(value : TFhirString);
    Function GetPathST : String;
    Procedure SetPathST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirElementDefinitionSlicingDiscriminator; overload;
    function Clone : TFhirElementDefinitionSlicingDiscriminator; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // How the element value is interpreted when discrimination is evaluated.
    property type_ : TFhirDiscriminatorTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A FHIRPath expression, using [the simple subset of FHIRPath](fhirpath.html#simple), that is used to identify the element on which discrimination is based.
    property path : String read GetPathST write SetPathST;
    // A FHIRPath expression, using [the simple subset of FHIRPath](fhirpath.html#simple), that is used to identify the element on which discrimination is based.
    property pathElement : TFhirString read FPath write SetPath;

  end;

  TFhirElementDefinitionSlicingDiscriminatorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirElementDefinitionSlicingDiscriminatorList;
    function GetCurrent : TFhirElementDefinitionSlicingDiscriminator;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirElementDefinitionSlicingDiscriminatorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirElementDefinitionSlicingDiscriminator read GetCurrent;
  end;

  TFhirElementDefinitionSlicingDiscriminatorList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirElementDefinitionSlicingDiscriminator;
    procedure SetItemN(index : Integer; value : TFhirElementDefinitionSlicingDiscriminator);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirElementDefinitionSlicingDiscriminatorList; Overload;
    function Clone : TFhirElementDefinitionSlicingDiscriminatorList; Overload;
    function GetEnumerator : TFhirElementDefinitionSlicingDiscriminatorListEnumerator;
    

    //  Add a FhirElementDefinitionSlicingDiscriminator to the end of the list.
    function Append : TFhirElementDefinitionSlicingDiscriminator;

    
    // Add an already existing FhirElementDefinitionSlicingDiscriminator to the end of the list.
    procedure AddItem(value : TFhirElementDefinitionSlicingDiscriminator); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirElementDefinitionSlicingDiscriminator) : Integer;
    

    // Insert FhirElementDefinitionSlicingDiscriminator before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirElementDefinitionSlicingDiscriminator;
    

    // Insert an existing FhirElementDefinitionSlicingDiscriminator before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirElementDefinitionSlicingDiscriminator);
    
    // Get the iIndexth FhirElementDefinitionSlicingDiscriminator. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirElementDefinitionSlicingDiscriminator);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirElementDefinitionSlicingDiscriminator;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirElementDefinitionSlicingDiscriminators[index : Integer] : TFhirElementDefinitionSlicingDiscriminator read GetItemN write SetItemN; default;
  End;

  // Information about the base definition of the element, provided to make it unnecessary for tools to trace the deviation of the element through the derived and related profiles. When the element definition is not the original definition of an element - i.g. either in a constraint on another type, or for elements from a super type in a snap shot - then the information in provided in the element definition may be different to the base definition. On the original definition of the element, it will be same.
  TFhirElementDefinitionBase = class (TFhirElement)
  protected
    FPath : TFhirString;
    FMin : TFhirUnsignedInt;
    FMax : TFhirString;
    Procedure SetPath(value : TFhirString);
    Function GetPathST : String;
    Procedure SetPathST(value : String);
    Procedure SetMin(value : TFhirUnsignedInt);
    Function GetMinST : String;
    Procedure SetMinST(value : String);
    Procedure SetMax(value : TFhirString);
    Function GetMaxST : String;
    Procedure SetMaxST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirElementDefinitionBase; overload;
    function Clone : TFhirElementDefinitionBase; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The Path that identifies the base element - this matches the ElementDefinition.path for that element. Across FHIR, there is only one base definition of any element - that is, an element definition on a [StructureDefinition](structuredefinition.html#) without a StructureDefinition.base.
    property path : String read GetPathST write SetPathST;
    // The Path that identifies the base element - this matches the ElementDefinition.path for that element. Across FHIR, there is only one base definition of any element - that is, an element definition on a [StructureDefinition](structuredefinition.html#) without a StructureDefinition.base.
    property pathElement : TFhirString read FPath write SetPath;

    // Typed access to Minimum cardinality of the base element identified by the path.
    property min : String read GetMinST write SetMinST;
    // Minimum cardinality of the base element identified by the path.
    property minElement : TFhirUnsignedInt read FMin write SetMin;

    // Typed access to Maximum cardinality of the base element identified by the path.
    property max : String read GetMaxST write SetMaxST;
    // Maximum cardinality of the base element identified by the path.
    property maxElement : TFhirString read FMax write SetMax;

  end;

  TFhirElementDefinitionBaseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirElementDefinitionBaseList;
    function GetCurrent : TFhirElementDefinitionBase;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirElementDefinitionBaseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirElementDefinitionBase read GetCurrent;
  end;

  TFhirElementDefinitionBaseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirElementDefinitionBase;
    procedure SetItemN(index : Integer; value : TFhirElementDefinitionBase);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirElementDefinitionBaseList; Overload;
    function Clone : TFhirElementDefinitionBaseList; Overload;
    function GetEnumerator : TFhirElementDefinitionBaseListEnumerator;
    

    //  Add a FhirElementDefinitionBase to the end of the list.
    function Append : TFhirElementDefinitionBase;

    
    // Add an already existing FhirElementDefinitionBase to the end of the list.
    procedure AddItem(value : TFhirElementDefinitionBase); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirElementDefinitionBase) : Integer;
    

    // Insert FhirElementDefinitionBase before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirElementDefinitionBase;
    

    // Insert an existing FhirElementDefinitionBase before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirElementDefinitionBase);
    
    // Get the iIndexth FhirElementDefinitionBase. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirElementDefinitionBase);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirElementDefinitionBase;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirElementDefinitionBases[index : Integer] : TFhirElementDefinitionBase read GetItemN write SetItemN; default;
  End;

  // The data type or resource that the value of this element is permitted to be.
  TFhirElementDefinitionType = class (TFhirElement)
  protected
    FCode : TFhirUri;
    FprofileList : TFhirCanonicalList;
    FtargetProfileList : TFhirCanonicalList;
    FAggregation : TFhirEnumList;
    FVersioning : TFhirEnum;
    Procedure SetCode(value : TFhirUri);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    function GetProfileList : TFhirCanonicalList;
    function GetHasProfileList : Boolean;
    function GetTargetProfileList : TFhirCanonicalList;
    function GetHasTargetProfileList : Boolean;
    function GetAggregation : TFhirEnumList;
    function GetHasAggregation : Boolean;
    Function GetAggregationST : TFhirResourceAggregationModeEnumList;
    Procedure SetAggregationST(value : TFhirResourceAggregationModeEnumList);
    Procedure SetVersioning(value : TFhirEnum);
    Function GetVersioningST : TFhirReferenceVersionRulesEnum;
    Procedure SetVersioningST(value : TFhirReferenceVersionRulesEnum);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirElementDefinitionType; overload;
    function Clone : TFhirElementDefinitionType; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to URL of Data type or Resource that is a(or the) type used for this element. References are URLs that are relative to http://hl7.org/fhir/StructureDefinition e.g. "string" is a reference to http://hl7.org/fhir/StructureDefinition/string. Absolute URLs are only allowed in logical models.
    property code : String read GetCodeST write SetCodeST;
    // URL of Data type or Resource that is a(or the) type used for this element. References are URLs that are relative to http://hl7.org/fhir/StructureDefinition e.g. "string" is a reference to http://hl7.org/fhir/StructureDefinition/string. Absolute URLs are only allowed in logical models.
    property codeElement : TFhirUri read FCode write SetCode;

    // Identifies a profile structure or implementation Guide that applies to the datatype this element refers to. If any profiles are specified, then the content must conform to at least one of them. The URL can be a local reference - to a contained StructureDefinition, or a reference to another StructureDefinition or Implementation Guide by a canonical URL. When an implementation guide is specified, the type SHALL conform to at least one profile defined in the implementation guide.
    property profileList : TFhirCanonicalList read GetProfileList;
    property hasProfileList : boolean read GetHasProfileList;

    // Used when the type is "Reference" or "canonical", and identifies a profile structure or implementation Guide that applies to the target of the reference this element refers to. If any profiles are specified, then the content must conform to at least one of them. The URL can be a local reference - to a contained StructureDefinition, or a reference to another StructureDefinition or Implementation Guide by a canonical URL. When an implementation guide is specified, the target resource SHALL conform to at least one profile defined in the implementation guide.
    property targetProfileList : TFhirCanonicalList read GetTargetProfileList;
    property hasTargetProfileList : boolean read GetHasTargetProfileList;

    // If the type is a reference to another resource, how the resource is or can be aggregated - is it a contained resource, or a reference, and if the context is a bundle, is it included in the bundle.
    property aggregation : TFhirResourceAggregationModeEnumList read GetAggregationST write SetAggregationST;
    property aggregationList : TFhirEnumList read GetAggregation;
    property hasAggregation : boolean read GetHasAggregation;
    // Whether this reference needs to be version specific or version independent, or whether either can be used.
    property versioning : TFhirReferenceVersionRulesEnum read GetVersioningST write SetVersioningST;
    property versioningElement : TFhirEnum read FVersioning write SetVersioning;

  end;

  TFhirElementDefinitionTypeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirElementDefinitionTypeList;
    function GetCurrent : TFhirElementDefinitionType;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirElementDefinitionTypeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirElementDefinitionType read GetCurrent;
  end;

  TFhirElementDefinitionTypeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirElementDefinitionType;
    procedure SetItemN(index : Integer; value : TFhirElementDefinitionType);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirElementDefinitionTypeList; Overload;
    function Clone : TFhirElementDefinitionTypeList; Overload;
    function GetEnumerator : TFhirElementDefinitionTypeListEnumerator;
    

    //  Add a FhirElementDefinitionType to the end of the list.
    function Append : TFhirElementDefinitionType;

    
    // Add an already existing FhirElementDefinitionType to the end of the list.
    procedure AddItem(value : TFhirElementDefinitionType); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirElementDefinitionType) : Integer;
    

    // Insert FhirElementDefinitionType before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirElementDefinitionType;
    

    // Insert an existing FhirElementDefinitionType before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirElementDefinitionType);
    
    // Get the iIndexth FhirElementDefinitionType. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirElementDefinitionType);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirElementDefinitionType;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirElementDefinitionTypes[index : Integer] : TFhirElementDefinitionType read GetItemN write SetItemN; default;
  End;

  // A sample value for this element demonstrating the type of information that would typically be found in the element.
  TFhirElementDefinitionExample = class (TFhirElement)
  protected
    FLabel_ : TFhirString;
    FValue : TFhirType;
    Procedure SetLabel_(value : TFhirString);
    Function GetLabel_ST : String;
    Procedure SetLabel_ST(value : String);
    Procedure SetValue(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirElementDefinitionExample; overload;
    function Clone : TFhirElementDefinitionExample; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Describes the purpose of this example amoung the set of examples.
    property label_ : String read GetLabel_ST write SetLabel_ST;
    // Describes the purpose of this example amoung the set of examples.
    property label_Element : TFhirString read FLabel_ write SetLabel_;

    // Typed access to The actual value for the element, which must be one of the types allowed for this element. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // The actual value for the element, which must be one of the types allowed for this element.
    property valueElement : TFhirType read FValue write SetValue;

  end;

  TFhirElementDefinitionExampleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirElementDefinitionExampleList;
    function GetCurrent : TFhirElementDefinitionExample;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirElementDefinitionExampleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirElementDefinitionExample read GetCurrent;
  end;

  TFhirElementDefinitionExampleList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirElementDefinitionExample;
    procedure SetItemN(index : Integer; value : TFhirElementDefinitionExample);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirElementDefinitionExampleList; Overload;
    function Clone : TFhirElementDefinitionExampleList; Overload;
    function GetEnumerator : TFhirElementDefinitionExampleListEnumerator;
    

    //  Add a FhirElementDefinitionExample to the end of the list.
    function Append : TFhirElementDefinitionExample;

    
    // Add an already existing FhirElementDefinitionExample to the end of the list.
    procedure AddItem(value : TFhirElementDefinitionExample); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirElementDefinitionExample) : Integer;
    

    // Insert FhirElementDefinitionExample before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirElementDefinitionExample;
    

    // Insert an existing FhirElementDefinitionExample before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirElementDefinitionExample);
    
    // Get the iIndexth FhirElementDefinitionExample. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirElementDefinitionExample);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirElementDefinitionExample;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirElementDefinitionExamples[index : Integer] : TFhirElementDefinitionExample read GetItemN write SetItemN; default;
  End;

  // Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
  TFhirElementDefinitionConstraint = class (TFhirElement)
  protected
    FKey : TFhirId;
    FRequirements : TFhirString;
    FSeverity : TFhirEnum;
    FHuman : TFhirString;
    FExpression : TFhirString;
    FXpath : TFhirString;
    FSource : TFhirCanonical;
    Procedure SetKey(value : TFhirId);
    Function GetKeyST : String;
    Procedure SetKeyST(value : String);
    Procedure SetRequirements(value : TFhirString);
    Function GetRequirementsST : String;
    Procedure SetRequirementsST(value : String);
    Procedure SetSeverity(value : TFhirEnum);
    Function GetSeverityST : TFhirConstraintSeverityEnum;
    Procedure SetSeverityST(value : TFhirConstraintSeverityEnum);
    Procedure SetHuman(value : TFhirString);
    Function GetHumanST : String;
    Procedure SetHumanST(value : String);
    Procedure SetExpression(value : TFhirString);
    Function GetExpressionST : String;
    Procedure SetExpressionST(value : String);
    Procedure SetXpath(value : TFhirString);
    Function GetXpathST : String;
    Procedure SetXpathST(value : String);
    Procedure SetSource(value : TFhirCanonical);
    Function GetSourceST : String;
    Procedure SetSourceST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirElementDefinitionConstraint; overload;
    function Clone : TFhirElementDefinitionConstraint; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Allows identification of which elements have their cardinalities impacted by the constraint.  Will not be referenced for constraints that do not affect cardinality.
    property key : String read GetKeyST write SetKeyST;
    // Allows identification of which elements have their cardinalities impacted by the constraint.  Will not be referenced for constraints that do not affect cardinality.
    property keyElement : TFhirId read FKey write SetKey;

    // Typed access to Description of why this constraint is necessary or appropriate.
    property requirements : String read GetRequirementsST write SetRequirementsST;
    // Description of why this constraint is necessary or appropriate.
    property requirementsElement : TFhirString read FRequirements write SetRequirements;

    // Identifies the impact constraint violation has on the conformance of the instance.
    property severity : TFhirConstraintSeverityEnum read GetSeverityST write SetSeverityST;
    property severityElement : TFhirEnum read FSeverity write SetSeverity;

    // Typed access to Text that can be used to describe the constraint in messages identifying that the constraint has been violated.
    property human : String read GetHumanST write SetHumanST;
    // Text that can be used to describe the constraint in messages identifying that the constraint has been violated.
    property humanElement : TFhirString read FHuman write SetHuman;

    // Typed access to A [FHIRPath](fhirpath.html) expression of constraint that can be executed to see if this constraint is met.
    property expression : String read GetExpressionST write SetExpressionST;
    // A [FHIRPath](fhirpath.html) expression of constraint that can be executed to see if this constraint is met.
    property expressionElement : TFhirString read FExpression write SetExpression;

    // Typed access to An XPath expression of constraint that can be executed to see if this constraint is met.
    property xpath : String read GetXpathST write SetXpathST;
    // An XPath expression of constraint that can be executed to see if this constraint is met.
    property xpathElement : TFhirString read FXpath write SetXpath;

    // Typed access to A reference to the original source of the constraint, for traceability purposes.
    property source : String read GetSourceST write SetSourceST;
    // A reference to the original source of the constraint, for traceability purposes.
    property sourceElement : TFhirCanonical read FSource write SetSource;

  end;

  TFhirElementDefinitionConstraintListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirElementDefinitionConstraintList;
    function GetCurrent : TFhirElementDefinitionConstraint;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirElementDefinitionConstraintList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirElementDefinitionConstraint read GetCurrent;
  end;

  TFhirElementDefinitionConstraintList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirElementDefinitionConstraint;
    procedure SetItemN(index : Integer; value : TFhirElementDefinitionConstraint);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirElementDefinitionConstraintList; Overload;
    function Clone : TFhirElementDefinitionConstraintList; Overload;
    function GetEnumerator : TFhirElementDefinitionConstraintListEnumerator;
    

    //  Add a FhirElementDefinitionConstraint to the end of the list.
    function Append : TFhirElementDefinitionConstraint;

    
    // Add an already existing FhirElementDefinitionConstraint to the end of the list.
    procedure AddItem(value : TFhirElementDefinitionConstraint); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirElementDefinitionConstraint) : Integer;
    

    // Insert FhirElementDefinitionConstraint before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirElementDefinitionConstraint;
    

    // Insert an existing FhirElementDefinitionConstraint before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirElementDefinitionConstraint);
    
    // Get the iIndexth FhirElementDefinitionConstraint. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirElementDefinitionConstraint);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirElementDefinitionConstraint;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirElementDefinitionConstraints[index : Integer] : TFhirElementDefinitionConstraint read GetItemN write SetItemN; default;
  End;

  // Binds to a value set if this element is coded (code, Coding, CodeableConcept, Quantity), or the data types (string, uri).
  TFhirElementDefinitionBinding = class (TFhirElement)
  protected
    FStrength : TFhirEnum;
    FDescription : TFhirString;
    FValueSet : TFhirCanonical;
    Procedure SetStrength(value : TFhirEnum);
    Function GetStrengthST : TFhirBindingStrengthEnum;
    Procedure SetStrengthST(value : TFhirBindingStrengthEnum);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetValueSet(value : TFhirCanonical);
    Function GetValueSetST : String;
    Procedure SetValueSetST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirElementDefinitionBinding; overload;
    function Clone : TFhirElementDefinitionBinding; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Indicates the degree of conformance expectations associated with this binding - that is, the degree to which the provided value set must be adhered to in the instances.
    property strength : TFhirBindingStrengthEnum read GetStrengthST write SetStrengthST;
    property strengthElement : TFhirEnum read FStrength write SetStrength;

    // Typed access to Describes the intended use of this particular set of codes.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Describes the intended use of this particular set of codes.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Refers to the value set that identifies the set of codes the binding refers to.
    property valueSet : String read GetValueSetST write SetValueSetST;
    // Refers to the value set that identifies the set of codes the binding refers to.
    property valueSetElement : TFhirCanonical read FValueSet write SetValueSet;

  end;

  TFhirElementDefinitionBindingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirElementDefinitionBindingList;
    function GetCurrent : TFhirElementDefinitionBinding;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirElementDefinitionBindingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirElementDefinitionBinding read GetCurrent;
  end;

  TFhirElementDefinitionBindingList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirElementDefinitionBinding;
    procedure SetItemN(index : Integer; value : TFhirElementDefinitionBinding);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirElementDefinitionBindingList; Overload;
    function Clone : TFhirElementDefinitionBindingList; Overload;
    function GetEnumerator : TFhirElementDefinitionBindingListEnumerator;
    

    //  Add a FhirElementDefinitionBinding to the end of the list.
    function Append : TFhirElementDefinitionBinding;

    
    // Add an already existing FhirElementDefinitionBinding to the end of the list.
    procedure AddItem(value : TFhirElementDefinitionBinding); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirElementDefinitionBinding) : Integer;
    

    // Insert FhirElementDefinitionBinding before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirElementDefinitionBinding;
    

    // Insert an existing FhirElementDefinitionBinding before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirElementDefinitionBinding);
    
    // Get the iIndexth FhirElementDefinitionBinding. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirElementDefinitionBinding);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirElementDefinitionBinding;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirElementDefinitionBindings[index : Integer] : TFhirElementDefinitionBinding read GetItemN write SetItemN; default;
  End;

  // Identifies a concept from an external specification that roughly corresponds to this element.
  TFhirElementDefinitionMapping = class (TFhirElement)
  protected
    FIdentity : TFhirId;
    FLanguage : TFhirCode;
    FMap : TFhirString;
    FComment : TFhirString;
    Procedure SetIdentity(value : TFhirId);
    Function GetIdentityST : String;
    Procedure SetIdentityST(value : String);
    Procedure SetLanguage(value : TFhirCode);
    Function GetLanguageST : String;
    Procedure SetLanguageST(value : String);
    Procedure SetMap(value : TFhirString);
    Function GetMapST : String;
    Procedure SetMapST(value : String);
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirElementDefinitionMapping; overload;
    function Clone : TFhirElementDefinitionMapping; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An internal reference to the definition of a mapping.
    property identity : String read GetIdentityST write SetIdentityST;
    // An internal reference to the definition of a mapping.
    property identityElement : TFhirId read FIdentity write SetIdentity;

    // Typed access to Identifies the computable language in which mapping.map is expressed.
    property language : String read GetLanguageST write SetLanguageST;
    // Identifies the computable language in which mapping.map is expressed.
    property languageElement : TFhirCode read FLanguage write SetLanguage;

    // Typed access to Expresses what part of the target specification corresponds to this element.
    property map : String read GetMapST write SetMapST;
    // Expresses what part of the target specification corresponds to this element.
    property mapElement : TFhirString read FMap write SetMap;

    // Typed access to Comments that provide information about the mapping or its use.
    property comment : String read GetCommentST write SetCommentST;
    // Comments that provide information about the mapping or its use.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirElementDefinitionMappingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirElementDefinitionMappingList;
    function GetCurrent : TFhirElementDefinitionMapping;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirElementDefinitionMappingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirElementDefinitionMapping read GetCurrent;
  end;

  TFhirElementDefinitionMappingList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirElementDefinitionMapping;
    procedure SetItemN(index : Integer; value : TFhirElementDefinitionMapping);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirElementDefinitionMappingList; Overload;
    function Clone : TFhirElementDefinitionMappingList; Overload;
    function GetEnumerator : TFhirElementDefinitionMappingListEnumerator;
    

    //  Add a FhirElementDefinitionMapping to the end of the list.
    function Append : TFhirElementDefinitionMapping;

    
    // Add an already existing FhirElementDefinitionMapping to the end of the list.
    procedure AddItem(value : TFhirElementDefinitionMapping); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirElementDefinitionMapping) : Integer;
    

    // Insert FhirElementDefinitionMapping before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirElementDefinitionMapping;
    

    // Insert an existing FhirElementDefinitionMapping before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirElementDefinitionMapping);
    
    // Get the iIndexth FhirElementDefinitionMapping. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirElementDefinitionMapping);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirElementDefinitionMapping;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirElementDefinitionMappings[index : Integer] : TFhirElementDefinitionMapping read GetItemN write SetItemN; default;
  End;

  // Captures constraints on each element within the resource, profile, or extension.
  TFhirElementDefinition = class (TFHIRBackboneType)
  protected
    FPath : TFhirString;
    FRepresentation : TFhirEnumList;
    FSliceName : TFhirString;
    FSliceIsConstraining : TFhirBoolean;
    FLabel_ : TFhirString;
    FcodeList : TFhirCodingList;
    FSlicing : TFhirElementDefinitionSlicing;
    FShort : TFhirString;
    FDefinition : TFhirMarkdown;
    FComment : TFhirMarkdown;
    FRequirements : TFhirMarkdown;
    FaliasList : TFhirStringList;
    FMin : TFhirUnsignedInt;
    FMax : TFhirString;
    FBase : TFhirElementDefinitionBase;
    FContentReference : TFhirUri;
    Ftype_List : TFhirElementDefinitionTypeList;
    FDefaultValue : TFhirType;
    FMeaningWhenMissing : TFhirMarkdown;
    FOrderMeaning : TFhirString;
    FFixed : TFhirType;
    FPattern : TFhirType;
    FexampleList : TFhirElementDefinitionExampleList;
    FMinValue : TFhirType;
    FMaxValue : TFhirType;
    FMaxLength : TFhirInteger;
    FconditionList : TFhirIdList;
    FconstraintList : TFhirElementDefinitionConstraintList;
    FMustSupport : TFhirBoolean;
    FIsModifier : TFhirBoolean;
    FIsModifierReason : TFhirString;
    FIsSummary : TFhirBoolean;
    FBinding : TFhirElementDefinitionBinding;
    FmappingList : TFhirElementDefinitionMappingList;
    Procedure SetPath(value : TFhirString);
    Function GetPathST : String;
    Procedure SetPathST(value : String);
    function GetRepresentation : TFhirEnumList;
    function GetHasRepresentation : Boolean;
    Function GetRepresentationST : TFhirPropertyRepresentationEnumList;
    Procedure SetRepresentationST(value : TFhirPropertyRepresentationEnumList);
    Procedure SetSliceName(value : TFhirString);
    Function GetSliceNameST : String;
    Procedure SetSliceNameST(value : String);
    Procedure SetSliceIsConstraining(value : TFhirBoolean);
    Function GetSliceIsConstrainingST : Boolean;
    Procedure SetSliceIsConstrainingST(value : Boolean);
    Procedure SetLabel_(value : TFhirString);
    Function GetLabel_ST : String;
    Procedure SetLabel_ST(value : String);
    function GetCodeList : TFhirCodingList;
    function GetHasCodeList : Boolean;
    Procedure SetSlicing(value : TFhirElementDefinitionSlicing);
    Procedure SetShort(value : TFhirString);
    Function GetShortST : String;
    Procedure SetShortST(value : String);
    Procedure SetDefinition(value : TFhirMarkdown);
    Function GetDefinitionST : String;
    Procedure SetDefinitionST(value : String);
    Procedure SetComment(value : TFhirMarkdown);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);
    Procedure SetRequirements(value : TFhirMarkdown);
    Function GetRequirementsST : String;
    Procedure SetRequirementsST(value : String);
    function GetAliasList : TFhirStringList;
    function GetHasAliasList : Boolean;
    Procedure SetMin(value : TFhirUnsignedInt);
    Function GetMinST : String;
    Procedure SetMinST(value : String);
    Procedure SetMax(value : TFhirString);
    Function GetMaxST : String;
    Procedure SetMaxST(value : String);
    Procedure SetBase(value : TFhirElementDefinitionBase);
    Procedure SetContentReference(value : TFhirUri);
    Function GetContentReferenceST : String;
    Procedure SetContentReferenceST(value : String);
    function GetType_List : TFhirElementDefinitionTypeList;
    function GetHasType_List : Boolean;
    Procedure SetDefaultValue(value : TFhirType);
    Procedure SetMeaningWhenMissing(value : TFhirMarkdown);
    Function GetMeaningWhenMissingST : String;
    Procedure SetMeaningWhenMissingST(value : String);
    Procedure SetOrderMeaning(value : TFhirString);
    Function GetOrderMeaningST : String;
    Procedure SetOrderMeaningST(value : String);
    Procedure SetFixed(value : TFhirType);
    Procedure SetPattern(value : TFhirType);
    function GetExampleList : TFhirElementDefinitionExampleList;
    function GetHasExampleList : Boolean;
    Procedure SetMinValue(value : TFhirType);
    Procedure SetMaxValue(value : TFhirType);
    Procedure SetMaxLength(value : TFhirInteger);
    Function GetMaxLengthST : String;
    Procedure SetMaxLengthST(value : String);
    function GetConditionList : TFhirIdList;
    function GetHasConditionList : Boolean;
    function GetConstraintList : TFhirElementDefinitionConstraintList;
    function GetHasConstraintList : Boolean;
    Procedure SetMustSupport(value : TFhirBoolean);
    Function GetMustSupportST : Boolean;
    Procedure SetMustSupportST(value : Boolean);
    Procedure SetIsModifier(value : TFhirBoolean);
    Function GetIsModifierST : Boolean;
    Procedure SetIsModifierST(value : Boolean);
    Procedure SetIsModifierReason(value : TFhirString);
    Function GetIsModifierReasonST : String;
    Procedure SetIsModifierReasonST(value : String);
    Procedure SetIsSummary(value : TFhirBoolean);
    Function GetIsSummaryST : Boolean;
    Procedure SetIsSummaryST(value : Boolean);
    Procedure SetBinding(value : TFhirElementDefinitionBinding);
    function GetMappingList : TFhirElementDefinitionMappingList;
    function GetHasMappingList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirElementDefinition; overload;
    function Clone : TFhirElementDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource or extension.
    property path : String read GetPathST write SetPathST;
    // The path identifies the element and is expressed as a "."-separated list of ancestor elements, beginning with the name of the resource or extension.
    property pathElement : TFhirString read FPath write SetPath;

    // Codes that define how this element is represented in instances, when the deviation varies from the normal case.
    property representation : TFhirPropertyRepresentationEnumList read GetRepresentationST write SetRepresentationST;
    property representationList : TFhirEnumList read GetRepresentation;
    property hasRepresentation : boolean read GetHasRepresentation;
    // Typed access to The name of this element definition slice, when slicing is working. The name must be a token with no dots or spaces. This is a unique name referring to a specific set of constraints applied to this element, used to provide a name to different slices of the same element.
    property sliceName : String read GetSliceNameST write SetSliceNameST;
    // The name of this element definition slice, when slicing is working. The name must be a token with no dots or spaces. This is a unique name referring to a specific set of constraints applied to this element, used to provide a name to different slices of the same element.
    property sliceNameElement : TFhirString read FSliceName write SetSliceName;

    // Typed access to If true, indicates that this slice definition is constraining a slice definition with the same name in an inherited profile. If false, the slice is not overriding any slice in an inherited profile. If missing, the slice might or might not be overriding a slice in an inherited profile, depending on the sliceName.
    property sliceIsConstraining : Boolean read GetSliceIsConstrainingST write SetSliceIsConstrainingST;
    // If true, indicates that this slice definition is constraining a slice definition with the same name in an inherited profile. If false, the slice is not overriding any slice in an inherited profile. If missing, the slice might or might not be overriding a slice in an inherited profile, depending on the sliceName.
    property sliceIsConstrainingElement : TFhirBoolean read FSliceIsConstraining write SetSliceIsConstraining;

    // Typed access to A single preferred label which is the text to display beside the element indicating its meaning or to use to prompt for the element in a user display or form.
    property label_ : String read GetLabel_ST write SetLabel_ST;
    // A single preferred label which is the text to display beside the element indicating its meaning or to use to prompt for the element in a user display or form.
    property label_Element : TFhirString read FLabel_ write SetLabel_;

    // A code that has the same meaning as the element in a particular terminology.
    property codeList : TFhirCodingList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Typed access to Indicates that the element is sliced into a set of alternative definitions (i.e. in a structure definition, there are multiple different constraints on a single element in the base resource). Slicing can be used in any resource that has cardinality ..* on the base resource, or any resource with a choice of types. The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set). (defined for API consistency)
    property slicing : TFhirElementDefinitionSlicing read FSlicing write SetSlicing;
    // Indicates that the element is sliced into a set of alternative definitions (i.e. in a structure definition, there are multiple different constraints on a single element in the base resource). Slicing can be used in any resource that has cardinality ..* on the base resource, or any resource with a choice of types. The set of slices is any elements that come after this in the element sequence that have the same path, until a shorter path occurs (the shorter path terminates the set).
    property slicingElement : TFhirElementDefinitionSlicing read FSlicing write SetSlicing;

    // Typed access to A concise description of what this element means (e.g. for use in autogenerated summaries).
    property short : String read GetShortST write SetShortST;
    // A concise description of what this element means (e.g. for use in autogenerated summaries).
    property shortElement : TFhirString read FShort write SetShort;

    // Typed access to Provides a complete explanation of the meaning of the data element for human readability.  For the case of elements derived from existing elements (e.g. constraints), the definition SHALL be consistent with the base definition, but convey the meaning of the element in the particular context of use of the resource. (Note: The text you are reading is specified in ElementDefinition.definition).
    property definition : String read GetDefinitionST write SetDefinitionST;
    // Provides a complete explanation of the meaning of the data element for human readability.  For the case of elements derived from existing elements (e.g. constraints), the definition SHALL be consistent with the base definition, but convey the meaning of the element in the particular context of use of the resource. (Note: The text you are reading is specified in ElementDefinition.definition).
    property definitionElement : TFhirMarkdown read FDefinition write SetDefinition;

    // Typed access to Explanatory notes and implementation guidance about the data element, including notes about how to use the data properly, exceptions to proper use, etc. (Note: The text you are reading is specified in ElementDefinition.comment).
    property comment : String read GetCommentST write SetCommentST;
    // Explanatory notes and implementation guidance about the data element, including notes about how to use the data properly, exceptions to proper use, etc. (Note: The text you are reading is specified in ElementDefinition.comment).
    property commentElement : TFhirMarkdown read FComment write SetComment;

    // Typed access to This element is for traceability of why the element was created and why the constraints exist as they do. This may be used to point to source materials or specifications that drove the structure of this element.
    property requirements : String read GetRequirementsST write SetRequirementsST;
    // This element is for traceability of why the element was created and why the constraints exist as they do. This may be used to point to source materials or specifications that drove the structure of this element.
    property requirementsElement : TFhirMarkdown read FRequirements write SetRequirements;

    // Identifies additional names by which this element might also be known.
    property aliasList : TFhirStringList read GetAliasList;
    property hasAliasList : boolean read GetHasAliasList;

    // Typed access to The minimum number of times this element SHALL appear in the instance.
    property min : String read GetMinST write SetMinST;
    // The minimum number of times this element SHALL appear in the instance.
    property minElement : TFhirUnsignedInt read FMin write SetMin;

    // Typed access to The maximum number of times this element is permitted to appear in the instance.
    property max : String read GetMaxST write SetMaxST;
    // The maximum number of times this element is permitted to appear in the instance.
    property maxElement : TFhirString read FMax write SetMax;

    // Typed access to Information about the base definition of the element, provided to make it unnecessary for tools to trace the deviation of the element through the derived and related profiles. When the element definition is not the original definition of an element - i.g. either in a constraint on another type, or for elements from a super type in a snap shot - then the information in provided in the element definition may be different to the base definition. On the original definition of the element, it will be same. (defined for API consistency)
    property base : TFhirElementDefinitionBase read FBase write SetBase;
    // Information about the base definition of the element, provided to make it unnecessary for tools to trace the deviation of the element through the derived and related profiles. When the element definition is not the original definition of an element - i.g. either in a constraint on another type, or for elements from a super type in a snap shot - then the information in provided in the element definition may be different to the base definition. On the original definition of the element, it will be same.
    property baseElement : TFhirElementDefinitionBase read FBase write SetBase;

    // Typed access to Identifies an element defined elsewhere in the definition whose content rules should be applied to the current element. ContentReferences bring across all the rules that are in the ElementDefinition for the element, including definitions, cardinality constraints, bindings, invariants etc.
    property contentReference : String read GetContentReferenceST write SetContentReferenceST;
    // Identifies an element defined elsewhere in the definition whose content rules should be applied to the current element. ContentReferences bring across all the rules that are in the ElementDefinition for the element, including definitions, cardinality constraints, bindings, invariants etc.
    property contentReferenceElement : TFhirUri read FContentReference write SetContentReference;

    // The data type or resource that the value of this element is permitted to be.
    property type_List : TFhirElementDefinitionTypeList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false'). (defined for API consistency)
    property defaultValue : TFhirType read FDefaultValue write SetDefaultValue;
    // The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise specified, the abstract is false').
    property defaultValueElement : TFhirType read FDefaultValue write SetDefaultValue;

    // Typed access to The Implicit meaning that is to be understood when this element is missing (e.g. 'when this element is missing, the period is ongoing').
    property meaningWhenMissing : String read GetMeaningWhenMissingST write SetMeaningWhenMissingST;
    // The Implicit meaning that is to be understood when this element is missing (e.g. 'when this element is missing, the period is ongoing').
    property meaningWhenMissingElement : TFhirMarkdown read FMeaningWhenMissing write SetMeaningWhenMissing;

    // Typed access to If present, indicates that the order of the repeating element has meaning and describes what that meaning is.  If absent, it means that the order of the element has no meaning.
    property orderMeaning : String read GetOrderMeaningST write SetOrderMeaningST;
    // If present, indicates that the order of the repeating element has meaning and describes what that meaning is.  If absent, it means that the order of the element has no meaning.
    property orderMeaningElement : TFhirString read FOrderMeaning write SetOrderMeaning;

    // Typed access to Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing. (defined for API consistency)
    property fixed : TFhirType read FFixed write SetFixed;
    // Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes of comparison, non-significant whitespace is ignored, and all values must be an exact match (case and accent sensitive). Missing elements/attributes must also be missing.
    property fixedElement : TFhirType read FFixed write SetFixed;

    // Typed access to Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.    When pattern[x] is used to constrain a primitive, it means that the value provided in the pattern[x] must match the instance value exactly.  When pattern[x] is used to constrain an array, it means that each element provided in the pattern[x] array must (recursively) match at least one element from the instance array.  When pattern[x] is used to constrain a complex object, it means that each property in the pattern must be present in the complex object, and its value must recursively match -- i.e.,  1. If primitive: it must match exactly the pattern value 2. If a complex object: it must match (recursively) the pattern value 3. If an array: it must match (recursively) the pattern value. (defined for API consistency)
    property pattern : TFhirType read FPattern write SetPattern;
    // Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern must be found in the instance. Other additional values may be found too. This is effectively constraint by example.    When pattern[x] is used to constrain a primitive, it means that the value provided in the pattern[x] must match the instance value exactly.  When pattern[x] is used to constrain an array, it means that each element provided in the pattern[x] array must (recursively) match at least one element from the instance array.  When pattern[x] is used to constrain a complex object, it means that each property in the pattern must be present in the complex object, and its value must recursively match -- i.e.,  1. If primitive: it must match exactly the pattern value 2. If a complex object: it must match (recursively) the pattern value 3. If an array: it must match (recursively) the pattern value.
    property patternElement : TFhirType read FPattern write SetPattern;

    // A sample value for this element demonstrating the type of information that would typically be found in the element.
    property exampleList : TFhirElementDefinitionExampleList read GetExampleList;
    property hasExampleList : boolean read GetHasExampleList;

    // Typed access to The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity. (defined for API consistency)
    property minValue : TFhirType read FMinValue write SetMinValue;
    // The minimum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    property minValueElement : TFhirType read FMinValue write SetMinValue;

    // Typed access to The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity. (defined for API consistency)
    property maxValue : TFhirType read FMaxValue write SetMaxValue;
    // The maximum allowed value for the element. The value is inclusive. This is allowed for the types date, dateTime, instant, time, decimal, integer, and Quantity.
    property maxValueElement : TFhirType read FMaxValue write SetMaxValue;

    // Typed access to Indicates the maximum length in characters that is permitted to be present in conformant instances and which is expected to be supported by conformant consumers that support the element.
    property maxLength : String read GetMaxLengthST write SetMaxLengthST;
    // Indicates the maximum length in characters that is permitted to be present in conformant instances and which is expected to be supported by conformant consumers that support the element.
    property maxLengthElement : TFhirInteger read FMaxLength write SetMaxLength;

    // A reference to an invariant that may make additional statements about the cardinality or value in the instance.
    property conditionList : TFhirIdList read GetConditionList;
    property hasConditionList : boolean read GetHasConditionList;

    // Formal constraints such as co-occurrence and other constraints that can be computationally evaluated within the context of the instance.
    property constraintList : TFhirElementDefinitionConstraintList read GetConstraintList;
    property hasConstraintList : boolean read GetHasConstraintList;

    // Typed access to If true, implementations that produce or consume resources SHALL provide "support" for the element in some meaningful way.  If false, the element may be ignored and not supported. If false, whether to populate or use the data element in any way is at the discretion of the implementation.
    property mustSupport : Boolean read GetMustSupportST write SetMustSupportST;
    // If true, implementations that produce or consume resources SHALL provide "support" for the element in some meaningful way.  If false, the element may be ignored and not supported. If false, whether to populate or use the data element in any way is at the discretion of the implementation.
    property mustSupportElement : TFhirBoolean read FMustSupport write SetMustSupport;

    // Typed access to If true, the value of this element affects the interpretation of the element or resource that contains it, and the value of the element cannot be ignored. Typically, this is used for status, negation and qualification codes. The effect of this is that the element cannot be ignored by systems: they SHALL either recognize the element and process it, and/or a pre-determination has been made that it is not relevant to their particular system.
    property isModifier : Boolean read GetIsModifierST write SetIsModifierST;
    // If true, the value of this element affects the interpretation of the element or resource that contains it, and the value of the element cannot be ignored. Typically, this is used for status, negation and qualification codes. The effect of this is that the element cannot be ignored by systems: they SHALL either recognize the element and process it, and/or a pre-determination has been made that it is not relevant to their particular system.
    property isModifierElement : TFhirBoolean read FIsModifier write SetIsModifier;

    // Typed access to Explains how that element affects the interpretation of the resource or element that contains it.
    property isModifierReason : String read GetIsModifierReasonST write SetIsModifierReasonST;
    // Explains how that element affects the interpretation of the resource or element that contains it.
    property isModifierReasonElement : TFhirString read FIsModifierReason write SetIsModifierReason;

    // Typed access to Whether the element should be included if a client requests a search with the parameter _summary=true.
    property isSummary : Boolean read GetIsSummaryST write SetIsSummaryST;
    // Whether the element should be included if a client requests a search with the parameter _summary=true.
    property isSummaryElement : TFhirBoolean read FIsSummary write SetIsSummary;

    // Typed access to Binds to a value set if this element is coded (code, Coding, CodeableConcept, Quantity), or the data types (string, uri). (defined for API consistency)
    property binding : TFhirElementDefinitionBinding read FBinding write SetBinding;
    // Binds to a value set if this element is coded (code, Coding, CodeableConcept, Quantity), or the data types (string, uri).
    property bindingElement : TFhirElementDefinitionBinding read FBinding write SetBinding;

    // Identifies a concept from an external specification that roughly corresponds to this element.
    property mappingList : TFhirElementDefinitionMappingList read GetMappingList;
    property hasMappingList : boolean read GetHasMappingList;

  end;

  TFhirElementDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirElementDefinitionList;
    function GetCurrent : TFhirElementDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirElementDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirElementDefinition read GetCurrent;
  end;

  TFhirElementDefinitionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirElementDefinition;
    procedure SetItemN(index : Integer; value : TFhirElementDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirElementDefinitionList; Overload;
    function Clone : TFhirElementDefinitionList; Overload;
    function GetEnumerator : TFhirElementDefinitionListEnumerator;
    

    //  Add a FhirElementDefinition to the end of the list.
    function Append : TFhirElementDefinition;

    
    // Add an already existing FhirElementDefinition to the end of the list.
    procedure AddItem(value : TFhirElementDefinition); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirElementDefinition) : Integer;
    

    // Insert FhirElementDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirElementDefinition;
    

    // Insert an existing FhirElementDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirElementDefinition);
    
    // Get the iIndexth FhirElementDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirElementDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirElementDefinition;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirElementDefinitions[index : Integer] : TFhirElementDefinition read GetItemN write SetItemN; default;
  End;

  // A set of rules that describe when the event is scheduled.
  TFhirTimingRepeat = class (TFhirElement)
  protected
    FBounds : TFhirType;
    FCount : TFhirPositiveInt;
    FCountMax : TFhirPositiveInt;
    FDuration : TFhirDecimal;
    FDurationMax : TFhirDecimal;
    FDurationUnit : TFhirEnum;
    FFrequency : TFhirPositiveInt;
    FFrequencyMax : TFhirPositiveInt;
    FPeriod : TFhirDecimal;
    FPeriodMax : TFhirDecimal;
    FPeriodUnit : TFhirEnum;
    FDayOfWeek : TFhirEnumList;
    FtimeOfDayList : TFhirTimeList;
    FWhen : TFhirEnumList;
    FOffset : TFhirUnsignedInt;
    Procedure SetBounds(value : TFhirType);
    Procedure SetCount(value : TFhirPositiveInt);
    Function GetCountST : String;
    Procedure SetCountST(value : String);
    Procedure SetCountMax(value : TFhirPositiveInt);
    Function GetCountMaxST : String;
    Procedure SetCountMaxST(value : String);
    Procedure SetDuration(value : TFhirDecimal);
    Function GetDurationST : String;
    Procedure SetDurationST(value : String);
    Procedure SetDurationMax(value : TFhirDecimal);
    Function GetDurationMaxST : String;
    Procedure SetDurationMaxST(value : String);
    Procedure SetDurationUnit(value : TFhirEnum);
    Function GetDurationUnitST : TFhirUnitsOfTimeEnum;
    Procedure SetDurationUnitST(value : TFhirUnitsOfTimeEnum);
    Procedure SetFrequency(value : TFhirPositiveInt);
    Function GetFrequencyST : String;
    Procedure SetFrequencyST(value : String);
    Procedure SetFrequencyMax(value : TFhirPositiveInt);
    Function GetFrequencyMaxST : String;
    Procedure SetFrequencyMaxST(value : String);
    Procedure SetPeriod(value : TFhirDecimal);
    Function GetPeriodST : String;
    Procedure SetPeriodST(value : String);
    Procedure SetPeriodMax(value : TFhirDecimal);
    Function GetPeriodMaxST : String;
    Procedure SetPeriodMaxST(value : String);
    Procedure SetPeriodUnit(value : TFhirEnum);
    Function GetPeriodUnitST : TFhirUnitsOfTimeEnum;
    Procedure SetPeriodUnitST(value : TFhirUnitsOfTimeEnum);
    function GetDayOfWeek : TFhirEnumList;
    function GetHasDayOfWeek : Boolean;
    Function GetDayOfWeekST : TFhirDaysOfWeekEnumList;
    Procedure SetDayOfWeekST(value : TFhirDaysOfWeekEnumList);
    function GetTimeOfDayList : TFhirTimeList;
    function GetHasTimeOfDayList : Boolean;
    function GetWhen : TFhirEnumList;
    function GetHasWhen : Boolean;
    Function GetWhenST : TFhirEventTimingEnumList;
    Procedure SetWhenST(value : TFhirEventTimingEnumList);
    Procedure SetOffset(value : TFhirUnsignedInt);
    Function GetOffsetST : String;
    Procedure SetOffsetST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTimingRepeat; overload;
    function Clone : TFhirTimingRepeat; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule. (defined for API consistency)
    property bounds : TFhirType read FBounds write SetBounds;
    // Either a duration for the length of the timing schedule, a range of possible length, or outer bounds for start and/or end limits of the timing schedule.
    property boundsElement : TFhirType read FBounds write SetBounds;

    // Typed access to A total count of the desired number of repetitions across the duration of the entire timing specification. If countMax is present, this element indicates the lower bound of the allowed range of count values.
    property count : String read GetCountST write SetCountST;
    // A total count of the desired number of repetitions across the duration of the entire timing specification. If countMax is present, this element indicates the lower bound of the allowed range of count values.
    property countElement : TFhirPositiveInt read FCount write SetCount;

    // Typed access to If present, indicates that the count is a range - so to perform the action between [count] and [countMax] times.
    property countMax : String read GetCountMaxST write SetCountMaxST;
    // If present, indicates that the count is a range - so to perform the action between [count] and [countMax] times.
    property countMaxElement : TFhirPositiveInt read FCountMax write SetCountMax;

    // Typed access to How long this thing happens for when it happens. If durationMax is present, this element indicates the lower bound of the allowed range of the duration.
    property duration : String read GetDurationST write SetDurationST;
    // How long this thing happens for when it happens. If durationMax is present, this element indicates the lower bound of the allowed range of the duration.
    property durationElement : TFhirDecimal read FDuration write SetDuration;

    // Typed access to If present, indicates that the duration is a range - so to perform the action between [duration] and [durationMax] time length.
    property durationMax : String read GetDurationMaxST write SetDurationMaxST;
    // If present, indicates that the duration is a range - so to perform the action between [duration] and [durationMax] time length.
    property durationMaxElement : TFhirDecimal read FDurationMax write SetDurationMax;

    // The units of time for the duration, in UCUM units.
    property durationUnit : TFhirUnitsOfTimeEnum read GetDurationUnitST write SetDurationUnitST;
    property durationUnitElement : TFhirEnum read FDurationUnit write SetDurationUnit;

    // Typed access to The number of times to repeat the action within the specified period. If frequencyMax is present, this element indicates the lower bound of the allowed range of the frequency.
    property frequency : String read GetFrequencyST write SetFrequencyST;
    // The number of times to repeat the action within the specified period. If frequencyMax is present, this element indicates the lower bound of the allowed range of the frequency.
    property frequencyElement : TFhirPositiveInt read FFrequency write SetFrequency;

    // Typed access to If present, indicates that the frequency is a range - so to repeat between [frequency] and [frequencyMax] times within the period or period range.
    property frequencyMax : String read GetFrequencyMaxST write SetFrequencyMaxST;
    // If present, indicates that the frequency is a range - so to repeat between [frequency] and [frequencyMax] times within the period or period range.
    property frequencyMaxElement : TFhirPositiveInt read FFrequencyMax write SetFrequencyMax;

    // Typed access to Indicates the duration of time over which repetitions are to occur; e.g. to express "3 times per day", 3 would be the frequency and "1 day" would be the period. If periodMax is present, this element indicates the lower bound of the allowed range of the period length.
    property period : String read GetPeriodST write SetPeriodST;
    // Indicates the duration of time over which repetitions are to occur; e.g. to express "3 times per day", 3 would be the frequency and "1 day" would be the period. If periodMax is present, this element indicates the lower bound of the allowed range of the period length.
    property periodElement : TFhirDecimal read FPeriod write SetPeriod;

    // Typed access to If present, indicates that the period is a range from [period] to [periodMax], allowing expressing concepts such as "do this once every 3-5 days.
    property periodMax : String read GetPeriodMaxST write SetPeriodMaxST;
    // If present, indicates that the period is a range from [period] to [periodMax], allowing expressing concepts such as "do this once every 3-5 days.
    property periodMaxElement : TFhirDecimal read FPeriodMax write SetPeriodMax;

    // The units of time for the period in UCUM units.
    property periodUnit : TFhirUnitsOfTimeEnum read GetPeriodUnitST write SetPeriodUnitST;
    property periodUnitElement : TFhirEnum read FPeriodUnit write SetPeriodUnit;

    // If one or more days of week is provided, then the action happens only on the specified day(s).
    property dayOfWeek : TFhirDaysOfWeekEnumList read GetDayOfWeekST write SetDayOfWeekST;
    property dayOfWeekList : TFhirEnumList read GetDayOfWeek;
    property hasDayOfWeek : boolean read GetHasDayOfWeek;
    // Specified time of day for action to take place.
    property timeOfDayList : TFhirTimeList read GetTimeOfDayList;
    property hasTimeOfDayList : boolean read GetHasTimeOfDayList;

    // An approximate time period during the day, potentially linked to an event of daily living that indicates when the action should occur.
    property when : TFhirEventTimingEnumList read GetWhenST write SetWhenST;
    property whenList : TFhirEnumList read GetWhen;
    property hasWhen : boolean read GetHasWhen;
    // Typed access to The number of minutes from the event. If the event code does not indicate whether the minutes is before or after the event, then the offset is assumed to be after the event.
    property offset : String read GetOffsetST write SetOffsetST;
    // The number of minutes from the event. If the event code does not indicate whether the minutes is before or after the event, then the offset is assumed to be after the event.
    property offsetElement : TFhirUnsignedInt read FOffset write SetOffset;

  end;

  TFhirTimingRepeatListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTimingRepeatList;
    function GetCurrent : TFhirTimingRepeat;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTimingRepeatList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTimingRepeat read GetCurrent;
  end;

  TFhirTimingRepeatList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTimingRepeat;
    procedure SetItemN(index : Integer; value : TFhirTimingRepeat);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTimingRepeatList; Overload;
    function Clone : TFhirTimingRepeatList; Overload;
    function GetEnumerator : TFhirTimingRepeatListEnumerator;
    

    //  Add a FhirTimingRepeat to the end of the list.
    function Append : TFhirTimingRepeat;

    
    // Add an already existing FhirTimingRepeat to the end of the list.
    procedure AddItem(value : TFhirTimingRepeat); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTimingRepeat) : Integer;
    

    // Insert FhirTimingRepeat before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTimingRepeat;
    

    // Insert an existing FhirTimingRepeat before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTimingRepeat);
    
    // Get the iIndexth FhirTimingRepeat. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTimingRepeat);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTimingRepeat;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTimingRepeats[index : Integer] : TFhirTimingRepeat read GetItemN write SetItemN; default;
  End;

  // Specifies an event that may occur multiple times. Timing schedules are used to record when things are planned, expected or requested to occur. The most common usage is in dosage instructions for medications. They are also used when planning care of various kinds, and may be used for reporting the schedule to which past regular activities were carried out.
  TFhirTiming = class (TFHIRBackboneType)
  protected
    FeventList : TFhirDateTimeList;
    FRepeat_ : TFhirTimingRepeat;
    FCode : TFhirCodeableConcept;
    function GetEventList : TFhirDateTimeList;
    function GetHasEventList : Boolean;
    Procedure SetRepeat_(value : TFhirTimingRepeat);
    Procedure SetCode(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTiming; overload;
    function Clone : TFhirTiming; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifies specific times when the event occurs.
    property eventList : TFhirDateTimeList read GetEventList;
    property hasEventList : boolean read GetHasEventList;

    // Typed access to A set of rules that describe when the event is scheduled. (defined for API consistency)
    property repeat_ : TFhirTimingRepeat read FRepeat_ write SetRepeat_;
    // A set of rules that describe when the event is scheduled.
    property repeat_Element : TFhirTimingRepeat read FRepeat_ write SetRepeat_;

    // Typed access to A code for the timing schedule (or just text in code.text). Some codes such as BID are ubiquitous, but many institutions define their own additional codes. If a code is provided, the code is understood to be a complete statement of whatever is specified in the structured timing data, and either the code or the data may be used to interpret the Timing, with the exception that .repeat.bounds still applies over the code (and is not contained in the code). (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code for the timing schedule (or just text in code.text). Some codes such as BID are ubiquitous, but many institutions define their own additional codes. If a code is provided, the code is understood to be a complete statement of whatever is specified in the structured timing data, and either the code or the data may be used to interpret the Timing, with the exception that .repeat.bounds still applies over the code (and is not contained in the code).
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

  end;

  TFhirTimingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTimingList;
    function GetCurrent : TFhirTiming;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTimingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTiming read GetCurrent;
  end;

  TFhirTimingList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTiming;
    procedure SetItemN(index : Integer; value : TFhirTiming);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTimingList; Overload;
    function Clone : TFhirTimingList; Overload;
    function GetEnumerator : TFhirTimingListEnumerator;
    

    //  Add a FhirTiming to the end of the list.
    function Append : TFhirTiming;

    
    // Add an already existing FhirTiming to the end of the list.
    procedure AddItem(value : TFhirTiming); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTiming) : Integer;
    

    // Insert FhirTiming before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTiming;
    

    // Insert an existing FhirTiming before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTiming);
    
    // Get the iIndexth FhirTiming. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTiming);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTiming;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirTimings[index : Integer] : TFhirTiming read GetItemN write SetItemN; default;
  End;

  // A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
  TFhirCount = class (TFhirQuantity)
  protected
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCount; overload;
    function Clone : TFhirCount; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
  end;

  TFhirCountListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCountList;
    function GetCurrent : TFhirCount;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCountList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCount read GetCurrent;
  end;

  TFhirCountList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCount;
    procedure SetItemN(index : Integer; value : TFhirCount);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCountList; Overload;
    function Clone : TFhirCountList; Overload;
    function GetEnumerator : TFhirCountListEnumerator;
    

    //  Add a FhirCount to the end of the list.
    function Append : TFhirCount;

    
    // Add an already existing FhirCount to the end of the list.
    procedure AddItem(value : TFhirCount); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCount) : Integer;
    

    // Insert FhirCount before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCount;
    

    // Insert an existing FhirCount before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCount);
    
    // Get the iIndexth FhirCount. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCount);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCount;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCounts[index : Integer] : TFhirCount read GetItemN write SetItemN; default;
  End;

  // A duration of time during which an organism (or a process) has existed.
  TFhirAge = class (TFhirQuantity)
  protected
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAge; overload;
    function Clone : TFhirAge; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
  end;

  TFhirAgeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAgeList;
    function GetCurrent : TFhirAge;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAgeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAge read GetCurrent;
  end;

  TFhirAgeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAge;
    procedure SetItemN(index : Integer; value : TFhirAge);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAgeList; Overload;
    function Clone : TFhirAgeList; Overload;
    function GetEnumerator : TFhirAgeListEnumerator;
    

    //  Add a FhirAge to the end of the list.
    function Append : TFhirAge;

    
    // Add an already existing FhirAge to the end of the list.
    procedure AddItem(value : TFhirAge); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAge) : Integer;
    

    // Insert FhirAge before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAge;
    

    // Insert an existing FhirAge before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAge);
    
    // Get the iIndexth FhirAge. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAge);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAge;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirAges[index : Integer] : TFhirAge read GetItemN write SetItemN; default;
  End;

  // A length - a value with a unit that is a physical distance.
  TFhirDistance = class (TFhirQuantity)
  protected
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDistance; overload;
    function Clone : TFhirDistance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
  end;

  TFhirDistanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDistanceList;
    function GetCurrent : TFhirDistance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDistanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDistance read GetCurrent;
  end;

  TFhirDistanceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDistance;
    procedure SetItemN(index : Integer; value : TFhirDistance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDistanceList; Overload;
    function Clone : TFhirDistanceList; Overload;
    function GetEnumerator : TFhirDistanceListEnumerator;
    

    //  Add a FhirDistance to the end of the list.
    function Append : TFhirDistance;

    
    // Add an already existing FhirDistance to the end of the list.
    procedure AddItem(value : TFhirDistance); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDistance) : Integer;
    

    // Insert FhirDistance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDistance;
    

    // Insert an existing FhirDistance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDistance);
    
    // Get the iIndexth FhirDistance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDistance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDistance;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDistances[index : Integer] : TFhirDistance read GetItemN write SetItemN; default;
  End;

  // A length of time.
  TFhirDuration = class (TFhirQuantity)
  protected
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDuration; overload;
    function Clone : TFhirDuration; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
  end;

  TFhirDurationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDurationList;
    function GetCurrent : TFhirDuration;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDurationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDuration read GetCurrent;
  end;

  TFhirDurationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDuration;
    procedure SetItemN(index : Integer; value : TFhirDuration);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDurationList; Overload;
    function Clone : TFhirDurationList; Overload;
    function GetEnumerator : TFhirDurationListEnumerator;
    

    //  Add a FhirDuration to the end of the list.
    function Append : TFhirDuration;

    
    // Add an already existing FhirDuration to the end of the list.
    procedure AddItem(value : TFhirDuration); overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDuration) : Integer;
    

    // Insert FhirDuration before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDuration;
    

    // Insert an existing FhirDuration before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDuration);
    
    // Get the iIndexth FhirDuration. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDuration);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDuration;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDurations[index : Integer] : TFhirDuration read GetItemN write SetItemN; default;
  End;

Const
  CODES_TFhirPublicationStatusEnum : Array[TFhirPublicationStatusEnum] of String = ('', 'draft', 'active', 'retired', 'unknown');
  SYSTEMS_TFhirPublicationStatusEnum : Array[TFhirPublicationStatusEnum] of String = ('', 'http://hl7.org/fhir/publication-status', 'http://hl7.org/fhir/publication-status', 'http://hl7.org/fhir/publication-status', 'http://hl7.org/fhir/publication-status');
  CODES_TFhirNarrativeStatusEnum : Array[TFhirNarrativeStatusEnum] of String = ('', 'generated', 'extensions', 'additional', 'empty');
  SYSTEMS_TFhirNarrativeStatusEnum : Array[TFhirNarrativeStatusEnum] of String = ('', 'http://hl7.org/fhir/narrative-status', 'http://hl7.org/fhir/narrative-status', 'http://hl7.org/fhir/narrative-status', 'http://hl7.org/fhir/narrative-status');
  CODES_TFhirContributorTypeEnum : Array[TFhirContributorTypeEnum] of String = ('', 'author', 'editor', 'reviewer', 'endorser');
  SYSTEMS_TFhirContributorTypeEnum : Array[TFhirContributorTypeEnum] of String = ('', 'http://hl7.org/fhir/contributor-type', 'http://hl7.org/fhir/contributor-type', 'http://hl7.org/fhir/contributor-type', 'http://hl7.org/fhir/contributor-type');
  CODES_TFhirAllTypesEnum : Array[TFhirAllTypesEnum] of String = ('', 'Address', 'Age', 'Annotation', 'Attachment', 'BackboneElement', 'CodeableConcept', 'Coding', 'ContactDetail', 'ContactPoint', 'Contributor', 'Count', 'DataRequirement', 'Distance', 'Dosage', 'Duration', 'Element', 'ElementDefinition', 'Expression', 'Extension', 'HumanName', 'Identifier', 'MarketingStatus', 'Meta', 'Money', 'MoneyQuantity', 'Narrative', 'ParameterDefinition', 'Period', 'Population', 'ProdCharacteristic', 'ProductShelfLife', 'Quantity', 'Range', 'Ratio', 'Reference', 'RelatedArtifact', 'SampledData', 'Signature', 'SimpleQuantity', 'SubstanceAmount', 'Timing', 'TriggerDefinition', 'UsageContext', 'base64Binary', 'boolean', 'canonical', 'code', 'date', 'dateTime', 'decimal', 'id', 'instant', 'integer', 'markdown', 'oid', 'positiveInt', 'string', 'time', 'unsignedInt', 'uri', 'url', 'uuid', 'xhtml', 'Account', 'ActivityDefinition', 'AdverseEvent', 'AllergyIntolerance', 'Appointment', 'AppointmentResponse', 
    'AuditEvent', 'Basic', 'Binary', 'BiologicallyDerivedProduct', 'BodyStructure', 'Bundle', 'CapabilityStatement', 'CarePlan', 'CareTeam', 'CatalogEntry', 'ChargeItem', 'ChargeItemDefinition', 'Claim', 'ClaimResponse', 'ClinicalImpression', 'CodeSystem', 'Communication', 'CommunicationRequest', 'CompartmentDefinition', 'Composition', 'ConceptMap', 'Condition', 'Consent', 'Contract', 'Coverage', 'CoverageEligibilityRequest', 'CoverageEligibilityResponse', 'DetectedIssue', 'Device', 'DeviceDefinition', 'DeviceMetric', 'DeviceRequest', 'DeviceUseStatement', 'DiagnosticReport', 'DocumentManifest', 'DocumentReference', 'DomainResource', 'EffectEvidenceSynthesis', 'Encounter', 'Endpoint', 'EnrollmentRequest', 'EnrollmentResponse', 'EpisodeOfCare', 'EventDefinition', 'Evidence', 'EvidenceVariable', 'ExampleScenario', 'ExplanationOfBenefit', 'FamilyMemberHistory', 'Flag', 'Goal', 'GraphDefinition', 'Group', 'GuidanceResponse', 'HealthcareService', 'ImagingStudy', 'Immunization', 'ImmunizationEvaluation', 
    'ImmunizationRecommendation', 'ImplementationGuide', 'InsurancePlan', 'Invoice', 'Library', 'Linkage', 'List', 'Location', 'Measure', 'MeasureReport', 'Media', 'Medication', 'MedicationAdministration', 'MedicationDispense', 'MedicationKnowledge', 'MedicationRequest', 'MedicationStatement', 'MedicinalProduct', 'MedicinalProductAuthorization', 'MedicinalProductContraindication', 'MedicinalProductIndication', 'MedicinalProductIngredient', 'MedicinalProductInteraction', 'MedicinalProductManufactured', 'MedicinalProductPackaged', 'MedicinalProductPharmaceutical', 'MedicinalProductUndesirableEffect', 'MessageDefinition', 'MessageHeader', 'MolecularSequence', 'NamingSystem', 'NutritionOrder', 'Observation', 'ObservationDefinition', 'OperationDefinition', 'OperationOutcome', 'Organization', 'OrganizationAffiliation', 'Parameters', 'Patient', 'PaymentNotice', 'PaymentReconciliation', 'Person', 'PlanDefinition', 'Practitioner', 'PractitionerRole', 'Procedure', 'Provenance', 'Questionnaire', 
    'QuestionnaireResponse', 'RelatedPerson', 'RequestGroup', 'ResearchDefinition', 'ResearchElementDefinition', 'ResearchStudy', 'ResearchSubject', 'Resource', 'RiskAssessment', 'RiskEvidenceSynthesis', 'Schedule', 'SearchParameter', 'ServiceRequest', 'Slot', 'Specimen', 'SpecimenDefinition', 'StructureDefinition', 'StructureMap', 'Subscription', 'Substance', 'SubstanceNucleicAcid', 'SubstancePolymer', 'SubstanceProtein', 'SubstanceReferenceInformation', 'SubstanceSourceMaterial', 'SubstanceSpecification', 'SupplyDelivery', 'SupplyRequest', 'Task', 'TerminologyCapabilities', 'TestReport', 'TestScript', 'ValueSet', 'VerificationResult', 'VisionPrescription', 'Type', 'Any');
  SYSTEMS_TFhirAllTypesEnum : Array[TFhirAllTypesEnum] of String = ('', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 
    'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 
    'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/data-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 
    'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 
    'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 
    'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 
    'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 
    'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/abstract-types', 'http://hl7.org/fhir/abstract-types');
  CODES_TFhirSortDirectionEnum : Array[TFhirSortDirectionEnum] of String = ('', 'ascending', 'descending');
  SYSTEMS_TFhirSortDirectionEnum : Array[TFhirSortDirectionEnum] of String = ('', 'http://hl7.org/fhir/sort-direction', 'http://hl7.org/fhir/sort-direction');
  CODES_TFhirIdentifierUseEnum : Array[TFhirIdentifierUseEnum] of String = ('', 'usual', 'official', 'temp', 'secondary', 'old');
  SYSTEMS_TFhirIdentifierUseEnum : Array[TFhirIdentifierUseEnum] of String = ('', 'http://hl7.org/fhir/identifier-use', 'http://hl7.org/fhir/identifier-use', 'http://hl7.org/fhir/identifier-use', 'http://hl7.org/fhir/identifier-use', 'http://hl7.org/fhir/identifier-use');
  CODES_TFhirTriggerTypeEnum : Array[TFhirTriggerTypeEnum] of String = ('', 'named-event', 'periodic', 'data-changed', 'data-added', 'data-modified', 'data-removed', 'data-accessed', 'data-access-ended');
  SYSTEMS_TFhirTriggerTypeEnum : Array[TFhirTriggerTypeEnum] of String = ('', 'http://hl7.org/fhir/trigger-type', 'http://hl7.org/fhir/trigger-type', 'http://hl7.org/fhir/trigger-type', 'http://hl7.org/fhir/trigger-type', 'http://hl7.org/fhir/trigger-type', 'http://hl7.org/fhir/trigger-type', 'http://hl7.org/fhir/trigger-type', 'http://hl7.org/fhir/trigger-type');
  CODES_TFhirQuantityComparatorEnum : Array[TFhirQuantityComparatorEnum] of String = ('', '<', '<=', '>=', '>');
  SYSTEMS_TFhirQuantityComparatorEnum : Array[TFhirQuantityComparatorEnum] of String = ('', 'http://hl7.org/fhir/quantity-comparator', 'http://hl7.org/fhir/quantity-comparator', 'http://hl7.org/fhir/quantity-comparator', 'http://hl7.org/fhir/quantity-comparator');
  CODES_TFhirRelatedArtifactTypeEnum : Array[TFhirRelatedArtifactTypeEnum] of String = ('', 'documentation', 'justification', 'citation', 'predecessor', 'successor', 'derived-from', 'depends-on', 'composed-of');
  SYSTEMS_TFhirRelatedArtifactTypeEnum : Array[TFhirRelatedArtifactTypeEnum] of String = ('', 'http://hl7.org/fhir/related-artifact-type', 'http://hl7.org/fhir/related-artifact-type', 'http://hl7.org/fhir/related-artifact-type', 'http://hl7.org/fhir/related-artifact-type', 'http://hl7.org/fhir/related-artifact-type', 'http://hl7.org/fhir/related-artifact-type', 'http://hl7.org/fhir/related-artifact-type', 'http://hl7.org/fhir/related-artifact-type');
  CODES_TFhirOperationParameterUseEnum : Array[TFhirOperationParameterUseEnum] of String = ('', 'in', 'out');
  SYSTEMS_TFhirOperationParameterUseEnum : Array[TFhirOperationParameterUseEnum] of String = ('', 'http://hl7.org/fhir/operation-parameter-use', 'http://hl7.org/fhir/operation-parameter-use');
  CODES_TFhirContactPointSystemEnum : Array[TFhirContactPointSystemEnum] of String = ('', 'phone', 'fax', 'email', 'pager', 'url', 'sms', 'other');
  SYSTEMS_TFhirContactPointSystemEnum : Array[TFhirContactPointSystemEnum] of String = ('', 'http://hl7.org/fhir/contact-point-system', 'http://hl7.org/fhir/contact-point-system', 'http://hl7.org/fhir/contact-point-system', 'http://hl7.org/fhir/contact-point-system', 'http://hl7.org/fhir/contact-point-system', 'http://hl7.org/fhir/contact-point-system', 'http://hl7.org/fhir/contact-point-system');
  CODES_TFhirContactPointUseEnum : Array[TFhirContactPointUseEnum] of String = ('', 'home', 'work', 'temp', 'old', 'mobile');
  SYSTEMS_TFhirContactPointUseEnum : Array[TFhirContactPointUseEnum] of String = ('', 'http://hl7.org/fhir/contact-point-use', 'http://hl7.org/fhir/contact-point-use', 'http://hl7.org/fhir/contact-point-use', 'http://hl7.org/fhir/contact-point-use', 'http://hl7.org/fhir/contact-point-use');
  CODES_TFhirNameUseEnum : Array[TFhirNameUseEnum] of String = ('', 'usual', 'official', 'temp', 'nickname', 'anonymous', 'old', 'maiden');
  SYSTEMS_TFhirNameUseEnum : Array[TFhirNameUseEnum] of String = ('', 'http://hl7.org/fhir/name-use', 'http://hl7.org/fhir/name-use', 'http://hl7.org/fhir/name-use', 'http://hl7.org/fhir/name-use', 'http://hl7.org/fhir/name-use', 'http://hl7.org/fhir/name-use', 'http://hl7.org/fhir/name-use');
  CODES_TFhirAddressUseEnum : Array[TFhirAddressUseEnum] of String = ('', 'home', 'work', 'temp', 'old', 'billing');
  SYSTEMS_TFhirAddressUseEnum : Array[TFhirAddressUseEnum] of String = ('', 'http://hl7.org/fhir/address-use', 'http://hl7.org/fhir/address-use', 'http://hl7.org/fhir/address-use', 'http://hl7.org/fhir/address-use', 'http://hl7.org/fhir/address-use');
  CODES_TFhirAddressTypeEnum : Array[TFhirAddressTypeEnum] of String = ('', 'postal', 'physical', 'both');
  SYSTEMS_TFhirAddressTypeEnum : Array[TFhirAddressTypeEnum] of String = ('', 'http://hl7.org/fhir/address-type', 'http://hl7.org/fhir/address-type', 'http://hl7.org/fhir/address-type');
  CODES_TFhirPropertyRepresentationEnum : Array[TFhirPropertyRepresentationEnum] of String = ('', 'xmlAttr', 'xmlText', 'typeAttr', 'cdaText', 'xhtml');
  SYSTEMS_TFhirPropertyRepresentationEnum : Array[TFhirPropertyRepresentationEnum] of String = ('', 'http://hl7.org/fhir/property-representation', 'http://hl7.org/fhir/property-representation', 'http://hl7.org/fhir/property-representation', 'http://hl7.org/fhir/property-representation', 'http://hl7.org/fhir/property-representation');
  CODES_TFhirDiscriminatorTypeEnum : Array[TFhirDiscriminatorTypeEnum] of String = ('', 'value', 'exists', 'pattern', 'type', 'profile');
  SYSTEMS_TFhirDiscriminatorTypeEnum : Array[TFhirDiscriminatorTypeEnum] of String = ('', 'http://hl7.org/fhir/discriminator-type', 'http://hl7.org/fhir/discriminator-type', 'http://hl7.org/fhir/discriminator-type', 'http://hl7.org/fhir/discriminator-type', 'http://hl7.org/fhir/discriminator-type');
  CODES_TFhirResourceSlicingRulesEnum : Array[TFhirResourceSlicingRulesEnum] of String = ('', 'closed', 'open', 'openAtEnd');
  SYSTEMS_TFhirResourceSlicingRulesEnum : Array[TFhirResourceSlicingRulesEnum] of String = ('', 'http://hl7.org/fhir/resource-slicing-rules', 'http://hl7.org/fhir/resource-slicing-rules', 'http://hl7.org/fhir/resource-slicing-rules');
  CODES_TFhirResourceAggregationModeEnum : Array[TFhirResourceAggregationModeEnum] of String = ('', 'contained', 'referenced', 'bundled');
  SYSTEMS_TFhirResourceAggregationModeEnum : Array[TFhirResourceAggregationModeEnum] of String = ('', 'http://hl7.org/fhir/resource-aggregation-mode', 'http://hl7.org/fhir/resource-aggregation-mode', 'http://hl7.org/fhir/resource-aggregation-mode');
  CODES_TFhirReferenceVersionRulesEnum : Array[TFhirReferenceVersionRulesEnum] of String = ('', 'either', 'independent', 'specific');
  SYSTEMS_TFhirReferenceVersionRulesEnum : Array[TFhirReferenceVersionRulesEnum] of String = ('', 'http://hl7.org/fhir/reference-version-rules', 'http://hl7.org/fhir/reference-version-rules', 'http://hl7.org/fhir/reference-version-rules');
  CODES_TFhirConstraintSeverityEnum : Array[TFhirConstraintSeverityEnum] of String = ('', 'error', 'warning');
  SYSTEMS_TFhirConstraintSeverityEnum : Array[TFhirConstraintSeverityEnum] of String = ('', 'http://hl7.org/fhir/constraint-severity', 'http://hl7.org/fhir/constraint-severity');
  CODES_TFhirBindingStrengthEnum : Array[TFhirBindingStrengthEnum] of String = ('', 'required', 'extensible', 'preferred', 'example');
  SYSTEMS_TFhirBindingStrengthEnum : Array[TFhirBindingStrengthEnum] of String = ('', 'http://hl7.org/fhir/binding-strength', 'http://hl7.org/fhir/binding-strength', 'http://hl7.org/fhir/binding-strength', 'http://hl7.org/fhir/binding-strength');
  CODES_TFhirUnitsOfTimeEnum : Array[TFhirUnitsOfTimeEnum] of String = ('', 's', 'min', 'h', 'd', 'wk', 'mo', 'a');
  SYSTEMS_TFhirUnitsOfTimeEnum : Array[TFhirUnitsOfTimeEnum] of String = ('', 'http://unitsofmeasure.org', 'http://unitsofmeasure.org', 'http://unitsofmeasure.org', 'http://unitsofmeasure.org', 'http://unitsofmeasure.org', 'http://unitsofmeasure.org', 'http://unitsofmeasure.org');
  CODES_TFhirDaysOfWeekEnum : Array[TFhirDaysOfWeekEnum] of String = ('', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun');
  SYSTEMS_TFhirDaysOfWeekEnum : Array[TFhirDaysOfWeekEnum] of String = ('', 'http://hl7.org/fhir/days-of-week', 'http://hl7.org/fhir/days-of-week', 'http://hl7.org/fhir/days-of-week', 'http://hl7.org/fhir/days-of-week', 'http://hl7.org/fhir/days-of-week', 'http://hl7.org/fhir/days-of-week', 'http://hl7.org/fhir/days-of-week');
  CODES_TFhirEventTimingEnum : Array[TFhirEventTimingEnum] of String = ('', 'MORN', 'MORN.early', 'MORN.late', 'NOON', 'AFT', 'AFT.early', 'AFT.late', 'EVE', 'EVE.early', 'EVE.late', 'NIGHT', 'PHS', 'HS', 'WAKE', 'C', 'CM', 'CD', 'CV', 'AC', 'ACM', 'ACD', 'ACV', 'PC', 'PCM', 'PCD', 'PCV');
  SYSTEMS_TFhirEventTimingEnum : Array[TFhirEventTimingEnum] of String = ('', 'http://hl7.org/fhir/event-timing', 'http://hl7.org/fhir/event-timing', 'http://hl7.org/fhir/event-timing', 'http://hl7.org/fhir/event-timing', 'http://hl7.org/fhir/event-timing', 'http://hl7.org/fhir/event-timing', 'http://hl7.org/fhir/event-timing', 'http://hl7.org/fhir/event-timing', 'http://hl7.org/fhir/event-timing', 'http://hl7.org/fhir/event-timing', 'http://hl7.org/fhir/event-timing', 'http://hl7.org/fhir/event-timing', 'http://terminology.hl7.org/CodeSystem/v3-TimingEvent', 'http://terminology.hl7.org/CodeSystem/v3-TimingEvent', 'http://terminology.hl7.org/CodeSystem/v3-TimingEvent', 'http://terminology.hl7.org/CodeSystem/v3-TimingEvent', 'http://terminology.hl7.org/CodeSystem/v3-TimingEvent', 'http://terminology.hl7.org/CodeSystem/v3-TimingEvent', 'http://terminology.hl7.org/CodeSystem/v3-TimingEvent', 'http://terminology.hl7.org/CodeSystem/v3-TimingEvent', 'http://terminology.hl7.org/CodeSystem/v3-TimingEvent', 
    'http://terminology.hl7.org/CodeSystem/v3-TimingEvent', 'http://terminology.hl7.org/CodeSystem/v3-TimingEvent', 'http://terminology.hl7.org/CodeSystem/v3-TimingEvent', 'http://terminology.hl7.org/CodeSystem/v3-TimingEvent', 'http://terminology.hl7.org/CodeSystem/v3-TimingEvent');
  CODES_TFhirAccountStatusEnum : Array[TFhirAccountStatusEnum] of String = ('', 'active', 'inactive', 'entered-in-error', 'on-hold', 'unknown');
  SYSTEMS_TFhirAccountStatusEnum : Array[TFhirAccountStatusEnum] of String = ('', 'http://hl7.org/fhir/account-status', 'http://hl7.org/fhir/account-status', 'http://hl7.org/fhir/account-status', 'http://hl7.org/fhir/account-status', 'http://hl7.org/fhir/account-status');
  CODES_TFhirRequestResourceTypesEnum : Array[TFhirRequestResourceTypesEnum] of String = ('', 'Appointment', 'AppointmentResponse', 'CarePlan', 'Claim', 'CommunicationRequest', 'Contract', 'DeviceRequest', 'EnrollmentRequest', 'ImmunizationRecommendation', 'MedicationRequest', 'NutritionOrder', 'ServiceRequest', 'SupplyRequest', 'Task', 'VisionPrescription');
  SYSTEMS_TFhirRequestResourceTypesEnum : Array[TFhirRequestResourceTypesEnum] of String = ('', 'http://hl7.org/fhir/request-resource-types', 'http://hl7.org/fhir/request-resource-types', 'http://hl7.org/fhir/request-resource-types', 'http://hl7.org/fhir/request-resource-types', 'http://hl7.org/fhir/request-resource-types', 'http://hl7.org/fhir/request-resource-types', 'http://hl7.org/fhir/request-resource-types', 'http://hl7.org/fhir/request-resource-types', 'http://hl7.org/fhir/request-resource-types', 'http://hl7.org/fhir/request-resource-types', 'http://hl7.org/fhir/request-resource-types', 'http://hl7.org/fhir/request-resource-types', 'http://hl7.org/fhir/request-resource-types', 'http://hl7.org/fhir/request-resource-types', 'http://hl7.org/fhir/request-resource-types');
  CODES_TFhirRequestIntentEnum : Array[TFhirRequestIntentEnum] of String = ('', 'proposal', 'plan', 'directive', 'order', 'original-order', 'reflex-order', 'filler-order', 'instance-order', 'option');
  SYSTEMS_TFhirRequestIntentEnum : Array[TFhirRequestIntentEnum] of String = ('', 'http://hl7.org/fhir/request-intent', 'http://hl7.org/fhir/request-intent', 'http://hl7.org/fhir/request-intent', 'http://hl7.org/fhir/request-intent', 'http://hl7.org/fhir/request-intent', 'http://hl7.org/fhir/request-intent', 'http://hl7.org/fhir/request-intent', 'http://hl7.org/fhir/request-intent', 'http://hl7.org/fhir/request-intent');
  CODES_TFhirRequestPriorityEnum : Array[TFhirRequestPriorityEnum] of String = ('', 'routine', 'urgent', 'asap', 'stat');
  SYSTEMS_TFhirRequestPriorityEnum : Array[TFhirRequestPriorityEnum] of String = ('', 'http://hl7.org/fhir/request-priority', 'http://hl7.org/fhir/request-priority', 'http://hl7.org/fhir/request-priority', 'http://hl7.org/fhir/request-priority');
  CODES_TFhirActionParticipantTypeEnum : Array[TFhirActionParticipantTypeEnum] of String = ('', 'patient', 'practitioner', 'related-person', 'device');
  SYSTEMS_TFhirActionParticipantTypeEnum : Array[TFhirActionParticipantTypeEnum] of String = ('', 'http://hl7.org/fhir/action-participant-type', 'http://hl7.org/fhir/action-participant-type', 'http://hl7.org/fhir/action-participant-type', 'http://hl7.org/fhir/action-participant-type');
  CODES_TFhirAdverseEventActualityEnum : Array[TFhirAdverseEventActualityEnum] of String = ('', 'actual', 'potential');
  SYSTEMS_TFhirAdverseEventActualityEnum : Array[TFhirAdverseEventActualityEnum] of String = ('', 'http://hl7.org/fhir/adverse-event-actuality', 'http://hl7.org/fhir/adverse-event-actuality');
  CODES_TFhirAllergyIntoleranceTypeEnum : Array[TFhirAllergyIntoleranceTypeEnum] of String = ('', 'allergy', 'intolerance');
  SYSTEMS_TFhirAllergyIntoleranceTypeEnum : Array[TFhirAllergyIntoleranceTypeEnum] of String = ('', 'http://hl7.org/fhir/allergy-intolerance-type', 'http://hl7.org/fhir/allergy-intolerance-type');
  CODES_TFhirAllergyIntoleranceCategoryEnum : Array[TFhirAllergyIntoleranceCategoryEnum] of String = ('', 'food', 'medication', 'environment', 'biologic');
  SYSTEMS_TFhirAllergyIntoleranceCategoryEnum : Array[TFhirAllergyIntoleranceCategoryEnum] of String = ('', 'http://hl7.org/fhir/allergy-intolerance-category', 'http://hl7.org/fhir/allergy-intolerance-category', 'http://hl7.org/fhir/allergy-intolerance-category', 'http://hl7.org/fhir/allergy-intolerance-category');
  CODES_TFhirAllergyIntoleranceCriticalityEnum : Array[TFhirAllergyIntoleranceCriticalityEnum] of String = ('', 'low', 'high', 'unable-to-assess');
  SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum : Array[TFhirAllergyIntoleranceCriticalityEnum] of String = ('', 'http://hl7.org/fhir/allergy-intolerance-criticality', 'http://hl7.org/fhir/allergy-intolerance-criticality', 'http://hl7.org/fhir/allergy-intolerance-criticality');
  CODES_TFhirReactionEventSeverityEnum : Array[TFhirReactionEventSeverityEnum] of String = ('', 'mild', 'moderate', 'severe');
  SYSTEMS_TFhirReactionEventSeverityEnum : Array[TFhirReactionEventSeverityEnum] of String = ('', 'http://hl7.org/fhir/reaction-event-severity', 'http://hl7.org/fhir/reaction-event-severity', 'http://hl7.org/fhir/reaction-event-severity');
  CODES_TFhirAppointmentstatusEnum : Array[TFhirAppointmentstatusEnum] of String = ('', 'proposed', 'pending', 'booked', 'arrived', 'fulfilled', 'cancelled', 'noshow', 'entered-in-error', 'checked-in', 'waitlist');
  SYSTEMS_TFhirAppointmentstatusEnum : Array[TFhirAppointmentstatusEnum] of String = ('', 'http://hl7.org/fhir/appointmentstatus', 'http://hl7.org/fhir/appointmentstatus', 'http://hl7.org/fhir/appointmentstatus', 'http://hl7.org/fhir/appointmentstatus', 'http://hl7.org/fhir/appointmentstatus', 'http://hl7.org/fhir/appointmentstatus', 'http://hl7.org/fhir/appointmentstatus', 'http://hl7.org/fhir/appointmentstatus', 'http://hl7.org/fhir/appointmentstatus', 'http://hl7.org/fhir/appointmentstatus');
  CODES_TFhirParticipantrequiredEnum : Array[TFhirParticipantrequiredEnum] of String = ('', 'required', 'optional', 'information-only');
  SYSTEMS_TFhirParticipantrequiredEnum : Array[TFhirParticipantrequiredEnum] of String = ('', 'http://hl7.org/fhir/participantrequired', 'http://hl7.org/fhir/participantrequired', 'http://hl7.org/fhir/participantrequired');
  CODES_TFhirParticipationstatusEnum : Array[TFhirParticipationstatusEnum] of String = ('', 'accepted', 'declined', 'tentative', 'needs-action');
  SYSTEMS_TFhirParticipationstatusEnum : Array[TFhirParticipationstatusEnum] of String = ('', 'http://hl7.org/fhir/participationstatus', 'http://hl7.org/fhir/participationstatus', 'http://hl7.org/fhir/participationstatus', 'http://hl7.org/fhir/participationstatus');
  CODES_TFhirAuditEventActionEnum : Array[TFhirAuditEventActionEnum] of String = ('', 'C', 'R', 'U', 'D', 'E');
  SYSTEMS_TFhirAuditEventActionEnum : Array[TFhirAuditEventActionEnum] of String = ('', 'http://hl7.org/fhir/audit-event-action', 'http://hl7.org/fhir/audit-event-action', 'http://hl7.org/fhir/audit-event-action', 'http://hl7.org/fhir/audit-event-action', 'http://hl7.org/fhir/audit-event-action');
  CODES_TFhirAuditEventOutcomeEnum : Array[TFhirAuditEventOutcomeEnum] of String = ('', '0', '4', '8', '12');
  SYSTEMS_TFhirAuditEventOutcomeEnum : Array[TFhirAuditEventOutcomeEnum] of String = ('', 'http://hl7.org/fhir/audit-event-outcome', 'http://hl7.org/fhir/audit-event-outcome', 'http://hl7.org/fhir/audit-event-outcome', 'http://hl7.org/fhir/audit-event-outcome');
  CODES_TFhirNetworkTypeEnum : Array[TFhirNetworkTypeEnum] of String = ('', '1', '2', '3', '4', '5');
  SYSTEMS_TFhirNetworkTypeEnum : Array[TFhirNetworkTypeEnum] of String = ('', 'http://hl7.org/fhir/network-type', 'http://hl7.org/fhir/network-type', 'http://hl7.org/fhir/network-type', 'http://hl7.org/fhir/network-type', 'http://hl7.org/fhir/network-type');
  CODES_TFhirProductCategoryEnum : Array[TFhirProductCategoryEnum] of String = ('', 'organ', 'tissue', 'fluid', 'cells', 'biologicalAgent');
  SYSTEMS_TFhirProductCategoryEnum : Array[TFhirProductCategoryEnum] of String = ('', 'http://hl7.org/fhir/product-category', 'http://hl7.org/fhir/product-category', 'http://hl7.org/fhir/product-category', 'http://hl7.org/fhir/product-category', 'http://hl7.org/fhir/product-category');
  CODES_TFhirProductStatusEnum : Array[TFhirProductStatusEnum] of String = ('', 'available', 'unavailable');
  SYSTEMS_TFhirProductStatusEnum : Array[TFhirProductStatusEnum] of String = ('', 'http://hl7.org/fhir/product-status', 'http://hl7.org/fhir/product-status');
  CODES_TFhirProductStorageScaleEnum : Array[TFhirProductStorageScaleEnum] of String = ('', 'farenheit', 'celsius', 'kelvin');
  SYSTEMS_TFhirProductStorageScaleEnum : Array[TFhirProductStorageScaleEnum] of String = ('', 'http://hl7.org/fhir/product-storage-scale', 'http://hl7.org/fhir/product-storage-scale', 'http://hl7.org/fhir/product-storage-scale');
  CODES_TFhirBundleTypeEnum : Array[TFhirBundleTypeEnum] of String = ('', 'document', 'message', 'transaction', 'transaction-response', 'batch', 'batch-response', 'history', 'searchset', 'collection');
  SYSTEMS_TFhirBundleTypeEnum : Array[TFhirBundleTypeEnum] of String = ('', 'http://hl7.org/fhir/bundle-type', 'http://hl7.org/fhir/bundle-type', 'http://hl7.org/fhir/bundle-type', 'http://hl7.org/fhir/bundle-type', 'http://hl7.org/fhir/bundle-type', 'http://hl7.org/fhir/bundle-type', 'http://hl7.org/fhir/bundle-type', 'http://hl7.org/fhir/bundle-type', 'http://hl7.org/fhir/bundle-type');
  CODES_TFhirSearchEntryModeEnum : Array[TFhirSearchEntryModeEnum] of String = ('', 'match', 'include', 'outcome');
  SYSTEMS_TFhirSearchEntryModeEnum : Array[TFhirSearchEntryModeEnum] of String = ('', 'http://hl7.org/fhir/search-entry-mode', 'http://hl7.org/fhir/search-entry-mode', 'http://hl7.org/fhir/search-entry-mode');
  CODES_TFhirHttpVerbEnum : Array[TFhirHttpVerbEnum] of String = ('', 'GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'PATCH');
  SYSTEMS_TFhirHttpVerbEnum : Array[TFhirHttpVerbEnum] of String = ('', 'http://hl7.org/fhir/http-verb', 'http://hl7.org/fhir/http-verb', 'http://hl7.org/fhir/http-verb', 'http://hl7.org/fhir/http-verb', 'http://hl7.org/fhir/http-verb', 'http://hl7.org/fhir/http-verb');
  CODES_TFhirCapabilityStatementKindEnum : Array[TFhirCapabilityStatementKindEnum] of String = ('', 'instance', 'capability', 'requirements');
  SYSTEMS_TFhirCapabilityStatementKindEnum : Array[TFhirCapabilityStatementKindEnum] of String = ('', 'http://hl7.org/fhir/capability-statement-kind', 'http://hl7.org/fhir/capability-statement-kind', 'http://hl7.org/fhir/capability-statement-kind');
  CODES_TFhirFHIRVersionEnum : Array[TFhirFHIRVersionEnum] of String = ('', '0.01', '0.05', '0.06', '0.11', '0.0.80', '0.0.81', '0.0.82', '0.4.0', '0.5.0', '1.0.0', '1.0.1', '1.0.2', '1.1.0', '1.4.0', '1.6.0', '1.8.0', '3.0.0', '3.0.1', '3.0.2', '3.3.0', '3.5.0', '4.0.0', '4.0.1');
  SYSTEMS_TFhirFHIRVersionEnum : Array[TFhirFHIRVersionEnum] of String = ('', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version', 'http://hl7.org/fhir/FHIR-version');
  CODES_TFhirRestfulCapabilityModeEnum : Array[TFhirRestfulCapabilityModeEnum] of String = ('', 'client', 'server');
  SYSTEMS_TFhirRestfulCapabilityModeEnum : Array[TFhirRestfulCapabilityModeEnum] of String = ('', 'http://hl7.org/fhir/restful-capability-mode', 'http://hl7.org/fhir/restful-capability-mode');
  CODES_TFhirResourceTypesEnum : Array[TFhirResourceTypesEnum] of String = ('', 'Account', 'ActivityDefinition', 'AdverseEvent', 'AllergyIntolerance', 'Appointment', 'AppointmentResponse', 'AuditEvent', 'Basic', 'Binary', 'BiologicallyDerivedProduct', 'BodyStructure', 'Bundle', 'CapabilityStatement', 'CarePlan', 'CareTeam', 'CatalogEntry', 'ChargeItem', 'ChargeItemDefinition', 'Claim', 'ClaimResponse', 'ClinicalImpression', 'CodeSystem', 'Communication', 'CommunicationRequest', 'CompartmentDefinition', 'Composition', 'ConceptMap', 'Condition', 'Consent', 'Contract', 'Coverage', 'CoverageEligibilityRequest', 'CoverageEligibilityResponse', 'DetectedIssue', 'Device', 'DeviceDefinition', 'DeviceMetric', 'DeviceRequest', 'DeviceUseStatement', 'DiagnosticReport', 'DocumentManifest', 'DocumentReference', 'DomainResource', 'EffectEvidenceSynthesis', 'Encounter', 'Endpoint', 'EnrollmentRequest', 'EnrollmentResponse', 'EpisodeOfCare', 'EventDefinition', 'Evidence', 'EvidenceVariable', 'ExampleScenario', 
    'ExplanationOfBenefit', 'FamilyMemberHistory', 'Flag', 'Goal', 'GraphDefinition', 'Group', 'GuidanceResponse', 'HealthcareService', 'ImagingStudy', 'Immunization', 'ImmunizationEvaluation', 'ImmunizationRecommendation', 'ImplementationGuide', 'InsurancePlan', 'Invoice', 'Library', 'Linkage', 'List', 'Location', 'Measure', 'MeasureReport', 'Media', 'Medication', 'MedicationAdministration', 'MedicationDispense', 'MedicationKnowledge', 'MedicationRequest', 'MedicationStatement', 'MedicinalProduct', 'MedicinalProductAuthorization', 'MedicinalProductContraindication', 'MedicinalProductIndication', 'MedicinalProductIngredient', 'MedicinalProductInteraction', 'MedicinalProductManufactured', 'MedicinalProductPackaged', 'MedicinalProductPharmaceutical', 'MedicinalProductUndesirableEffect', 'MessageDefinition', 'MessageHeader', 'MolecularSequence', 'NamingSystem', 'NutritionOrder', 'Observation', 'ObservationDefinition', 'OperationDefinition', 'OperationOutcome', 'Organization', 'OrganizationAffiliation', 
    'Parameters', 'Patient', 'PaymentNotice', 'PaymentReconciliation', 'Person', 'PlanDefinition', 'Practitioner', 'PractitionerRole', 'Procedure', 'Provenance', 'Questionnaire', 'QuestionnaireResponse', 'RelatedPerson', 'RequestGroup', 'ResearchDefinition', 'ResearchElementDefinition', 'ResearchStudy', 'ResearchSubject', 'Resource', 'RiskAssessment', 'RiskEvidenceSynthesis', 'Schedule', 'SearchParameter', 'ServiceRequest', 'Slot', 'Specimen', 'SpecimenDefinition', 'StructureDefinition', 'StructureMap', 'Subscription', 'Substance', 'SubstanceNucleicAcid', 'SubstancePolymer', 'SubstanceProtein', 'SubstanceReferenceInformation', 'SubstanceSourceMaterial', 'SubstanceSpecification', 'SupplyDelivery', 'SupplyRequest', 'Task', 'TerminologyCapabilities', 'TestReport', 'TestScript', 'ValueSet', 'VerificationResult', 'VisionPrescription');
  SYSTEMS_TFhirResourceTypesEnum : Array[TFhirResourceTypesEnum] of String = ('', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 
    'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 
    'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 
    'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 
    'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 
    'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types');
  CODES_TFhirTypeRestfulInteractionEnum : Array[TFhirTypeRestfulInteractionEnum] of String = ('', 'read', 'vread', 'update', 'patch', 'delete', 'history-instance', 'history-type', 'create', 'search-type');
  SYSTEMS_TFhirTypeRestfulInteractionEnum : Array[TFhirTypeRestfulInteractionEnum] of String = ('', 'http://hl7.org/fhir/restful-interaction', 'http://hl7.org/fhir/restful-interaction', 'http://hl7.org/fhir/restful-interaction', 'http://hl7.org/fhir/restful-interaction', 'http://hl7.org/fhir/restful-interaction', 'http://hl7.org/fhir/restful-interaction', 'http://hl7.org/fhir/restful-interaction', 'http://hl7.org/fhir/restful-interaction', 'http://hl7.org/fhir/restful-interaction');
  CODES_TFhirVersioningPolicyEnum : Array[TFhirVersioningPolicyEnum] of String = ('', 'no-version', 'versioned', 'versioned-update');
  SYSTEMS_TFhirVersioningPolicyEnum : Array[TFhirVersioningPolicyEnum] of String = ('', 'http://hl7.org/fhir/versioning-policy', 'http://hl7.org/fhir/versioning-policy', 'http://hl7.org/fhir/versioning-policy');
  CODES_TFhirConditionalReadStatusEnum : Array[TFhirConditionalReadStatusEnum] of String = ('', 'not-supported', 'modified-since', 'not-match', 'full-support');
  SYSTEMS_TFhirConditionalReadStatusEnum : Array[TFhirConditionalReadStatusEnum] of String = ('', 'http://hl7.org/fhir/conditional-read-status', 'http://hl7.org/fhir/conditional-read-status', 'http://hl7.org/fhir/conditional-read-status', 'http://hl7.org/fhir/conditional-read-status');
  CODES_TFhirConditionalDeleteStatusEnum : Array[TFhirConditionalDeleteStatusEnum] of String = ('', 'not-supported', 'single', 'multiple');
  SYSTEMS_TFhirConditionalDeleteStatusEnum : Array[TFhirConditionalDeleteStatusEnum] of String = ('', 'http://hl7.org/fhir/conditional-delete-status', 'http://hl7.org/fhir/conditional-delete-status', 'http://hl7.org/fhir/conditional-delete-status');
  CODES_TFhirReferenceHandlingPolicyEnum : Array[TFhirReferenceHandlingPolicyEnum] of String = ('', 'literal', 'logical', 'resolves', 'enforced', 'local');
  SYSTEMS_TFhirReferenceHandlingPolicyEnum : Array[TFhirReferenceHandlingPolicyEnum] of String = ('', 'http://hl7.org/fhir/reference-handling-policy', 'http://hl7.org/fhir/reference-handling-policy', 'http://hl7.org/fhir/reference-handling-policy', 'http://hl7.org/fhir/reference-handling-policy', 'http://hl7.org/fhir/reference-handling-policy');
  CODES_TFhirSearchParamTypeEnum : Array[TFhirSearchParamTypeEnum] of String = ('', 'number', 'date', 'string', 'token', 'reference', 'composite', 'quantity', 'uri', 'special');
  SYSTEMS_TFhirSearchParamTypeEnum : Array[TFhirSearchParamTypeEnum] of String = ('', 'http://hl7.org/fhir/search-param-type', 'http://hl7.org/fhir/search-param-type', 'http://hl7.org/fhir/search-param-type', 'http://hl7.org/fhir/search-param-type', 'http://hl7.org/fhir/search-param-type', 'http://hl7.org/fhir/search-param-type', 'http://hl7.org/fhir/search-param-type', 'http://hl7.org/fhir/search-param-type', 'http://hl7.org/fhir/search-param-type');
  CODES_TFhirSystemRestfulInteractionEnum : Array[TFhirSystemRestfulInteractionEnum] of String = ('', 'transaction', 'batch', 'search-system', 'history-system');
  SYSTEMS_TFhirSystemRestfulInteractionEnum : Array[TFhirSystemRestfulInteractionEnum] of String = ('', 'http://hl7.org/fhir/restful-interaction', 'http://hl7.org/fhir/restful-interaction', 'http://hl7.org/fhir/restful-interaction', 'http://hl7.org/fhir/restful-interaction');
  CODES_TFhirEventCapabilityModeEnum : Array[TFhirEventCapabilityModeEnum] of String = ('', 'sender', 'receiver');
  SYSTEMS_TFhirEventCapabilityModeEnum : Array[TFhirEventCapabilityModeEnum] of String = ('', 'http://hl7.org/fhir/event-capability-mode', 'http://hl7.org/fhir/event-capability-mode');
  CODES_TFhirDocumentModeEnum : Array[TFhirDocumentModeEnum] of String = ('', 'producer', 'consumer');
  SYSTEMS_TFhirDocumentModeEnum : Array[TFhirDocumentModeEnum] of String = ('', 'http://hl7.org/fhir/document-mode', 'http://hl7.org/fhir/document-mode');
  CODES_TFhirRequestStatusEnum : Array[TFhirRequestStatusEnum] of String = ('', 'draft', 'active', 'on-hold', 'revoked', 'completed', 'entered-in-error', 'unknown');
  SYSTEMS_TFhirRequestStatusEnum : Array[TFhirRequestStatusEnum] of String = ('', 'http://hl7.org/fhir/request-status', 'http://hl7.org/fhir/request-status', 'http://hl7.org/fhir/request-status', 'http://hl7.org/fhir/request-status', 'http://hl7.org/fhir/request-status', 'http://hl7.org/fhir/request-status', 'http://hl7.org/fhir/request-status');
  CODES_TFhirCarePlanIntentEnum : Array[TFhirCarePlanIntentEnum] of String = ('', 'proposal', 'plan', 'order', 'option');
  SYSTEMS_TFhirCarePlanIntentEnum : Array[TFhirCarePlanIntentEnum] of String = ('', 'http://hl7.org/fhir/request-intent', 'http://hl7.org/fhir/request-intent', 'http://hl7.org/fhir/request-intent', 'http://hl7.org/fhir/request-intent');
  CODES_TFhirCarePlanActivityKindEnum : Array[TFhirCarePlanActivityKindEnum] of String = ('', 'Appointment', 'CommunicationRequest', 'DeviceRequest', 'MedicationRequest', 'NutritionOrder', 'Task', 'ServiceRequest', 'VisionPrescription');
  SYSTEMS_TFhirCarePlanActivityKindEnum : Array[TFhirCarePlanActivityKindEnum] of String = ('', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types', 'http://hl7.org/fhir/resource-types');
  CODES_TFhirCarePlanActivityStatusEnum : Array[TFhirCarePlanActivityStatusEnum] of String = ('', 'not-started', 'scheduled', 'in-progress', 'on-hold', 'completed', 'cancelled', 'stopped', 'unknown', 'entered-in-error');
  SYSTEMS_TFhirCarePlanActivityStatusEnum : Array[TFhirCarePlanActivityStatusEnum] of String = ('', 'http://hl7.org/fhir/care-plan-activity-status', 'http://hl7.org/fhir/care-plan-activity-status', 'http://hl7.org/fhir/care-plan-activity-status', 'http://hl7.org/fhir/care-plan-activity-status', 'http://hl7.org/fhir/care-plan-activity-status', 'http://hl7.org/fhir/care-plan-activity-status', 'http://hl7.org/fhir/care-plan-activity-status', 'http://hl7.org/fhir/care-plan-activity-status', 'http://hl7.org/fhir/care-plan-activity-status');
  CODES_TFhirCareTeamStatusEnum : Array[TFhirCareTeamStatusEnum] of String = ('', 'proposed', 'active', 'suspended', 'inactive', 'entered-in-error');
  SYSTEMS_TFhirCareTeamStatusEnum : Array[TFhirCareTeamStatusEnum] of String = ('', 'http://hl7.org/fhir/care-team-status', 'http://hl7.org/fhir/care-team-status', 'http://hl7.org/fhir/care-team-status', 'http://hl7.org/fhir/care-team-status', 'http://hl7.org/fhir/care-team-status');
  CODES_TFhirRelationTypeEnum : Array[TFhirRelationTypeEnum] of String = ('', 'triggers', 'is-replaced-by');
  SYSTEMS_TFhirRelationTypeEnum : Array[TFhirRelationTypeEnum] of String = ('', 'http://hl7.org/fhir/relation-type', 'http://hl7.org/fhir/relation-type');
  CODES_TFhirChargeitemStatusEnum : Array[TFhirChargeitemStatusEnum] of String = ('', 'planned', 'billable', 'not-billable', 'aborted', 'billed', 'entered-in-error', 'unknown');
  SYSTEMS_TFhirChargeitemStatusEnum : Array[TFhirChargeitemStatusEnum] of String = ('', 'http://hl7.org/fhir/chargeitem-status', 'http://hl7.org/fhir/chargeitem-status', 'http://hl7.org/fhir/chargeitem-status', 'http://hl7.org/fhir/chargeitem-status', 'http://hl7.org/fhir/chargeitem-status', 'http://hl7.org/fhir/chargeitem-status', 'http://hl7.org/fhir/chargeitem-status');
  CODES_TFhirInvoicePriceComponentTypeEnum : Array[TFhirInvoicePriceComponentTypeEnum] of String = ('', 'base', 'surcharge', 'deduction', 'discount', 'tax', 'informational');
  SYSTEMS_TFhirInvoicePriceComponentTypeEnum : Array[TFhirInvoicePriceComponentTypeEnum] of String = ('', 'http://hl7.org/fhir/invoice-priceComponentType', 'http://hl7.org/fhir/invoice-priceComponentType', 'http://hl7.org/fhir/invoice-priceComponentType', 'http://hl7.org/fhir/invoice-priceComponentType', 'http://hl7.org/fhir/invoice-priceComponentType', 'http://hl7.org/fhir/invoice-priceComponentType');
  CODES_TFhirFmStatusEnum : Array[TFhirFmStatusEnum] of String = ('', 'active', 'cancelled', 'draft', 'entered-in-error');
  SYSTEMS_TFhirFmStatusEnum : Array[TFhirFmStatusEnum] of String = ('', 'http://hl7.org/fhir/fm-status', 'http://hl7.org/fhir/fm-status', 'http://hl7.org/fhir/fm-status', 'http://hl7.org/fhir/fm-status');
  CODES_TFhirClaimUseEnum : Array[TFhirClaimUseEnum] of String = ('', 'claim', 'preauthorization', 'predetermination');
  SYSTEMS_TFhirClaimUseEnum : Array[TFhirClaimUseEnum] of String = ('', 'http://hl7.org/fhir/claim-use', 'http://hl7.org/fhir/claim-use', 'http://hl7.org/fhir/claim-use');
  CODES_TFhirRemittanceOutcomeEnum : Array[TFhirRemittanceOutcomeEnum] of String = ('', 'queued', 'complete', 'error', 'partial');
  SYSTEMS_TFhirRemittanceOutcomeEnum : Array[TFhirRemittanceOutcomeEnum] of String = ('', 'http://hl7.org/fhir/remittance-outcome', 'http://hl7.org/fhir/remittance-outcome', 'http://hl7.org/fhir/remittance-outcome', 'http://hl7.org/fhir/remittance-outcome');
  CODES_TFhirNoteTypeEnum : Array[TFhirNoteTypeEnum] of String = ('', 'display', 'print', 'printoper');
  SYSTEMS_TFhirNoteTypeEnum : Array[TFhirNoteTypeEnum] of String = ('', 'http://hl7.org/fhir/note-type', 'http://hl7.org/fhir/note-type', 'http://hl7.org/fhir/note-type');
  CODES_TFhirClinicalimpressionStatusEnum : Array[TFhirClinicalimpressionStatusEnum] of String = ('', 'in-progress', 'completed', 'entered-in-error');
  SYSTEMS_TFhirClinicalimpressionStatusEnum : Array[TFhirClinicalimpressionStatusEnum] of String = ('', 'http://hl7.org/fhir/event-status', 'http://hl7.org/fhir/event-status', 'http://hl7.org/fhir/event-status');
  CODES_TFhirCodesystemHierarchyMeaningEnum : Array[TFhirCodesystemHierarchyMeaningEnum] of String = ('', 'grouped-by', 'is-a', 'part-of', 'classified-with');
  SYSTEMS_TFhirCodesystemHierarchyMeaningEnum : Array[TFhirCodesystemHierarchyMeaningEnum] of String = ('', 'http://hl7.org/fhir/codesystem-hierarchy-meaning', 'http://hl7.org/fhir/codesystem-hierarchy-meaning', 'http://hl7.org/fhir/codesystem-hierarchy-meaning', 'http://hl7.org/fhir/codesystem-hierarchy-meaning');
  CODES_TFhirCodesystemContentModeEnum : Array[TFhirCodesystemContentModeEnum] of String = ('', 'not-present', 'example', 'fragment', 'complete', 'supplement');
  SYSTEMS_TFhirCodesystemContentModeEnum : Array[TFhirCodesystemContentModeEnum] of String = ('', 'http://hl7.org/fhir/codesystem-content-mode', 'http://hl7.org/fhir/codesystem-content-mode', 'http://hl7.org/fhir/codesystem-content-mode', 'http://hl7.org/fhir/codesystem-content-mode', 'http://hl7.org/fhir/codesystem-content-mode');
  CODES_TFhirFilterOperatorEnum : Array[TFhirFilterOperatorEnum] of String = ('', '=', 'is-a', 'descendent-of', 'is-not-a', 'regex', 'in', 'not-in', 'generalizes', 'exists');
  SYSTEMS_TFhirFilterOperatorEnum : Array[TFhirFilterOperatorEnum] of String = ('', 'http://hl7.org/fhir/filter-operator', 'http://hl7.org/fhir/filter-operator', 'http://hl7.org/fhir/filter-operator', 'http://hl7.org/fhir/filter-operator', 'http://hl7.org/fhir/filter-operator', 'http://hl7.org/fhir/filter-operator', 'http://hl7.org/fhir/filter-operator', 'http://hl7.org/fhir/filter-operator', 'http://hl7.org/fhir/filter-operator');
  CODES_TFhirConceptPropertyTypeEnum : Array[TFhirConceptPropertyTypeEnum] of String = ('', 'code', 'Coding', 'string', 'integer', 'boolean', 'dateTime', 'decimal');
  SYSTEMS_TFhirConceptPropertyTypeEnum : Array[TFhirConceptPropertyTypeEnum] of String = ('', 'http://hl7.org/fhir/concept-property-type', 'http://hl7.org/fhir/concept-property-type', 'http://hl7.org/fhir/concept-property-type', 'http://hl7.org/fhir/concept-property-type', 'http://hl7.org/fhir/concept-property-type', 'http://hl7.org/fhir/concept-property-type', 'http://hl7.org/fhir/concept-property-type');
  CODES_TFhirEventStatusEnum : Array[TFhirEventStatusEnum] of String = ('', 'preparation', 'in-progress', 'not-done', 'on-hold', 'stopped', 'completed', 'entered-in-error', 'unknown');
  SYSTEMS_TFhirEventStatusEnum : Array[TFhirEventStatusEnum] of String = ('', 'http://hl7.org/fhir/event-status', 'http://hl7.org/fhir/event-status', 'http://hl7.org/fhir/event-status', 'http://hl7.org/fhir/event-status', 'http://hl7.org/fhir/event-status', 'http://hl7.org/fhir/event-status', 'http://hl7.org/fhir/event-status', 'http://hl7.org/fhir/event-status');
  CODES_TFhirCompartmentTypeEnum : Array[TFhirCompartmentTypeEnum] of String = ('', 'Patient', 'Encounter', 'RelatedPerson', 'Practitioner', 'Device');
  SYSTEMS_TFhirCompartmentTypeEnum : Array[TFhirCompartmentTypeEnum] of String = ('', 'http://hl7.org/fhir/compartment-type', 'http://hl7.org/fhir/compartment-type', 'http://hl7.org/fhir/compartment-type', 'http://hl7.org/fhir/compartment-type', 'http://hl7.org/fhir/compartment-type');
  CODES_TFhirCompositionStatusEnum : Array[TFhirCompositionStatusEnum] of String = ('', 'preliminary', 'final', 'amended', 'entered-in-error');
  SYSTEMS_TFhirCompositionStatusEnum : Array[TFhirCompositionStatusEnum] of String = ('', 'http://hl7.org/fhir/composition-status', 'http://hl7.org/fhir/composition-status', 'http://hl7.org/fhir/composition-status', 'http://hl7.org/fhir/composition-status');
  CODES_TFhirV3ConfidentialityClassificationEnum : Array[TFhirV3ConfidentialityClassificationEnum] of String = ('', 'U', 'L', 'M', 'N', 'R', 'V');
  SYSTEMS_TFhirV3ConfidentialityClassificationEnum : Array[TFhirV3ConfidentialityClassificationEnum] of String = ('', 'http://terminology.hl7.org/CodeSystem/v3-Confidentiality', 'http://terminology.hl7.org/CodeSystem/v3-Confidentiality', 'http://terminology.hl7.org/CodeSystem/v3-Confidentiality', 'http://terminology.hl7.org/CodeSystem/v3-Confidentiality', 'http://terminology.hl7.org/CodeSystem/v3-Confidentiality', 'http://terminology.hl7.org/CodeSystem/v3-Confidentiality');
  CODES_TFhirCompositionAttestationModeEnum : Array[TFhirCompositionAttestationModeEnum] of String = ('', 'personal', 'professional', 'legal', 'official');
  SYSTEMS_TFhirCompositionAttestationModeEnum : Array[TFhirCompositionAttestationModeEnum] of String = ('', 'http://hl7.org/fhir/composition-attestation-mode', 'http://hl7.org/fhir/composition-attestation-mode', 'http://hl7.org/fhir/composition-attestation-mode', 'http://hl7.org/fhir/composition-attestation-mode');
  CODES_TFhirDocumentRelationshipTypeEnum : Array[TFhirDocumentRelationshipTypeEnum] of String = ('', 'replaces', 'transforms', 'signs', 'appends');
  SYSTEMS_TFhirDocumentRelationshipTypeEnum : Array[TFhirDocumentRelationshipTypeEnum] of String = ('', 'http://hl7.org/fhir/document-relationship-type', 'http://hl7.org/fhir/document-relationship-type', 'http://hl7.org/fhir/document-relationship-type', 'http://hl7.org/fhir/document-relationship-type');
  CODES_TFhirListModeEnum : Array[TFhirListModeEnum] of String = ('', 'working', 'snapshot', 'changes');
  SYSTEMS_TFhirListModeEnum : Array[TFhirListModeEnum] of String = ('', 'http://hl7.org/fhir/list-mode', 'http://hl7.org/fhir/list-mode', 'http://hl7.org/fhir/list-mode');
  CODES_TFhirConceptMapEquivalenceEnum : Array[TFhirConceptMapEquivalenceEnum] of String = ('', 'relatedto', 'equivalent', 'equal', 'wider', 'subsumes', 'narrower', 'specializes', 'inexact', 'unmatched', 'disjoint');
  SYSTEMS_TFhirConceptMapEquivalenceEnum : Array[TFhirConceptMapEquivalenceEnum] of String = ('', 'http://hl7.org/fhir/concept-map-equivalence', 'http://hl7.org/fhir/concept-map-equivalence', 'http://hl7.org/fhir/concept-map-equivalence', 'http://hl7.org/fhir/concept-map-equivalence', 'http://hl7.org/fhir/concept-map-equivalence', 'http://hl7.org/fhir/concept-map-equivalence', 'http://hl7.org/fhir/concept-map-equivalence', 'http://hl7.org/fhir/concept-map-equivalence', 'http://hl7.org/fhir/concept-map-equivalence', 'http://hl7.org/fhir/concept-map-equivalence');
  CODES_TFhirConceptmapUnmappedModeEnum : Array[TFhirConceptmapUnmappedModeEnum] of String = ('', 'provided', 'fixed', 'other-map');
  SYSTEMS_TFhirConceptmapUnmappedModeEnum : Array[TFhirConceptmapUnmappedModeEnum] of String = ('', 'http://hl7.org/fhir/conceptmap-unmapped-mode', 'http://hl7.org/fhir/conceptmap-unmapped-mode', 'http://hl7.org/fhir/conceptmap-unmapped-mode');
  CODES_TFhirConsentStateCodesEnum : Array[TFhirConsentStateCodesEnum] of String = ('', 'draft', 'proposed', 'active', 'rejected', 'inactive', 'entered-in-error');
  SYSTEMS_TFhirConsentStateCodesEnum : Array[TFhirConsentStateCodesEnum] of String = ('', 'http://hl7.org/fhir/consent-state-codes', 'http://hl7.org/fhir/consent-state-codes', 'http://hl7.org/fhir/consent-state-codes', 'http://hl7.org/fhir/consent-state-codes', 'http://hl7.org/fhir/consent-state-codes', 'http://hl7.org/fhir/consent-state-codes');
  CODES_TFhirConsentProvisionTypeEnum : Array[TFhirConsentProvisionTypeEnum] of String = ('', 'deny', 'permit');
  SYSTEMS_TFhirConsentProvisionTypeEnum : Array[TFhirConsentProvisionTypeEnum] of String = ('', 'http://hl7.org/fhir/consent-provision-type', 'http://hl7.org/fhir/consent-provision-type');
  CODES_TFhirConsentDataMeaningEnum : Array[TFhirConsentDataMeaningEnum] of String = ('', 'instance', 'related', 'dependents', 'authoredby');
  SYSTEMS_TFhirConsentDataMeaningEnum : Array[TFhirConsentDataMeaningEnum] of String = ('', 'http://hl7.org/fhir/consent-data-meaning', 'http://hl7.org/fhir/consent-data-meaning', 'http://hl7.org/fhir/consent-data-meaning', 'http://hl7.org/fhir/consent-data-meaning');
  CODES_TFhirContractStatusEnum : Array[TFhirContractStatusEnum] of String = ('', 'amended', 'appended', 'cancelled', 'disputed', 'entered-in-error', 'executable', 'executed', 'negotiable', 'offered', 'policy', 'rejected', 'renewed', 'revoked', 'resolved', 'terminated');
  SYSTEMS_TFhirContractStatusEnum : Array[TFhirContractStatusEnum] of String = ('', 'http://hl7.org/fhir/contract-status', 'http://hl7.org/fhir/contract-status', 'http://hl7.org/fhir/contract-status', 'http://hl7.org/fhir/contract-status', 'http://hl7.org/fhir/contract-status', 'http://hl7.org/fhir/contract-status', 'http://hl7.org/fhir/contract-status', 'http://hl7.org/fhir/contract-status', 'http://hl7.org/fhir/contract-status', 'http://hl7.org/fhir/contract-status', 'http://hl7.org/fhir/contract-status', 'http://hl7.org/fhir/contract-status', 'http://hl7.org/fhir/contract-status', 'http://hl7.org/fhir/contract-status', 'http://hl7.org/fhir/contract-status');
  CODES_TFhirContractPublicationstatusEnum : Array[TFhirContractPublicationstatusEnum] of String = ('', 'amended', 'appended', 'cancelled', 'disputed', 'entered-in-error', 'executable', 'executed', 'negotiable', 'offered', 'policy', 'rejected', 'renewed', 'revoked', 'resolved', 'terminated');
  SYSTEMS_TFhirContractPublicationstatusEnum : Array[TFhirContractPublicationstatusEnum] of String = ('', 'http://hl7.org/fhir/contract-publicationstatus', 'http://hl7.org/fhir/contract-publicationstatus', 'http://hl7.org/fhir/contract-publicationstatus', 'http://hl7.org/fhir/contract-publicationstatus', 'http://hl7.org/fhir/contract-publicationstatus', 'http://hl7.org/fhir/contract-publicationstatus', 'http://hl7.org/fhir/contract-publicationstatus', 'http://hl7.org/fhir/contract-publicationstatus', 'http://hl7.org/fhir/contract-publicationstatus', 'http://hl7.org/fhir/contract-publicationstatus', 'http://hl7.org/fhir/contract-publicationstatus', 'http://hl7.org/fhir/contract-publicationstatus', 'http://hl7.org/fhir/contract-publicationstatus', 'http://hl7.org/fhir/contract-publicationstatus', 'http://hl7.org/fhir/contract-publicationstatus');
  CODES_TFhirEligibilityrequestPurposeEnum : Array[TFhirEligibilityrequestPurposeEnum] of String = ('', 'auth-requirements', 'benefits', 'discovery', 'validation');
  SYSTEMS_TFhirEligibilityrequestPurposeEnum : Array[TFhirEligibilityrequestPurposeEnum] of String = ('', 'http://hl7.org/fhir/eligibilityrequest-purpose', 'http://hl7.org/fhir/eligibilityrequest-purpose', 'http://hl7.org/fhir/eligibilityrequest-purpose', 'http://hl7.org/fhir/eligibilityrequest-purpose');
  CODES_TFhirEligibilityresponsePurposeEnum : Array[TFhirEligibilityresponsePurposeEnum] of String = ('', 'auth-requirements', 'benefits', 'discovery', 'validation');
  SYSTEMS_TFhirEligibilityresponsePurposeEnum : Array[TFhirEligibilityresponsePurposeEnum] of String = ('', 'http://hl7.org/fhir/eligibilityresponse-purpose', 'http://hl7.org/fhir/eligibilityresponse-purpose', 'http://hl7.org/fhir/eligibilityresponse-purpose', 'http://hl7.org/fhir/eligibilityresponse-purpose');
  CODES_TFhirObservationStatusEnum : Array[TFhirObservationStatusEnum] of String = ('', 'registered', 'preliminary', 'final', 'amended', 'corrected', 'cancelled', 'entered-in-error', 'unknown');
  SYSTEMS_TFhirObservationStatusEnum : Array[TFhirObservationStatusEnum] of String = ('', 'http://hl7.org/fhir/observation-status', 'http://hl7.org/fhir/observation-status', 'http://hl7.org/fhir/observation-status', 'http://hl7.org/fhir/observation-status', 'http://hl7.org/fhir/observation-status', 'http://hl7.org/fhir/observation-status', 'http://hl7.org/fhir/observation-status', 'http://hl7.org/fhir/observation-status');
  CODES_TFhirDetectedissueSeverityEnum : Array[TFhirDetectedissueSeverityEnum] of String = ('', 'high', 'moderate', 'low');
  SYSTEMS_TFhirDetectedissueSeverityEnum : Array[TFhirDetectedissueSeverityEnum] of String = ('', 'http://hl7.org/fhir/detectedissue-severity', 'http://hl7.org/fhir/detectedissue-severity', 'http://hl7.org/fhir/detectedissue-severity');
  CODES_TFhirUdiEntryTypeEnum : Array[TFhirUdiEntryTypeEnum] of String = ('', 'barcode', 'rfid', 'manual', 'card', 'self-reported', 'unknown');
  SYSTEMS_TFhirUdiEntryTypeEnum : Array[TFhirUdiEntryTypeEnum] of String = ('', 'http://hl7.org/fhir/udi-entry-type', 'http://hl7.org/fhir/udi-entry-type', 'http://hl7.org/fhir/udi-entry-type', 'http://hl7.org/fhir/udi-entry-type', 'http://hl7.org/fhir/udi-entry-type', 'http://hl7.org/fhir/udi-entry-type');
  CODES_TFhirDeviceStatusEnum : Array[TFhirDeviceStatusEnum] of String = ('', 'active', 'inactive', 'entered-in-error', 'unknown');
  SYSTEMS_TFhirDeviceStatusEnum : Array[TFhirDeviceStatusEnum] of String = ('', 'http://hl7.org/fhir/device-status', 'http://hl7.org/fhir/device-status', 'http://hl7.org/fhir/device-status', 'http://hl7.org/fhir/device-status');
  CODES_TFhirDeviceNametypeEnum : Array[TFhirDeviceNametypeEnum] of String = ('', 'udi-label-name', 'user-friendly-name', 'patient-reported-name', 'manufacturer-name', 'model-name', 'other');
  SYSTEMS_TFhirDeviceNametypeEnum : Array[TFhirDeviceNametypeEnum] of String = ('', 'http://hl7.org/fhir/device-nametype', 'http://hl7.org/fhir/device-nametype', 'http://hl7.org/fhir/device-nametype', 'http://hl7.org/fhir/device-nametype', 'http://hl7.org/fhir/device-nametype', 'http://hl7.org/fhir/device-nametype');
  CODES_TFhirMetricOperationalStatusEnum : Array[TFhirMetricOperationalStatusEnum] of String = ('', 'on', 'off', 'standby', 'entered-in-error');
  SYSTEMS_TFhirMetricOperationalStatusEnum : Array[TFhirMetricOperationalStatusEnum] of String = ('', 'http://hl7.org/fhir/metric-operational-status', 'http://hl7.org/fhir/metric-operational-status', 'http://hl7.org/fhir/metric-operational-status', 'http://hl7.org/fhir/metric-operational-status');
  CODES_TFhirMetricColorEnum : Array[TFhirMetricColorEnum] of String = ('', 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white');
  SYSTEMS_TFhirMetricColorEnum : Array[TFhirMetricColorEnum] of String = ('', 'http://hl7.org/fhir/metric-color', 'http://hl7.org/fhir/metric-color', 'http://hl7.org/fhir/metric-color', 'http://hl7.org/fhir/metric-color', 'http://hl7.org/fhir/metric-color', 'http://hl7.org/fhir/metric-color', 'http://hl7.org/fhir/metric-color', 'http://hl7.org/fhir/metric-color');
  CODES_TFhirMetricCategoryEnum : Array[TFhirMetricCategoryEnum] of String = ('', 'measurement', 'setting', 'calculation', 'unspecified');
  SYSTEMS_TFhirMetricCategoryEnum : Array[TFhirMetricCategoryEnum] of String = ('', 'http://hl7.org/fhir/metric-category', 'http://hl7.org/fhir/metric-category', 'http://hl7.org/fhir/metric-category', 'http://hl7.org/fhir/metric-category');
  CODES_TFhirMetricCalibrationTypeEnum : Array[TFhirMetricCalibrationTypeEnum] of String = ('', 'unspecified', 'offset', 'gain', 'two-point');
  SYSTEMS_TFhirMetricCalibrationTypeEnum : Array[TFhirMetricCalibrationTypeEnum] of String = ('', 'http://hl7.org/fhir/metric-calibration-type', 'http://hl7.org/fhir/metric-calibration-type', 'http://hl7.org/fhir/metric-calibration-type', 'http://hl7.org/fhir/metric-calibration-type');
  CODES_TFhirMetricCalibrationStateEnum : Array[TFhirMetricCalibrationStateEnum] of String = ('', 'not-calibrated', 'calibration-required', 'calibrated', 'unspecified');
  SYSTEMS_TFhirMetricCalibrationStateEnum : Array[TFhirMetricCalibrationStateEnum] of String = ('', 'http://hl7.org/fhir/metric-calibration-state', 'http://hl7.org/fhir/metric-calibration-state', 'http://hl7.org/fhir/metric-calibration-state', 'http://hl7.org/fhir/metric-calibration-state');
  CODES_TFhirDeviceStatementStatusEnum : Array[TFhirDeviceStatementStatusEnum] of String = ('', 'active', 'completed', 'entered-in-error', 'intended', 'stopped', 'on-hold');
  SYSTEMS_TFhirDeviceStatementStatusEnum : Array[TFhirDeviceStatementStatusEnum] of String = ('', 'http://hl7.org/fhir/device-statement-status', 'http://hl7.org/fhir/device-statement-status', 'http://hl7.org/fhir/device-statement-status', 'http://hl7.org/fhir/device-statement-status', 'http://hl7.org/fhir/device-statement-status', 'http://hl7.org/fhir/device-statement-status');
  CODES_TFhirDiagnosticReportStatusEnum : Array[TFhirDiagnosticReportStatusEnum] of String = ('', 'registered', 'partial', 'preliminary', 'final', 'amended', 'corrected', 'appended', 'cancelled', 'entered-in-error', 'unknown');
  SYSTEMS_TFhirDiagnosticReportStatusEnum : Array[TFhirDiagnosticReportStatusEnum] of String = ('', 'http://hl7.org/fhir/diagnostic-report-status', 'http://hl7.org/fhir/diagnostic-report-status', 'http://hl7.org/fhir/diagnostic-report-status', 'http://hl7.org/fhir/diagnostic-report-status', 'http://hl7.org/fhir/diagnostic-report-status', 'http://hl7.org/fhir/diagnostic-report-status', 'http://hl7.org/fhir/diagnostic-report-status', 'http://hl7.org/fhir/diagnostic-report-status', 'http://hl7.org/fhir/diagnostic-report-status', 'http://hl7.org/fhir/diagnostic-report-status');
  CODES_TFhirDocumentReferenceStatusEnum : Array[TFhirDocumentReferenceStatusEnum] of String = ('', 'current', 'superseded', 'entered-in-error');
  SYSTEMS_TFhirDocumentReferenceStatusEnum : Array[TFhirDocumentReferenceStatusEnum] of String = ('', 'http://hl7.org/fhir/document-reference-status', 'http://hl7.org/fhir/document-reference-status', 'http://hl7.org/fhir/document-reference-status');
  CODES_TFhirExposureStateEnum : Array[TFhirExposureStateEnum] of String = ('', 'exposure', 'exposure-alternative');
  SYSTEMS_TFhirExposureStateEnum : Array[TFhirExposureStateEnum] of String = ('', 'http://hl7.org/fhir/exposure-state', 'http://hl7.org/fhir/exposure-state');
  CODES_TFhirEncounterStatusEnum : Array[TFhirEncounterStatusEnum] of String = ('', 'planned', 'arrived', 'triaged', 'in-progress', 'onleave', 'finished', 'cancelled', 'entered-in-error', 'unknown');
  SYSTEMS_TFhirEncounterStatusEnum : Array[TFhirEncounterStatusEnum] of String = ('', 'http://hl7.org/fhir/encounter-status', 'http://hl7.org/fhir/encounter-status', 'http://hl7.org/fhir/encounter-status', 'http://hl7.org/fhir/encounter-status', 'http://hl7.org/fhir/encounter-status', 'http://hl7.org/fhir/encounter-status', 'http://hl7.org/fhir/encounter-status', 'http://hl7.org/fhir/encounter-status', 'http://hl7.org/fhir/encounter-status');
  CODES_TFhirEncounterLocationStatusEnum : Array[TFhirEncounterLocationStatusEnum] of String = ('', 'planned', 'active', 'reserved', 'completed');
  SYSTEMS_TFhirEncounterLocationStatusEnum : Array[TFhirEncounterLocationStatusEnum] of String = ('', 'http://hl7.org/fhir/encounter-location-status', 'http://hl7.org/fhir/encounter-location-status', 'http://hl7.org/fhir/encounter-location-status', 'http://hl7.org/fhir/encounter-location-status');
  CODES_TFhirEndpointStatusEnum : Array[TFhirEndpointStatusEnum] of String = ('', 'active', 'suspended', 'error', 'off', 'entered-in-error', 'test');
  SYSTEMS_TFhirEndpointStatusEnum : Array[TFhirEndpointStatusEnum] of String = ('', 'http://hl7.org/fhir/endpoint-status', 'http://hl7.org/fhir/endpoint-status', 'http://hl7.org/fhir/endpoint-status', 'http://hl7.org/fhir/endpoint-status', 'http://hl7.org/fhir/endpoint-status', 'http://hl7.org/fhir/endpoint-status');
  CODES_TFhirEpisodeOfCareStatusEnum : Array[TFhirEpisodeOfCareStatusEnum] of String = ('', 'planned', 'waitlist', 'active', 'onhold', 'finished', 'cancelled', 'entered-in-error');
  SYSTEMS_TFhirEpisodeOfCareStatusEnum : Array[TFhirEpisodeOfCareStatusEnum] of String = ('', 'http://hl7.org/fhir/episode-of-care-status', 'http://hl7.org/fhir/episode-of-care-status', 'http://hl7.org/fhir/episode-of-care-status', 'http://hl7.org/fhir/episode-of-care-status', 'http://hl7.org/fhir/episode-of-care-status', 'http://hl7.org/fhir/episode-of-care-status', 'http://hl7.org/fhir/episode-of-care-status');
  CODES_TFhirVariableTypeEnum : Array[TFhirVariableTypeEnum] of String = ('', 'dichotomous', 'continuous', 'descriptive');
  SYSTEMS_TFhirVariableTypeEnum : Array[TFhirVariableTypeEnum] of String = ('', 'http://hl7.org/fhir/variable-type', 'http://hl7.org/fhir/variable-type', 'http://hl7.org/fhir/variable-type');
  CODES_TFhirGroupMeasureEnum : Array[TFhirGroupMeasureEnum] of String = ('', 'mean', 'median', 'mean-of-mean', 'mean-of-median', 'median-of-mean', 'median-of-median');
  SYSTEMS_TFhirGroupMeasureEnum : Array[TFhirGroupMeasureEnum] of String = ('', 'http://hl7.org/fhir/group-measure', 'http://hl7.org/fhir/group-measure', 'http://hl7.org/fhir/group-measure', 'http://hl7.org/fhir/group-measure', 'http://hl7.org/fhir/group-measure', 'http://hl7.org/fhir/group-measure');
  CODES_TFhirExamplescenarioActorTypeEnum : Array[TFhirExamplescenarioActorTypeEnum] of String = ('', 'person', 'entity');
  SYSTEMS_TFhirExamplescenarioActorTypeEnum : Array[TFhirExamplescenarioActorTypeEnum] of String = ('', 'http://hl7.org/fhir/examplescenario-actor-type', 'http://hl7.org/fhir/examplescenario-actor-type');
  CODES_TFhirExplanationofbenefitStatusEnum : Array[TFhirExplanationofbenefitStatusEnum] of String = ('', 'active', 'cancelled', 'draft', 'entered-in-error');
  SYSTEMS_TFhirExplanationofbenefitStatusEnum : Array[TFhirExplanationofbenefitStatusEnum] of String = ('', 'http://hl7.org/fhir/explanationofbenefit-status', 'http://hl7.org/fhir/explanationofbenefit-status', 'http://hl7.org/fhir/explanationofbenefit-status', 'http://hl7.org/fhir/explanationofbenefit-status');
  CODES_TFhirHistoryStatusEnum : Array[TFhirHistoryStatusEnum] of String = ('', 'partial', 'completed', 'entered-in-error', 'health-unknown');
  SYSTEMS_TFhirHistoryStatusEnum : Array[TFhirHistoryStatusEnum] of String = ('', 'http://hl7.org/fhir/history-status', 'http://hl7.org/fhir/history-status', 'http://hl7.org/fhir/history-status', 'http://hl7.org/fhir/history-status');
  CODES_TFhirFlagStatusEnum : Array[TFhirFlagStatusEnum] of String = ('', 'active', 'inactive', 'entered-in-error');
  SYSTEMS_TFhirFlagStatusEnum : Array[TFhirFlagStatusEnum] of String = ('', 'http://hl7.org/fhir/flag-status', 'http://hl7.org/fhir/flag-status', 'http://hl7.org/fhir/flag-status');
  CODES_TFhirGoalStatusEnum : Array[TFhirGoalStatusEnum] of String = ('', 'proposed', 'planned', 'accepted', 'active', 'on-hold', 'completed', 'cancelled', 'entered-in-error', 'rejected');
  SYSTEMS_TFhirGoalStatusEnum : Array[TFhirGoalStatusEnum] of String = ('', 'http://hl7.org/fhir/goal-status', 'http://hl7.org/fhir/goal-status', 'http://hl7.org/fhir/goal-status', 'http://hl7.org/fhir/goal-status', 'http://hl7.org/fhir/goal-status', 'http://hl7.org/fhir/goal-status', 'http://hl7.org/fhir/goal-status', 'http://hl7.org/fhir/goal-status', 'http://hl7.org/fhir/goal-status');
  CODES_TFhirGraphCompartmentUseEnum : Array[TFhirGraphCompartmentUseEnum] of String = ('', 'condition', 'requirement');
  SYSTEMS_TFhirGraphCompartmentUseEnum : Array[TFhirGraphCompartmentUseEnum] of String = ('', 'http://hl7.org/fhir/graph-compartment-use', 'http://hl7.org/fhir/graph-compartment-use');
  CODES_TFhirGraphCompartmentRuleEnum : Array[TFhirGraphCompartmentRuleEnum] of String = ('', 'identical', 'matching', 'different', 'custom');
  SYSTEMS_TFhirGraphCompartmentRuleEnum : Array[TFhirGraphCompartmentRuleEnum] of String = ('', 'http://hl7.org/fhir/graph-compartment-rule', 'http://hl7.org/fhir/graph-compartment-rule', 'http://hl7.org/fhir/graph-compartment-rule', 'http://hl7.org/fhir/graph-compartment-rule');
  CODES_TFhirGroupTypeEnum : Array[TFhirGroupTypeEnum] of String = ('', 'person', 'animal', 'practitioner', 'device', 'medication', 'substance');
  SYSTEMS_TFhirGroupTypeEnum : Array[TFhirGroupTypeEnum] of String = ('', 'http://hl7.org/fhir/group-type', 'http://hl7.org/fhir/group-type', 'http://hl7.org/fhir/group-type', 'http://hl7.org/fhir/group-type', 'http://hl7.org/fhir/group-type', 'http://hl7.org/fhir/group-type');
  CODES_TFhirGuidanceResponseStatusEnum : Array[TFhirGuidanceResponseStatusEnum] of String = ('', 'success', 'data-requested', 'data-required', 'in-progress', 'failure', 'entered-in-error');
  SYSTEMS_TFhirGuidanceResponseStatusEnum : Array[TFhirGuidanceResponseStatusEnum] of String = ('', 'http://hl7.org/fhir/guidance-response-status', 'http://hl7.org/fhir/guidance-response-status', 'http://hl7.org/fhir/guidance-response-status', 'http://hl7.org/fhir/guidance-response-status', 'http://hl7.org/fhir/guidance-response-status', 'http://hl7.org/fhir/guidance-response-status');
  CODES_TFhirImagingstudyStatusEnum : Array[TFhirImagingstudyStatusEnum] of String = ('', 'registered', 'available', 'cancelled', 'entered-in-error', 'unknown');
  SYSTEMS_TFhirImagingstudyStatusEnum : Array[TFhirImagingstudyStatusEnum] of String = ('', 'http://hl7.org/fhir/imagingstudy-status', 'http://hl7.org/fhir/imagingstudy-status', 'http://hl7.org/fhir/imagingstudy-status', 'http://hl7.org/fhir/imagingstudy-status', 'http://hl7.org/fhir/imagingstudy-status');
  CODES_TFhirImmunizationStatusEnum : Array[TFhirImmunizationStatusEnum] of String = ('', 'completed', 'entered-in-error', 'not-done');
  SYSTEMS_TFhirImmunizationStatusEnum : Array[TFhirImmunizationStatusEnum] of String = ('', 'http://hl7.org/fhir/event-status', 'http://hl7.org/fhir/event-status', 'http://hl7.org/fhir/event-status');
  CODES_TFhirImmunizationEvaluationStatusEnum : Array[TFhirImmunizationEvaluationStatusEnum] of String = ('', 'completed', 'entered-in-error');
  SYSTEMS_TFhirImmunizationEvaluationStatusEnum : Array[TFhirImmunizationEvaluationStatusEnum] of String = ('', 'http://terminology.hl7.org/CodeSystem/medication-admin-status', 'http://terminology.hl7.org/CodeSystem/medication-admin-status');
  CODES_TFhirSpdxLicenseEnum : Array[TFhirSpdxLicenseEnum] of String = ('', 'not-open-source', '0BSD', 'AAL', 'Abstyles', 'Adobe-2006', 'Adobe-Glyph', 'ADSL', 'AFL-1.1', 'AFL-1.2', 'AFL-2.0', 'AFL-2.1', 'AFL-3.0', 'Afmparse', 'AGPL-1.0-only', 'AGPL-1.0-or-later', 'AGPL-3.0-only', 'AGPL-3.0-or-later', 'Aladdin', 'AMDPLPA', 'AML', 'AMPAS', 'ANTLR-PD', 'Apache-1.0', 'Apache-1.1', 'Apache-2.0', 'APAFML', 'APL-1.0', 'APSL-1.0', 'APSL-1.1', 'APSL-1.2', 'APSL-2.0', 'Artistic-1.0-cl8', 'Artistic-1.0-Perl', 'Artistic-1.0', 'Artistic-2.0', 'Bahyph', 'Barr', 'Beerware', 'BitTorrent-1.0', 'BitTorrent-1.1', 'Borceux', 'BSD-1-Clause', 'BSD-2-Clause-FreeBSD', 'BSD-2-Clause-NetBSD', 'BSD-2-Clause-Patent', 'BSD-2-Clause', 'BSD-3-Clause-Attribution', 'BSD-3-Clause-Clear', 'BSD-3-Clause-LBNL', 'BSD-3-Clause-No-Nuclear-License-2014', 'BSD-3-Clause-No-Nuclear-License', 'BSD-3-Clause-No-Nuclear-Warranty', 'BSD-3-Clause', 'BSD-4-Clause-UC', 'BSD-4-Clause', 'BSD-Protection', 'BSD-Source-Code', 'BSL-1.0', 'bzip2-1.0.5', 
    'bzip2-1.0.6', 'Caldera', 'CATOSL-1.1', 'CC-BY-1.0', 'CC-BY-2.0', 'CC-BY-2.5', 'CC-BY-3.0', 'CC-BY-4.0', 'CC-BY-NC-1.0', 'CC-BY-NC-2.0', 'CC-BY-NC-2.5', 'CC-BY-NC-3.0', 'CC-BY-NC-4.0', 'CC-BY-NC-ND-1.0', 'CC-BY-NC-ND-2.0', 'CC-BY-NC-ND-2.5', 'CC-BY-NC-ND-3.0', 'CC-BY-NC-ND-4.0', 'CC-BY-NC-SA-1.0', 'CC-BY-NC-SA-2.0', 'CC-BY-NC-SA-2.5', 'CC-BY-NC-SA-3.0', 'CC-BY-NC-SA-4.0', 'CC-BY-ND-1.0', 'CC-BY-ND-2.0', 'CC-BY-ND-2.5', 'CC-BY-ND-3.0', 'CC-BY-ND-4.0', 'CC-BY-SA-1.0', 'CC-BY-SA-2.0', 'CC-BY-SA-2.5', 'CC-BY-SA-3.0', 'CC-BY-SA-4.0', 'CC0-1.0', 'CDDL-1.0', 'CDDL-1.1', 'CDLA-Permissive-1.0', 'CDLA-Sharing-1.0', 'CECILL-1.0', 'CECILL-1.1', 'CECILL-2.0', 'CECILL-2.1', 'CECILL-B', 'CECILL-C', 'ClArtistic', 'CNRI-Jython', 'CNRI-Python-GPL-Compatible', 'CNRI-Python', 'Condor-1.1', 'CPAL-1.0', 'CPL-1.0', 'CPOL-1.02', 'Crossword', 'CrystalStacker', 'CUA-OPL-1.0', 'Cube', 'curl', 'D-FSL-1.0', 'diffmark', 'DOC', 'Dotseqn', 'DSDP', 'dvipdfm', 'ECL-1.0', 'ECL-2.0', 'EFL-1.0', 'EFL-2.0', 'eGenix', 'Entessa', 
    'EPL-1.0', 'EPL-2.0', 'ErlPL-1.1', 'EUDatagrid', 'EUPL-1.0', 'EUPL-1.1', 'EUPL-1.2', 'Eurosym', 'Fair', 'Frameworx-1.0', 'FreeImage', 'FSFAP', 'FSFUL', 'FSFULLR', 'FTL', 'GFDL-1.1-only', 'GFDL-1.1-or-later', 'GFDL-1.2-only', 'GFDL-1.2-or-later', 'GFDL-1.3-only', 'GFDL-1.3-or-later', 'Giftware', 'GL2PS', 'Glide', 'Glulxe', 'gnuplot', 'GPL-1.0-only', 'GPL-1.0-or-later', 'GPL-2.0-only', 'GPL-2.0-or-later', 'GPL-3.0-only', 'GPL-3.0-or-later', 'gSOAP-1.3b', 'HaskellReport', 'HPND', 'IBM-pibs', 'ICU', 'IJG', 'ImageMagick', 'iMatix', 'Imlib2', 'Info-ZIP', 'Intel-ACPI', 'Intel', 'Interbase-1.0', 'IPA', 'IPL-1.0', 'ISC', 'JasPer-2.0', 'JSON', 'LAL-1.2', 'LAL-1.3', 'Latex2e', 'Leptonica', 'LGPL-2.0-only', 'LGPL-2.0-or-later', 'LGPL-2.1-only', 'LGPL-2.1-or-later', 'LGPL-3.0-only', 'LGPL-3.0-or-later', 'LGPLLR', 'Libpng', 'libtiff', 'LiLiQ-P-1.1', 'LiLiQ-R-1.1', 'LiLiQ-Rplus-1.1', 'Linux-OpenIB', 'LPL-1.0', 'LPL-1.02', 'LPPL-1.0', 'LPPL-1.1', 'LPPL-1.2', 'LPPL-1.3a', 'LPPL-1.3c', 'MakeIndex', 'MirOS', 'MIT-0', 
    'MIT-advertising', 'MIT-CMU', 'MIT-enna', 'MIT-feh', 'MIT', 'MITNFA', 'Motosoto', 'mpich2', 'MPL-1.0', 'MPL-1.1', 'MPL-2.0-no-copyleft-exception', 'MPL-2.0', 'MS-PL', 'MS-RL', 'MTLL', 'Multics', 'Mup', 'NASA-1.3', 'Naumen', 'NBPL-1.0', 'NCSA', 'Net-SNMP', 'NetCDF', 'Newsletr', 'NGPL', 'NLOD-1.0', 'NLPL', 'Nokia', 'NOSL', 'Noweb', 'NPL-1.0', 'NPL-1.1', 'NPOSL-3.0', 'NRL', 'NTP', 'OCCT-PL', 'OCLC-2.0', 'ODbL-1.0', 'OFL-1.0', 'OFL-1.1', 'OGTSL', 'OLDAP-1.1', 'OLDAP-1.2', 'OLDAP-1.3', 'OLDAP-1.4', 'OLDAP-2.0.1', 'OLDAP-2.0', 'OLDAP-2.1', 'OLDAP-2.2.1');
  SYSTEMS_TFhirSpdxLicenseEnum : Array[TFhirSpdxLicenseEnum] of String = ('', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 
    'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 
    'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 
    'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 
    'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 
    'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 
    'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 
    'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 
    'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 
    'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license', 'http://hl7.org/fhir/spdx-license');
  CODES_TFhirGuidePageGenerationEnum : Array[TFhirGuidePageGenerationEnum] of String = ('', 'html', 'markdown', 'xml', 'generated');
  SYSTEMS_TFhirGuidePageGenerationEnum : Array[TFhirGuidePageGenerationEnum] of String = ('', 'http://hl7.org/fhir/guide-page-generation', 'http://hl7.org/fhir/guide-page-generation', 'http://hl7.org/fhir/guide-page-generation', 'http://hl7.org/fhir/guide-page-generation');
  CODES_TFhirGuideParameterCodeEnum : Array[TFhirGuideParameterCodeEnum] of String = ('', 'apply', 'path-resource', 'path-pages', 'path-tx-cache', 'expansion-parameter', 'rule-broken-links', 'generate-xml', 'generate-json', 'generate-turtle', 'html-template');
  SYSTEMS_TFhirGuideParameterCodeEnum : Array[TFhirGuideParameterCodeEnum] of String = ('', 'http://hl7.org/fhir/guide-parameter-code', 'http://hl7.org/fhir/guide-parameter-code', 'http://hl7.org/fhir/guide-parameter-code', 'http://hl7.org/fhir/guide-parameter-code', 'http://hl7.org/fhir/guide-parameter-code', 'http://hl7.org/fhir/guide-parameter-code', 'http://hl7.org/fhir/guide-parameter-code', 'http://hl7.org/fhir/guide-parameter-code', 'http://hl7.org/fhir/guide-parameter-code', 'http://hl7.org/fhir/guide-parameter-code');
  CODES_TFhirInvoiceStatusEnum : Array[TFhirInvoiceStatusEnum] of String = ('', 'draft', 'issued', 'balanced', 'cancelled', 'entered-in-error');
  SYSTEMS_TFhirInvoiceStatusEnum : Array[TFhirInvoiceStatusEnum] of String = ('', 'http://hl7.org/fhir/invoice-status', 'http://hl7.org/fhir/invoice-status', 'http://hl7.org/fhir/invoice-status', 'http://hl7.org/fhir/invoice-status', 'http://hl7.org/fhir/invoice-status');
  CODES_TFhirLinkageTypeEnum : Array[TFhirLinkageTypeEnum] of String = ('', 'source', 'alternate', 'historical');
  SYSTEMS_TFhirLinkageTypeEnum : Array[TFhirLinkageTypeEnum] of String = ('', 'http://hl7.org/fhir/linkage-type', 'http://hl7.org/fhir/linkage-type', 'http://hl7.org/fhir/linkage-type');
  CODES_TFhirListStatusEnum : Array[TFhirListStatusEnum] of String = ('', 'current', 'retired', 'entered-in-error');
  SYSTEMS_TFhirListStatusEnum : Array[TFhirListStatusEnum] of String = ('', 'http://hl7.org/fhir/list-status', 'http://hl7.org/fhir/list-status', 'http://hl7.org/fhir/list-status');
  CODES_TFhirLocationStatusEnum : Array[TFhirLocationStatusEnum] of String = ('', 'active', 'suspended', 'inactive');
  SYSTEMS_TFhirLocationStatusEnum : Array[TFhirLocationStatusEnum] of String = ('', 'http://hl7.org/fhir/location-status', 'http://hl7.org/fhir/location-status', 'http://hl7.org/fhir/location-status');
  CODES_TFhirLocationModeEnum : Array[TFhirLocationModeEnum] of String = ('', 'instance', 'kind');
  SYSTEMS_TFhirLocationModeEnum : Array[TFhirLocationModeEnum] of String = ('', 'http://hl7.org/fhir/location-mode', 'http://hl7.org/fhir/location-mode');
  CODES_TFhirMeasureReportStatusEnum : Array[TFhirMeasureReportStatusEnum] of String = ('', 'complete', 'pending', 'error');
  SYSTEMS_TFhirMeasureReportStatusEnum : Array[TFhirMeasureReportStatusEnum] of String = ('', 'http://hl7.org/fhir/measure-report-status', 'http://hl7.org/fhir/measure-report-status', 'http://hl7.org/fhir/measure-report-status');
  CODES_TFhirMeasureReportTypeEnum : Array[TFhirMeasureReportTypeEnum] of String = ('', 'individual', 'subject-list', 'summary', 'data-collection');
  SYSTEMS_TFhirMeasureReportTypeEnum : Array[TFhirMeasureReportTypeEnum] of String = ('', 'http://hl7.org/fhir/measure-report-type', 'http://hl7.org/fhir/measure-report-type', 'http://hl7.org/fhir/measure-report-type', 'http://hl7.org/fhir/measure-report-type');
  CODES_TFhirMedicationStatusEnum : Array[TFhirMedicationStatusEnum] of String = ('', 'active', 'inactive', 'entered-in-error');
  SYSTEMS_TFhirMedicationStatusEnum : Array[TFhirMedicationStatusEnum] of String = ('', 'http://hl7.org/fhir/CodeSystem/medication-status', 'http://hl7.org/fhir/CodeSystem/medication-status', 'http://hl7.org/fhir/CodeSystem/medication-status');
  CODES_TFhirMedicationrequestStatusEnum : Array[TFhirMedicationrequestStatusEnum] of String = ('', 'active', 'on-hold', 'cancelled', 'completed', 'entered-in-error', 'stopped', 'draft', 'unknown');
  SYSTEMS_TFhirMedicationrequestStatusEnum : Array[TFhirMedicationrequestStatusEnum] of String = ('', 'http://hl7.org/fhir/CodeSystem/medicationrequest-status', 'http://hl7.org/fhir/CodeSystem/medicationrequest-status', 'http://hl7.org/fhir/CodeSystem/medicationrequest-status', 'http://hl7.org/fhir/CodeSystem/medicationrequest-status', 'http://hl7.org/fhir/CodeSystem/medicationrequest-status', 'http://hl7.org/fhir/CodeSystem/medicationrequest-status', 'http://hl7.org/fhir/CodeSystem/medicationrequest-status', 'http://hl7.org/fhir/CodeSystem/medicationrequest-status');
  CODES_TFhirMedicationrequestIntentEnum : Array[TFhirMedicationrequestIntentEnum] of String = ('', 'proposal', 'plan', 'order', 'original-order', 'reflex-order', 'filler-order', 'instance-order', 'option');
  SYSTEMS_TFhirMedicationrequestIntentEnum : Array[TFhirMedicationrequestIntentEnum] of String = ('', 'http://hl7.org/fhir/CodeSystem/medicationrequest-intent', 'http://hl7.org/fhir/CodeSystem/medicationrequest-intent', 'http://hl7.org/fhir/CodeSystem/medicationrequest-intent', 'http://hl7.org/fhir/CodeSystem/medicationrequest-intent', 'http://hl7.org/fhir/CodeSystem/medicationrequest-intent', 'http://hl7.org/fhir/CodeSystem/medicationrequest-intent', 'http://hl7.org/fhir/CodeSystem/medicationrequest-intent', 'http://hl7.org/fhir/CodeSystem/medicationrequest-intent');
  CODES_TFhirMedicationStatementStatusEnum : Array[TFhirMedicationStatementStatusEnum] of String = ('', 'active', 'completed', 'entered-in-error', 'intended', 'stopped', 'on-hold', 'unknown', 'not-taken');
  SYSTEMS_TFhirMedicationStatementStatusEnum : Array[TFhirMedicationStatementStatusEnum] of String = ('', 'http://hl7.org/fhir/CodeSystem/medication-statement-status', 'http://hl7.org/fhir/CodeSystem/medication-statement-status', 'http://hl7.org/fhir/CodeSystem/medication-statement-status', 'http://hl7.org/fhir/CodeSystem/medication-statement-status', 'http://hl7.org/fhir/CodeSystem/medication-statement-status', 'http://hl7.org/fhir/CodeSystem/medication-statement-status', 'http://hl7.org/fhir/CodeSystem/medication-statement-status', 'http://hl7.org/fhir/CodeSystem/medication-statement-status');
  CODES_TFhirMessageSignificanceCategoryEnum : Array[TFhirMessageSignificanceCategoryEnum] of String = ('', 'consequence', 'currency', 'notification');
  SYSTEMS_TFhirMessageSignificanceCategoryEnum : Array[TFhirMessageSignificanceCategoryEnum] of String = ('', 'http://hl7.org/fhir/message-significance-category', 'http://hl7.org/fhir/message-significance-category', 'http://hl7.org/fhir/message-significance-category');
  CODES_TFhirMessageheaderResponseRequestEnum : Array[TFhirMessageheaderResponseRequestEnum] of String = ('', 'always', 'on-error', 'never', 'on-success');
  SYSTEMS_TFhirMessageheaderResponseRequestEnum : Array[TFhirMessageheaderResponseRequestEnum] of String = ('', 'http://hl7.org/fhir/messageheader-response-request', 'http://hl7.org/fhir/messageheader-response-request', 'http://hl7.org/fhir/messageheader-response-request', 'http://hl7.org/fhir/messageheader-response-request');
  CODES_TFhirResponseCodeEnum : Array[TFhirResponseCodeEnum] of String = ('', 'ok', 'transient-error', 'fatal-error');
  SYSTEMS_TFhirResponseCodeEnum : Array[TFhirResponseCodeEnum] of String = ('', 'http://hl7.org/fhir/response-code', 'http://hl7.org/fhir/response-code', 'http://hl7.org/fhir/response-code');
  CODES_TFhirSequenceTypeEnum : Array[TFhirSequenceTypeEnum] of String = ('', 'aa', 'dna', 'rna');
  SYSTEMS_TFhirSequenceTypeEnum : Array[TFhirSequenceTypeEnum] of String = ('', 'http://hl7.org/fhir/sequence-type', 'http://hl7.org/fhir/sequence-type', 'http://hl7.org/fhir/sequence-type');
  CODES_TFhirOrientationTypeEnum : Array[TFhirOrientationTypeEnum] of String = ('', 'sense', 'antisense');
  SYSTEMS_TFhirOrientationTypeEnum : Array[TFhirOrientationTypeEnum] of String = ('', 'http://hl7.org/fhir/orientation-type', 'http://hl7.org/fhir/orientation-type');
  CODES_TFhirStrandTypeEnum : Array[TFhirStrandTypeEnum] of String = ('', 'watson', 'crick');
  SYSTEMS_TFhirStrandTypeEnum : Array[TFhirStrandTypeEnum] of String = ('', 'http://hl7.org/fhir/strand-type', 'http://hl7.org/fhir/strand-type');
  CODES_TFhirQualityTypeEnum : Array[TFhirQualityTypeEnum] of String = ('', 'indel', 'snp', 'unknown');
  SYSTEMS_TFhirQualityTypeEnum : Array[TFhirQualityTypeEnum] of String = ('', 'http://hl7.org/fhir/quality-type', 'http://hl7.org/fhir/quality-type', 'http://hl7.org/fhir/quality-type');
  CODES_TFhirRepositoryTypeEnum : Array[TFhirRepositoryTypeEnum] of String = ('', 'directlink', 'openapi', 'login', 'oauth', 'other');
  SYSTEMS_TFhirRepositoryTypeEnum : Array[TFhirRepositoryTypeEnum] of String = ('', 'http://hl7.org/fhir/repository-type', 'http://hl7.org/fhir/repository-type', 'http://hl7.org/fhir/repository-type', 'http://hl7.org/fhir/repository-type', 'http://hl7.org/fhir/repository-type');
  CODES_TFhirNamingsystemTypeEnum : Array[TFhirNamingsystemTypeEnum] of String = ('', 'codesystem', 'identifier', 'root');
  SYSTEMS_TFhirNamingsystemTypeEnum : Array[TFhirNamingsystemTypeEnum] of String = ('', 'http://hl7.org/fhir/namingsystem-type', 'http://hl7.org/fhir/namingsystem-type', 'http://hl7.org/fhir/namingsystem-type');
  CODES_TFhirNamingsystemIdentifierTypeEnum : Array[TFhirNamingsystemIdentifierTypeEnum] of String = ('', 'oid', 'uuid', 'uri', 'other');
  SYSTEMS_TFhirNamingsystemIdentifierTypeEnum : Array[TFhirNamingsystemIdentifierTypeEnum] of String = ('', 'http://hl7.org/fhir/namingsystem-identifier-type', 'http://hl7.org/fhir/namingsystem-identifier-type', 'http://hl7.org/fhir/namingsystem-identifier-type', 'http://hl7.org/fhir/namingsystem-identifier-type');
  CODES_TFhirPermittedDataTypeEnum : Array[TFhirPermittedDataTypeEnum] of String = ('', 'Quantity', 'CodeableConcept', 'string', 'boolean', 'integer', 'Range', 'Ratio', 'SampledData', 'time', 'dateTime', 'Period');
  SYSTEMS_TFhirPermittedDataTypeEnum : Array[TFhirPermittedDataTypeEnum] of String = ('', 'http://hl7.org/fhir/permitted-data-type', 'http://hl7.org/fhir/permitted-data-type', 'http://hl7.org/fhir/permitted-data-type', 'http://hl7.org/fhir/permitted-data-type', 'http://hl7.org/fhir/permitted-data-type', 'http://hl7.org/fhir/permitted-data-type', 'http://hl7.org/fhir/permitted-data-type', 'http://hl7.org/fhir/permitted-data-type', 'http://hl7.org/fhir/permitted-data-type', 'http://hl7.org/fhir/permitted-data-type', 'http://hl7.org/fhir/permitted-data-type');
  CODES_TFhirObservationRangeCategoryEnum : Array[TFhirObservationRangeCategoryEnum] of String = ('', 'reference', 'critical', 'absolute');
  SYSTEMS_TFhirObservationRangeCategoryEnum : Array[TFhirObservationRangeCategoryEnum] of String = ('', 'http://hl7.org/fhir/observation-range-category', 'http://hl7.org/fhir/observation-range-category', 'http://hl7.org/fhir/observation-range-category');
  CODES_TFhirAdministrativeGenderEnum : Array[TFhirAdministrativeGenderEnum] of String = ('', 'male', 'female', 'other', 'unknown');
  SYSTEMS_TFhirAdministrativeGenderEnum : Array[TFhirAdministrativeGenderEnum] of String = ('', 'http://hl7.org/fhir/administrative-gender', 'http://hl7.org/fhir/administrative-gender', 'http://hl7.org/fhir/administrative-gender', 'http://hl7.org/fhir/administrative-gender');
  CODES_TFhirOperationKindEnum : Array[TFhirOperationKindEnum] of String = ('', 'operation', 'query');
  SYSTEMS_TFhirOperationKindEnum : Array[TFhirOperationKindEnum] of String = ('', 'http://hl7.org/fhir/operation-kind', 'http://hl7.org/fhir/operation-kind');
  CODES_TFhirIssueSeverityEnum : Array[TFhirIssueSeverityEnum] of String = ('', 'fatal', 'error', 'warning', 'information');
  SYSTEMS_TFhirIssueSeverityEnum : Array[TFhirIssueSeverityEnum] of String = ('', 'http://hl7.org/fhir/issue-severity', 'http://hl7.org/fhir/issue-severity', 'http://hl7.org/fhir/issue-severity', 'http://hl7.org/fhir/issue-severity');
  CODES_TFhirIssueTypeEnum : Array[TFhirIssueTypeEnum] of String = ('', 'invalid', 'structure', 'required', 'value', 'invariant', 'security', 'login', 'unknown', 'expired', 'forbidden', 'suppressed', 'processing', 'not-supported', 'duplicate', 'multiple-matches', 'not-found', 'deleted', 'too-long', 'code-invalid', 'extension', 'too-costly', 'business-rule', 'conflict', 'transient', 'lock-error', 'no-store', 'exception', 'timeout', 'incomplete', 'throttled', 'informational');
  SYSTEMS_TFhirIssueTypeEnum : Array[TFhirIssueTypeEnum] of String = ('', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 
    'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type', 'http://hl7.org/fhir/issue-type');
  CODES_TFhirLinkTypeEnum : Array[TFhirLinkTypeEnum] of String = ('', 'replaced-by', 'replaces', 'refer', 'seealso');
  SYSTEMS_TFhirLinkTypeEnum : Array[TFhirLinkTypeEnum] of String = ('', 'http://hl7.org/fhir/link-type', 'http://hl7.org/fhir/link-type', 'http://hl7.org/fhir/link-type', 'http://hl7.org/fhir/link-type');
  CODES_TFhirIdentityAssuranceLevelEnum : Array[TFhirIdentityAssuranceLevelEnum] of String = ('', 'level1', 'level2', 'level3', 'level4');
  SYSTEMS_TFhirIdentityAssuranceLevelEnum : Array[TFhirIdentityAssuranceLevelEnum] of String = ('', 'http://hl7.org/fhir/identity-assuranceLevel', 'http://hl7.org/fhir/identity-assuranceLevel', 'http://hl7.org/fhir/identity-assuranceLevel', 'http://hl7.org/fhir/identity-assuranceLevel');
  CODES_TFhirActionConditionKindEnum : Array[TFhirActionConditionKindEnum] of String = ('', 'applicability', 'start', 'stop');
  SYSTEMS_TFhirActionConditionKindEnum : Array[TFhirActionConditionKindEnum] of String = ('', 'http://hl7.org/fhir/action-condition-kind', 'http://hl7.org/fhir/action-condition-kind', 'http://hl7.org/fhir/action-condition-kind');
  CODES_TFhirActionRelationshipTypeEnum : Array[TFhirActionRelationshipTypeEnum] of String = ('', 'before-start', 'before', 'before-end', 'concurrent-with-start', 'concurrent', 'concurrent-with-end', 'after-start', 'after', 'after-end');
  SYSTEMS_TFhirActionRelationshipTypeEnum : Array[TFhirActionRelationshipTypeEnum] of String = ('', 'http://hl7.org/fhir/action-relationship-type', 'http://hl7.org/fhir/action-relationship-type', 'http://hl7.org/fhir/action-relationship-type', 'http://hl7.org/fhir/action-relationship-type', 'http://hl7.org/fhir/action-relationship-type', 'http://hl7.org/fhir/action-relationship-type', 'http://hl7.org/fhir/action-relationship-type', 'http://hl7.org/fhir/action-relationship-type', 'http://hl7.org/fhir/action-relationship-type');
  CODES_TFhirActionGroupingBehaviorEnum : Array[TFhirActionGroupingBehaviorEnum] of String = ('', 'visual-group', 'logical-group', 'sentence-group');
  SYSTEMS_TFhirActionGroupingBehaviorEnum : Array[TFhirActionGroupingBehaviorEnum] of String = ('', 'http://hl7.org/fhir/action-grouping-behavior', 'http://hl7.org/fhir/action-grouping-behavior', 'http://hl7.org/fhir/action-grouping-behavior');
  CODES_TFhirActionSelectionBehaviorEnum : Array[TFhirActionSelectionBehaviorEnum] of String = ('', 'any', 'all', 'all-or-none', 'exactly-one', 'at-most-one', 'one-or-more');
  SYSTEMS_TFhirActionSelectionBehaviorEnum : Array[TFhirActionSelectionBehaviorEnum] of String = ('', 'http://hl7.org/fhir/action-selection-behavior', 'http://hl7.org/fhir/action-selection-behavior', 'http://hl7.org/fhir/action-selection-behavior', 'http://hl7.org/fhir/action-selection-behavior', 'http://hl7.org/fhir/action-selection-behavior', 'http://hl7.org/fhir/action-selection-behavior');
  CODES_TFhirActionRequiredBehaviorEnum : Array[TFhirActionRequiredBehaviorEnum] of String = ('', 'must', 'could', 'must-unless-documented');
  SYSTEMS_TFhirActionRequiredBehaviorEnum : Array[TFhirActionRequiredBehaviorEnum] of String = ('', 'http://hl7.org/fhir/action-required-behavior', 'http://hl7.org/fhir/action-required-behavior', 'http://hl7.org/fhir/action-required-behavior');
  CODES_TFhirActionPrecheckBehaviorEnum : Array[TFhirActionPrecheckBehaviorEnum] of String = ('', 'yes', 'no');
  SYSTEMS_TFhirActionPrecheckBehaviorEnum : Array[TFhirActionPrecheckBehaviorEnum] of String = ('', 'http://hl7.org/fhir/action-precheck-behavior', 'http://hl7.org/fhir/action-precheck-behavior');
  CODES_TFhirActionCardinalityBehaviorEnum : Array[TFhirActionCardinalityBehaviorEnum] of String = ('', 'single', 'multiple');
  SYSTEMS_TFhirActionCardinalityBehaviorEnum : Array[TFhirActionCardinalityBehaviorEnum] of String = ('', 'http://hl7.org/fhir/action-cardinality-behavior', 'http://hl7.org/fhir/action-cardinality-behavior');
  CODES_TFhirProvenanceEntityRoleEnum : Array[TFhirProvenanceEntityRoleEnum] of String = ('', 'derivation', 'revision', 'quotation', 'source', 'removal');
  SYSTEMS_TFhirProvenanceEntityRoleEnum : Array[TFhirProvenanceEntityRoleEnum] of String = ('', 'http://hl7.org/fhir/provenance-entity-role', 'http://hl7.org/fhir/provenance-entity-role', 'http://hl7.org/fhir/provenance-entity-role', 'http://hl7.org/fhir/provenance-entity-role', 'http://hl7.org/fhir/provenance-entity-role');
  CODES_TFhirItemTypeEnum : Array[TFhirItemTypeEnum] of String = ('', 'group', 'display', 'boolean', 'decimal', 'integer', 'date', 'dateTime', 'time', 'string', 'text', 'url', 'choice', 'open-choice', 'attachment', 'reference', 'quantity');
  SYSTEMS_TFhirItemTypeEnum : Array[TFhirItemTypeEnum] of String = ('', 'http://hl7.org/fhir/item-type', 'http://hl7.org/fhir/item-type', 'http://hl7.org/fhir/item-type', 'http://hl7.org/fhir/item-type', 'http://hl7.org/fhir/item-type', 'http://hl7.org/fhir/item-type', 'http://hl7.org/fhir/item-type', 'http://hl7.org/fhir/item-type', 'http://hl7.org/fhir/item-type', 'http://hl7.org/fhir/item-type', 'http://hl7.org/fhir/item-type', 'http://hl7.org/fhir/item-type', 'http://hl7.org/fhir/item-type', 'http://hl7.org/fhir/item-type', 'http://hl7.org/fhir/item-type', 'http://hl7.org/fhir/item-type');
  CODES_TFhirQuestionnaireEnableOperatorEnum : Array[TFhirQuestionnaireEnableOperatorEnum] of String = ('', 'exists', '=', '!=', '>', '<', '>=', '<=');
  SYSTEMS_TFhirQuestionnaireEnableOperatorEnum : Array[TFhirQuestionnaireEnableOperatorEnum] of String = ('', 'http://hl7.org/fhir/questionnaire-enable-operator', 'http://hl7.org/fhir/questionnaire-enable-operator', 'http://hl7.org/fhir/questionnaire-enable-operator', 'http://hl7.org/fhir/questionnaire-enable-operator', 'http://hl7.org/fhir/questionnaire-enable-operator', 'http://hl7.org/fhir/questionnaire-enable-operator', 'http://hl7.org/fhir/questionnaire-enable-operator');
  CODES_TFhirQuestionnaireEnableBehaviorEnum : Array[TFhirQuestionnaireEnableBehaviorEnum] of String = ('', 'all', 'any');
  SYSTEMS_TFhirQuestionnaireEnableBehaviorEnum : Array[TFhirQuestionnaireEnableBehaviorEnum] of String = ('', 'http://hl7.org/fhir/questionnaire-enable-behavior', 'http://hl7.org/fhir/questionnaire-enable-behavior');
  CODES_TFhirQuestionnaireAnswersStatusEnum : Array[TFhirQuestionnaireAnswersStatusEnum] of String = ('', 'in-progress', 'completed', 'amended', 'entered-in-error', 'stopped');
  SYSTEMS_TFhirQuestionnaireAnswersStatusEnum : Array[TFhirQuestionnaireAnswersStatusEnum] of String = ('', 'http://hl7.org/fhir/questionnaire-answers-status', 'http://hl7.org/fhir/questionnaire-answers-status', 'http://hl7.org/fhir/questionnaire-answers-status', 'http://hl7.org/fhir/questionnaire-answers-status', 'http://hl7.org/fhir/questionnaire-answers-status');
  CODES_TFhirResearchElementTypeEnum : Array[TFhirResearchElementTypeEnum] of String = ('', 'population', 'exposure', 'outcome');
  SYSTEMS_TFhirResearchElementTypeEnum : Array[TFhirResearchElementTypeEnum] of String = ('', 'http://hl7.org/fhir/research-element-type', 'http://hl7.org/fhir/research-element-type', 'http://hl7.org/fhir/research-element-type');
  CODES_TFhirResearchStudyStatusEnum : Array[TFhirResearchStudyStatusEnum] of String = ('', 'active', 'administratively-completed', 'approved', 'closed-to-accrual', 'closed-to-accrual-and-intervention', 'completed', 'disapproved', 'in-review', 'temporarily-closed-to-accrual', 'temporarily-closed-to-accrual-and-intervention', 'withdrawn');
  SYSTEMS_TFhirResearchStudyStatusEnum : Array[TFhirResearchStudyStatusEnum] of String = ('', 'http://hl7.org/fhir/research-study-status', 'http://hl7.org/fhir/research-study-status', 'http://hl7.org/fhir/research-study-status', 'http://hl7.org/fhir/research-study-status', 'http://hl7.org/fhir/research-study-status', 'http://hl7.org/fhir/research-study-status', 'http://hl7.org/fhir/research-study-status', 'http://hl7.org/fhir/research-study-status', 'http://hl7.org/fhir/research-study-status', 'http://hl7.org/fhir/research-study-status', 'http://hl7.org/fhir/research-study-status');
  CODES_TFhirResearchSubjectStatusEnum : Array[TFhirResearchSubjectStatusEnum] of String = ('', 'candidate', 'eligible', 'follow-up', 'ineligible', 'not-registered', 'off-study', 'on-study', 'on-study-intervention', 'on-study-observation', 'pending-on-study', 'potential-candidate', 'screening', 'withdrawn');
  SYSTEMS_TFhirResearchSubjectStatusEnum : Array[TFhirResearchSubjectStatusEnum] of String = ('', 'http://hl7.org/fhir/research-subject-status', 'http://hl7.org/fhir/research-subject-status', 'http://hl7.org/fhir/research-subject-status', 'http://hl7.org/fhir/research-subject-status', 'http://hl7.org/fhir/research-subject-status', 'http://hl7.org/fhir/research-subject-status', 'http://hl7.org/fhir/research-subject-status', 'http://hl7.org/fhir/research-subject-status', 'http://hl7.org/fhir/research-subject-status', 'http://hl7.org/fhir/research-subject-status', 'http://hl7.org/fhir/research-subject-status', 'http://hl7.org/fhir/research-subject-status', 'http://hl7.org/fhir/research-subject-status');
  CODES_TFhirSearchXpathUsageEnum : Array[TFhirSearchXpathUsageEnum] of String = ('', 'normal', 'phonetic', 'nearby', 'distance', 'other');
  SYSTEMS_TFhirSearchXpathUsageEnum : Array[TFhirSearchXpathUsageEnum] of String = ('', 'http://hl7.org/fhir/search-xpath-usage', 'http://hl7.org/fhir/search-xpath-usage', 'http://hl7.org/fhir/search-xpath-usage', 'http://hl7.org/fhir/search-xpath-usage', 'http://hl7.org/fhir/search-xpath-usage');
  CODES_TFhirSearchComparatorEnum : Array[TFhirSearchComparatorEnum] of String = ('', 'eq', 'ne', 'gt', 'lt', 'ge', 'le', 'sa', 'eb', 'ap');
  SYSTEMS_TFhirSearchComparatorEnum : Array[TFhirSearchComparatorEnum] of String = ('', 'http://hl7.org/fhir/search-comparator', 'http://hl7.org/fhir/search-comparator', 'http://hl7.org/fhir/search-comparator', 'http://hl7.org/fhir/search-comparator', 'http://hl7.org/fhir/search-comparator', 'http://hl7.org/fhir/search-comparator', 'http://hl7.org/fhir/search-comparator', 'http://hl7.org/fhir/search-comparator', 'http://hl7.org/fhir/search-comparator');
  CODES_TFhirSearchModifierCodeEnum : Array[TFhirSearchModifierCodeEnum] of String = ('', 'missing', 'exact', 'contains', 'not', 'text', 'in', 'not-in', 'below', 'above', 'type', 'identifier', 'ofType');
  SYSTEMS_TFhirSearchModifierCodeEnum : Array[TFhirSearchModifierCodeEnum] of String = ('', 'http://hl7.org/fhir/search-modifier-code', 'http://hl7.org/fhir/search-modifier-code', 'http://hl7.org/fhir/search-modifier-code', 'http://hl7.org/fhir/search-modifier-code', 'http://hl7.org/fhir/search-modifier-code', 'http://hl7.org/fhir/search-modifier-code', 'http://hl7.org/fhir/search-modifier-code', 'http://hl7.org/fhir/search-modifier-code', 'http://hl7.org/fhir/search-modifier-code', 'http://hl7.org/fhir/search-modifier-code', 'http://hl7.org/fhir/search-modifier-code', 'http://hl7.org/fhir/search-modifier-code');
  CODES_TFhirSlotstatusEnum : Array[TFhirSlotstatusEnum] of String = ('', 'busy', 'free', 'busy-unavailable', 'busy-tentative', 'entered-in-error');
  SYSTEMS_TFhirSlotstatusEnum : Array[TFhirSlotstatusEnum] of String = ('', 'http://hl7.org/fhir/slotstatus', 'http://hl7.org/fhir/slotstatus', 'http://hl7.org/fhir/slotstatus', 'http://hl7.org/fhir/slotstatus', 'http://hl7.org/fhir/slotstatus');
  CODES_TFhirSpecimenStatusEnum : Array[TFhirSpecimenStatusEnum] of String = ('', 'available', 'unavailable', 'unsatisfactory', 'entered-in-error');
  SYSTEMS_TFhirSpecimenStatusEnum : Array[TFhirSpecimenStatusEnum] of String = ('', 'http://hl7.org/fhir/specimen-status', 'http://hl7.org/fhir/specimen-status', 'http://hl7.org/fhir/specimen-status', 'http://hl7.org/fhir/specimen-status');
  CODES_TFhirSpecimenContainedPreferenceEnum : Array[TFhirSpecimenContainedPreferenceEnum] of String = ('', 'preferred', 'alternate');
  SYSTEMS_TFhirSpecimenContainedPreferenceEnum : Array[TFhirSpecimenContainedPreferenceEnum] of String = ('', 'http://hl7.org/fhir/specimen-contained-preference', 'http://hl7.org/fhir/specimen-contained-preference');
  CODES_TFhirStructureDefinitionKindEnum : Array[TFhirStructureDefinitionKindEnum] of String = ('', 'primitive-type', 'complex-type', 'resource', 'logical');
  SYSTEMS_TFhirStructureDefinitionKindEnum : Array[TFhirStructureDefinitionKindEnum] of String = ('', 'http://hl7.org/fhir/structure-definition-kind', 'http://hl7.org/fhir/structure-definition-kind', 'http://hl7.org/fhir/structure-definition-kind', 'http://hl7.org/fhir/structure-definition-kind');
  CODES_TFhirExtensionContextTypeEnum : Array[TFhirExtensionContextTypeEnum] of String = ('', 'fhirpath', 'element', 'extension');
  SYSTEMS_TFhirExtensionContextTypeEnum : Array[TFhirExtensionContextTypeEnum] of String = ('', 'http://hl7.org/fhir/extension-context-type', 'http://hl7.org/fhir/extension-context-type', 'http://hl7.org/fhir/extension-context-type');
  CODES_TFhirTypeDerivationRuleEnum : Array[TFhirTypeDerivationRuleEnum] of String = ('', 'specialization', 'constraint');
  SYSTEMS_TFhirTypeDerivationRuleEnum : Array[TFhirTypeDerivationRuleEnum] of String = ('', 'http://hl7.org/fhir/type-derivation-rule', 'http://hl7.org/fhir/type-derivation-rule');
  CODES_TFhirMapModelModeEnum : Array[TFhirMapModelModeEnum] of String = ('', 'source', 'queried', 'target', 'produced');
  SYSTEMS_TFhirMapModelModeEnum : Array[TFhirMapModelModeEnum] of String = ('', 'http://hl7.org/fhir/map-model-mode', 'http://hl7.org/fhir/map-model-mode', 'http://hl7.org/fhir/map-model-mode', 'http://hl7.org/fhir/map-model-mode');
  CODES_TFhirMapGroupTypeModeEnum : Array[TFhirMapGroupTypeModeEnum] of String = ('', 'none', 'types', 'type-and-types');
  SYSTEMS_TFhirMapGroupTypeModeEnum : Array[TFhirMapGroupTypeModeEnum] of String = ('', 'http://hl7.org/fhir/map-group-type-mode', 'http://hl7.org/fhir/map-group-type-mode', 'http://hl7.org/fhir/map-group-type-mode');
  CODES_TFhirMapInputModeEnum : Array[TFhirMapInputModeEnum] of String = ('', 'source', 'target');
  SYSTEMS_TFhirMapInputModeEnum : Array[TFhirMapInputModeEnum] of String = ('', 'http://hl7.org/fhir/map-input-mode', 'http://hl7.org/fhir/map-input-mode');
  CODES_TFhirMapSourceListModeEnum : Array[TFhirMapSourceListModeEnum] of String = ('', 'first', 'not_first', 'last', 'not_last', 'only_one');
  SYSTEMS_TFhirMapSourceListModeEnum : Array[TFhirMapSourceListModeEnum] of String = ('', 'http://hl7.org/fhir/map-source-list-mode', 'http://hl7.org/fhir/map-source-list-mode', 'http://hl7.org/fhir/map-source-list-mode', 'http://hl7.org/fhir/map-source-list-mode', 'http://hl7.org/fhir/map-source-list-mode');
  CODES_TFhirMapContextTypeEnum : Array[TFhirMapContextTypeEnum] of String = ('', 'type', 'variable');
  SYSTEMS_TFhirMapContextTypeEnum : Array[TFhirMapContextTypeEnum] of String = ('', 'http://hl7.org/fhir/map-context-type', 'http://hl7.org/fhir/map-context-type');
  CODES_TFhirMapTargetListModeEnum : Array[TFhirMapTargetListModeEnum] of String = ('', 'first', 'share', 'last', 'collate');
  SYSTEMS_TFhirMapTargetListModeEnum : Array[TFhirMapTargetListModeEnum] of String = ('', 'http://hl7.org/fhir/map-target-list-mode', 'http://hl7.org/fhir/map-target-list-mode', 'http://hl7.org/fhir/map-target-list-mode', 'http://hl7.org/fhir/map-target-list-mode');
  CODES_TFhirMapTransformEnum : Array[TFhirMapTransformEnum] of String = ('', 'create', 'copy', 'truncate', 'escape', 'cast', 'append', 'translate', 'reference', 'dateOp', 'uuid', 'pointer', 'evaluate', 'cc', 'c', 'qty', 'id', 'cp');
  SYSTEMS_TFhirMapTransformEnum : Array[TFhirMapTransformEnum] of String = ('', 'http://hl7.org/fhir/map-transform', 'http://hl7.org/fhir/map-transform', 'http://hl7.org/fhir/map-transform', 'http://hl7.org/fhir/map-transform', 'http://hl7.org/fhir/map-transform', 'http://hl7.org/fhir/map-transform', 'http://hl7.org/fhir/map-transform', 'http://hl7.org/fhir/map-transform', 'http://hl7.org/fhir/map-transform', 'http://hl7.org/fhir/map-transform', 'http://hl7.org/fhir/map-transform', 'http://hl7.org/fhir/map-transform', 'http://hl7.org/fhir/map-transform', 'http://hl7.org/fhir/map-transform', 'http://hl7.org/fhir/map-transform', 'http://hl7.org/fhir/map-transform', 'http://hl7.org/fhir/map-transform');
  CODES_TFhirSubscriptionStatusEnum : Array[TFhirSubscriptionStatusEnum] of String = ('', 'requested', 'active', 'error', 'off');
  SYSTEMS_TFhirSubscriptionStatusEnum : Array[TFhirSubscriptionStatusEnum] of String = ('', 'http://hl7.org/fhir/subscription-status', 'http://hl7.org/fhir/subscription-status', 'http://hl7.org/fhir/subscription-status', 'http://hl7.org/fhir/subscription-status');
  CODES_TFhirSubscriptionChannelTypeEnum : Array[TFhirSubscriptionChannelTypeEnum] of String = ('', 'rest-hook', 'websocket', 'email', 'sms', 'message');
  SYSTEMS_TFhirSubscriptionChannelTypeEnum : Array[TFhirSubscriptionChannelTypeEnum] of String = ('', 'http://hl7.org/fhir/subscription-channel-type', 'http://hl7.org/fhir/subscription-channel-type', 'http://hl7.org/fhir/subscription-channel-type', 'http://hl7.org/fhir/subscription-channel-type', 'http://hl7.org/fhir/subscription-channel-type');
  CODES_TFhirSubstanceStatusEnum : Array[TFhirSubstanceStatusEnum] of String = ('', 'active', 'inactive', 'entered-in-error');
  SYSTEMS_TFhirSubstanceStatusEnum : Array[TFhirSubstanceStatusEnum] of String = ('', 'http://hl7.org/fhir/substance-status', 'http://hl7.org/fhir/substance-status', 'http://hl7.org/fhir/substance-status');
  CODES_TFhirSupplydeliveryStatusEnum : Array[TFhirSupplydeliveryStatusEnum] of String = ('', 'in-progress', 'completed', 'abandoned', 'entered-in-error');
  SYSTEMS_TFhirSupplydeliveryStatusEnum : Array[TFhirSupplydeliveryStatusEnum] of String = ('', 'http://hl7.org/fhir/supplydelivery-status', 'http://hl7.org/fhir/supplydelivery-status', 'http://hl7.org/fhir/supplydelivery-status', 'http://hl7.org/fhir/supplydelivery-status');
  CODES_TFhirSupplyrequestStatusEnum : Array[TFhirSupplyrequestStatusEnum] of String = ('', 'draft', 'active', 'suspended', 'cancelled', 'completed', 'entered-in-error', 'unknown');
  SYSTEMS_TFhirSupplyrequestStatusEnum : Array[TFhirSupplyrequestStatusEnum] of String = ('', 'http://hl7.org/fhir/supplyrequest-status', 'http://hl7.org/fhir/supplyrequest-status', 'http://hl7.org/fhir/supplyrequest-status', 'http://hl7.org/fhir/supplyrequest-status', 'http://hl7.org/fhir/supplyrequest-status', 'http://hl7.org/fhir/supplyrequest-status', 'http://hl7.org/fhir/supplyrequest-status');
  CODES_TFhirTaskStatusEnum : Array[TFhirTaskStatusEnum] of String = ('', 'draft', 'requested', 'received', 'accepted', 'rejected', 'ready', 'cancelled', 'in-progress', 'on-hold', 'failed', 'completed', 'entered-in-error');
  SYSTEMS_TFhirTaskStatusEnum : Array[TFhirTaskStatusEnum] of String = ('', 'http://hl7.org/fhir/task-status', 'http://hl7.org/fhir/task-status', 'http://hl7.org/fhir/task-status', 'http://hl7.org/fhir/task-status', 'http://hl7.org/fhir/task-status', 'http://hl7.org/fhir/task-status', 'http://hl7.org/fhir/task-status', 'http://hl7.org/fhir/task-status', 'http://hl7.org/fhir/task-status', 'http://hl7.org/fhir/task-status', 'http://hl7.org/fhir/task-status', 'http://hl7.org/fhir/task-status');
  CODES_TFhirTaskIntentEnum : Array[TFhirTaskIntentEnum] of String = ('', 'unknown', 'proposal', 'plan', 'order', 'original-order', 'reflex-order', 'filler-order', 'instance-order', 'option');
  SYSTEMS_TFhirTaskIntentEnum : Array[TFhirTaskIntentEnum] of String = ('', 'http://hl7.org/fhir/task-intent', 'http://hl7.org/fhir/request-intent', 'http://hl7.org/fhir/request-intent', 'http://hl7.org/fhir/request-intent', 'http://hl7.org/fhir/request-intent', 'http://hl7.org/fhir/request-intent', 'http://hl7.org/fhir/request-intent', 'http://hl7.org/fhir/request-intent', 'http://hl7.org/fhir/request-intent');
  CODES_TFhirCodeSearchSupportEnum : Array[TFhirCodeSearchSupportEnum] of String = ('', 'explicit', 'all');
  SYSTEMS_TFhirCodeSearchSupportEnum : Array[TFhirCodeSearchSupportEnum] of String = ('', 'http://hl7.org/fhir/code-search-support', 'http://hl7.org/fhir/code-search-support');
  CODES_TFhirReportStatusCodesEnum : Array[TFhirReportStatusCodesEnum] of String = ('', 'completed', 'in-progress', 'waiting', 'stopped', 'entered-in-error');
  SYSTEMS_TFhirReportStatusCodesEnum : Array[TFhirReportStatusCodesEnum] of String = ('', 'http://hl7.org/fhir/report-status-codes', 'http://hl7.org/fhir/report-status-codes', 'http://hl7.org/fhir/report-status-codes', 'http://hl7.org/fhir/report-status-codes', 'http://hl7.org/fhir/report-status-codes');
  CODES_TFhirReportResultCodesEnum : Array[TFhirReportResultCodesEnum] of String = ('', 'pass', 'fail', 'pending');
  SYSTEMS_TFhirReportResultCodesEnum : Array[TFhirReportResultCodesEnum] of String = ('', 'http://hl7.org/fhir/report-result-codes', 'http://hl7.org/fhir/report-result-codes', 'http://hl7.org/fhir/report-result-codes');
  CODES_TFhirReportParticipantTypeEnum : Array[TFhirReportParticipantTypeEnum] of String = ('', 'test-engine', 'client', 'server');
  SYSTEMS_TFhirReportParticipantTypeEnum : Array[TFhirReportParticipantTypeEnum] of String = ('', 'http://hl7.org/fhir/report-participant-type', 'http://hl7.org/fhir/report-participant-type', 'http://hl7.org/fhir/report-participant-type');
  CODES_TFhirReportActionResultCodesEnum : Array[TFhirReportActionResultCodesEnum] of String = ('', 'pass', 'skip', 'fail', 'warning', 'error');
  SYSTEMS_TFhirReportActionResultCodesEnum : Array[TFhirReportActionResultCodesEnum] of String = ('', 'http://hl7.org/fhir/report-action-result-codes', 'http://hl7.org/fhir/report-action-result-codes', 'http://hl7.org/fhir/report-action-result-codes', 'http://hl7.org/fhir/report-action-result-codes', 'http://hl7.org/fhir/report-action-result-codes');
  CODES_TFhirHttpOperationsEnum : Array[TFhirHttpOperationsEnum] of String = ('', 'delete', 'get', 'options', 'patch', 'post', 'put', 'head');
  SYSTEMS_TFhirHttpOperationsEnum : Array[TFhirHttpOperationsEnum] of String = ('', 'http://hl7.org/fhir/http-operations', 'http://hl7.org/fhir/http-operations', 'http://hl7.org/fhir/http-operations', 'http://hl7.org/fhir/http-operations', 'http://hl7.org/fhir/http-operations', 'http://hl7.org/fhir/http-operations', 'http://hl7.org/fhir/http-operations');
  CODES_TFhirAssertDirectionCodesEnum : Array[TFhirAssertDirectionCodesEnum] of String = ('', 'response', 'request');
  SYSTEMS_TFhirAssertDirectionCodesEnum : Array[TFhirAssertDirectionCodesEnum] of String = ('', 'http://hl7.org/fhir/assert-direction-codes', 'http://hl7.org/fhir/assert-direction-codes');
  CODES_TFhirAssertOperatorCodesEnum : Array[TFhirAssertOperatorCodesEnum] of String = ('', 'equals', 'notEquals', 'in', 'notIn', 'greaterThan', 'lessThan', 'empty', 'notEmpty', 'contains', 'notContains', 'eval');
  SYSTEMS_TFhirAssertOperatorCodesEnum : Array[TFhirAssertOperatorCodesEnum] of String = ('', 'http://hl7.org/fhir/assert-operator-codes', 'http://hl7.org/fhir/assert-operator-codes', 'http://hl7.org/fhir/assert-operator-codes', 'http://hl7.org/fhir/assert-operator-codes', 'http://hl7.org/fhir/assert-operator-codes', 'http://hl7.org/fhir/assert-operator-codes', 'http://hl7.org/fhir/assert-operator-codes', 'http://hl7.org/fhir/assert-operator-codes', 'http://hl7.org/fhir/assert-operator-codes', 'http://hl7.org/fhir/assert-operator-codes', 'http://hl7.org/fhir/assert-operator-codes');
  CODES_TFhirAssertResponseCodeTypesEnum : Array[TFhirAssertResponseCodeTypesEnum] of String = ('', 'okay', 'created', 'noContent', 'notModified', 'bad', 'forbidden', 'notFound', 'methodNotAllowed', 'conflict', 'gone', 'preconditionFailed', 'unprocessable');
  SYSTEMS_TFhirAssertResponseCodeTypesEnum : Array[TFhirAssertResponseCodeTypesEnum] of String = ('', 'http://hl7.org/fhir/assert-response-code-types', 'http://hl7.org/fhir/assert-response-code-types', 'http://hl7.org/fhir/assert-response-code-types', 'http://hl7.org/fhir/assert-response-code-types', 'http://hl7.org/fhir/assert-response-code-types', 'http://hl7.org/fhir/assert-response-code-types', 'http://hl7.org/fhir/assert-response-code-types', 'http://hl7.org/fhir/assert-response-code-types', 'http://hl7.org/fhir/assert-response-code-types', 'http://hl7.org/fhir/assert-response-code-types', 'http://hl7.org/fhir/assert-response-code-types', 'http://hl7.org/fhir/assert-response-code-types');
  CODES_TFhirVerificationresultStatusEnum : Array[TFhirVerificationresultStatusEnum] of String = ('', 'attested', 'validated', 'in-process', 'req-revalid', 'val-fail', 'reval-fail');
  SYSTEMS_TFhirVerificationresultStatusEnum : Array[TFhirVerificationresultStatusEnum] of String = ('', 'http://hl7.org/fhir/CodeSystem/status', 'http://hl7.org/fhir/CodeSystem/status', 'http://hl7.org/fhir/CodeSystem/status', 'http://hl7.org/fhir/CodeSystem/status', 'http://hl7.org/fhir/CodeSystem/status', 'http://hl7.org/fhir/CodeSystem/status');
  CODES_TFhirVisionEyeCodesEnum : Array[TFhirVisionEyeCodesEnum] of String = ('', 'right', 'left');
  SYSTEMS_TFhirVisionEyeCodesEnum : Array[TFhirVisionEyeCodesEnum] of String = ('', 'http://hl7.org/fhir/vision-eye-codes', 'http://hl7.org/fhir/vision-eye-codes');
  CODES_TFhirVisionBaseCodesEnum : Array[TFhirVisionBaseCodesEnum] of String = ('', 'up', 'down', 'in', 'out');
  SYSTEMS_TFhirVisionBaseCodesEnum : Array[TFhirVisionBaseCodesEnum] of String = ('', 'http://hl7.org/fhir/vision-base-codes', 'http://hl7.org/fhir/vision-base-codes', 'http://hl7.org/fhir/vision-base-codes', 'http://hl7.org/fhir/vision-base-codes');

Function TFhirPublicationStatusEnumListAsInteger(aSet : TFhirPublicationStatusEnumList) : Integer; overload;
Function IntegerAsTFhirPublicationStatusEnumList(i : integer) : TFhirPublicationStatusEnumList; overload;
Function TFhirNarrativeStatusEnumListAsInteger(aSet : TFhirNarrativeStatusEnumList) : Integer; overload;
Function IntegerAsTFhirNarrativeStatusEnumList(i : integer) : TFhirNarrativeStatusEnumList; overload;
Function TFhirContributorTypeEnumListAsInteger(aSet : TFhirContributorTypeEnumList) : Integer; overload;
Function IntegerAsTFhirContributorTypeEnumList(i : integer) : TFhirContributorTypeEnumList; overload;
Function TFhirAllTypesEnumListAsInteger(aSet : TFhirAllTypesEnumList) : Integer; overload;
Function IntegerAsTFhirAllTypesEnumList(i : integer) : TFhirAllTypesEnumList; overload;
Function TFhirSortDirectionEnumListAsInteger(aSet : TFhirSortDirectionEnumList) : Integer; overload;
Function IntegerAsTFhirSortDirectionEnumList(i : integer) : TFhirSortDirectionEnumList; overload;
Function TFhirIdentifierUseEnumListAsInteger(aSet : TFhirIdentifierUseEnumList) : Integer; overload;
Function IntegerAsTFhirIdentifierUseEnumList(i : integer) : TFhirIdentifierUseEnumList; overload;
Function TFhirTriggerTypeEnumListAsInteger(aSet : TFhirTriggerTypeEnumList) : Integer; overload;
Function IntegerAsTFhirTriggerTypeEnumList(i : integer) : TFhirTriggerTypeEnumList; overload;
Function TFhirQuantityComparatorEnumListAsInteger(aSet : TFhirQuantityComparatorEnumList) : Integer; overload;
Function IntegerAsTFhirQuantityComparatorEnumList(i : integer) : TFhirQuantityComparatorEnumList; overload;
Function TFhirRelatedArtifactTypeEnumListAsInteger(aSet : TFhirRelatedArtifactTypeEnumList) : Integer; overload;
Function IntegerAsTFhirRelatedArtifactTypeEnumList(i : integer) : TFhirRelatedArtifactTypeEnumList; overload;
Function TFhirOperationParameterUseEnumListAsInteger(aSet : TFhirOperationParameterUseEnumList) : Integer; overload;
Function IntegerAsTFhirOperationParameterUseEnumList(i : integer) : TFhirOperationParameterUseEnumList; overload;
Function TFhirContactPointSystemEnumListAsInteger(aSet : TFhirContactPointSystemEnumList) : Integer; overload;
Function IntegerAsTFhirContactPointSystemEnumList(i : integer) : TFhirContactPointSystemEnumList; overload;
Function TFhirContactPointUseEnumListAsInteger(aSet : TFhirContactPointUseEnumList) : Integer; overload;
Function IntegerAsTFhirContactPointUseEnumList(i : integer) : TFhirContactPointUseEnumList; overload;
Function TFhirNameUseEnumListAsInteger(aSet : TFhirNameUseEnumList) : Integer; overload;
Function IntegerAsTFhirNameUseEnumList(i : integer) : TFhirNameUseEnumList; overload;
Function TFhirAddressUseEnumListAsInteger(aSet : TFhirAddressUseEnumList) : Integer; overload;
Function IntegerAsTFhirAddressUseEnumList(i : integer) : TFhirAddressUseEnumList; overload;
Function TFhirAddressTypeEnumListAsInteger(aSet : TFhirAddressTypeEnumList) : Integer; overload;
Function IntegerAsTFhirAddressTypeEnumList(i : integer) : TFhirAddressTypeEnumList; overload;
Function TFhirPropertyRepresentationEnumListAsInteger(aSet : TFhirPropertyRepresentationEnumList) : Integer; overload;
Function IntegerAsTFhirPropertyRepresentationEnumList(i : integer) : TFhirPropertyRepresentationEnumList; overload;
Function TFhirDiscriminatorTypeEnumListAsInteger(aSet : TFhirDiscriminatorTypeEnumList) : Integer; overload;
Function IntegerAsTFhirDiscriminatorTypeEnumList(i : integer) : TFhirDiscriminatorTypeEnumList; overload;
Function TFhirResourceSlicingRulesEnumListAsInteger(aSet : TFhirResourceSlicingRulesEnumList) : Integer; overload;
Function IntegerAsTFhirResourceSlicingRulesEnumList(i : integer) : TFhirResourceSlicingRulesEnumList; overload;
Function TFhirResourceAggregationModeEnumListAsInteger(aSet : TFhirResourceAggregationModeEnumList) : Integer; overload;
Function IntegerAsTFhirResourceAggregationModeEnumList(i : integer) : TFhirResourceAggregationModeEnumList; overload;
Function TFhirReferenceVersionRulesEnumListAsInteger(aSet : TFhirReferenceVersionRulesEnumList) : Integer; overload;
Function IntegerAsTFhirReferenceVersionRulesEnumList(i : integer) : TFhirReferenceVersionRulesEnumList; overload;
Function TFhirConstraintSeverityEnumListAsInteger(aSet : TFhirConstraintSeverityEnumList) : Integer; overload;
Function IntegerAsTFhirConstraintSeverityEnumList(i : integer) : TFhirConstraintSeverityEnumList; overload;
Function TFhirBindingStrengthEnumListAsInteger(aSet : TFhirBindingStrengthEnumList) : Integer; overload;
Function IntegerAsTFhirBindingStrengthEnumList(i : integer) : TFhirBindingStrengthEnumList; overload;
Function TFhirUnitsOfTimeEnumListAsInteger(aSet : TFhirUnitsOfTimeEnumList) : Integer; overload;
Function IntegerAsTFhirUnitsOfTimeEnumList(i : integer) : TFhirUnitsOfTimeEnumList; overload;
Function TFhirDaysOfWeekEnumListAsInteger(aSet : TFhirDaysOfWeekEnumList) : Integer; overload;
Function IntegerAsTFhirDaysOfWeekEnumList(i : integer) : TFhirDaysOfWeekEnumList; overload;
Function TFhirEventTimingEnumListAsInteger(aSet : TFhirEventTimingEnumList) : Integer; overload;
Function IntegerAsTFhirEventTimingEnumList(i : integer) : TFhirEventTimingEnumList; overload;
Function TFhirAccountStatusEnumListAsInteger(aSet : TFhirAccountStatusEnumList) : Integer; overload;
Function IntegerAsTFhirAccountStatusEnumList(i : integer) : TFhirAccountStatusEnumList; overload;
Function TFhirRequestResourceTypesEnumListAsInteger(aSet : TFhirRequestResourceTypesEnumList) : Integer; overload;
Function IntegerAsTFhirRequestResourceTypesEnumList(i : integer) : TFhirRequestResourceTypesEnumList; overload;
Function TFhirRequestIntentEnumListAsInteger(aSet : TFhirRequestIntentEnumList) : Integer; overload;
Function IntegerAsTFhirRequestIntentEnumList(i : integer) : TFhirRequestIntentEnumList; overload;
Function TFhirRequestPriorityEnumListAsInteger(aSet : TFhirRequestPriorityEnumList) : Integer; overload;
Function IntegerAsTFhirRequestPriorityEnumList(i : integer) : TFhirRequestPriorityEnumList; overload;
Function TFhirActionParticipantTypeEnumListAsInteger(aSet : TFhirActionParticipantTypeEnumList) : Integer; overload;
Function IntegerAsTFhirActionParticipantTypeEnumList(i : integer) : TFhirActionParticipantTypeEnumList; overload;
Function TFhirAdverseEventActualityEnumListAsInteger(aSet : TFhirAdverseEventActualityEnumList) : Integer; overload;
Function IntegerAsTFhirAdverseEventActualityEnumList(i : integer) : TFhirAdverseEventActualityEnumList; overload;
Function TFhirAllergyIntoleranceTypeEnumListAsInteger(aSet : TFhirAllergyIntoleranceTypeEnumList) : Integer; overload;
Function IntegerAsTFhirAllergyIntoleranceTypeEnumList(i : integer) : TFhirAllergyIntoleranceTypeEnumList; overload;
Function TFhirAllergyIntoleranceCategoryEnumListAsInteger(aSet : TFhirAllergyIntoleranceCategoryEnumList) : Integer; overload;
Function IntegerAsTFhirAllergyIntoleranceCategoryEnumList(i : integer) : TFhirAllergyIntoleranceCategoryEnumList; overload;
Function TFhirAllergyIntoleranceCriticalityEnumListAsInteger(aSet : TFhirAllergyIntoleranceCriticalityEnumList) : Integer; overload;
Function IntegerAsTFhirAllergyIntoleranceCriticalityEnumList(i : integer) : TFhirAllergyIntoleranceCriticalityEnumList; overload;
Function TFhirReactionEventSeverityEnumListAsInteger(aSet : TFhirReactionEventSeverityEnumList) : Integer; overload;
Function IntegerAsTFhirReactionEventSeverityEnumList(i : integer) : TFhirReactionEventSeverityEnumList; overload;
Function TFhirAppointmentstatusEnumListAsInteger(aSet : TFhirAppointmentstatusEnumList) : Integer; overload;
Function IntegerAsTFhirAppointmentstatusEnumList(i : integer) : TFhirAppointmentstatusEnumList; overload;
Function TFhirParticipantrequiredEnumListAsInteger(aSet : TFhirParticipantrequiredEnumList) : Integer; overload;
Function IntegerAsTFhirParticipantrequiredEnumList(i : integer) : TFhirParticipantrequiredEnumList; overload;
Function TFhirParticipationstatusEnumListAsInteger(aSet : TFhirParticipationstatusEnumList) : Integer; overload;
Function IntegerAsTFhirParticipationstatusEnumList(i : integer) : TFhirParticipationstatusEnumList; overload;
Function TFhirAuditEventActionEnumListAsInteger(aSet : TFhirAuditEventActionEnumList) : Integer; overload;
Function IntegerAsTFhirAuditEventActionEnumList(i : integer) : TFhirAuditEventActionEnumList; overload;
Function TFhirAuditEventOutcomeEnumListAsInteger(aSet : TFhirAuditEventOutcomeEnumList) : Integer; overload;
Function IntegerAsTFhirAuditEventOutcomeEnumList(i : integer) : TFhirAuditEventOutcomeEnumList; overload;
Function TFhirNetworkTypeEnumListAsInteger(aSet : TFhirNetworkTypeEnumList) : Integer; overload;
Function IntegerAsTFhirNetworkTypeEnumList(i : integer) : TFhirNetworkTypeEnumList; overload;
Function TFhirProductCategoryEnumListAsInteger(aSet : TFhirProductCategoryEnumList) : Integer; overload;
Function IntegerAsTFhirProductCategoryEnumList(i : integer) : TFhirProductCategoryEnumList; overload;
Function TFhirProductStatusEnumListAsInteger(aSet : TFhirProductStatusEnumList) : Integer; overload;
Function IntegerAsTFhirProductStatusEnumList(i : integer) : TFhirProductStatusEnumList; overload;
Function TFhirProductStorageScaleEnumListAsInteger(aSet : TFhirProductStorageScaleEnumList) : Integer; overload;
Function IntegerAsTFhirProductStorageScaleEnumList(i : integer) : TFhirProductStorageScaleEnumList; overload;
Function TFhirBundleTypeEnumListAsInteger(aSet : TFhirBundleTypeEnumList) : Integer; overload;
Function IntegerAsTFhirBundleTypeEnumList(i : integer) : TFhirBundleTypeEnumList; overload;
Function TFhirSearchEntryModeEnumListAsInteger(aSet : TFhirSearchEntryModeEnumList) : Integer; overload;
Function IntegerAsTFhirSearchEntryModeEnumList(i : integer) : TFhirSearchEntryModeEnumList; overload;
Function TFhirHttpVerbEnumListAsInteger(aSet : TFhirHttpVerbEnumList) : Integer; overload;
Function IntegerAsTFhirHttpVerbEnumList(i : integer) : TFhirHttpVerbEnumList; overload;
Function TFhirCapabilityStatementKindEnumListAsInteger(aSet : TFhirCapabilityStatementKindEnumList) : Integer; overload;
Function IntegerAsTFhirCapabilityStatementKindEnumList(i : integer) : TFhirCapabilityStatementKindEnumList; overload;
Function TFhirFHIRVersionEnumListAsInteger(aSet : TFhirFHIRVersionEnumList) : Integer; overload;
Function IntegerAsTFhirFHIRVersionEnumList(i : integer) : TFhirFHIRVersionEnumList; overload;
Function TFhirRestfulCapabilityModeEnumListAsInteger(aSet : TFhirRestfulCapabilityModeEnumList) : Integer; overload;
Function IntegerAsTFhirRestfulCapabilityModeEnumList(i : integer) : TFhirRestfulCapabilityModeEnumList; overload;
Function TFhirResourceTypesEnumListAsInteger(aSet : TFhirResourceTypesEnumList) : Integer; overload;
Function IntegerAsTFhirResourceTypesEnumList(i : integer) : TFhirResourceTypesEnumList; overload;
Function TFhirTypeRestfulInteractionEnumListAsInteger(aSet : TFhirTypeRestfulInteractionEnumList) : Integer; overload;
Function IntegerAsTFhirTypeRestfulInteractionEnumList(i : integer) : TFhirTypeRestfulInteractionEnumList; overload;
Function TFhirVersioningPolicyEnumListAsInteger(aSet : TFhirVersioningPolicyEnumList) : Integer; overload;
Function IntegerAsTFhirVersioningPolicyEnumList(i : integer) : TFhirVersioningPolicyEnumList; overload;
Function TFhirConditionalReadStatusEnumListAsInteger(aSet : TFhirConditionalReadStatusEnumList) : Integer; overload;
Function IntegerAsTFhirConditionalReadStatusEnumList(i : integer) : TFhirConditionalReadStatusEnumList; overload;
Function TFhirConditionalDeleteStatusEnumListAsInteger(aSet : TFhirConditionalDeleteStatusEnumList) : Integer; overload;
Function IntegerAsTFhirConditionalDeleteStatusEnumList(i : integer) : TFhirConditionalDeleteStatusEnumList; overload;
Function TFhirReferenceHandlingPolicyEnumListAsInteger(aSet : TFhirReferenceHandlingPolicyEnumList) : Integer; overload;
Function IntegerAsTFhirReferenceHandlingPolicyEnumList(i : integer) : TFhirReferenceHandlingPolicyEnumList; overload;
Function TFhirSearchParamTypeEnumListAsInteger(aSet : TFhirSearchParamTypeEnumList) : Integer; overload;
Function IntegerAsTFhirSearchParamTypeEnumList(i : integer) : TFhirSearchParamTypeEnumList; overload;
Function TFhirSystemRestfulInteractionEnumListAsInteger(aSet : TFhirSystemRestfulInteractionEnumList) : Integer; overload;
Function IntegerAsTFhirSystemRestfulInteractionEnumList(i : integer) : TFhirSystemRestfulInteractionEnumList; overload;
Function TFhirEventCapabilityModeEnumListAsInteger(aSet : TFhirEventCapabilityModeEnumList) : Integer; overload;
Function IntegerAsTFhirEventCapabilityModeEnumList(i : integer) : TFhirEventCapabilityModeEnumList; overload;
Function TFhirDocumentModeEnumListAsInteger(aSet : TFhirDocumentModeEnumList) : Integer; overload;
Function IntegerAsTFhirDocumentModeEnumList(i : integer) : TFhirDocumentModeEnumList; overload;
Function TFhirRequestStatusEnumListAsInteger(aSet : TFhirRequestStatusEnumList) : Integer; overload;
Function IntegerAsTFhirRequestStatusEnumList(i : integer) : TFhirRequestStatusEnumList; overload;
Function TFhirCarePlanIntentEnumListAsInteger(aSet : TFhirCarePlanIntentEnumList) : Integer; overload;
Function IntegerAsTFhirCarePlanIntentEnumList(i : integer) : TFhirCarePlanIntentEnumList; overload;
Function TFhirCarePlanActivityKindEnumListAsInteger(aSet : TFhirCarePlanActivityKindEnumList) : Integer; overload;
Function IntegerAsTFhirCarePlanActivityKindEnumList(i : integer) : TFhirCarePlanActivityKindEnumList; overload;
Function TFhirCarePlanActivityStatusEnumListAsInteger(aSet : TFhirCarePlanActivityStatusEnumList) : Integer; overload;
Function IntegerAsTFhirCarePlanActivityStatusEnumList(i : integer) : TFhirCarePlanActivityStatusEnumList; overload;
Function TFhirCareTeamStatusEnumListAsInteger(aSet : TFhirCareTeamStatusEnumList) : Integer; overload;
Function IntegerAsTFhirCareTeamStatusEnumList(i : integer) : TFhirCareTeamStatusEnumList; overload;
Function TFhirRelationTypeEnumListAsInteger(aSet : TFhirRelationTypeEnumList) : Integer; overload;
Function IntegerAsTFhirRelationTypeEnumList(i : integer) : TFhirRelationTypeEnumList; overload;
Function TFhirChargeitemStatusEnumListAsInteger(aSet : TFhirChargeitemStatusEnumList) : Integer; overload;
Function IntegerAsTFhirChargeitemStatusEnumList(i : integer) : TFhirChargeitemStatusEnumList; overload;
Function TFhirInvoicePriceComponentTypeEnumListAsInteger(aSet : TFhirInvoicePriceComponentTypeEnumList) : Integer; overload;
Function IntegerAsTFhirInvoicePriceComponentTypeEnumList(i : integer) : TFhirInvoicePriceComponentTypeEnumList; overload;
Function TFhirFmStatusEnumListAsInteger(aSet : TFhirFmStatusEnumList) : Integer; overload;
Function IntegerAsTFhirFmStatusEnumList(i : integer) : TFhirFmStatusEnumList; overload;
Function TFhirClaimUseEnumListAsInteger(aSet : TFhirClaimUseEnumList) : Integer; overload;
Function IntegerAsTFhirClaimUseEnumList(i : integer) : TFhirClaimUseEnumList; overload;
Function TFhirRemittanceOutcomeEnumListAsInteger(aSet : TFhirRemittanceOutcomeEnumList) : Integer; overload;
Function IntegerAsTFhirRemittanceOutcomeEnumList(i : integer) : TFhirRemittanceOutcomeEnumList; overload;
Function TFhirNoteTypeEnumListAsInteger(aSet : TFhirNoteTypeEnumList) : Integer; overload;
Function IntegerAsTFhirNoteTypeEnumList(i : integer) : TFhirNoteTypeEnumList; overload;
Function TFhirClinicalimpressionStatusEnumListAsInteger(aSet : TFhirClinicalimpressionStatusEnumList) : Integer; overload;
Function IntegerAsTFhirClinicalimpressionStatusEnumList(i : integer) : TFhirClinicalimpressionStatusEnumList; overload;
Function TFhirCodesystemHierarchyMeaningEnumListAsInteger(aSet : TFhirCodesystemHierarchyMeaningEnumList) : Integer; overload;
Function IntegerAsTFhirCodesystemHierarchyMeaningEnumList(i : integer) : TFhirCodesystemHierarchyMeaningEnumList; overload;
Function TFhirCodesystemContentModeEnumListAsInteger(aSet : TFhirCodesystemContentModeEnumList) : Integer; overload;
Function IntegerAsTFhirCodesystemContentModeEnumList(i : integer) : TFhirCodesystemContentModeEnumList; overload;
Function TFhirFilterOperatorEnumListAsInteger(aSet : TFhirFilterOperatorEnumList) : Integer; overload;
Function IntegerAsTFhirFilterOperatorEnumList(i : integer) : TFhirFilterOperatorEnumList; overload;
Function TFhirConceptPropertyTypeEnumListAsInteger(aSet : TFhirConceptPropertyTypeEnumList) : Integer; overload;
Function IntegerAsTFhirConceptPropertyTypeEnumList(i : integer) : TFhirConceptPropertyTypeEnumList; overload;
Function TFhirEventStatusEnumListAsInteger(aSet : TFhirEventStatusEnumList) : Integer; overload;
Function IntegerAsTFhirEventStatusEnumList(i : integer) : TFhirEventStatusEnumList; overload;
Function TFhirCompartmentTypeEnumListAsInteger(aSet : TFhirCompartmentTypeEnumList) : Integer; overload;
Function IntegerAsTFhirCompartmentTypeEnumList(i : integer) : TFhirCompartmentTypeEnumList; overload;
Function TFhirCompositionStatusEnumListAsInteger(aSet : TFhirCompositionStatusEnumList) : Integer; overload;
Function IntegerAsTFhirCompositionStatusEnumList(i : integer) : TFhirCompositionStatusEnumList; overload;
Function TFhirV3ConfidentialityClassificationEnumListAsInteger(aSet : TFhirV3ConfidentialityClassificationEnumList) : Integer; overload;
Function IntegerAsTFhirV3ConfidentialityClassificationEnumList(i : integer) : TFhirV3ConfidentialityClassificationEnumList; overload;
Function TFhirCompositionAttestationModeEnumListAsInteger(aSet : TFhirCompositionAttestationModeEnumList) : Integer; overload;
Function IntegerAsTFhirCompositionAttestationModeEnumList(i : integer) : TFhirCompositionAttestationModeEnumList; overload;
Function TFhirDocumentRelationshipTypeEnumListAsInteger(aSet : TFhirDocumentRelationshipTypeEnumList) : Integer; overload;
Function IntegerAsTFhirDocumentRelationshipTypeEnumList(i : integer) : TFhirDocumentRelationshipTypeEnumList; overload;
Function TFhirListModeEnumListAsInteger(aSet : TFhirListModeEnumList) : Integer; overload;
Function IntegerAsTFhirListModeEnumList(i : integer) : TFhirListModeEnumList; overload;
Function TFhirConceptMapEquivalenceEnumListAsInteger(aSet : TFhirConceptMapEquivalenceEnumList) : Integer; overload;
Function IntegerAsTFhirConceptMapEquivalenceEnumList(i : integer) : TFhirConceptMapEquivalenceEnumList; overload;
Function TFhirConceptmapUnmappedModeEnumListAsInteger(aSet : TFhirConceptmapUnmappedModeEnumList) : Integer; overload;
Function IntegerAsTFhirConceptmapUnmappedModeEnumList(i : integer) : TFhirConceptmapUnmappedModeEnumList; overload;
Function TFhirConsentStateCodesEnumListAsInteger(aSet : TFhirConsentStateCodesEnumList) : Integer; overload;
Function IntegerAsTFhirConsentStateCodesEnumList(i : integer) : TFhirConsentStateCodesEnumList; overload;
Function TFhirConsentProvisionTypeEnumListAsInteger(aSet : TFhirConsentProvisionTypeEnumList) : Integer; overload;
Function IntegerAsTFhirConsentProvisionTypeEnumList(i : integer) : TFhirConsentProvisionTypeEnumList; overload;
Function TFhirConsentDataMeaningEnumListAsInteger(aSet : TFhirConsentDataMeaningEnumList) : Integer; overload;
Function IntegerAsTFhirConsentDataMeaningEnumList(i : integer) : TFhirConsentDataMeaningEnumList; overload;
Function TFhirContractStatusEnumListAsInteger(aSet : TFhirContractStatusEnumList) : Integer; overload;
Function IntegerAsTFhirContractStatusEnumList(i : integer) : TFhirContractStatusEnumList; overload;
Function TFhirContractPublicationstatusEnumListAsInteger(aSet : TFhirContractPublicationstatusEnumList) : Integer; overload;
Function IntegerAsTFhirContractPublicationstatusEnumList(i : integer) : TFhirContractPublicationstatusEnumList; overload;
Function TFhirEligibilityrequestPurposeEnumListAsInteger(aSet : TFhirEligibilityrequestPurposeEnumList) : Integer; overload;
Function IntegerAsTFhirEligibilityrequestPurposeEnumList(i : integer) : TFhirEligibilityrequestPurposeEnumList; overload;
Function TFhirEligibilityresponsePurposeEnumListAsInteger(aSet : TFhirEligibilityresponsePurposeEnumList) : Integer; overload;
Function IntegerAsTFhirEligibilityresponsePurposeEnumList(i : integer) : TFhirEligibilityresponsePurposeEnumList; overload;
Function TFhirObservationStatusEnumListAsInteger(aSet : TFhirObservationStatusEnumList) : Integer; overload;
Function IntegerAsTFhirObservationStatusEnumList(i : integer) : TFhirObservationStatusEnumList; overload;
Function TFhirDetectedissueSeverityEnumListAsInteger(aSet : TFhirDetectedissueSeverityEnumList) : Integer; overload;
Function IntegerAsTFhirDetectedissueSeverityEnumList(i : integer) : TFhirDetectedissueSeverityEnumList; overload;
Function TFhirUdiEntryTypeEnumListAsInteger(aSet : TFhirUdiEntryTypeEnumList) : Integer; overload;
Function IntegerAsTFhirUdiEntryTypeEnumList(i : integer) : TFhirUdiEntryTypeEnumList; overload;
Function TFhirDeviceStatusEnumListAsInteger(aSet : TFhirDeviceStatusEnumList) : Integer; overload;
Function IntegerAsTFhirDeviceStatusEnumList(i : integer) : TFhirDeviceStatusEnumList; overload;
Function TFhirDeviceNametypeEnumListAsInteger(aSet : TFhirDeviceNametypeEnumList) : Integer; overload;
Function IntegerAsTFhirDeviceNametypeEnumList(i : integer) : TFhirDeviceNametypeEnumList; overload;
Function TFhirMetricOperationalStatusEnumListAsInteger(aSet : TFhirMetricOperationalStatusEnumList) : Integer; overload;
Function IntegerAsTFhirMetricOperationalStatusEnumList(i : integer) : TFhirMetricOperationalStatusEnumList; overload;
Function TFhirMetricColorEnumListAsInteger(aSet : TFhirMetricColorEnumList) : Integer; overload;
Function IntegerAsTFhirMetricColorEnumList(i : integer) : TFhirMetricColorEnumList; overload;
Function TFhirMetricCategoryEnumListAsInteger(aSet : TFhirMetricCategoryEnumList) : Integer; overload;
Function IntegerAsTFhirMetricCategoryEnumList(i : integer) : TFhirMetricCategoryEnumList; overload;
Function TFhirMetricCalibrationTypeEnumListAsInteger(aSet : TFhirMetricCalibrationTypeEnumList) : Integer; overload;
Function IntegerAsTFhirMetricCalibrationTypeEnumList(i : integer) : TFhirMetricCalibrationTypeEnumList; overload;
Function TFhirMetricCalibrationStateEnumListAsInteger(aSet : TFhirMetricCalibrationStateEnumList) : Integer; overload;
Function IntegerAsTFhirMetricCalibrationStateEnumList(i : integer) : TFhirMetricCalibrationStateEnumList; overload;
Function TFhirDeviceStatementStatusEnumListAsInteger(aSet : TFhirDeviceStatementStatusEnumList) : Integer; overload;
Function IntegerAsTFhirDeviceStatementStatusEnumList(i : integer) : TFhirDeviceStatementStatusEnumList; overload;
Function TFhirDiagnosticReportStatusEnumListAsInteger(aSet : TFhirDiagnosticReportStatusEnumList) : Integer; overload;
Function IntegerAsTFhirDiagnosticReportStatusEnumList(i : integer) : TFhirDiagnosticReportStatusEnumList; overload;
Function TFhirDocumentReferenceStatusEnumListAsInteger(aSet : TFhirDocumentReferenceStatusEnumList) : Integer; overload;
Function IntegerAsTFhirDocumentReferenceStatusEnumList(i : integer) : TFhirDocumentReferenceStatusEnumList; overload;
Function TFhirExposureStateEnumListAsInteger(aSet : TFhirExposureStateEnumList) : Integer; overload;
Function IntegerAsTFhirExposureStateEnumList(i : integer) : TFhirExposureStateEnumList; overload;
Function TFhirEncounterStatusEnumListAsInteger(aSet : TFhirEncounterStatusEnumList) : Integer; overload;
Function IntegerAsTFhirEncounterStatusEnumList(i : integer) : TFhirEncounterStatusEnumList; overload;
Function TFhirEncounterLocationStatusEnumListAsInteger(aSet : TFhirEncounterLocationStatusEnumList) : Integer; overload;
Function IntegerAsTFhirEncounterLocationStatusEnumList(i : integer) : TFhirEncounterLocationStatusEnumList; overload;
Function TFhirEndpointStatusEnumListAsInteger(aSet : TFhirEndpointStatusEnumList) : Integer; overload;
Function IntegerAsTFhirEndpointStatusEnumList(i : integer) : TFhirEndpointStatusEnumList; overload;
Function TFhirEpisodeOfCareStatusEnumListAsInteger(aSet : TFhirEpisodeOfCareStatusEnumList) : Integer; overload;
Function IntegerAsTFhirEpisodeOfCareStatusEnumList(i : integer) : TFhirEpisodeOfCareStatusEnumList; overload;
Function TFhirVariableTypeEnumListAsInteger(aSet : TFhirVariableTypeEnumList) : Integer; overload;
Function IntegerAsTFhirVariableTypeEnumList(i : integer) : TFhirVariableTypeEnumList; overload;
Function TFhirGroupMeasureEnumListAsInteger(aSet : TFhirGroupMeasureEnumList) : Integer; overload;
Function IntegerAsTFhirGroupMeasureEnumList(i : integer) : TFhirGroupMeasureEnumList; overload;
Function TFhirExamplescenarioActorTypeEnumListAsInteger(aSet : TFhirExamplescenarioActorTypeEnumList) : Integer; overload;
Function IntegerAsTFhirExamplescenarioActorTypeEnumList(i : integer) : TFhirExamplescenarioActorTypeEnumList; overload;
Function TFhirExplanationofbenefitStatusEnumListAsInteger(aSet : TFhirExplanationofbenefitStatusEnumList) : Integer; overload;
Function IntegerAsTFhirExplanationofbenefitStatusEnumList(i : integer) : TFhirExplanationofbenefitStatusEnumList; overload;
Function TFhirHistoryStatusEnumListAsInteger(aSet : TFhirHistoryStatusEnumList) : Integer; overload;
Function IntegerAsTFhirHistoryStatusEnumList(i : integer) : TFhirHistoryStatusEnumList; overload;
Function TFhirFlagStatusEnumListAsInteger(aSet : TFhirFlagStatusEnumList) : Integer; overload;
Function IntegerAsTFhirFlagStatusEnumList(i : integer) : TFhirFlagStatusEnumList; overload;
Function TFhirGoalStatusEnumListAsInteger(aSet : TFhirGoalStatusEnumList) : Integer; overload;
Function IntegerAsTFhirGoalStatusEnumList(i : integer) : TFhirGoalStatusEnumList; overload;
Function TFhirGraphCompartmentUseEnumListAsInteger(aSet : TFhirGraphCompartmentUseEnumList) : Integer; overload;
Function IntegerAsTFhirGraphCompartmentUseEnumList(i : integer) : TFhirGraphCompartmentUseEnumList; overload;
Function TFhirGraphCompartmentRuleEnumListAsInteger(aSet : TFhirGraphCompartmentRuleEnumList) : Integer; overload;
Function IntegerAsTFhirGraphCompartmentRuleEnumList(i : integer) : TFhirGraphCompartmentRuleEnumList; overload;
Function TFhirGroupTypeEnumListAsInteger(aSet : TFhirGroupTypeEnumList) : Integer; overload;
Function IntegerAsTFhirGroupTypeEnumList(i : integer) : TFhirGroupTypeEnumList; overload;
Function TFhirGuidanceResponseStatusEnumListAsInteger(aSet : TFhirGuidanceResponseStatusEnumList) : Integer; overload;
Function IntegerAsTFhirGuidanceResponseStatusEnumList(i : integer) : TFhirGuidanceResponseStatusEnumList; overload;
Function TFhirImagingstudyStatusEnumListAsInteger(aSet : TFhirImagingstudyStatusEnumList) : Integer; overload;
Function IntegerAsTFhirImagingstudyStatusEnumList(i : integer) : TFhirImagingstudyStatusEnumList; overload;
Function TFhirImmunizationStatusEnumListAsInteger(aSet : TFhirImmunizationStatusEnumList) : Integer; overload;
Function IntegerAsTFhirImmunizationStatusEnumList(i : integer) : TFhirImmunizationStatusEnumList; overload;
Function TFhirImmunizationEvaluationStatusEnumListAsInteger(aSet : TFhirImmunizationEvaluationStatusEnumList) : Integer; overload;
Function IntegerAsTFhirImmunizationEvaluationStatusEnumList(i : integer) : TFhirImmunizationEvaluationStatusEnumList; overload;
Function TFhirSpdxLicenseEnumListAsInteger(aSet : TFhirSpdxLicenseEnumList) : Integer; overload;
Function IntegerAsTFhirSpdxLicenseEnumList(i : integer) : TFhirSpdxLicenseEnumList; overload;
Function TFhirGuidePageGenerationEnumListAsInteger(aSet : TFhirGuidePageGenerationEnumList) : Integer; overload;
Function IntegerAsTFhirGuidePageGenerationEnumList(i : integer) : TFhirGuidePageGenerationEnumList; overload;
Function TFhirGuideParameterCodeEnumListAsInteger(aSet : TFhirGuideParameterCodeEnumList) : Integer; overload;
Function IntegerAsTFhirGuideParameterCodeEnumList(i : integer) : TFhirGuideParameterCodeEnumList; overload;
Function TFhirInvoiceStatusEnumListAsInteger(aSet : TFhirInvoiceStatusEnumList) : Integer; overload;
Function IntegerAsTFhirInvoiceStatusEnumList(i : integer) : TFhirInvoiceStatusEnumList; overload;
Function TFhirLinkageTypeEnumListAsInteger(aSet : TFhirLinkageTypeEnumList) : Integer; overload;
Function IntegerAsTFhirLinkageTypeEnumList(i : integer) : TFhirLinkageTypeEnumList; overload;
Function TFhirListStatusEnumListAsInteger(aSet : TFhirListStatusEnumList) : Integer; overload;
Function IntegerAsTFhirListStatusEnumList(i : integer) : TFhirListStatusEnumList; overload;
Function TFhirLocationStatusEnumListAsInteger(aSet : TFhirLocationStatusEnumList) : Integer; overload;
Function IntegerAsTFhirLocationStatusEnumList(i : integer) : TFhirLocationStatusEnumList; overload;
Function TFhirLocationModeEnumListAsInteger(aSet : TFhirLocationModeEnumList) : Integer; overload;
Function IntegerAsTFhirLocationModeEnumList(i : integer) : TFhirLocationModeEnumList; overload;
Function TFhirMeasureReportStatusEnumListAsInteger(aSet : TFhirMeasureReportStatusEnumList) : Integer; overload;
Function IntegerAsTFhirMeasureReportStatusEnumList(i : integer) : TFhirMeasureReportStatusEnumList; overload;
Function TFhirMeasureReportTypeEnumListAsInteger(aSet : TFhirMeasureReportTypeEnumList) : Integer; overload;
Function IntegerAsTFhirMeasureReportTypeEnumList(i : integer) : TFhirMeasureReportTypeEnumList; overload;
Function TFhirMedicationStatusEnumListAsInteger(aSet : TFhirMedicationStatusEnumList) : Integer; overload;
Function IntegerAsTFhirMedicationStatusEnumList(i : integer) : TFhirMedicationStatusEnumList; overload;
Function TFhirMedicationrequestStatusEnumListAsInteger(aSet : TFhirMedicationrequestStatusEnumList) : Integer; overload;
Function IntegerAsTFhirMedicationrequestStatusEnumList(i : integer) : TFhirMedicationrequestStatusEnumList; overload;
Function TFhirMedicationrequestIntentEnumListAsInteger(aSet : TFhirMedicationrequestIntentEnumList) : Integer; overload;
Function IntegerAsTFhirMedicationrequestIntentEnumList(i : integer) : TFhirMedicationrequestIntentEnumList; overload;
Function TFhirMedicationStatementStatusEnumListAsInteger(aSet : TFhirMedicationStatementStatusEnumList) : Integer; overload;
Function IntegerAsTFhirMedicationStatementStatusEnumList(i : integer) : TFhirMedicationStatementStatusEnumList; overload;
Function TFhirMessageSignificanceCategoryEnumListAsInteger(aSet : TFhirMessageSignificanceCategoryEnumList) : Integer; overload;
Function IntegerAsTFhirMessageSignificanceCategoryEnumList(i : integer) : TFhirMessageSignificanceCategoryEnumList; overload;
Function TFhirMessageheaderResponseRequestEnumListAsInteger(aSet : TFhirMessageheaderResponseRequestEnumList) : Integer; overload;
Function IntegerAsTFhirMessageheaderResponseRequestEnumList(i : integer) : TFhirMessageheaderResponseRequestEnumList; overload;
Function TFhirResponseCodeEnumListAsInteger(aSet : TFhirResponseCodeEnumList) : Integer; overload;
Function IntegerAsTFhirResponseCodeEnumList(i : integer) : TFhirResponseCodeEnumList; overload;
Function TFhirSequenceTypeEnumListAsInteger(aSet : TFhirSequenceTypeEnumList) : Integer; overload;
Function IntegerAsTFhirSequenceTypeEnumList(i : integer) : TFhirSequenceTypeEnumList; overload;
Function TFhirOrientationTypeEnumListAsInteger(aSet : TFhirOrientationTypeEnumList) : Integer; overload;
Function IntegerAsTFhirOrientationTypeEnumList(i : integer) : TFhirOrientationTypeEnumList; overload;
Function TFhirStrandTypeEnumListAsInteger(aSet : TFhirStrandTypeEnumList) : Integer; overload;
Function IntegerAsTFhirStrandTypeEnumList(i : integer) : TFhirStrandTypeEnumList; overload;
Function TFhirQualityTypeEnumListAsInteger(aSet : TFhirQualityTypeEnumList) : Integer; overload;
Function IntegerAsTFhirQualityTypeEnumList(i : integer) : TFhirQualityTypeEnumList; overload;
Function TFhirRepositoryTypeEnumListAsInteger(aSet : TFhirRepositoryTypeEnumList) : Integer; overload;
Function IntegerAsTFhirRepositoryTypeEnumList(i : integer) : TFhirRepositoryTypeEnumList; overload;
Function TFhirNamingsystemTypeEnumListAsInteger(aSet : TFhirNamingsystemTypeEnumList) : Integer; overload;
Function IntegerAsTFhirNamingsystemTypeEnumList(i : integer) : TFhirNamingsystemTypeEnumList; overload;
Function TFhirNamingsystemIdentifierTypeEnumListAsInteger(aSet : TFhirNamingsystemIdentifierTypeEnumList) : Integer; overload;
Function IntegerAsTFhirNamingsystemIdentifierTypeEnumList(i : integer) : TFhirNamingsystemIdentifierTypeEnumList; overload;
Function TFhirPermittedDataTypeEnumListAsInteger(aSet : TFhirPermittedDataTypeEnumList) : Integer; overload;
Function IntegerAsTFhirPermittedDataTypeEnumList(i : integer) : TFhirPermittedDataTypeEnumList; overload;
Function TFhirObservationRangeCategoryEnumListAsInteger(aSet : TFhirObservationRangeCategoryEnumList) : Integer; overload;
Function IntegerAsTFhirObservationRangeCategoryEnumList(i : integer) : TFhirObservationRangeCategoryEnumList; overload;
Function TFhirAdministrativeGenderEnumListAsInteger(aSet : TFhirAdministrativeGenderEnumList) : Integer; overload;
Function IntegerAsTFhirAdministrativeGenderEnumList(i : integer) : TFhirAdministrativeGenderEnumList; overload;
Function TFhirOperationKindEnumListAsInteger(aSet : TFhirOperationKindEnumList) : Integer; overload;
Function IntegerAsTFhirOperationKindEnumList(i : integer) : TFhirOperationKindEnumList; overload;
Function TFhirIssueSeverityEnumListAsInteger(aSet : TFhirIssueSeverityEnumList) : Integer; overload;
Function IntegerAsTFhirIssueSeverityEnumList(i : integer) : TFhirIssueSeverityEnumList; overload;
Function TFhirIssueTypeEnumListAsInteger(aSet : TFhirIssueTypeEnumList) : Integer; overload;
Function IntegerAsTFhirIssueTypeEnumList(i : integer) : TFhirIssueTypeEnumList; overload;
Function TFhirLinkTypeEnumListAsInteger(aSet : TFhirLinkTypeEnumList) : Integer; overload;
Function IntegerAsTFhirLinkTypeEnumList(i : integer) : TFhirLinkTypeEnumList; overload;
Function TFhirIdentityAssuranceLevelEnumListAsInteger(aSet : TFhirIdentityAssuranceLevelEnumList) : Integer; overload;
Function IntegerAsTFhirIdentityAssuranceLevelEnumList(i : integer) : TFhirIdentityAssuranceLevelEnumList; overload;
Function TFhirActionConditionKindEnumListAsInteger(aSet : TFhirActionConditionKindEnumList) : Integer; overload;
Function IntegerAsTFhirActionConditionKindEnumList(i : integer) : TFhirActionConditionKindEnumList; overload;
Function TFhirActionRelationshipTypeEnumListAsInteger(aSet : TFhirActionRelationshipTypeEnumList) : Integer; overload;
Function IntegerAsTFhirActionRelationshipTypeEnumList(i : integer) : TFhirActionRelationshipTypeEnumList; overload;
Function TFhirActionGroupingBehaviorEnumListAsInteger(aSet : TFhirActionGroupingBehaviorEnumList) : Integer; overload;
Function IntegerAsTFhirActionGroupingBehaviorEnumList(i : integer) : TFhirActionGroupingBehaviorEnumList; overload;
Function TFhirActionSelectionBehaviorEnumListAsInteger(aSet : TFhirActionSelectionBehaviorEnumList) : Integer; overload;
Function IntegerAsTFhirActionSelectionBehaviorEnumList(i : integer) : TFhirActionSelectionBehaviorEnumList; overload;
Function TFhirActionRequiredBehaviorEnumListAsInteger(aSet : TFhirActionRequiredBehaviorEnumList) : Integer; overload;
Function IntegerAsTFhirActionRequiredBehaviorEnumList(i : integer) : TFhirActionRequiredBehaviorEnumList; overload;
Function TFhirActionPrecheckBehaviorEnumListAsInteger(aSet : TFhirActionPrecheckBehaviorEnumList) : Integer; overload;
Function IntegerAsTFhirActionPrecheckBehaviorEnumList(i : integer) : TFhirActionPrecheckBehaviorEnumList; overload;
Function TFhirActionCardinalityBehaviorEnumListAsInteger(aSet : TFhirActionCardinalityBehaviorEnumList) : Integer; overload;
Function IntegerAsTFhirActionCardinalityBehaviorEnumList(i : integer) : TFhirActionCardinalityBehaviorEnumList; overload;
Function TFhirProvenanceEntityRoleEnumListAsInteger(aSet : TFhirProvenanceEntityRoleEnumList) : Integer; overload;
Function IntegerAsTFhirProvenanceEntityRoleEnumList(i : integer) : TFhirProvenanceEntityRoleEnumList; overload;
Function TFhirItemTypeEnumListAsInteger(aSet : TFhirItemTypeEnumList) : Integer; overload;
Function IntegerAsTFhirItemTypeEnumList(i : integer) : TFhirItemTypeEnumList; overload;
Function TFhirQuestionnaireEnableOperatorEnumListAsInteger(aSet : TFhirQuestionnaireEnableOperatorEnumList) : Integer; overload;
Function IntegerAsTFhirQuestionnaireEnableOperatorEnumList(i : integer) : TFhirQuestionnaireEnableOperatorEnumList; overload;
Function TFhirQuestionnaireEnableBehaviorEnumListAsInteger(aSet : TFhirQuestionnaireEnableBehaviorEnumList) : Integer; overload;
Function IntegerAsTFhirQuestionnaireEnableBehaviorEnumList(i : integer) : TFhirQuestionnaireEnableBehaviorEnumList; overload;
Function TFhirQuestionnaireAnswersStatusEnumListAsInteger(aSet : TFhirQuestionnaireAnswersStatusEnumList) : Integer; overload;
Function IntegerAsTFhirQuestionnaireAnswersStatusEnumList(i : integer) : TFhirQuestionnaireAnswersStatusEnumList; overload;
Function TFhirResearchElementTypeEnumListAsInteger(aSet : TFhirResearchElementTypeEnumList) : Integer; overload;
Function IntegerAsTFhirResearchElementTypeEnumList(i : integer) : TFhirResearchElementTypeEnumList; overload;
Function TFhirResearchStudyStatusEnumListAsInteger(aSet : TFhirResearchStudyStatusEnumList) : Integer; overload;
Function IntegerAsTFhirResearchStudyStatusEnumList(i : integer) : TFhirResearchStudyStatusEnumList; overload;
Function TFhirResearchSubjectStatusEnumListAsInteger(aSet : TFhirResearchSubjectStatusEnumList) : Integer; overload;
Function IntegerAsTFhirResearchSubjectStatusEnumList(i : integer) : TFhirResearchSubjectStatusEnumList; overload;
Function TFhirSearchXpathUsageEnumListAsInteger(aSet : TFhirSearchXpathUsageEnumList) : Integer; overload;
Function IntegerAsTFhirSearchXpathUsageEnumList(i : integer) : TFhirSearchXpathUsageEnumList; overload;
Function TFhirSearchComparatorEnumListAsInteger(aSet : TFhirSearchComparatorEnumList) : Integer; overload;
Function IntegerAsTFhirSearchComparatorEnumList(i : integer) : TFhirSearchComparatorEnumList; overload;
Function TFhirSearchModifierCodeEnumListAsInteger(aSet : TFhirSearchModifierCodeEnumList) : Integer; overload;
Function IntegerAsTFhirSearchModifierCodeEnumList(i : integer) : TFhirSearchModifierCodeEnumList; overload;
Function TFhirSlotstatusEnumListAsInteger(aSet : TFhirSlotstatusEnumList) : Integer; overload;
Function IntegerAsTFhirSlotstatusEnumList(i : integer) : TFhirSlotstatusEnumList; overload;
Function TFhirSpecimenStatusEnumListAsInteger(aSet : TFhirSpecimenStatusEnumList) : Integer; overload;
Function IntegerAsTFhirSpecimenStatusEnumList(i : integer) : TFhirSpecimenStatusEnumList; overload;
Function TFhirSpecimenContainedPreferenceEnumListAsInteger(aSet : TFhirSpecimenContainedPreferenceEnumList) : Integer; overload;
Function IntegerAsTFhirSpecimenContainedPreferenceEnumList(i : integer) : TFhirSpecimenContainedPreferenceEnumList; overload;
Function TFhirStructureDefinitionKindEnumListAsInteger(aSet : TFhirStructureDefinitionKindEnumList) : Integer; overload;
Function IntegerAsTFhirStructureDefinitionKindEnumList(i : integer) : TFhirStructureDefinitionKindEnumList; overload;
Function TFhirExtensionContextTypeEnumListAsInteger(aSet : TFhirExtensionContextTypeEnumList) : Integer; overload;
Function IntegerAsTFhirExtensionContextTypeEnumList(i : integer) : TFhirExtensionContextTypeEnumList; overload;
Function TFhirTypeDerivationRuleEnumListAsInteger(aSet : TFhirTypeDerivationRuleEnumList) : Integer; overload;
Function IntegerAsTFhirTypeDerivationRuleEnumList(i : integer) : TFhirTypeDerivationRuleEnumList; overload;
Function TFhirMapModelModeEnumListAsInteger(aSet : TFhirMapModelModeEnumList) : Integer; overload;
Function IntegerAsTFhirMapModelModeEnumList(i : integer) : TFhirMapModelModeEnumList; overload;
Function TFhirMapGroupTypeModeEnumListAsInteger(aSet : TFhirMapGroupTypeModeEnumList) : Integer; overload;
Function IntegerAsTFhirMapGroupTypeModeEnumList(i : integer) : TFhirMapGroupTypeModeEnumList; overload;
Function TFhirMapInputModeEnumListAsInteger(aSet : TFhirMapInputModeEnumList) : Integer; overload;
Function IntegerAsTFhirMapInputModeEnumList(i : integer) : TFhirMapInputModeEnumList; overload;
Function TFhirMapSourceListModeEnumListAsInteger(aSet : TFhirMapSourceListModeEnumList) : Integer; overload;
Function IntegerAsTFhirMapSourceListModeEnumList(i : integer) : TFhirMapSourceListModeEnumList; overload;
Function TFhirMapContextTypeEnumListAsInteger(aSet : TFhirMapContextTypeEnumList) : Integer; overload;
Function IntegerAsTFhirMapContextTypeEnumList(i : integer) : TFhirMapContextTypeEnumList; overload;
Function TFhirMapTargetListModeEnumListAsInteger(aSet : TFhirMapTargetListModeEnumList) : Integer; overload;
Function IntegerAsTFhirMapTargetListModeEnumList(i : integer) : TFhirMapTargetListModeEnumList; overload;
Function TFhirMapTransformEnumListAsInteger(aSet : TFhirMapTransformEnumList) : Integer; overload;
Function IntegerAsTFhirMapTransformEnumList(i : integer) : TFhirMapTransformEnumList; overload;
Function TFhirSubscriptionStatusEnumListAsInteger(aSet : TFhirSubscriptionStatusEnumList) : Integer; overload;
Function IntegerAsTFhirSubscriptionStatusEnumList(i : integer) : TFhirSubscriptionStatusEnumList; overload;
Function TFhirSubscriptionChannelTypeEnumListAsInteger(aSet : TFhirSubscriptionChannelTypeEnumList) : Integer; overload;
Function IntegerAsTFhirSubscriptionChannelTypeEnumList(i : integer) : TFhirSubscriptionChannelTypeEnumList; overload;
Function TFhirSubstanceStatusEnumListAsInteger(aSet : TFhirSubstanceStatusEnumList) : Integer; overload;
Function IntegerAsTFhirSubstanceStatusEnumList(i : integer) : TFhirSubstanceStatusEnumList; overload;
Function TFhirSupplydeliveryStatusEnumListAsInteger(aSet : TFhirSupplydeliveryStatusEnumList) : Integer; overload;
Function IntegerAsTFhirSupplydeliveryStatusEnumList(i : integer) : TFhirSupplydeliveryStatusEnumList; overload;
Function TFhirSupplyrequestStatusEnumListAsInteger(aSet : TFhirSupplyrequestStatusEnumList) : Integer; overload;
Function IntegerAsTFhirSupplyrequestStatusEnumList(i : integer) : TFhirSupplyrequestStatusEnumList; overload;
Function TFhirTaskStatusEnumListAsInteger(aSet : TFhirTaskStatusEnumList) : Integer; overload;
Function IntegerAsTFhirTaskStatusEnumList(i : integer) : TFhirTaskStatusEnumList; overload;
Function TFhirTaskIntentEnumListAsInteger(aSet : TFhirTaskIntentEnumList) : Integer; overload;
Function IntegerAsTFhirTaskIntentEnumList(i : integer) : TFhirTaskIntentEnumList; overload;
Function TFhirCodeSearchSupportEnumListAsInteger(aSet : TFhirCodeSearchSupportEnumList) : Integer; overload;
Function IntegerAsTFhirCodeSearchSupportEnumList(i : integer) : TFhirCodeSearchSupportEnumList; overload;
Function TFhirReportStatusCodesEnumListAsInteger(aSet : TFhirReportStatusCodesEnumList) : Integer; overload;
Function IntegerAsTFhirReportStatusCodesEnumList(i : integer) : TFhirReportStatusCodesEnumList; overload;
Function TFhirReportResultCodesEnumListAsInteger(aSet : TFhirReportResultCodesEnumList) : Integer; overload;
Function IntegerAsTFhirReportResultCodesEnumList(i : integer) : TFhirReportResultCodesEnumList; overload;
Function TFhirReportParticipantTypeEnumListAsInteger(aSet : TFhirReportParticipantTypeEnumList) : Integer; overload;
Function IntegerAsTFhirReportParticipantTypeEnumList(i : integer) : TFhirReportParticipantTypeEnumList; overload;
Function TFhirReportActionResultCodesEnumListAsInteger(aSet : TFhirReportActionResultCodesEnumList) : Integer; overload;
Function IntegerAsTFhirReportActionResultCodesEnumList(i : integer) : TFhirReportActionResultCodesEnumList; overload;
Function TFhirHttpOperationsEnumListAsInteger(aSet : TFhirHttpOperationsEnumList) : Integer; overload;
Function IntegerAsTFhirHttpOperationsEnumList(i : integer) : TFhirHttpOperationsEnumList; overload;
Function TFhirAssertDirectionCodesEnumListAsInteger(aSet : TFhirAssertDirectionCodesEnumList) : Integer; overload;
Function IntegerAsTFhirAssertDirectionCodesEnumList(i : integer) : TFhirAssertDirectionCodesEnumList; overload;
Function TFhirAssertOperatorCodesEnumListAsInteger(aSet : TFhirAssertOperatorCodesEnumList) : Integer; overload;
Function IntegerAsTFhirAssertOperatorCodesEnumList(i : integer) : TFhirAssertOperatorCodesEnumList; overload;
Function TFhirAssertResponseCodeTypesEnumListAsInteger(aSet : TFhirAssertResponseCodeTypesEnumList) : Integer; overload;
Function IntegerAsTFhirAssertResponseCodeTypesEnumList(i : integer) : TFhirAssertResponseCodeTypesEnumList; overload;
Function TFhirVerificationresultStatusEnumListAsInteger(aSet : TFhirVerificationresultStatusEnumList) : Integer; overload;
Function IntegerAsTFhirVerificationresultStatusEnumList(i : integer) : TFhirVerificationresultStatusEnumList; overload;
Function TFhirVisionEyeCodesEnumListAsInteger(aSet : TFhirVisionEyeCodesEnumList) : Integer; overload;
Function IntegerAsTFhirVisionEyeCodesEnumList(i : integer) : TFhirVisionEyeCodesEnumList; overload;
Function TFhirVisionBaseCodesEnumListAsInteger(aSet : TFhirVisionBaseCodesEnumList) : Integer; overload;
Function IntegerAsTFhirVisionBaseCodesEnumList(i : integer) : TFhirVisionBaseCodesEnumList; overload;

function asEnum(systems, values: array of String; obj : TFHIRObject) : TFhirEnum;
function asDate(obj : TFHIRObject) : TFhirDate;
function asDateTime(obj : TFHIRObject) : TFhirDateTime;
function asString(obj : TFHIRObject) : TFhirString;
function asInteger(obj : TFHIRObject) : TFhirInteger;
function asUri(obj : TFHIRObject) : TFhirUri;
function asInstant(obj : TFHIRObject) : TFhirInstant;
function asXhtml(obj : TFHIRObject) : TFhirXhtml;
function asBoolean(obj : TFHIRObject) : TFhirBoolean;
function asBase64Binary(obj : TFHIRObject) : TFhirBase64Binary;
function asTime(obj : TFHIRObject) : TFhirTime;
function asDecimal(obj : TFHIRObject) : TFhirDecimal;
function asCode(obj : TFHIRObject) : TFhirCode;
function asCanonical(obj : TFHIRObject) : TFhirCanonical;
function asOid(obj : TFHIRObject) : TFhirOid;
function asUuid(obj : TFHIRObject) : TFhirUuid;
function asUrl(obj : TFHIRObject) : TFhirUrl;
function asMarkdown(obj : TFHIRObject) : TFhirMarkdown;
function asUnsignedInt(obj : TFHIRObject) : TFhirUnsignedInt;
function asId(obj : TFHIRObject) : TFhirId;
function asPositiveInt(obj : TFHIRObject) : TFhirPositiveInt;

implementation

uses
  fhir4_elementmodel, fhir4_utilities;

{ TFhirElement }

constructor TFhirElement.Create;
begin
  inherited;
end;

destructor TFhirElement.Destroy;
begin
  FId.free;
  FExtensionList.Free;
  inherited;
end;

function TFhirElement.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FId.sizeInBytes);
  inc(result, FextensionList.sizeInBytes);
end;

function TFHIRElement.getId : string;
begin
  result := id;
end;

procedure TFhirElement.setIdValue(id: String);
begin
  SetIdSt(id);
end;

function TFhirElement.noExtensions: TFhirElement;
begin
  DisallowExtensions := true;
  result := self;
end;

procedure TFhirElement.addExtension(url: String; value: TFHIRObject);
var
  ex : TFhirExtension;
begin
  ex := extensionList.Append;
  ex.url := url;
  ex.value := value as TFhirType;
end;

function TFhirElement.extensionCount(url: String): integer;
var
  ex : TFhirExtension;
begin
  result := 0;
  for ex in ExtensionList do
    if (ex.url = url) or (url = '') then
      inc(result);
end;
      
function TFhirElement.extensions(url: String): TFslList<TFHIRObject>;
var
  ex : TFhirExtension;
begin
  result := TFslList<TFHIRObject>.create;
  try
    for ex in ExtensionList do
      if ex.url = url then
        result.Add(ex.Link);
    result.link;
  finally
    result.Free;
  end;
end;

function TFhirElement.hasExtension(url: string): boolean;
var
  ex : TFhirExtension;
begin
  result := false;
  for ex in ExtensionList do
    if ex.url = url then
      exit(true);
end;
      
function TFhirElement.hasExtensions: boolean;
begin
  result := FextensionList.Count > 0;
end;

function TFhirElement.getExtensionString(url: String): String;
var
  ex : TFhirExtension;
begin
  result := '';
  for ex in ExtensionList do
  begin
    if ex.url = url then
    begin
      if not ex.value.isPrimitive then
        raise EFHIRException.create('Complex extension '+url)
      else if result <> '' then
        raise EFHIRException.create('Duplicate extension '+url)
      else
        result := ex.value.primitiveValue;
    end;
  end;
end;

procedure TFhirElement.Assign(oSource : TFslObject);
begin
  inherited;
  idElement := TFhirElement(oSource).idElement.Clone;
  if (TFhirElement(oSource).FExtensionList = nil) then
  begin
    FExtensionList.free;
    FExtensionList := nil;
  end
  else
  begin
    if FExtensionList = nil then
      FExtensionList := TFhirExtensionList.Create;
    FExtensionList.Assign(TFhirElement(oSource).FExtensionList);
  end;
end;

procedure TFhirElement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'id') Then
     list.add(self.link, 'id', FId.Link);
  if (child_name = 'extension') Then
    list.addAll(self, 'extension', FExtensionList);
end;

procedure TFhirElement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'id', 'id', false, TFhirId, FId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'extension', 'Extension', true, TFhirExtension, FExtensionList.Link)){3};
end;

function TFhirElement.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'id') then
  begin
    IdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'extension') then
  begin
    ExtensionList.add(propValue as TFhirExtension){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirElement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'extension') then ExtensionList.insertItem(index, propValue as TFhirExtension){2a}
  else inherited;
end;

function TFhirElement.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'id') then result := TFhirId.create() {5b}
  else if (propName = 'extension') then result := ExtensionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirElement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'id') then result := 'id'
  else if (propName = 'extension') then result := 'Extension'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirElement.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'id') then IdElement := nil
  else if (propName = 'extension') then deletePropertyValue('extension', ExtensionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirElement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'id') then IdElement := asId(new){5b}
  else if (propName = 'extension') then replacePropertyValue('extension', ExtensionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirElement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'extension') then ExtensionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirElement.fhirType : string;
begin
  result := 'Element';
end;

function TFhirElement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FId) and isEmptyProp(FextensionList);
end;

function TFhirElement.equals(other : TObject) : boolean; 
var
  o : TFhirElement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirElement)) then
    result := false
  else
  begin
    o := TFhirElement(other);
    result := compareDeep(idElement, o.idElement, true) and compareDeep(extensionList, o.extensionList, true);
  end;
end;

function TFhirElement.Link : TFhirElement;
begin
  result := TFhirElement(inherited Link);
end;

procedure TFhirElement.listElementFieldsInOrder(fields: TStringList);
begin
  fields.Add('@id');
end;

procedure TFhirElement.listFieldsInOrder(fields: TStringList);
begin
  fields.Add('@id');
end;

function TFhirElement.Clone : TFhirElement;
begin
  result := TFhirElement(inherited Clone);
end;

{ TFhirElement }

Procedure TFhirElement.SetId(value : TFhirId);
begin
  FId.free;
  FId := value;
end;

Function TFhirElement.GetIdST : String;
begin
  if FId = nil then
    result := ''
  else
    result := FId.value;
end;

Procedure TFhirElement.SetIdST(value : String);
begin
  if value <> '' then
  begin
    if FId = nil then
      FId := TFhirId.create;
    FId.value := value
  end
  else if FId <> nil then
    FId.value := '';
end;

Function TFhirElement.GetExtensionList : TFhirExtensionList;
begin
  if FExtensionList = nil then
    FExtensionList := TFhirExtensionList.Create;
  result := FExtensionList;
end;

Function TFhirElement.GetHasExtensionList : boolean;
begin
  result := (FExtensionList <> nil) and (FExtensionList.count > 0);
end;

{ TFhirElementListEnumerator }

Constructor TFhirElementListEnumerator.Create(list : TFhirElementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirElementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirElementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirElementListEnumerator.GetCurrent : TFhirElement;
begin
  Result := FList[FIndex];
end;

function TFhirElementListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirElementList }
procedure TFhirElementList.AddItem(value: TFhirElement);
begin
  assert(value.ClassName = 'TFhirElement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirElement');
  add(value);
end;

function TFhirElementList.Append: TFhirElement;
begin
  result := TFhirElement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirElementList.ClearItems;
begin
  Clear;
end;

function TFhirElementList.GetEnumerator : TFhirElementListEnumerator;
begin
  result := TFhirElementListEnumerator.Create(self.link);
end;

function TFhirElementList.Clone: TFhirElementList;
begin
  result := TFhirElementList(inherited Clone);
end;

function TFhirElementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirElementList.GetItemN(index: Integer): TFhirElement;
begin
  result := TFhirElement(ObjectByIndex[index]);
end;

function TFhirElementList.ItemClass: TFslObjectClass;
begin
  result := TFhirElement;
end;
function TFhirElementList.IndexOf(value: TFhirElement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirElementList.Insert(index: Integer): TFhirElement;
begin
  result := TFhirElement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirElementList.InsertItem(index: Integer; value: TFhirElement);
begin
  assert(value is TFhirElement);
  Inherited Insert(index, value);
end;

function TFhirElementList.Item(index: Integer): TFhirElement;
begin
  result := TFhirElement(ObjectByIndex[index]);
end;

function TFhirElementList.Link: TFhirElementList;
begin
  result := TFhirElementList(inherited Link);
end;

procedure TFhirElementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirElementList.SetItemByIndex(index: Integer; value: TFhirElement);
begin
  assert(value is TFhirElement);
  FhirElements[index] := value;
end;

procedure TFhirElementList.SetItemN(index: Integer; value: TFhirElement);
begin
  assert(value is TFhirElement);
  ObjectByIndex[index] := value;
end;

{ TFhirType }

function TFhirType.Link : TFhirType;
begin
  result := TFhirType(inherited Link);
end;

function TFhirType.ToString : String;
begin
  result := gen(self);
end;

function TFhirType.isType : boolean;
begin
  result := true;
end;

function TFhirType.Clone : TFhirType;
begin
  result := TFhirType(inherited Clone);
end;

{ TFHIRPrimitiveType }

function TFHIRPrimitiveType.Link : TFHIRPrimitiveType;
begin
  result := TFHIRPrimitiveType(inherited Link);
end;

function TFHIRPrimitiveType.Clone : TFHIRPrimitiveType;
begin
  result := TFHIRPrimitiveType(inherited Clone);
end;

function TFHIRPrimitiveType.GetStringValue : string;
begin
  if self = nil then
    result := ''
  else
    result := AsStringValue;
end;

function TFHIRPrimitiveType.isPrimitive: boolean;
begin
  result := true;
end;

function TFHIRPrimitiveType.hasPrimitiveValue: boolean;
begin
  result := StringValue <> '';
end;

function TFHIRPrimitiveType.primitiveValue: string;
begin
  result := StringValue;
end;

function TFHIRPrimitiveType.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'value') then
  begin
    StringValue := propValue.primitiveValue;
    propValue.Free;
    result := self;
  end
  else
    result := inherited setProperty(propName, propValue);
end;

function TFHIRPrimitiveType.toString : String;
begin
  result := StringValue;
end;

{ TFhirBackboneElement }

constructor TFhirBackboneElement.Create;
begin
  inherited;
end;

destructor TFhirBackboneElement.Destroy;
begin
  FModifierExtensionList.Free;
  inherited;
end;

procedure TFhirBackboneElement.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirBackboneElement(oSource).FModifierExtensionList = nil) then
  begin
    FModifierExtensionList.free;
    FModifierExtensionList := nil;
  end
  else
  begin
    if FModifierExtensionList = nil then
      FModifierExtensionList := TFhirExtensionList.Create;
    FModifierExtensionList.Assign(TFhirBackboneElement(oSource).FModifierExtensionList);
  end;
end;

procedure TFhirBackboneElement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'modifierExtension') Then
    list.addAll(self, 'modifierExtension', FModifierExtensionList);
end;

procedure TFhirBackboneElement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'modifierExtension', 'Extension', true, TFhirExtension, FModifierExtensionList.Link)){3};
end;

function TFhirBackboneElement.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'modifierExtension') then
  begin
    ModifierExtensionList.add(propValue as TFhirExtension){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirBackboneElement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifierExtension') then ModifierExtensionList.insertItem(index, propValue as TFhirExtension){2a}
  else inherited;
end;

function TFhirBackboneElement.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'modifierExtension') then result := ModifierExtensionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBackboneElement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'modifierExtension') then result := 'Extension'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBackboneElement.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'modifierExtension') then deletePropertyValue('modifierExtension', ModifierExtensionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBackboneElement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'modifierExtension') then replacePropertyValue('modifierExtension', ModifierExtensionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBackboneElement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifierExtension') then ModifierExtensionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBackboneElement.fhirType : string;
begin
  result := 'BackboneElement';
end;

function TFhirBackboneElement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FmodifierExtensionList);
end;

function TFhirBackboneElement.equals(other : TObject) : boolean; 
var
  o : TFhirBackboneElement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBackboneElement)) then
    result := false
  else
  begin
    o := TFhirBackboneElement(other);
    result := compareDeep(modifierExtensionList, o.modifierExtensionList, true);
  end;
end;

function TFhirBackboneElement.Link : TFhirBackboneElement;
begin
  result := TFhirBackboneElement(inherited Link);
end;

procedure TFhirBackboneElement.listBackboneElementFieldsInOrder(fields: TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('modifierExtension');
end;

procedure TFhirBackboneElement.listFieldsInOrder(fields: TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('modifierExtension');
end;

function TFhirBackboneElement.Clone : TFhirBackboneElement;
begin
  result := TFhirBackboneElement(inherited Clone);
end;

{ TFhirBackboneElement }

Function TFhirBackboneElement.GetModifierExtensionList : TFhirExtensionList;
begin
  if FModifierExtensionList = nil then
    FModifierExtensionList := TFhirExtensionList.Create;
  result := FModifierExtensionList;
end;

Function TFhirBackboneElement.GetHasModifierExtensionList : boolean;
begin
  result := (FModifierExtensionList <> nil) and (FModifierExtensionList.count > 0);
end;

function TFhirBackboneElement.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FmodifierExtensionList.sizeInBytes);
end;

{ TFhirBackboneElementListEnumerator }

Constructor TFhirBackboneElementListEnumerator.Create(list : TFhirBackboneElementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBackboneElementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBackboneElementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBackboneElementListEnumerator.GetCurrent : TFhirBackboneElement;
begin
  Result := FList[FIndex];
end;

function TFhirBackboneElementListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBackboneElementList }
procedure TFhirBackboneElementList.AddItem(value: TFhirBackboneElement);
begin
  assert(value.ClassName = 'TFhirBackboneElement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBackboneElement');
  add(value);
end;

function TFhirBackboneElementList.Append: TFhirBackboneElement;
begin
  result := TFhirBackboneElement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBackboneElementList.ClearItems;
begin
  Clear;
end;

function TFhirBackboneElementList.GetEnumerator : TFhirBackboneElementListEnumerator;
begin
  result := TFhirBackboneElementListEnumerator.Create(self.link);
end;

function TFhirBackboneElementList.Clone: TFhirBackboneElementList;
begin
  result := TFhirBackboneElementList(inherited Clone);
end;

function TFhirBackboneElementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBackboneElementList.GetItemN(index: Integer): TFhirBackboneElement;
begin
  result := TFhirBackboneElement(ObjectByIndex[index]);
end;

function TFhirBackboneElementList.ItemClass: TFslObjectClass;
begin
  result := TFhirBackboneElement;
end;
function TFhirBackboneElementList.IndexOf(value: TFhirBackboneElement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBackboneElementList.Insert(index: Integer): TFhirBackboneElement;
begin
  result := TFhirBackboneElement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBackboneElementList.InsertItem(index: Integer; value: TFhirBackboneElement);
begin
  assert(value is TFhirBackboneElement);
  Inherited Insert(index, value);
end;

function TFhirBackboneElementList.Item(index: Integer): TFhirBackboneElement;
begin
  result := TFhirBackboneElement(ObjectByIndex[index]);
end;

function TFhirBackboneElementList.Link: TFhirBackboneElementList;
begin
  result := TFhirBackboneElementList(inherited Link);
end;

procedure TFhirBackboneElementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBackboneElementList.SetItemByIndex(index: Integer; value: TFhirBackboneElement);
begin
  assert(value is TFhirBackboneElement);
  FhirBackboneElements[index] := value;
end;

procedure TFhirBackboneElementList.SetItemN(index: Integer; value: TFhirBackboneElement);
begin
  assert(value is TFhirBackboneElement);
  ObjectByIndex[index] := value;
end;

{ TFhirBackboneType }

constructor TFhirBackboneType.Create;
begin
  inherited;
end;

destructor TFhirBackboneType.Destroy;
begin
  FModifierExtensionList.Free;
  inherited;
end;

procedure TFhirBackboneType.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirBackboneType(oSource).FModifierExtensionList = nil) then
  begin
    FModifierExtensionList.free;
    FModifierExtensionList := nil;
  end
  else
  begin
    if FModifierExtensionList = nil then
      FModifierExtensionList := TFhirExtensionList.Create;
    FModifierExtensionList.Assign(TFhirBackboneType(oSource).FModifierExtensionList);
  end;
end;

procedure TFhirBackboneType.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'modifierExtension') Then
    list.addAll(self, 'modifierExtension', FModifierExtensionList);
end;

procedure TFhirBackboneType.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'modifierExtension', 'Extension', true, TFhirExtension, FModifierExtensionList.Link)){3};
end;

function TFhirBackboneType.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'modifierExtension') then
  begin
    ModifierExtensionList.add(propValue as TFhirExtension){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirBackboneType.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifierExtension') then ModifierExtensionList.insertItem(index, propValue as TFhirExtension){2a}
  else inherited;
end;

function TFhirBackboneType.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'modifierExtension') then result := ModifierExtensionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBackboneType.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'modifierExtension') then result := 'Extension'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBackboneType.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'modifierExtension') then deletePropertyValue('modifierExtension', ModifierExtensionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBackboneType.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'modifierExtension') then replacePropertyValue('modifierExtension', ModifierExtensionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBackboneType.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifierExtension') then ModifierExtensionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBackboneType.fhirType : string;
begin
  result := 'BackboneType';
end;

function TFhirBackboneType.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FmodifierExtensionList);
end;

function TFhirBackboneType.equals(other : TObject) : boolean; 
var
  o : TFhirBackboneType;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBackboneType)) then
    result := false
  else
  begin
    o := TFhirBackboneType(other);
    result := compareDeep(modifierExtensionList, o.modifierExtensionList, true);
  end;
end;

function TFhirBackboneType.Link : TFhirBackboneType;
begin
  result := TFhirBackboneType(inherited Link);
end;

function TFhirBackboneType.Clone : TFhirBackboneType;
begin
  result := TFhirBackboneType(inherited Clone);
end;

procedure TFhirBackboneType.listBackboneTypeFieldsInOrder(fields: TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('modifierExtension');
end;

procedure TFhirBackboneType.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('modifierExtension');
end;

{ TFhirBackboneType }

Function TFhirBackboneType.GetModifierExtensionList : TFhirExtensionList;
begin
  if FModifierExtensionList = nil then
    FModifierExtensionList := TFhirExtensionList.Create;
  result := FModifierExtensionList;
end;

Function TFhirBackboneType.GetHasModifierExtensionList : boolean;
begin
  result := (FModifierExtensionList <> nil) and (FModifierExtensionList.count > 0);
end;

function TFhirBackboneType.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FmodifierExtensionList.sizeInBytes);
end;

{ TFhirBackboneTypeListEnumerator }

Constructor TFhirBackboneTypeListEnumerator.Create(list : TFhirBackboneTypeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBackboneTypeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBackboneTypeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBackboneTypeListEnumerator.GetCurrent : TFhirBackboneType;
begin
  Result := FList[FIndex];
end;

function TFhirBackboneTypeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBackboneTypeList }
procedure TFhirBackboneTypeList.AddItem(value: TFhirBackboneType);
begin
  assert(value.ClassName = 'TFhirBackboneType', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBackboneType');
  add(value);
end;

function TFhirBackboneTypeList.Append: TFhirBackboneType;
begin
  result := TFhirBackboneType.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBackboneTypeList.ClearItems;
begin
  Clear;
end;

function TFhirBackboneTypeList.GetEnumerator : TFhirBackboneTypeListEnumerator;
begin
  result := TFhirBackboneTypeListEnumerator.Create(self.link);
end;

function TFhirBackboneTypeList.Clone: TFhirBackboneTypeList;
begin
  result := TFhirBackboneTypeList(inherited Clone);
end;

function TFhirBackboneTypeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBackboneTypeList.GetItemN(index: Integer): TFhirBackboneType;
begin
  result := TFhirBackboneType(ObjectByIndex[index]);
end;

function TFhirBackboneTypeList.ItemClass: TFslObjectClass;
begin
  result := TFhirBackboneType;
end;
function TFhirBackboneTypeList.IndexOf(value: TFhirBackboneType): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBackboneTypeList.Insert(index: Integer): TFhirBackboneType;
begin
  result := TFhirBackboneType.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBackboneTypeList.InsertItem(index: Integer; value: TFhirBackboneType);
begin
  assert(value is TFhirBackboneType);
  Inherited Insert(index, value);
end;

function TFhirBackboneTypeList.Item(index: Integer): TFhirBackboneType;
begin
  result := TFhirBackboneType(ObjectByIndex[index]);
end;

function TFhirBackboneTypeList.Link: TFhirBackboneTypeList;
begin
  result := TFhirBackboneTypeList(inherited Link);
end;

procedure TFhirBackboneTypeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBackboneTypeList.SetItemByIndex(index: Integer; value: TFhirBackboneType);
begin
  assert(value is TFhirBackboneType);
  FhirBackboneTypes[index] := value;
end;

procedure TFhirBackboneTypeList.SetItemN(index: Integer; value: TFhirBackboneType);
begin
  assert(value is TFhirBackboneType);
  ObjectByIndex[index] := value;
end;

{ TFhirEnum }

Constructor TFhirEnum.Create(system : String; value : String);
begin
  Create;
  FSystem := system;
  FValue := value;
end;

destructor TFhirEnum.Destroy;
begin
  inherited;
end;

function TFhirEnum.fhirType : string;
begin
  result := 'code';
end;

function TFhirEnum.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, (FValue.length * sizeof(char)) + 12);
  inc(result, (FSystem.length * sizeof(char)) + 12);
end;

function TFHIREnum.isEnum : boolean;
begin
  result := true;
end;

procedure TFhirEnum.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if child_name = 'value' then
    list.add(self.link, 'value', TFHIRObjectText.create(value));
end;

procedure TFhirEnum.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  if (bPrimitiveValues) then
    oList.add(TFHIRProperty.create(self, 'value', 'enum', false, nil, FValue));
end;

procedure TFhirEnum.Assign(oSource : TFslObject);
begin
  inherited;
  FValue := TFhirEnum(oSource).Value;
end;

function TFhirEnum.AsStringValue : string;
begin
  result := FValue;
end;

procedure TFhirEnum.SetStringValue(value : string);
begin
  FValue := value;
end;

function TFhirEnum.equals(other : TObject) : boolean; 
var
  o : TFhirEnum;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEnum)) then
    result := false
  else
  begin
    o := TFhirEnum(other);
    result := o.value = value;
  end;
end;

function TFhirEnum.isEmpty : boolean;
begin
  result := inherited isEmpty and (FValue = '');
end;

function TFhirEnum.Link : TFhirEnum;
begin
  result := TFhirEnum(inherited Link);
end;

function TFhirEnum.Clone : TFhirEnum;
begin
  result := TFhirEnum(inherited Clone);
end;

procedure TFhirEnum.setValue(value : String);
begin
  FValue := value;
end;

procedure TFhirEnum.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

{ TFhirEnumListEnumerator }

Constructor TFhirEnumListEnumerator.Create(list : TFhirEnumList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEnumListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEnumListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEnumListEnumerator.GetCurrent : TFhirEnum;
begin
  Result := FList[FIndex];
end;

function TFhirEnumListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirEnumList }
procedure TFhirEnumList.AddItem(value: TFhirEnum);
begin
  assert(value.ClassName = 'TFhirEnum', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEnum');
  add(value);
end;

constructor TFhirEnumList.Create(Systems, Codes : Array Of String);
var
  i : integer;
begin
  inherited create;
  SetLength(FSystems, length(systems));
  SetLength(FCodes, length(codes));
  for i := 0 to length(systems) - 1 do
  begin
    FSystems[i] := systems[i];
    FCodes[i] := codes[i];
  end;
end;

procedure TFhirEnumList.AddItem(value: String);
begin
  add(TFhirEnum.create(FSystems[StringArrayIndexOf(FCodes, value)], value));
end;

function TFhirEnumList.Append: TFhirEnum;
begin
  result := TFhirEnum.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnumList.ClearItems;
begin
  Clear;
end;

function TFhirEnumList.GetEnumerator : TFhirEnumListEnumerator;
begin
  result := TFhirEnumListEnumerator.Create(self.link);
end;

function TFhirEnumList.Clone: TFhirEnumList;
begin
  result := TFhirEnumList(inherited Clone);
end;

function TFhirEnumList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEnumList.GetItemN(index: Integer): TFhirEnum;
begin
  result := TFhirEnum(ObjectByIndex[index]);
end;

function TFhirEnumList.ItemClass: TFslObjectClass;
begin
  result := TFhirEnum;
end;
function TFhirEnumList.IndexOf(value: TFhirEnum): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEnumList.Insert(index: Integer): TFhirEnum;
begin
  result := TFhirEnum.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEnumList.InsertItem(index: Integer; value: TFhirEnum);
begin
  assert(value is TFhirEnum);
  Inherited Insert(index, value);
end;

function TFhirEnumList.Item(index: Integer): TFhirEnum;
begin
  result := TFhirEnum(ObjectByIndex[index]);
end;

function TFhirEnumList.Link: TFhirEnumList;
begin
  result := TFhirEnumList(inherited Link);
end;

procedure TFhirEnumList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEnumList.SetItemByIndex(index: Integer; value: TFhirEnum);
begin
  assert(value is TFhirEnum);
  FhirEnums[index] := value;
end;

procedure TFhirEnumList.SetItemN(index: Integer; value: TFhirEnum);
begin
  assert(value is TFhirEnum);
  ObjectByIndex[index] := value;
end;


{ TFhirDate }

Constructor TFhirDate.Create(value : TFslDateTime);
begin
  Create;
  FValue := value;
end;

destructor TFhirDate.Destroy;
begin
  inherited;
end;

function TFhirDate.fhirType : string;
begin
  result := 'date';
end;

function TFhirDate.getdateValue : TFslDateTime;
begin
  result := FValue;
end;

procedure TFhirDate.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if child_name = 'value' then
    list.add(self.link, 'value', TFHIRObjectText.create(value));
end;

procedure TFhirDate.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  if (bPrimitiveValues) then
    if (FValue.notNull) then
      oList.add(TFHIRProperty.create(self, 'value', 'date', false, nil, FValue.ToString));
end;

procedure TFhirDate.setDateValue(value: TFslDateTime);
begin
  FValue := value;
end;

procedure TFhirDate.Assign(oSource : TFslObject);
begin
  inherited;
  FValue := TFhirDate(oSource).Value;
end;

function TFhirDate.AsStringValue : string;
begin
  if (FValue.null) then
    result := ''
  else
    result := FValue.toXml;
end;

procedure TFhirDate.SetStringValue(value : string);
begin
  if (value = '') then
    FValue := TFslDateTime.makeNull
  else
    FValue := TFslDateTime.fromXml(value);
end;

function TFhirDate.equals(other : TObject) : boolean; 
var
  o : TFhirDate;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDate)) then
    result := false
  else
  begin
    o := TFhirDate(other);
    result := o.value.equal(value);
  end;
end;

function TFhirDate.isDateTime: boolean;
begin
  result := true;
end;

function TFhirDate.isEmpty : boolean;
begin
  result := inherited isEmpty and (FValue.null);
end;

function TFhirDate.Link : TFhirDate;
begin
  result := TFhirDate(inherited Link);
end;

function TFhirDate.Clone : TFhirDate;
begin
  result := TFhirDate(inherited Clone);
end;

procedure TFhirDate.setValue(value : TFslDateTime);
begin
  FValue := value;
end;

procedure TFhirDate.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

function TFhirDate.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
end;

{ TFhirDateListEnumerator }

Constructor TFhirDateListEnumerator.Create(list : TFhirDateList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDateListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDateListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDateListEnumerator.GetCurrent : TFhirDate;
begin
  Result := FList[FIndex];
end;

function TFhirDateListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDateList }
procedure TFhirDateList.AddItem(value: TFhirDate);
begin
  assert(value.ClassName = 'TFhirDate', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDate');
  add(value);
end;

procedure TFhirDateList.AddItem(value: TFslDateTime);
begin
  add(TFhirDate.create(value));
end;

function TFhirDateList.Append: TFhirDate;
begin
  result := TFhirDate.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDateList.ClearItems;
begin
  Clear;
end;

function TFhirDateList.GetEnumerator : TFhirDateListEnumerator;
begin
  result := TFhirDateListEnumerator.Create(self.link);
end;

function TFhirDateList.Clone: TFhirDateList;
begin
  result := TFhirDateList(inherited Clone);
end;

function TFhirDateList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDateList.GetItemN(index: Integer): TFhirDate;
begin
  result := TFhirDate(ObjectByIndex[index]);
end;

function TFhirDateList.ItemClass: TFslObjectClass;
begin
  result := TFhirDate;
end;
function TFhirDateList.IndexOf(value: TFhirDate): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDateList.Insert(index: Integer): TFhirDate;
begin
  result := TFhirDate.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDateList.InsertItem(index: Integer; value: TFhirDate);
begin
  assert(value is TFhirDate);
  Inherited Insert(index, value);
end;

function TFhirDateList.Item(index: Integer): TFhirDate;
begin
  result := TFhirDate(ObjectByIndex[index]);
end;

function TFhirDateList.Link: TFhirDateList;
begin
  result := TFhirDateList(inherited Link);
end;

procedure TFhirDateList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDateList.SetItemByIndex(index: Integer; value: TFhirDate);
begin
  assert(value is TFhirDate);
  FhirDates[index] := value;
end;

procedure TFhirDateList.SetItemN(index: Integer; value: TFhirDate);
begin
  assert(value is TFhirDate);
  ObjectByIndex[index] := value;
end;

{ TFhirDateTime }

Constructor TFhirDateTime.Create(value : TFslDateTime);
begin
  Create;
  FValue := value;
end;

destructor TFhirDateTime.Destroy;
begin
  inherited;
end;

function TFhirDateTime.fhirType : string;
begin
  result := 'dateTime';
end;

function TFhirDateTime.getdateValue : TFslDateTime;
begin
  result := FValue;
end;

procedure TFhirDateTime.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if child_name = 'value' then
    list.add(self.link, 'value', TFHIRObjectText.create(value));
end;

procedure TFhirDateTime.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  if (bPrimitiveValues) then
    if (FValue.notNull) then
      oList.add(TFHIRProperty.create(self, 'value', 'dateTime', false, nil, FValue.ToString));
end;

procedure TFhirDateTime.setDateValue(value: TFslDateTime);
begin
  FValue := value;
end;

procedure TFhirDateTime.Assign(oSource : TFslObject);
begin
  inherited;
  FValue := TFhirDateTime(oSource).Value;
end;

function TFhirDateTime.AsStringValue : string;
begin
  if (FValue.null) then
    result := ''
  else
    result := FValue.toXml;
end;

procedure TFhirDateTime.SetStringValue(value : string);
begin
  if (value = '') then
    FValue := TFslDateTime.makeNull
  else
    FValue := TFslDateTime.fromXml(value);
end;

function TFhirDateTime.equals(other : TObject) : boolean; 
var
  o : TFhirDateTime;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDateTime)) then
    result := false
  else
  begin
    o := TFhirDateTime(other);
    result := o.value.equal(value);
  end;
end;

function TFhirDateTime.isDateTime: boolean;
begin
  result := true;
end;

function TFhirDateTime.isEmpty : boolean;
begin
  result := inherited isEmpty and (FValue.null);
end;

function TFhirDateTime.Link : TFhirDateTime;
begin
  result := TFhirDateTime(inherited Link);
end;

function TFhirDateTime.Clone : TFhirDateTime;
begin
  result := TFhirDateTime(inherited Clone);
end;

procedure TFhirDateTime.setValue(value : TFslDateTime);
begin
  FValue := value;
end;

procedure TFhirDateTime.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

function TFhirDateTime.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
end;

{ TFhirDateTimeListEnumerator }

Constructor TFhirDateTimeListEnumerator.Create(list : TFhirDateTimeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDateTimeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDateTimeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDateTimeListEnumerator.GetCurrent : TFhirDateTime;
begin
  Result := FList[FIndex];
end;

function TFhirDateTimeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDateTimeList }
procedure TFhirDateTimeList.AddItem(value: TFhirDateTime);
begin
  assert(value.ClassName = 'TFhirDateTime', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDateTime');
  add(value);
end;

procedure TFhirDateTimeList.AddItem(value: TFslDateTime);
begin
  add(TFhirDateTime.create(value));
end;

function TFhirDateTimeList.Append: TFhirDateTime;
begin
  result := TFhirDateTime.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDateTimeList.ClearItems;
begin
  Clear;
end;

function TFhirDateTimeList.GetEnumerator : TFhirDateTimeListEnumerator;
begin
  result := TFhirDateTimeListEnumerator.Create(self.link);
end;

function TFhirDateTimeList.Clone: TFhirDateTimeList;
begin
  result := TFhirDateTimeList(inherited Clone);
end;

function TFhirDateTimeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDateTimeList.GetItemN(index: Integer): TFhirDateTime;
begin
  result := TFhirDateTime(ObjectByIndex[index]);
end;

function TFhirDateTimeList.ItemClass: TFslObjectClass;
begin
  result := TFhirDateTime;
end;
function TFhirDateTimeList.IndexOf(value: TFhirDateTime): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDateTimeList.Insert(index: Integer): TFhirDateTime;
begin
  result := TFhirDateTime.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDateTimeList.InsertItem(index: Integer; value: TFhirDateTime);
begin
  assert(value is TFhirDateTime);
  Inherited Insert(index, value);
end;

function TFhirDateTimeList.Item(index: Integer): TFhirDateTime;
begin
  result := TFhirDateTime(ObjectByIndex[index]);
end;

function TFhirDateTimeList.Link: TFhirDateTimeList;
begin
  result := TFhirDateTimeList(inherited Link);
end;

procedure TFhirDateTimeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDateTimeList.SetItemByIndex(index: Integer; value: TFhirDateTime);
begin
  assert(value is TFhirDateTime);
  FhirDateTimes[index] := value;
end;

procedure TFhirDateTimeList.SetItemN(index: Integer; value: TFhirDateTime);
begin
  assert(value is TFhirDateTime);
  ObjectByIndex[index] := value;
end;

{ TFhirString }

Constructor TFhirString.Create(value : String);
begin
  Create;
  FValue := value;
end;

destructor TFhirString.Destroy;
begin
  inherited;
end;

function TFhirString.fhirType : string;
begin
  result := 'string';
end;

procedure TFhirString.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if child_name = 'value' then
    list.add(self.link, 'value', TFHIRObjectText.create(value));
end;

procedure TFhirString.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  if (bPrimitiveValues) then
    oList.add(TFHIRProperty.create(self, 'value', 'string', false, nil, FValue));
end;

procedure TFhirString.Assign(oSource : TFslObject);
begin
  inherited;
  FValue := TFhirString(oSource).Value;
end;

function TFhirString.AsStringValue : string;
begin
  result := FValue;
end;

procedure TFhirString.SetStringValue(value : string);
begin
  FValue := value;
end;

function TFhirString.equals(other : TObject) : boolean; 
var
  o : TFhirString;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirString)) then
    result := false
  else
  begin
    o := TFhirString(other);
    result := o.value = value;
  end;
end;

function TFhirString.isEmpty : boolean;
begin
  result := inherited isEmpty and (FValue = '');
end;

function TFhirString.Link : TFhirString;
begin
  result := TFhirString(inherited Link);
end;

function TFhirString.Clone : TFhirString;
begin
  result := TFhirString(inherited Clone);
end;

procedure TFhirString.setValue(value : String);
begin
  FValue := value;
end;

procedure TFhirString.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

function TFhirString.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, (FValue.length * sizeof(char)) + 12);
end;

{ TFhirStringListEnumerator }

Constructor TFhirStringListEnumerator.Create(list : TFhirStringList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStringListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStringListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStringListEnumerator.GetCurrent : TFhirString;
begin
  Result := FList[FIndex];
end;

function TFhirStringListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirStringList }
procedure TFhirStringList.AddItem(value: TFhirString);
begin
  assert(value.ClassName = 'TFhirString', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirString');
  add(value);
end;

procedure TFhirStringList.AddItem(value: String);
begin
  add(TFhirString.create(value));
end;

function TFhirStringList.Append: TFhirString;
begin
  result := TFhirString.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStringList.ClearItems;
begin
  Clear;
end;

function TFhirStringList.GetEnumerator : TFhirStringListEnumerator;
begin
  result := TFhirStringListEnumerator.Create(self.link);
end;

function TFhirStringList.Clone: TFhirStringList;
begin
  result := TFhirStringList(inherited Clone);
end;

function TFhirStringList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStringList.GetItemN(index: Integer): TFhirString;
begin
  result := TFhirString(ObjectByIndex[index]);
end;

function TFhirStringList.ItemClass: TFslObjectClass;
begin
  result := TFhirString;
end;
function TFhirStringList.IndexOf(value: TFhirString): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStringList.Insert(index: Integer): TFhirString;
begin
  result := TFhirString.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStringList.InsertItem(index: Integer; value: TFhirString);
begin
  assert(value is TFhirString);
  Inherited Insert(index, value);
end;

function TFhirStringList.Item(index: Integer): TFhirString;
begin
  result := TFhirString(ObjectByIndex[index]);
end;

function TFhirStringList.Link: TFhirStringList;
begin
  result := TFhirStringList(inherited Link);
end;

procedure TFhirStringList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStringList.SetItemByIndex(index: Integer; value: TFhirString);
begin
  assert(value is TFhirString);
  FhirStrings[index] := value;
end;

procedure TFhirStringList.SetItemN(index: Integer; value: TFhirString);
begin
  assert(value is TFhirString);
  ObjectByIndex[index] := value;
end;

{ TFhirInteger }

Constructor TFhirInteger.Create(value : String);
begin
  Create;
  FValue := value;
end;

destructor TFhirInteger.Destroy;
begin
  inherited;
end;

function TFhirInteger.fhirType : string;
begin
  result := 'integer';
end;

procedure TFhirInteger.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if child_name = 'value' then
    list.add(self.link, 'value', TFHIRObjectText.create(value));
end;

procedure TFhirInteger.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  if (bPrimitiveValues) then
    oList.add(TFHIRProperty.create(self, 'value', 'integer', false, nil, FValue));
end;

procedure TFhirInteger.Assign(oSource : TFslObject);
begin
  inherited;
  FValue := TFhirInteger(oSource).Value;
end;

function TFhirInteger.AsStringValue : string;
begin
  result := FValue;
end;

procedure TFhirInteger.SetStringValue(value : string);
begin
  FValue := value;
end;

function TFhirInteger.equals(other : TObject) : boolean; 
var
  o : TFhirInteger;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInteger)) then
    result := false
  else
  begin
    o := TFhirInteger(other);
    result := o.value = value;
  end;
end;

function TFhirInteger.isEmpty : boolean;
begin
  result := inherited isEmpty and (FValue = '');
end;

function TFhirInteger.Link : TFhirInteger;
begin
  result := TFhirInteger(inherited Link);
end;

function TFhirInteger.Clone : TFhirInteger;
begin
  result := TFhirInteger(inherited Clone);
end;

constructor TFhirInteger.Create(value: Integer);
begin
  Create;
  FValue := inttostr(value);
end;

procedure TFhirInteger.setValue(value : String);
begin
  FValue := value;
end;

procedure TFhirInteger.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

function TFhirInteger.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, (FValue.length * sizeof(char)) + 12);
end;

{ TFhirIntegerListEnumerator }

Constructor TFhirIntegerListEnumerator.Create(list : TFhirIntegerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirIntegerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirIntegerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirIntegerListEnumerator.GetCurrent : TFhirInteger;
begin
  Result := FList[FIndex];
end;

function TFhirIntegerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirIntegerList }
procedure TFhirIntegerList.AddItem(value: TFhirInteger);
begin
  assert(value.ClassName = 'TFhirInteger', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInteger');
  add(value);
end;

procedure TFhirIntegerList.AddItem(value: String);
begin
  add(TFhirInteger.create(value));
end;

function TFhirIntegerList.Append: TFhirInteger;
begin
  result := TFhirInteger.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIntegerList.ClearItems;
begin
  Clear;
end;

function TFhirIntegerList.GetEnumerator : TFhirIntegerListEnumerator;
begin
  result := TFhirIntegerListEnumerator.Create(self.link);
end;

function TFhirIntegerList.Clone: TFhirIntegerList;
begin
  result := TFhirIntegerList(inherited Clone);
end;

function TFhirIntegerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirIntegerList.GetItemN(index: Integer): TFhirInteger;
begin
  result := TFhirInteger(ObjectByIndex[index]);
end;

function TFhirIntegerList.ItemClass: TFslObjectClass;
begin
  result := TFhirInteger;
end;
function TFhirIntegerList.IndexOf(value: TFhirInteger): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirIntegerList.Insert(index: Integer): TFhirInteger;
begin
  result := TFhirInteger.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIntegerList.InsertItem(index: Integer; value: TFhirInteger);
begin
  assert(value is TFhirInteger);
  Inherited Insert(index, value);
end;

function TFhirIntegerList.Item(index: Integer): TFhirInteger;
begin
  result := TFhirInteger(ObjectByIndex[index]);
end;

function TFhirIntegerList.Link: TFhirIntegerList;
begin
  result := TFhirIntegerList(inherited Link);
end;

procedure TFhirIntegerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirIntegerList.SetItemByIndex(index: Integer; value: TFhirInteger);
begin
  assert(value is TFhirInteger);
  FhirIntegers[index] := value;
end;

procedure TFhirIntegerList.SetItemN(index: Integer; value: TFhirInteger);
begin
  assert(value is TFhirInteger);
  ObjectByIndex[index] := value;
end;

{ TFhirUri }

Constructor TFhirUri.Create(value : String);
begin
  Create;
  FValue := value;
end;

destructor TFhirUri.Destroy;
begin
  inherited;
end;

function TFhirUri.fhirType : string;
begin
  result := 'uri';
end;

procedure TFhirUri.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if child_name = 'value' then
    list.add(self.link, 'value', TFHIRObjectText.create(value));
end;

procedure TFhirUri.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  if (bPrimitiveValues) then
    oList.add(TFHIRProperty.create(self, 'value', 'uri', false, nil, FValue));
end;

procedure TFhirUri.Assign(oSource : TFslObject);
begin
  inherited;
  FValue := TFhirUri(oSource).Value;
end;

function TFhirUri.AsStringValue : string;
begin
  result := FValue;
end;

procedure TFhirUri.SetStringValue(value : string);
begin
  FValue := value;
end;

function TFhirUri.equals(other : TObject) : boolean; 
var
  o : TFhirUri;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirUri)) then
    result := false
  else
  begin
    o := TFhirUri(other);
    result := o.value = value;
  end;
end;

function TFhirUri.isEmpty : boolean;
begin
  result := inherited isEmpty and (FValue = '');
end;

function TFhirUri.Link : TFhirUri;
begin
  result := TFhirUri(inherited Link);
end;

function TFhirUri.Clone : TFhirUri;
begin
  result := TFhirUri(inherited Clone);
end;

procedure TFhirUri.setValue(value : String);
begin
  FValue := value;
end;

procedure TFhirUri.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

function TFhirUri.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, (FValue.length * sizeof(char)) + 12);
end;

{ TFhirUriListEnumerator }

Constructor TFhirUriListEnumerator.Create(list : TFhirUriList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirUriListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirUriListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirUriListEnumerator.GetCurrent : TFhirUri;
begin
  Result := FList[FIndex];
end;

function TFhirUriListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirUriList }
procedure TFhirUriList.AddItem(value: TFhirUri);
begin
  assert(value.ClassName = 'TFhirUri', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirUri');
  add(value);
end;

procedure TFhirUriList.AddItem(value: String);
begin
  add(TFhirUri.create(value));
end;

function TFhirUriList.Append: TFhirUri;
begin
  result := TFhirUri.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirUriList.ClearItems;
begin
  Clear;
end;

function TFhirUriList.GetEnumerator : TFhirUriListEnumerator;
begin
  result := TFhirUriListEnumerator.Create(self.link);
end;

function TFhirUriList.Clone: TFhirUriList;
begin
  result := TFhirUriList(inherited Clone);
end;

function TFhirUriList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirUriList.GetItemN(index: Integer): TFhirUri;
begin
  result := TFhirUri(ObjectByIndex[index]);
end;

function TFhirUriList.ItemClass: TFslObjectClass;
begin
  result := TFhirUri;
end;
function TFhirUriList.IndexOf(value: TFhirUri): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirUriList.Insert(index: Integer): TFhirUri;
begin
  result := TFhirUri.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirUriList.InsertItem(index: Integer; value: TFhirUri);
begin
  assert(value is TFhirUri);
  Inherited Insert(index, value);
end;

function TFhirUriList.Item(index: Integer): TFhirUri;
begin
  result := TFhirUri(ObjectByIndex[index]);
end;

function TFhirUriList.Link: TFhirUriList;
begin
  result := TFhirUriList(inherited Link);
end;

procedure TFhirUriList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirUriList.SetItemByIndex(index: Integer; value: TFhirUri);
begin
  assert(value is TFhirUri);
  FhirUris[index] := value;
end;

procedure TFhirUriList.SetItemN(index: Integer; value: TFhirUri);
begin
  assert(value is TFhirUri);
  ObjectByIndex[index] := value;
end;

{ TFhirInstant }

Constructor TFhirInstant.Create(value : TFslDateTime);
begin
  Create;
  FValue := value;
end;

destructor TFhirInstant.Destroy;
begin
  inherited;
end;

function TFhirInstant.fhirType : string;
begin
  result := 'instant';
end;

function TFhirInstant.getdateValue : TFslDateTime;
begin
  result := FValue;
end;

procedure TFhirInstant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if child_name = 'value' then
    list.add(self.link, 'value', TFHIRObjectText.create(value));
end;

procedure TFhirInstant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  if (bPrimitiveValues) then
    if (FValue.notNull) then
      oList.add(TFHIRProperty.create(self, 'value', 'instant', false, nil, FValue.ToString));
end;

procedure TFhirInstant.setDateValue(value: TFslDateTime);
begin
  FValue := value;
end;

procedure TFhirInstant.Assign(oSource : TFslObject);
begin
  inherited;
  FValue := TFhirInstant(oSource).Value;
end;

function TFhirInstant.AsStringValue : string;
begin
  if (FValue.null) then
    result := ''
  else
    result := FValue.toXml;
end;

procedure TFhirInstant.SetStringValue(value : string);
begin
  if (value = '') then
    FValue := TFslDateTime.makeNull
  else
    FValue := TFslDateTime.fromXml(value);
end;

function TFhirInstant.equals(other : TObject) : boolean; 
var
  o : TFhirInstant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirInstant)) then
    result := false
  else
  begin
    o := TFhirInstant(other);
    result := o.value.equal(value);
  end;
end;

function TFhirInstant.isDateTime: boolean;
begin
  result := true;
end;

function TFhirInstant.isEmpty : boolean;
begin
  result := inherited isEmpty and (FValue.null);
end;

function TFhirInstant.Link : TFhirInstant;
begin
  result := TFhirInstant(inherited Link);
end;

function TFhirInstant.Clone : TFhirInstant;
begin
  result := TFhirInstant(inherited Clone);
end;

procedure TFhirInstant.setValue(value : TFslDateTime);
begin
  FValue := value;
end;

procedure TFhirInstant.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

function TFhirInstant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
end;

{ TFhirInstantListEnumerator }

Constructor TFhirInstantListEnumerator.Create(list : TFhirInstantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirInstantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirInstantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirInstantListEnumerator.GetCurrent : TFhirInstant;
begin
  Result := FList[FIndex];
end;

function TFhirInstantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirInstantList }
procedure TFhirInstantList.AddItem(value: TFhirInstant);
begin
  assert(value.ClassName = 'TFhirInstant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirInstant');
  add(value);
end;

procedure TFhirInstantList.AddItem(value: TFslDateTime);
begin
  add(TFhirInstant.create(value));
end;

function TFhirInstantList.Append: TFhirInstant;
begin
  result := TFhirInstant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInstantList.ClearItems;
begin
  Clear;
end;

function TFhirInstantList.GetEnumerator : TFhirInstantListEnumerator;
begin
  result := TFhirInstantListEnumerator.Create(self.link);
end;

function TFhirInstantList.Clone: TFhirInstantList;
begin
  result := TFhirInstantList(inherited Clone);
end;

function TFhirInstantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirInstantList.GetItemN(index: Integer): TFhirInstant;
begin
  result := TFhirInstant(ObjectByIndex[index]);
end;

function TFhirInstantList.ItemClass: TFslObjectClass;
begin
  result := TFhirInstant;
end;
function TFhirInstantList.IndexOf(value: TFhirInstant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirInstantList.Insert(index: Integer): TFhirInstant;
begin
  result := TFhirInstant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirInstantList.InsertItem(index: Integer; value: TFhirInstant);
begin
  assert(value is TFhirInstant);
  Inherited Insert(index, value);
end;

function TFhirInstantList.Item(index: Integer): TFhirInstant;
begin
  result := TFhirInstant(ObjectByIndex[index]);
end;

function TFhirInstantList.Link: TFhirInstantList;
begin
  result := TFhirInstantList(inherited Link);
end;

procedure TFhirInstantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirInstantList.SetItemByIndex(index: Integer; value: TFhirInstant);
begin
  assert(value is TFhirInstant);
  FhirInstants[index] := value;
end;

procedure TFhirInstantList.SetItemN(index: Integer; value: TFhirInstant);
begin
  assert(value is TFhirInstant);
  ObjectByIndex[index] := value;
end;

{ TFhirXhtml }

Constructor TFhirXhtml.Create(value : String);
begin
  Create;
  FValue := value;
end;

destructor TFhirXhtml.Destroy;
begin
  inherited;
end;

function TFhirXhtml.fhirType : string;
begin
  result := 'xhtml';
end;

procedure TFhirXhtml.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if child_name = 'value' then
    list.add(self.link, 'value', TFHIRObjectText.create(value));
end;

procedure TFhirXhtml.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  if (bPrimitiveValues) then
    oList.add(TFHIRProperty.create(self, 'value', 'xhtml', false, nil, FValue));
end;

procedure TFhirXhtml.Assign(oSource : TFslObject);
begin
  inherited;
  FValue := TFhirXhtml(oSource).Value;
end;

function TFhirXhtml.AsStringValue : string;
begin
  result := FValue;
end;

procedure TFhirXhtml.SetStringValue(value : string);
begin
  FValue := value;
end;

function TFhirXhtml.equals(other : TObject) : boolean; 
var
  o : TFhirXhtml;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirXhtml)) then
    result := false
  else
  begin
    o := TFhirXhtml(other);
    result := o.value = value;
  end;
end;

function TFhirXhtml.isEmpty : boolean;
begin
  result := inherited isEmpty and (FValue = '');
end;

function TFhirXhtml.Link : TFhirXhtml;
begin
  result := TFhirXhtml(inherited Link);
end;

function TFhirXhtml.Clone : TFhirXhtml;
begin
  result := TFhirXhtml(inherited Clone);
end;

procedure TFhirXhtml.setValue(value : String);
begin
  FValue := value;
end;

procedure TFhirXhtml.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

function TFhirXhtml.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, (FValue.length * sizeof(char)) + 12);
end;

{ TFhirXhtmlListEnumerator }

Constructor TFhirXhtmlListEnumerator.Create(list : TFhirXhtmlList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirXhtmlListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirXhtmlListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirXhtmlListEnumerator.GetCurrent : TFhirXhtml;
begin
  Result := FList[FIndex];
end;

function TFhirXhtmlListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirXhtmlList }
procedure TFhirXhtmlList.AddItem(value: TFhirXhtml);
begin
  assert(value.ClassName = 'TFhirXhtml', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirXhtml');
  add(value);
end;

procedure TFhirXhtmlList.AddItem(value: String);
begin
  add(TFhirXhtml.create(value));
end;

function TFhirXhtmlList.Append: TFhirXhtml;
begin
  result := TFhirXhtml.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirXhtmlList.ClearItems;
begin
  Clear;
end;

function TFhirXhtmlList.GetEnumerator : TFhirXhtmlListEnumerator;
begin
  result := TFhirXhtmlListEnumerator.Create(self.link);
end;

function TFhirXhtmlList.Clone: TFhirXhtmlList;
begin
  result := TFhirXhtmlList(inherited Clone);
end;

function TFhirXhtmlList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirXhtmlList.GetItemN(index: Integer): TFhirXhtml;
begin
  result := TFhirXhtml(ObjectByIndex[index]);
end;

function TFhirXhtmlList.ItemClass: TFslObjectClass;
begin
  result := TFhirXhtml;
end;
function TFhirXhtmlList.IndexOf(value: TFhirXhtml): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirXhtmlList.Insert(index: Integer): TFhirXhtml;
begin
  result := TFhirXhtml.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirXhtmlList.InsertItem(index: Integer; value: TFhirXhtml);
begin
  assert(value is TFhirXhtml);
  Inherited Insert(index, value);
end;

function TFhirXhtmlList.Item(index: Integer): TFhirXhtml;
begin
  result := TFhirXhtml(ObjectByIndex[index]);
end;

function TFhirXhtmlList.Link: TFhirXhtmlList;
begin
  result := TFhirXhtmlList(inherited Link);
end;

procedure TFhirXhtmlList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirXhtmlList.SetItemByIndex(index: Integer; value: TFhirXhtml);
begin
  assert(value is TFhirXhtml);
  FhirXhtmls[index] := value;
end;

procedure TFhirXhtmlList.SetItemN(index: Integer; value: TFhirXhtml);
begin
  assert(value is TFhirXhtml);
  ObjectByIndex[index] := value;
end;

{ TFhirBoolean }

Constructor TFhirBoolean.Create(value : Boolean);
begin
  Create;
  FValue := value;
end;

destructor TFhirBoolean.Destroy;
begin
  inherited;
end;

function TFhirBoolean.fhirType : string;
begin
  result := 'boolean';
end;

procedure TFhirBoolean.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if child_name = 'value' then
    list.add(self.link, 'value', TFHIRObjectText.create(value));
end;

procedure TFhirBoolean.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  if (bPrimitiveValues) then
    oList.add(TFHIRProperty.create(self, 'value', 'boolean', false, nil, LCBooleanToString(FValue)));
end;

procedure TFhirBoolean.Assign(oSource : TFslObject);
begin
  inherited;
  FValue := TFhirBoolean(oSource).Value;
end;

function TFhirBoolean.AsStringValue : string;
begin
  result := LCBooleanToString(FValue);
end;

procedure TFhirBoolean.SetStringValue(value : string);
begin
  FValue := StringToBoolean(value);
end;

function TFhirBoolean.equals(other : TObject) : boolean; 
var
  o : TFhirBoolean;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBoolean)) then
    result := false
  else
  begin
    o := TFhirBoolean(other);
    result := o.value = value;
  end;
end;

function TFhirBoolean.isBooleanPrimitive: boolean;
begin
  result := true;
end;

function TFhirBoolean.isEmpty : boolean;
begin
  result := false;
end;

function TFhirBoolean.Link : TFhirBoolean;
begin
  result := TFhirBoolean(inherited Link);
end;

function TFhirBoolean.Clone : TFhirBoolean;
begin
  result := TFhirBoolean(inherited Clone);
end;

procedure TFhirBoolean.setValue(value : Boolean);
begin
  FValue := value;
end;

procedure TFhirBoolean.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

function TFhirBoolean.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
end;

{ TFhirBooleanListEnumerator }

Constructor TFhirBooleanListEnumerator.Create(list : TFhirBooleanList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBooleanListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBooleanListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBooleanListEnumerator.GetCurrent : TFhirBoolean;
begin
  Result := FList[FIndex];
end;

function TFhirBooleanListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBooleanList }
procedure TFhirBooleanList.AddItem(value: TFhirBoolean);
begin
  assert(value.ClassName = 'TFhirBoolean', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBoolean');
  add(value);
end;

procedure TFhirBooleanList.AddItem(value: Boolean);
begin
  add(TFhirBoolean.create(value));
end;

function TFhirBooleanList.Append: TFhirBoolean;
begin
  result := TFhirBoolean.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBooleanList.ClearItems;
begin
  Clear;
end;

function TFhirBooleanList.GetEnumerator : TFhirBooleanListEnumerator;
begin
  result := TFhirBooleanListEnumerator.Create(self.link);
end;

function TFhirBooleanList.Clone: TFhirBooleanList;
begin
  result := TFhirBooleanList(inherited Clone);
end;

function TFhirBooleanList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBooleanList.GetItemN(index: Integer): TFhirBoolean;
begin
  result := TFhirBoolean(ObjectByIndex[index]);
end;

function TFhirBooleanList.ItemClass: TFslObjectClass;
begin
  result := TFhirBoolean;
end;
function TFhirBooleanList.IndexOf(value: TFhirBoolean): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBooleanList.Insert(index: Integer): TFhirBoolean;
begin
  result := TFhirBoolean.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBooleanList.InsertItem(index: Integer; value: TFhirBoolean);
begin
  assert(value is TFhirBoolean);
  Inherited Insert(index, value);
end;

function TFhirBooleanList.Item(index: Integer): TFhirBoolean;
begin
  result := TFhirBoolean(ObjectByIndex[index]);
end;

function TFhirBooleanList.Link: TFhirBooleanList;
begin
  result := TFhirBooleanList(inherited Link);
end;

procedure TFhirBooleanList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBooleanList.SetItemByIndex(index: Integer; value: TFhirBoolean);
begin
  assert(value is TFhirBoolean);
  FhirBooleans[index] := value;
end;

procedure TFhirBooleanList.SetItemN(index: Integer; value: TFhirBoolean);
begin
  assert(value is TFhirBoolean);
  ObjectByIndex[index] := value;
end;

{ TFhirBase64Binary }

Constructor TFhirBase64Binary.Create(value : TBytes);
begin
  Create;
  FValue := value;
end;

destructor TFhirBase64Binary.Destroy;
begin
  inherited;
end;

function TFhirBase64Binary.fhirType : string;
begin
  result := 'base64Binary';
end;

procedure TFhirBase64Binary.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if child_name = 'value' then
    list.add(self.link, 'value', TFHIRObjectText.create(value));
end;

procedure TFhirBase64Binary.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  if (bPrimitiveValues) then
    oList.add(TFHIRProperty.create(self, 'value', 'base64Binary', false, nil, FValue));
end;

procedure TFhirBase64Binary.Assign(oSource : TFslObject);
begin
  inherited;
  FValue := TFhirBase64Binary(oSource).Value;
end;

function TFhirBase64Binary.AsStringValue : string;
begin
  if (length(FValue) = 0) then result := '' else result := string(EncodeBase64(FValue));
end;

procedure TFhirBase64Binary.SetStringValue(value : string);
begin
  if (length(value) = 0) then SetLength(FValue, 0) else FValue := DecodeBase64(wideString(value));
end;

function TFhirBase64Binary.equals(other : TObject) : boolean; 
var
  o : TFhirBase64Binary;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBase64Binary)) then
    result := false
  else
  begin
    o := TFhirBase64Binary(other);
    result := o.value = value;
  end;
end;

function TFhirBase64Binary.isEmpty : boolean;
begin
  result := inherited isEmpty and (length(FValue) = 0);
end;

function TFhirBase64Binary.Link : TFhirBase64Binary;
begin
  result := TFhirBase64Binary(inherited Link);
end;

function TFhirBase64Binary.Clone : TFhirBase64Binary;
begin
  result := TFhirBase64Binary(inherited Clone);
end;

procedure TFhirBase64Binary.setValue(value : TBytes);
begin
  FValue := value;
end;

procedure TFhirBase64Binary.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

function TFhirBase64Binary.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, length(FValue));
end;

{ TFhirBase64BinaryListEnumerator }

Constructor TFhirBase64BinaryListEnumerator.Create(list : TFhirBase64BinaryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBase64BinaryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBase64BinaryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBase64BinaryListEnumerator.GetCurrent : TFhirBase64Binary;
begin
  Result := FList[FIndex];
end;

function TFhirBase64BinaryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBase64BinaryList }
procedure TFhirBase64BinaryList.AddItem(value: TFhirBase64Binary);
begin
  assert(value.ClassName = 'TFhirBase64Binary', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBase64Binary');
  add(value);
end;

procedure TFhirBase64BinaryList.AddItem(value: TBytes);
begin
  add(TFhirBase64Binary.create(value));
end;

function TFhirBase64BinaryList.Append: TFhirBase64Binary;
begin
  result := TFhirBase64Binary.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBase64BinaryList.ClearItems;
begin
  Clear;
end;

function TFhirBase64BinaryList.GetEnumerator : TFhirBase64BinaryListEnumerator;
begin
  result := TFhirBase64BinaryListEnumerator.Create(self.link);
end;

function TFhirBase64BinaryList.Clone: TFhirBase64BinaryList;
begin
  result := TFhirBase64BinaryList(inherited Clone);
end;

function TFhirBase64BinaryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBase64BinaryList.GetItemN(index: Integer): TFhirBase64Binary;
begin
  result := TFhirBase64Binary(ObjectByIndex[index]);
end;

function TFhirBase64BinaryList.ItemClass: TFslObjectClass;
begin
  result := TFhirBase64Binary;
end;
function TFhirBase64BinaryList.IndexOf(value: TFhirBase64Binary): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBase64BinaryList.Insert(index: Integer): TFhirBase64Binary;
begin
  result := TFhirBase64Binary.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBase64BinaryList.InsertItem(index: Integer; value: TFhirBase64Binary);
begin
  assert(value is TFhirBase64Binary);
  Inherited Insert(index, value);
end;

function TFhirBase64BinaryList.Item(index: Integer): TFhirBase64Binary;
begin
  result := TFhirBase64Binary(ObjectByIndex[index]);
end;

function TFhirBase64BinaryList.Link: TFhirBase64BinaryList;
begin
  result := TFhirBase64BinaryList(inherited Link);
end;

procedure TFhirBase64BinaryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBase64BinaryList.SetItemByIndex(index: Integer; value: TFhirBase64Binary);
begin
  assert(value is TFhirBase64Binary);
  FhirBase64Binaries[index] := value;
end;

procedure TFhirBase64BinaryList.SetItemN(index: Integer; value: TFhirBase64Binary);
begin
  assert(value is TFhirBase64Binary);
  ObjectByIndex[index] := value;
end;

{ TFhirTime }

Constructor TFhirTime.Create(value : String);
begin
  Create;
  FValue := value;
end;

destructor TFhirTime.Destroy;
begin
  inherited;
end;

function TFhirTime.fhirType : string;
begin
  result := 'time';
end;

procedure TFhirTime.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if child_name = 'value' then
    list.add(self.link, 'value', TFHIRObjectText.create(value));
end;

procedure TFhirTime.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  if (bPrimitiveValues) then
    oList.add(TFHIRProperty.create(self, 'value', 'time', false, nil, FValue));
end;

procedure TFhirTime.Assign(oSource : TFslObject);
begin
  inherited;
  FValue := TFhirTime(oSource).Value;
end;

function TFhirTime.AsStringValue : string;
begin
  result := FValue;
end;

procedure TFhirTime.SetStringValue(value : string);
begin
  FValue := value;
end;

function TFhirTime.equals(other : TObject) : boolean; 
var
  o : TFhirTime;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTime)) then
    result := false
  else
  begin
    o := TFhirTime(other);
    result := o.value = value;
  end;
end;

function TFhirTime.isEmpty : boolean;
begin
  result := inherited isEmpty and (FValue = '');
end;

function TFhirTime.Link : TFhirTime;
begin
  result := TFhirTime(inherited Link);
end;

function TFhirTime.Clone : TFhirTime;
begin
  result := TFhirTime(inherited Clone);
end;

procedure TFhirTime.setValue(value : String);
begin
  FValue := value;
end;

procedure TFhirTime.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

function TFhirTime.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, (FValue.length * sizeof(char)) + 12);
end;

{ TFhirTimeListEnumerator }

Constructor TFhirTimeListEnumerator.Create(list : TFhirTimeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTimeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTimeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTimeListEnumerator.GetCurrent : TFhirTime;
begin
  Result := FList[FIndex];
end;

function TFhirTimeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTimeList }
procedure TFhirTimeList.AddItem(value: TFhirTime);
begin
  assert(value.ClassName = 'TFhirTime', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTime');
  add(value);
end;

procedure TFhirTimeList.AddItem(value: String);
begin
  add(TFhirTime.create(value));
end;

function TFhirTimeList.Append: TFhirTime;
begin
  result := TFhirTime.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTimeList.ClearItems;
begin
  Clear;
end;

function TFhirTimeList.GetEnumerator : TFhirTimeListEnumerator;
begin
  result := TFhirTimeListEnumerator.Create(self.link);
end;

function TFhirTimeList.Clone: TFhirTimeList;
begin
  result := TFhirTimeList(inherited Clone);
end;

function TFhirTimeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTimeList.GetItemN(index: Integer): TFhirTime;
begin
  result := TFhirTime(ObjectByIndex[index]);
end;

function TFhirTimeList.ItemClass: TFslObjectClass;
begin
  result := TFhirTime;
end;
function TFhirTimeList.IndexOf(value: TFhirTime): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTimeList.Insert(index: Integer): TFhirTime;
begin
  result := TFhirTime.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTimeList.InsertItem(index: Integer; value: TFhirTime);
begin
  assert(value is TFhirTime);
  Inherited Insert(index, value);
end;

function TFhirTimeList.Item(index: Integer): TFhirTime;
begin
  result := TFhirTime(ObjectByIndex[index]);
end;

function TFhirTimeList.Link: TFhirTimeList;
begin
  result := TFhirTimeList(inherited Link);
end;

procedure TFhirTimeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTimeList.SetItemByIndex(index: Integer; value: TFhirTime);
begin
  assert(value is TFhirTime);
  FhirTimes[index] := value;
end;

procedure TFhirTimeList.SetItemN(index: Integer; value: TFhirTime);
begin
  assert(value is TFhirTime);
  ObjectByIndex[index] := value;
end;

{ TFhirDecimal }

Constructor TFhirDecimal.Create(value : String);
begin
  Create;
  FValue := value;
end;

destructor TFhirDecimal.Destroy;
begin
  inherited;
end;

function TFhirDecimal.fhirType : string;
begin
  result := 'decimal';
end;

procedure TFhirDecimal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if child_name = 'value' then
    list.add(self.link, 'value', TFHIRObjectText.create(value));
end;

procedure TFhirDecimal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  if (bPrimitiveValues) then
    oList.add(TFHIRProperty.create(self, 'value', 'decimal', false, nil, FValue));
end;

procedure TFhirDecimal.Assign(oSource : TFslObject);
begin
  inherited;
  FValue := TFhirDecimal(oSource).Value;
end;

function TFhirDecimal.AsStringValue : string;
begin
  result := FValue;
end;

procedure TFhirDecimal.SetStringValue(value : string);
begin
  FValue := value;
end;

function TFhirDecimal.equals(other : TObject) : boolean; 
var
  o : TFhirDecimal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDecimal)) then
    result := false
  else
  begin
    o := TFhirDecimal(other);
    result := o.value = value;
  end;
end;

function TFhirDecimal.isEmpty : boolean;
begin
  result := inherited isEmpty and (FValue = '');
end;

function TFhirDecimal.Link : TFhirDecimal;
begin
  result := TFhirDecimal(inherited Link);
end;

function TFhirDecimal.Clone : TFhirDecimal;
begin
  result := TFhirDecimal(inherited Clone);
end;

procedure TFhirDecimal.setValue(value : String);
begin
  FValue := value;
end;

procedure TFhirDecimal.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

function TFhirDecimal.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, (FValue.length * sizeof(char)) + 12);
end;

{ TFhirDecimalListEnumerator }

Constructor TFhirDecimalListEnumerator.Create(list : TFhirDecimalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDecimalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDecimalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDecimalListEnumerator.GetCurrent : TFhirDecimal;
begin
  Result := FList[FIndex];
end;

function TFhirDecimalListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDecimalList }
procedure TFhirDecimalList.AddItem(value: TFhirDecimal);
begin
  assert(value.ClassName = 'TFhirDecimal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDecimal');
  add(value);
end;

procedure TFhirDecimalList.AddItem(value: String);
begin
  add(TFhirDecimal.create(value));
end;

function TFhirDecimalList.Append: TFhirDecimal;
begin
  result := TFhirDecimal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDecimalList.ClearItems;
begin
  Clear;
end;

function TFhirDecimalList.GetEnumerator : TFhirDecimalListEnumerator;
begin
  result := TFhirDecimalListEnumerator.Create(self.link);
end;

function TFhirDecimalList.Clone: TFhirDecimalList;
begin
  result := TFhirDecimalList(inherited Clone);
end;

function TFhirDecimalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDecimalList.GetItemN(index: Integer): TFhirDecimal;
begin
  result := TFhirDecimal(ObjectByIndex[index]);
end;

function TFhirDecimalList.ItemClass: TFslObjectClass;
begin
  result := TFhirDecimal;
end;
function TFhirDecimalList.IndexOf(value: TFhirDecimal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDecimalList.Insert(index: Integer): TFhirDecimal;
begin
  result := TFhirDecimal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDecimalList.InsertItem(index: Integer; value: TFhirDecimal);
begin
  assert(value is TFhirDecimal);
  Inherited Insert(index, value);
end;

function TFhirDecimalList.Item(index: Integer): TFhirDecimal;
begin
  result := TFhirDecimal(ObjectByIndex[index]);
end;

function TFhirDecimalList.Link: TFhirDecimalList;
begin
  result := TFhirDecimalList(inherited Link);
end;

procedure TFhirDecimalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDecimalList.SetItemByIndex(index: Integer; value: TFhirDecimal);
begin
  assert(value is TFhirDecimal);
  FhirDecimals[index] := value;
end;

procedure TFhirDecimalList.SetItemN(index: Integer; value: TFhirDecimal);
begin
  assert(value is TFhirDecimal);
  ObjectByIndex[index] := value;
end;

{ TFhirCode }

Constructor TFhirCode.Create(value : String);
begin
  Create;
  FValue := value;
end;

destructor TFhirCode.Destroy;
begin
  inherited;
end;

function TFhirCode.fhirType : string;
begin
  result := 'code';
end;

function TFhirCode.Link : TFhirCode;
begin
  result := TFhirCode(inherited Link);
end;

function TFhirCode.Clone : TFhirCode;
begin
  result := TFhirCode(inherited Clone);
end;

procedure TFhirCode.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

{ TFhirCodeListEnumerator }

Constructor TFhirCodeListEnumerator.Create(list : TFhirCodeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCodeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCodeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCodeListEnumerator.GetCurrent : TFhirCode;
begin
  Result := FList[FIndex];
end;

function TFhirCodeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCodeList }
procedure TFhirCodeList.AddItem(value: TFhirCode);
begin
  assert(value.ClassName = 'TFhirCode', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCode');
  add(value);
end;

procedure TFhirCodeList.AddItem(value: String);
begin
  add(TFhirCode.create(value));
end;

function TFhirCodeList.Append: TFhirCode;
begin
  result := TFhirCode.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeList.ClearItems;
begin
  Clear;
end;

function TFhirCodeList.GetEnumerator : TFhirCodeListEnumerator;
begin
  result := TFhirCodeListEnumerator.Create(self.link);
end;

function TFhirCodeList.Clone: TFhirCodeList;
begin
  result := TFhirCodeList(inherited Clone);
end;

function TFhirCodeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCodeList.GetItemN(index: Integer): TFhirCode;
begin
  result := TFhirCode(ObjectByIndex[index]);
end;

function TFhirCodeList.ItemClass: TFslObjectClass;
begin
  result := TFhirCode;
end;
function TFhirCodeList.IndexOf(value: TFhirCode): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCodeList.Insert(index: Integer): TFhirCode;
begin
  result := TFhirCode.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeList.InsertItem(index: Integer; value: TFhirCode);
begin
  assert(value is TFhirCode);
  Inherited Insert(index, value);
end;

function TFhirCodeList.Item(index: Integer): TFhirCode;
begin
  result := TFhirCode(ObjectByIndex[index]);
end;

function TFhirCodeList.Link: TFhirCodeList;
begin
  result := TFhirCodeList(inherited Link);
end;

procedure TFhirCodeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCodeList.SetItemByIndex(index: Integer; value: TFhirCode);
begin
  assert(value is TFhirCode);
  FhirCodes[index] := value;
end;

procedure TFhirCodeList.SetItemN(index: Integer; value: TFhirCode);
begin
  assert(value is TFhirCode);
  ObjectByIndex[index] := value;
end;

{ TFhirCanonical }

Constructor TFhirCanonical.Create(value : String);
begin
  Create;
  FValue := value;
end;

destructor TFhirCanonical.Destroy;
begin
  inherited;
end;

function TFhirCanonical.fhirType : string;
begin
  result := 'canonical';
end;

function TFhirCanonical.Link : TFhirCanonical;
begin
  result := TFhirCanonical(inherited Link);
end;

function TFhirCanonical.Clone : TFhirCanonical;
begin
  result := TFhirCanonical(inherited Clone);
end;

procedure TFhirCanonical.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

{ TFhirCanonicalListEnumerator }

Constructor TFhirCanonicalListEnumerator.Create(list : TFhirCanonicalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCanonicalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCanonicalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCanonicalListEnumerator.GetCurrent : TFhirCanonical;
begin
  Result := FList[FIndex];
end;

function TFhirCanonicalListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCanonicalList }
procedure TFhirCanonicalList.AddItem(value: TFhirCanonical);
begin
  assert(value.ClassName = 'TFhirCanonical', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCanonical');
  add(value);
end;

procedure TFhirCanonicalList.AddItem(value: String);
begin
  add(TFhirCanonical.create(value));
end;

function TFhirCanonicalList.Append: TFhirCanonical;
begin
  result := TFhirCanonical.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCanonicalList.ClearItems;
begin
  Clear;
end;

function TFhirCanonicalList.GetEnumerator : TFhirCanonicalListEnumerator;
begin
  result := TFhirCanonicalListEnumerator.Create(self.link);
end;

function TFhirCanonicalList.Clone: TFhirCanonicalList;
begin
  result := TFhirCanonicalList(inherited Clone);
end;

function TFhirCanonicalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCanonicalList.GetItemN(index: Integer): TFhirCanonical;
begin
  result := TFhirCanonical(ObjectByIndex[index]);
end;

function TFhirCanonicalList.ItemClass: TFslObjectClass;
begin
  result := TFhirCanonical;
end;
function TFhirCanonicalList.IndexOf(value: TFhirCanonical): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCanonicalList.Insert(index: Integer): TFhirCanonical;
begin
  result := TFhirCanonical.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCanonicalList.InsertItem(index: Integer; value: TFhirCanonical);
begin
  assert(value is TFhirCanonical);
  Inherited Insert(index, value);
end;

function TFhirCanonicalList.Item(index: Integer): TFhirCanonical;
begin
  result := TFhirCanonical(ObjectByIndex[index]);
end;

function TFhirCanonicalList.Link: TFhirCanonicalList;
begin
  result := TFhirCanonicalList(inherited Link);
end;

procedure TFhirCanonicalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCanonicalList.SetItemByIndex(index: Integer; value: TFhirCanonical);
begin
  assert(value is TFhirCanonical);
  FhirCanonicals[index] := value;
end;

procedure TFhirCanonicalList.SetItemN(index: Integer; value: TFhirCanonical);
begin
  assert(value is TFhirCanonical);
  ObjectByIndex[index] := value;
end;

{ TFhirOid }

Constructor TFhirOid.Create(value : String);
begin
  Create;
  FValue := value;
end;

destructor TFhirOid.Destroy;
begin
  inherited;
end;

function TFhirOid.fhirType : string;
begin
  result := 'oid';
end;

function TFhirOid.Link : TFhirOid;
begin
  result := TFhirOid(inherited Link);
end;

function TFhirOid.Clone : TFhirOid;
begin
  result := TFhirOid(inherited Clone);
end;

procedure TFhirOid.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

{ TFhirOidListEnumerator }

Constructor TFhirOidListEnumerator.Create(list : TFhirOidList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOidListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOidListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOidListEnumerator.GetCurrent : TFhirOid;
begin
  Result := FList[FIndex];
end;

function TFhirOidListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOidList }
procedure TFhirOidList.AddItem(value: TFhirOid);
begin
  assert(value.ClassName = 'TFhirOid', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOid');
  add(value);
end;

procedure TFhirOidList.AddItem(value: String);
begin
  add(TFhirOid.create(value));
end;

function TFhirOidList.Append: TFhirOid;
begin
  result := TFhirOid.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOidList.ClearItems;
begin
  Clear;
end;

function TFhirOidList.GetEnumerator : TFhirOidListEnumerator;
begin
  result := TFhirOidListEnumerator.Create(self.link);
end;

function TFhirOidList.Clone: TFhirOidList;
begin
  result := TFhirOidList(inherited Clone);
end;

function TFhirOidList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOidList.GetItemN(index: Integer): TFhirOid;
begin
  result := TFhirOid(ObjectByIndex[index]);
end;

function TFhirOidList.ItemClass: TFslObjectClass;
begin
  result := TFhirOid;
end;
function TFhirOidList.IndexOf(value: TFhirOid): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOidList.Insert(index: Integer): TFhirOid;
begin
  result := TFhirOid.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOidList.InsertItem(index: Integer; value: TFhirOid);
begin
  assert(value is TFhirOid);
  Inherited Insert(index, value);
end;

function TFhirOidList.Item(index: Integer): TFhirOid;
begin
  result := TFhirOid(ObjectByIndex[index]);
end;

function TFhirOidList.Link: TFhirOidList;
begin
  result := TFhirOidList(inherited Link);
end;

procedure TFhirOidList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOidList.SetItemByIndex(index: Integer; value: TFhirOid);
begin
  assert(value is TFhirOid);
  FhirOids[index] := value;
end;

procedure TFhirOidList.SetItemN(index: Integer; value: TFhirOid);
begin
  assert(value is TFhirOid);
  ObjectByIndex[index] := value;
end;

{ TFhirUuid }

Constructor TFhirUuid.Create(value : String);
begin
  Create;
  FValue := value;
end;

destructor TFhirUuid.Destroy;
begin
  inherited;
end;

function TFhirUuid.fhirType : string;
begin
  result := 'uuid';
end;

function TFhirUuid.Link : TFhirUuid;
begin
  result := TFhirUuid(inherited Link);
end;

function TFhirUuid.Clone : TFhirUuid;
begin
  result := TFhirUuid(inherited Clone);
end;

procedure TFhirUuid.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

{ TFhirUuidListEnumerator }

Constructor TFhirUuidListEnumerator.Create(list : TFhirUuidList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirUuidListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirUuidListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirUuidListEnumerator.GetCurrent : TFhirUuid;
begin
  Result := FList[FIndex];
end;

function TFhirUuidListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirUuidList }
procedure TFhirUuidList.AddItem(value: TFhirUuid);
begin
  assert(value.ClassName = 'TFhirUuid', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirUuid');
  add(value);
end;

procedure TFhirUuidList.AddItem(value: String);
begin
  add(TFhirUuid.create(value));
end;

function TFhirUuidList.Append: TFhirUuid;
begin
  result := TFhirUuid.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirUuidList.ClearItems;
begin
  Clear;
end;

function TFhirUuidList.GetEnumerator : TFhirUuidListEnumerator;
begin
  result := TFhirUuidListEnumerator.Create(self.link);
end;

function TFhirUuidList.Clone: TFhirUuidList;
begin
  result := TFhirUuidList(inherited Clone);
end;

function TFhirUuidList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirUuidList.GetItemN(index: Integer): TFhirUuid;
begin
  result := TFhirUuid(ObjectByIndex[index]);
end;

function TFhirUuidList.ItemClass: TFslObjectClass;
begin
  result := TFhirUuid;
end;
function TFhirUuidList.IndexOf(value: TFhirUuid): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirUuidList.Insert(index: Integer): TFhirUuid;
begin
  result := TFhirUuid.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirUuidList.InsertItem(index: Integer; value: TFhirUuid);
begin
  assert(value is TFhirUuid);
  Inherited Insert(index, value);
end;

function TFhirUuidList.Item(index: Integer): TFhirUuid;
begin
  result := TFhirUuid(ObjectByIndex[index]);
end;

function TFhirUuidList.Link: TFhirUuidList;
begin
  result := TFhirUuidList(inherited Link);
end;

procedure TFhirUuidList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirUuidList.SetItemByIndex(index: Integer; value: TFhirUuid);
begin
  assert(value is TFhirUuid);
  FhirUuids[index] := value;
end;

procedure TFhirUuidList.SetItemN(index: Integer; value: TFhirUuid);
begin
  assert(value is TFhirUuid);
  ObjectByIndex[index] := value;
end;

{ TFhirUrl }

Constructor TFhirUrl.Create(value : String);
begin
  Create;
  FValue := value;
end;

destructor TFhirUrl.Destroy;
begin
  inherited;
end;

function TFhirUrl.fhirType : string;
begin
  result := 'url';
end;

function TFhirUrl.Link : TFhirUrl;
begin
  result := TFhirUrl(inherited Link);
end;

function TFhirUrl.Clone : TFhirUrl;
begin
  result := TFhirUrl(inherited Clone);
end;

procedure TFhirUrl.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

{ TFhirUrlListEnumerator }

Constructor TFhirUrlListEnumerator.Create(list : TFhirUrlList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirUrlListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirUrlListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirUrlListEnumerator.GetCurrent : TFhirUrl;
begin
  Result := FList[FIndex];
end;

function TFhirUrlListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirUrlList }
procedure TFhirUrlList.AddItem(value: TFhirUrl);
begin
  assert(value.ClassName = 'TFhirUrl', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirUrl');
  add(value);
end;

procedure TFhirUrlList.AddItem(value: String);
begin
  add(TFhirUrl.create(value));
end;

function TFhirUrlList.Append: TFhirUrl;
begin
  result := TFhirUrl.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirUrlList.ClearItems;
begin
  Clear;
end;

function TFhirUrlList.GetEnumerator : TFhirUrlListEnumerator;
begin
  result := TFhirUrlListEnumerator.Create(self.link);
end;

function TFhirUrlList.Clone: TFhirUrlList;
begin
  result := TFhirUrlList(inherited Clone);
end;

function TFhirUrlList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirUrlList.GetItemN(index: Integer): TFhirUrl;
begin
  result := TFhirUrl(ObjectByIndex[index]);
end;

function TFhirUrlList.ItemClass: TFslObjectClass;
begin
  result := TFhirUrl;
end;
function TFhirUrlList.IndexOf(value: TFhirUrl): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirUrlList.Insert(index: Integer): TFhirUrl;
begin
  result := TFhirUrl.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirUrlList.InsertItem(index: Integer; value: TFhirUrl);
begin
  assert(value is TFhirUrl);
  Inherited Insert(index, value);
end;

function TFhirUrlList.Item(index: Integer): TFhirUrl;
begin
  result := TFhirUrl(ObjectByIndex[index]);
end;

function TFhirUrlList.Link: TFhirUrlList;
begin
  result := TFhirUrlList(inherited Link);
end;

procedure TFhirUrlList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirUrlList.SetItemByIndex(index: Integer; value: TFhirUrl);
begin
  assert(value is TFhirUrl);
  FhirUrls[index] := value;
end;

procedure TFhirUrlList.SetItemN(index: Integer; value: TFhirUrl);
begin
  assert(value is TFhirUrl);
  ObjectByIndex[index] := value;
end;

{ TFhirMarkdown }

Constructor TFhirMarkdown.Create(value : String);
begin
  Create;
  FValue := value;
end;

destructor TFhirMarkdown.Destroy;
begin
  inherited;
end;

function TFhirMarkdown.fhirType : string;
begin
  result := 'markdown';
end;

function TFhirMarkdown.Link : TFhirMarkdown;
begin
  result := TFhirMarkdown(inherited Link);
end;

function TFhirMarkdown.Clone : TFhirMarkdown;
begin
  result := TFhirMarkdown(inherited Clone);
end;

procedure TFhirMarkdown.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

{ TFhirMarkdownListEnumerator }

Constructor TFhirMarkdownListEnumerator.Create(list : TFhirMarkdownList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMarkdownListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMarkdownListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMarkdownListEnumerator.GetCurrent : TFhirMarkdown;
begin
  Result := FList[FIndex];
end;

function TFhirMarkdownListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMarkdownList }
procedure TFhirMarkdownList.AddItem(value: TFhirMarkdown);
begin
  assert(value.ClassName = 'TFhirMarkdown', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMarkdown');
  add(value);
end;

procedure TFhirMarkdownList.AddItem(value: String);
begin
  add(TFhirMarkdown.create(value));
end;

function TFhirMarkdownList.Append: TFhirMarkdown;
begin
  result := TFhirMarkdown.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMarkdownList.ClearItems;
begin
  Clear;
end;

function TFhirMarkdownList.GetEnumerator : TFhirMarkdownListEnumerator;
begin
  result := TFhirMarkdownListEnumerator.Create(self.link);
end;

function TFhirMarkdownList.Clone: TFhirMarkdownList;
begin
  result := TFhirMarkdownList(inherited Clone);
end;

function TFhirMarkdownList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMarkdownList.GetItemN(index: Integer): TFhirMarkdown;
begin
  result := TFhirMarkdown(ObjectByIndex[index]);
end;

function TFhirMarkdownList.ItemClass: TFslObjectClass;
begin
  result := TFhirMarkdown;
end;
function TFhirMarkdownList.IndexOf(value: TFhirMarkdown): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMarkdownList.Insert(index: Integer): TFhirMarkdown;
begin
  result := TFhirMarkdown.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMarkdownList.InsertItem(index: Integer; value: TFhirMarkdown);
begin
  assert(value is TFhirMarkdown);
  Inherited Insert(index, value);
end;

function TFhirMarkdownList.Item(index: Integer): TFhirMarkdown;
begin
  result := TFhirMarkdown(ObjectByIndex[index]);
end;

function TFhirMarkdownList.Link: TFhirMarkdownList;
begin
  result := TFhirMarkdownList(inherited Link);
end;

procedure TFhirMarkdownList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMarkdownList.SetItemByIndex(index: Integer; value: TFhirMarkdown);
begin
  assert(value is TFhirMarkdown);
  FhirMarkdowns[index] := value;
end;

procedure TFhirMarkdownList.SetItemN(index: Integer; value: TFhirMarkdown);
begin
  assert(value is TFhirMarkdown);
  ObjectByIndex[index] := value;
end;

{ TFhirUnsignedInt }

Constructor TFhirUnsignedInt.Create(value : String);
begin
  Create;
  FValue := value;
end;

destructor TFhirUnsignedInt.Destroy;
begin
  inherited;
end;

function TFhirUnsignedInt.fhirType : string;
begin
  result := 'unsignedInt';
end;

function TFhirUnsignedInt.Link : TFhirUnsignedInt;
begin
  result := TFhirUnsignedInt(inherited Link);
end;

function TFhirUnsignedInt.Clone : TFhirUnsignedInt;
begin
  result := TFhirUnsignedInt(inherited Clone);
end;

procedure TFhirUnsignedInt.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

{ TFhirUnsignedIntListEnumerator }

Constructor TFhirUnsignedIntListEnumerator.Create(list : TFhirUnsignedIntList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirUnsignedIntListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirUnsignedIntListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirUnsignedIntListEnumerator.GetCurrent : TFhirUnsignedInt;
begin
  Result := FList[FIndex];
end;

function TFhirUnsignedIntListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirUnsignedIntList }
procedure TFhirUnsignedIntList.AddItem(value: TFhirUnsignedInt);
begin
  assert(value.ClassName = 'TFhirUnsignedInt', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirUnsignedInt');
  add(value);
end;

procedure TFhirUnsignedIntList.AddItem(value: String);
begin
  add(TFhirUnsignedInt.create(value));
end;

function TFhirUnsignedIntList.Append: TFhirUnsignedInt;
begin
  result := TFhirUnsignedInt.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirUnsignedIntList.ClearItems;
begin
  Clear;
end;

function TFhirUnsignedIntList.GetEnumerator : TFhirUnsignedIntListEnumerator;
begin
  result := TFhirUnsignedIntListEnumerator.Create(self.link);
end;

function TFhirUnsignedIntList.Clone: TFhirUnsignedIntList;
begin
  result := TFhirUnsignedIntList(inherited Clone);
end;

function TFhirUnsignedIntList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirUnsignedIntList.GetItemN(index: Integer): TFhirUnsignedInt;
begin
  result := TFhirUnsignedInt(ObjectByIndex[index]);
end;

function TFhirUnsignedIntList.ItemClass: TFslObjectClass;
begin
  result := TFhirUnsignedInt;
end;
function TFhirUnsignedIntList.IndexOf(value: TFhirUnsignedInt): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirUnsignedIntList.Insert(index: Integer): TFhirUnsignedInt;
begin
  result := TFhirUnsignedInt.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirUnsignedIntList.InsertItem(index: Integer; value: TFhirUnsignedInt);
begin
  assert(value is TFhirUnsignedInt);
  Inherited Insert(index, value);
end;

function TFhirUnsignedIntList.Item(index: Integer): TFhirUnsignedInt;
begin
  result := TFhirUnsignedInt(ObjectByIndex[index]);
end;

function TFhirUnsignedIntList.Link: TFhirUnsignedIntList;
begin
  result := TFhirUnsignedIntList(inherited Link);
end;

procedure TFhirUnsignedIntList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirUnsignedIntList.SetItemByIndex(index: Integer; value: TFhirUnsignedInt);
begin
  assert(value is TFhirUnsignedInt);
  FhirUnsignedInts[index] := value;
end;

procedure TFhirUnsignedIntList.SetItemN(index: Integer; value: TFhirUnsignedInt);
begin
  assert(value is TFhirUnsignedInt);
  ObjectByIndex[index] := value;
end;

{ TFhirId }

Constructor TFhirId.Create(value : String);
begin
  Create;
  FValue := value;
end;

destructor TFhirId.Destroy;
begin
  inherited;
end;

function TFhirId.fhirType : string;
begin
  result := 'id';
end;

function TFhirId.Link : TFhirId;
begin
  result := TFhirId(inherited Link);
end;

function TFhirId.Clone : TFhirId;
begin
  result := TFhirId(inherited Clone);
end;

procedure TFhirId.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

{ TFhirIdListEnumerator }

Constructor TFhirIdListEnumerator.Create(list : TFhirIdList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirIdListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirIdListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirIdListEnumerator.GetCurrent : TFhirId;
begin
  Result := FList[FIndex];
end;

function TFhirIdListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirIdList }
procedure TFhirIdList.AddItem(value: TFhirId);
begin
  assert(value.ClassName = 'TFhirId', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirId');
  add(value);
end;

procedure TFhirIdList.AddItem(value: String);
begin
  add(TFhirId.create(value));
end;

function TFhirIdList.Append: TFhirId;
begin
  result := TFhirId.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIdList.ClearItems;
begin
  Clear;
end;

function TFhirIdList.GetEnumerator : TFhirIdListEnumerator;
begin
  result := TFhirIdListEnumerator.Create(self.link);
end;

function TFhirIdList.Clone: TFhirIdList;
begin
  result := TFhirIdList(inherited Clone);
end;

function TFhirIdList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirIdList.GetItemN(index: Integer): TFhirId;
begin
  result := TFhirId(ObjectByIndex[index]);
end;

function TFhirIdList.ItemClass: TFslObjectClass;
begin
  result := TFhirId;
end;
function TFhirIdList.IndexOf(value: TFhirId): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirIdList.Insert(index: Integer): TFhirId;
begin
  result := TFhirId.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIdList.InsertItem(index: Integer; value: TFhirId);
begin
  assert(value is TFhirId);
  Inherited Insert(index, value);
end;

function TFhirIdList.Item(index: Integer): TFhirId;
begin
  result := TFhirId(ObjectByIndex[index]);
end;

function TFhirIdList.Link: TFhirIdList;
begin
  result := TFhirIdList(inherited Link);
end;

procedure TFhirIdList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirIdList.SetItemByIndex(index: Integer; value: TFhirId);
begin
  assert(value is TFhirId);
  FhirIds[index] := value;
end;

procedure TFhirIdList.SetItemN(index: Integer; value: TFhirId);
begin
  assert(value is TFhirId);
  ObjectByIndex[index] := value;
end;

{ TFhirPositiveInt }

Constructor TFhirPositiveInt.Create(value : String);
begin
  Create;
  FValue := value;
end;

destructor TFhirPositiveInt.Destroy;
begin
  inherited;
end;

function TFhirPositiveInt.fhirType : string;
begin
  result := 'positiveInt';
end;

function TFhirPositiveInt.Link : TFhirPositiveInt;
begin
  result := TFhirPositiveInt(inherited Link);
end;

function TFhirPositiveInt.Clone : TFhirPositiveInt;
begin
  result := TFhirPositiveInt(inherited Clone);
end;

procedure TFhirPositiveInt.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('@value');
end;

{ TFhirPositiveIntListEnumerator }

Constructor TFhirPositiveIntListEnumerator.Create(list : TFhirPositiveIntList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPositiveIntListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPositiveIntListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPositiveIntListEnumerator.GetCurrent : TFhirPositiveInt;
begin
  Result := FList[FIndex];
end;

function TFhirPositiveIntListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPositiveIntList }
procedure TFhirPositiveIntList.AddItem(value: TFhirPositiveInt);
begin
  assert(value.ClassName = 'TFhirPositiveInt', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPositiveInt');
  add(value);
end;

procedure TFhirPositiveIntList.AddItem(value: String);
begin
  add(TFhirPositiveInt.create(value));
end;

function TFhirPositiveIntList.Append: TFhirPositiveInt;
begin
  result := TFhirPositiveInt.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPositiveIntList.ClearItems;
begin
  Clear;
end;

function TFhirPositiveIntList.GetEnumerator : TFhirPositiveIntListEnumerator;
begin
  result := TFhirPositiveIntListEnumerator.Create(self.link);
end;

function TFhirPositiveIntList.Clone: TFhirPositiveIntList;
begin
  result := TFhirPositiveIntList(inherited Clone);
end;

function TFhirPositiveIntList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPositiveIntList.GetItemN(index: Integer): TFhirPositiveInt;
begin
  result := TFhirPositiveInt(ObjectByIndex[index]);
end;

function TFhirPositiveIntList.ItemClass: TFslObjectClass;
begin
  result := TFhirPositiveInt;
end;
function TFhirPositiveIntList.IndexOf(value: TFhirPositiveInt): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPositiveIntList.Insert(index: Integer): TFhirPositiveInt;
begin
  result := TFhirPositiveInt.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPositiveIntList.InsertItem(index: Integer; value: TFhirPositiveInt);
begin
  assert(value is TFhirPositiveInt);
  Inherited Insert(index, value);
end;

function TFhirPositiveIntList.Item(index: Integer): TFhirPositiveInt;
begin
  result := TFhirPositiveInt(ObjectByIndex[index]);
end;

function TFhirPositiveIntList.Link: TFhirPositiveIntList;
begin
  result := TFhirPositiveIntList(inherited Link);
end;

procedure TFhirPositiveIntList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPositiveIntList.SetItemByIndex(index: Integer; value: TFhirPositiveInt);
begin
  assert(value is TFhirPositiveInt);
  FhirPositiveInts[index] := value;
end;

procedure TFhirPositiveIntList.SetItemN(index: Integer; value: TFhirPositiveInt);
begin
  assert(value is TFhirPositiveInt);
  ObjectByIndex[index] := value;
end;

function TFhirPublicationStatusEnumListAsInteger(aSet : TFhirPublicationStatusEnumList) : Integer;
var
  a : TFhirPublicationStatusEnum;
begin
  result := 0;
  for a := low(TFhirPublicationStatusEnum) to high(TFhirPublicationStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirPublicationStatusEnumList(i : Integer) : TFhirPublicationStatusEnumList;
var
  aLoop : TFhirPublicationStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirPublicationStatusEnum) to high(TFhirPublicationStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

{ TFhirExtension }

constructor TFhirExtension.Create;
begin
  inherited;
end;

destructor TFhirExtension.Destroy;
begin
  FUrl.free;
  FValue.free;
  inherited;
end;

procedure TFhirExtension.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirExtension(oSource).urlElement.Clone;
  value := TFhirExtension(oSource).value.Clone;
end;

procedure TFhirExtension.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirExtension.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'string', false, TFhirString, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage', false, TFhirType, FValue.Link));{2}
end;

function TFhirExtension.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirExtension.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExtension.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExtension.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'string'
  else if (propName = 'value[x]') then result := 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExtension.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then ValueElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExtension.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asString(new){5b}
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then ValueElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExtension.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExtension.fhirType : string;
begin
  result := 'Extension';
end;

function TFhirExtension.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FValue);
end;

function TFhirExtension.equals(other : TObject) : boolean; 
var
  o : TFhirExtension;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExtension)) then
    result := false
  else
  begin
    o := TFhirExtension(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirExtension.Link : TFhirExtension;
begin
  result := TFhirExtension(inherited Link);
end;

function TFhirExtension.Clone : TFhirExtension;
begin
  result := TFhirExtension(inherited Clone);
end;

procedure TFhirExtension.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('value[x]');
end;

{ TFhirExtension }

Procedure TFhirExtension.SetUrl(value : TFhirString);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirExtension.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirExtension.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirString.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirExtension.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

function TFhirExtension.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUrl.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirExtensionListEnumerator }

Constructor TFhirExtensionListEnumerator.Create(list : TFhirExtensionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExtensionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExtensionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExtensionListEnumerator.GetCurrent : TFhirExtension;
begin
  Result := FList[FIndex];
end;

function TFhirExtensionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExtensionList }
procedure TFhirExtensionList.AddItem(value: TFhirExtension);
begin
  assert(value.ClassName = 'TFhirExtension', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExtension');
  add(value);
end;

function TFhirExtensionList.Append: TFhirExtension;
begin
  result := TFhirExtension.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExtensionList.ClearItems;
begin
  Clear;
end;

function TFhirExtensionList.GetEnumerator : TFhirExtensionListEnumerator;
begin
  result := TFhirExtensionListEnumerator.Create(self.link);
end;

function TFhirExtensionList.Clone: TFhirExtensionList;
begin
  result := TFhirExtensionList(inherited Clone);
end;

function TFhirExtensionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExtensionList.GetItemN(index: Integer): TFhirExtension;
begin
  result := TFhirExtension(ObjectByIndex[index]);
end;

function TFhirExtensionList.ItemClass: TFslObjectClass;
begin
  result := TFhirExtension;
end;
function TFhirExtensionList.IndexOf(value: TFhirExtension): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExtensionList.Insert(index: Integer): TFhirExtension;
begin
  result := TFhirExtension.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExtensionList.InsertItem(index: Integer; value: TFhirExtension);
begin
  assert(value is TFhirExtension);
  Inherited Insert(index, value);
end;

function TFhirExtensionList.Item(index: Integer): TFhirExtension;
begin
  result := TFhirExtension(ObjectByIndex[index]);
end;

function TFhirExtensionList.Link: TFhirExtensionList;
begin
  result := TFhirExtensionList(inherited Link);
end;

procedure TFhirExtensionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExtensionList.SetItemByIndex(index: Integer; value: TFhirExtension);
begin
  assert(value is TFhirExtension);
  FhirExtensions[index] := value;
end;

procedure TFhirExtensionList.SetItemN(index: Integer; value: TFhirExtension);
begin
  assert(value is TFhirExtension);
  ObjectByIndex[index] := value;
end;

function TFhirNarrativeStatusEnumListAsInteger(aSet : TFhirNarrativeStatusEnumList) : Integer;
var
  a : TFhirNarrativeStatusEnum;
begin
  result := 0;
  for a := low(TFhirNarrativeStatusEnum) to high(TFhirNarrativeStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirNarrativeStatusEnumList(i : Integer) : TFhirNarrativeStatusEnumList;
var
  aLoop : TFhirNarrativeStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirNarrativeStatusEnum) to high(TFhirNarrativeStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

{ TFhirNarrative }

constructor TFhirNarrative.Create;
begin
  inherited;
end;

destructor TFhirNarrative.Destroy;
begin
  FStatus.free;
  FDiv_.free;
  inherited;
end;

procedure TFhirNarrative.Assign(oSource : TFslObject);
begin
  inherited;
  FStatus := TFhirNarrative(oSource).FStatus.Link;
  div_ := TFhirNarrative(oSource).div_.Clone;
end;

procedure TFhirNarrative.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'div') Then
     list.add(self.link, 'div', FDiv_.Link);
end;

procedure TFhirNarrative.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'div', 'xhtml', false, TFhirXHtmlNode, FDiv_.Link));{2}
end;

function TFhirNarrative.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirNarrativeStatusEnum, CODES_TFhirNarrativeStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'div') then
  begin
    Div_Element := asXHtmlNode(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirNarrative.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNarrative.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'div') then result := TFhirXHtmlNode.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNarrative.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'code'
  else if (propName = 'div') then result := 'xhtml'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNarrative.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'div') then Div_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNarrative.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirNarrativeStatusEnum, CODES_TFhirNarrativeStatusEnum, new){4}
  else if (propName = 'div') then Div_Element := asXHtmlNode(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNarrative.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNarrative.fhirType : string;
begin
  result := 'Narrative';
end;

function TFhirNarrative.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FDiv_);
end;

function TFhirNarrative.equals(other : TObject) : boolean; 
var
  o : TFhirNarrative;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNarrative)) then
    result := false
  else
  begin
    o := TFhirNarrative(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(div_Element, o.div_Element, true);
  end;
end;

function TFhirNarrative.Link : TFhirNarrative;
begin
  result := TFhirNarrative(inherited Link);
end;

function TFhirNarrative.Clone : TFhirNarrative;
begin
  result := TFhirNarrative(inherited Clone);
end;

procedure TFhirNarrative.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('status');
  fields.add('div');
end;

{ TFhirNarrative }

Procedure TFhirNarrative.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirNarrative.GetStatusST : TFhirNarrativeStatusEnum;
begin
  if FStatus = nil then
    result := TFhirNarrativeStatusEnum(0)
  else
    result := TFhirNarrativeStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirNarrativeStatusEnum, FStatus.value));
end;

Procedure TFhirNarrative.SetStatusST(value : TFhirNarrativeStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirNarrativeStatusEnum[value], CODES_TFhirNarrativeStatusEnum[value]);
end;

Procedure TFhirNarrative.SetDiv_(value : TFhirXHtmlNode);
begin
  FDiv_.free;
  FDiv_ := value;
end;

function TFhirNarrative.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStatus.sizeInBytes);
  inc(result, FDiv_.sizeInBytes);
end;

{ TFhirNarrativeListEnumerator }

Constructor TFhirNarrativeListEnumerator.Create(list : TFhirNarrativeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNarrativeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNarrativeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNarrativeListEnumerator.GetCurrent : TFhirNarrative;
begin
  Result := FList[FIndex];
end;

function TFhirNarrativeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNarrativeList }
procedure TFhirNarrativeList.AddItem(value: TFhirNarrative);
begin
  assert(value.ClassName = 'TFhirNarrative', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNarrative');
  add(value);
end;

function TFhirNarrativeList.Append: TFhirNarrative;
begin
  result := TFhirNarrative.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNarrativeList.ClearItems;
begin
  Clear;
end;

function TFhirNarrativeList.GetEnumerator : TFhirNarrativeListEnumerator;
begin
  result := TFhirNarrativeListEnumerator.Create(self.link);
end;

function TFhirNarrativeList.Clone: TFhirNarrativeList;
begin
  result := TFhirNarrativeList(inherited Clone);
end;

function TFhirNarrativeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNarrativeList.GetItemN(index: Integer): TFhirNarrative;
begin
  result := TFhirNarrative(ObjectByIndex[index]);
end;

function TFhirNarrativeList.ItemClass: TFslObjectClass;
begin
  result := TFhirNarrative;
end;
function TFhirNarrativeList.IndexOf(value: TFhirNarrative): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNarrativeList.Insert(index: Integer): TFhirNarrative;
begin
  result := TFhirNarrative.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNarrativeList.InsertItem(index: Integer; value: TFhirNarrative);
begin
  assert(value is TFhirNarrative);
  Inherited Insert(index, value);
end;

function TFhirNarrativeList.Item(index: Integer): TFhirNarrative;
begin
  result := TFhirNarrative(ObjectByIndex[index]);
end;

function TFhirNarrativeList.Link: TFhirNarrativeList;
begin
  result := TFhirNarrativeList(inherited Link);
end;

procedure TFhirNarrativeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNarrativeList.SetItemByIndex(index: Integer; value: TFhirNarrative);
begin
  assert(value is TFhirNarrative);
  FhirNarratives[index] := value;
end;

procedure TFhirNarrativeList.SetItemN(index: Integer; value: TFhirNarrative);
begin
  assert(value is TFhirNarrative);
  ObjectByIndex[index] := value;
end;

function TFhirContributorTypeEnumListAsInteger(aSet : TFhirContributorTypeEnumList) : Integer;
var
  a : TFhirContributorTypeEnum;
begin
  result := 0;
  for a := low(TFhirContributorTypeEnum) to high(TFhirContributorTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirContributorTypeEnumList(i : Integer) : TFhirContributorTypeEnumList;
var
  aLoop : TFhirContributorTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirContributorTypeEnum) to high(TFhirContributorTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

{ TFhirContributor }

constructor TFhirContributor.Create;
begin
  inherited;
end;

destructor TFhirContributor.Destroy;
begin
  FType_.free;
  FName.free;
  FContactList.Free;
  inherited;
end;

procedure TFhirContributor.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirContributor(oSource).FType_.Link;
  nameElement := TFhirContributor(oSource).nameElement.Clone;
  if (TFhirContributor(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirContributor(oSource).FContactList);
  end;
end;

procedure TFhirContributor.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
end;

procedure TFhirContributor.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link)){3};
end;

function TFhirContributor.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirContributorTypeEnum, CODES_TFhirContributorTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirContributor.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail){2a}
  else inherited;
end;

function TFhirContributor.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContributor.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContributor.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContributor.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirContributorTypeEnum, CODES_TFhirContributorTypeEnum, new){4}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContributor.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContributor.fhirType : string;
begin
  result := 'Contributor';
end;

function TFhirContributor.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FName) and isEmptyProp(FcontactList);
end;

function TFhirContributor.equals(other : TObject) : boolean; 
var
  o : TFhirContributor;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContributor)) then
    result := false
  else
  begin
    o := TFhirContributor(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(contactList, o.contactList, true);
  end;
end;

function TFhirContributor.Link : TFhirContributor;
begin
  result := TFhirContributor(inherited Link);
end;

function TFhirContributor.Clone : TFhirContributor;
begin
  result := TFhirContributor(inherited Clone);
end;

procedure TFhirContributor.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('name');
  fields.add('contact');
end;

{ TFhirContributor }

Procedure TFhirContributor.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirContributor.GetType_ST : TFhirContributorTypeEnum;
begin
  if FType_ = nil then
    result := TFhirContributorTypeEnum(0)
  else
    result := TFhirContributorTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirContributorTypeEnum, FType_.value));
end;

Procedure TFhirContributor.SetType_ST(value : TFhirContributorTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirContributorTypeEnum[value], CODES_TFhirContributorTypeEnum[value]);
end;

Procedure TFhirContributor.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirContributor.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirContributor.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Function TFhirContributor.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

Function TFhirContributor.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirContributor.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FcontactList.sizeInBytes);
end;

{ TFhirContributorListEnumerator }

Constructor TFhirContributorListEnumerator.Create(list : TFhirContributorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContributorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContributorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContributorListEnumerator.GetCurrent : TFhirContributor;
begin
  Result := FList[FIndex];
end;

function TFhirContributorListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContributorList }
procedure TFhirContributorList.AddItem(value: TFhirContributor);
begin
  assert(value.ClassName = 'TFhirContributor', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContributor');
  add(value);
end;

function TFhirContributorList.Append: TFhirContributor;
begin
  result := TFhirContributor.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContributorList.ClearItems;
begin
  Clear;
end;

function TFhirContributorList.GetEnumerator : TFhirContributorListEnumerator;
begin
  result := TFhirContributorListEnumerator.Create(self.link);
end;

function TFhirContributorList.Clone: TFhirContributorList;
begin
  result := TFhirContributorList(inherited Clone);
end;

function TFhirContributorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContributorList.GetItemN(index: Integer): TFhirContributor;
begin
  result := TFhirContributor(ObjectByIndex[index]);
end;

function TFhirContributorList.ItemClass: TFslObjectClass;
begin
  result := TFhirContributor;
end;
function TFhirContributorList.IndexOf(value: TFhirContributor): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContributorList.Insert(index: Integer): TFhirContributor;
begin
  result := TFhirContributor.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContributorList.InsertItem(index: Integer; value: TFhirContributor);
begin
  assert(value is TFhirContributor);
  Inherited Insert(index, value);
end;

function TFhirContributorList.Item(index: Integer): TFhirContributor;
begin
  result := TFhirContributor(ObjectByIndex[index]);
end;

function TFhirContributorList.Link: TFhirContributorList;
begin
  result := TFhirContributorList(inherited Link);
end;

procedure TFhirContributorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContributorList.SetItemByIndex(index: Integer; value: TFhirContributor);
begin
  assert(value is TFhirContributor);
  FhirContributors[index] := value;
end;

procedure TFhirContributorList.SetItemN(index: Integer; value: TFhirContributor);
begin
  assert(value is TFhirContributor);
  ObjectByIndex[index] := value;
end;

{ TFhirAttachment }

constructor TFhirAttachment.Create;
begin
  inherited;
end;

destructor TFhirAttachment.Destroy;
begin
  FContentType.free;
  FLanguage.free;
  FData.free;
  FUrl.free;
  FSize.free;
  FHash.free;
  FTitle.free;
  FCreation.free;
  inherited;
end;

procedure TFhirAttachment.Assign(oSource : TFslObject);
begin
  inherited;
  contentTypeElement := TFhirAttachment(oSource).contentTypeElement.Clone;
  languageElement := TFhirAttachment(oSource).languageElement.Clone;
  dataElement := TFhirAttachment(oSource).dataElement.Clone;
  urlElement := TFhirAttachment(oSource).urlElement.Clone;
  sizeElement := TFhirAttachment(oSource).sizeElement.Clone;
  hashElement := TFhirAttachment(oSource).hashElement.Clone;
  titleElement := TFhirAttachment(oSource).titleElement.Clone;
  creationElement := TFhirAttachment(oSource).creationElement.Clone;
end;

procedure TFhirAttachment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'contentType') Then
     list.add(self.link, 'contentType', FContentType.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'data') Then
     list.add(self.link, 'data', FData.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'size') Then
     list.add(self.link, 'size', FSize.Link);
  if (child_name = 'hash') Then
     list.add(self.link, 'hash', FHash.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'creation') Then
     list.add(self.link, 'creation', FCreation.Link);
end;

procedure TFhirAttachment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'contentType', 'code', false, TFhirCode, FContentType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'language', 'code', false, TFhirCode, FLanguage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'data', 'base64Binary', false, TFhirBase64Binary, FData.Link));{2}
  oList.add(TFHIRProperty.create(self, 'url', 'url', false, TFhirUrl, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'size', 'unsignedInt', false, TFhirUnsignedInt, FSize.Link));{2}
  oList.add(TFHIRProperty.create(self, 'hash', 'base64Binary', false, TFhirBase64Binary, FHash.Link));{2}
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'creation', 'dateTime', false, TFhirDateTime, FCreation.Link));{2}
end;

function TFhirAttachment.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'contentType') then
  begin
    ContentTypeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    LanguageElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'data') then
  begin
    DataElement := asBase64Binary(propValue){5a};
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUrl(propValue){5a};
    result := propValue;
  end
  else if (propName = 'size') then
  begin
    SizeElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'hash') then
  begin
    HashElement := asBase64Binary(propValue){5a};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'creation') then
  begin
    CreationElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirAttachment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAttachment.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'contentType') then result := TFhirCode.create() {5b}
  else if (propName = 'language') then result := TFhirCode.create() {5b}
  else if (propName = 'data') then result := TFhirBase64Binary.create() {5b}
  else if (propName = 'url') then result := TFhirUrl.create() {5b}
  else if (propName = 'size') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'hash') then result := TFhirBase64Binary.create() {5b}
  else if (propName = 'title') then result := TFhirString.create() {5b}
  else if (propName = 'creation') then result := TFhirDateTime.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAttachment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'contentType') then result := 'code'
  else if (propName = 'language') then result := 'code'
  else if (propName = 'data') then result := 'base64Binary'
  else if (propName = 'url') then result := 'url'
  else if (propName = 'size') then result := 'unsignedInt'
  else if (propName = 'hash') then result := 'base64Binary'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'creation') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAttachment.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'contentType') then ContentTypeElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else if (propName = 'data') then DataElement := nil
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'size') then SizeElement := nil
  else if (propName = 'hash') then HashElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'creation') then CreationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAttachment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'contentType') then ContentTypeElement := asCode(new){5b}
  else if (propName = 'language') then LanguageElement := asCode(new){5b}
  else if (propName = 'data') then DataElement := asBase64Binary(new){5b}
  else if (propName = 'url') then UrlElement := asUrl(new){5b}
  else if (propName = 'size') then SizeElement := asUnsignedInt(new){5b}
  else if (propName = 'hash') then HashElement := asBase64Binary(new){5b}
  else if (propName = 'title') then TitleElement := asString(new){5b}
  else if (propName = 'creation') then CreationElement := asDateTime(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAttachment.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAttachment.fhirType : string;
begin
  result := 'Attachment';
end;

function TFhirAttachment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContentType) and isEmptyProp(FLanguage) and isEmptyProp(FData) and isEmptyProp(FUrl) and isEmptyProp(FSize) and isEmptyProp(FHash) and isEmptyProp(FTitle) and isEmptyProp(FCreation);
end;

function TFhirAttachment.equals(other : TObject) : boolean; 
var
  o : TFhirAttachment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAttachment)) then
    result := false
  else
  begin
    o := TFhirAttachment(other);
    result := compareDeep(contentTypeElement, o.contentTypeElement, true) and compareDeep(languageElement, o.languageElement, true) and 
      compareDeep(dataElement, o.dataElement, true) and compareDeep(urlElement, o.urlElement, true) and 
      compareDeep(sizeElement, o.sizeElement, true) and compareDeep(hashElement, o.hashElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(creationElement, o.creationElement, true);
  end;
end;

function TFhirAttachment.Link : TFhirAttachment;
begin
  result := TFhirAttachment(inherited Link);
end;

function TFhirAttachment.Clone : TFhirAttachment;
begin
  result := TFhirAttachment(inherited Clone);
end;

procedure TFhirAttachment.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('contentType');
  fields.add('language');
  fields.add('data');
  fields.add('url');
  fields.add('size');
  fields.add('hash');
  fields.add('title');
  fields.add('creation');
end;

{ TFhirAttachment }

Procedure TFhirAttachment.SetContentType(value : TFhirCode);
begin
  FContentType.free;
  FContentType := value;
end;

Function TFhirAttachment.GetContentTypeST : String;
begin
  if FContentType = nil then
    result := ''
  else
    result := FContentType.value;
end;

Procedure TFhirAttachment.SetContentTypeST(value : String);
begin
  if value <> '' then
  begin
    if FContentType = nil then
      FContentType := TFhirCode.create;
    FContentType.value := value
  end
  else if FContentType <> nil then
    FContentType.value := '';
end;

Procedure TFhirAttachment.SetLanguage(value : TFhirCode);
begin
  FLanguage.free;
  FLanguage := value;
end;

Function TFhirAttachment.GetLanguageST : String;
begin
  if FLanguage = nil then
    result := ''
  else
    result := FLanguage.value;
end;

Procedure TFhirAttachment.SetLanguageST(value : String);
begin
  if value <> '' then
  begin
    if FLanguage = nil then
      FLanguage := TFhirCode.create;
    FLanguage.value := value
  end
  else if FLanguage <> nil then
    FLanguage.value := '';
end;

Procedure TFhirAttachment.SetData(value : TFhirBase64Binary);
begin
  FData.free;
  FData := value;
end;

Function TFhirAttachment.GetDataST : TBytes;
begin
  if FData = nil then
    result := nil
  else
    result := FData.value;
end;

Procedure TFhirAttachment.SetDataST(value : TBytes);
begin
  if value <> nil then
  begin
    if FData = nil then
      FData := TFhirBase64Binary.create;
    FData.value := value
  end
  else if FData <> nil then
    FData.value := nil;
end;

Procedure TFhirAttachment.SetUrl(value : TFhirUrl);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirAttachment.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirAttachment.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUrl.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirAttachment.SetSize(value : TFhirUnsignedInt);
begin
  FSize.free;
  FSize := value;
end;

Function TFhirAttachment.GetSizeST : String;
begin
  if FSize = nil then
    result := ''
  else
    result := FSize.value;
end;

Procedure TFhirAttachment.SetSizeST(value : String);
begin
  if value <> '' then
  begin
    if FSize = nil then
      FSize := TFhirUnsignedInt.create;
    FSize.value := value
  end
  else if FSize <> nil then
    FSize.value := '';
end;

Procedure TFhirAttachment.SetHash(value : TFhirBase64Binary);
begin
  FHash.free;
  FHash := value;
end;

Function TFhirAttachment.GetHashST : TBytes;
begin
  if FHash = nil then
    result := nil
  else
    result := FHash.value;
end;

Procedure TFhirAttachment.SetHashST(value : TBytes);
begin
  if value <> nil then
  begin
    if FHash = nil then
      FHash := TFhirBase64Binary.create;
    FHash.value := value
  end
  else if FHash <> nil then
    FHash.value := nil;
end;

Procedure TFhirAttachment.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirAttachment.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirAttachment.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirAttachment.SetCreation(value : TFhirDateTime);
begin
  FCreation.free;
  FCreation := value;
end;

Function TFhirAttachment.GetCreationST : TFslDateTime;
begin
  if FCreation = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreation.value;
end;

Procedure TFhirAttachment.SetCreationST(value : TFslDateTime);
begin
  if FCreation = nil then
    FCreation := TFhirDateTime.create;
  FCreation.value := value
end;

function TFhirAttachment.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContentType.sizeInBytes);
  inc(result, FLanguage.sizeInBytes);
  inc(result, FData.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
  inc(result, FSize.sizeInBytes);
  inc(result, FHash.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
  inc(result, FCreation.sizeInBytes);
end;

{ TFhirAttachmentListEnumerator }

Constructor TFhirAttachmentListEnumerator.Create(list : TFhirAttachmentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAttachmentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAttachmentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAttachmentListEnumerator.GetCurrent : TFhirAttachment;
begin
  Result := FList[FIndex];
end;

function TFhirAttachmentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAttachmentList }
procedure TFhirAttachmentList.AddItem(value: TFhirAttachment);
begin
  assert(value.ClassName = 'TFhirAttachment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAttachment');
  add(value);
end;

function TFhirAttachmentList.Append: TFhirAttachment;
begin
  result := TFhirAttachment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAttachmentList.ClearItems;
begin
  Clear;
end;

function TFhirAttachmentList.GetEnumerator : TFhirAttachmentListEnumerator;
begin
  result := TFhirAttachmentListEnumerator.Create(self.link);
end;

function TFhirAttachmentList.Clone: TFhirAttachmentList;
begin
  result := TFhirAttachmentList(inherited Clone);
end;

function TFhirAttachmentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAttachmentList.GetItemN(index: Integer): TFhirAttachment;
begin
  result := TFhirAttachment(ObjectByIndex[index]);
end;

function TFhirAttachmentList.ItemClass: TFslObjectClass;
begin
  result := TFhirAttachment;
end;
function TFhirAttachmentList.IndexOf(value: TFhirAttachment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAttachmentList.Insert(index: Integer): TFhirAttachment;
begin
  result := TFhirAttachment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAttachmentList.InsertItem(index: Integer; value: TFhirAttachment);
begin
  assert(value is TFhirAttachment);
  Inherited Insert(index, value);
end;

function TFhirAttachmentList.Item(index: Integer): TFhirAttachment;
begin
  result := TFhirAttachment(ObjectByIndex[index]);
end;

function TFhirAttachmentList.Link: TFhirAttachmentList;
begin
  result := TFhirAttachmentList(inherited Link);
end;

procedure TFhirAttachmentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAttachmentList.SetItemByIndex(index: Integer; value: TFhirAttachment);
begin
  assert(value is TFhirAttachment);
  FhirAttachments[index] := value;
end;

procedure TFhirAttachmentList.SetItemN(index: Integer; value: TFhirAttachment);
begin
  assert(value is TFhirAttachment);
  ObjectByIndex[index] := value;
end;

function TFhirAllTypesEnumListAsInteger(aSet : TFhirAllTypesEnumList) : Integer;
var
  a : TFhirAllTypesEnum;
begin
  result := 0;
  for a := low(TFhirAllTypesEnum) to high(TFhirAllTypesEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirAllTypesEnumList(i : Integer) : TFhirAllTypesEnumList;
var
  aLoop : TFhirAllTypesEnum;
begin
  result := [];
  for aLoop := low(TFhirAllTypesEnum) to high(TFhirAllTypesEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirSortDirectionEnumListAsInteger(aSet : TFhirSortDirectionEnumList) : Integer;
var
  a : TFhirSortDirectionEnum;
begin
  result := 0;
  for a := low(TFhirSortDirectionEnum) to high(TFhirSortDirectionEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirSortDirectionEnumList(i : Integer) : TFhirSortDirectionEnumList;
var
  aLoop : TFhirSortDirectionEnum;
begin
  result := [];
  for aLoop := low(TFhirSortDirectionEnum) to high(TFhirSortDirectionEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

{ TFhirDataRequirementCodeFilter }

constructor TFhirDataRequirementCodeFilter.Create;
begin
  inherited;
end;

destructor TFhirDataRequirementCodeFilter.Destroy;
begin
  FPath.free;
  FSearchParam.free;
  FValueSet.free;
  FCodeList.Free;
  inherited;
end;

procedure TFhirDataRequirementCodeFilter.Assign(oSource : TFslObject);
begin
  inherited;
  pathElement := TFhirDataRequirementCodeFilter(oSource).pathElement.Clone;
  searchParamElement := TFhirDataRequirementCodeFilter(oSource).searchParamElement.Clone;
  valueSetElement := TFhirDataRequirementCodeFilter(oSource).valueSetElement.Clone;
  if (TFhirDataRequirementCodeFilter(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodingList.Create;
    FCodeList.Assign(TFhirDataRequirementCodeFilter(oSource).FCodeList);
  end;
end;

procedure TFhirDataRequirementCodeFilter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
  if (child_name = 'searchParam') Then
     list.add(self.link, 'searchParam', FSearchParam.Link);
  if (child_name = 'valueSet') Then
     list.add(self.link, 'valueSet', FValueSet.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
end;

procedure TFhirDataRequirementCodeFilter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));{2}
  oList.add(TFHIRProperty.create(self, 'searchParam', 'string', false, TFhirString, FSearchParam.Link));{2}
  oList.add(TFHIRProperty.create(self, 'valueSet', 'canonical', false, TFhirCanonical, FValueSet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', true, TFhirCoding, FCodeList.Link)){3};
end;

function TFhirDataRequirementCodeFilter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'path') then
  begin
    PathElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'searchParam') then
  begin
    SearchParamElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'valueSet') then
  begin
    ValueSetElement := asCanonical(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDataRequirementCodeFilter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCoding){2a}
  else inherited;
end;

function TFhirDataRequirementCodeFilter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'path') then result := TFhirString.create() {5b}
  else if (propName = 'searchParam') then result := TFhirString.create() {5b}
  else if (propName = 'valueSet') then result := TFhirCanonical.create() {5b}
  else if (propName = 'code') then result := CodeList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDataRequirementCodeFilter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'path') then result := 'string'
  else if (propName = 'searchParam') then result := 'string'
  else if (propName = 'valueSet') then result := 'canonical'
  else if (propName = 'code') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDataRequirementCodeFilter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'path') then PathElement := nil
  else if (propName = 'searchParam') then SearchParamElement := nil
  else if (propName = 'valueSet') then ValueSetElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDataRequirementCodeFilter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'path') then PathElement := asString(new){5b}
  else if (propName = 'searchParam') then SearchParamElement := asString(new){5b}
  else if (propName = 'valueSet') then ValueSetElement := asCanonical(new){5b}
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDataRequirementCodeFilter.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDataRequirementCodeFilter.fhirType : string;
begin
  result := 'codeFilter';
end;

function TFhirDataRequirementCodeFilter.Link : TFhirDataRequirementCodeFilter;
begin
  result := TFhirDataRequirementCodeFilter(inherited Link);
end;

function TFhirDataRequirementCodeFilter.Clone : TFhirDataRequirementCodeFilter;
begin
  result := TFhirDataRequirementCodeFilter(inherited Clone);
end;

function TFhirDataRequirementCodeFilter.equals(other : TObject) : boolean; 
var
  o : TFhirDataRequirementCodeFilter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDataRequirementCodeFilter)) then
    result := false
  else
  begin
    o := TFhirDataRequirementCodeFilter(other);
    result := compareDeep(pathElement, o.pathElement, true) and compareDeep(searchParamElement, o.searchParamElement, true) and 
      compareDeep(valueSetElement, o.valueSetElement, true) and compareDeep(codeList, o.codeList, true);
  end;
end;

function TFhirDataRequirementCodeFilter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPath) and isEmptyProp(FSearchParam) and isEmptyProp(FValueSet) and isEmptyProp(FcodeList);
end;

procedure TFhirDataRequirementCodeFilter.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('path');
  fields.add('searchParam');
  fields.add('valueSet');
  fields.add('code');
end;

{ TFhirDataRequirementCodeFilter }

Procedure TFhirDataRequirementCodeFilter.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

Function TFhirDataRequirementCodeFilter.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

Procedure TFhirDataRequirementCodeFilter.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

Procedure TFhirDataRequirementCodeFilter.SetSearchParam(value : TFhirString);
begin
  FSearchParam.free;
  FSearchParam := value;
end;

Function TFhirDataRequirementCodeFilter.GetSearchParamST : String;
begin
  if FSearchParam = nil then
    result := ''
  else
    result := FSearchParam.value;
end;

Procedure TFhirDataRequirementCodeFilter.SetSearchParamST(value : String);
begin
  if value <> '' then
  begin
    if FSearchParam = nil then
      FSearchParam := TFhirString.create;
    FSearchParam.value := value
  end
  else if FSearchParam <> nil then
    FSearchParam.value := '';
end;

Procedure TFhirDataRequirementCodeFilter.SetValueSet(value : TFhirCanonical);
begin
  FValueSet.free;
  FValueSet := value;
end;

Function TFhirDataRequirementCodeFilter.GetValueSetST : String;
begin
  if FValueSet = nil then
    result := ''
  else
    result := FValueSet.value;
end;

Procedure TFhirDataRequirementCodeFilter.SetValueSetST(value : String);
begin
  if value <> '' then
  begin
    if FValueSet = nil then
      FValueSet := TFhirCanonical.create;
    FValueSet.value := value
  end
  else if FValueSet <> nil then
    FValueSet.value := '';
end;

Function TFhirDataRequirementCodeFilter.GetCodeList : TFhirCodingList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodingList.Create;
  result := FCodeList;
end;

Function TFhirDataRequirementCodeFilter.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirDataRequirementCodeFilter.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPath.sizeInBytes);
  inc(result, FSearchParam.sizeInBytes);
  inc(result, FValueSet.sizeInBytes);
  inc(result, FcodeList.sizeInBytes);
end;

{ TFhirDataRequirementCodeFilterListEnumerator }

Constructor TFhirDataRequirementCodeFilterListEnumerator.Create(list : TFhirDataRequirementCodeFilterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDataRequirementCodeFilterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDataRequirementCodeFilterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDataRequirementCodeFilterListEnumerator.GetCurrent : TFhirDataRequirementCodeFilter;
begin
  Result := FList[FIndex];
end;

function TFhirDataRequirementCodeFilterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDataRequirementCodeFilterList }
procedure TFhirDataRequirementCodeFilterList.AddItem(value: TFhirDataRequirementCodeFilter);
begin
  assert(value.ClassName = 'TFhirDataRequirementCodeFilter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDataRequirementCodeFilter');
  add(value);
end;

function TFhirDataRequirementCodeFilterList.Append: TFhirDataRequirementCodeFilter;
begin
  result := TFhirDataRequirementCodeFilter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDataRequirementCodeFilterList.ClearItems;
begin
  Clear;
end;

function TFhirDataRequirementCodeFilterList.GetEnumerator : TFhirDataRequirementCodeFilterListEnumerator;
begin
  result := TFhirDataRequirementCodeFilterListEnumerator.Create(self.link);
end;

function TFhirDataRequirementCodeFilterList.Clone: TFhirDataRequirementCodeFilterList;
begin
  result := TFhirDataRequirementCodeFilterList(inherited Clone);
end;

function TFhirDataRequirementCodeFilterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDataRequirementCodeFilterList.GetItemN(index: Integer): TFhirDataRequirementCodeFilter;
begin
  result := TFhirDataRequirementCodeFilter(ObjectByIndex[index]);
end;

function TFhirDataRequirementCodeFilterList.ItemClass: TFslObjectClass;
begin
  result := TFhirDataRequirementCodeFilter;
end;
function TFhirDataRequirementCodeFilterList.IndexOf(value: TFhirDataRequirementCodeFilter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDataRequirementCodeFilterList.Insert(index: Integer): TFhirDataRequirementCodeFilter;
begin
  result := TFhirDataRequirementCodeFilter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDataRequirementCodeFilterList.InsertItem(index: Integer; value: TFhirDataRequirementCodeFilter);
begin
  assert(value is TFhirDataRequirementCodeFilter);
  Inherited Insert(index, value);
end;

function TFhirDataRequirementCodeFilterList.Item(index: Integer): TFhirDataRequirementCodeFilter;
begin
  result := TFhirDataRequirementCodeFilter(ObjectByIndex[index]);
end;

function TFhirDataRequirementCodeFilterList.Link: TFhirDataRequirementCodeFilterList;
begin
  result := TFhirDataRequirementCodeFilterList(inherited Link);
end;

procedure TFhirDataRequirementCodeFilterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDataRequirementCodeFilterList.SetItemByIndex(index: Integer; value: TFhirDataRequirementCodeFilter);
begin
  assert(value is TFhirDataRequirementCodeFilter);
  FhirDataRequirementCodeFilters[index] := value;
end;

procedure TFhirDataRequirementCodeFilterList.SetItemN(index: Integer; value: TFhirDataRequirementCodeFilter);
begin
  assert(value is TFhirDataRequirementCodeFilter);
  ObjectByIndex[index] := value;
end;

{ TFhirDataRequirementDateFilter }

constructor TFhirDataRequirementDateFilter.Create;
begin
  inherited;
end;

destructor TFhirDataRequirementDateFilter.Destroy;
begin
  FPath.free;
  FSearchParam.free;
  FValue.free;
  inherited;
end;

procedure TFhirDataRequirementDateFilter.Assign(oSource : TFslObject);
begin
  inherited;
  pathElement := TFhirDataRequirementDateFilter(oSource).pathElement.Clone;
  searchParamElement := TFhirDataRequirementDateFilter(oSource).searchParamElement.Clone;
  value := TFhirDataRequirementDateFilter(oSource).value.Clone;
end;

procedure TFhirDataRequirementDateFilter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
  if (child_name = 'searchParam') Then
     list.add(self.link, 'searchParam', FSearchParam.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirDataRequirementDateFilter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));{2}
  oList.add(TFHIRProperty.create(self, 'searchParam', 'string', false, TFhirString, FSearchParam.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'dateTime|Period|Duration', false, TFhirType, FValue.Link));{2}
end;

function TFhirDataRequirementDateFilter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'path') then
  begin
    PathElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'searchParam') then
  begin
    SearchParamElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['DateTime', 'Period', 'Duration'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDataRequirementDateFilter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDataRequirementDateFilter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'path') then result := TFhirString.create() {5b}
  else if (propName = 'searchParam') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'value', ['DateTime', 'Period', 'Duration'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDataRequirementDateFilter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'path') then result := 'string'
  else if (propName = 'searchParam') then result := 'string'
  else if (propName = 'value[x]') then result := 'dateTime|Period|Duration'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDataRequirementDateFilter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'path') then PathElement := nil
  else if (propName = 'searchParam') then SearchParamElement := nil
  else if (isMatchingName(propName, 'value', ['DateTime', 'Period', 'Duration'])) then ValueElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDataRequirementDateFilter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'path') then PathElement := asString(new){5b}
  else if (propName = 'searchParam') then SearchParamElement := asString(new){5b}
  else if (isMatchingName(propName, 'value', ['DateTime', 'Period', 'Duration'])) then ValueElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDataRequirementDateFilter.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDataRequirementDateFilter.fhirType : string;
begin
  result := 'dateFilter';
end;

function TFhirDataRequirementDateFilter.Link : TFhirDataRequirementDateFilter;
begin
  result := TFhirDataRequirementDateFilter(inherited Link);
end;

function TFhirDataRequirementDateFilter.Clone : TFhirDataRequirementDateFilter;
begin
  result := TFhirDataRequirementDateFilter(inherited Clone);
end;

function TFhirDataRequirementDateFilter.equals(other : TObject) : boolean; 
var
  o : TFhirDataRequirementDateFilter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDataRequirementDateFilter)) then
    result := false
  else
  begin
    o := TFhirDataRequirementDateFilter(other);
    result := compareDeep(pathElement, o.pathElement, true) and compareDeep(searchParamElement, o.searchParamElement, true) and 
      compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirDataRequirementDateFilter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPath) and isEmptyProp(FSearchParam) and isEmptyProp(FValue);
end;

procedure TFhirDataRequirementDateFilter.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('path');
  fields.add('searchParam');
  fields.add('value[x]');
end;

{ TFhirDataRequirementDateFilter }

Procedure TFhirDataRequirementDateFilter.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

Function TFhirDataRequirementDateFilter.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

Procedure TFhirDataRequirementDateFilter.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

Procedure TFhirDataRequirementDateFilter.SetSearchParam(value : TFhirString);
begin
  FSearchParam.free;
  FSearchParam := value;
end;

Function TFhirDataRequirementDateFilter.GetSearchParamST : String;
begin
  if FSearchParam = nil then
    result := ''
  else
    result := FSearchParam.value;
end;

Procedure TFhirDataRequirementDateFilter.SetSearchParamST(value : String);
begin
  if value <> '' then
  begin
    if FSearchParam = nil then
      FSearchParam := TFhirString.create;
    FSearchParam.value := value
  end
  else if FSearchParam <> nil then
    FSearchParam.value := '';
end;

Procedure TFhirDataRequirementDateFilter.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

function TFhirDataRequirementDateFilter.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPath.sizeInBytes);
  inc(result, FSearchParam.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirDataRequirementDateFilterListEnumerator }

Constructor TFhirDataRequirementDateFilterListEnumerator.Create(list : TFhirDataRequirementDateFilterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDataRequirementDateFilterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDataRequirementDateFilterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDataRequirementDateFilterListEnumerator.GetCurrent : TFhirDataRequirementDateFilter;
begin
  Result := FList[FIndex];
end;

function TFhirDataRequirementDateFilterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDataRequirementDateFilterList }
procedure TFhirDataRequirementDateFilterList.AddItem(value: TFhirDataRequirementDateFilter);
begin
  assert(value.ClassName = 'TFhirDataRequirementDateFilter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDataRequirementDateFilter');
  add(value);
end;

function TFhirDataRequirementDateFilterList.Append: TFhirDataRequirementDateFilter;
begin
  result := TFhirDataRequirementDateFilter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDataRequirementDateFilterList.ClearItems;
begin
  Clear;
end;

function TFhirDataRequirementDateFilterList.GetEnumerator : TFhirDataRequirementDateFilterListEnumerator;
begin
  result := TFhirDataRequirementDateFilterListEnumerator.Create(self.link);
end;

function TFhirDataRequirementDateFilterList.Clone: TFhirDataRequirementDateFilterList;
begin
  result := TFhirDataRequirementDateFilterList(inherited Clone);
end;

function TFhirDataRequirementDateFilterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDataRequirementDateFilterList.GetItemN(index: Integer): TFhirDataRequirementDateFilter;
begin
  result := TFhirDataRequirementDateFilter(ObjectByIndex[index]);
end;

function TFhirDataRequirementDateFilterList.ItemClass: TFslObjectClass;
begin
  result := TFhirDataRequirementDateFilter;
end;
function TFhirDataRequirementDateFilterList.IndexOf(value: TFhirDataRequirementDateFilter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDataRequirementDateFilterList.Insert(index: Integer): TFhirDataRequirementDateFilter;
begin
  result := TFhirDataRequirementDateFilter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDataRequirementDateFilterList.InsertItem(index: Integer; value: TFhirDataRequirementDateFilter);
begin
  assert(value is TFhirDataRequirementDateFilter);
  Inherited Insert(index, value);
end;

function TFhirDataRequirementDateFilterList.Item(index: Integer): TFhirDataRequirementDateFilter;
begin
  result := TFhirDataRequirementDateFilter(ObjectByIndex[index]);
end;

function TFhirDataRequirementDateFilterList.Link: TFhirDataRequirementDateFilterList;
begin
  result := TFhirDataRequirementDateFilterList(inherited Link);
end;

procedure TFhirDataRequirementDateFilterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDataRequirementDateFilterList.SetItemByIndex(index: Integer; value: TFhirDataRequirementDateFilter);
begin
  assert(value is TFhirDataRequirementDateFilter);
  FhirDataRequirementDateFilters[index] := value;
end;

procedure TFhirDataRequirementDateFilterList.SetItemN(index: Integer; value: TFhirDataRequirementDateFilter);
begin
  assert(value is TFhirDataRequirementDateFilter);
  ObjectByIndex[index] := value;
end;

{ TFhirDataRequirementSort }

constructor TFhirDataRequirementSort.Create;
begin
  inherited;
end;

destructor TFhirDataRequirementSort.Destroy;
begin
  FPath.free;
  FDirection.free;
  inherited;
end;

procedure TFhirDataRequirementSort.Assign(oSource : TFslObject);
begin
  inherited;
  pathElement := TFhirDataRequirementSort(oSource).pathElement.Clone;
  FDirection := TFhirDataRequirementSort(oSource).FDirection.Link;
end;

procedure TFhirDataRequirementSort.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
  if (child_name = 'direction') Then
     list.add(self.link, 'direction', FDirection.Link);
end;

procedure TFhirDataRequirementSort.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));{2}
  oList.add(TFHIRProperty.create(self, 'direction', 'code', false, TFHIREnum, FDirection.Link));{1}
end;

function TFhirDataRequirementSort.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'path') then
  begin
    PathElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'direction') then
  begin
    DirectionElement := asEnum(SYSTEMS_TFhirSortDirectionEnum, CODES_TFhirSortDirectionEnum, propValue);
    result := propValue
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDataRequirementSort.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDataRequirementSort.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'path') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDataRequirementSort.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'path') then result := 'string'
  else if (propName = 'direction') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDataRequirementSort.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'path') then PathElement := nil
  else if (propName = 'direction') then DirectionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDataRequirementSort.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'path') then PathElement := asString(new){5b}
  else if (propName = 'direction') then DirectionElement := asEnum(SYSTEMS_TFhirSortDirectionEnum, CODES_TFhirSortDirectionEnum, new){4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDataRequirementSort.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDataRequirementSort.fhirType : string;
begin
  result := 'sort';
end;

function TFhirDataRequirementSort.Link : TFhirDataRequirementSort;
begin
  result := TFhirDataRequirementSort(inherited Link);
end;

function TFhirDataRequirementSort.Clone : TFhirDataRequirementSort;
begin
  result := TFhirDataRequirementSort(inherited Clone);
end;

function TFhirDataRequirementSort.equals(other : TObject) : boolean; 
var
  o : TFhirDataRequirementSort;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDataRequirementSort)) then
    result := false
  else
  begin
    o := TFhirDataRequirementSort(other);
    result := compareDeep(pathElement, o.pathElement, true) and compareDeep(directionElement, o.directionElement, true);
  end;
end;

function TFhirDataRequirementSort.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPath) and isEmptyProp(FDirection);
end;

procedure TFhirDataRequirementSort.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('path');
  fields.add('direction');
end;

{ TFhirDataRequirementSort }

Procedure TFhirDataRequirementSort.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

Function TFhirDataRequirementSort.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

Procedure TFhirDataRequirementSort.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

Procedure TFhirDataRequirementSort.SetDirection(value : TFhirEnum);
begin
  FDirection.free;
  FDirection := value;
end;

Function TFhirDataRequirementSort.GetDirectionST : TFhirSortDirectionEnum;
begin
  if FDirection = nil then
    result := TFhirSortDirectionEnum(0)
  else
    result := TFhirSortDirectionEnum(StringArrayIndexOfSensitive(CODES_TFhirSortDirectionEnum, FDirection.value));
end;

Procedure TFhirDataRequirementSort.SetDirectionST(value : TFhirSortDirectionEnum);
begin
  if ord(value) = 0 then
    DirectionElement := nil
  else
    DirectionElement := TFhirEnum.create(SYSTEMS_TFhirSortDirectionEnum[value], CODES_TFhirSortDirectionEnum[value]);
end;

function TFhirDataRequirementSort.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPath.sizeInBytes);
  inc(result, FDirection.sizeInBytes);
end;

{ TFhirDataRequirementSortListEnumerator }

Constructor TFhirDataRequirementSortListEnumerator.Create(list : TFhirDataRequirementSortList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDataRequirementSortListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDataRequirementSortListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDataRequirementSortListEnumerator.GetCurrent : TFhirDataRequirementSort;
begin
  Result := FList[FIndex];
end;

function TFhirDataRequirementSortListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDataRequirementSortList }
procedure TFhirDataRequirementSortList.AddItem(value: TFhirDataRequirementSort);
begin
  assert(value.ClassName = 'TFhirDataRequirementSort', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDataRequirementSort');
  add(value);
end;

function TFhirDataRequirementSortList.Append: TFhirDataRequirementSort;
begin
  result := TFhirDataRequirementSort.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDataRequirementSortList.ClearItems;
begin
  Clear;
end;

function TFhirDataRequirementSortList.GetEnumerator : TFhirDataRequirementSortListEnumerator;
begin
  result := TFhirDataRequirementSortListEnumerator.Create(self.link);
end;

function TFhirDataRequirementSortList.Clone: TFhirDataRequirementSortList;
begin
  result := TFhirDataRequirementSortList(inherited Clone);
end;

function TFhirDataRequirementSortList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDataRequirementSortList.GetItemN(index: Integer): TFhirDataRequirementSort;
begin
  result := TFhirDataRequirementSort(ObjectByIndex[index]);
end;

function TFhirDataRequirementSortList.ItemClass: TFslObjectClass;
begin
  result := TFhirDataRequirementSort;
end;
function TFhirDataRequirementSortList.IndexOf(value: TFhirDataRequirementSort): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDataRequirementSortList.Insert(index: Integer): TFhirDataRequirementSort;
begin
  result := TFhirDataRequirementSort.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDataRequirementSortList.InsertItem(index: Integer; value: TFhirDataRequirementSort);
begin
  assert(value is TFhirDataRequirementSort);
  Inherited Insert(index, value);
end;

function TFhirDataRequirementSortList.Item(index: Integer): TFhirDataRequirementSort;
begin
  result := TFhirDataRequirementSort(ObjectByIndex[index]);
end;

function TFhirDataRequirementSortList.Link: TFhirDataRequirementSortList;
begin
  result := TFhirDataRequirementSortList(inherited Link);
end;

procedure TFhirDataRequirementSortList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDataRequirementSortList.SetItemByIndex(index: Integer; value: TFhirDataRequirementSort);
begin
  assert(value is TFhirDataRequirementSort);
  FhirDataRequirementSorts[index] := value;
end;

procedure TFhirDataRequirementSortList.SetItemN(index: Integer; value: TFhirDataRequirementSort);
begin
  assert(value is TFhirDataRequirementSort);
  ObjectByIndex[index] := value;
end;

{ TFhirDataRequirement }

constructor TFhirDataRequirement.Create;
begin
  inherited;
end;

destructor TFhirDataRequirement.Destroy;
begin
  FType_.free;
  FProfileList.Free;
  FSubject.free;
  FMustSupportList.Free;
  FCodeFilterList.Free;
  FDateFilterList.Free;
  FLimit.free;
  FSortList.Free;
  inherited;
end;

procedure TFhirDataRequirement.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirDataRequirement(oSource).FType_.Link;
  if (TFhirDataRequirement(oSource).FProfileList = nil) then
  begin
    FProfileList.free;
    FProfileList := nil;
  end
  else
  begin
    if FProfileList = nil then
      FProfileList := TFhirCanonicalList.Create;
    FProfileList.Assign(TFhirDataRequirement(oSource).FProfileList);
  end;
  subject := TFhirDataRequirement(oSource).subject.Clone;
  if (TFhirDataRequirement(oSource).FMustSupportList = nil) then
  begin
    FMustSupportList.free;
    FMustSupportList := nil;
  end
  else
  begin
    if FMustSupportList = nil then
      FMustSupportList := TFhirStringList.Create;
    FMustSupportList.Assign(TFhirDataRequirement(oSource).FMustSupportList);
  end;
  if (TFhirDataRequirement(oSource).FCodeFilterList = nil) then
  begin
    FCodeFilterList.free;
    FCodeFilterList := nil;
  end
  else
  begin
    if FCodeFilterList = nil then
      FCodeFilterList := TFhirDataRequirementCodeFilterList.Create;
    FCodeFilterList.Assign(TFhirDataRequirement(oSource).FCodeFilterList);
  end;
  if (TFhirDataRequirement(oSource).FDateFilterList = nil) then
  begin
    FDateFilterList.free;
    FDateFilterList := nil;
  end
  else
  begin
    if FDateFilterList = nil then
      FDateFilterList := TFhirDataRequirementDateFilterList.Create;
    FDateFilterList.Assign(TFhirDataRequirement(oSource).FDateFilterList);
  end;
  limitElement := TFhirDataRequirement(oSource).limitElement.Clone;
  if (TFhirDataRequirement(oSource).FSortList = nil) then
  begin
    FSortList.free;
    FSortList := nil;
  end
  else
  begin
    if FSortList = nil then
      FSortList := TFhirDataRequirementSortList.Create;
    FSortList.Assign(TFhirDataRequirement(oSource).FSortList);
  end;
end;

procedure TFhirDataRequirement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'profile') Then
    list.addAll(self, 'profile', FProfileList);
  if (child_name = 'subject[x]') or (child_name = 'subject') Then
     list.add(self.link, 'subject[x]', FSubject.Link);
  if (child_name = 'mustSupport') Then
    list.addAll(self, 'mustSupport', FMustSupportList);
  if (child_name = 'codeFilter') Then
    list.addAll(self, 'codeFilter', FCodeFilterList);
  if (child_name = 'dateFilter') Then
    list.addAll(self, 'dateFilter', FDateFilterList);
  if (child_name = 'limit') Then
     list.add(self.link, 'limit', FLimit.Link);
  if (child_name = 'sort') Then
    list.addAll(self, 'sort', FSortList);
end;

procedure TFhirDataRequirement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'profile', 'canonical', true, TFhirCanonical, FProfileList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subject[x]', 'CodeableConcept|Reference(Group)', false, TFhirType, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'mustSupport', 'string', true, TFhirString, FMustSupportList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'codeFilter', '', true, TFhirDataRequirementCodeFilter, FCodeFilterList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'dateFilter', '', true, TFhirDataRequirementDateFilter, FDateFilterList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'limit', 'positiveInt', false, TFhirPositiveInt, FLimit.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sort', '', true, TFhirDataRequirementSort, FSortList.Link)){3};
end;

function TFhirDataRequirement.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirAllTypesEnum, CODES_TFhirAllTypesEnum, propValue);
    result := propValue
  end
  else if (propName = 'profile') then
  begin
    ProfileList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then
  begin
    Subject := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'mustSupport') then
  begin
    MustSupportList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'codeFilter') then
  begin
    CodeFilterList.add(propValue as TFhirDataRequirementCodeFilter){2a};
    result := propValue;
  end
  else if (propName = 'dateFilter') then
  begin
    DateFilterList.add(propValue as TFhirDataRequirementDateFilter){2a};
    result := propValue;
  end
  else if (propName = 'limit') then
  begin
    LimitElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'sort') then
  begin
    SortList.add(propValue as TFhirDataRequirementSort){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirDataRequirement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'profile') then ProfileList.insertItem(index, asCanonical(propValue)){2}
  else if (propName = 'mustSupport') then MustSupportList.insertItem(index, asString(propValue)){2}
  else if (propName = 'codeFilter') then CodeFilterList.insertItem(index, propValue as TFhirDataRequirementCodeFilter){2a}
  else if (propName = 'dateFilter') then DateFilterList.insertItem(index, propValue as TFhirDataRequirementDateFilter){2a}
  else if (propName = 'sort') then SortList.insertItem(index, propValue as TFhirDataRequirementSort){2a}
  else inherited;
end;

function TFhirDataRequirement.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'profile') then result := ProfileList.new(){2}
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Subject'){4x}
  else if (propName = 'mustSupport') then result := MustSupportList.new(){2}
  else if (propName = 'codeFilter') then result := CodeFilterList.new(){2}
  else if (propName = 'dateFilter') then result := DateFilterList.new(){2}
  else if (propName = 'limit') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'sort') then result := SortList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDataRequirement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'profile') then result := 'canonical'
  else if (propName = 'subject[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'mustSupport') then result := 'string'
  else if (propName = 'codeFilter') then result := ''
  else if (propName = 'dateFilter') then result := ''
  else if (propName = 'limit') then result := 'positiveInt'
  else if (propName = 'sort') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDataRequirement.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'profile') then deletePropertyValue('profile', ProfileList, value) {2}
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then SubjectElement := nil{4x}
  else if (propName = 'mustSupport') then deletePropertyValue('mustSupport', MustSupportList, value) {2}
  else if (propName = 'codeFilter') then deletePropertyValue('codeFilter', CodeFilterList, value) {2}
  else if (propName = 'dateFilter') then deletePropertyValue('dateFilter', DateFilterList, value) {2}
  else if (propName = 'limit') then LimitElement := nil
  else if (propName = 'sort') then deletePropertyValue('sort', SortList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDataRequirement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirAllTypesEnum, CODES_TFhirAllTypesEnum, new){4}
  else if (propName = 'profile') then replacePropertyValue('profile', ProfileList, existing, new) {2}
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then SubjectElement := new as TFhirType{4x}
  else if (propName = 'mustSupport') then replacePropertyValue('mustSupport', MustSupportList, existing, new) {2}
  else if (propName = 'codeFilter') then replacePropertyValue('codeFilter', CodeFilterList, existing, new) {2}
  else if (propName = 'dateFilter') then replacePropertyValue('dateFilter', DateFilterList, existing, new) {2}
  else if (propName = 'limit') then LimitElement := asPositiveInt(new){5b}
  else if (propName = 'sort') then replacePropertyValue('sort', SortList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDataRequirement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'profile') then ProfileList.move(source, destination){2}
  else if (propName = 'mustSupport') then MustSupportList.move(source, destination){2}
  else if (propName = 'codeFilter') then CodeFilterList.move(source, destination){2a}
  else if (propName = 'dateFilter') then DateFilterList.move(source, destination){2a}
  else if (propName = 'sort') then SortList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDataRequirement.fhirType : string;
begin
  result := 'DataRequirement';
end;

function TFhirDataRequirement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FprofileList) and isEmptyProp(FSubject) and isEmptyProp(FmustSupportList) and isEmptyProp(FcodeFilterList) and isEmptyProp(FdateFilterList) and isEmptyProp(FLimit) and isEmptyProp(FsortList);
end;

function TFhirDataRequirement.equals(other : TObject) : boolean; 
var
  o : TFhirDataRequirement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDataRequirement)) then
    result := false
  else
  begin
    o := TFhirDataRequirement(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(profileList, o.profileList, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(mustSupportList, o.mustSupportList, true) and 
      compareDeep(codeFilterList, o.codeFilterList, true) and compareDeep(dateFilterList, o.dateFilterList, true) and 
      compareDeep(limitElement, o.limitElement, true) and compareDeep(sortList, o.sortList, true);
  end;
end;

function TFhirDataRequirement.Link : TFhirDataRequirement;
begin
  result := TFhirDataRequirement(inherited Link);
end;

function TFhirDataRequirement.Clone : TFhirDataRequirement;
begin
  result := TFhirDataRequirement(inherited Clone);
end;

procedure TFhirDataRequirement.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('profile');
  fields.add('subject[x]');
  fields.add('mustSupport');
  fields.add('codeFilter');
  fields.add('dateFilter');
  fields.add('limit');
  fields.add('sort');
end;

{ TFhirDataRequirement }

Procedure TFhirDataRequirement.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirDataRequirement.GetType_ST : TFhirAllTypesEnum;
begin
  if FType_ = nil then
    result := TFhirAllTypesEnum(0)
  else
    result := TFhirAllTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirAllTypesEnum, FType_.value));
end;

Procedure TFhirDataRequirement.SetType_ST(value : TFhirAllTypesEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirAllTypesEnum[value], CODES_TFhirAllTypesEnum[value]);
end;

Function TFhirDataRequirement.GetProfileList : TFhirCanonicalList;
begin
  if FProfileList = nil then
    FProfileList := TFhirCanonicalList.Create;
  result := FProfileList;
end;

Function TFhirDataRequirement.GetHasProfileList : boolean;
begin
  result := (FProfileList <> nil) and (FProfileList.count > 0);
end;

Procedure TFhirDataRequirement.SetSubject(value : TFhirType);
begin
  FSubject.free;
  FSubject := value;
end;

Function TFhirDataRequirement.GetMustSupportList : TFhirStringList;
begin
  if FMustSupportList = nil then
    FMustSupportList := TFhirStringList.Create;
  result := FMustSupportList;
end;

Function TFhirDataRequirement.GetHasMustSupportList : boolean;
begin
  result := (FMustSupportList <> nil) and (FMustSupportList.count > 0);
end;

Function TFhirDataRequirement.GetCodeFilterList : TFhirDataRequirementCodeFilterList;
begin
  if FCodeFilterList = nil then
    FCodeFilterList := TFhirDataRequirementCodeFilterList.Create;
  result := FCodeFilterList;
end;

Function TFhirDataRequirement.GetHasCodeFilterList : boolean;
begin
  result := (FCodeFilterList <> nil) and (FCodeFilterList.count > 0);
end;

Function TFhirDataRequirement.GetDateFilterList : TFhirDataRequirementDateFilterList;
begin
  if FDateFilterList = nil then
    FDateFilterList := TFhirDataRequirementDateFilterList.Create;
  result := FDateFilterList;
end;

Function TFhirDataRequirement.GetHasDateFilterList : boolean;
begin
  result := (FDateFilterList <> nil) and (FDateFilterList.count > 0);
end;

Procedure TFhirDataRequirement.SetLimit(value : TFhirPositiveInt);
begin
  FLimit.free;
  FLimit := value;
end;

Function TFhirDataRequirement.GetLimitST : String;
begin
  if FLimit = nil then
    result := ''
  else
    result := FLimit.value;
end;

Procedure TFhirDataRequirement.SetLimitST(value : String);
begin
  if value <> '' then
  begin
    if FLimit = nil then
      FLimit := TFhirPositiveInt.create;
    FLimit.value := value
  end
  else if FLimit <> nil then
    FLimit.value := '';
end;

Function TFhirDataRequirement.GetSortList : TFhirDataRequirementSortList;
begin
  if FSortList = nil then
    FSortList := TFhirDataRequirementSortList.Create;
  result := FSortList;
end;

Function TFhirDataRequirement.GetHasSortList : boolean;
begin
  result := (FSortList <> nil) and (FSortList.count > 0);
end;

function TFhirDataRequirement.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FprofileList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FmustSupportList.sizeInBytes);
  inc(result, FcodeFilterList.sizeInBytes);
  inc(result, FdateFilterList.sizeInBytes);
  inc(result, FLimit.sizeInBytes);
  inc(result, FsortList.sizeInBytes);
end;

{ TFhirDataRequirementListEnumerator }

Constructor TFhirDataRequirementListEnumerator.Create(list : TFhirDataRequirementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDataRequirementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDataRequirementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDataRequirementListEnumerator.GetCurrent : TFhirDataRequirement;
begin
  Result := FList[FIndex];
end;

function TFhirDataRequirementListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDataRequirementList }
procedure TFhirDataRequirementList.AddItem(value: TFhirDataRequirement);
begin
  assert(value.ClassName = 'TFhirDataRequirement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDataRequirement');
  add(value);
end;

function TFhirDataRequirementList.Append: TFhirDataRequirement;
begin
  result := TFhirDataRequirement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDataRequirementList.ClearItems;
begin
  Clear;
end;

function TFhirDataRequirementList.GetEnumerator : TFhirDataRequirementListEnumerator;
begin
  result := TFhirDataRequirementListEnumerator.Create(self.link);
end;

function TFhirDataRequirementList.Clone: TFhirDataRequirementList;
begin
  result := TFhirDataRequirementList(inherited Clone);
end;

function TFhirDataRequirementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDataRequirementList.GetItemN(index: Integer): TFhirDataRequirement;
begin
  result := TFhirDataRequirement(ObjectByIndex[index]);
end;

function TFhirDataRequirementList.ItemClass: TFslObjectClass;
begin
  result := TFhirDataRequirement;
end;
function TFhirDataRequirementList.IndexOf(value: TFhirDataRequirement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDataRequirementList.Insert(index: Integer): TFhirDataRequirement;
begin
  result := TFhirDataRequirement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDataRequirementList.InsertItem(index: Integer; value: TFhirDataRequirement);
begin
  assert(value is TFhirDataRequirement);
  Inherited Insert(index, value);
end;

function TFhirDataRequirementList.Item(index: Integer): TFhirDataRequirement;
begin
  result := TFhirDataRequirement(ObjectByIndex[index]);
end;

function TFhirDataRequirementList.Link: TFhirDataRequirementList;
begin
  result := TFhirDataRequirementList(inherited Link);
end;

procedure TFhirDataRequirementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDataRequirementList.SetItemByIndex(index: Integer; value: TFhirDataRequirement);
begin
  assert(value is TFhirDataRequirement);
  FhirDataRequirements[index] := value;
end;

procedure TFhirDataRequirementList.SetItemN(index: Integer; value: TFhirDataRequirement);
begin
  assert(value is TFhirDataRequirement);
  ObjectByIndex[index] := value;
end;

{ TFhirDosageDoseAndRate }

constructor TFhirDosageDoseAndRate.Create;
begin
  inherited;
end;

destructor TFhirDosageDoseAndRate.Destroy;
begin
  FType_.free;
  FDose.free;
  FRate.free;
  inherited;
end;

procedure TFhirDosageDoseAndRate.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirDosageDoseAndRate(oSource).type_.Clone;
  dose := TFhirDosageDoseAndRate(oSource).dose.Clone;
  rate := TFhirDosageDoseAndRate(oSource).rate.Clone;
end;

procedure TFhirDosageDoseAndRate.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'dose[x]') or (child_name = 'dose') Then
     list.add(self.link, 'dose[x]', FDose.Link);
  if (child_name = 'rate[x]') or (child_name = 'rate') Then
     list.add(self.link, 'rate[x]', FRate.Link);
end;

procedure TFhirDosageDoseAndRate.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dose[x]', 'Range|Quantity', false, TFhirType, FDose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rate[x]', 'Ratio|Range|Quantity', false, TFhirType, FRate.Link));{2}
end;

function TFhirDosageDoseAndRate.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'dose', ['Range', 'Quantity'])) then
  begin
    Dose := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Range', 'Quantity'])) then
  begin
    Rate := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDosageDoseAndRate.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDosageDoseAndRate.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'dose', ['Range', 'Quantity'])) then raise EFHIRException.create('Cannot make property Dose'){4x}
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Range', 'Quantity'])) then raise EFHIRException.create('Cannot make property Rate'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDosageDoseAndRate.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'dose[x]') then result := 'Range|Quantity'
  else if (propName = 'rate[x]') then result := 'Ratio|Range|Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDosageDoseAndRate.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'dose', ['Range', 'Quantity'])) then DoseElement := nil{4x}
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Range', 'Quantity'])) then RateElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDosageDoseAndRate.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'dose', ['Range', 'Quantity'])) then DoseElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Range', 'Quantity'])) then RateElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDosageDoseAndRate.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDosageDoseAndRate.fhirType : string;
begin
  result := 'doseAndRate';
end;

function TFhirDosageDoseAndRate.Link : TFhirDosageDoseAndRate;
begin
  result := TFhirDosageDoseAndRate(inherited Link);
end;

function TFhirDosageDoseAndRate.Clone : TFhirDosageDoseAndRate;
begin
  result := TFhirDosageDoseAndRate(inherited Clone);
end;

function TFhirDosageDoseAndRate.equals(other : TObject) : boolean; 
var
  o : TFhirDosageDoseAndRate;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDosageDoseAndRate)) then
    result := false
  else
  begin
    o := TFhirDosageDoseAndRate(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(doseElement, o.doseElement, true) and 
      compareDeep(rateElement, o.rateElement, true);
  end;
end;

function TFhirDosageDoseAndRate.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FDose) and isEmptyProp(FRate);
end;

procedure TFhirDosageDoseAndRate.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('dose[x]');
  fields.add('rate[x]');
end;

{ TFhirDosageDoseAndRate }

Procedure TFhirDosageDoseAndRate.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirDosageDoseAndRate.SetDose(value : TFhirType);
begin
  FDose.free;
  FDose := value;
end;

Procedure TFhirDosageDoseAndRate.SetRate(value : TFhirType);
begin
  FRate.free;
  FRate := value;
end;

function TFhirDosageDoseAndRate.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FDose.sizeInBytes);
  inc(result, FRate.sizeInBytes);
end;

{ TFhirDosageDoseAndRateListEnumerator }

Constructor TFhirDosageDoseAndRateListEnumerator.Create(list : TFhirDosageDoseAndRateList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDosageDoseAndRateListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDosageDoseAndRateListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDosageDoseAndRateListEnumerator.GetCurrent : TFhirDosageDoseAndRate;
begin
  Result := FList[FIndex];
end;

function TFhirDosageDoseAndRateListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDosageDoseAndRateList }
procedure TFhirDosageDoseAndRateList.AddItem(value: TFhirDosageDoseAndRate);
begin
  assert(value.ClassName = 'TFhirDosageDoseAndRate', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDosageDoseAndRate');
  add(value);
end;

function TFhirDosageDoseAndRateList.Append: TFhirDosageDoseAndRate;
begin
  result := TFhirDosageDoseAndRate.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDosageDoseAndRateList.ClearItems;
begin
  Clear;
end;

function TFhirDosageDoseAndRateList.GetEnumerator : TFhirDosageDoseAndRateListEnumerator;
begin
  result := TFhirDosageDoseAndRateListEnumerator.Create(self.link);
end;

function TFhirDosageDoseAndRateList.Clone: TFhirDosageDoseAndRateList;
begin
  result := TFhirDosageDoseAndRateList(inherited Clone);
end;

function TFhirDosageDoseAndRateList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDosageDoseAndRateList.GetItemN(index: Integer): TFhirDosageDoseAndRate;
begin
  result := TFhirDosageDoseAndRate(ObjectByIndex[index]);
end;

function TFhirDosageDoseAndRateList.ItemClass: TFslObjectClass;
begin
  result := TFhirDosageDoseAndRate;
end;
function TFhirDosageDoseAndRateList.IndexOf(value: TFhirDosageDoseAndRate): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDosageDoseAndRateList.Insert(index: Integer): TFhirDosageDoseAndRate;
begin
  result := TFhirDosageDoseAndRate.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDosageDoseAndRateList.InsertItem(index: Integer; value: TFhirDosageDoseAndRate);
begin
  assert(value is TFhirDosageDoseAndRate);
  Inherited Insert(index, value);
end;

function TFhirDosageDoseAndRateList.Item(index: Integer): TFhirDosageDoseAndRate;
begin
  result := TFhirDosageDoseAndRate(ObjectByIndex[index]);
end;

function TFhirDosageDoseAndRateList.Link: TFhirDosageDoseAndRateList;
begin
  result := TFhirDosageDoseAndRateList(inherited Link);
end;

procedure TFhirDosageDoseAndRateList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDosageDoseAndRateList.SetItemByIndex(index: Integer; value: TFhirDosageDoseAndRate);
begin
  assert(value is TFhirDosageDoseAndRate);
  FhirDosageDoseAndRates[index] := value;
end;

procedure TFhirDosageDoseAndRateList.SetItemN(index: Integer; value: TFhirDosageDoseAndRate);
begin
  assert(value is TFhirDosageDoseAndRate);
  ObjectByIndex[index] := value;
end;

{ TFhirDosage }

constructor TFhirDosage.Create;
begin
  inherited;
end;

destructor TFhirDosage.Destroy;
begin
  FSequence.free;
  FText.free;
  FAdditionalInstructionList.Free;
  FPatientInstruction.free;
  FTiming.free;
  FAsNeeded.free;
  FSite.free;
  FRoute.free;
  FMethod.free;
  FDoseAndRateList.Free;
  FMaxDosePerPeriod.free;
  FMaxDosePerAdministration.free;
  FMaxDosePerLifetime.free;
  inherited;
end;

procedure TFhirDosage.Assign(oSource : TFslObject);
begin
  inherited;
  sequenceElement := TFhirDosage(oSource).sequenceElement.Clone;
  textElement := TFhirDosage(oSource).textElement.Clone;
  if (TFhirDosage(oSource).FAdditionalInstructionList = nil) then
  begin
    FAdditionalInstructionList.free;
    FAdditionalInstructionList := nil;
  end
  else
  begin
    if FAdditionalInstructionList = nil then
      FAdditionalInstructionList := TFhirCodeableConceptList.Create;
    FAdditionalInstructionList.Assign(TFhirDosage(oSource).FAdditionalInstructionList);
  end;
  patientInstructionElement := TFhirDosage(oSource).patientInstructionElement.Clone;
  timing := TFhirDosage(oSource).timing.Clone;
  asNeeded := TFhirDosage(oSource).asNeeded.Clone;
  site := TFhirDosage(oSource).site.Clone;
  route := TFhirDosage(oSource).route.Clone;
  method := TFhirDosage(oSource).method.Clone;
  if (TFhirDosage(oSource).FDoseAndRateList = nil) then
  begin
    FDoseAndRateList.free;
    FDoseAndRateList := nil;
  end
  else
  begin
    if FDoseAndRateList = nil then
      FDoseAndRateList := TFhirDosageDoseAndRateList.Create;
    FDoseAndRateList.Assign(TFhirDosage(oSource).FDoseAndRateList);
  end;
  maxDosePerPeriod := TFhirDosage(oSource).maxDosePerPeriod.Clone;
  maxDosePerAdministration := TFhirDosage(oSource).maxDosePerAdministration.Clone;
  maxDosePerLifetime := TFhirDosage(oSource).maxDosePerLifetime.Clone;
end;

procedure TFhirDosage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'additionalInstruction') Then
    list.addAll(self, 'additionalInstruction', FAdditionalInstructionList);
  if (child_name = 'patientInstruction') Then
     list.add(self.link, 'patientInstruction', FPatientInstruction.Link);
  if (child_name = 'timing') Then
     list.add(self.link, 'timing', FTiming.Link);
  if (child_name = 'asNeeded[x]') or (child_name = 'asNeeded') Then
     list.add(self.link, 'asNeeded[x]', FAsNeeded.Link);
  if (child_name = 'site') Then
     list.add(self.link, 'site', FSite.Link);
  if (child_name = 'route') Then
     list.add(self.link, 'route', FRoute.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'doseAndRate') Then
    list.addAll(self, 'doseAndRate', FDoseAndRateList);
  if (child_name = 'maxDosePerPeriod') Then
     list.add(self.link, 'maxDosePerPeriod', FMaxDosePerPeriod.Link);
  if (child_name = 'maxDosePerAdministration') Then
     list.add(self.link, 'maxDosePerAdministration', FMaxDosePerAdministration.Link);
  if (child_name = 'maxDosePerLifetime') Then
     list.add(self.link, 'maxDosePerLifetime', FMaxDosePerLifetime.Link);
end;

procedure TFhirDosage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sequence', 'integer', false, TFhirInteger, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additionalInstruction', 'CodeableConcept', true, TFhirCodeableConcept, FAdditionalInstructionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'patientInstruction', 'string', false, TFhirString, FPatientInstruction.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing', 'Timing', false, TFhirTiming, FTiming.Link));{2}
  oList.add(TFHIRProperty.create(self, 'asNeeded[x]', 'boolean|CodeableConcept', false, TFhirType, FAsNeeded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site', 'CodeableConcept', false, TFhirCodeableConcept, FSite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', false, TFhirCodeableConcept, FRoute.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseAndRate', '', true, TFhirDosageDoseAndRate, FDoseAndRateList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'maxDosePerPeriod', 'Ratio', false, TFhirRatio, FMaxDosePerPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxDosePerAdministration', 'Quantity', false, TFhirQuantity, FMaxDosePerAdministration.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxDosePerLifetime', 'Quantity', false, TFhirQuantity, FMaxDosePerLifetime.Link));{2}
end;

function TFhirDosage.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sequence') then
  begin
    SequenceElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'additionalInstruction') then
  begin
    AdditionalInstructionList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'patientInstruction') then
  begin
    PatientInstructionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'timing') then
  begin
    Timing := propValue as TFhirTiming{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then
  begin
    AsNeeded := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'site') then
  begin
    Site := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'route') then
  begin
    Route := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'doseAndRate') then
  begin
    DoseAndRateList.add(propValue as TFhirDosageDoseAndRate){2a};
    result := propValue;
  end
  else if (propName = 'maxDosePerPeriod') then
  begin
    MaxDosePerPeriod := propValue as TFhirRatio{4b};
    result := propValue;
  end
  else if (propName = 'maxDosePerAdministration') then
  begin
    MaxDosePerAdministration := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'maxDosePerLifetime') then
  begin
    MaxDosePerLifetime := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirDosage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'additionalInstruction') then AdditionalInstructionList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'doseAndRate') then DoseAndRateList.insertItem(index, propValue as TFhirDosageDoseAndRate){2a}
  else inherited;
end;

function TFhirDosage.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'sequence') then result := TFhirInteger.create() {5b}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'additionalInstruction') then result := AdditionalInstructionList.new(){2}
  else if (propName = 'patientInstruction') then result := TFhirString.create() {5b}
  else if (propName = 'timing') then result := TFhirTiming.create(){4b}
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property AsNeeded'){4x}
  else if (propName = 'site') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'route') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'method') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'doseAndRate') then result := DoseAndRateList.new(){2}
  else if (propName = 'maxDosePerPeriod') then result := TFhirRatio.create(){4b}
  else if (propName = 'maxDosePerAdministration') then result := TFhirQuantity.create(){4b}
  else if (propName = 'maxDosePerLifetime') then result := TFhirQuantity.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDosage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sequence') then result := 'integer'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'additionalInstruction') then result := 'CodeableConcept'
  else if (propName = 'patientInstruction') then result := 'string'
  else if (propName = 'timing') then result := 'Timing'
  else if (propName = 'asNeeded[x]') then result := 'boolean|CodeableConcept'
  else if (propName = 'site') then result := 'CodeableConcept'
  else if (propName = 'route') then result := 'CodeableConcept'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'doseAndRate') then result := ''
  else if (propName = 'maxDosePerPeriod') then result := 'Ratio'
  else if (propName = 'maxDosePerAdministration') then result := 'Quantity'
  else if (propName = 'maxDosePerLifetime') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDosage.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'additionalInstruction') then deletePropertyValue('additionalInstruction', AdditionalInstructionList, value) {2}
  else if (propName = 'patientInstruction') then PatientInstructionElement := nil
  else if (propName = 'timing') then TimingElement := nil
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then AsNeededElement := nil{4x}
  else if (propName = 'site') then SiteElement := nil
  else if (propName = 'route') then RouteElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'doseAndRate') then deletePropertyValue('doseAndRate', DoseAndRateList, value) {2}
  else if (propName = 'maxDosePerPeriod') then MaxDosePerPeriodElement := nil
  else if (propName = 'maxDosePerAdministration') then MaxDosePerAdministrationElement := nil
  else if (propName = 'maxDosePerLifetime') then MaxDosePerLifetimeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDosage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sequence') then SequenceElement := asInteger(new){5b}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'additionalInstruction') then replacePropertyValue('additionalInstruction', AdditionalInstructionList, existing, new) {2}
  else if (propName = 'patientInstruction') then PatientInstructionElement := asString(new){5b}
  else if (propName = 'timing') then TimingElement := new as TFhirTiming{4}
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then AsNeededElement := new as TFhirType{4x}
  else if (propName = 'site') then SiteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'route') then RouteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept{4}
  else if (propName = 'doseAndRate') then replacePropertyValue('doseAndRate', DoseAndRateList, existing, new) {2}
  else if (propName = 'maxDosePerPeriod') then MaxDosePerPeriodElement := new as TFhirRatio{4}
  else if (propName = 'maxDosePerAdministration') then MaxDosePerAdministrationElement := new as TFhirQuantity{4}
  else if (propName = 'maxDosePerLifetime') then MaxDosePerLifetimeElement := new as TFhirQuantity{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDosage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'additionalInstruction') then AdditionalInstructionList.move(source, destination){2a}
  else if (propName = 'doseAndRate') then DoseAndRateList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDosage.fhirType : string;
begin
  result := 'Dosage';
end;

function TFhirDosage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSequence) and isEmptyProp(FText) and isEmptyProp(FadditionalInstructionList) and isEmptyProp(FPatientInstruction) and isEmptyProp(FTiming) and isEmptyProp(FAsNeeded) and isEmptyProp(FSite) and isEmptyProp(FRoute) and isEmptyProp(FMethod) and isEmptyProp(FdoseAndRateList) and isEmptyProp(FMaxDosePerPeriod) and isEmptyProp(FMaxDosePerAdministration) and isEmptyProp(FMaxDosePerLifetime);
end;

function TFhirDosage.equals(other : TObject) : boolean; 
var
  o : TFhirDosage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDosage)) then
    result := false
  else
  begin
    o := TFhirDosage(other);
    result := compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(textElement, o.textElement, true) and 
      compareDeep(additionalInstructionList, o.additionalInstructionList, true) and 
      compareDeep(patientInstructionElement, o.patientInstructionElement, true) and 
      compareDeep(timingElement, o.timingElement, true) and compareDeep(asNeededElement, o.asNeededElement, true) and 
      compareDeep(siteElement, o.siteElement, true) and compareDeep(routeElement, o.routeElement, true) and 
      compareDeep(methodElement, o.methodElement, true) and compareDeep(doseAndRateList, o.doseAndRateList, true) and 
      compareDeep(maxDosePerPeriodElement, o.maxDosePerPeriodElement, true) and compareDeep(maxDosePerAdministrationElement, o.maxDosePerAdministrationElement, true) and 
      compareDeep(maxDosePerLifetimeElement, o.maxDosePerLifetimeElement, true);
  end;
end;

function TFhirDosage.Link : TFhirDosage;
begin
  result := TFhirDosage(inherited Link);
end;

function TFhirDosage.Clone : TFhirDosage;
begin
  result := TFhirDosage(inherited Clone);
end;

procedure TFhirDosage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneTypeFieldsInOrder(fields);
  fields.add('sequence');
  fields.add('text');
  fields.add('additionalInstruction');
  fields.add('patientInstruction');
  fields.add('timing');
  fields.add('asNeeded[x]');
  fields.add('site');
  fields.add('route');
  fields.add('method');
  fields.add('doseAndRate');
  fields.add('maxDosePerPeriod');
  fields.add('maxDosePerAdministration');
  fields.add('maxDosePerLifetime');
end;

{ TFhirDosage }

Procedure TFhirDosage.SetSequence(value : TFhirInteger);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirDosage.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirDosage.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirInteger.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirDosage.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirDosage.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirDosage.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Function TFhirDosage.GetAdditionalInstructionList : TFhirCodeableConceptList;
begin
  if FAdditionalInstructionList = nil then
    FAdditionalInstructionList := TFhirCodeableConceptList.Create;
  result := FAdditionalInstructionList;
end;

Function TFhirDosage.GetHasAdditionalInstructionList : boolean;
begin
  result := (FAdditionalInstructionList <> nil) and (FAdditionalInstructionList.count > 0);
end;

Procedure TFhirDosage.SetPatientInstruction(value : TFhirString);
begin
  FPatientInstruction.free;
  FPatientInstruction := value;
end;

Function TFhirDosage.GetPatientInstructionST : String;
begin
  if FPatientInstruction = nil then
    result := ''
  else
    result := FPatientInstruction.value;
end;

Procedure TFhirDosage.SetPatientInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FPatientInstruction = nil then
      FPatientInstruction := TFhirString.create;
    FPatientInstruction.value := value
  end
  else if FPatientInstruction <> nil then
    FPatientInstruction.value := '';
end;

Procedure TFhirDosage.SetTiming(value : TFhirTiming);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirDosage.SetAsNeeded(value : TFhirType);
begin
  FAsNeeded.free;
  FAsNeeded := value;
end;

Procedure TFhirDosage.SetSite(value : TFhirCodeableConcept);
begin
  FSite.free;
  FSite := value;
end;

Procedure TFhirDosage.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

Procedure TFhirDosage.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Function TFhirDosage.GetDoseAndRateList : TFhirDosageDoseAndRateList;
begin
  if FDoseAndRateList = nil then
    FDoseAndRateList := TFhirDosageDoseAndRateList.Create;
  result := FDoseAndRateList;
end;

Function TFhirDosage.GetHasDoseAndRateList : boolean;
begin
  result := (FDoseAndRateList <> nil) and (FDoseAndRateList.count > 0);
end;

Procedure TFhirDosage.SetMaxDosePerPeriod(value : TFhirRatio);
begin
  FMaxDosePerPeriod.free;
  FMaxDosePerPeriod := value;
end;

Procedure TFhirDosage.SetMaxDosePerAdministration(value : TFhirQuantity);
begin
  FMaxDosePerAdministration.free;
  FMaxDosePerAdministration := value;
end;

Procedure TFhirDosage.SetMaxDosePerLifetime(value : TFhirQuantity);
begin
  FMaxDosePerLifetime.free;
  FMaxDosePerLifetime := value;
end;

function TFhirDosage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSequence.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FadditionalInstructionList.sizeInBytes);
  inc(result, FPatientInstruction.sizeInBytes);
  inc(result, FTiming.sizeInBytes);
  inc(result, FAsNeeded.sizeInBytes);
  inc(result, FSite.sizeInBytes);
  inc(result, FRoute.sizeInBytes);
  inc(result, FMethod.sizeInBytes);
  inc(result, FdoseAndRateList.sizeInBytes);
  inc(result, FMaxDosePerPeriod.sizeInBytes);
  inc(result, FMaxDosePerAdministration.sizeInBytes);
  inc(result, FMaxDosePerLifetime.sizeInBytes);
end;

{ TFhirDosageListEnumerator }

Constructor TFhirDosageListEnumerator.Create(list : TFhirDosageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDosageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDosageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDosageListEnumerator.GetCurrent : TFhirDosage;
begin
  Result := FList[FIndex];
end;

function TFhirDosageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDosageList }
procedure TFhirDosageList.AddItem(value: TFhirDosage);
begin
  assert(value.ClassName = 'TFhirDosage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDosage');
  add(value);
end;

function TFhirDosageList.Append: TFhirDosage;
begin
  result := TFhirDosage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDosageList.ClearItems;
begin
  Clear;
end;

function TFhirDosageList.GetEnumerator : TFhirDosageListEnumerator;
begin
  result := TFhirDosageListEnumerator.Create(self.link);
end;

function TFhirDosageList.Clone: TFhirDosageList;
begin
  result := TFhirDosageList(inherited Clone);
end;

function TFhirDosageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDosageList.GetItemN(index: Integer): TFhirDosage;
begin
  result := TFhirDosage(ObjectByIndex[index]);
end;

function TFhirDosageList.ItemClass: TFslObjectClass;
begin
  result := TFhirDosage;
end;
function TFhirDosageList.IndexOf(value: TFhirDosage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDosageList.Insert(index: Integer): TFhirDosage;
begin
  result := TFhirDosage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDosageList.InsertItem(index: Integer; value: TFhirDosage);
begin
  assert(value is TFhirDosage);
  Inherited Insert(index, value);
end;

function TFhirDosageList.Item(index: Integer): TFhirDosage;
begin
  result := TFhirDosage(ObjectByIndex[index]);
end;

function TFhirDosageList.Link: TFhirDosageList;
begin
  result := TFhirDosageList(inherited Link);
end;

procedure TFhirDosageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDosageList.SetItemByIndex(index: Integer; value: TFhirDosage);
begin
  assert(value is TFhirDosage);
  FhirDosages[index] := value;
end;

procedure TFhirDosageList.SetItemN(index: Integer; value: TFhirDosage);
begin
  assert(value is TFhirDosage);
  ObjectByIndex[index] := value;
end;

{ TFhirMoney }

constructor TFhirMoney.Create;
begin
  inherited;
end;

destructor TFhirMoney.Destroy;
begin
  FValue.free;
  FCurrency.free;
  inherited;
end;

procedure TFhirMoney.Assign(oSource : TFslObject);
begin
  inherited;
  valueElement := TFhirMoney(oSource).valueElement.Clone;
  currencyElement := TFhirMoney(oSource).currencyElement.Clone;
end;

procedure TFhirMoney.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'currency') Then
     list.add(self.link, 'currency', FCurrency.Link);
end;

procedure TFhirMoney.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value', 'decimal', false, TFhirDecimal, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'currency', 'code', false, TFhirCode, FCurrency.Link));{2}
end;

function TFhirMoney.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'value') then
  begin
    ValueElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'currency') then
  begin
    CurrencyElement := asCode(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMoney.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMoney.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'value') then result := TFhirDecimal.create() {5b}
  else if (propName = 'currency') then result := TFhirCode.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMoney.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value') then result := 'decimal'
  else if (propName = 'currency') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMoney.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := nil
  else if (propName = 'currency') then CurrencyElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMoney.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := asDecimal(new){5b}
  else if (propName = 'currency') then CurrencyElement := asCode(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMoney.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMoney.fhirType : string;
begin
  result := 'Money';
end;

function TFhirMoney.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue) and isEmptyProp(FCurrency);
end;

function TFhirMoney.equals(other : TObject) : boolean; 
var
  o : TFhirMoney;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMoney)) then
    result := false
  else
  begin
    o := TFhirMoney(other);
    result := compareDeep(valueElement, o.valueElement, true) and compareDeep(currencyElement, o.currencyElement, true);
  end;
end;

function TFhirMoney.Link : TFhirMoney;
begin
  result := TFhirMoney(inherited Link);
end;

function TFhirMoney.Clone : TFhirMoney;
begin
  result := TFhirMoney(inherited Clone);
end;

procedure TFhirMoney.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('value');
  fields.add('currency');
end;

{ TFhirMoney }

Procedure TFhirMoney.SetValue(value : TFhirDecimal);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirMoney.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirMoney.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirDecimal.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

Procedure TFhirMoney.SetCurrency(value : TFhirCode);
begin
  FCurrency.free;
  FCurrency := value;
end;

Function TFhirMoney.GetCurrencyST : String;
begin
  if FCurrency = nil then
    result := ''
  else
    result := FCurrency.value;
end;

Procedure TFhirMoney.SetCurrencyST(value : String);
begin
  if value <> '' then
  begin
    if FCurrency = nil then
      FCurrency := TFhirCode.create;
    FCurrency.value := value
  end
  else if FCurrency <> nil then
    FCurrency.value := '';
end;

function TFhirMoney.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FValue.sizeInBytes);
  inc(result, FCurrency.sizeInBytes);
end;

{ TFhirMoneyListEnumerator }

Constructor TFhirMoneyListEnumerator.Create(list : TFhirMoneyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMoneyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMoneyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMoneyListEnumerator.GetCurrent : TFhirMoney;
begin
  Result := FList[FIndex];
end;

function TFhirMoneyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMoneyList }
procedure TFhirMoneyList.AddItem(value: TFhirMoney);
begin
  assert(value.ClassName = 'TFhirMoney', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMoney');
  add(value);
end;

function TFhirMoneyList.Append: TFhirMoney;
begin
  result := TFhirMoney.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMoneyList.ClearItems;
begin
  Clear;
end;

function TFhirMoneyList.GetEnumerator : TFhirMoneyListEnumerator;
begin
  result := TFhirMoneyListEnumerator.Create(self.link);
end;

function TFhirMoneyList.Clone: TFhirMoneyList;
begin
  result := TFhirMoneyList(inherited Clone);
end;

function TFhirMoneyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMoneyList.GetItemN(index: Integer): TFhirMoney;
begin
  result := TFhirMoney(ObjectByIndex[index]);
end;

function TFhirMoneyList.ItemClass: TFslObjectClass;
begin
  result := TFhirMoney;
end;
function TFhirMoneyList.IndexOf(value: TFhirMoney): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMoneyList.Insert(index: Integer): TFhirMoney;
begin
  result := TFhirMoney.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMoneyList.InsertItem(index: Integer; value: TFhirMoney);
begin
  assert(value is TFhirMoney);
  Inherited Insert(index, value);
end;

function TFhirMoneyList.Item(index: Integer): TFhirMoney;
begin
  result := TFhirMoney(ObjectByIndex[index]);
end;

function TFhirMoneyList.Link: TFhirMoneyList;
begin
  result := TFhirMoneyList(inherited Link);
end;

procedure TFhirMoneyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMoneyList.SetItemByIndex(index: Integer; value: TFhirMoney);
begin
  assert(value is TFhirMoney);
  FhirMoneys[index] := value;
end;

procedure TFhirMoneyList.SetItemN(index: Integer; value: TFhirMoney);
begin
  assert(value is TFhirMoney);
  ObjectByIndex[index] := value;
end;

{ TFhirMarketingStatus }

constructor TFhirMarketingStatus.Create;
begin
  inherited;
end;

destructor TFhirMarketingStatus.Destroy;
begin
  FCountry.free;
  FJurisdiction.free;
  FStatus.free;
  FDateRange.free;
  FRestoreDate.free;
  inherited;
end;

procedure TFhirMarketingStatus.Assign(oSource : TFslObject);
begin
  inherited;
  country := TFhirMarketingStatus(oSource).country.Clone;
  jurisdiction := TFhirMarketingStatus(oSource).jurisdiction.Clone;
  status := TFhirMarketingStatus(oSource).status.Clone;
  dateRange := TFhirMarketingStatus(oSource).dateRange.Clone;
  restoreDateElement := TFhirMarketingStatus(oSource).restoreDateElement.Clone;
end;

procedure TFhirMarketingStatus.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'country') Then
     list.add(self.link, 'country', FCountry.Link);
  if (child_name = 'jurisdiction') Then
     list.add(self.link, 'jurisdiction', FJurisdiction.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'dateRange') Then
     list.add(self.link, 'dateRange', FDateRange.Link);
  if (child_name = 'restoreDate') Then
     list.add(self.link, 'restoreDate', FRestoreDate.Link);
end;

procedure TFhirMarketingStatus.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'country', 'CodeableConcept', false, TFhirCodeableConcept, FCountry.Link));{2}
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', false, TFhirCodeableConcept, FJurisdiction.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateRange', 'Period', false, TFhirPeriod, FDateRange.Link));{2}
  oList.add(TFHIRProperty.create(self, 'restoreDate', 'dateTime', false, TFhirDateTime, FRestoreDate.Link));{2}
end;

function TFhirMarketingStatus.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'country') then
  begin
    Country := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    Jurisdiction := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'dateRange') then
  begin
    DateRange := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'restoreDate') then
  begin
    RestoreDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMarketingStatus.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMarketingStatus.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'country') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'jurisdiction') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'status') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'dateRange') then result := TFhirPeriod.create(){4b}
  else if (propName = 'restoreDate') then result := TFhirDateTime.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMarketingStatus.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'country') then result := 'CodeableConcept'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'dateRange') then result := 'Period'
  else if (propName = 'restoreDate') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMarketingStatus.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'country') then CountryElement := nil
  else if (propName = 'jurisdiction') then JurisdictionElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'dateRange') then DateRangeElement := nil
  else if (propName = 'restoreDate') then RestoreDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMarketingStatus.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'country') then CountryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'jurisdiction') then JurisdictionElement := new as TFhirCodeableConcept{4}
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept{4}
  else if (propName = 'dateRange') then DateRangeElement := new as TFhirPeriod{4}
  else if (propName = 'restoreDate') then RestoreDateElement := asDateTime(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMarketingStatus.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMarketingStatus.fhirType : string;
begin
  result := 'MarketingStatus';
end;

function TFhirMarketingStatus.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCountry) and isEmptyProp(FJurisdiction) and isEmptyProp(FStatus) and isEmptyProp(FDateRange) and isEmptyProp(FRestoreDate);
end;

function TFhirMarketingStatus.equals(other : TObject) : boolean; 
var
  o : TFhirMarketingStatus;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMarketingStatus)) then
    result := false
  else
  begin
    o := TFhirMarketingStatus(other);
    result := compareDeep(countryElement, o.countryElement, true) and compareDeep(jurisdictionElement, o.jurisdictionElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(dateRangeElement, o.dateRangeElement, true) and 
      compareDeep(restoreDateElement, o.restoreDateElement, true);
  end;
end;

function TFhirMarketingStatus.Link : TFhirMarketingStatus;
begin
  result := TFhirMarketingStatus(inherited Link);
end;

function TFhirMarketingStatus.Clone : TFhirMarketingStatus;
begin
  result := TFhirMarketingStatus(inherited Clone);
end;

procedure TFhirMarketingStatus.listFieldsInOrder(fields : TStringList);
begin
  listBackboneTypeFieldsInOrder(fields);
  fields.add('country');
  fields.add('jurisdiction');
  fields.add('status');
  fields.add('dateRange');
  fields.add('restoreDate');
end;

{ TFhirMarketingStatus }

Procedure TFhirMarketingStatus.SetCountry(value : TFhirCodeableConcept);
begin
  FCountry.free;
  FCountry := value;
end;

Procedure TFhirMarketingStatus.SetJurisdiction(value : TFhirCodeableConcept);
begin
  FJurisdiction.free;
  FJurisdiction := value;
end;

Procedure TFhirMarketingStatus.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

Procedure TFhirMarketingStatus.SetDateRange(value : TFhirPeriod);
begin
  FDateRange.free;
  FDateRange := value;
end;

Procedure TFhirMarketingStatus.SetRestoreDate(value : TFhirDateTime);
begin
  FRestoreDate.free;
  FRestoreDate := value;
end;

Function TFhirMarketingStatus.GetRestoreDateST : TFslDateTime;
begin
  if FRestoreDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FRestoreDate.value;
end;

Procedure TFhirMarketingStatus.SetRestoreDateST(value : TFslDateTime);
begin
  if FRestoreDate = nil then
    FRestoreDate := TFhirDateTime.create;
  FRestoreDate.value := value
end;

function TFhirMarketingStatus.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCountry.sizeInBytes);
  inc(result, FJurisdiction.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FDateRange.sizeInBytes);
  inc(result, FRestoreDate.sizeInBytes);
end;

{ TFhirMarketingStatusListEnumerator }

Constructor TFhirMarketingStatusListEnumerator.Create(list : TFhirMarketingStatusList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMarketingStatusListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMarketingStatusListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMarketingStatusListEnumerator.GetCurrent : TFhirMarketingStatus;
begin
  Result := FList[FIndex];
end;

function TFhirMarketingStatusListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMarketingStatusList }
procedure TFhirMarketingStatusList.AddItem(value: TFhirMarketingStatus);
begin
  assert(value.ClassName = 'TFhirMarketingStatus', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMarketingStatus');
  add(value);
end;

function TFhirMarketingStatusList.Append: TFhirMarketingStatus;
begin
  result := TFhirMarketingStatus.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMarketingStatusList.ClearItems;
begin
  Clear;
end;

function TFhirMarketingStatusList.GetEnumerator : TFhirMarketingStatusListEnumerator;
begin
  result := TFhirMarketingStatusListEnumerator.Create(self.link);
end;

function TFhirMarketingStatusList.Clone: TFhirMarketingStatusList;
begin
  result := TFhirMarketingStatusList(inherited Clone);
end;

function TFhirMarketingStatusList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMarketingStatusList.GetItemN(index: Integer): TFhirMarketingStatus;
begin
  result := TFhirMarketingStatus(ObjectByIndex[index]);
end;

function TFhirMarketingStatusList.ItemClass: TFslObjectClass;
begin
  result := TFhirMarketingStatus;
end;
function TFhirMarketingStatusList.IndexOf(value: TFhirMarketingStatus): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMarketingStatusList.Insert(index: Integer): TFhirMarketingStatus;
begin
  result := TFhirMarketingStatus.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMarketingStatusList.InsertItem(index: Integer; value: TFhirMarketingStatus);
begin
  assert(value is TFhirMarketingStatus);
  Inherited Insert(index, value);
end;

function TFhirMarketingStatusList.Item(index: Integer): TFhirMarketingStatus;
begin
  result := TFhirMarketingStatus(ObjectByIndex[index]);
end;

function TFhirMarketingStatusList.Link: TFhirMarketingStatusList;
begin
  result := TFhirMarketingStatusList(inherited Link);
end;

procedure TFhirMarketingStatusList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMarketingStatusList.SetItemByIndex(index: Integer; value: TFhirMarketingStatus);
begin
  assert(value is TFhirMarketingStatus);
  FhirMarketingStatuses[index] := value;
end;

procedure TFhirMarketingStatusList.SetItemN(index: Integer; value: TFhirMarketingStatus);
begin
  assert(value is TFhirMarketingStatus);
  ObjectByIndex[index] := value;
end;

function TFhirIdentifierUseEnumListAsInteger(aSet : TFhirIdentifierUseEnumList) : Integer;
var
  a : TFhirIdentifierUseEnum;
begin
  result := 0;
  for a := low(TFhirIdentifierUseEnum) to high(TFhirIdentifierUseEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirIdentifierUseEnumList(i : Integer) : TFhirIdentifierUseEnumList;
var
  aLoop : TFhirIdentifierUseEnum;
begin
  result := [];
  for aLoop := low(TFhirIdentifierUseEnum) to high(TFhirIdentifierUseEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

{ TFhirIdentifier }

constructor TFhirIdentifier.Create;
begin
  inherited;
end;

destructor TFhirIdentifier.Destroy;
begin
  FUse.free;
  FType_.free;
  FSystem.free;
  FValue.free;
  FPeriod.free;
  FAssigner.free;
  inherited;
end;

procedure TFhirIdentifier.Assign(oSource : TFslObject);
begin
  inherited;
  FUse := TFhirIdentifier(oSource).FUse.Link;
  type_ := TFhirIdentifier(oSource).type_.Clone;
  systemElement := TFhirIdentifier(oSource).systemElement.Clone;
  valueElement := TFhirIdentifier(oSource).valueElement.Clone;
  period := TFhirIdentifier(oSource).period.Clone;
  assigner := TFhirIdentifier(oSource).assigner.Clone;
end;

procedure TFhirIdentifier.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'system') Then
     list.add(self.link, 'system', FSystem.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'assigner') Then
     list.add(self.link, 'assigner', FAssigner.Link);
end;

procedure TFhirIdentifier.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'use', 'code', false, TFHIREnum, FUse.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'system', 'uri', false, TFhirUri, FSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'assigner', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FAssigner.Link));{2}
end;

function TFhirIdentifier.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'use') then
  begin
    UseElement := asEnum(SYSTEMS_TFhirIdentifierUseEnum, CODES_TFhirIdentifierUseEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'system') then
  begin
    SystemElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'assigner') then
  begin
    Assigner := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirIdentifier.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirIdentifier.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'system') then result := TFhirUri.create() {5b}
  else if (propName = 'value') then result := TFhirString.create() {5b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'assigner') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirIdentifier.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'use') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'system') then result := 'uri'
  else if (propName = 'value') then result := 'string'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'assigner') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirIdentifier.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'use') then UseElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'system') then SystemElement := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'assigner') then AssignerElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirIdentifier.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'use') then UseElement := asEnum(SYSTEMS_TFhirIdentifierUseEnum, CODES_TFhirIdentifierUseEnum, new){4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'system') then SystemElement := asUri(new){5b}
  else if (propName = 'value') then ValueElement := asString(new){5b}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'assigner') then AssignerElement := new as TFhirReference{TFhirOrganization}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirIdentifier.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirIdentifier.fhirType : string;
begin
  result := 'Identifier';
end;

function TFhirIdentifier.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUse) and isEmptyProp(FType_) and isEmptyProp(FSystem) and isEmptyProp(FValue) and isEmptyProp(FPeriod) and isEmptyProp(FAssigner);
end;

function TFhirIdentifier.equals(other : TObject) : boolean; 
var
  o : TFhirIdentifier;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirIdentifier)) then
    result := false
  else
  begin
    o := TFhirIdentifier(other);
    result := compareDeep(useElement, o.useElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(systemElement, o.systemElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(assignerElement, o.assignerElement, true);
  end;
end;

function TFhirIdentifier.Link : TFhirIdentifier;
begin
  result := TFhirIdentifier(inherited Link);
end;

function TFhirIdentifier.Clone : TFhirIdentifier;
begin
  result := TFhirIdentifier(inherited Clone);
end;

procedure TFhirIdentifier.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('use');
  fields.add('type');
  fields.add('system');
  fields.add('value');
  fields.add('period');
  fields.add('assigner');
end;

{ TFhirIdentifier }

Procedure TFhirIdentifier.SetUse(value : TFhirEnum);
begin
  FUse.free;
  FUse := value;
end;

Function TFhirIdentifier.GetUseST : TFhirIdentifierUseEnum;
begin
  if FUse = nil then
    result := TFhirIdentifierUseEnum(0)
  else
    result := TFhirIdentifierUseEnum(StringArrayIndexOfSensitive(CODES_TFhirIdentifierUseEnum, FUse.value));
end;

Procedure TFhirIdentifier.SetUseST(value : TFhirIdentifierUseEnum);
begin
  if ord(value) = 0 then
    UseElement := nil
  else
    UseElement := TFhirEnum.create(SYSTEMS_TFhirIdentifierUseEnum[value], CODES_TFhirIdentifierUseEnum[value]);
end;

Procedure TFhirIdentifier.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirIdentifier.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirIdentifier.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := FSystem.value;
end;

Procedure TFhirIdentifier.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirIdentifier.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirIdentifier.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirIdentifier.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

Procedure TFhirIdentifier.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirIdentifier.SetAssigner(value : TFhirReference{TFhirOrganization});
begin
  FAssigner.free;
  FAssigner := value;
end;

function TFhirIdentifier.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUse.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSystem.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FAssigner.sizeInBytes);
end;

{ TFhirIdentifierListEnumerator }

Constructor TFhirIdentifierListEnumerator.Create(list : TFhirIdentifierList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirIdentifierListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirIdentifierListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirIdentifierListEnumerator.GetCurrent : TFhirIdentifier;
begin
  Result := FList[FIndex];
end;

function TFhirIdentifierListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirIdentifierList }
procedure TFhirIdentifierList.AddItem(value: TFhirIdentifier);
begin
  assert(value.ClassName = 'TFhirIdentifier', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirIdentifier');
  add(value);
end;

function TFhirIdentifierList.Append: TFhirIdentifier;
begin
  result := TFhirIdentifier.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIdentifierList.ClearItems;
begin
  Clear;
end;

function TFhirIdentifierList.GetEnumerator : TFhirIdentifierListEnumerator;
begin
  result := TFhirIdentifierListEnumerator.Create(self.link);
end;

function TFhirIdentifierList.Clone: TFhirIdentifierList;
begin
  result := TFhirIdentifierList(inherited Clone);
end;

function TFhirIdentifierList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirIdentifierList.GetItemN(index: Integer): TFhirIdentifier;
begin
  result := TFhirIdentifier(ObjectByIndex[index]);
end;

function TFhirIdentifierList.ItemClass: TFslObjectClass;
begin
  result := TFhirIdentifier;
end;
function TFhirIdentifierList.IndexOf(value: TFhirIdentifier): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirIdentifierList.Insert(index: Integer): TFhirIdentifier;
begin
  result := TFhirIdentifier.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIdentifierList.InsertItem(index: Integer; value: TFhirIdentifier);
begin
  assert(value is TFhirIdentifier);
  Inherited Insert(index, value);
end;

function TFhirIdentifierList.Item(index: Integer): TFhirIdentifier;
begin
  result := TFhirIdentifier(ObjectByIndex[index]);
end;

function TFhirIdentifierList.Link: TFhirIdentifierList;
begin
  result := TFhirIdentifierList(inherited Link);
end;

procedure TFhirIdentifierList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirIdentifierList.SetItemByIndex(index: Integer; value: TFhirIdentifier);
begin
  assert(value is TFhirIdentifier);
  FhirIdentifiers[index] := value;
end;

procedure TFhirIdentifierList.SetItemN(index: Integer; value: TFhirIdentifier);
begin
  assert(value is TFhirIdentifier);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceAmountReferenceRange }

constructor TFhirSubstanceAmountReferenceRange.Create;
begin
  inherited;
end;

destructor TFhirSubstanceAmountReferenceRange.Destroy;
begin
  FLowLimit.free;
  FHighLimit.free;
  inherited;
end;

procedure TFhirSubstanceAmountReferenceRange.Assign(oSource : TFslObject);
begin
  inherited;
  lowLimit := TFhirSubstanceAmountReferenceRange(oSource).lowLimit.Clone;
  highLimit := TFhirSubstanceAmountReferenceRange(oSource).highLimit.Clone;
end;

procedure TFhirSubstanceAmountReferenceRange.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'lowLimit') Then
     list.add(self.link, 'lowLimit', FLowLimit.Link);
  if (child_name = 'highLimit') Then
     list.add(self.link, 'highLimit', FHighLimit.Link);
end;

procedure TFhirSubstanceAmountReferenceRange.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'lowLimit', 'Quantity', false, TFhirQuantity, FLowLimit.Link));{2}
  oList.add(TFHIRProperty.create(self, 'highLimit', 'Quantity', false, TFhirQuantity, FHighLimit.Link));{2}
end;

function TFhirSubstanceAmountReferenceRange.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'lowLimit') then
  begin
    LowLimit := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'highLimit') then
  begin
    HighLimit := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceAmountReferenceRange.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceAmountReferenceRange.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'lowLimit') then result := TFhirQuantity.create(){4b}
  else if (propName = 'highLimit') then result := TFhirQuantity.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceAmountReferenceRange.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'lowLimit') then result := 'Quantity'
  else if (propName = 'highLimit') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceAmountReferenceRange.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'lowLimit') then LowLimitElement := nil
  else if (propName = 'highLimit') then HighLimitElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceAmountReferenceRange.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'lowLimit') then LowLimitElement := new as TFhirQuantity{4}
  else if (propName = 'highLimit') then HighLimitElement := new as TFhirQuantity{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceAmountReferenceRange.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceAmountReferenceRange.fhirType : string;
begin
  result := 'referenceRange';
end;

function TFhirSubstanceAmountReferenceRange.Link : TFhirSubstanceAmountReferenceRange;
begin
  result := TFhirSubstanceAmountReferenceRange(inherited Link);
end;

function TFhirSubstanceAmountReferenceRange.Clone : TFhirSubstanceAmountReferenceRange;
begin
  result := TFhirSubstanceAmountReferenceRange(inherited Clone);
end;

function TFhirSubstanceAmountReferenceRange.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceAmountReferenceRange;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceAmountReferenceRange)) then
    result := false
  else
  begin
    o := TFhirSubstanceAmountReferenceRange(other);
    result := compareDeep(lowLimitElement, o.lowLimitElement, true) and compareDeep(highLimitElement, o.highLimitElement, true);
  end;
end;

function TFhirSubstanceAmountReferenceRange.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLowLimit) and isEmptyProp(FHighLimit);
end;

procedure TFhirSubstanceAmountReferenceRange.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('lowLimit');
  fields.add('highLimit');
end;

{ TFhirSubstanceAmountReferenceRange }

Procedure TFhirSubstanceAmountReferenceRange.SetLowLimit(value : TFhirQuantity);
begin
  FLowLimit.free;
  FLowLimit := value;
end;

Procedure TFhirSubstanceAmountReferenceRange.SetHighLimit(value : TFhirQuantity);
begin
  FHighLimit.free;
  FHighLimit := value;
end;

function TFhirSubstanceAmountReferenceRange.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLowLimit.sizeInBytes);
  inc(result, FHighLimit.sizeInBytes);
end;

{ TFhirSubstanceAmountReferenceRangeListEnumerator }

Constructor TFhirSubstanceAmountReferenceRangeListEnumerator.Create(list : TFhirSubstanceAmountReferenceRangeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceAmountReferenceRangeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceAmountReferenceRangeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceAmountReferenceRangeListEnumerator.GetCurrent : TFhirSubstanceAmountReferenceRange;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceAmountReferenceRangeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceAmountReferenceRangeList }
procedure TFhirSubstanceAmountReferenceRangeList.AddItem(value: TFhirSubstanceAmountReferenceRange);
begin
  assert(value.ClassName = 'TFhirSubstanceAmountReferenceRange', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceAmountReferenceRange');
  add(value);
end;

function TFhirSubstanceAmountReferenceRangeList.Append: TFhirSubstanceAmountReferenceRange;
begin
  result := TFhirSubstanceAmountReferenceRange.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceAmountReferenceRangeList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceAmountReferenceRangeList.GetEnumerator : TFhirSubstanceAmountReferenceRangeListEnumerator;
begin
  result := TFhirSubstanceAmountReferenceRangeListEnumerator.Create(self.link);
end;

function TFhirSubstanceAmountReferenceRangeList.Clone: TFhirSubstanceAmountReferenceRangeList;
begin
  result := TFhirSubstanceAmountReferenceRangeList(inherited Clone);
end;

function TFhirSubstanceAmountReferenceRangeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceAmountReferenceRangeList.GetItemN(index: Integer): TFhirSubstanceAmountReferenceRange;
begin
  result := TFhirSubstanceAmountReferenceRange(ObjectByIndex[index]);
end;

function TFhirSubstanceAmountReferenceRangeList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceAmountReferenceRange;
end;
function TFhirSubstanceAmountReferenceRangeList.IndexOf(value: TFhirSubstanceAmountReferenceRange): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceAmountReferenceRangeList.Insert(index: Integer): TFhirSubstanceAmountReferenceRange;
begin
  result := TFhirSubstanceAmountReferenceRange.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceAmountReferenceRangeList.InsertItem(index: Integer; value: TFhirSubstanceAmountReferenceRange);
begin
  assert(value is TFhirSubstanceAmountReferenceRange);
  Inherited Insert(index, value);
end;

function TFhirSubstanceAmountReferenceRangeList.Item(index: Integer): TFhirSubstanceAmountReferenceRange;
begin
  result := TFhirSubstanceAmountReferenceRange(ObjectByIndex[index]);
end;

function TFhirSubstanceAmountReferenceRangeList.Link: TFhirSubstanceAmountReferenceRangeList;
begin
  result := TFhirSubstanceAmountReferenceRangeList(inherited Link);
end;

procedure TFhirSubstanceAmountReferenceRangeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceAmountReferenceRangeList.SetItemByIndex(index: Integer; value: TFhirSubstanceAmountReferenceRange);
begin
  assert(value is TFhirSubstanceAmountReferenceRange);
  FhirSubstanceAmountReferenceRanges[index] := value;
end;

procedure TFhirSubstanceAmountReferenceRangeList.SetItemN(index: Integer; value: TFhirSubstanceAmountReferenceRange);
begin
  assert(value is TFhirSubstanceAmountReferenceRange);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceAmount }

constructor TFhirSubstanceAmount.Create;
begin
  inherited;
end;

destructor TFhirSubstanceAmount.Destroy;
begin
  FAmount.free;
  FAmountType.free;
  FAmountText.free;
  FReferenceRange.free;
  inherited;
end;

procedure TFhirSubstanceAmount.Assign(oSource : TFslObject);
begin
  inherited;
  amount := TFhirSubstanceAmount(oSource).amount.Clone;
  amountType := TFhirSubstanceAmount(oSource).amountType.Clone;
  amountTextElement := TFhirSubstanceAmount(oSource).amountTextElement.Clone;
  referenceRange := TFhirSubstanceAmount(oSource).referenceRange.Clone;
end;

procedure TFhirSubstanceAmount.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'amount[x]') or (child_name = 'amount') Then
     list.add(self.link, 'amount[x]', FAmount.Link);
  if (child_name = 'amountType') Then
     list.add(self.link, 'amountType', FAmountType.Link);
  if (child_name = 'amountText') Then
     list.add(self.link, 'amountText', FAmountText.Link);
  if (child_name = 'referenceRange') Then
     list.add(self.link, 'referenceRange', FReferenceRange.Link);
end;

procedure TFhirSubstanceAmount.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'amount[x]', 'Quantity|Range|string', false, TFhirType, FAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amountType', 'CodeableConcept', false, TFhirCodeableConcept, FAmountType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amountText', 'string', false, TFhirString, FAmountText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'referenceRange', '', false, TFhirSubstanceAmountReferenceRange, FReferenceRange.Link));{2}
end;

function TFhirSubstanceAmount.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'String'])) then
  begin
    Amount := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'amountType') then
  begin
    AmountType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'amountText') then
  begin
    AmountTextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'referenceRange') then
  begin
    ReferenceRange := propValue as TFhirSubstanceAmountReferenceRange{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSubstanceAmount.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceAmount.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'String'])) then raise EFHIRException.create('Cannot make property Amount'){4x}
  else if (propName = 'amountType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'amountText') then result := TFhirString.create() {5b}
  else if (propName = 'referenceRange') then result := TFhirSubstanceAmountReferenceRange.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceAmount.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'amount[x]') then result := 'Quantity|Range|string'
  else if (propName = 'amountType') then result := 'CodeableConcept'
  else if (propName = 'amountText') then result := 'string'
  else if (propName = 'referenceRange') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceAmount.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'String'])) then AmountElement := nil{4x}
  else if (propName = 'amountType') then AmountTypeElement := nil
  else if (propName = 'amountText') then AmountTextElement := nil
  else if (propName = 'referenceRange') then ReferenceRangeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceAmount.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'amount', ['Quantity', 'Range', 'String'])) then AmountElement := new as TFhirType{4x}
  else if (propName = 'amountType') then AmountTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'amountText') then AmountTextElement := asString(new){5b}
  else if (propName = 'referenceRange') then ReferenceRangeElement := new as TFhirSubstanceAmountReferenceRange{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceAmount.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceAmount.fhirType : string;
begin
  result := 'SubstanceAmount';
end;

function TFhirSubstanceAmount.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAmount) and isEmptyProp(FAmountType) and isEmptyProp(FAmountText) and isEmptyProp(FReferenceRange);
end;

function TFhirSubstanceAmount.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceAmount;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceAmount)) then
    result := false
  else
  begin
    o := TFhirSubstanceAmount(other);
    result := compareDeep(amountElement, o.amountElement, true) and compareDeep(amountTypeElement, o.amountTypeElement, true) and 
      compareDeep(amountTextElement, o.amountTextElement, true) and compareDeep(referenceRangeElement, o.referenceRangeElement, true);
  end;
end;

function TFhirSubstanceAmount.Link : TFhirSubstanceAmount;
begin
  result := TFhirSubstanceAmount(inherited Link);
end;

function TFhirSubstanceAmount.Clone : TFhirSubstanceAmount;
begin
  result := TFhirSubstanceAmount(inherited Clone);
end;

procedure TFhirSubstanceAmount.listFieldsInOrder(fields : TStringList);
begin
  listBackboneTypeFieldsInOrder(fields);
  fields.add('amount[x]');
  fields.add('amountType');
  fields.add('amountText');
  fields.add('referenceRange');
end;

{ TFhirSubstanceAmount }

Procedure TFhirSubstanceAmount.SetAmount(value : TFhirType);
begin
  FAmount.free;
  FAmount := value;
end;

Procedure TFhirSubstanceAmount.SetAmountType(value : TFhirCodeableConcept);
begin
  FAmountType.free;
  FAmountType := value;
end;

Procedure TFhirSubstanceAmount.SetAmountText(value : TFhirString);
begin
  FAmountText.free;
  FAmountText := value;
end;

Function TFhirSubstanceAmount.GetAmountTextST : String;
begin
  if FAmountText = nil then
    result := ''
  else
    result := FAmountText.value;
end;

Procedure TFhirSubstanceAmount.SetAmountTextST(value : String);
begin
  if value <> '' then
  begin
    if FAmountText = nil then
      FAmountText := TFhirString.create;
    FAmountText.value := value
  end
  else if FAmountText <> nil then
    FAmountText.value := '';
end;

Procedure TFhirSubstanceAmount.SetReferenceRange(value : TFhirSubstanceAmountReferenceRange);
begin
  FReferenceRange.free;
  FReferenceRange := value;
end;

function TFhirSubstanceAmount.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAmount.sizeInBytes);
  inc(result, FAmountType.sizeInBytes);
  inc(result, FAmountText.sizeInBytes);
  inc(result, FReferenceRange.sizeInBytes);
end;

{ TFhirSubstanceAmountListEnumerator }

Constructor TFhirSubstanceAmountListEnumerator.Create(list : TFhirSubstanceAmountList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceAmountListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceAmountListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceAmountListEnumerator.GetCurrent : TFhirSubstanceAmount;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceAmountListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSubstanceAmountList }
procedure TFhirSubstanceAmountList.AddItem(value: TFhirSubstanceAmount);
begin
  assert(value.ClassName = 'TFhirSubstanceAmount', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceAmount');
  add(value);
end;

function TFhirSubstanceAmountList.Append: TFhirSubstanceAmount;
begin
  result := TFhirSubstanceAmount.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceAmountList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceAmountList.GetEnumerator : TFhirSubstanceAmountListEnumerator;
begin
  result := TFhirSubstanceAmountListEnumerator.Create(self.link);
end;

function TFhirSubstanceAmountList.Clone: TFhirSubstanceAmountList;
begin
  result := TFhirSubstanceAmountList(inherited Clone);
end;

function TFhirSubstanceAmountList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceAmountList.GetItemN(index: Integer): TFhirSubstanceAmount;
begin
  result := TFhirSubstanceAmount(ObjectByIndex[index]);
end;

function TFhirSubstanceAmountList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceAmount;
end;
function TFhirSubstanceAmountList.IndexOf(value: TFhirSubstanceAmount): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceAmountList.Insert(index: Integer): TFhirSubstanceAmount;
begin
  result := TFhirSubstanceAmount.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceAmountList.InsertItem(index: Integer; value: TFhirSubstanceAmount);
begin
  assert(value is TFhirSubstanceAmount);
  Inherited Insert(index, value);
end;

function TFhirSubstanceAmountList.Item(index: Integer): TFhirSubstanceAmount;
begin
  result := TFhirSubstanceAmount(ObjectByIndex[index]);
end;

function TFhirSubstanceAmountList.Link: TFhirSubstanceAmountList;
begin
  result := TFhirSubstanceAmountList(inherited Link);
end;

procedure TFhirSubstanceAmountList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceAmountList.SetItemByIndex(index: Integer; value: TFhirSubstanceAmount);
begin
  assert(value is TFhirSubstanceAmount);
  FhirSubstanceAmounts[index] := value;
end;

procedure TFhirSubstanceAmountList.SetItemN(index: Integer; value: TFhirSubstanceAmount);
begin
  assert(value is TFhirSubstanceAmount);
  ObjectByIndex[index] := value;
end;

{ TFhirCoding }

constructor TFhirCoding.Create;
begin
  inherited;
end;

destructor TFhirCoding.Destroy;
begin
  FSystem.free;
  FVersion.free;
  FCode.free;
  FDisplay.free;
  FUserSelected.free;
  inherited;
end;

procedure TFhirCoding.Assign(oSource : TFslObject);
begin
  inherited;
  systemElement := TFhirCoding(oSource).systemElement.Clone;
  versionElement := TFhirCoding(oSource).versionElement.Clone;
  codeElement := TFhirCoding(oSource).codeElement.Clone;
  displayElement := TFhirCoding(oSource).displayElement.Clone;
  userSelectedElement := TFhirCoding(oSource).userSelectedElement.Clone;
end;

procedure TFhirCoding.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(self.link, 'system', FSystem.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
  if (child_name = 'userSelected') Then
     list.add(self.link, 'userSelected', FUserSelected.Link);
end;

procedure TFhirCoding.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', false, TFhirUri, FSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'userSelected', 'boolean', false, TFhirBoolean, FUserSelected.Link));{2}
end;

function TFhirCoding.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'system') then
  begin
    SystemElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'userSelected') then
  begin
    UserSelectedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirCoding.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoding.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'system') then result := TFhirUri.create() {5b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'code') then result := TFhirCode.create() {5b}
  else if (propName = 'display') then result := TFhirString.create() {5b}
  else if (propName = 'userSelected') then result := TFhirBoolean.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoding.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'system') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'display') then result := 'string'
  else if (propName = 'userSelected') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoding.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else if (propName = 'userSelected') then UserSelectedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoding.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := asUri(new){5b}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'code') then CodeElement := asCode(new){5b}
  else if (propName = 'display') then DisplayElement := asString(new){5b}
  else if (propName = 'userSelected') then UserSelectedElement := asBoolean(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoding.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoding.fhirType : string;
begin
  result := 'Coding';
end;

function TFhirCoding.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSystem) and isEmptyProp(FVersion) and isEmptyProp(FCode) and isEmptyProp(FDisplay) and isEmptyProp(FUserSelected);
end;

function TFhirCoding.equals(other : TObject) : boolean; 
var
  o : TFhirCoding;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoding)) then
    result := false
  else
  begin
    o := TFhirCoding(other);
    result := compareDeep(systemElement, o.systemElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(displayElement, o.displayElement, true) and 
      compareDeep(userSelectedElement, o.userSelectedElement, true);
  end;
end;

function TFhirCoding.Link : TFhirCoding;
begin
  result := TFhirCoding(inherited Link);
end;

function TFhirCoding.Clone : TFhirCoding;
begin
  result := TFhirCoding(inherited Clone);
end;

procedure TFhirCoding.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('system');
  fields.add('version');
  fields.add('code');
  fields.add('display');
  fields.add('userSelected');
end;

{ TFhirCoding }

Procedure TFhirCoding.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirCoding.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := FSystem.value;
end;

Procedure TFhirCoding.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirCoding.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirCoding.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirCoding.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirCoding.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirCoding.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirCoding.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirCoding.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirCoding.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirCoding.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Procedure TFhirCoding.SetUserSelected(value : TFhirBoolean);
begin
  FUserSelected.free;
  FUserSelected := value;
end;

Function TFhirCoding.GetUserSelectedST : Boolean;
begin
  if FUserSelected = nil then
    result := false
  else
    result := FUserSelected.value;
end;

Procedure TFhirCoding.SetUserSelectedST(value : Boolean);
begin
  if FUserSelected = nil then
    FUserSelected := TFhirBoolean.create;
  FUserSelected.value := value
end;

function TFhirCoding.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSystem.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FDisplay.sizeInBytes);
  inc(result, FUserSelected.sizeInBytes);
end;

{ TFhirCodingListEnumerator }

Constructor TFhirCodingListEnumerator.Create(list : TFhirCodingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCodingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCodingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCodingListEnumerator.GetCurrent : TFhirCoding;
begin
  Result := FList[FIndex];
end;

function TFhirCodingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCodingList }
procedure TFhirCodingList.AddItem(value: TFhirCoding);
begin
  assert(value.ClassName = 'TFhirCoding', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoding');
  add(value);
end;

function TFhirCodingList.Append: TFhirCoding;
begin
  result := TFhirCoding.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodingList.ClearItems;
begin
  Clear;
end;

function TFhirCodingList.GetEnumerator : TFhirCodingListEnumerator;
begin
  result := TFhirCodingListEnumerator.Create(self.link);
end;

function TFhirCodingList.Clone: TFhirCodingList;
begin
  result := TFhirCodingList(inherited Clone);
end;

function TFhirCodingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCodingList.GetItemN(index: Integer): TFhirCoding;
begin
  result := TFhirCoding(ObjectByIndex[index]);
end;

function TFhirCodingList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoding;
end;
function TFhirCodingList.IndexOf(value: TFhirCoding): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCodingList.Insert(index: Integer): TFhirCoding;
begin
  result := TFhirCoding.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodingList.InsertItem(index: Integer; value: TFhirCoding);
begin
  assert(value is TFhirCoding);
  Inherited Insert(index, value);
end;

function TFhirCodingList.Item(index: Integer): TFhirCoding;
begin
  result := TFhirCoding(ObjectByIndex[index]);
end;

function TFhirCodingList.Link: TFhirCodingList;
begin
  result := TFhirCodingList(inherited Link);
end;

procedure TFhirCodingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCodingList.SetItemByIndex(index: Integer; value: TFhirCoding);
begin
  assert(value is TFhirCoding);
  FhirCodings[index] := value;
end;

procedure TFhirCodingList.SetItemN(index: Integer; value: TFhirCoding);
begin
  assert(value is TFhirCoding);
  ObjectByIndex[index] := value;
end;

{ TFhirSampledData }

constructor TFhirSampledData.Create;
begin
  inherited;
end;

destructor TFhirSampledData.Destroy;
begin
  FOrigin.free;
  FPeriod.free;
  FFactor.free;
  FLowerLimit.free;
  FUpperLimit.free;
  FDimensions.free;
  FData.free;
  inherited;
end;

procedure TFhirSampledData.Assign(oSource : TFslObject);
begin
  inherited;
  origin := TFhirSampledData(oSource).origin.Clone;
  periodElement := TFhirSampledData(oSource).periodElement.Clone;
  factorElement := TFhirSampledData(oSource).factorElement.Clone;
  lowerLimitElement := TFhirSampledData(oSource).lowerLimitElement.Clone;
  upperLimitElement := TFhirSampledData(oSource).upperLimitElement.Clone;
  dimensionsElement := TFhirSampledData(oSource).dimensionsElement.Clone;
  dataElement := TFhirSampledData(oSource).dataElement.Clone;
end;

procedure TFhirSampledData.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'origin') Then
     list.add(self.link, 'origin', FOrigin.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'lowerLimit') Then
     list.add(self.link, 'lowerLimit', FLowerLimit.Link);
  if (child_name = 'upperLimit') Then
     list.add(self.link, 'upperLimit', FUpperLimit.Link);
  if (child_name = 'dimensions') Then
     list.add(self.link, 'dimensions', FDimensions.Link);
  if (child_name = 'data') Then
     list.add(self.link, 'data', FData.Link);
end;

procedure TFhirSampledData.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'origin', 'Quantity', false, TFhirQuantity, FOrigin.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'decimal', false, TFhirDecimal, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lowerLimit', 'decimal', false, TFhirDecimal, FLowerLimit.Link));{2}
  oList.add(TFHIRProperty.create(self, 'upperLimit', 'decimal', false, TFhirDecimal, FUpperLimit.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dimensions', 'positiveInt', false, TFhirPositiveInt, FDimensions.Link));{2}
  oList.add(TFHIRProperty.create(self, 'data', 'string', false, TFhirString, FData.Link));{2}
end;

function TFhirSampledData.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'origin') then
  begin
    Origin := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    PeriodElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lowerLimit') then
  begin
    LowerLimitElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'upperLimit') then
  begin
    UpperLimitElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'dimensions') then
  begin
    DimensionsElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'data') then
  begin
    DataElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSampledData.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSampledData.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'origin') then result := TFhirQuantity.create(){4b}
  else if (propName = 'period') then result := TFhirDecimal.create() {5b}
  else if (propName = 'factor') then result := TFhirDecimal.create() {5b}
  else if (propName = 'lowerLimit') then result := TFhirDecimal.create() {5b}
  else if (propName = 'upperLimit') then result := TFhirDecimal.create() {5b}
  else if (propName = 'dimensions') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'data') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSampledData.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'origin') then result := 'Quantity'
  else if (propName = 'period') then result := 'decimal'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'lowerLimit') then result := 'decimal'
  else if (propName = 'upperLimit') then result := 'decimal'
  else if (propName = 'dimensions') then result := 'positiveInt'
  else if (propName = 'data') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSampledData.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'origin') then OriginElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'lowerLimit') then LowerLimitElement := nil
  else if (propName = 'upperLimit') then UpperLimitElement := nil
  else if (propName = 'dimensions') then DimensionsElement := nil
  else if (propName = 'data') then DataElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSampledData.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'origin') then OriginElement := new as TFhirQuantity{4}
  else if (propName = 'period') then PeriodElement := asDecimal(new){5b}
  else if (propName = 'factor') then FactorElement := asDecimal(new){5b}
  else if (propName = 'lowerLimit') then LowerLimitElement := asDecimal(new){5b}
  else if (propName = 'upperLimit') then UpperLimitElement := asDecimal(new){5b}
  else if (propName = 'dimensions') then DimensionsElement := asPositiveInt(new){5b}
  else if (propName = 'data') then DataElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSampledData.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSampledData.fhirType : string;
begin
  result := 'SampledData';
end;

function TFhirSampledData.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOrigin) and isEmptyProp(FPeriod) and isEmptyProp(FFactor) and isEmptyProp(FLowerLimit) and isEmptyProp(FUpperLimit) and isEmptyProp(FDimensions) and isEmptyProp(FData);
end;

function TFhirSampledData.equals(other : TObject) : boolean; 
var
  o : TFhirSampledData;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSampledData)) then
    result := false
  else
  begin
    o := TFhirSampledData(other);
    result := compareDeep(originElement, o.originElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(factorElement, o.factorElement, true) and compareDeep(lowerLimitElement, o.lowerLimitElement, true) and 
      compareDeep(upperLimitElement, o.upperLimitElement, true) and compareDeep(dimensionsElement, o.dimensionsElement, true) and 
      compareDeep(dataElement, o.dataElement, true);
  end;
end;

function TFhirSampledData.Link : TFhirSampledData;
begin
  result := TFhirSampledData(inherited Link);
end;

function TFhirSampledData.Clone : TFhirSampledData;
begin
  result := TFhirSampledData(inherited Clone);
end;

procedure TFhirSampledData.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('origin');
  fields.add('period');
  fields.add('factor');
  fields.add('lowerLimit');
  fields.add('upperLimit');
  fields.add('dimensions');
  fields.add('data');
end;

{ TFhirSampledData }

Procedure TFhirSampledData.SetOrigin(value : TFhirQuantity);
begin
  FOrigin.free;
  FOrigin := value;
end;

Procedure TFhirSampledData.SetPeriod(value : TFhirDecimal);
begin
  FPeriod.free;
  FPeriod := value;
end;

Function TFhirSampledData.GetPeriodST : String;
begin
  if FPeriod = nil then
    result := ''
  else
    result := FPeriod.value;
end;

Procedure TFhirSampledData.SetPeriodST(value : String);
begin
  if value <> '' then
  begin
    if FPeriod = nil then
      FPeriod := TFhirDecimal.create;
    FPeriod.value := value
  end
  else if FPeriod <> nil then
    FPeriod.value := '';
end;

Procedure TFhirSampledData.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

Function TFhirSampledData.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

Procedure TFhirSampledData.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

Procedure TFhirSampledData.SetLowerLimit(value : TFhirDecimal);
begin
  FLowerLimit.free;
  FLowerLimit := value;
end;

Function TFhirSampledData.GetLowerLimitST : String;
begin
  if FLowerLimit = nil then
    result := ''
  else
    result := FLowerLimit.value;
end;

Procedure TFhirSampledData.SetLowerLimitST(value : String);
begin
  if value <> '' then
  begin
    if FLowerLimit = nil then
      FLowerLimit := TFhirDecimal.create;
    FLowerLimit.value := value
  end
  else if FLowerLimit <> nil then
    FLowerLimit.value := '';
end;

Procedure TFhirSampledData.SetUpperLimit(value : TFhirDecimal);
begin
  FUpperLimit.free;
  FUpperLimit := value;
end;

Function TFhirSampledData.GetUpperLimitST : String;
begin
  if FUpperLimit = nil then
    result := ''
  else
    result := FUpperLimit.value;
end;

Procedure TFhirSampledData.SetUpperLimitST(value : String);
begin
  if value <> '' then
  begin
    if FUpperLimit = nil then
      FUpperLimit := TFhirDecimal.create;
    FUpperLimit.value := value
  end
  else if FUpperLimit <> nil then
    FUpperLimit.value := '';
end;

Procedure TFhirSampledData.SetDimensions(value : TFhirPositiveInt);
begin
  FDimensions.free;
  FDimensions := value;
end;

Function TFhirSampledData.GetDimensionsST : String;
begin
  if FDimensions = nil then
    result := ''
  else
    result := FDimensions.value;
end;

Procedure TFhirSampledData.SetDimensionsST(value : String);
begin
  if value <> '' then
  begin
    if FDimensions = nil then
      FDimensions := TFhirPositiveInt.create;
    FDimensions.value := value
  end
  else if FDimensions <> nil then
    FDimensions.value := '';
end;

Procedure TFhirSampledData.SetData(value : TFhirString);
begin
  FData.free;
  FData := value;
end;

Function TFhirSampledData.GetDataST : String;
begin
  if FData = nil then
    result := ''
  else
    result := FData.value;
end;

Procedure TFhirSampledData.SetDataST(value : String);
begin
  if value <> '' then
  begin
    if FData = nil then
      FData := TFhirString.create;
    FData.value := value
  end
  else if FData <> nil then
    FData.value := '';
end;

function TFhirSampledData.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOrigin.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FFactor.sizeInBytes);
  inc(result, FLowerLimit.sizeInBytes);
  inc(result, FUpperLimit.sizeInBytes);
  inc(result, FDimensions.sizeInBytes);
  inc(result, FData.sizeInBytes);
end;

{ TFhirSampledDataListEnumerator }

Constructor TFhirSampledDataListEnumerator.Create(list : TFhirSampledDataList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSampledDataListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSampledDataListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSampledDataListEnumerator.GetCurrent : TFhirSampledData;
begin
  Result := FList[FIndex];
end;

function TFhirSampledDataListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSampledDataList }
procedure TFhirSampledDataList.AddItem(value: TFhirSampledData);
begin
  assert(value.ClassName = 'TFhirSampledData', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSampledData');
  add(value);
end;

function TFhirSampledDataList.Append: TFhirSampledData;
begin
  result := TFhirSampledData.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSampledDataList.ClearItems;
begin
  Clear;
end;

function TFhirSampledDataList.GetEnumerator : TFhirSampledDataListEnumerator;
begin
  result := TFhirSampledDataListEnumerator.Create(self.link);
end;

function TFhirSampledDataList.Clone: TFhirSampledDataList;
begin
  result := TFhirSampledDataList(inherited Clone);
end;

function TFhirSampledDataList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSampledDataList.GetItemN(index: Integer): TFhirSampledData;
begin
  result := TFhirSampledData(ObjectByIndex[index]);
end;

function TFhirSampledDataList.ItemClass: TFslObjectClass;
begin
  result := TFhirSampledData;
end;
function TFhirSampledDataList.IndexOf(value: TFhirSampledData): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSampledDataList.Insert(index: Integer): TFhirSampledData;
begin
  result := TFhirSampledData.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSampledDataList.InsertItem(index: Integer; value: TFhirSampledData);
begin
  assert(value is TFhirSampledData);
  Inherited Insert(index, value);
end;

function TFhirSampledDataList.Item(index: Integer): TFhirSampledData;
begin
  result := TFhirSampledData(ObjectByIndex[index]);
end;

function TFhirSampledDataList.Link: TFhirSampledDataList;
begin
  result := TFhirSampledDataList(inherited Link);
end;

procedure TFhirSampledDataList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSampledDataList.SetItemByIndex(index: Integer; value: TFhirSampledData);
begin
  assert(value is TFhirSampledData);
  FhirSampledData[index] := value;
end;

procedure TFhirSampledDataList.SetItemN(index: Integer; value: TFhirSampledData);
begin
  assert(value is TFhirSampledData);
  ObjectByIndex[index] := value;
end;

{ TFhirPopulation }

constructor TFhirPopulation.Create;
begin
  inherited;
end;

destructor TFhirPopulation.Destroy;
begin
  FAge.free;
  FGender.free;
  FRace.free;
  FPhysiologicalCondition.free;
  inherited;
end;

procedure TFhirPopulation.Assign(oSource : TFslObject);
begin
  inherited;
  age := TFhirPopulation(oSource).age.Clone;
  gender := TFhirPopulation(oSource).gender.Clone;
  race := TFhirPopulation(oSource).race.Clone;
  physiologicalCondition := TFhirPopulation(oSource).physiologicalCondition.Clone;
end;

procedure TFhirPopulation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'age[x]') or (child_name = 'age') Then
     list.add(self.link, 'age[x]', FAge.Link);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'race') Then
     list.add(self.link, 'race', FRace.Link);
  if (child_name = 'physiologicalCondition') Then
     list.add(self.link, 'physiologicalCondition', FPhysiologicalCondition.Link);
end;

procedure TFhirPopulation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'age[x]', 'Range|CodeableConcept', false, TFhirType, FAge.Link));{2}
  oList.add(TFHIRProperty.create(self, 'gender', 'CodeableConcept', false, TFhirCodeableConcept, FGender.Link));{2}
  oList.add(TFHIRProperty.create(self, 'race', 'CodeableConcept', false, TFhirCodeableConcept, FRace.Link));{2}
  oList.add(TFHIRProperty.create(self, 'physiologicalCondition', 'CodeableConcept', false, TFhirCodeableConcept, FPhysiologicalCondition.Link));{2}
end;

function TFhirPopulation.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'age', ['Range', 'CodeableConcept'])) then
  begin
    Age := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    Gender := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'race') then
  begin
    Race := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'physiologicalCondition') then
  begin
    PhysiologicalCondition := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirPopulation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPopulation.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'age', ['Range', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Age'){4x}
  else if (propName = 'gender') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'race') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'physiologicalCondition') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPopulation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'age[x]') then result := 'Range|CodeableConcept'
  else if (propName = 'gender') then result := 'CodeableConcept'
  else if (propName = 'race') then result := 'CodeableConcept'
  else if (propName = 'physiologicalCondition') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPopulation.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'age', ['Range', 'CodeableConcept'])) then AgeElement := nil{4x}
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'race') then RaceElement := nil
  else if (propName = 'physiologicalCondition') then PhysiologicalConditionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPopulation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'age', ['Range', 'CodeableConcept'])) then AgeElement := new as TFhirType{4x}
  else if (propName = 'gender') then GenderElement := new as TFhirCodeableConcept{4}
  else if (propName = 'race') then RaceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'physiologicalCondition') then PhysiologicalConditionElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPopulation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPopulation.fhirType : string;
begin
  result := 'Population';
end;

function TFhirPopulation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAge) and isEmptyProp(FGender) and isEmptyProp(FRace) and isEmptyProp(FPhysiologicalCondition);
end;

function TFhirPopulation.equals(other : TObject) : boolean; 
var
  o : TFhirPopulation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPopulation)) then
    result := false
  else
  begin
    o := TFhirPopulation(other);
    result := compareDeep(ageElement, o.ageElement, true) and compareDeep(genderElement, o.genderElement, true) and 
      compareDeep(raceElement, o.raceElement, true) and compareDeep(physiologicalConditionElement, o.physiologicalConditionElement, true);
  end;
end;

function TFhirPopulation.Link : TFhirPopulation;
begin
  result := TFhirPopulation(inherited Link);
end;

function TFhirPopulation.Clone : TFhirPopulation;
begin
  result := TFhirPopulation(inherited Clone);
end;

procedure TFhirPopulation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneTypeFieldsInOrder(fields);
  fields.add('age[x]');
  fields.add('gender');
  fields.add('race');
  fields.add('physiologicalCondition');
end;

{ TFhirPopulation }

Procedure TFhirPopulation.SetAge(value : TFhirType);
begin
  FAge.free;
  FAge := value;
end;

Procedure TFhirPopulation.SetGender(value : TFhirCodeableConcept);
begin
  FGender.free;
  FGender := value;
end;

Procedure TFhirPopulation.SetRace(value : TFhirCodeableConcept);
begin
  FRace.free;
  FRace := value;
end;

Procedure TFhirPopulation.SetPhysiologicalCondition(value : TFhirCodeableConcept);
begin
  FPhysiologicalCondition.free;
  FPhysiologicalCondition := value;
end;

function TFhirPopulation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAge.sizeInBytes);
  inc(result, FGender.sizeInBytes);
  inc(result, FRace.sizeInBytes);
  inc(result, FPhysiologicalCondition.sizeInBytes);
end;

{ TFhirPopulationListEnumerator }

Constructor TFhirPopulationListEnumerator.Create(list : TFhirPopulationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPopulationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPopulationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPopulationListEnumerator.GetCurrent : TFhirPopulation;
begin
  Result := FList[FIndex];
end;

function TFhirPopulationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPopulationList }
procedure TFhirPopulationList.AddItem(value: TFhirPopulation);
begin
  assert(value.ClassName = 'TFhirPopulation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPopulation');
  add(value);
end;

function TFhirPopulationList.Append: TFhirPopulation;
begin
  result := TFhirPopulation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPopulationList.ClearItems;
begin
  Clear;
end;

function TFhirPopulationList.GetEnumerator : TFhirPopulationListEnumerator;
begin
  result := TFhirPopulationListEnumerator.Create(self.link);
end;

function TFhirPopulationList.Clone: TFhirPopulationList;
begin
  result := TFhirPopulationList(inherited Clone);
end;

function TFhirPopulationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPopulationList.GetItemN(index: Integer): TFhirPopulation;
begin
  result := TFhirPopulation(ObjectByIndex[index]);
end;

function TFhirPopulationList.ItemClass: TFslObjectClass;
begin
  result := TFhirPopulation;
end;
function TFhirPopulationList.IndexOf(value: TFhirPopulation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPopulationList.Insert(index: Integer): TFhirPopulation;
begin
  result := TFhirPopulation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPopulationList.InsertItem(index: Integer; value: TFhirPopulation);
begin
  assert(value is TFhirPopulation);
  Inherited Insert(index, value);
end;

function TFhirPopulationList.Item(index: Integer): TFhirPopulation;
begin
  result := TFhirPopulation(ObjectByIndex[index]);
end;

function TFhirPopulationList.Link: TFhirPopulationList;
begin
  result := TFhirPopulationList(inherited Link);
end;

procedure TFhirPopulationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPopulationList.SetItemByIndex(index: Integer; value: TFhirPopulation);
begin
  assert(value is TFhirPopulation);
  FhirPopulations[index] := value;
end;

procedure TFhirPopulationList.SetItemN(index: Integer; value: TFhirPopulation);
begin
  assert(value is TFhirPopulation);
  ObjectByIndex[index] := value;
end;

{ TFhirRatio }

constructor TFhirRatio.Create;
begin
  inherited;
end;

destructor TFhirRatio.Destroy;
begin
  FNumerator.free;
  FDenominator.free;
  inherited;
end;

procedure TFhirRatio.Assign(oSource : TFslObject);
begin
  inherited;
  numerator := TFhirRatio(oSource).numerator.Clone;
  denominator := TFhirRatio(oSource).denominator.Clone;
end;

procedure TFhirRatio.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'numerator') Then
     list.add(self.link, 'numerator', FNumerator.Link);
  if (child_name = 'denominator') Then
     list.add(self.link, 'denominator', FDenominator.Link);
end;

procedure TFhirRatio.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'numerator', 'Quantity', false, TFhirQuantity, FNumerator.Link));{2}
  oList.add(TFHIRProperty.create(self, 'denominator', 'Quantity', false, TFhirQuantity, FDenominator.Link));{2}
end;

function TFhirRatio.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'numerator') then
  begin
    Numerator := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'denominator') then
  begin
    Denominator := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirRatio.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRatio.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'numerator') then result := TFhirQuantity.create(){4b}
  else if (propName = 'denominator') then result := TFhirQuantity.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRatio.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'numerator') then result := 'Quantity'
  else if (propName = 'denominator') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRatio.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'numerator') then NumeratorElement := nil
  else if (propName = 'denominator') then DenominatorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRatio.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'numerator') then NumeratorElement := new as TFhirQuantity{4}
  else if (propName = 'denominator') then DenominatorElement := new as TFhirQuantity{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRatio.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRatio.fhirType : string;
begin
  result := 'Ratio';
end;

function TFhirRatio.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FNumerator) and isEmptyProp(FDenominator);
end;

function TFhirRatio.equals(other : TObject) : boolean; 
var
  o : TFhirRatio;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRatio)) then
    result := false
  else
  begin
    o := TFhirRatio(other);
    result := compareDeep(numeratorElement, o.numeratorElement, true) and compareDeep(denominatorElement, o.denominatorElement, true);
  end;
end;

function TFhirRatio.Link : TFhirRatio;
begin
  result := TFhirRatio(inherited Link);
end;

function TFhirRatio.Clone : TFhirRatio;
begin
  result := TFhirRatio(inherited Clone);
end;

procedure TFhirRatio.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('numerator');
  fields.add('denominator');
end;

{ TFhirRatio }

Procedure TFhirRatio.SetNumerator(value : TFhirQuantity);
begin
  FNumerator.free;
  FNumerator := value;
end;

Procedure TFhirRatio.SetDenominator(value : TFhirQuantity);
begin
  FDenominator.free;
  FDenominator := value;
end;

function TFhirRatio.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FNumerator.sizeInBytes);
  inc(result, FDenominator.sizeInBytes);
end;

{ TFhirRatioListEnumerator }

Constructor TFhirRatioListEnumerator.Create(list : TFhirRatioList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRatioListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRatioListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRatioListEnumerator.GetCurrent : TFhirRatio;
begin
  Result := FList[FIndex];
end;

function TFhirRatioListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRatioList }
procedure TFhirRatioList.AddItem(value: TFhirRatio);
begin
  assert(value.ClassName = 'TFhirRatio', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRatio');
  add(value);
end;

function TFhirRatioList.Append: TFhirRatio;
begin
  result := TFhirRatio.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRatioList.ClearItems;
begin
  Clear;
end;

function TFhirRatioList.GetEnumerator : TFhirRatioListEnumerator;
begin
  result := TFhirRatioListEnumerator.Create(self.link);
end;

function TFhirRatioList.Clone: TFhirRatioList;
begin
  result := TFhirRatioList(inherited Clone);
end;

function TFhirRatioList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRatioList.GetItemN(index: Integer): TFhirRatio;
begin
  result := TFhirRatio(ObjectByIndex[index]);
end;

function TFhirRatioList.ItemClass: TFslObjectClass;
begin
  result := TFhirRatio;
end;
function TFhirRatioList.IndexOf(value: TFhirRatio): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRatioList.Insert(index: Integer): TFhirRatio;
begin
  result := TFhirRatio.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRatioList.InsertItem(index: Integer; value: TFhirRatio);
begin
  assert(value is TFhirRatio);
  Inherited Insert(index, value);
end;

function TFhirRatioList.Item(index: Integer): TFhirRatio;
begin
  result := TFhirRatio(ObjectByIndex[index]);
end;

function TFhirRatioList.Link: TFhirRatioList;
begin
  result := TFhirRatioList(inherited Link);
end;

procedure TFhirRatioList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRatioList.SetItemByIndex(index: Integer; value: TFhirRatio);
begin
  assert(value is TFhirRatio);
  FhirRatios[index] := value;
end;

procedure TFhirRatioList.SetItemN(index: Integer; value: TFhirRatio);
begin
  assert(value is TFhirRatio);
  ObjectByIndex[index] := value;
end;

{ TFhirReference }

constructor TFhirReference.Create;
begin
  inherited;
end;

destructor TFhirReference.Destroy;
begin
  FReference.free;
  FType_.free;
  FIdentifier.free;
  FDisplay.free;
  inherited;
end;

procedure TFhirReference.Assign(oSource : TFslObject);
begin
  inherited;
  referenceElement := TFhirReference(oSource).referenceElement.Clone;
  type_Element := TFhirReference(oSource).type_Element.Clone;
  identifier := TFhirReference(oSource).identifier.Clone;
  displayElement := TFhirReference(oSource).displayElement.Clone;
end;

procedure TFhirReference.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
end;

procedure TFhirReference.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'reference', 'string', false, TFhirString, FReference.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'uri', false, TFhirUri, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));{2}
end;

function TFhirReference.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'reference') then
  begin
    ReferenceElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirReference.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirReference.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'reference') then result := TFhirString.create() {5b}
  else if (propName = 'type') then result := TFhirUri.create() {5b}
  else if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'display') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirReference.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'reference') then result := 'string'
  else if (propName = 'type') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'display') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirReference.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirReference.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'reference') then ReferenceElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := asUri(new){5b}
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'display') then DisplayElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirReference.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirReference.fhirType : string;
begin
  result := 'Reference';
end;

function TFhirReference.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FReference) and isEmptyProp(FType_) and isEmptyProp(FIdentifier) and isEmptyProp(FDisplay);
end;

function TFhirReference.equals(other : TObject) : boolean; 
var
  o : TFhirReference;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirReference)) then
    result := false
  else
  begin
    o := TFhirReference(other);
    result := compareDeep(referenceElement, o.referenceElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(identifierElement, o.identifierElement, true) and compareDeep(displayElement, o.displayElement, true);
  end;
end;

function TFhirReference.Link : TFhirReference;
begin
  result := TFhirReference(inherited Link);
end;

function TFhirReference.Clone : TFhirReference;
begin
  result := TFhirReference(inherited Clone);
end;

procedure TFhirReference.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('reference');
  fields.add('type');
  fields.add('identifier');
  fields.add('display');
end;

{ TFhirReference }

Procedure TFhirReference.SetReference(value : TFhirString);
begin
  FReference.free;
  FReference := value;
end;

Function TFhirReference.GetReferenceST : String;
begin
  if FReference = nil then
    result := ''
  else
    result := FReference.value;
end;

Procedure TFhirReference.SetReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FReference = nil then
      FReference := TFhirString.create;
    FReference.value := value
  end
  else if FReference <> nil then
    FReference.value := '';
end;

Procedure TFhirReference.SetType_(value : TFhirUri);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirReference.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

Procedure TFhirReference.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirUri.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirReference.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirReference.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirReference.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirReference.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

function TFhirReference.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FReference.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FDisplay.sizeInBytes);
end;

{ TFhirReferenceListEnumerator }

Constructor TFhirReferenceListEnumerator.Create(list : TFhirReferenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirReferenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirReferenceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirReferenceListEnumerator.GetCurrent : TFhirReference;
begin
  Result := FList[FIndex];
end;

function TFhirReferenceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirReferenceList }
procedure TFhirReferenceList.AddItem(value: TFhirReference);
begin
  assert(value.ClassName = 'TFhirReference', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirReference');
  add(value);
end;

function TFhirReferenceList.Append: TFhirReference;
begin
  result := TFhirReference.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirReferenceList.ClearItems;
begin
  Clear;
end;

function TFhirReferenceList.GetEnumerator : TFhirReferenceListEnumerator;
begin
  result := TFhirReferenceListEnumerator.Create(self.link);
end;

function TFhirReferenceList.Clone: TFhirReferenceList;
begin
  result := TFhirReferenceList(inherited Clone);
end;

function TFhirReferenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirReferenceList.GetItemN(index: Integer): TFhirReference;
begin
  result := TFhirReference(ObjectByIndex[index]);
end;

function TFhirReferenceList.ItemClass: TFslObjectClass;
begin
  result := TFhirReference;
end;
function TFhirReferenceList.IndexOf(value: TFhirReference): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirReferenceList.Insert(index: Integer): TFhirReference;
begin
  result := TFhirReference.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirReferenceList.InsertItem(index: Integer; value: TFhirReference);
begin
  assert(value is TFhirReference);
  Inherited Insert(index, value);
end;

function TFhirReferenceList.Item(index: Integer): TFhirReference;
begin
  result := TFhirReference(ObjectByIndex[index]);
end;

function TFhirReferenceList.Link: TFhirReferenceList;
begin
  result := TFhirReferenceList(inherited Link);
end;

procedure TFhirReferenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirReferenceList.SetItemByIndex(index: Integer; value: TFhirReference);
begin
  assert(value is TFhirReference);
  FhirReferences[index] := value;
end;

procedure TFhirReferenceList.SetItemN(index: Integer; value: TFhirReference);
begin
  assert(value is TFhirReference);
  ObjectByIndex[index] := value;
end;

function TFhirTriggerTypeEnumListAsInteger(aSet : TFhirTriggerTypeEnumList) : Integer;
var
  a : TFhirTriggerTypeEnum;
begin
  result := 0;
  for a := low(TFhirTriggerTypeEnum) to high(TFhirTriggerTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirTriggerTypeEnumList(i : Integer) : TFhirTriggerTypeEnumList;
var
  aLoop : TFhirTriggerTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirTriggerTypeEnum) to high(TFhirTriggerTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

{ TFhirTriggerDefinition }

constructor TFhirTriggerDefinition.Create;
begin
  inherited;
end;

destructor TFhirTriggerDefinition.Destroy;
begin
  FType_.free;
  FName.free;
  FTiming.free;
  FDataList.Free;
  FCondition.free;
  inherited;
end;

procedure TFhirTriggerDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirTriggerDefinition(oSource).FType_.Link;
  nameElement := TFhirTriggerDefinition(oSource).nameElement.Clone;
  timing := TFhirTriggerDefinition(oSource).timing.Clone;
  if (TFhirTriggerDefinition(oSource).FDataList = nil) then
  begin
    FDataList.free;
    FDataList := nil;
  end
  else
  begin
    if FDataList = nil then
      FDataList := TFhirDataRequirementList.Create;
    FDataList.Assign(TFhirTriggerDefinition(oSource).FDataList);
  end;
  condition := TFhirTriggerDefinition(oSource).condition.Clone;
end;

procedure TFhirTriggerDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'data') Then
    list.addAll(self, 'data', FDataList);
  if (child_name = 'condition') Then
     list.add(self.link, 'condition', FCondition.Link);
end;

procedure TFhirTriggerDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'Timing|Reference(Schedule)|date|dateTime', false, TFhirType, FTiming.Link));{2}
  oList.add(TFHIRProperty.create(self, 'data', 'DataRequirement', true, TFhirDataRequirement, FDataList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'condition', 'Expression', false, TFhirExpression, FCondition.Link));{2}
end;

function TFhirTriggerDefinition.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirTriggerTypeEnum, CODES_TFhirTriggerTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['Timing', 'Reference', 'Date', 'DateTime'])) then
  begin
    Timing := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'data') then
  begin
    DataList.add(propValue as TFhirDataRequirement){2a};
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    Condition := propValue as TFhirExpression{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirTriggerDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'data') then DataList.insertItem(index, propValue as TFhirDataRequirement){2a}
  else inherited;
end;

function TFhirTriggerDefinition.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'timing', ['Timing', 'Reference', 'Date', 'DateTime'])) then raise EFHIRException.create('Cannot make property Timing'){4x}
  else if (propName = 'data') then result := DataList.new(){2}
  else if (propName = 'condition') then result := TFhirExpression.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTriggerDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'timing[x]') then result := 'Timing|Reference|date|dateTime'
  else if (propName = 'data') then result := 'DataRequirement'
  else if (propName = 'condition') then result := 'Expression'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTriggerDefinition.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'name') then NameElement := nil
  else if (isMatchingName(propName, 'timing', ['Timing', 'Reference', 'Date', 'DateTime'])) then TimingElement := nil{4x}
  else if (propName = 'data') then deletePropertyValue('data', DataList, value) {2}
  else if (propName = 'condition') then ConditionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTriggerDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirTriggerTypeEnum, CODES_TFhirTriggerTypeEnum, new){4}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (isMatchingName(propName, 'timing', ['Timing', 'Reference', 'Date', 'DateTime'])) then TimingElement := new as TFhirType{4x}
  else if (propName = 'data') then replacePropertyValue('data', DataList, existing, new) {2}
  else if (propName = 'condition') then ConditionElement := new as TFhirExpression{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTriggerDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'data') then DataList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTriggerDefinition.fhirType : string;
begin
  result := 'TriggerDefinition';
end;

function TFhirTriggerDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FName) and isEmptyProp(FTiming) and isEmptyProp(FdataList) and isEmptyProp(FCondition);
end;

function TFhirTriggerDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirTriggerDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTriggerDefinition)) then
    result := false
  else
  begin
    o := TFhirTriggerDefinition(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(timingElement, o.timingElement, true) and compareDeep(dataList, o.dataList, true) and 
      compareDeep(conditionElement, o.conditionElement, true);
  end;
end;

function TFhirTriggerDefinition.Link : TFhirTriggerDefinition;
begin
  result := TFhirTriggerDefinition(inherited Link);
end;

function TFhirTriggerDefinition.Clone : TFhirTriggerDefinition;
begin
  result := TFhirTriggerDefinition(inherited Clone);
end;

procedure TFhirTriggerDefinition.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('name');
  fields.add('timing[x]');
  fields.add('data');
  fields.add('condition');
end;

{ TFhirTriggerDefinition }

Procedure TFhirTriggerDefinition.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirTriggerDefinition.GetType_ST : TFhirTriggerTypeEnum;
begin
  if FType_ = nil then
    result := TFhirTriggerTypeEnum(0)
  else
    result := TFhirTriggerTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirTriggerTypeEnum, FType_.value));
end;

Procedure TFhirTriggerDefinition.SetType_ST(value : TFhirTriggerTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirTriggerTypeEnum[value], CODES_TFhirTriggerTypeEnum[value]);
end;

Procedure TFhirTriggerDefinition.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirTriggerDefinition.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirTriggerDefinition.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirTriggerDefinition.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Function TFhirTriggerDefinition.GetDataList : TFhirDataRequirementList;
begin
  if FDataList = nil then
    FDataList := TFhirDataRequirementList.Create;
  result := FDataList;
end;

Function TFhirTriggerDefinition.GetHasDataList : boolean;
begin
  result := (FDataList <> nil) and (FDataList.count > 0);
end;

Procedure TFhirTriggerDefinition.SetCondition(value : TFhirExpression);
begin
  FCondition.free;
  FCondition := value;
end;

function TFhirTriggerDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FTiming.sizeInBytes);
  inc(result, FdataList.sizeInBytes);
  inc(result, FCondition.sizeInBytes);
end;

{ TFhirTriggerDefinitionListEnumerator }

Constructor TFhirTriggerDefinitionListEnumerator.Create(list : TFhirTriggerDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTriggerDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTriggerDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTriggerDefinitionListEnumerator.GetCurrent : TFhirTriggerDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirTriggerDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTriggerDefinitionList }
procedure TFhirTriggerDefinitionList.AddItem(value: TFhirTriggerDefinition);
begin
  assert(value.ClassName = 'TFhirTriggerDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTriggerDefinition');
  add(value);
end;

function TFhirTriggerDefinitionList.Append: TFhirTriggerDefinition;
begin
  result := TFhirTriggerDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTriggerDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirTriggerDefinitionList.GetEnumerator : TFhirTriggerDefinitionListEnumerator;
begin
  result := TFhirTriggerDefinitionListEnumerator.Create(self.link);
end;

function TFhirTriggerDefinitionList.Clone: TFhirTriggerDefinitionList;
begin
  result := TFhirTriggerDefinitionList(inherited Clone);
end;

function TFhirTriggerDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTriggerDefinitionList.GetItemN(index: Integer): TFhirTriggerDefinition;
begin
  result := TFhirTriggerDefinition(ObjectByIndex[index]);
end;

function TFhirTriggerDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTriggerDefinition;
end;
function TFhirTriggerDefinitionList.IndexOf(value: TFhirTriggerDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTriggerDefinitionList.Insert(index: Integer): TFhirTriggerDefinition;
begin
  result := TFhirTriggerDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTriggerDefinitionList.InsertItem(index: Integer; value: TFhirTriggerDefinition);
begin
  assert(value is TFhirTriggerDefinition);
  Inherited Insert(index, value);
end;

function TFhirTriggerDefinitionList.Item(index: Integer): TFhirTriggerDefinition;
begin
  result := TFhirTriggerDefinition(ObjectByIndex[index]);
end;

function TFhirTriggerDefinitionList.Link: TFhirTriggerDefinitionList;
begin
  result := TFhirTriggerDefinitionList(inherited Link);
end;

procedure TFhirTriggerDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTriggerDefinitionList.SetItemByIndex(index: Integer; value: TFhirTriggerDefinition);
begin
  assert(value is TFhirTriggerDefinition);
  FhirTriggerDefinitions[index] := value;
end;

procedure TFhirTriggerDefinitionList.SetItemN(index: Integer; value: TFhirTriggerDefinition);
begin
  assert(value is TFhirTriggerDefinition);
  ObjectByIndex[index] := value;
end;

{ TFhirPeriod }

constructor TFhirPeriod.Create;
begin
  inherited;
end;

destructor TFhirPeriod.Destroy;
begin
  FStart.free;
  FEnd_.free;
  inherited;
end;

procedure TFhirPeriod.Assign(oSource : TFslObject);
begin
  inherited;
  startElement := TFhirPeriod(oSource).startElement.Clone;
  end_Element := TFhirPeriod(oSource).end_Element.Clone;
end;

procedure TFhirPeriod.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
end;

procedure TFhirPeriod.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'start', 'dateTime', false, TFhirDateTime, FStart.Link));{2}
  oList.add(TFHIRProperty.create(self, 'end', 'dateTime', false, TFhirDateTime, FEnd_.Link));{2}
end;

function TFhirPeriod.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'start') then
  begin
    StartElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asDateTime(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirPeriod.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPeriod.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'start') then result := TFhirDateTime.create() {5b}
  else if (propName = 'end') then result := TFhirDateTime.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPeriod.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'start') then result := 'dateTime'
  else if (propName = 'end') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPeriod.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPeriod.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'start') then StartElement := asDateTime(new){5b}
  else if (propName = 'end') then End_Element := asDateTime(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPeriod.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPeriod.fhirType : string;
begin
  result := 'Period';
end;

function TFhirPeriod.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStart) and isEmptyProp(FEnd_);
end;

function TFhirPeriod.equals(other : TObject) : boolean; 
var
  o : TFhirPeriod;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPeriod)) then
    result := false
  else
  begin
    o := TFhirPeriod(other);
    result := compareDeep(startElement, o.startElement, true) and compareDeep(end_Element, o.end_Element, true);
  end;
end;

function TFhirPeriod.Link : TFhirPeriod;
begin
  result := TFhirPeriod(inherited Link);
end;

function TFhirPeriod.Clone : TFhirPeriod;
begin
  result := TFhirPeriod(inherited Clone);
end;

procedure TFhirPeriod.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('start');
  fields.add('end');
end;

{ TFhirPeriod }

Procedure TFhirPeriod.SetStart(value : TFhirDateTime);
begin
  FStart.free;
  FStart := value;
end;

Function TFhirPeriod.GetStartST : TFslDateTime;
begin
  if FStart = nil then
    result := TFslDateTime.makeNull
  else
    result := FStart.value;
end;

Procedure TFhirPeriod.SetStartST(value : TFslDateTime);
begin
  if FStart = nil then
    FStart := TFhirDateTime.create;
  FStart.value := value
end;

Procedure TFhirPeriod.SetEnd_(value : TFhirDateTime);
begin
  FEnd_.free;
  FEnd_ := value;
end;

Function TFhirPeriod.GetEnd_ST : TFslDateTime;
begin
  if FEnd_ = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnd_.value;
end;

Procedure TFhirPeriod.SetEnd_ST(value : TFslDateTime);
begin
  if FEnd_ = nil then
    FEnd_ := TFhirDateTime.create;
  FEnd_.value := value
end;

function TFhirPeriod.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStart.sizeInBytes);
  inc(result, FEnd_.sizeInBytes);
end;

{ TFhirPeriodListEnumerator }

Constructor TFhirPeriodListEnumerator.Create(list : TFhirPeriodList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPeriodListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPeriodListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPeriodListEnumerator.GetCurrent : TFhirPeriod;
begin
  Result := FList[FIndex];
end;

function TFhirPeriodListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPeriodList }
procedure TFhirPeriodList.AddItem(value: TFhirPeriod);
begin
  assert(value.ClassName = 'TFhirPeriod', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPeriod');
  add(value);
end;

function TFhirPeriodList.Append: TFhirPeriod;
begin
  result := TFhirPeriod.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPeriodList.ClearItems;
begin
  Clear;
end;

function TFhirPeriodList.GetEnumerator : TFhirPeriodListEnumerator;
begin
  result := TFhirPeriodListEnumerator.Create(self.link);
end;

function TFhirPeriodList.Clone: TFhirPeriodList;
begin
  result := TFhirPeriodList(inherited Clone);
end;

function TFhirPeriodList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPeriodList.GetItemN(index: Integer): TFhirPeriod;
begin
  result := TFhirPeriod(ObjectByIndex[index]);
end;

function TFhirPeriodList.ItemClass: TFslObjectClass;
begin
  result := TFhirPeriod;
end;
function TFhirPeriodList.IndexOf(value: TFhirPeriod): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPeriodList.Insert(index: Integer): TFhirPeriod;
begin
  result := TFhirPeriod.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPeriodList.InsertItem(index: Integer; value: TFhirPeriod);
begin
  assert(value is TFhirPeriod);
  Inherited Insert(index, value);
end;

function TFhirPeriodList.Item(index: Integer): TFhirPeriod;
begin
  result := TFhirPeriod(ObjectByIndex[index]);
end;

function TFhirPeriodList.Link: TFhirPeriodList;
begin
  result := TFhirPeriodList(inherited Link);
end;

procedure TFhirPeriodList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPeriodList.SetItemByIndex(index: Integer; value: TFhirPeriod);
begin
  assert(value is TFhirPeriod);
  FhirPeriods[index] := value;
end;

procedure TFhirPeriodList.SetItemN(index: Integer; value: TFhirPeriod);
begin
  assert(value is TFhirPeriod);
  ObjectByIndex[index] := value;
end;

function TFhirQuantityComparatorEnumListAsInteger(aSet : TFhirQuantityComparatorEnumList) : Integer;
var
  a : TFhirQuantityComparatorEnum;
begin
  result := 0;
  for a := low(TFhirQuantityComparatorEnum) to high(TFhirQuantityComparatorEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirQuantityComparatorEnumList(i : Integer) : TFhirQuantityComparatorEnumList;
var
  aLoop : TFhirQuantityComparatorEnum;
begin
  result := [];
  for aLoop := low(TFhirQuantityComparatorEnum) to high(TFhirQuantityComparatorEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

{ TFhirQuantity }

constructor TFhirQuantity.Create;
begin
  inherited;
end;

destructor TFhirQuantity.Destroy;
begin
  FValue.free;
  FComparator.free;
  FUnit_.free;
  FSystem.free;
  FCode.free;
  inherited;
end;

procedure TFhirQuantity.Assign(oSource : TFslObject);
begin
  inherited;
  valueElement := TFhirQuantity(oSource).valueElement.Clone;
  FComparator := TFhirQuantity(oSource).FComparator.Link;
  unit_Element := TFhirQuantity(oSource).unit_Element.Clone;
  systemElement := TFhirQuantity(oSource).systemElement.Clone;
  codeElement := TFhirQuantity(oSource).codeElement.Clone;
end;

procedure TFhirQuantity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'comparator') Then
     list.add(self.link, 'comparator', FComparator.Link);
  if (child_name = 'unit') Then
     list.add(self.link, 'unit', FUnit_.Link);
  if (child_name = 'system') Then
     list.add(self.link, 'system', FSystem.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
end;

procedure TFhirQuantity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value', 'decimal', false, TFhirDecimal, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comparator', 'code', false, TFHIREnum, FComparator.Link));{1}
  oList.add(TFHIRProperty.create(self, 'unit', 'string', false, TFhirString, FUnit_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'system', 'uri', false, TFhirUri, FSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));{2}
end;

procedure TFhirQuantity.listQuantityFieldsInOrder(fields: TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('value');
  fields.add('comparator');
  fields.add('unit');
  fields.add('system');
  fields.add('code');
end;

function TFhirQuantity.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'value') then
  begin
    ValueElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'comparator') then
  begin
    ComparatorElement := asEnum(SYSTEMS_TFhirQuantityComparatorEnum, CODES_TFhirQuantityComparatorEnum, propValue);
    result := propValue
  end
  else if (propName = 'unit') then
  begin
    Unit_Element := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'system') then
  begin
    SystemElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirQuantity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirQuantity.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'value') then result := TFhirDecimal.create() {5b}
  else if (propName = 'unit') then result := TFhirString.create() {5b}
  else if (propName = 'system') then result := TFhirUri.create() {5b}
  else if (propName = 'code') then result := TFhirCode.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuantity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value') then result := 'decimal'
  else if (propName = 'comparator') then result := 'code'
  else if (propName = 'unit') then result := 'string'
  else if (propName = 'system') then result := 'uri'
  else if (propName = 'code') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuantity.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := nil
  else if (propName = 'comparator') then ComparatorElement := nil
  else if (propName = 'unit') then Unit_Element := nil
  else if (propName = 'system') then SystemElement := nil
  else if (propName = 'code') then CodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuantity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := asDecimal(new){5b}
  else if (propName = 'comparator') then ComparatorElement := asEnum(SYSTEMS_TFhirQuantityComparatorEnum, CODES_TFhirQuantityComparatorEnum, new){4}
  else if (propName = 'unit') then Unit_Element := asString(new){5b}
  else if (propName = 'system') then SystemElement := asUri(new){5b}
  else if (propName = 'code') then CodeElement := asCode(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuantity.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirQuantity.fhirType : string;
begin
  result := 'Quantity';
end;

function TFhirQuantity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue) and isEmptyProp(FComparator) and isEmptyProp(FUnit_) and isEmptyProp(FSystem) and isEmptyProp(FCode);
end;

function TFhirQuantity.equals(other : TObject) : boolean; 
var
  o : TFhirQuantity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuantity)) then
    result := false
  else
  begin
    o := TFhirQuantity(other);
    result := compareDeep(valueElement, o.valueElement, true) and compareDeep(comparatorElement, o.comparatorElement, true) and 
      compareDeep(unit_Element, o.unit_Element, true) and compareDeep(systemElement, o.systemElement, true) and 
      compareDeep(codeElement, o.codeElement, true);
  end;
end;

function TFhirQuantity.Link : TFhirQuantity;
begin
  result := TFhirQuantity(inherited Link);
end;

function TFhirQuantity.Clone : TFhirQuantity;
begin
  result := TFhirQuantity(inherited Clone);
end;

procedure TFhirQuantity.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('value');
  fields.add('comparator');
  fields.add('unit');
  fields.add('system');
  fields.add('code');
end;

{ TFhirQuantity }

Procedure TFhirQuantity.SetValue(value : TFhirDecimal);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirQuantity.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirQuantity.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirDecimal.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

Procedure TFhirQuantity.SetComparator(value : TFhirEnum);
begin
  FComparator.free;
  FComparator := value;
end;

Function TFhirQuantity.GetComparatorST : TFhirQuantityComparatorEnum;
begin
  if FComparator = nil then
    result := TFhirQuantityComparatorEnum(0)
  else
    result := TFhirQuantityComparatorEnum(StringArrayIndexOfSensitive(CODES_TFhirQuantityComparatorEnum, FComparator.value));
end;

Procedure TFhirQuantity.SetComparatorST(value : TFhirQuantityComparatorEnum);
begin
  if ord(value) = 0 then
    ComparatorElement := nil
  else
    ComparatorElement := TFhirEnum.create(SYSTEMS_TFhirQuantityComparatorEnum[value], CODES_TFhirQuantityComparatorEnum[value]);
end;

Procedure TFhirQuantity.SetUnit_(value : TFhirString);
begin
  FUnit_.free;
  FUnit_ := value;
end;

Function TFhirQuantity.GetUnit_ST : String;
begin
  if FUnit_ = nil then
    result := ''
  else
    result := FUnit_.value;
end;

Procedure TFhirQuantity.SetUnit_ST(value : String);
begin
  if value <> '' then
  begin
    if FUnit_ = nil then
      FUnit_ := TFhirString.create;
    FUnit_.value := value
  end
  else if FUnit_ <> nil then
    FUnit_.value := '';
end;

Procedure TFhirQuantity.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirQuantity.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := FSystem.value;
end;

Procedure TFhirQuantity.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirQuantity.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirQuantity.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirQuantity.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

function TFhirQuantity.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FValue.sizeInBytes);
  inc(result, FComparator.sizeInBytes);
  inc(result, FUnit_.sizeInBytes);
  inc(result, FSystem.sizeInBytes);
  inc(result, FCode.sizeInBytes);
end;

{ TFhirQuantityListEnumerator }

Constructor TFhirQuantityListEnumerator.Create(list : TFhirQuantityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuantityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuantityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuantityListEnumerator.GetCurrent : TFhirQuantity;
begin
  Result := FList[FIndex];
end;

function TFhirQuantityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirQuantityList }
procedure TFhirQuantityList.AddItem(value: TFhirQuantity);
begin
  assert(value.ClassName = 'TFhirQuantity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuantity');
  add(value);
end;

function TFhirQuantityList.Append: TFhirQuantity;
begin
  result := TFhirQuantity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuantityList.ClearItems;
begin
  Clear;
end;

function TFhirQuantityList.GetEnumerator : TFhirQuantityListEnumerator;
begin
  result := TFhirQuantityListEnumerator.Create(self.link);
end;

function TFhirQuantityList.Clone: TFhirQuantityList;
begin
  result := TFhirQuantityList(inherited Clone);
end;

function TFhirQuantityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuantityList.GetItemN(index: Integer): TFhirQuantity;
begin
  result := TFhirQuantity(ObjectByIndex[index]);
end;

function TFhirQuantityList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuantity;
end;
function TFhirQuantityList.IndexOf(value: TFhirQuantity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuantityList.Insert(index: Integer): TFhirQuantity;
begin
  result := TFhirQuantity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuantityList.InsertItem(index: Integer; value: TFhirQuantity);
begin
  assert(value is TFhirQuantity);
  Inherited Insert(index, value);
end;

function TFhirQuantityList.Item(index: Integer): TFhirQuantity;
begin
  result := TFhirQuantity(ObjectByIndex[index]);
end;

function TFhirQuantityList.Link: TFhirQuantityList;
begin
  result := TFhirQuantityList(inherited Link);
end;

procedure TFhirQuantityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuantityList.SetItemByIndex(index: Integer; value: TFhirQuantity);
begin
  assert(value is TFhirQuantity);
  FhirQuantities[index] := value;
end;

procedure TFhirQuantityList.SetItemN(index: Integer; value: TFhirQuantity);
begin
  assert(value is TFhirQuantity);
  ObjectByIndex[index] := value;
end;

{ TFhirRange }

constructor TFhirRange.Create;
begin
  inherited;
end;

destructor TFhirRange.Destroy;
begin
  FLow.free;
  FHigh.free;
  inherited;
end;

procedure TFhirRange.Assign(oSource : TFslObject);
begin
  inherited;
  low := TFhirRange(oSource).low.Clone;
  high := TFhirRange(oSource).high.Clone;
end;

procedure TFhirRange.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'low') Then
     list.add(self.link, 'low', FLow.Link);
  if (child_name = 'high') Then
     list.add(self.link, 'high', FHigh.Link);
end;

procedure TFhirRange.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'low', 'Quantity', false, TFhirQuantity, FLow.Link));{2}
  oList.add(TFHIRProperty.create(self, 'high', 'Quantity', false, TFhirQuantity, FHigh.Link));{2}
end;

function TFhirRange.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'low') then
  begin
    Low := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'high') then
  begin
    High := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirRange.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRange.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'low') then result := TFhirQuantity.create(){4b}
  else if (propName = 'high') then result := TFhirQuantity.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRange.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'low') then result := 'Quantity'
  else if (propName = 'high') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRange.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'low') then LowElement := nil
  else if (propName = 'high') then HighElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRange.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'low') then LowElement := new as TFhirQuantity{4}
  else if (propName = 'high') then HighElement := new as TFhirQuantity{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRange.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRange.fhirType : string;
begin
  result := 'Range';
end;

function TFhirRange.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLow) and isEmptyProp(FHigh);
end;

function TFhirRange.equals(other : TObject) : boolean; 
var
  o : TFhirRange;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRange)) then
    result := false
  else
  begin
    o := TFhirRange(other);
    result := compareDeep(lowElement, o.lowElement, true) and compareDeep(highElement, o.highElement, true);
  end;
end;

function TFhirRange.Link : TFhirRange;
begin
  result := TFhirRange(inherited Link);
end;

function TFhirRange.Clone : TFhirRange;
begin
  result := TFhirRange(inherited Clone);
end;

procedure TFhirRange.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('low');
  fields.add('high');
end;

{ TFhirRange }

Procedure TFhirRange.SetLow(value : TFhirQuantity);
begin
  FLow.free;
  FLow := value;
end;

Procedure TFhirRange.SetHigh(value : TFhirQuantity);
begin
  FHigh.free;
  FHigh := value;
end;

function TFhirRange.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLow.sizeInBytes);
  inc(result, FHigh.sizeInBytes);
end;

{ TFhirRangeListEnumerator }

Constructor TFhirRangeListEnumerator.Create(list : TFhirRangeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRangeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRangeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRangeListEnumerator.GetCurrent : TFhirRange;
begin
  Result := FList[FIndex];
end;

function TFhirRangeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRangeList }
procedure TFhirRangeList.AddItem(value: TFhirRange);
begin
  assert(value.ClassName = 'TFhirRange', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRange');
  add(value);
end;

function TFhirRangeList.Append: TFhirRange;
begin
  result := TFhirRange.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRangeList.ClearItems;
begin
  Clear;
end;

function TFhirRangeList.GetEnumerator : TFhirRangeListEnumerator;
begin
  result := TFhirRangeListEnumerator.Create(self.link);
end;

function TFhirRangeList.Clone: TFhirRangeList;
begin
  result := TFhirRangeList(inherited Clone);
end;

function TFhirRangeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRangeList.GetItemN(index: Integer): TFhirRange;
begin
  result := TFhirRange(ObjectByIndex[index]);
end;

function TFhirRangeList.ItemClass: TFslObjectClass;
begin
  result := TFhirRange;
end;
function TFhirRangeList.IndexOf(value: TFhirRange): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRangeList.Insert(index: Integer): TFhirRange;
begin
  result := TFhirRange.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRangeList.InsertItem(index: Integer; value: TFhirRange);
begin
  assert(value is TFhirRange);
  Inherited Insert(index, value);
end;

function TFhirRangeList.Item(index: Integer): TFhirRange;
begin
  result := TFhirRange(ObjectByIndex[index]);
end;

function TFhirRangeList.Link: TFhirRangeList;
begin
  result := TFhirRangeList(inherited Link);
end;

procedure TFhirRangeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRangeList.SetItemByIndex(index: Integer; value: TFhirRange);
begin
  assert(value is TFhirRange);
  FhirRanges[index] := value;
end;

procedure TFhirRangeList.SetItemN(index: Integer; value: TFhirRange);
begin
  assert(value is TFhirRange);
  ObjectByIndex[index] := value;
end;

function TFhirRelatedArtifactTypeEnumListAsInteger(aSet : TFhirRelatedArtifactTypeEnumList) : Integer;
var
  a : TFhirRelatedArtifactTypeEnum;
begin
  result := 0;
  for a := low(TFhirRelatedArtifactTypeEnum) to high(TFhirRelatedArtifactTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirRelatedArtifactTypeEnumList(i : Integer) : TFhirRelatedArtifactTypeEnumList;
var
  aLoop : TFhirRelatedArtifactTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirRelatedArtifactTypeEnum) to high(TFhirRelatedArtifactTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

{ TFhirRelatedArtifact }

constructor TFhirRelatedArtifact.Create;
begin
  inherited;
end;

destructor TFhirRelatedArtifact.Destroy;
begin
  FType_.free;
  FLabel_.free;
  FDisplay.free;
  FCitation.free;
  FUrl.free;
  FDocument.free;
  FResource.free;
  inherited;
end;

procedure TFhirRelatedArtifact.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirRelatedArtifact(oSource).FType_.Link;
  label_Element := TFhirRelatedArtifact(oSource).label_Element.Clone;
  displayElement := TFhirRelatedArtifact(oSource).displayElement.Clone;
  citationElement := TFhirRelatedArtifact(oSource).citationElement.Clone;
  urlElement := TFhirRelatedArtifact(oSource).urlElement.Clone;
  document := TFhirRelatedArtifact(oSource).document.Clone;
  resourceElement := TFhirRelatedArtifact(oSource).resourceElement.Clone;
end;

procedure TFhirRelatedArtifact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'label') Then
     list.add(self.link, 'label', FLabel_.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
  if (child_name = 'citation') Then
     list.add(self.link, 'citation', FCitation.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'document') Then
     list.add(self.link, 'document', FDocument.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
end;

procedure TFhirRelatedArtifact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'label', 'string', false, TFhirString, FLabel_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'citation', 'markdown', false, TFhirMarkdown, FCitation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'url', 'url', false, TFhirUrl, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'document', 'Attachment', false, TFhirAttachment, FDocument.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', 'canonical', false, TFhirCanonical, FResource.Link));{2}
end;

function TFhirRelatedArtifact.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirRelatedArtifactTypeEnum, CODES_TFhirRelatedArtifactTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'label') then
  begin
    Label_Element := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'citation') then
  begin
    CitationElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUrl(propValue){5a};
    result := propValue;
  end
  else if (propName = 'document') then
  begin
    Document := propValue as TFhirAttachment{4b};
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceElement := asCanonical(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirRelatedArtifact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRelatedArtifact.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'label') then result := TFhirString.create() {5b}
  else if (propName = 'display') then result := TFhirString.create() {5b}
  else if (propName = 'citation') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'url') then result := TFhirUrl.create() {5b}
  else if (propName = 'document') then result := TFhirAttachment.create(){4b}
  else if (propName = 'resource') then result := TFhirCanonical.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRelatedArtifact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'label') then result := 'string'
  else if (propName = 'display') then result := 'string'
  else if (propName = 'citation') then result := 'markdown'
  else if (propName = 'url') then result := 'url'
  else if (propName = 'document') then result := 'Attachment'
  else if (propName = 'resource') then result := 'canonical'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRelatedArtifact.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'label') then Label_Element := nil
  else if (propName = 'display') then DisplayElement := nil
  else if (propName = 'citation') then CitationElement := nil
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'document') then DocumentElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRelatedArtifact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirRelatedArtifactTypeEnum, CODES_TFhirRelatedArtifactTypeEnum, new){4}
  else if (propName = 'label') then Label_Element := asString(new){5b}
  else if (propName = 'display') then DisplayElement := asString(new){5b}
  else if (propName = 'citation') then CitationElement := asMarkdown(new){5b}
  else if (propName = 'url') then UrlElement := asUrl(new){5b}
  else if (propName = 'document') then DocumentElement := new as TFhirAttachment{4}
  else if (propName = 'resource') then ResourceElement := asCanonical(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRelatedArtifact.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRelatedArtifact.fhirType : string;
begin
  result := 'RelatedArtifact';
end;

function TFhirRelatedArtifact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FLabel_) and isEmptyProp(FDisplay) and isEmptyProp(FCitation) and isEmptyProp(FUrl) and isEmptyProp(FDocument) and isEmptyProp(FResource);
end;

function TFhirRelatedArtifact.equals(other : TObject) : boolean; 
var
  o : TFhirRelatedArtifact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRelatedArtifact)) then
    result := false
  else
  begin
    o := TFhirRelatedArtifact(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(label_Element, o.label_Element, true) and 
      compareDeep(displayElement, o.displayElement, true) and compareDeep(citationElement, o.citationElement, true) and 
      compareDeep(urlElement, o.urlElement, true) and compareDeep(documentElement, o.documentElement, true) and 
      compareDeep(resourceElement, o.resourceElement, true);
  end;
end;

function TFhirRelatedArtifact.Link : TFhirRelatedArtifact;
begin
  result := TFhirRelatedArtifact(inherited Link);
end;

function TFhirRelatedArtifact.Clone : TFhirRelatedArtifact;
begin
  result := TFhirRelatedArtifact(inherited Clone);
end;

procedure TFhirRelatedArtifact.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('label');
  fields.add('display');
  fields.add('citation');
  fields.add('url');
  fields.add('document');
  fields.add('resource');
end;

{ TFhirRelatedArtifact }

Procedure TFhirRelatedArtifact.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirRelatedArtifact.GetType_ST : TFhirRelatedArtifactTypeEnum;
begin
  if FType_ = nil then
    result := TFhirRelatedArtifactTypeEnum(0)
  else
    result := TFhirRelatedArtifactTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirRelatedArtifactTypeEnum, FType_.value));
end;

Procedure TFhirRelatedArtifact.SetType_ST(value : TFhirRelatedArtifactTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirRelatedArtifactTypeEnum[value], CODES_TFhirRelatedArtifactTypeEnum[value]);
end;

Procedure TFhirRelatedArtifact.SetLabel_(value : TFhirString);
begin
  FLabel_.free;
  FLabel_ := value;
end;

Function TFhirRelatedArtifact.GetLabel_ST : String;
begin
  if FLabel_ = nil then
    result := ''
  else
    result := FLabel_.value;
end;

Procedure TFhirRelatedArtifact.SetLabel_ST(value : String);
begin
  if value <> '' then
  begin
    if FLabel_ = nil then
      FLabel_ := TFhirString.create;
    FLabel_.value := value
  end
  else if FLabel_ <> nil then
    FLabel_.value := '';
end;

Procedure TFhirRelatedArtifact.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirRelatedArtifact.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirRelatedArtifact.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Procedure TFhirRelatedArtifact.SetCitation(value : TFhirMarkdown);
begin
  FCitation.free;
  FCitation := value;
end;

Function TFhirRelatedArtifact.GetCitationST : String;
begin
  if FCitation = nil then
    result := ''
  else
    result := FCitation.value;
end;

Procedure TFhirRelatedArtifact.SetCitationST(value : String);
begin
  if value <> '' then
  begin
    if FCitation = nil then
      FCitation := TFhirMarkdown.create;
    FCitation.value := value
  end
  else if FCitation <> nil then
    FCitation.value := '';
end;

Procedure TFhirRelatedArtifact.SetUrl(value : TFhirUrl);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirRelatedArtifact.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirRelatedArtifact.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUrl.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirRelatedArtifact.SetDocument(value : TFhirAttachment);
begin
  FDocument.free;
  FDocument := value;
end;

Procedure TFhirRelatedArtifact.SetResource(value : TFhirCanonical);
begin
  FResource.free;
  FResource := value;
end;

Function TFhirRelatedArtifact.GetResourceST : String;
begin
  if FResource = nil then
    result := ''
  else
    result := FResource.value;
end;

Procedure TFhirRelatedArtifact.SetResourceST(value : String);
begin
  if value <> '' then
  begin
    if FResource = nil then
      FResource := TFhirCanonical.create;
    FResource.value := value
  end
  else if FResource <> nil then
    FResource.value := '';
end;

function TFhirRelatedArtifact.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FLabel_.sizeInBytes);
  inc(result, FDisplay.sizeInBytes);
  inc(result, FCitation.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
  inc(result, FDocument.sizeInBytes);
  inc(result, FResource.sizeInBytes);
end;

{ TFhirRelatedArtifactListEnumerator }

Constructor TFhirRelatedArtifactListEnumerator.Create(list : TFhirRelatedArtifactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRelatedArtifactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRelatedArtifactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRelatedArtifactListEnumerator.GetCurrent : TFhirRelatedArtifact;
begin
  Result := FList[FIndex];
end;

function TFhirRelatedArtifactListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRelatedArtifactList }
procedure TFhirRelatedArtifactList.AddItem(value: TFhirRelatedArtifact);
begin
  assert(value.ClassName = 'TFhirRelatedArtifact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRelatedArtifact');
  add(value);
end;

function TFhirRelatedArtifactList.Append: TFhirRelatedArtifact;
begin
  result := TFhirRelatedArtifact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRelatedArtifactList.ClearItems;
begin
  Clear;
end;

function TFhirRelatedArtifactList.GetEnumerator : TFhirRelatedArtifactListEnumerator;
begin
  result := TFhirRelatedArtifactListEnumerator.Create(self.link);
end;

function TFhirRelatedArtifactList.Clone: TFhirRelatedArtifactList;
begin
  result := TFhirRelatedArtifactList(inherited Clone);
end;

function TFhirRelatedArtifactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRelatedArtifactList.GetItemN(index: Integer): TFhirRelatedArtifact;
begin
  result := TFhirRelatedArtifact(ObjectByIndex[index]);
end;

function TFhirRelatedArtifactList.ItemClass: TFslObjectClass;
begin
  result := TFhirRelatedArtifact;
end;
function TFhirRelatedArtifactList.IndexOf(value: TFhirRelatedArtifact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRelatedArtifactList.Insert(index: Integer): TFhirRelatedArtifact;
begin
  result := TFhirRelatedArtifact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRelatedArtifactList.InsertItem(index: Integer; value: TFhirRelatedArtifact);
begin
  assert(value is TFhirRelatedArtifact);
  Inherited Insert(index, value);
end;

function TFhirRelatedArtifactList.Item(index: Integer): TFhirRelatedArtifact;
begin
  result := TFhirRelatedArtifact(ObjectByIndex[index]);
end;

function TFhirRelatedArtifactList.Link: TFhirRelatedArtifactList;
begin
  result := TFhirRelatedArtifactList(inherited Link);
end;

procedure TFhirRelatedArtifactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRelatedArtifactList.SetItemByIndex(index: Integer; value: TFhirRelatedArtifact);
begin
  assert(value is TFhirRelatedArtifact);
  FhirRelatedArtifacts[index] := value;
end;

procedure TFhirRelatedArtifactList.SetItemN(index: Integer; value: TFhirRelatedArtifact);
begin
  assert(value is TFhirRelatedArtifact);
  ObjectByIndex[index] := value;
end;

{ TFhirAnnotation }

constructor TFhirAnnotation.Create;
begin
  inherited;
end;

destructor TFhirAnnotation.Destroy;
begin
  FAuthor.free;
  FTime.free;
  FText.free;
  inherited;
end;

procedure TFhirAnnotation.Assign(oSource : TFslObject);
begin
  inherited;
  author := TFhirAnnotation(oSource).author.Clone;
  timeElement := TFhirAnnotation(oSource).timeElement.Clone;
  textElement := TFhirAnnotation(oSource).textElement.Clone;
end;

procedure TFhirAnnotation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'author[x]') or (child_name = 'author') Then
     list.add(self.link, 'author[x]', FAuthor.Link);
  if (child_name = 'time') Then
     list.add(self.link, 'time', FTime.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirAnnotation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'author[x]', 'Reference(Practitioner)|string', false, TFhirType, FAuthor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'time', 'dateTime', false, TFhirDateTime, FTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'markdown', false, TFhirMarkdown, FText.Link));{2}
end;

function TFhirAnnotation.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'author', ['Reference', 'String'])) then
  begin
    Author := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'time') then
  begin
    TimeElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirAnnotation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAnnotation.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'author', ['Reference', 'String'])) then raise EFHIRException.create('Cannot make property Author'){4x}
  else if (propName = 'time') then result := TFhirDateTime.create() {5b}
  else if (propName = 'text') then result := TFhirMarkdown.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAnnotation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'author[x]') then result := 'Reference|string'
  else if (propName = 'time') then result := 'dateTime'
  else if (propName = 'text') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAnnotation.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'author', ['Reference', 'String'])) then AuthorElement := nil{4x}
  else if (propName = 'time') then TimeElement := nil
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAnnotation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'author', ['Reference', 'String'])) then AuthorElement := new as TFhirType{4x}
  else if (propName = 'time') then TimeElement := asDateTime(new){5b}
  else if (propName = 'text') then TextElement := asMarkdown(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAnnotation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAnnotation.fhirType : string;
begin
  result := 'Annotation';
end;

function TFhirAnnotation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAuthor) and isEmptyProp(FTime) and isEmptyProp(FText);
end;

function TFhirAnnotation.equals(other : TObject) : boolean; 
var
  o : TFhirAnnotation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAnnotation)) then
    result := false
  else
  begin
    o := TFhirAnnotation(other);
    result := compareDeep(authorElement, o.authorElement, true) and compareDeep(timeElement, o.timeElement, true) and 
      compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirAnnotation.Link : TFhirAnnotation;
begin
  result := TFhirAnnotation(inherited Link);
end;

function TFhirAnnotation.Clone : TFhirAnnotation;
begin
  result := TFhirAnnotation(inherited Clone);
end;

procedure TFhirAnnotation.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('author[x]');
  fields.add('time');
  fields.add('text');
end;

{ TFhirAnnotation }

Procedure TFhirAnnotation.SetAuthor(value : TFhirType);
begin
  FAuthor.free;
  FAuthor := value;
end;

Procedure TFhirAnnotation.SetTime(value : TFhirDateTime);
begin
  FTime.free;
  FTime := value;
end;

Function TFhirAnnotation.GetTimeST : TFslDateTime;
begin
  if FTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FTime.value;
end;

Procedure TFhirAnnotation.SetTimeST(value : TFslDateTime);
begin
  if FTime = nil then
    FTime := TFhirDateTime.create;
  FTime.value := value
end;

Procedure TFhirAnnotation.SetText(value : TFhirMarkdown);
begin
  FText.free;
  FText := value;
end;

Function TFhirAnnotation.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirAnnotation.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirMarkdown.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

function TFhirAnnotation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAuthor.sizeInBytes);
  inc(result, FTime.sizeInBytes);
  inc(result, FText.sizeInBytes);
end;

{ TFhirAnnotationListEnumerator }

Constructor TFhirAnnotationListEnumerator.Create(list : TFhirAnnotationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAnnotationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAnnotationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAnnotationListEnumerator.GetCurrent : TFhirAnnotation;
begin
  Result := FList[FIndex];
end;

function TFhirAnnotationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAnnotationList }
procedure TFhirAnnotationList.AddItem(value: TFhirAnnotation);
begin
  assert(value.ClassName = 'TFhirAnnotation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAnnotation');
  add(value);
end;

function TFhirAnnotationList.Append: TFhirAnnotation;
begin
  result := TFhirAnnotation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAnnotationList.ClearItems;
begin
  Clear;
end;

function TFhirAnnotationList.GetEnumerator : TFhirAnnotationListEnumerator;
begin
  result := TFhirAnnotationListEnumerator.Create(self.link);
end;

function TFhirAnnotationList.Clone: TFhirAnnotationList;
begin
  result := TFhirAnnotationList(inherited Clone);
end;

function TFhirAnnotationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAnnotationList.GetItemN(index: Integer): TFhirAnnotation;
begin
  result := TFhirAnnotation(ObjectByIndex[index]);
end;

function TFhirAnnotationList.ItemClass: TFslObjectClass;
begin
  result := TFhirAnnotation;
end;
function TFhirAnnotationList.IndexOf(value: TFhirAnnotation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAnnotationList.Insert(index: Integer): TFhirAnnotation;
begin
  result := TFhirAnnotation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAnnotationList.InsertItem(index: Integer; value: TFhirAnnotation);
begin
  assert(value is TFhirAnnotation);
  Inherited Insert(index, value);
end;

function TFhirAnnotationList.Item(index: Integer): TFhirAnnotation;
begin
  result := TFhirAnnotation(ObjectByIndex[index]);
end;

function TFhirAnnotationList.Link: TFhirAnnotationList;
begin
  result := TFhirAnnotationList(inherited Link);
end;

procedure TFhirAnnotationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAnnotationList.SetItemByIndex(index: Integer; value: TFhirAnnotation);
begin
  assert(value is TFhirAnnotation);
  FhirAnnotations[index] := value;
end;

procedure TFhirAnnotationList.SetItemN(index: Integer; value: TFhirAnnotation);
begin
  assert(value is TFhirAnnotation);
  ObjectByIndex[index] := value;
end;

{ TFhirProductShelfLife }

constructor TFhirProductShelfLife.Create;
begin
  inherited;
end;

destructor TFhirProductShelfLife.Destroy;
begin
  FIdentifier.free;
  FType_.free;
  FPeriod.free;
  FSpecialPrecautionsForStorageList.Free;
  inherited;
end;

procedure TFhirProductShelfLife.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirProductShelfLife(oSource).identifier.Clone;
  type_ := TFhirProductShelfLife(oSource).type_.Clone;
  period := TFhirProductShelfLife(oSource).period.Clone;
  if (TFhirProductShelfLife(oSource).FSpecialPrecautionsForStorageList = nil) then
  begin
    FSpecialPrecautionsForStorageList.free;
    FSpecialPrecautionsForStorageList := nil;
  end
  else
  begin
    if FSpecialPrecautionsForStorageList = nil then
      FSpecialPrecautionsForStorageList := TFhirCodeableConceptList.Create;
    FSpecialPrecautionsForStorageList.Assign(TFhirProductShelfLife(oSource).FSpecialPrecautionsForStorageList);
  end;
end;

procedure TFhirProductShelfLife.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'specialPrecautionsForStorage') Then
    list.addAll(self, 'specialPrecautionsForStorage', FSpecialPrecautionsForStorageList);
end;

procedure TFhirProductShelfLife.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Quantity', false, TFhirQuantity, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'specialPrecautionsForStorage', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialPrecautionsForStorageList.Link)){3};
end;

function TFhirProductShelfLife.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'specialPrecautionsForStorage') then
  begin
    SpecialPrecautionsForStorageList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirProductShelfLife.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'specialPrecautionsForStorage') then SpecialPrecautionsForStorageList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirProductShelfLife.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'period') then result := TFhirQuantity.create(){4b}
  else if (propName = 'specialPrecautionsForStorage') then result := SpecialPrecautionsForStorageList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProductShelfLife.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Quantity'
  else if (propName = 'specialPrecautionsForStorage') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProductShelfLife.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'specialPrecautionsForStorage') then deletePropertyValue('specialPrecautionsForStorage', SpecialPrecautionsForStorageList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProductShelfLife.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'period') then PeriodElement := new as TFhirQuantity{4}
  else if (propName = 'specialPrecautionsForStorage') then replacePropertyValue('specialPrecautionsForStorage', SpecialPrecautionsForStorageList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProductShelfLife.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'specialPrecautionsForStorage') then SpecialPrecautionsForStorageList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProductShelfLife.fhirType : string;
begin
  result := 'ProductShelfLife';
end;

function TFhirProductShelfLife.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FType_) and isEmptyProp(FPeriod) and isEmptyProp(FspecialPrecautionsForStorageList);
end;

function TFhirProductShelfLife.equals(other : TObject) : boolean; 
var
  o : TFhirProductShelfLife;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProductShelfLife)) then
    result := false
  else
  begin
    o := TFhirProductShelfLife(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(specialPrecautionsForStorageList, o.specialPrecautionsForStorageList, true);
  end;
end;

function TFhirProductShelfLife.Link : TFhirProductShelfLife;
begin
  result := TFhirProductShelfLife(inherited Link);
end;

function TFhirProductShelfLife.Clone : TFhirProductShelfLife;
begin
  result := TFhirProductShelfLife(inherited Clone);
end;

procedure TFhirProductShelfLife.listFieldsInOrder(fields : TStringList);
begin
  listBackboneTypeFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('period');
  fields.add('specialPrecautionsForStorage');
end;

{ TFhirProductShelfLife }

Procedure TFhirProductShelfLife.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirProductShelfLife.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirProductShelfLife.SetPeriod(value : TFhirQuantity);
begin
  FPeriod.free;
  FPeriod := value;
end;

Function TFhirProductShelfLife.GetSpecialPrecautionsForStorageList : TFhirCodeableConceptList;
begin
  if FSpecialPrecautionsForStorageList = nil then
    FSpecialPrecautionsForStorageList := TFhirCodeableConceptList.Create;
  result := FSpecialPrecautionsForStorageList;
end;

Function TFhirProductShelfLife.GetHasSpecialPrecautionsForStorageList : boolean;
begin
  result := (FSpecialPrecautionsForStorageList <> nil) and (FSpecialPrecautionsForStorageList.count > 0);
end;

function TFhirProductShelfLife.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FspecialPrecautionsForStorageList.sizeInBytes);
end;

{ TFhirProductShelfLifeListEnumerator }

Constructor TFhirProductShelfLifeListEnumerator.Create(list : TFhirProductShelfLifeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProductShelfLifeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProductShelfLifeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProductShelfLifeListEnumerator.GetCurrent : TFhirProductShelfLife;
begin
  Result := FList[FIndex];
end;

function TFhirProductShelfLifeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProductShelfLifeList }
procedure TFhirProductShelfLifeList.AddItem(value: TFhirProductShelfLife);
begin
  assert(value.ClassName = 'TFhirProductShelfLife', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProductShelfLife');
  add(value);
end;

function TFhirProductShelfLifeList.Append: TFhirProductShelfLife;
begin
  result := TFhirProductShelfLife.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProductShelfLifeList.ClearItems;
begin
  Clear;
end;

function TFhirProductShelfLifeList.GetEnumerator : TFhirProductShelfLifeListEnumerator;
begin
  result := TFhirProductShelfLifeListEnumerator.Create(self.link);
end;

function TFhirProductShelfLifeList.Clone: TFhirProductShelfLifeList;
begin
  result := TFhirProductShelfLifeList(inherited Clone);
end;

function TFhirProductShelfLifeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProductShelfLifeList.GetItemN(index: Integer): TFhirProductShelfLife;
begin
  result := TFhirProductShelfLife(ObjectByIndex[index]);
end;

function TFhirProductShelfLifeList.ItemClass: TFslObjectClass;
begin
  result := TFhirProductShelfLife;
end;
function TFhirProductShelfLifeList.IndexOf(value: TFhirProductShelfLife): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProductShelfLifeList.Insert(index: Integer): TFhirProductShelfLife;
begin
  result := TFhirProductShelfLife.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProductShelfLifeList.InsertItem(index: Integer; value: TFhirProductShelfLife);
begin
  assert(value is TFhirProductShelfLife);
  Inherited Insert(index, value);
end;

function TFhirProductShelfLifeList.Item(index: Integer): TFhirProductShelfLife;
begin
  result := TFhirProductShelfLife(ObjectByIndex[index]);
end;

function TFhirProductShelfLifeList.Link: TFhirProductShelfLifeList;
begin
  result := TFhirProductShelfLifeList(inherited Link);
end;

procedure TFhirProductShelfLifeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProductShelfLifeList.SetItemByIndex(index: Integer; value: TFhirProductShelfLife);
begin
  assert(value is TFhirProductShelfLife);
  FhirProductShelfLives[index] := value;
end;

procedure TFhirProductShelfLifeList.SetItemN(index: Integer; value: TFhirProductShelfLife);
begin
  assert(value is TFhirProductShelfLife);
  ObjectByIndex[index] := value;
end;

{ TFhirContactDetail }

constructor TFhirContactDetail.Create;
begin
  inherited;
end;

destructor TFhirContactDetail.Destroy;
begin
  FName.free;
  FTelecomList.Free;
  inherited;
end;

procedure TFhirContactDetail.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirContactDetail(oSource).nameElement.Clone;
  if (TFhirContactDetail(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirContactDetail(oSource).FTelecomList);
  end;
end;

procedure TFhirContactDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
end;

procedure TFhirContactDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
end;

function TFhirContactDetail.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirContactDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else inherited;
end;

function TFhirContactDetail.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContactDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContactDetail.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContactDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContactDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContactDetail.fhirType : string;
begin
  result := 'ContactDetail';
end;

function TFhirContactDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FtelecomList);
end;

function TFhirContactDetail.equals(other : TObject) : boolean; 
var
  o : TFhirContactDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContactDetail)) then
    result := false
  else
  begin
    o := TFhirContactDetail(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(telecomList, o.telecomList, true);
  end;
end;

function TFhirContactDetail.Link : TFhirContactDetail;
begin
  result := TFhirContactDetail(inherited Link);
end;

function TFhirContactDetail.Clone : TFhirContactDetail;
begin
  result := TFhirContactDetail(inherited Clone);
end;

procedure TFhirContactDetail.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('telecom');
end;

{ TFhirContactDetail }

Procedure TFhirContactDetail.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirContactDetail.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirContactDetail.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Function TFhirContactDetail.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirContactDetail.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirContactDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FtelecomList.sizeInBytes);
end;

{ TFhirContactDetailListEnumerator }

Constructor TFhirContactDetailListEnumerator.Create(list : TFhirContactDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContactDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContactDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContactDetailListEnumerator.GetCurrent : TFhirContactDetail;
begin
  Result := FList[FIndex];
end;

function TFhirContactDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContactDetailList }
procedure TFhirContactDetailList.AddItem(value: TFhirContactDetail);
begin
  assert(value.ClassName = 'TFhirContactDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContactDetail');
  add(value);
end;

function TFhirContactDetailList.Append: TFhirContactDetail;
begin
  result := TFhirContactDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContactDetailList.ClearItems;
begin
  Clear;
end;

function TFhirContactDetailList.GetEnumerator : TFhirContactDetailListEnumerator;
begin
  result := TFhirContactDetailListEnumerator.Create(self.link);
end;

function TFhirContactDetailList.Clone: TFhirContactDetailList;
begin
  result := TFhirContactDetailList(inherited Clone);
end;

function TFhirContactDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContactDetailList.GetItemN(index: Integer): TFhirContactDetail;
begin
  result := TFhirContactDetail(ObjectByIndex[index]);
end;

function TFhirContactDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirContactDetail;
end;
function TFhirContactDetailList.IndexOf(value: TFhirContactDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContactDetailList.Insert(index: Integer): TFhirContactDetail;
begin
  result := TFhirContactDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContactDetailList.InsertItem(index: Integer; value: TFhirContactDetail);
begin
  assert(value is TFhirContactDetail);
  Inherited Insert(index, value);
end;

function TFhirContactDetailList.Item(index: Integer): TFhirContactDetail;
begin
  result := TFhirContactDetail(ObjectByIndex[index]);
end;

function TFhirContactDetailList.Link: TFhirContactDetailList;
begin
  result := TFhirContactDetailList(inherited Link);
end;

procedure TFhirContactDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContactDetailList.SetItemByIndex(index: Integer; value: TFhirContactDetail);
begin
  assert(value is TFhirContactDetail);
  FhirContactDetails[index] := value;
end;

procedure TFhirContactDetailList.SetItemN(index: Integer; value: TFhirContactDetail);
begin
  assert(value is TFhirContactDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirExpression }

constructor TFhirExpression.Create;
begin
  inherited;
end;

destructor TFhirExpression.Destroy;
begin
  FDescription.free;
  FName.free;
  FLanguage.free;
  FExpression.free;
  FReference.free;
  inherited;
end;

procedure TFhirExpression.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirExpression(oSource).descriptionElement.Clone;
  nameElement := TFhirExpression(oSource).nameElement.Clone;
  languageElement := TFhirExpression(oSource).languageElement.Clone;
  expressionElement := TFhirExpression(oSource).expressionElement.Clone;
  referenceElement := TFhirExpression(oSource).referenceElement.Clone;
end;

procedure TFhirExpression.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirExpression.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'id', false, TFhirId, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'language', 'code', false, TFhirCode, FLanguage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expression', 'string', false, TFhirString, FExpression.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'uri', false, TFhirUri, FReference.Link));{2}
end;

function TFhirExpression.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    LanguageElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    ExpressionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    ReferenceElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirExpression.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExpression.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'name') then result := TFhirId.create() {5b}
  else if (propName = 'language') then result := TFhirCode.create() {5b}
  else if (propName = 'expression') then result := TFhirString.create() {5b}
  else if (propName = 'reference') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExpression.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'name') then result := 'id'
  else if (propName = 'language') then result := 'code'
  else if (propName = 'expression') then result := 'string'
  else if (propName = 'reference') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExpression.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExpression.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'name') then NameElement := asId(new){5b}
  else if (propName = 'language') then LanguageElement := asCode(new){5b}
  else if (propName = 'expression') then ExpressionElement := asString(new){5b}
  else if (propName = 'reference') then ReferenceElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExpression.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExpression.fhirType : string;
begin
  result := 'Expression';
end;

function TFhirExpression.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FName) and isEmptyProp(FLanguage) and isEmptyProp(FExpression) and isEmptyProp(FReference);
end;

function TFhirExpression.equals(other : TObject) : boolean; 
var
  o : TFhirExpression;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExpression)) then
    result := false
  else
  begin
    o := TFhirExpression(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(languageElement, o.languageElement, true) and compareDeep(expressionElement, o.expressionElement, true) and 
      compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirExpression.Link : TFhirExpression;
begin
  result := TFhirExpression(inherited Link);
end;

function TFhirExpression.Clone : TFhirExpression;
begin
  result := TFhirExpression(inherited Clone);
end;

procedure TFhirExpression.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('name');
  fields.add('language');
  fields.add('expression');
  fields.add('reference');
end;

{ TFhirExpression }

Procedure TFhirExpression.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirExpression.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirExpression.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirExpression.SetName(value : TFhirId);
begin
  FName.free;
  FName := value;
end;

Function TFhirExpression.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirExpression.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirId.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirExpression.SetLanguage(value : TFhirCode);
begin
  FLanguage.free;
  FLanguage := value;
end;

Function TFhirExpression.GetLanguageST : String;
begin
  if FLanguage = nil then
    result := ''
  else
    result := FLanguage.value;
end;

Procedure TFhirExpression.SetLanguageST(value : String);
begin
  if value <> '' then
  begin
    if FLanguage = nil then
      FLanguage := TFhirCode.create;
    FLanguage.value := value
  end
  else if FLanguage <> nil then
    FLanguage.value := '';
end;

Procedure TFhirExpression.SetExpression(value : TFhirString);
begin
  FExpression.free;
  FExpression := value;
end;

Function TFhirExpression.GetExpressionST : String;
begin
  if FExpression = nil then
    result := ''
  else
    result := FExpression.value;
end;

Procedure TFhirExpression.SetExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FExpression = nil then
      FExpression := TFhirString.create;
    FExpression.value := value
  end
  else if FExpression <> nil then
    FExpression.value := '';
end;

Procedure TFhirExpression.SetReference(value : TFhirUri);
begin
  FReference.free;
  FReference := value;
end;

Function TFhirExpression.GetReferenceST : String;
begin
  if FReference = nil then
    result := ''
  else
    result := FReference.value;
end;

Procedure TFhirExpression.SetReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FReference = nil then
      FReference := TFhirUri.create;
    FReference.value := value
  end
  else if FReference <> nil then
    FReference.value := '';
end;

function TFhirExpression.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDescription.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FLanguage.sizeInBytes);
  inc(result, FExpression.sizeInBytes);
  inc(result, FReference.sizeInBytes);
end;

{ TFhirExpressionListEnumerator }

Constructor TFhirExpressionListEnumerator.Create(list : TFhirExpressionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExpressionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExpressionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExpressionListEnumerator.GetCurrent : TFhirExpression;
begin
  Result := FList[FIndex];
end;

function TFhirExpressionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExpressionList }
procedure TFhirExpressionList.AddItem(value: TFhirExpression);
begin
  assert(value.ClassName = 'TFhirExpression', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExpression');
  add(value);
end;

function TFhirExpressionList.Append: TFhirExpression;
begin
  result := TFhirExpression.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExpressionList.ClearItems;
begin
  Clear;
end;

function TFhirExpressionList.GetEnumerator : TFhirExpressionListEnumerator;
begin
  result := TFhirExpressionListEnumerator.Create(self.link);
end;

function TFhirExpressionList.Clone: TFhirExpressionList;
begin
  result := TFhirExpressionList(inherited Clone);
end;

function TFhirExpressionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExpressionList.GetItemN(index: Integer): TFhirExpression;
begin
  result := TFhirExpression(ObjectByIndex[index]);
end;

function TFhirExpressionList.ItemClass: TFslObjectClass;
begin
  result := TFhirExpression;
end;
function TFhirExpressionList.IndexOf(value: TFhirExpression): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExpressionList.Insert(index: Integer): TFhirExpression;
begin
  result := TFhirExpression.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExpressionList.InsertItem(index: Integer; value: TFhirExpression);
begin
  assert(value is TFhirExpression);
  Inherited Insert(index, value);
end;

function TFhirExpressionList.Item(index: Integer): TFhirExpression;
begin
  result := TFhirExpression(ObjectByIndex[index]);
end;

function TFhirExpressionList.Link: TFhirExpressionList;
begin
  result := TFhirExpressionList(inherited Link);
end;

procedure TFhirExpressionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExpressionList.SetItemByIndex(index: Integer; value: TFhirExpression);
begin
  assert(value is TFhirExpression);
  FhirExpressions[index] := value;
end;

procedure TFhirExpressionList.SetItemN(index: Integer; value: TFhirExpression);
begin
  assert(value is TFhirExpression);
  ObjectByIndex[index] := value;
end;

{ TFhirUsageContext }

constructor TFhirUsageContext.Create;
begin
  inherited;
end;

destructor TFhirUsageContext.Destroy;
begin
  FCode.free;
  FValue.free;
  inherited;
end;

procedure TFhirUsageContext.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirUsageContext(oSource).code.Clone;
  value := TFhirUsageContext(oSource).value.Clone;
end;

procedure TFhirUsageContext.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirUsageContext.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', false, TFhirCoding, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity|Range|Reference(PlanDefinition)', false, TFhirType, FValue.Link));{2}
end;

function TFhirUsageContext.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range', 'Reference'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirUsageContext.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirUsageContext.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCoding.create(){4b}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range', 'Reference'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirUsageContext.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'Coding'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity|Range|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirUsageContext.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range', 'Reference'])) then ValueElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirUsageContext.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCoding{4}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range', 'Reference'])) then ValueElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirUsageContext.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirUsageContext.fhirType : string;
begin
  result := 'UsageContext';
end;

function TFhirUsageContext.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue);
end;

function TFhirUsageContext.equals(other : TObject) : boolean; 
var
  o : TFhirUsageContext;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirUsageContext)) then
    result := false
  else
  begin
    o := TFhirUsageContext(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirUsageContext.Link : TFhirUsageContext;
begin
  result := TFhirUsageContext(inherited Link);
end;

function TFhirUsageContext.Clone : TFhirUsageContext;
begin
  result := TFhirUsageContext(inherited Clone);
end;

procedure TFhirUsageContext.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('value[x]');
end;

{ TFhirUsageContext }

Procedure TFhirUsageContext.SetCode(value : TFhirCoding);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirUsageContext.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

function TFhirUsageContext.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirUsageContextListEnumerator }

Constructor TFhirUsageContextListEnumerator.Create(list : TFhirUsageContextList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirUsageContextListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirUsageContextListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirUsageContextListEnumerator.GetCurrent : TFhirUsageContext;
begin
  Result := FList[FIndex];
end;

function TFhirUsageContextListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirUsageContextList }
procedure TFhirUsageContextList.AddItem(value: TFhirUsageContext);
begin
  assert(value.ClassName = 'TFhirUsageContext', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirUsageContext');
  add(value);
end;

function TFhirUsageContextList.Append: TFhirUsageContext;
begin
  result := TFhirUsageContext.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirUsageContextList.ClearItems;
begin
  Clear;
end;

function TFhirUsageContextList.GetEnumerator : TFhirUsageContextListEnumerator;
begin
  result := TFhirUsageContextListEnumerator.Create(self.link);
end;

function TFhirUsageContextList.Clone: TFhirUsageContextList;
begin
  result := TFhirUsageContextList(inherited Clone);
end;

function TFhirUsageContextList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirUsageContextList.GetItemN(index: Integer): TFhirUsageContext;
begin
  result := TFhirUsageContext(ObjectByIndex[index]);
end;

function TFhirUsageContextList.ItemClass: TFslObjectClass;
begin
  result := TFhirUsageContext;
end;
function TFhirUsageContextList.IndexOf(value: TFhirUsageContext): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirUsageContextList.Insert(index: Integer): TFhirUsageContext;
begin
  result := TFhirUsageContext.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirUsageContextList.InsertItem(index: Integer; value: TFhirUsageContext);
begin
  assert(value is TFhirUsageContext);
  Inherited Insert(index, value);
end;

function TFhirUsageContextList.Item(index: Integer): TFhirUsageContext;
begin
  result := TFhirUsageContext(ObjectByIndex[index]);
end;

function TFhirUsageContextList.Link: TFhirUsageContextList;
begin
  result := TFhirUsageContextList(inherited Link);
end;

procedure TFhirUsageContextList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirUsageContextList.SetItemByIndex(index: Integer; value: TFhirUsageContext);
begin
  assert(value is TFhirUsageContext);
  FhirUsageContexts[index] := value;
end;

procedure TFhirUsageContextList.SetItemN(index: Integer; value: TFhirUsageContext);
begin
  assert(value is TFhirUsageContext);
  ObjectByIndex[index] := value;
end;

{ TFhirSignature }

constructor TFhirSignature.Create;
begin
  inherited;
end;

destructor TFhirSignature.Destroy;
begin
  FType_List.Free;
  FWhen.free;
  FWho.free;
  FOnBehalfOf.free;
  FTargetFormat.free;
  FSigFormat.free;
  FData.free;
  inherited;
end;

procedure TFhirSignature.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSignature(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodingList.Create;
    FType_List.Assign(TFhirSignature(oSource).FType_List);
  end;
  whenElement := TFhirSignature(oSource).whenElement.Clone;
  who := TFhirSignature(oSource).who.Clone;
  onBehalfOf := TFhirSignature(oSource).onBehalfOf.Clone;
  targetFormatElement := TFhirSignature(oSource).targetFormatElement.Clone;
  sigFormatElement := TFhirSignature(oSource).sigFormatElement.Clone;
  dataElement := TFhirSignature(oSource).dataElement.Clone;
end;

procedure TFhirSignature.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'when') Then
     list.add(self.link, 'when', FWhen.Link);
  if (child_name = 'who') Then
     list.add(self.link, 'who', FWho.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
  if (child_name = 'targetFormat') Then
     list.add(self.link, 'targetFormat', FTargetFormat.Link);
  if (child_name = 'sigFormat') Then
     list.add(self.link, 'sigFormat', FSigFormat.Link);
  if (child_name = 'data') Then
     list.add(self.link, 'data', FData.Link);
end;

procedure TFhirSignature.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', true, TFhirCoding, FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'when', 'instant', false, TFhirInstant, FWhen.Link));{2}
  oList.add(TFHIRProperty.create(self, 'who', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FWho.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FOnBehalfOf.Link));{2}
  oList.add(TFHIRProperty.create(self, 'targetFormat', 'code', false, TFhirCode, FTargetFormat.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sigFormat', 'code', false, TFhirCode, FSigFormat.Link));{2}
  oList.add(TFHIRProperty.create(self, 'data', 'base64Binary', false, TFhirBase64Binary, FData.Link));{2}
end;

function TFhirSignature.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'when') then
  begin
    WhenElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'who') then
  begin
    Who := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'targetFormat') then
  begin
    TargetFormatElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'sigFormat') then
  begin
    SigFormatElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'data') then
  begin
    DataElement := asBase64Binary(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSignature.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCoding){2a}
  else inherited;
end;

function TFhirSignature.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'when') then result := TFhirInstant.create() {5b}
  else if (propName = 'who') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'onBehalfOf') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'targetFormat') then result := TFhirCode.create() {5b}
  else if (propName = 'sigFormat') then result := TFhirCode.create() {5b}
  else if (propName = 'data') then result := TFhirBase64Binary.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSignature.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'Coding'
  else if (propName = 'when') then result := 'instant'
  else if (propName = 'who') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else if (propName = 'targetFormat') then result := 'code'
  else if (propName = 'sigFormat') then result := 'code'
  else if (propName = 'data') then result := 'base64Binary'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSignature.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'when') then WhenElement := nil
  else if (propName = 'who') then WhoElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else if (propName = 'targetFormat') then TargetFormatElement := nil
  else if (propName = 'sigFormat') then SigFormatElement := nil
  else if (propName = 'data') then DataElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSignature.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'when') then WhenElement := asInstant(new){5b}
  else if (propName = 'who') then WhoElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'targetFormat') then TargetFormatElement := asCode(new){5b}
  else if (propName = 'sigFormat') then SigFormatElement := asCode(new){5b}
  else if (propName = 'data') then DataElement := asBase64Binary(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSignature.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSignature.fhirType : string;
begin
  result := 'Signature';
end;

function TFhirSignature.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Ftype_List) and isEmptyProp(FWhen) and isEmptyProp(FWho) and isEmptyProp(FOnBehalfOf) and isEmptyProp(FTargetFormat) and isEmptyProp(FSigFormat) and isEmptyProp(FData);
end;

function TFhirSignature.equals(other : TObject) : boolean; 
var
  o : TFhirSignature;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSignature)) then
    result := false
  else
  begin
    o := TFhirSignature(other);
    result := compareDeep(type_List, o.type_List, true) and compareDeep(whenElement, o.whenElement, true) and 
      compareDeep(whoElement, o.whoElement, true) and compareDeep(onBehalfOfElement, o.onBehalfOfElement, true) and 
      compareDeep(targetFormatElement, o.targetFormatElement, true) and compareDeep(sigFormatElement, o.sigFormatElement, true) and 
      compareDeep(dataElement, o.dataElement, true);
  end;
end;

function TFhirSignature.Link : TFhirSignature;
begin
  result := TFhirSignature(inherited Link);
end;

function TFhirSignature.Clone : TFhirSignature;
begin
  result := TFhirSignature(inherited Clone);
end;

procedure TFhirSignature.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('when');
  fields.add('who');
  fields.add('onBehalfOf');
  fields.add('targetFormat');
  fields.add('sigFormat');
  fields.add('data');
end;

{ TFhirSignature }

Function TFhirSignature.GetType_List : TFhirCodingList;
begin
  if FType_List = nil then
    FType_List := TFhirCodingList.Create;
  result := FType_List;
end;

Function TFhirSignature.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Procedure TFhirSignature.SetWhen(value : TFhirInstant);
begin
  FWhen.free;
  FWhen := value;
end;

Function TFhirSignature.GetWhenST : TFslDateTime;
begin
  if FWhen = nil then
    result := TFslDateTime.makeNull
  else
    result := FWhen.value;
end;

Procedure TFhirSignature.SetWhenST(value : TFslDateTime);
begin
  if FWhen = nil then
    FWhen := TFhirInstant.create;
  FWhen.value := value
end;

Procedure TFhirSignature.SetWho(value : TFhirReference{TFhirPractitioner});
begin
  FWho.free;
  FWho := value;
end;

Procedure TFhirSignature.SetOnBehalfOf(value : TFhirReference{TFhirPractitioner});
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

Procedure TFhirSignature.SetTargetFormat(value : TFhirCode);
begin
  FTargetFormat.free;
  FTargetFormat := value;
end;

Function TFhirSignature.GetTargetFormatST : String;
begin
  if FTargetFormat = nil then
    result := ''
  else
    result := FTargetFormat.value;
end;

Procedure TFhirSignature.SetTargetFormatST(value : String);
begin
  if value <> '' then
  begin
    if FTargetFormat = nil then
      FTargetFormat := TFhirCode.create;
    FTargetFormat.value := value
  end
  else if FTargetFormat <> nil then
    FTargetFormat.value := '';
end;

Procedure TFhirSignature.SetSigFormat(value : TFhirCode);
begin
  FSigFormat.free;
  FSigFormat := value;
end;

Function TFhirSignature.GetSigFormatST : String;
begin
  if FSigFormat = nil then
    result := ''
  else
    result := FSigFormat.value;
end;

Procedure TFhirSignature.SetSigFormatST(value : String);
begin
  if value <> '' then
  begin
    if FSigFormat = nil then
      FSigFormat := TFhirCode.create;
    FSigFormat.value := value
  end
  else if FSigFormat <> nil then
    FSigFormat.value := '';
end;

Procedure TFhirSignature.SetData(value : TFhirBase64Binary);
begin
  FData.free;
  FData := value;
end;

Function TFhirSignature.GetDataST : TBytes;
begin
  if FData = nil then
    result := nil
  else
    result := FData.value;
end;

Procedure TFhirSignature.SetDataST(value : TBytes);
begin
  if value <> nil then
  begin
    if FData = nil then
      FData := TFhirBase64Binary.create;
    FData.value := value
  end
  else if FData <> nil then
    FData.value := nil;
end;

function TFhirSignature.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FWhen.sizeInBytes);
  inc(result, FWho.sizeInBytes);
  inc(result, FOnBehalfOf.sizeInBytes);
  inc(result, FTargetFormat.sizeInBytes);
  inc(result, FSigFormat.sizeInBytes);
  inc(result, FData.sizeInBytes);
end;

{ TFhirSignatureListEnumerator }

Constructor TFhirSignatureListEnumerator.Create(list : TFhirSignatureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSignatureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSignatureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSignatureListEnumerator.GetCurrent : TFhirSignature;
begin
  Result := FList[FIndex];
end;

function TFhirSignatureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSignatureList }
procedure TFhirSignatureList.AddItem(value: TFhirSignature);
begin
  assert(value.ClassName = 'TFhirSignature', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSignature');
  add(value);
end;

function TFhirSignatureList.Append: TFhirSignature;
begin
  result := TFhirSignature.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSignatureList.ClearItems;
begin
  Clear;
end;

function TFhirSignatureList.GetEnumerator : TFhirSignatureListEnumerator;
begin
  result := TFhirSignatureListEnumerator.Create(self.link);
end;

function TFhirSignatureList.Clone: TFhirSignatureList;
begin
  result := TFhirSignatureList(inherited Clone);
end;

function TFhirSignatureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSignatureList.GetItemN(index: Integer): TFhirSignature;
begin
  result := TFhirSignature(ObjectByIndex[index]);
end;

function TFhirSignatureList.ItemClass: TFslObjectClass;
begin
  result := TFhirSignature;
end;
function TFhirSignatureList.IndexOf(value: TFhirSignature): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSignatureList.Insert(index: Integer): TFhirSignature;
begin
  result := TFhirSignature.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSignatureList.InsertItem(index: Integer; value: TFhirSignature);
begin
  assert(value is TFhirSignature);
  Inherited Insert(index, value);
end;

function TFhirSignatureList.Item(index: Integer): TFhirSignature;
begin
  result := TFhirSignature(ObjectByIndex[index]);
end;

function TFhirSignatureList.Link: TFhirSignatureList;
begin
  result := TFhirSignatureList(inherited Link);
end;

procedure TFhirSignatureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSignatureList.SetItemByIndex(index: Integer; value: TFhirSignature);
begin
  assert(value is TFhirSignature);
  FhirSignatures[index] := value;
end;

procedure TFhirSignatureList.SetItemN(index: Integer; value: TFhirSignature);
begin
  assert(value is TFhirSignature);
  ObjectByIndex[index] := value;
end;

{ TFhirProdCharacteristic }

constructor TFhirProdCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirProdCharacteristic.Destroy;
begin
  FHeight.free;
  FWidth.free;
  FDepth.free;
  FWeight.free;
  FNominalVolume.free;
  FExternalDiameter.free;
  FShape.free;
  FColorList.Free;
  FImprintList.Free;
  FImageList.Free;
  FScoring.free;
  inherited;
end;

procedure TFhirProdCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  height := TFhirProdCharacteristic(oSource).height.Clone;
  width := TFhirProdCharacteristic(oSource).width.Clone;
  depth := TFhirProdCharacteristic(oSource).depth.Clone;
  weight := TFhirProdCharacteristic(oSource).weight.Clone;
  nominalVolume := TFhirProdCharacteristic(oSource).nominalVolume.Clone;
  externalDiameter := TFhirProdCharacteristic(oSource).externalDiameter.Clone;
  shapeElement := TFhirProdCharacteristic(oSource).shapeElement.Clone;
  if (TFhirProdCharacteristic(oSource).FColorList = nil) then
  begin
    FColorList.free;
    FColorList := nil;
  end
  else
  begin
    if FColorList = nil then
      FColorList := TFhirStringList.Create;
    FColorList.Assign(TFhirProdCharacteristic(oSource).FColorList);
  end;
  if (TFhirProdCharacteristic(oSource).FImprintList = nil) then
  begin
    FImprintList.free;
    FImprintList := nil;
  end
  else
  begin
    if FImprintList = nil then
      FImprintList := TFhirStringList.Create;
    FImprintList.Assign(TFhirProdCharacteristic(oSource).FImprintList);
  end;
  if (TFhirProdCharacteristic(oSource).FImageList = nil) then
  begin
    FImageList.free;
    FImageList := nil;
  end
  else
  begin
    if FImageList = nil then
      FImageList := TFhirAttachmentList.Create;
    FImageList.Assign(TFhirProdCharacteristic(oSource).FImageList);
  end;
  scoring := TFhirProdCharacteristic(oSource).scoring.Clone;
end;

procedure TFhirProdCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'height') Then
     list.add(self.link, 'height', FHeight.Link);
  if (child_name = 'width') Then
     list.add(self.link, 'width', FWidth.Link);
  if (child_name = 'depth') Then
     list.add(self.link, 'depth', FDepth.Link);
  if (child_name = 'weight') Then
     list.add(self.link, 'weight', FWeight.Link);
  if (child_name = 'nominalVolume') Then
     list.add(self.link, 'nominalVolume', FNominalVolume.Link);
  if (child_name = 'externalDiameter') Then
     list.add(self.link, 'externalDiameter', FExternalDiameter.Link);
  if (child_name = 'shape') Then
     list.add(self.link, 'shape', FShape.Link);
  if (child_name = 'color') Then
    list.addAll(self, 'color', FColorList);
  if (child_name = 'imprint') Then
    list.addAll(self, 'imprint', FImprintList);
  if (child_name = 'image') Then
    list.addAll(self, 'image', FImageList);
  if (child_name = 'scoring') Then
     list.add(self.link, 'scoring', FScoring.Link);
end;

procedure TFhirProdCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'height', 'Quantity', false, TFhirQuantity, FHeight.Link));{2}
  oList.add(TFHIRProperty.create(self, 'width', 'Quantity', false, TFhirQuantity, FWidth.Link));{2}
  oList.add(TFHIRProperty.create(self, 'depth', 'Quantity', false, TFhirQuantity, FDepth.Link));{2}
  oList.add(TFHIRProperty.create(self, 'weight', 'Quantity', false, TFhirQuantity, FWeight.Link));{2}
  oList.add(TFHIRProperty.create(self, 'nominalVolume', 'Quantity', false, TFhirQuantity, FNominalVolume.Link));{2}
  oList.add(TFHIRProperty.create(self, 'externalDiameter', 'Quantity', false, TFhirQuantity, FExternalDiameter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'shape', 'string', false, TFhirString, FShape.Link));{2}
  oList.add(TFHIRProperty.create(self, 'color', 'string', true, TFhirString, FColorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'imprint', 'string', true, TFhirString, FImprintList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'image', 'Attachment', true, TFhirAttachment, FImageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'scoring', 'CodeableConcept', false, TFhirCodeableConcept, FScoring.Link));{2}
end;

function TFhirProdCharacteristic.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'height') then
  begin
    Height := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'width') then
  begin
    Width := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'depth') then
  begin
    Depth := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'weight') then
  begin
    Weight := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'nominalVolume') then
  begin
    NominalVolume := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'externalDiameter') then
  begin
    ExternalDiameter := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'shape') then
  begin
    ShapeElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'color') then
  begin
    ColorList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'imprint') then
  begin
    ImprintList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'image') then
  begin
    ImageList.add(propValue as TFhirAttachment){2a};
    result := propValue;
  end
  else if (propName = 'scoring') then
  begin
    Scoring := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirProdCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'color') then ColorList.insertItem(index, asString(propValue)){2}
  else if (propName = 'imprint') then ImprintList.insertItem(index, asString(propValue)){2}
  else if (propName = 'image') then ImageList.insertItem(index, propValue as TFhirAttachment){2a}
  else inherited;
end;

function TFhirProdCharacteristic.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'height') then result := TFhirQuantity.create(){4b}
  else if (propName = 'width') then result := TFhirQuantity.create(){4b}
  else if (propName = 'depth') then result := TFhirQuantity.create(){4b}
  else if (propName = 'weight') then result := TFhirQuantity.create(){4b}
  else if (propName = 'nominalVolume') then result := TFhirQuantity.create(){4b}
  else if (propName = 'externalDiameter') then result := TFhirQuantity.create(){4b}
  else if (propName = 'shape') then result := TFhirString.create() {5b}
  else if (propName = 'color') then result := ColorList.new(){2}
  else if (propName = 'imprint') then result := ImprintList.new(){2}
  else if (propName = 'image') then result := ImageList.new(){2}
  else if (propName = 'scoring') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProdCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'height') then result := 'Quantity'
  else if (propName = 'width') then result := 'Quantity'
  else if (propName = 'depth') then result := 'Quantity'
  else if (propName = 'weight') then result := 'Quantity'
  else if (propName = 'nominalVolume') then result := 'Quantity'
  else if (propName = 'externalDiameter') then result := 'Quantity'
  else if (propName = 'shape') then result := 'string'
  else if (propName = 'color') then result := 'string'
  else if (propName = 'imprint') then result := 'string'
  else if (propName = 'image') then result := 'Attachment'
  else if (propName = 'scoring') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProdCharacteristic.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'height') then HeightElement := nil
  else if (propName = 'width') then WidthElement := nil
  else if (propName = 'depth') then DepthElement := nil
  else if (propName = 'weight') then WeightElement := nil
  else if (propName = 'nominalVolume') then NominalVolumeElement := nil
  else if (propName = 'externalDiameter') then ExternalDiameterElement := nil
  else if (propName = 'shape') then ShapeElement := nil
  else if (propName = 'color') then deletePropertyValue('color', ColorList, value) {2}
  else if (propName = 'imprint') then deletePropertyValue('imprint', ImprintList, value) {2}
  else if (propName = 'image') then deletePropertyValue('image', ImageList, value) {2}
  else if (propName = 'scoring') then ScoringElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProdCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'height') then HeightElement := new as TFhirQuantity{4}
  else if (propName = 'width') then WidthElement := new as TFhirQuantity{4}
  else if (propName = 'depth') then DepthElement := new as TFhirQuantity{4}
  else if (propName = 'weight') then WeightElement := new as TFhirQuantity{4}
  else if (propName = 'nominalVolume') then NominalVolumeElement := new as TFhirQuantity{4}
  else if (propName = 'externalDiameter') then ExternalDiameterElement := new as TFhirQuantity{4}
  else if (propName = 'shape') then ShapeElement := asString(new){5b}
  else if (propName = 'color') then replacePropertyValue('color', ColorList, existing, new) {2}
  else if (propName = 'imprint') then replacePropertyValue('imprint', ImprintList, existing, new) {2}
  else if (propName = 'image') then replacePropertyValue('image', ImageList, existing, new) {2}
  else if (propName = 'scoring') then ScoringElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProdCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'color') then ColorList.move(source, destination){2}
  else if (propName = 'imprint') then ImprintList.move(source, destination){2}
  else if (propName = 'image') then ImageList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProdCharacteristic.fhirType : string;
begin
  result := 'ProdCharacteristic';
end;

function TFhirProdCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FHeight) and isEmptyProp(FWidth) and isEmptyProp(FDepth) and isEmptyProp(FWeight) and isEmptyProp(FNominalVolume) and isEmptyProp(FExternalDiameter) and isEmptyProp(FShape) and isEmptyProp(FcolorList) and isEmptyProp(FimprintList) and isEmptyProp(FimageList) and isEmptyProp(FScoring);
end;

function TFhirProdCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirProdCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProdCharacteristic)) then
    result := false
  else
  begin
    o := TFhirProdCharacteristic(other);
    result := compareDeep(heightElement, o.heightElement, true) and compareDeep(widthElement, o.widthElement, true) and 
      compareDeep(depthElement, o.depthElement, true) and compareDeep(weightElement, o.weightElement, true) and 
      compareDeep(nominalVolumeElement, o.nominalVolumeElement, true) and compareDeep(externalDiameterElement, o.externalDiameterElement, true) and 
      compareDeep(shapeElement, o.shapeElement, true) and compareDeep(colorList, o.colorList, true) and 
      compareDeep(imprintList, o.imprintList, true) and compareDeep(imageList, o.imageList, true) and 
      compareDeep(scoringElement, o.scoringElement, true);
  end;
end;

function TFhirProdCharacteristic.Link : TFhirProdCharacteristic;
begin
  result := TFhirProdCharacteristic(inherited Link);
end;

function TFhirProdCharacteristic.Clone : TFhirProdCharacteristic;
begin
  result := TFhirProdCharacteristic(inherited Clone);
end;

procedure TFhirProdCharacteristic.listFieldsInOrder(fields : TStringList);
begin
  listBackboneTypeFieldsInOrder(fields);
  fields.add('height');
  fields.add('width');
  fields.add('depth');
  fields.add('weight');
  fields.add('nominalVolume');
  fields.add('externalDiameter');
  fields.add('shape');
  fields.add('color');
  fields.add('imprint');
  fields.add('image');
  fields.add('scoring');
end;

{ TFhirProdCharacteristic }

Procedure TFhirProdCharacteristic.SetHeight(value : TFhirQuantity);
begin
  FHeight.free;
  FHeight := value;
end;

Procedure TFhirProdCharacteristic.SetWidth(value : TFhirQuantity);
begin
  FWidth.free;
  FWidth := value;
end;

Procedure TFhirProdCharacteristic.SetDepth(value : TFhirQuantity);
begin
  FDepth.free;
  FDepth := value;
end;

Procedure TFhirProdCharacteristic.SetWeight(value : TFhirQuantity);
begin
  FWeight.free;
  FWeight := value;
end;

Procedure TFhirProdCharacteristic.SetNominalVolume(value : TFhirQuantity);
begin
  FNominalVolume.free;
  FNominalVolume := value;
end;

Procedure TFhirProdCharacteristic.SetExternalDiameter(value : TFhirQuantity);
begin
  FExternalDiameter.free;
  FExternalDiameter := value;
end;

Procedure TFhirProdCharacteristic.SetShape(value : TFhirString);
begin
  FShape.free;
  FShape := value;
end;

Function TFhirProdCharacteristic.GetShapeST : String;
begin
  if FShape = nil then
    result := ''
  else
    result := FShape.value;
end;

Procedure TFhirProdCharacteristic.SetShapeST(value : String);
begin
  if value <> '' then
  begin
    if FShape = nil then
      FShape := TFhirString.create;
    FShape.value := value
  end
  else if FShape <> nil then
    FShape.value := '';
end;

Function TFhirProdCharacteristic.GetColorList : TFhirStringList;
begin
  if FColorList = nil then
    FColorList := TFhirStringList.Create;
  result := FColorList;
end;

Function TFhirProdCharacteristic.GetHasColorList : boolean;
begin
  result := (FColorList <> nil) and (FColorList.count > 0);
end;

Function TFhirProdCharacteristic.GetImprintList : TFhirStringList;
begin
  if FImprintList = nil then
    FImprintList := TFhirStringList.Create;
  result := FImprintList;
end;

Function TFhirProdCharacteristic.GetHasImprintList : boolean;
begin
  result := (FImprintList <> nil) and (FImprintList.count > 0);
end;

Function TFhirProdCharacteristic.GetImageList : TFhirAttachmentList;
begin
  if FImageList = nil then
    FImageList := TFhirAttachmentList.Create;
  result := FImageList;
end;

Function TFhirProdCharacteristic.GetHasImageList : boolean;
begin
  result := (FImageList <> nil) and (FImageList.count > 0);
end;

Procedure TFhirProdCharacteristic.SetScoring(value : TFhirCodeableConcept);
begin
  FScoring.free;
  FScoring := value;
end;

function TFhirProdCharacteristic.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FHeight.sizeInBytes);
  inc(result, FWidth.sizeInBytes);
  inc(result, FDepth.sizeInBytes);
  inc(result, FWeight.sizeInBytes);
  inc(result, FNominalVolume.sizeInBytes);
  inc(result, FExternalDiameter.sizeInBytes);
  inc(result, FShape.sizeInBytes);
  inc(result, FcolorList.sizeInBytes);
  inc(result, FimprintList.sizeInBytes);
  inc(result, FimageList.sizeInBytes);
  inc(result, FScoring.sizeInBytes);
end;

{ TFhirProdCharacteristicListEnumerator }

Constructor TFhirProdCharacteristicListEnumerator.Create(list : TFhirProdCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProdCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProdCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProdCharacteristicListEnumerator.GetCurrent : TFhirProdCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirProdCharacteristicListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProdCharacteristicList }
procedure TFhirProdCharacteristicList.AddItem(value: TFhirProdCharacteristic);
begin
  assert(value.ClassName = 'TFhirProdCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProdCharacteristic');
  add(value);
end;

function TFhirProdCharacteristicList.Append: TFhirProdCharacteristic;
begin
  result := TFhirProdCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProdCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirProdCharacteristicList.GetEnumerator : TFhirProdCharacteristicListEnumerator;
begin
  result := TFhirProdCharacteristicListEnumerator.Create(self.link);
end;

function TFhirProdCharacteristicList.Clone: TFhirProdCharacteristicList;
begin
  result := TFhirProdCharacteristicList(inherited Clone);
end;

function TFhirProdCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProdCharacteristicList.GetItemN(index: Integer): TFhirProdCharacteristic;
begin
  result := TFhirProdCharacteristic(ObjectByIndex[index]);
end;

function TFhirProdCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirProdCharacteristic;
end;
function TFhirProdCharacteristicList.IndexOf(value: TFhirProdCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProdCharacteristicList.Insert(index: Integer): TFhirProdCharacteristic;
begin
  result := TFhirProdCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProdCharacteristicList.InsertItem(index: Integer; value: TFhirProdCharacteristic);
begin
  assert(value is TFhirProdCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirProdCharacteristicList.Item(index: Integer): TFhirProdCharacteristic;
begin
  result := TFhirProdCharacteristic(ObjectByIndex[index]);
end;

function TFhirProdCharacteristicList.Link: TFhirProdCharacteristicList;
begin
  result := TFhirProdCharacteristicList(inherited Link);
end;

procedure TFhirProdCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProdCharacteristicList.SetItemByIndex(index: Integer; value: TFhirProdCharacteristic);
begin
  assert(value is TFhirProdCharacteristic);
  FhirProdCharacteristics[index] := value;
end;

procedure TFhirProdCharacteristicList.SetItemN(index: Integer; value: TFhirProdCharacteristic);
begin
  assert(value is TFhirProdCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirCodeableConcept }

constructor TFhirCodeableConcept.Create;
begin
  inherited;
end;

destructor TFhirCodeableConcept.Destroy;
begin
  FCodingList.Free;
  FText.free;
  inherited;
end;

procedure TFhirCodeableConcept.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCodeableConcept(oSource).FCodingList = nil) then
  begin
    FCodingList.free;
    FCodingList := nil;
  end
  else
  begin
    if FCodingList = nil then
      FCodingList := TFhirCodingList.Create;
    FCodingList.Assign(TFhirCodeableConcept(oSource).FCodingList);
  end;
  textElement := TFhirCodeableConcept(oSource).textElement.Clone;
end;

procedure TFhirCodeableConcept.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'coding') Then
    list.addAll(self, 'coding', FCodingList);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirCodeableConcept.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'coding', 'Coding', true, TFhirCoding, FCodingList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
end;

function TFhirCodeableConcept.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'coding') then
  begin
    CodingList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirCodeableConcept.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'coding') then CodingList.insertItem(index, propValue as TFhirCoding){2a}
  else inherited;
end;

function TFhirCodeableConcept.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'coding') then result := CodingList.new(){2}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCodeableConcept.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'coding') then result := 'Coding'
  else if (propName = 'text') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCodeableConcept.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'coding') then deletePropertyValue('coding', CodingList, value) {2}
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCodeableConcept.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'coding') then replacePropertyValue('coding', CodingList, existing, new) {2}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCodeableConcept.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'coding') then CodingList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCodeableConcept.fhirType : string;
begin
  result := 'CodeableConcept';
end;

function TFhirCodeableConcept.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FcodingList) and isEmptyProp(FText);
end;

function TFhirCodeableConcept.equals(other : TObject) : boolean; 
var
  o : TFhirCodeableConcept;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCodeableConcept)) then
    result := false
  else
  begin
    o := TFhirCodeableConcept(other);
    result := compareDeep(codingList, o.codingList, true) and compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirCodeableConcept.Link : TFhirCodeableConcept;
begin
  result := TFhirCodeableConcept(inherited Link);
end;

function TFhirCodeableConcept.Clone : TFhirCodeableConcept;
begin
  result := TFhirCodeableConcept(inherited Clone);
end;

procedure TFhirCodeableConcept.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('coding');
  fields.add('text');
end;

{ TFhirCodeableConcept }

Function TFhirCodeableConcept.GetCodingList : TFhirCodingList;
begin
  if FCodingList = nil then
    FCodingList := TFhirCodingList.Create;
  result := FCodingList;
end;

Function TFhirCodeableConcept.GetHasCodingList : boolean;
begin
  result := (FCodingList <> nil) and (FCodingList.count > 0);
end;

Procedure TFhirCodeableConcept.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirCodeableConcept.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirCodeableConcept.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

function TFhirCodeableConcept.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FcodingList.sizeInBytes);
  inc(result, FText.sizeInBytes);
end;

{ TFhirCodeableConceptListEnumerator }

Constructor TFhirCodeableConceptListEnumerator.Create(list : TFhirCodeableConceptList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCodeableConceptListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCodeableConceptListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCodeableConceptListEnumerator.GetCurrent : TFhirCodeableConcept;
begin
  Result := FList[FIndex];
end;

function TFhirCodeableConceptListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCodeableConceptList }
procedure TFhirCodeableConceptList.AddItem(value: TFhirCodeableConcept);
begin
  assert(value.ClassName = 'TFhirCodeableConcept', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCodeableConcept');
  add(value);
end;

function TFhirCodeableConceptList.Append: TFhirCodeableConcept;
begin
  result := TFhirCodeableConcept.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeableConceptList.ClearItems;
begin
  Clear;
end;

function TFhirCodeableConceptList.GetEnumerator : TFhirCodeableConceptListEnumerator;
begin
  result := TFhirCodeableConceptListEnumerator.Create(self.link);
end;

function TFhirCodeableConceptList.Clone: TFhirCodeableConceptList;
begin
  result := TFhirCodeableConceptList(inherited Clone);
end;

function TFhirCodeableConceptList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCodeableConceptList.GetItemN(index: Integer): TFhirCodeableConcept;
begin
  result := TFhirCodeableConcept(ObjectByIndex[index]);
end;

function TFhirCodeableConceptList.ItemClass: TFslObjectClass;
begin
  result := TFhirCodeableConcept;
end;
function TFhirCodeableConceptList.IndexOf(value: TFhirCodeableConcept): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCodeableConceptList.Insert(index: Integer): TFhirCodeableConcept;
begin
  result := TFhirCodeableConcept.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeableConceptList.InsertItem(index: Integer; value: TFhirCodeableConcept);
begin
  assert(value is TFhirCodeableConcept);
  Inherited Insert(index, value);
end;

function TFhirCodeableConceptList.Item(index: Integer): TFhirCodeableConcept;
begin
  result := TFhirCodeableConcept(ObjectByIndex[index]);
end;

function TFhirCodeableConceptList.Link: TFhirCodeableConceptList;
begin
  result := TFhirCodeableConceptList(inherited Link);
end;

procedure TFhirCodeableConceptList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCodeableConceptList.SetItemByIndex(index: Integer; value: TFhirCodeableConcept);
begin
  assert(value is TFhirCodeableConcept);
  FhirCodeableConcepts[index] := value;
end;

procedure TFhirCodeableConceptList.SetItemN(index: Integer; value: TFhirCodeableConcept);
begin
  assert(value is TFhirCodeableConcept);
  ObjectByIndex[index] := value;
end;

function TFhirOperationParameterUseEnumListAsInteger(aSet : TFhirOperationParameterUseEnumList) : Integer;
var
  a : TFhirOperationParameterUseEnum;
begin
  result := 0;
  for a := low(TFhirOperationParameterUseEnum) to high(TFhirOperationParameterUseEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirOperationParameterUseEnumList(i : Integer) : TFhirOperationParameterUseEnumList;
var
  aLoop : TFhirOperationParameterUseEnum;
begin
  result := [];
  for aLoop := low(TFhirOperationParameterUseEnum) to high(TFhirOperationParameterUseEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

{ TFhirParameterDefinition }

constructor TFhirParameterDefinition.Create;
begin
  inherited;
end;

destructor TFhirParameterDefinition.Destroy;
begin
  FName.free;
  FUse.free;
  FMin.free;
  FMax.free;
  FDocumentation.free;
  FType_.free;
  FProfile.free;
  inherited;
end;

procedure TFhirParameterDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirParameterDefinition(oSource).nameElement.Clone;
  FUse := TFhirParameterDefinition(oSource).FUse.Link;
  minElement := TFhirParameterDefinition(oSource).minElement.Clone;
  maxElement := TFhirParameterDefinition(oSource).maxElement.Clone;
  documentationElement := TFhirParameterDefinition(oSource).documentationElement.Clone;
  FType_ := TFhirParameterDefinition(oSource).FType_.Link;
  profileElement := TFhirParameterDefinition(oSource).profileElement.Clone;
end;

procedure TFhirParameterDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'min') Then
     list.add(self.link, 'min', FMin.Link);
  if (child_name = 'max') Then
     list.add(self.link, 'max', FMax.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
end;

procedure TFhirParameterDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'code', false, TFhirCode, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'use', 'code', false, TFHIREnum, FUse.Link));{1}
  oList.add(TFHIRProperty.create(self, 'min', 'integer', false, TFhirInteger, FMin.Link));{2}
  oList.add(TFHIRProperty.create(self, 'max', 'string', false, TFhirString, FMax.Link));{2}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'profile', 'canonical', false, TFhirCanonical, FProfile.Link));{2}
end;

function TFhirParameterDefinition.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    UseElement := asEnum(SYSTEMS_TFhirOperationParameterUseEnum, CODES_TFhirOperationParameterUseEnum, propValue);
    result := propValue
  end
  else if (propName = 'min') then
  begin
    MinElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'max') then
  begin
    MaxElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirAllTypesEnum, CODES_TFhirAllTypesEnum, propValue);
    result := propValue
  end
  else if (propName = 'profile') then
  begin
    ProfileElement := asCanonical(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirParameterDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirParameterDefinition.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirCode.create() {5b}
  else if (propName = 'min') then result := TFhirInteger.create() {5b}
  else if (propName = 'max') then result := TFhirString.create() {5b}
  else if (propName = 'documentation') then result := TFhirString.create() {5b}
  else if (propName = 'profile') then result := TFhirCanonical.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirParameterDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'code'
  else if (propName = 'use') then result := 'code'
  else if (propName = 'min') then result := 'integer'
  else if (propName = 'max') then result := 'string'
  else if (propName = 'documentation') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'profile') then result := 'canonical'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirParameterDefinition.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'min') then MinElement := nil
  else if (propName = 'max') then MaxElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'profile') then ProfileElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirParameterDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asCode(new){5b}
  else if (propName = 'use') then UseElement := asEnum(SYSTEMS_TFhirOperationParameterUseEnum, CODES_TFhirOperationParameterUseEnum, new){4}
  else if (propName = 'min') then MinElement := asInteger(new){5b}
  else if (propName = 'max') then MaxElement := asString(new){5b}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirAllTypesEnum, CODES_TFhirAllTypesEnum, new){4}
  else if (propName = 'profile') then ProfileElement := asCanonical(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirParameterDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirParameterDefinition.fhirType : string;
begin
  result := 'ParameterDefinition';
end;

function TFhirParameterDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FUse) and isEmptyProp(FMin) and isEmptyProp(FMax) and isEmptyProp(FDocumentation) and isEmptyProp(FType_) and isEmptyProp(FProfile);
end;

function TFhirParameterDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirParameterDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirParameterDefinition)) then
    result := false
  else
  begin
    o := TFhirParameterDefinition(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(useElement, o.useElement, true) and 
      compareDeep(minElement, o.minElement, true) and compareDeep(maxElement, o.maxElement, true) and 
      compareDeep(documentationElement, o.documentationElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(profileElement, o.profileElement, true);
  end;
end;

function TFhirParameterDefinition.Link : TFhirParameterDefinition;
begin
  result := TFhirParameterDefinition(inherited Link);
end;

function TFhirParameterDefinition.Clone : TFhirParameterDefinition;
begin
  result := TFhirParameterDefinition(inherited Clone);
end;

procedure TFhirParameterDefinition.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('use');
  fields.add('min');
  fields.add('max');
  fields.add('documentation');
  fields.add('type');
  fields.add('profile');
end;

{ TFhirParameterDefinition }

Procedure TFhirParameterDefinition.SetName(value : TFhirCode);
begin
  FName.free;
  FName := value;
end;

Function TFhirParameterDefinition.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirParameterDefinition.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirCode.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirParameterDefinition.SetUse(value : TFhirEnum);
begin
  FUse.free;
  FUse := value;
end;

Function TFhirParameterDefinition.GetUseST : TFhirOperationParameterUseEnum;
begin
  if FUse = nil then
    result := TFhirOperationParameterUseEnum(0)
  else
    result := TFhirOperationParameterUseEnum(StringArrayIndexOfSensitive(CODES_TFhirOperationParameterUseEnum, FUse.value));
end;

Procedure TFhirParameterDefinition.SetUseST(value : TFhirOperationParameterUseEnum);
begin
  if ord(value) = 0 then
    UseElement := nil
  else
    UseElement := TFhirEnum.create(SYSTEMS_TFhirOperationParameterUseEnum[value], CODES_TFhirOperationParameterUseEnum[value]);
end;

Procedure TFhirParameterDefinition.SetMin(value : TFhirInteger);
begin
  FMin.free;
  FMin := value;
end;

Function TFhirParameterDefinition.GetMinST : String;
begin
  if FMin = nil then
    result := ''
  else
    result := FMin.value;
end;

Procedure TFhirParameterDefinition.SetMinST(value : String);
begin
  if value <> '' then
  begin
    if FMin = nil then
      FMin := TFhirInteger.create;
    FMin.value := value
  end
  else if FMin <> nil then
    FMin.value := '';
end;

Procedure TFhirParameterDefinition.SetMax(value : TFhirString);
begin
  FMax.free;
  FMax := value;
end;

Function TFhirParameterDefinition.GetMaxST : String;
begin
  if FMax = nil then
    result := ''
  else
    result := FMax.value;
end;

Procedure TFhirParameterDefinition.SetMaxST(value : String);
begin
  if value <> '' then
  begin
    if FMax = nil then
      FMax := TFhirString.create;
    FMax.value := value
  end
  else if FMax <> nil then
    FMax.value := '';
end;

Procedure TFhirParameterDefinition.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirParameterDefinition.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirParameterDefinition.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Procedure TFhirParameterDefinition.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirParameterDefinition.GetType_ST : TFhirAllTypesEnum;
begin
  if FType_ = nil then
    result := TFhirAllTypesEnum(0)
  else
    result := TFhirAllTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirAllTypesEnum, FType_.value));
end;

Procedure TFhirParameterDefinition.SetType_ST(value : TFhirAllTypesEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirAllTypesEnum[value], CODES_TFhirAllTypesEnum[value]);
end;

Procedure TFhirParameterDefinition.SetProfile(value : TFhirCanonical);
begin
  FProfile.free;
  FProfile := value;
end;

Function TFhirParameterDefinition.GetProfileST : String;
begin
  if FProfile = nil then
    result := ''
  else
    result := FProfile.value;
end;

Procedure TFhirParameterDefinition.SetProfileST(value : String);
begin
  if value <> '' then
  begin
    if FProfile = nil then
      FProfile := TFhirCanonical.create;
    FProfile.value := value
  end
  else if FProfile <> nil then
    FProfile.value := '';
end;

function TFhirParameterDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FUse.sizeInBytes);
  inc(result, FMin.sizeInBytes);
  inc(result, FMax.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FProfile.sizeInBytes);
end;

{ TFhirParameterDefinitionListEnumerator }

Constructor TFhirParameterDefinitionListEnumerator.Create(list : TFhirParameterDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirParameterDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirParameterDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirParameterDefinitionListEnumerator.GetCurrent : TFhirParameterDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirParameterDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirParameterDefinitionList }
procedure TFhirParameterDefinitionList.AddItem(value: TFhirParameterDefinition);
begin
  assert(value.ClassName = 'TFhirParameterDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirParameterDefinition');
  add(value);
end;

function TFhirParameterDefinitionList.Append: TFhirParameterDefinition;
begin
  result := TFhirParameterDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParameterDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirParameterDefinitionList.GetEnumerator : TFhirParameterDefinitionListEnumerator;
begin
  result := TFhirParameterDefinitionListEnumerator.Create(self.link);
end;

function TFhirParameterDefinitionList.Clone: TFhirParameterDefinitionList;
begin
  result := TFhirParameterDefinitionList(inherited Clone);
end;

function TFhirParameterDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirParameterDefinitionList.GetItemN(index: Integer): TFhirParameterDefinition;
begin
  result := TFhirParameterDefinition(ObjectByIndex[index]);
end;

function TFhirParameterDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirParameterDefinition;
end;
function TFhirParameterDefinitionList.IndexOf(value: TFhirParameterDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirParameterDefinitionList.Insert(index: Integer): TFhirParameterDefinition;
begin
  result := TFhirParameterDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParameterDefinitionList.InsertItem(index: Integer; value: TFhirParameterDefinition);
begin
  assert(value is TFhirParameterDefinition);
  Inherited Insert(index, value);
end;

function TFhirParameterDefinitionList.Item(index: Integer): TFhirParameterDefinition;
begin
  result := TFhirParameterDefinition(ObjectByIndex[index]);
end;

function TFhirParameterDefinitionList.Link: TFhirParameterDefinitionList;
begin
  result := TFhirParameterDefinitionList(inherited Link);
end;

procedure TFhirParameterDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirParameterDefinitionList.SetItemByIndex(index: Integer; value: TFhirParameterDefinition);
begin
  assert(value is TFhirParameterDefinition);
  FhirParameterDefinitions[index] := value;
end;

procedure TFhirParameterDefinitionList.SetItemN(index: Integer; value: TFhirParameterDefinition);
begin
  assert(value is TFhirParameterDefinition);
  ObjectByIndex[index] := value;
end;

function TFhirContactPointSystemEnumListAsInteger(aSet : TFhirContactPointSystemEnumList) : Integer;
var
  a : TFhirContactPointSystemEnum;
begin
  result := 0;
  for a := low(TFhirContactPointSystemEnum) to high(TFhirContactPointSystemEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirContactPointSystemEnumList(i : Integer) : TFhirContactPointSystemEnumList;
var
  aLoop : TFhirContactPointSystemEnum;
begin
  result := [];
  for aLoop := low(TFhirContactPointSystemEnum) to high(TFhirContactPointSystemEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirContactPointUseEnumListAsInteger(aSet : TFhirContactPointUseEnumList) : Integer;
var
  a : TFhirContactPointUseEnum;
begin
  result := 0;
  for a := low(TFhirContactPointUseEnum) to high(TFhirContactPointUseEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirContactPointUseEnumList(i : Integer) : TFhirContactPointUseEnumList;
var
  aLoop : TFhirContactPointUseEnum;
begin
  result := [];
  for aLoop := low(TFhirContactPointUseEnum) to high(TFhirContactPointUseEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

{ TFhirContactPoint }

constructor TFhirContactPoint.Create;
begin
  inherited;
end;

destructor TFhirContactPoint.Destroy;
begin
  FSystem.free;
  FValue.free;
  FUse.free;
  FRank.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirContactPoint.Assign(oSource : TFslObject);
begin
  inherited;
  FSystem := TFhirContactPoint(oSource).FSystem.Link;
  valueElement := TFhirContactPoint(oSource).valueElement.Clone;
  FUse := TFhirContactPoint(oSource).FUse.Link;
  rankElement := TFhirContactPoint(oSource).rankElement.Clone;
  period := TFhirContactPoint(oSource).period.Clone;
end;

procedure TFhirContactPoint.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(self.link, 'system', FSystem.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'rank') Then
     list.add(self.link, 'rank', FRank.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirContactPoint.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'code', false, TFHIREnum, FSystem.Link));{1}
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'use', 'code', false, TFHIREnum, FUse.Link));{1}
  oList.add(TFHIRProperty.create(self, 'rank', 'positiveInt', false, TFhirPositiveInt, FRank.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
end;

function TFhirContactPoint.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'system') then
  begin
    SystemElement := asEnum(SYSTEMS_TFhirContactPointSystemEnum, CODES_TFhirContactPointSystemEnum, propValue);
    result := propValue
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    UseElement := asEnum(SYSTEMS_TFhirContactPointUseEnum, CODES_TFhirContactPointUseEnum, propValue);
    result := propValue
  end
  else if (propName = 'rank') then
  begin
    RankElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirContactPoint.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContactPoint.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'value') then result := TFhirString.create() {5b}
  else if (propName = 'rank') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirContactPoint.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'system') then result := 'code'
  else if (propName = 'value') then result := 'string'
  else if (propName = 'use') then result := 'code'
  else if (propName = 'rank') then result := 'positiveInt'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContactPoint.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'rank') then RankElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContactPoint.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := asEnum(SYSTEMS_TFhirContactPointSystemEnum, CODES_TFhirContactPointSystemEnum, new){4}
  else if (propName = 'value') then ValueElement := asString(new){5b}
  else if (propName = 'use') then UseElement := asEnum(SYSTEMS_TFhirContactPointUseEnum, CODES_TFhirContactPointUseEnum, new){4}
  else if (propName = 'rank') then RankElement := asPositiveInt(new){5b}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContactPoint.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContactPoint.fhirType : string;
begin
  result := 'ContactPoint';
end;

function TFhirContactPoint.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSystem) and isEmptyProp(FValue) and isEmptyProp(FUse) and isEmptyProp(FRank) and isEmptyProp(FPeriod);
end;

function TFhirContactPoint.equals(other : TObject) : boolean; 
var
  o : TFhirContactPoint;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContactPoint)) then
    result := false
  else
  begin
    o := TFhirContactPoint(other);
    result := compareDeep(systemElement, o.systemElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(useElement, o.useElement, true) and compareDeep(rankElement, o.rankElement, true) and 
      compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirContactPoint.Link : TFhirContactPoint;
begin
  result := TFhirContactPoint(inherited Link);
end;

function TFhirContactPoint.Clone : TFhirContactPoint;
begin
  result := TFhirContactPoint(inherited Clone);
end;

procedure TFhirContactPoint.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('system');
  fields.add('value');
  fields.add('use');
  fields.add('rank');
  fields.add('period');
end;

{ TFhirContactPoint }

Procedure TFhirContactPoint.SetSystem(value : TFhirEnum);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirContactPoint.GetSystemST : TFhirContactPointSystemEnum;
begin
  if FSystem = nil then
    result := TFhirContactPointSystemEnum(0)
  else
    result := TFhirContactPointSystemEnum(StringArrayIndexOfSensitive(CODES_TFhirContactPointSystemEnum, FSystem.value));
end;

Procedure TFhirContactPoint.SetSystemST(value : TFhirContactPointSystemEnum);
begin
  if ord(value) = 0 then
    SystemElement := nil
  else
    SystemElement := TFhirEnum.create(SYSTEMS_TFhirContactPointSystemEnum[value], CODES_TFhirContactPointSystemEnum[value]);
end;

Procedure TFhirContactPoint.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirContactPoint.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirContactPoint.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

Procedure TFhirContactPoint.SetUse(value : TFhirEnum);
begin
  FUse.free;
  FUse := value;
end;

Function TFhirContactPoint.GetUseST : TFhirContactPointUseEnum;
begin
  if FUse = nil then
    result := TFhirContactPointUseEnum(0)
  else
    result := TFhirContactPointUseEnum(StringArrayIndexOfSensitive(CODES_TFhirContactPointUseEnum, FUse.value));
end;

Procedure TFhirContactPoint.SetUseST(value : TFhirContactPointUseEnum);
begin
  if ord(value) = 0 then
    UseElement := nil
  else
    UseElement := TFhirEnum.create(SYSTEMS_TFhirContactPointUseEnum[value], CODES_TFhirContactPointUseEnum[value]);
end;

Procedure TFhirContactPoint.SetRank(value : TFhirPositiveInt);
begin
  FRank.free;
  FRank := value;
end;

Function TFhirContactPoint.GetRankST : String;
begin
  if FRank = nil then
    result := ''
  else
    result := FRank.value;
end;

Procedure TFhirContactPoint.SetRankST(value : String);
begin
  if value <> '' then
  begin
    if FRank = nil then
      FRank := TFhirPositiveInt.create;
    FRank.value := value
  end
  else if FRank <> nil then
    FRank.value := '';
end;

Procedure TFhirContactPoint.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirContactPoint.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSystem.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FUse.sizeInBytes);
  inc(result, FRank.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirContactPointListEnumerator }

Constructor TFhirContactPointListEnumerator.Create(list : TFhirContactPointList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContactPointListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContactPointListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContactPointListEnumerator.GetCurrent : TFhirContactPoint;
begin
  Result := FList[FIndex];
end;

function TFhirContactPointListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirContactPointList }
procedure TFhirContactPointList.AddItem(value: TFhirContactPoint);
begin
  assert(value.ClassName = 'TFhirContactPoint', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContactPoint');
  add(value);
end;

function TFhirContactPointList.Append: TFhirContactPoint;
begin
  result := TFhirContactPoint.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContactPointList.ClearItems;
begin
  Clear;
end;

function TFhirContactPointList.GetEnumerator : TFhirContactPointListEnumerator;
begin
  result := TFhirContactPointListEnumerator.Create(self.link);
end;

function TFhirContactPointList.Clone: TFhirContactPointList;
begin
  result := TFhirContactPointList(inherited Clone);
end;

function TFhirContactPointList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContactPointList.GetItemN(index: Integer): TFhirContactPoint;
begin
  result := TFhirContactPoint(ObjectByIndex[index]);
end;

function TFhirContactPointList.ItemClass: TFslObjectClass;
begin
  result := TFhirContactPoint;
end;
function TFhirContactPointList.IndexOf(value: TFhirContactPoint): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContactPointList.Insert(index: Integer): TFhirContactPoint;
begin
  result := TFhirContactPoint.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContactPointList.InsertItem(index: Integer; value: TFhirContactPoint);
begin
  assert(value is TFhirContactPoint);
  Inherited Insert(index, value);
end;

function TFhirContactPointList.Item(index: Integer): TFhirContactPoint;
begin
  result := TFhirContactPoint(ObjectByIndex[index]);
end;

function TFhirContactPointList.Link: TFhirContactPointList;
begin
  result := TFhirContactPointList(inherited Link);
end;

procedure TFhirContactPointList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContactPointList.SetItemByIndex(index: Integer; value: TFhirContactPoint);
begin
  assert(value is TFhirContactPoint);
  FhirContactPoints[index] := value;
end;

procedure TFhirContactPointList.SetItemN(index: Integer; value: TFhirContactPoint);
begin
  assert(value is TFhirContactPoint);
  ObjectByIndex[index] := value;
end;

function TFhirNameUseEnumListAsInteger(aSet : TFhirNameUseEnumList) : Integer;
var
  a : TFhirNameUseEnum;
begin
  result := 0;
  for a := low(TFhirNameUseEnum) to high(TFhirNameUseEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirNameUseEnumList(i : Integer) : TFhirNameUseEnumList;
var
  aLoop : TFhirNameUseEnum;
begin
  result := [];
  for aLoop := low(TFhirNameUseEnum) to high(TFhirNameUseEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

{ TFhirHumanName }

constructor TFhirHumanName.Create;
begin
  inherited;
end;

destructor TFhirHumanName.Destroy;
begin
  FUse.free;
  FText.free;
  FFamily.free;
  FGivenList.Free;
  FPrefixList.Free;
  FSuffixList.Free;
  FPeriod.free;
  inherited;
end;

procedure TFhirHumanName.Assign(oSource : TFslObject);
begin
  inherited;
  FUse := TFhirHumanName(oSource).FUse.Link;
  textElement := TFhirHumanName(oSource).textElement.Clone;
  familyElement := TFhirHumanName(oSource).familyElement.Clone;
  if (TFhirHumanName(oSource).FGivenList = nil) then
  begin
    FGivenList.free;
    FGivenList := nil;
  end
  else
  begin
    if FGivenList = nil then
      FGivenList := TFhirStringList.Create;
    FGivenList.Assign(TFhirHumanName(oSource).FGivenList);
  end;
  if (TFhirHumanName(oSource).FPrefixList = nil) then
  begin
    FPrefixList.free;
    FPrefixList := nil;
  end
  else
  begin
    if FPrefixList = nil then
      FPrefixList := TFhirStringList.Create;
    FPrefixList.Assign(TFhirHumanName(oSource).FPrefixList);
  end;
  if (TFhirHumanName(oSource).FSuffixList = nil) then
  begin
    FSuffixList.free;
    FSuffixList := nil;
  end
  else
  begin
    if FSuffixList = nil then
      FSuffixList := TFhirStringList.Create;
    FSuffixList.Assign(TFhirHumanName(oSource).FSuffixList);
  end;
  period := TFhirHumanName(oSource).period.Clone;
end;

procedure TFhirHumanName.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'family') Then
     list.add(self.link, 'family', FFamily.Link);
  if (child_name = 'given') Then
    list.addAll(self, 'given', FGivenList);
  if (child_name = 'prefix') Then
    list.addAll(self, 'prefix', FPrefixList);
  if (child_name = 'suffix') Then
    list.addAll(self, 'suffix', FSuffixList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirHumanName.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'use', 'code', false, TFHIREnum, FUse.Link));{1}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'family', 'string', false, TFhirString, FFamily.Link));{2}
  oList.add(TFHIRProperty.create(self, 'given', 'string', true, TFhirString, FGivenList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'prefix', 'string', true, TFhirString, FPrefixList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'suffix', 'string', true, TFhirString, FSuffixList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
end;

function TFhirHumanName.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'use') then
  begin
    UseElement := asEnum(SYSTEMS_TFhirNameUseEnum, CODES_TFhirNameUseEnum, propValue);
    result := propValue
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'family') then
  begin
    FamilyElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'given') then
  begin
    GivenList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'prefix') then
  begin
    PrefixList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'suffix') then
  begin
    SuffixList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirHumanName.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'given') then GivenList.insertItem(index, asString(propValue)){2}
  else if (propName = 'prefix') then PrefixList.insertItem(index, asString(propValue)){2}
  else if (propName = 'suffix') then SuffixList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirHumanName.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'family') then result := TFhirString.create() {5b}
  else if (propName = 'given') then result := GivenList.new(){2}
  else if (propName = 'prefix') then result := PrefixList.new(){2}
  else if (propName = 'suffix') then result := SuffixList.new(){2}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirHumanName.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'use') then result := 'code'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'family') then result := 'string'
  else if (propName = 'given') then result := 'string'
  else if (propName = 'prefix') then result := 'string'
  else if (propName = 'suffix') then result := 'string'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirHumanName.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'use') then UseElement := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'family') then FamilyElement := nil
  else if (propName = 'given') then deletePropertyValue('given', GivenList, value) {2}
  else if (propName = 'prefix') then deletePropertyValue('prefix', PrefixList, value) {2}
  else if (propName = 'suffix') then deletePropertyValue('suffix', SuffixList, value) {2}
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirHumanName.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'use') then UseElement := asEnum(SYSTEMS_TFhirNameUseEnum, CODES_TFhirNameUseEnum, new){4}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'family') then FamilyElement := asString(new){5b}
  else if (propName = 'given') then replacePropertyValue('given', GivenList, existing, new) {2}
  else if (propName = 'prefix') then replacePropertyValue('prefix', PrefixList, existing, new) {2}
  else if (propName = 'suffix') then replacePropertyValue('suffix', SuffixList, existing, new) {2}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirHumanName.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'given') then GivenList.move(source, destination){2}
  else if (propName = 'prefix') then PrefixList.move(source, destination){2}
  else if (propName = 'suffix') then SuffixList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirHumanName.fhirType : string;
begin
  result := 'HumanName';
end;

function TFhirHumanName.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUse) and isEmptyProp(FText) and isEmptyProp(FFamily) and isEmptyProp(FgivenList) and isEmptyProp(FprefixList) and isEmptyProp(FsuffixList) and isEmptyProp(FPeriod);
end;

function TFhirHumanName.equals(other : TObject) : boolean; 
var
  o : TFhirHumanName;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirHumanName)) then
    result := false
  else
  begin
    o := TFhirHumanName(other);
    result := compareDeep(useElement, o.useElement, true) and compareDeep(textElement, o.textElement, true) and 
      compareDeep(familyElement, o.familyElement, true) and compareDeep(givenList, o.givenList, true) and 
      compareDeep(prefixList, o.prefixList, true) and compareDeep(suffixList, o.suffixList, true) and 
      compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirHumanName.Link : TFhirHumanName;
begin
  result := TFhirHumanName(inherited Link);
end;

function TFhirHumanName.Clone : TFhirHumanName;
begin
  result := TFhirHumanName(inherited Clone);
end;

procedure TFhirHumanName.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('use');
  fields.add('text');
  fields.add('family');
  fields.add('given');
  fields.add('prefix');
  fields.add('suffix');
  fields.add('period');
end;

{ TFhirHumanName }

Procedure TFhirHumanName.SetUse(value : TFhirEnum);
begin
  FUse.free;
  FUse := value;
end;

Function TFhirHumanName.GetUseST : TFhirNameUseEnum;
begin
  if FUse = nil then
    result := TFhirNameUseEnum(0)
  else
    result := TFhirNameUseEnum(StringArrayIndexOfSensitive(CODES_TFhirNameUseEnum, FUse.value));
end;

Procedure TFhirHumanName.SetUseST(value : TFhirNameUseEnum);
begin
  if ord(value) = 0 then
    UseElement := nil
  else
    UseElement := TFhirEnum.create(SYSTEMS_TFhirNameUseEnum[value], CODES_TFhirNameUseEnum[value]);
end;

Procedure TFhirHumanName.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirHumanName.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirHumanName.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirHumanName.SetFamily(value : TFhirString);
begin
  FFamily.free;
  FFamily := value;
end;

Function TFhirHumanName.GetFamilyST : String;
begin
  if FFamily = nil then
    result := ''
  else
    result := FFamily.value;
end;

Procedure TFhirHumanName.SetFamilyST(value : String);
begin
  if value <> '' then
  begin
    if FFamily = nil then
      FFamily := TFhirString.create;
    FFamily.value := value
  end
  else if FFamily <> nil then
    FFamily.value := '';
end;

Function TFhirHumanName.GetGivenList : TFhirStringList;
begin
  if FGivenList = nil then
    FGivenList := TFhirStringList.Create;
  result := FGivenList;
end;

Function TFhirHumanName.GetHasGivenList : boolean;
begin
  result := (FGivenList <> nil) and (FGivenList.count > 0);
end;

Function TFhirHumanName.GetPrefixList : TFhirStringList;
begin
  if FPrefixList = nil then
    FPrefixList := TFhirStringList.Create;
  result := FPrefixList;
end;

Function TFhirHumanName.GetHasPrefixList : boolean;
begin
  result := (FPrefixList <> nil) and (FPrefixList.count > 0);
end;

Function TFhirHumanName.GetSuffixList : TFhirStringList;
begin
  if FSuffixList = nil then
    FSuffixList := TFhirStringList.Create;
  result := FSuffixList;
end;

Function TFhirHumanName.GetHasSuffixList : boolean;
begin
  result := (FSuffixList <> nil) and (FSuffixList.count > 0);
end;

Procedure TFhirHumanName.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirHumanName.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUse.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FFamily.sizeInBytes);
  inc(result, FgivenList.sizeInBytes);
  inc(result, FprefixList.sizeInBytes);
  inc(result, FsuffixList.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirHumanNameListEnumerator }

Constructor TFhirHumanNameListEnumerator.Create(list : TFhirHumanNameList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirHumanNameListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirHumanNameListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirHumanNameListEnumerator.GetCurrent : TFhirHumanName;
begin
  Result := FList[FIndex];
end;

function TFhirHumanNameListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirHumanNameList }
procedure TFhirHumanNameList.AddItem(value: TFhirHumanName);
begin
  assert(value.ClassName = 'TFhirHumanName', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirHumanName');
  add(value);
end;

function TFhirHumanNameList.Append: TFhirHumanName;
begin
  result := TFhirHumanName.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHumanNameList.ClearItems;
begin
  Clear;
end;

function TFhirHumanNameList.GetEnumerator : TFhirHumanNameListEnumerator;
begin
  result := TFhirHumanNameListEnumerator.Create(self.link);
end;

function TFhirHumanNameList.Clone: TFhirHumanNameList;
begin
  result := TFhirHumanNameList(inherited Clone);
end;

function TFhirHumanNameList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirHumanNameList.GetItemN(index: Integer): TFhirHumanName;
begin
  result := TFhirHumanName(ObjectByIndex[index]);
end;

function TFhirHumanNameList.ItemClass: TFslObjectClass;
begin
  result := TFhirHumanName;
end;
function TFhirHumanNameList.IndexOf(value: TFhirHumanName): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirHumanNameList.Insert(index: Integer): TFhirHumanName;
begin
  result := TFhirHumanName.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHumanNameList.InsertItem(index: Integer; value: TFhirHumanName);
begin
  assert(value is TFhirHumanName);
  Inherited Insert(index, value);
end;

function TFhirHumanNameList.Item(index: Integer): TFhirHumanName;
begin
  result := TFhirHumanName(ObjectByIndex[index]);
end;

function TFhirHumanNameList.Link: TFhirHumanNameList;
begin
  result := TFhirHumanNameList(inherited Link);
end;

procedure TFhirHumanNameList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirHumanNameList.SetItemByIndex(index: Integer; value: TFhirHumanName);
begin
  assert(value is TFhirHumanName);
  FhirHumanNames[index] := value;
end;

procedure TFhirHumanNameList.SetItemN(index: Integer; value: TFhirHumanName);
begin
  assert(value is TFhirHumanName);
  ObjectByIndex[index] := value;
end;

{ TFhirMeta }

constructor TFhirMeta.Create;
begin
  inherited;
end;

destructor TFhirMeta.Destroy;
begin
  FVersionId.free;
  FLastUpdated.free;
  FSource.free;
  FProfileList.Free;
  FSecurityList.Free;
  FTagList.Free;
  inherited;
end;

procedure TFhirMeta.Assign(oSource : TFslObject);
begin
  inherited;
  versionIdElement := TFhirMeta(oSource).versionIdElement.Clone;
  lastUpdatedElement := TFhirMeta(oSource).lastUpdatedElement.Clone;
  sourceElement := TFhirMeta(oSource).sourceElement.Clone;
  if (TFhirMeta(oSource).FProfileList = nil) then
  begin
    FProfileList.free;
    FProfileList := nil;
  end
  else
  begin
    if FProfileList = nil then
      FProfileList := TFhirCanonicalList.Create;
    FProfileList.Assign(TFhirMeta(oSource).FProfileList);
  end;
  if (TFhirMeta(oSource).FSecurityList = nil) then
  begin
    FSecurityList.free;
    FSecurityList := nil;
  end
  else
  begin
    if FSecurityList = nil then
      FSecurityList := TFhirCodingList.Create;
    FSecurityList.Assign(TFhirMeta(oSource).FSecurityList);
  end;
  if (TFhirMeta(oSource).FTagList = nil) then
  begin
    FTagList.free;
    FTagList := nil;
  end
  else
  begin
    if FTagList = nil then
      FTagList := TFhirCodingList.Create;
    FTagList.Assign(TFhirMeta(oSource).FTagList);
  end;
end;

procedure TFhirMeta.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'versionId') Then
     list.add(self.link, 'versionId', FVersionId.Link);
  if (child_name = 'lastUpdated') Then
     list.add(self.link, 'lastUpdated', FLastUpdated.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'profile') Then
    list.addAll(self, 'profile', FProfileList);
  if (child_name = 'security') Then
    list.addAll(self, 'security', FSecurityList);
  if (child_name = 'tag') Then
    list.addAll(self, 'tag', FTagList);
end;

procedure TFhirMeta.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'versionId', 'id', false, TFhirId, FVersionId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lastUpdated', 'instant', false, TFhirInstant, FLastUpdated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'uri', false, TFhirUri, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'profile', 'canonical', true, TFhirCanonical, FProfileList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'security', 'Coding', true, TFhirCoding, FSecurityList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'tag', 'Coding', true, TFhirCoding, FTagList.Link)){3};
end;

function TFhirMeta.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'versionId') then
  begin
    VersionIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lastUpdated') then
  begin
    LastUpdatedElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'profile') then
  begin
    ProfileList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'security') then
  begin
    SecurityList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'tag') then
  begin
    TagList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMeta.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'profile') then ProfileList.insertItem(index, asCanonical(propValue)){2}
  else if (propName = 'security') then SecurityList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'tag') then TagList.insertItem(index, propValue as TFhirCoding){2a}
  else inherited;
end;

function TFhirMeta.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'versionId') then result := TFhirId.create() {5b}
  else if (propName = 'lastUpdated') then result := TFhirInstant.create() {5b}
  else if (propName = 'source') then result := TFhirUri.create() {5b}
  else if (propName = 'profile') then result := ProfileList.new(){2}
  else if (propName = 'security') then result := SecurityList.new(){2}
  else if (propName = 'tag') then result := TagList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeta.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'versionId') then result := 'id'
  else if (propName = 'lastUpdated') then result := 'instant'
  else if (propName = 'source') then result := 'uri'
  else if (propName = 'profile') then result := 'canonical'
  else if (propName = 'security') then result := 'Coding'
  else if (propName = 'tag') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeta.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'versionId') then VersionIdElement := nil
  else if (propName = 'lastUpdated') then LastUpdatedElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'profile') then deletePropertyValue('profile', ProfileList, value) {2}
  else if (propName = 'security') then deletePropertyValue('security', SecurityList, value) {2}
  else if (propName = 'tag') then deletePropertyValue('tag', TagList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeta.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'versionId') then VersionIdElement := asId(new){5b}
  else if (propName = 'lastUpdated') then LastUpdatedElement := asInstant(new){5b}
  else if (propName = 'source') then SourceElement := asUri(new){5b}
  else if (propName = 'profile') then replacePropertyValue('profile', ProfileList, existing, new) {2}
  else if (propName = 'security') then replacePropertyValue('security', SecurityList, existing, new) {2}
  else if (propName = 'tag') then replacePropertyValue('tag', TagList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeta.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'profile') then ProfileList.move(source, destination){2}
  else if (propName = 'security') then SecurityList.move(source, destination){2a}
  else if (propName = 'tag') then TagList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeta.fhirType : string;
begin
  result := 'Meta';
end;

function TFhirMeta.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FVersionId) and isEmptyProp(FLastUpdated) and isEmptyProp(FSource) and isEmptyProp(FprofileList) and isEmptyProp(FsecurityList) and isEmptyProp(FtagList);
end;

function TFhirMeta.equals(other : TObject) : boolean; 
var
  o : TFhirMeta;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeta)) then
    result := false
  else
  begin
    o := TFhirMeta(other);
    result := compareDeep(versionIdElement, o.versionIdElement, true) and compareDeep(lastUpdatedElement, o.lastUpdatedElement, true) and 
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(profileList, o.profileList, true) and 
      compareDeep(securityList, o.securityList, true) and compareDeep(tagList, o.tagList, true);
  end;
end;

function TFhirMeta.Link : TFhirMeta;
begin
  result := TFhirMeta(inherited Link);
end;

function TFhirMeta.Clone : TFhirMeta;
begin
  result := TFhirMeta(inherited Clone);
end;

procedure TFhirMeta.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('versionId');
  fields.add('lastUpdated');
  fields.add('source');
  fields.add('profile');
  fields.add('security');
  fields.add('tag');
end;

{ TFhirMeta }

Procedure TFhirMeta.SetVersionId(value : TFhirId);
begin
  FVersionId.free;
  FVersionId := value;
end;

Function TFhirMeta.GetVersionIdST : String;
begin
  if FVersionId = nil then
    result := ''
  else
    result := FVersionId.value;
end;

Procedure TFhirMeta.SetVersionIdST(value : String);
begin
  if value <> '' then
  begin
    if FVersionId = nil then
      FVersionId := TFhirId.create;
    FVersionId.value := value
  end
  else if FVersionId <> nil then
    FVersionId.value := '';
end;

Procedure TFhirMeta.SetLastUpdated(value : TFhirInstant);
begin
  FLastUpdated.free;
  FLastUpdated := value;
end;

Function TFhirMeta.GetLastUpdatedST : TFslDateTime;
begin
  if FLastUpdated = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastUpdated.value;
end;

Procedure TFhirMeta.SetLastUpdatedST(value : TFslDateTime);
begin
  if FLastUpdated = nil then
    FLastUpdated := TFhirInstant.create;
  FLastUpdated.value := value
end;

Procedure TFhirMeta.SetSource(value : TFhirUri);
begin
  FSource.free;
  FSource := value;
end;

Function TFhirMeta.GetSourceST : String;
begin
  if FSource = nil then
    result := ''
  else
    result := FSource.value;
end;

Procedure TFhirMeta.SetSourceST(value : String);
begin
  if value <> '' then
  begin
    if FSource = nil then
      FSource := TFhirUri.create;
    FSource.value := value
  end
  else if FSource <> nil then
    FSource.value := '';
end;

Function TFhirMeta.GetProfileList : TFhirCanonicalList;
begin
  if FProfileList = nil then
    FProfileList := TFhirCanonicalList.Create;
  result := FProfileList;
end;

Function TFhirMeta.GetHasProfileList : boolean;
begin
  result := (FProfileList <> nil) and (FProfileList.count > 0);
end;

Function TFhirMeta.GetSecurityList : TFhirCodingList;
begin
  if FSecurityList = nil then
    FSecurityList := TFhirCodingList.Create;
  result := FSecurityList;
end;

Function TFhirMeta.GetHasSecurityList : boolean;
begin
  result := (FSecurityList <> nil) and (FSecurityList.count > 0);
end;

Function TFhirMeta.GetTagList : TFhirCodingList;
begin
  if FTagList = nil then
    FTagList := TFhirCodingList.Create;
  result := FTagList;
end;

Function TFhirMeta.GetHasTagList : boolean;
begin
  result := (FTagList <> nil) and (FTagList.count > 0);
end;

function TFhirMeta.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FVersionId.sizeInBytes);
  inc(result, FLastUpdated.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FprofileList.sizeInBytes);
  inc(result, FsecurityList.sizeInBytes);
  inc(result, FtagList.sizeInBytes);
end;

{ TFhirMetaListEnumerator }

Constructor TFhirMetaListEnumerator.Create(list : TFhirMetaList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMetaListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMetaListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMetaListEnumerator.GetCurrent : TFhirMeta;
begin
  Result := FList[FIndex];
end;

function TFhirMetaListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMetaList }
procedure TFhirMetaList.AddItem(value: TFhirMeta);
begin
  assert(value.ClassName = 'TFhirMeta', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeta');
  add(value);
end;

function TFhirMetaList.Append: TFhirMeta;
begin
  result := TFhirMeta.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMetaList.ClearItems;
begin
  Clear;
end;

function TFhirMetaList.GetEnumerator : TFhirMetaListEnumerator;
begin
  result := TFhirMetaListEnumerator.Create(self.link);
end;

function TFhirMetaList.Clone: TFhirMetaList;
begin
  result := TFhirMetaList(inherited Clone);
end;

function TFhirMetaList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMetaList.GetItemN(index: Integer): TFhirMeta;
begin
  result := TFhirMeta(ObjectByIndex[index]);
end;

function TFhirMetaList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeta;
end;
function TFhirMetaList.IndexOf(value: TFhirMeta): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMetaList.Insert(index: Integer): TFhirMeta;
begin
  result := TFhirMeta.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMetaList.InsertItem(index: Integer; value: TFhirMeta);
begin
  assert(value is TFhirMeta);
  Inherited Insert(index, value);
end;

function TFhirMetaList.Item(index: Integer): TFhirMeta;
begin
  result := TFhirMeta(ObjectByIndex[index]);
end;

function TFhirMetaList.Link: TFhirMetaList;
begin
  result := TFhirMetaList(inherited Link);
end;

procedure TFhirMetaList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMetaList.SetItemByIndex(index: Integer; value: TFhirMeta);
begin
  assert(value is TFhirMeta);
  FhirMeta[index] := value;
end;

procedure TFhirMetaList.SetItemN(index: Integer; value: TFhirMeta);
begin
  assert(value is TFhirMeta);
  ObjectByIndex[index] := value;
end;

function TFhirAddressUseEnumListAsInteger(aSet : TFhirAddressUseEnumList) : Integer;
var
  a : TFhirAddressUseEnum;
begin
  result := 0;
  for a := low(TFhirAddressUseEnum) to high(TFhirAddressUseEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirAddressUseEnumList(i : Integer) : TFhirAddressUseEnumList;
var
  aLoop : TFhirAddressUseEnum;
begin
  result := [];
  for aLoop := low(TFhirAddressUseEnum) to high(TFhirAddressUseEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirAddressTypeEnumListAsInteger(aSet : TFhirAddressTypeEnumList) : Integer;
var
  a : TFhirAddressTypeEnum;
begin
  result := 0;
  for a := low(TFhirAddressTypeEnum) to high(TFhirAddressTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirAddressTypeEnumList(i : Integer) : TFhirAddressTypeEnumList;
var
  aLoop : TFhirAddressTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirAddressTypeEnum) to high(TFhirAddressTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

{ TFhirAddress }

constructor TFhirAddress.Create;
begin
  inherited;
end;

destructor TFhirAddress.Destroy;
begin
  FUse.free;
  FType_.free;
  FText.free;
  FLineList.Free;
  FCity.free;
  FDistrict.free;
  FState.free;
  FPostalCode.free;
  FCountry.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirAddress.Assign(oSource : TFslObject);
begin
  inherited;
  FUse := TFhirAddress(oSource).FUse.Link;
  FType_ := TFhirAddress(oSource).FType_.Link;
  textElement := TFhirAddress(oSource).textElement.Clone;
  if (TFhirAddress(oSource).FLineList = nil) then
  begin
    FLineList.free;
    FLineList := nil;
  end
  else
  begin
    if FLineList = nil then
      FLineList := TFhirStringList.Create;
    FLineList.Assign(TFhirAddress(oSource).FLineList);
  end;
  cityElement := TFhirAddress(oSource).cityElement.Clone;
  districtElement := TFhirAddress(oSource).districtElement.Clone;
  stateElement := TFhirAddress(oSource).stateElement.Clone;
  postalCodeElement := TFhirAddress(oSource).postalCodeElement.Clone;
  countryElement := TFhirAddress(oSource).countryElement.Clone;
  period := TFhirAddress(oSource).period.Clone;
end;

procedure TFhirAddress.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'line') Then
    list.addAll(self, 'line', FLineList);
  if (child_name = 'city') Then
     list.add(self.link, 'city', FCity.Link);
  if (child_name = 'district') Then
     list.add(self.link, 'district', FDistrict.Link);
  if (child_name = 'state') Then
     list.add(self.link, 'state', FState.Link);
  if (child_name = 'postalCode') Then
     list.add(self.link, 'postalCode', FPostalCode.Link);
  if (child_name = 'country') Then
     list.add(self.link, 'country', FCountry.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirAddress.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'use', 'code', false, TFHIREnum, FUse.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'line', 'string', true, TFhirString, FLineList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'city', 'string', false, TFhirString, FCity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'district', 'string', false, TFhirString, FDistrict.Link));{2}
  oList.add(TFHIRProperty.create(self, 'state', 'string', false, TFhirString, FState.Link));{2}
  oList.add(TFHIRProperty.create(self, 'postalCode', 'string', false, TFhirString, FPostalCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'country', 'string', false, TFhirString, FCountry.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
end;

function TFhirAddress.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'use') then
  begin
    UseElement := asEnum(SYSTEMS_TFhirAddressUseEnum, CODES_TFhirAddressUseEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirAddressTypeEnum, CODES_TFhirAddressTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'line') then
  begin
    LineList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'city') then
  begin
    CityElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'district') then
  begin
    DistrictElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'state') then
  begin
    StateElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'postalCode') then
  begin
    PostalCodeElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'country') then
  begin
    CountryElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirAddress.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'line') then LineList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirAddress.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'line') then result := LineList.new(){2}
  else if (propName = 'city') then result := TFhirString.create() {5b}
  else if (propName = 'district') then result := TFhirString.create() {5b}
  else if (propName = 'state') then result := TFhirString.create() {5b}
  else if (propName = 'postalCode') then result := TFhirString.create() {5b}
  else if (propName = 'country') then result := TFhirString.create() {5b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAddress.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'use') then result := 'code'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'line') then result := 'string'
  else if (propName = 'city') then result := 'string'
  else if (propName = 'district') then result := 'string'
  else if (propName = 'state') then result := 'string'
  else if (propName = 'postalCode') then result := 'string'
  else if (propName = 'country') then result := 'string'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAddress.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'use') then UseElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'line') then deletePropertyValue('line', LineList, value) {2}
  else if (propName = 'city') then CityElement := nil
  else if (propName = 'district') then DistrictElement := nil
  else if (propName = 'state') then StateElement := nil
  else if (propName = 'postalCode') then PostalCodeElement := nil
  else if (propName = 'country') then CountryElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAddress.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'use') then UseElement := asEnum(SYSTEMS_TFhirAddressUseEnum, CODES_TFhirAddressUseEnum, new){4}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirAddressTypeEnum, CODES_TFhirAddressTypeEnum, new){4}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'line') then replacePropertyValue('line', LineList, existing, new) {2}
  else if (propName = 'city') then CityElement := asString(new){5b}
  else if (propName = 'district') then DistrictElement := asString(new){5b}
  else if (propName = 'state') then StateElement := asString(new){5b}
  else if (propName = 'postalCode') then PostalCodeElement := asString(new){5b}
  else if (propName = 'country') then CountryElement := asString(new){5b}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAddress.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'line') then LineList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAddress.fhirType : string;
begin
  result := 'Address';
end;

function TFhirAddress.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUse) and isEmptyProp(FType_) and isEmptyProp(FText) and isEmptyProp(FlineList) and isEmptyProp(FCity) and isEmptyProp(FDistrict) and isEmptyProp(FState) and isEmptyProp(FPostalCode) and isEmptyProp(FCountry) and isEmptyProp(FPeriod);
end;

function TFhirAddress.equals(other : TObject) : boolean; 
var
  o : TFhirAddress;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAddress)) then
    result := false
  else
  begin
    o := TFhirAddress(other);
    result := compareDeep(useElement, o.useElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(lineList, o.lineList, true) and 
      compareDeep(cityElement, o.cityElement, true) and compareDeep(districtElement, o.districtElement, true) and 
      compareDeep(stateElement, o.stateElement, true) and compareDeep(postalCodeElement, o.postalCodeElement, true) and 
      compareDeep(countryElement, o.countryElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirAddress.Link : TFhirAddress;
begin
  result := TFhirAddress(inherited Link);
end;

function TFhirAddress.Clone : TFhirAddress;
begin
  result := TFhirAddress(inherited Clone);
end;

procedure TFhirAddress.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('use');
  fields.add('type');
  fields.add('text');
  fields.add('line');
  fields.add('city');
  fields.add('district');
  fields.add('state');
  fields.add('postalCode');
  fields.add('country');
  fields.add('period');
end;

{ TFhirAddress }

Procedure TFhirAddress.SetUse(value : TFhirEnum);
begin
  FUse.free;
  FUse := value;
end;

Function TFhirAddress.GetUseST : TFhirAddressUseEnum;
begin
  if FUse = nil then
    result := TFhirAddressUseEnum(0)
  else
    result := TFhirAddressUseEnum(StringArrayIndexOfSensitive(CODES_TFhirAddressUseEnum, FUse.value));
end;

Procedure TFhirAddress.SetUseST(value : TFhirAddressUseEnum);
begin
  if ord(value) = 0 then
    UseElement := nil
  else
    UseElement := TFhirEnum.create(SYSTEMS_TFhirAddressUseEnum[value], CODES_TFhirAddressUseEnum[value]);
end;

Procedure TFhirAddress.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirAddress.GetType_ST : TFhirAddressTypeEnum;
begin
  if FType_ = nil then
    result := TFhirAddressTypeEnum(0)
  else
    result := TFhirAddressTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirAddressTypeEnum, FType_.value));
end;

Procedure TFhirAddress.SetType_ST(value : TFhirAddressTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirAddressTypeEnum[value], CODES_TFhirAddressTypeEnum[value]);
end;

Procedure TFhirAddress.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirAddress.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirAddress.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Function TFhirAddress.GetLineList : TFhirStringList;
begin
  if FLineList = nil then
    FLineList := TFhirStringList.Create;
  result := FLineList;
end;

Function TFhirAddress.GetHasLineList : boolean;
begin
  result := (FLineList <> nil) and (FLineList.count > 0);
end;

Procedure TFhirAddress.SetCity(value : TFhirString);
begin
  FCity.free;
  FCity := value;
end;

Function TFhirAddress.GetCityST : String;
begin
  if FCity = nil then
    result := ''
  else
    result := FCity.value;
end;

Procedure TFhirAddress.SetCityST(value : String);
begin
  if value <> '' then
  begin
    if FCity = nil then
      FCity := TFhirString.create;
    FCity.value := value
  end
  else if FCity <> nil then
    FCity.value := '';
end;

Procedure TFhirAddress.SetDistrict(value : TFhirString);
begin
  FDistrict.free;
  FDistrict := value;
end;

Function TFhirAddress.GetDistrictST : String;
begin
  if FDistrict = nil then
    result := ''
  else
    result := FDistrict.value;
end;

Procedure TFhirAddress.SetDistrictST(value : String);
begin
  if value <> '' then
  begin
    if FDistrict = nil then
      FDistrict := TFhirString.create;
    FDistrict.value := value
  end
  else if FDistrict <> nil then
    FDistrict.value := '';
end;

Procedure TFhirAddress.SetState(value : TFhirString);
begin
  FState.free;
  FState := value;
end;

Function TFhirAddress.GetStateST : String;
begin
  if FState = nil then
    result := ''
  else
    result := FState.value;
end;

Procedure TFhirAddress.SetStateST(value : String);
begin
  if value <> '' then
  begin
    if FState = nil then
      FState := TFhirString.create;
    FState.value := value
  end
  else if FState <> nil then
    FState.value := '';
end;

Procedure TFhirAddress.SetPostalCode(value : TFhirString);
begin
  FPostalCode.free;
  FPostalCode := value;
end;

Function TFhirAddress.GetPostalCodeST : String;
begin
  if FPostalCode = nil then
    result := ''
  else
    result := FPostalCode.value;
end;

Procedure TFhirAddress.SetPostalCodeST(value : String);
begin
  if value <> '' then
  begin
    if FPostalCode = nil then
      FPostalCode := TFhirString.create;
    FPostalCode.value := value
  end
  else if FPostalCode <> nil then
    FPostalCode.value := '';
end;

Procedure TFhirAddress.SetCountry(value : TFhirString);
begin
  FCountry.free;
  FCountry := value;
end;

Function TFhirAddress.GetCountryST : String;
begin
  if FCountry = nil then
    result := ''
  else
    result := FCountry.value;
end;

Procedure TFhirAddress.SetCountryST(value : String);
begin
  if value <> '' then
  begin
    if FCountry = nil then
      FCountry := TFhirString.create;
    FCountry.value := value
  end
  else if FCountry <> nil then
    FCountry.value := '';
end;

Procedure TFhirAddress.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirAddress.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUse.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FlineList.sizeInBytes);
  inc(result, FCity.sizeInBytes);
  inc(result, FDistrict.sizeInBytes);
  inc(result, FState.sizeInBytes);
  inc(result, FPostalCode.sizeInBytes);
  inc(result, FCountry.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirAddressListEnumerator }

Constructor TFhirAddressListEnumerator.Create(list : TFhirAddressList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAddressListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAddressListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAddressListEnumerator.GetCurrent : TFhirAddress;
begin
  Result := FList[FIndex];
end;

function TFhirAddressListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAddressList }
procedure TFhirAddressList.AddItem(value: TFhirAddress);
begin
  assert(value.ClassName = 'TFhirAddress', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAddress');
  add(value);
end;

function TFhirAddressList.Append: TFhirAddress;
begin
  result := TFhirAddress.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAddressList.ClearItems;
begin
  Clear;
end;

function TFhirAddressList.GetEnumerator : TFhirAddressListEnumerator;
begin
  result := TFhirAddressListEnumerator.Create(self.link);
end;

function TFhirAddressList.Clone: TFhirAddressList;
begin
  result := TFhirAddressList(inherited Clone);
end;

function TFhirAddressList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAddressList.GetItemN(index: Integer): TFhirAddress;
begin
  result := TFhirAddress(ObjectByIndex[index]);
end;

function TFhirAddressList.ItemClass: TFslObjectClass;
begin
  result := TFhirAddress;
end;
function TFhirAddressList.IndexOf(value: TFhirAddress): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAddressList.Insert(index: Integer): TFhirAddress;
begin
  result := TFhirAddress.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAddressList.InsertItem(index: Integer; value: TFhirAddress);
begin
  assert(value is TFhirAddress);
  Inherited Insert(index, value);
end;

function TFhirAddressList.Item(index: Integer): TFhirAddress;
begin
  result := TFhirAddress(ObjectByIndex[index]);
end;

function TFhirAddressList.Link: TFhirAddressList;
begin
  result := TFhirAddressList(inherited Link);
end;

procedure TFhirAddressList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAddressList.SetItemByIndex(index: Integer; value: TFhirAddress);
begin
  assert(value is TFhirAddress);
  FhirAddresses[index] := value;
end;

procedure TFhirAddressList.SetItemN(index: Integer; value: TFhirAddress);
begin
  assert(value is TFhirAddress);
  ObjectByIndex[index] := value;
end;

function TFhirPropertyRepresentationEnumListAsInteger(aSet : TFhirPropertyRepresentationEnumList) : Integer;
var
  a : TFhirPropertyRepresentationEnum;
begin
  result := 0;
  for a := low(TFhirPropertyRepresentationEnum) to high(TFhirPropertyRepresentationEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirPropertyRepresentationEnumList(i : Integer) : TFhirPropertyRepresentationEnumList;
var
  aLoop : TFhirPropertyRepresentationEnum;
begin
  result := [];
  for aLoop := low(TFhirPropertyRepresentationEnum) to high(TFhirPropertyRepresentationEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirDiscriminatorTypeEnumListAsInteger(aSet : TFhirDiscriminatorTypeEnumList) : Integer;
var
  a : TFhirDiscriminatorTypeEnum;
begin
  result := 0;
  for a := low(TFhirDiscriminatorTypeEnum) to high(TFhirDiscriminatorTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirDiscriminatorTypeEnumList(i : Integer) : TFhirDiscriminatorTypeEnumList;
var
  aLoop : TFhirDiscriminatorTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirDiscriminatorTypeEnum) to high(TFhirDiscriminatorTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirResourceSlicingRulesEnumListAsInteger(aSet : TFhirResourceSlicingRulesEnumList) : Integer;
var
  a : TFhirResourceSlicingRulesEnum;
begin
  result := 0;
  for a := low(TFhirResourceSlicingRulesEnum) to high(TFhirResourceSlicingRulesEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirResourceSlicingRulesEnumList(i : Integer) : TFhirResourceSlicingRulesEnumList;
var
  aLoop : TFhirResourceSlicingRulesEnum;
begin
  result := [];
  for aLoop := low(TFhirResourceSlicingRulesEnum) to high(TFhirResourceSlicingRulesEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirResourceAggregationModeEnumListAsInteger(aSet : TFhirResourceAggregationModeEnumList) : Integer;
var
  a : TFhirResourceAggregationModeEnum;
begin
  result := 0;
  for a := low(TFhirResourceAggregationModeEnum) to high(TFhirResourceAggregationModeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirResourceAggregationModeEnumList(i : Integer) : TFhirResourceAggregationModeEnumList;
var
  aLoop : TFhirResourceAggregationModeEnum;
begin
  result := [];
  for aLoop := low(TFhirResourceAggregationModeEnum) to high(TFhirResourceAggregationModeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirReferenceVersionRulesEnumListAsInteger(aSet : TFhirReferenceVersionRulesEnumList) : Integer;
var
  a : TFhirReferenceVersionRulesEnum;
begin
  result := 0;
  for a := low(TFhirReferenceVersionRulesEnum) to high(TFhirReferenceVersionRulesEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirReferenceVersionRulesEnumList(i : Integer) : TFhirReferenceVersionRulesEnumList;
var
  aLoop : TFhirReferenceVersionRulesEnum;
begin
  result := [];
  for aLoop := low(TFhirReferenceVersionRulesEnum) to high(TFhirReferenceVersionRulesEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirConstraintSeverityEnumListAsInteger(aSet : TFhirConstraintSeverityEnumList) : Integer;
var
  a : TFhirConstraintSeverityEnum;
begin
  result := 0;
  for a := low(TFhirConstraintSeverityEnum) to high(TFhirConstraintSeverityEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirConstraintSeverityEnumList(i : Integer) : TFhirConstraintSeverityEnumList;
var
  aLoop : TFhirConstraintSeverityEnum;
begin
  result := [];
  for aLoop := low(TFhirConstraintSeverityEnum) to high(TFhirConstraintSeverityEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirBindingStrengthEnumListAsInteger(aSet : TFhirBindingStrengthEnumList) : Integer;
var
  a : TFhirBindingStrengthEnum;
begin
  result := 0;
  for a := low(TFhirBindingStrengthEnum) to high(TFhirBindingStrengthEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirBindingStrengthEnumList(i : Integer) : TFhirBindingStrengthEnumList;
var
  aLoop : TFhirBindingStrengthEnum;
begin
  result := [];
  for aLoop := low(TFhirBindingStrengthEnum) to high(TFhirBindingStrengthEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

{ TFhirElementDefinitionSlicing }

constructor TFhirElementDefinitionSlicing.Create;
begin
  inherited;
end;

destructor TFhirElementDefinitionSlicing.Destroy;
begin
  FDiscriminatorList.Free;
  FDescription.free;
  FOrdered.free;
  FRules.free;
  inherited;
end;

procedure TFhirElementDefinitionSlicing.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirElementDefinitionSlicing(oSource).FDiscriminatorList = nil) then
  begin
    FDiscriminatorList.free;
    FDiscriminatorList := nil;
  end
  else
  begin
    if FDiscriminatorList = nil then
      FDiscriminatorList := TFhirElementDefinitionSlicingDiscriminatorList.Create;
    FDiscriminatorList.Assign(TFhirElementDefinitionSlicing(oSource).FDiscriminatorList);
  end;
  descriptionElement := TFhirElementDefinitionSlicing(oSource).descriptionElement.Clone;
  orderedElement := TFhirElementDefinitionSlicing(oSource).orderedElement.Clone;
  FRules := TFhirElementDefinitionSlicing(oSource).FRules.Link;
end;

procedure TFhirElementDefinitionSlicing.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'discriminator') Then
    list.addAll(self, 'discriminator', FDiscriminatorList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'ordered') Then
     list.add(self.link, 'ordered', FOrdered.Link);
  if (child_name = 'rules') Then
     list.add(self.link, 'rules', FRules.Link);
end;

procedure TFhirElementDefinitionSlicing.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'discriminator', '', true, TFhirElementDefinitionSlicingDiscriminator, FDiscriminatorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ordered', 'boolean', false, TFhirBoolean, FOrdered.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rules', 'code', false, TFHIREnum, FRules.Link));{1}
end;

function TFhirElementDefinitionSlicing.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'discriminator') then
  begin
    DiscriminatorList.add(propValue as TFhirElementDefinitionSlicingDiscriminator){2a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'ordered') then
  begin
    OrderedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'rules') then
  begin
    RulesElement := asEnum(SYSTEMS_TFhirResourceSlicingRulesEnum, CODES_TFhirResourceSlicingRulesEnum, propValue);
    result := propValue
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirElementDefinitionSlicing.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'discriminator') then DiscriminatorList.insertItem(index, propValue as TFhirElementDefinitionSlicingDiscriminator){2a}
  else inherited;
end;

function TFhirElementDefinitionSlicing.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'discriminator') then result := DiscriminatorList.new(){2}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'ordered') then result := TFhirBoolean.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirElementDefinitionSlicing.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'discriminator') then result := ''
  else if (propName = 'description') then result := 'string'
  else if (propName = 'ordered') then result := 'boolean'
  else if (propName = 'rules') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirElementDefinitionSlicing.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'discriminator') then deletePropertyValue('discriminator', DiscriminatorList, value) {2}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'ordered') then OrderedElement := nil
  else if (propName = 'rules') then RulesElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirElementDefinitionSlicing.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'discriminator') then replacePropertyValue('discriminator', DiscriminatorList, existing, new) {2}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'ordered') then OrderedElement := asBoolean(new){5b}
  else if (propName = 'rules') then RulesElement := asEnum(SYSTEMS_TFhirResourceSlicingRulesEnum, CODES_TFhirResourceSlicingRulesEnum, new){4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirElementDefinitionSlicing.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'discriminator') then DiscriminatorList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirElementDefinitionSlicing.fhirType : string;
begin
  result := 'slicing';
end;

function TFhirElementDefinitionSlicing.Link : TFhirElementDefinitionSlicing;
begin
  result := TFhirElementDefinitionSlicing(inherited Link);
end;

function TFhirElementDefinitionSlicing.Clone : TFhirElementDefinitionSlicing;
begin
  result := TFhirElementDefinitionSlicing(inherited Clone);
end;

function TFhirElementDefinitionSlicing.equals(other : TObject) : boolean; 
var
  o : TFhirElementDefinitionSlicing;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirElementDefinitionSlicing)) then
    result := false
  else
  begin
    o := TFhirElementDefinitionSlicing(other);
    result := compareDeep(discriminatorList, o.discriminatorList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(orderedElement, o.orderedElement, true) and compareDeep(rulesElement, o.rulesElement, true);
  end;
end;

function TFhirElementDefinitionSlicing.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FdiscriminatorList) and isEmptyProp(FDescription) and isEmptyProp(FOrdered) and isEmptyProp(FRules);
end;

procedure TFhirElementDefinitionSlicing.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('discriminator');
  fields.add('description');
  fields.add('ordered');
  fields.add('rules');
end;

{ TFhirElementDefinitionSlicing }

Function TFhirElementDefinitionSlicing.GetDiscriminatorList : TFhirElementDefinitionSlicingDiscriminatorList;
begin
  if FDiscriminatorList = nil then
    FDiscriminatorList := TFhirElementDefinitionSlicingDiscriminatorList.Create;
  result := FDiscriminatorList;
end;

Function TFhirElementDefinitionSlicing.GetHasDiscriminatorList : boolean;
begin
  result := (FDiscriminatorList <> nil) and (FDiscriminatorList.count > 0);
end;

Procedure TFhirElementDefinitionSlicing.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirElementDefinitionSlicing.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirElementDefinitionSlicing.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirElementDefinitionSlicing.SetOrdered(value : TFhirBoolean);
begin
  FOrdered.free;
  FOrdered := value;
end;

Function TFhirElementDefinitionSlicing.GetOrderedST : Boolean;
begin
  if FOrdered = nil then
    result := false
  else
    result := FOrdered.value;
end;

Procedure TFhirElementDefinitionSlicing.SetOrderedST(value : Boolean);
begin
  if FOrdered = nil then
    FOrdered := TFhirBoolean.create;
  FOrdered.value := value
end;

Procedure TFhirElementDefinitionSlicing.SetRules(value : TFhirEnum);
begin
  FRules.free;
  FRules := value;
end;

Function TFhirElementDefinitionSlicing.GetRulesST : TFhirResourceSlicingRulesEnum;
begin
  if FRules = nil then
    result := TFhirResourceSlicingRulesEnum(0)
  else
    result := TFhirResourceSlicingRulesEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceSlicingRulesEnum, FRules.value));
end;

Procedure TFhirElementDefinitionSlicing.SetRulesST(value : TFhirResourceSlicingRulesEnum);
begin
  if ord(value) = 0 then
    RulesElement := nil
  else
    RulesElement := TFhirEnum.create(SYSTEMS_TFhirResourceSlicingRulesEnum[value], CODES_TFhirResourceSlicingRulesEnum[value]);
end;

function TFhirElementDefinitionSlicing.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FdiscriminatorList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FOrdered.sizeInBytes);
  inc(result, FRules.sizeInBytes);
end;

{ TFhirElementDefinitionSlicingListEnumerator }

Constructor TFhirElementDefinitionSlicingListEnumerator.Create(list : TFhirElementDefinitionSlicingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirElementDefinitionSlicingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirElementDefinitionSlicingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirElementDefinitionSlicingListEnumerator.GetCurrent : TFhirElementDefinitionSlicing;
begin
  Result := FList[FIndex];
end;

function TFhirElementDefinitionSlicingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirElementDefinitionSlicingList }
procedure TFhirElementDefinitionSlicingList.AddItem(value: TFhirElementDefinitionSlicing);
begin
  assert(value.ClassName = 'TFhirElementDefinitionSlicing', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirElementDefinitionSlicing');
  add(value);
end;

function TFhirElementDefinitionSlicingList.Append: TFhirElementDefinitionSlicing;
begin
  result := TFhirElementDefinitionSlicing.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirElementDefinitionSlicingList.ClearItems;
begin
  Clear;
end;

function TFhirElementDefinitionSlicingList.GetEnumerator : TFhirElementDefinitionSlicingListEnumerator;
begin
  result := TFhirElementDefinitionSlicingListEnumerator.Create(self.link);
end;

function TFhirElementDefinitionSlicingList.Clone: TFhirElementDefinitionSlicingList;
begin
  result := TFhirElementDefinitionSlicingList(inherited Clone);
end;

function TFhirElementDefinitionSlicingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirElementDefinitionSlicingList.GetItemN(index: Integer): TFhirElementDefinitionSlicing;
begin
  result := TFhirElementDefinitionSlicing(ObjectByIndex[index]);
end;

function TFhirElementDefinitionSlicingList.ItemClass: TFslObjectClass;
begin
  result := TFhirElementDefinitionSlicing;
end;
function TFhirElementDefinitionSlicingList.IndexOf(value: TFhirElementDefinitionSlicing): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirElementDefinitionSlicingList.Insert(index: Integer): TFhirElementDefinitionSlicing;
begin
  result := TFhirElementDefinitionSlicing.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirElementDefinitionSlicingList.InsertItem(index: Integer; value: TFhirElementDefinitionSlicing);
begin
  assert(value is TFhirElementDefinitionSlicing);
  Inherited Insert(index, value);
end;

function TFhirElementDefinitionSlicingList.Item(index: Integer): TFhirElementDefinitionSlicing;
begin
  result := TFhirElementDefinitionSlicing(ObjectByIndex[index]);
end;

function TFhirElementDefinitionSlicingList.Link: TFhirElementDefinitionSlicingList;
begin
  result := TFhirElementDefinitionSlicingList(inherited Link);
end;

procedure TFhirElementDefinitionSlicingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirElementDefinitionSlicingList.SetItemByIndex(index: Integer; value: TFhirElementDefinitionSlicing);
begin
  assert(value is TFhirElementDefinitionSlicing);
  FhirElementDefinitionSlicings[index] := value;
end;

procedure TFhirElementDefinitionSlicingList.SetItemN(index: Integer; value: TFhirElementDefinitionSlicing);
begin
  assert(value is TFhirElementDefinitionSlicing);
  ObjectByIndex[index] := value;
end;

{ TFhirElementDefinitionSlicingDiscriminator }

constructor TFhirElementDefinitionSlicingDiscriminator.Create;
begin
  inherited;
end;

destructor TFhirElementDefinitionSlicingDiscriminator.Destroy;
begin
  FType_.free;
  FPath.free;
  inherited;
end;

procedure TFhirElementDefinitionSlicingDiscriminator.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirElementDefinitionSlicingDiscriminator(oSource).FType_.Link;
  pathElement := TFhirElementDefinitionSlicingDiscriminator(oSource).pathElement.Clone;
end;

procedure TFhirElementDefinitionSlicingDiscriminator.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
end;

procedure TFhirElementDefinitionSlicingDiscriminator.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));{2}
end;

function TFhirElementDefinitionSlicingDiscriminator.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirDiscriminatorTypeEnum, CODES_TFhirDiscriminatorTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'path') then
  begin
    PathElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirElementDefinitionSlicingDiscriminator.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirElementDefinitionSlicingDiscriminator.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'path') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirElementDefinitionSlicingDiscriminator.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'path') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirElementDefinitionSlicingDiscriminator.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'path') then PathElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirElementDefinitionSlicingDiscriminator.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirDiscriminatorTypeEnum, CODES_TFhirDiscriminatorTypeEnum, new){4}
  else if (propName = 'path') then PathElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirElementDefinitionSlicingDiscriminator.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirElementDefinitionSlicingDiscriminator.fhirType : string;
begin
  result := 'discriminator';
end;

function TFhirElementDefinitionSlicingDiscriminator.Link : TFhirElementDefinitionSlicingDiscriminator;
begin
  result := TFhirElementDefinitionSlicingDiscriminator(inherited Link);
end;

function TFhirElementDefinitionSlicingDiscriminator.Clone : TFhirElementDefinitionSlicingDiscriminator;
begin
  result := TFhirElementDefinitionSlicingDiscriminator(inherited Clone);
end;

function TFhirElementDefinitionSlicingDiscriminator.equals(other : TObject) : boolean; 
var
  o : TFhirElementDefinitionSlicingDiscriminator;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirElementDefinitionSlicingDiscriminator)) then
    result := false
  else
  begin
    o := TFhirElementDefinitionSlicingDiscriminator(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(pathElement, o.pathElement, true);
  end;
end;

function TFhirElementDefinitionSlicingDiscriminator.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FPath);
end;

procedure TFhirElementDefinitionSlicingDiscriminator.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('path');
end;

{ TFhirElementDefinitionSlicingDiscriminator }

Procedure TFhirElementDefinitionSlicingDiscriminator.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirElementDefinitionSlicingDiscriminator.GetType_ST : TFhirDiscriminatorTypeEnum;
begin
  if FType_ = nil then
    result := TFhirDiscriminatorTypeEnum(0)
  else
    result := TFhirDiscriminatorTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDiscriminatorTypeEnum, FType_.value));
end;

Procedure TFhirElementDefinitionSlicingDiscriminator.SetType_ST(value : TFhirDiscriminatorTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirDiscriminatorTypeEnum[value], CODES_TFhirDiscriminatorTypeEnum[value]);
end;

Procedure TFhirElementDefinitionSlicingDiscriminator.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

Function TFhirElementDefinitionSlicingDiscriminator.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

Procedure TFhirElementDefinitionSlicingDiscriminator.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

function TFhirElementDefinitionSlicingDiscriminator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FPath.sizeInBytes);
end;

{ TFhirElementDefinitionSlicingDiscriminatorListEnumerator }

Constructor TFhirElementDefinitionSlicingDiscriminatorListEnumerator.Create(list : TFhirElementDefinitionSlicingDiscriminatorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirElementDefinitionSlicingDiscriminatorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirElementDefinitionSlicingDiscriminatorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirElementDefinitionSlicingDiscriminatorListEnumerator.GetCurrent : TFhirElementDefinitionSlicingDiscriminator;
begin
  Result := FList[FIndex];
end;

function TFhirElementDefinitionSlicingDiscriminatorListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirElementDefinitionSlicingDiscriminatorList }
procedure TFhirElementDefinitionSlicingDiscriminatorList.AddItem(value: TFhirElementDefinitionSlicingDiscriminator);
begin
  assert(value.ClassName = 'TFhirElementDefinitionSlicingDiscriminator', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirElementDefinitionSlicingDiscriminator');
  add(value);
end;

function TFhirElementDefinitionSlicingDiscriminatorList.Append: TFhirElementDefinitionSlicingDiscriminator;
begin
  result := TFhirElementDefinitionSlicingDiscriminator.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirElementDefinitionSlicingDiscriminatorList.ClearItems;
begin
  Clear;
end;

function TFhirElementDefinitionSlicingDiscriminatorList.GetEnumerator : TFhirElementDefinitionSlicingDiscriminatorListEnumerator;
begin
  result := TFhirElementDefinitionSlicingDiscriminatorListEnumerator.Create(self.link);
end;

function TFhirElementDefinitionSlicingDiscriminatorList.Clone: TFhirElementDefinitionSlicingDiscriminatorList;
begin
  result := TFhirElementDefinitionSlicingDiscriminatorList(inherited Clone);
end;

function TFhirElementDefinitionSlicingDiscriminatorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirElementDefinitionSlicingDiscriminatorList.GetItemN(index: Integer): TFhirElementDefinitionSlicingDiscriminator;
begin
  result := TFhirElementDefinitionSlicingDiscriminator(ObjectByIndex[index]);
end;

function TFhirElementDefinitionSlicingDiscriminatorList.ItemClass: TFslObjectClass;
begin
  result := TFhirElementDefinitionSlicingDiscriminator;
end;
function TFhirElementDefinitionSlicingDiscriminatorList.IndexOf(value: TFhirElementDefinitionSlicingDiscriminator): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirElementDefinitionSlicingDiscriminatorList.Insert(index: Integer): TFhirElementDefinitionSlicingDiscriminator;
begin
  result := TFhirElementDefinitionSlicingDiscriminator.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirElementDefinitionSlicingDiscriminatorList.InsertItem(index: Integer; value: TFhirElementDefinitionSlicingDiscriminator);
begin
  assert(value is TFhirElementDefinitionSlicingDiscriminator);
  Inherited Insert(index, value);
end;

function TFhirElementDefinitionSlicingDiscriminatorList.Item(index: Integer): TFhirElementDefinitionSlicingDiscriminator;
begin
  result := TFhirElementDefinitionSlicingDiscriminator(ObjectByIndex[index]);
end;

function TFhirElementDefinitionSlicingDiscriminatorList.Link: TFhirElementDefinitionSlicingDiscriminatorList;
begin
  result := TFhirElementDefinitionSlicingDiscriminatorList(inherited Link);
end;

procedure TFhirElementDefinitionSlicingDiscriminatorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirElementDefinitionSlicingDiscriminatorList.SetItemByIndex(index: Integer; value: TFhirElementDefinitionSlicingDiscriminator);
begin
  assert(value is TFhirElementDefinitionSlicingDiscriminator);
  FhirElementDefinitionSlicingDiscriminators[index] := value;
end;

procedure TFhirElementDefinitionSlicingDiscriminatorList.SetItemN(index: Integer; value: TFhirElementDefinitionSlicingDiscriminator);
begin
  assert(value is TFhirElementDefinitionSlicingDiscriminator);
  ObjectByIndex[index] := value;
end;

{ TFhirElementDefinitionBase }

constructor TFhirElementDefinitionBase.Create;
begin
  inherited;
end;

destructor TFhirElementDefinitionBase.Destroy;
begin
  FPath.free;
  FMin.free;
  FMax.free;
  inherited;
end;

procedure TFhirElementDefinitionBase.Assign(oSource : TFslObject);
begin
  inherited;
  pathElement := TFhirElementDefinitionBase(oSource).pathElement.Clone;
  minElement := TFhirElementDefinitionBase(oSource).minElement.Clone;
  maxElement := TFhirElementDefinitionBase(oSource).maxElement.Clone;
end;

procedure TFhirElementDefinitionBase.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
  if (child_name = 'min') Then
     list.add(self.link, 'min', FMin.Link);
  if (child_name = 'max') Then
     list.add(self.link, 'max', FMax.Link);
end;

procedure TFhirElementDefinitionBase.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));{2}
  oList.add(TFHIRProperty.create(self, 'min', 'unsignedInt', false, TFhirUnsignedInt, FMin.Link));{2}
  oList.add(TFHIRProperty.create(self, 'max', 'string', false, TFhirString, FMax.Link));{2}
end;

function TFhirElementDefinitionBase.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'path') then
  begin
    PathElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'min') then
  begin
    MinElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'max') then
  begin
    MaxElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirElementDefinitionBase.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirElementDefinitionBase.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'path') then result := TFhirString.create() {5b}
  else if (propName = 'min') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'max') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirElementDefinitionBase.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'path') then result := 'string'
  else if (propName = 'min') then result := 'unsignedInt'
  else if (propName = 'max') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirElementDefinitionBase.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'path') then PathElement := nil
  else if (propName = 'min') then MinElement := nil
  else if (propName = 'max') then MaxElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirElementDefinitionBase.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'path') then PathElement := asString(new){5b}
  else if (propName = 'min') then MinElement := asUnsignedInt(new){5b}
  else if (propName = 'max') then MaxElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirElementDefinitionBase.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirElementDefinitionBase.fhirType : string;
begin
  result := 'base';
end;

function TFhirElementDefinitionBase.Link : TFhirElementDefinitionBase;
begin
  result := TFhirElementDefinitionBase(inherited Link);
end;

function TFhirElementDefinitionBase.Clone : TFhirElementDefinitionBase;
begin
  result := TFhirElementDefinitionBase(inherited Clone);
end;

function TFhirElementDefinitionBase.equals(other : TObject) : boolean; 
var
  o : TFhirElementDefinitionBase;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirElementDefinitionBase)) then
    result := false
  else
  begin
    o := TFhirElementDefinitionBase(other);
    result := compareDeep(pathElement, o.pathElement, true) and compareDeep(minElement, o.minElement, true) and 
      compareDeep(maxElement, o.maxElement, true);
  end;
end;

function TFhirElementDefinitionBase.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPath) and isEmptyProp(FMin) and isEmptyProp(FMax);
end;

procedure TFhirElementDefinitionBase.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('path');
  fields.add('min');
  fields.add('max');
end;

{ TFhirElementDefinitionBase }

Procedure TFhirElementDefinitionBase.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

Function TFhirElementDefinitionBase.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

Procedure TFhirElementDefinitionBase.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

Procedure TFhirElementDefinitionBase.SetMin(value : TFhirUnsignedInt);
begin
  FMin.free;
  FMin := value;
end;

Function TFhirElementDefinitionBase.GetMinST : String;
begin
  if FMin = nil then
    result := ''
  else
    result := FMin.value;
end;

Procedure TFhirElementDefinitionBase.SetMinST(value : String);
begin
  if value <> '' then
  begin
    if FMin = nil then
      FMin := TFhirUnsignedInt.create;
    FMin.value := value
  end
  else if FMin <> nil then
    FMin.value := '';
end;

Procedure TFhirElementDefinitionBase.SetMax(value : TFhirString);
begin
  FMax.free;
  FMax := value;
end;

Function TFhirElementDefinitionBase.GetMaxST : String;
begin
  if FMax = nil then
    result := ''
  else
    result := FMax.value;
end;

Procedure TFhirElementDefinitionBase.SetMaxST(value : String);
begin
  if value <> '' then
  begin
    if FMax = nil then
      FMax := TFhirString.create;
    FMax.value := value
  end
  else if FMax <> nil then
    FMax.value := '';
end;

function TFhirElementDefinitionBase.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPath.sizeInBytes);
  inc(result, FMin.sizeInBytes);
  inc(result, FMax.sizeInBytes);
end;

{ TFhirElementDefinitionBaseListEnumerator }

Constructor TFhirElementDefinitionBaseListEnumerator.Create(list : TFhirElementDefinitionBaseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirElementDefinitionBaseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirElementDefinitionBaseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirElementDefinitionBaseListEnumerator.GetCurrent : TFhirElementDefinitionBase;
begin
  Result := FList[FIndex];
end;

function TFhirElementDefinitionBaseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirElementDefinitionBaseList }
procedure TFhirElementDefinitionBaseList.AddItem(value: TFhirElementDefinitionBase);
begin
  assert(value.ClassName = 'TFhirElementDefinitionBase', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirElementDefinitionBase');
  add(value);
end;

function TFhirElementDefinitionBaseList.Append: TFhirElementDefinitionBase;
begin
  result := TFhirElementDefinitionBase.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirElementDefinitionBaseList.ClearItems;
begin
  Clear;
end;

function TFhirElementDefinitionBaseList.GetEnumerator : TFhirElementDefinitionBaseListEnumerator;
begin
  result := TFhirElementDefinitionBaseListEnumerator.Create(self.link);
end;

function TFhirElementDefinitionBaseList.Clone: TFhirElementDefinitionBaseList;
begin
  result := TFhirElementDefinitionBaseList(inherited Clone);
end;

function TFhirElementDefinitionBaseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirElementDefinitionBaseList.GetItemN(index: Integer): TFhirElementDefinitionBase;
begin
  result := TFhirElementDefinitionBase(ObjectByIndex[index]);
end;

function TFhirElementDefinitionBaseList.ItemClass: TFslObjectClass;
begin
  result := TFhirElementDefinitionBase;
end;
function TFhirElementDefinitionBaseList.IndexOf(value: TFhirElementDefinitionBase): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirElementDefinitionBaseList.Insert(index: Integer): TFhirElementDefinitionBase;
begin
  result := TFhirElementDefinitionBase.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirElementDefinitionBaseList.InsertItem(index: Integer; value: TFhirElementDefinitionBase);
begin
  assert(value is TFhirElementDefinitionBase);
  Inherited Insert(index, value);
end;

function TFhirElementDefinitionBaseList.Item(index: Integer): TFhirElementDefinitionBase;
begin
  result := TFhirElementDefinitionBase(ObjectByIndex[index]);
end;

function TFhirElementDefinitionBaseList.Link: TFhirElementDefinitionBaseList;
begin
  result := TFhirElementDefinitionBaseList(inherited Link);
end;

procedure TFhirElementDefinitionBaseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirElementDefinitionBaseList.SetItemByIndex(index: Integer; value: TFhirElementDefinitionBase);
begin
  assert(value is TFhirElementDefinitionBase);
  FhirElementDefinitionBases[index] := value;
end;

procedure TFhirElementDefinitionBaseList.SetItemN(index: Integer; value: TFhirElementDefinitionBase);
begin
  assert(value is TFhirElementDefinitionBase);
  ObjectByIndex[index] := value;
end;

{ TFhirElementDefinitionType }

constructor TFhirElementDefinitionType.Create;
begin
  inherited;
end;

destructor TFhirElementDefinitionType.Destroy;
begin
  FCode.free;
  FProfileList.Free;
  FTargetProfileList.Free;
  FAggregation.Free;
  FVersioning.free;
  inherited;
end;

procedure TFhirElementDefinitionType.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirElementDefinitionType(oSource).codeElement.Clone;
  if (TFhirElementDefinitionType(oSource).FProfileList = nil) then
  begin
    FProfileList.free;
    FProfileList := nil;
  end
  else
  begin
    if FProfileList = nil then
      FProfileList := TFhirCanonicalList.Create;
    FProfileList.Assign(TFhirElementDefinitionType(oSource).FProfileList);
  end;
  if (TFhirElementDefinitionType(oSource).FTargetProfileList = nil) then
  begin
    FTargetProfileList.free;
    FTargetProfileList := nil;
  end
  else
  begin
    if FTargetProfileList = nil then
      FTargetProfileList := TFhirCanonicalList.Create;
    FTargetProfileList.Assign(TFhirElementDefinitionType(oSource).FTargetProfileList);
  end;
  if (TFhirElementDefinitionType(oSource).FAggregation = nil) then
  begin
    FAggregation.free;
    FAggregation := nil;
  end
  else
  begin
    FAggregation := TFHIREnumList.Create(SYSTEMS_TFhirResourceAggregationModeEnum, CODES_TFhirResourceAggregationModeEnum);
    FAggregation.Assign(TFhirElementDefinitionType(oSource).FAggregation);
  end;
  FVersioning := TFhirElementDefinitionType(oSource).FVersioning.Link;
end;

procedure TFhirElementDefinitionType.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'profile') Then
    list.addAll(self, 'profile', FProfileList);
  if (child_name = 'targetProfile') Then
    list.addAll(self, 'targetProfile', FTargetProfileList);
  if (child_name = 'aggregation') Then
     list.addAll(self, 'aggregation', FAggregation);
  if (child_name = 'versioning') Then
     list.add(self.link, 'versioning', FVersioning.Link);
end;

procedure TFhirElementDefinitionType.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'uri', false, TFhirUri, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'profile', 'canonical', true, TFhirCanonical, FProfileList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'targetProfile', 'canonical', true, TFhirCanonical, FTargetProfileList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'aggregation', 'code', true, TFHIREnum, FAggregation.Link)){3};
  oList.add(TFHIRProperty.create(self, 'versioning', 'code', false, TFHIREnum, FVersioning.Link));{1}
end;

function TFhirElementDefinitionType.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'profile') then
  begin
    ProfileList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'targetProfile') then
  begin
    TargetProfileList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'aggregation') then
  begin
    AggregationList.add(asEnum(SYSTEMS_TFhirResourceAggregationModeEnum, CODES_TFhirResourceAggregationModeEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'versioning') then
  begin
    VersioningElement := asEnum(SYSTEMS_TFhirReferenceVersionRulesEnum, CODES_TFhirReferenceVersionRulesEnum, propValue);
    result := propValue
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirElementDefinitionType.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'profile') then ProfileList.insertItem(index, asCanonical(propValue)){2}
  else if (propName = 'targetProfile') then TargetProfileList.insertItem(index, asCanonical(propValue)){2}
  else if (propName = 'aggregation') then FAggregation.insertItem(index, asEnum(SYSTEMS_TFhirResourceAggregationModeEnum, CODES_TFhirResourceAggregationModeEnum, propValue)) {1}
  else inherited;
end;

function TFhirElementDefinitionType.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirUri.create() {5b}
  else if (propName = 'profile') then result := ProfileList.new(){2}
  else if (propName = 'targetProfile') then result := TargetProfileList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirElementDefinitionType.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'uri'
  else if (propName = 'profile') then result := 'canonical'
  else if (propName = 'targetProfile') then result := 'canonical'
  else if (propName = 'aggregation') then result := 'code'
  else if (propName = 'versioning') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirElementDefinitionType.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'profile') then deletePropertyValue('profile', ProfileList, value) {2}
  else if (propName = 'targetProfile') then deletePropertyValue('targetProfile', TargetProfileList, value) {2}
  else if (propName = 'versioning') then VersioningElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirElementDefinitionType.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asUri(new){5b}
  else if (propName = 'profile') then replacePropertyValue('profile', ProfileList, existing, new) {2}
  else if (propName = 'targetProfile') then replacePropertyValue('targetProfile', TargetProfileList, existing, new) {2}
  else if (propName = 'versioning') then VersioningElement := asEnum(SYSTEMS_TFhirReferenceVersionRulesEnum, CODES_TFhirReferenceVersionRulesEnum, new){4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirElementDefinitionType.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'profile') then ProfileList.move(source, destination){2}
  else if (propName = 'targetProfile') then TargetProfileList.move(source, destination){2}
  else if (propName = 'aggregation') then FAggregation.move(source, destination) {1}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirElementDefinitionType.fhirType : string;
begin
  result := 'type';
end;

function TFhirElementDefinitionType.Link : TFhirElementDefinitionType;
begin
  result := TFhirElementDefinitionType(inherited Link);
end;

function TFhirElementDefinitionType.Clone : TFhirElementDefinitionType;
begin
  result := TFhirElementDefinitionType(inherited Clone);
end;

function TFhirElementDefinitionType.equals(other : TObject) : boolean; 
var
  o : TFhirElementDefinitionType;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirElementDefinitionType)) then
    result := false
  else
  begin
    o := TFhirElementDefinitionType(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(profileList, o.profileList, true) and 
      compareDeep(targetProfileList, o.targetProfileList, true) and compareDeep(aggregationList, o.aggregationList, true) and 
      compareDeep(versioningElement, o.versioningElement, true);
  end;
end;

function TFhirElementDefinitionType.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FprofileList) and isEmptyProp(FtargetProfileList) and isEmptyProp(FAggregation) and isEmptyProp(FVersioning);
end;

procedure TFhirElementDefinitionType.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('profile');
  fields.add('targetProfile');
  fields.add('aggregation');
  fields.add('versioning');
end;

{ TFhirElementDefinitionType }

Procedure TFhirElementDefinitionType.SetCode(value : TFhirUri);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirElementDefinitionType.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirElementDefinitionType.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirUri.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Function TFhirElementDefinitionType.GetProfileList : TFhirCanonicalList;
begin
  if FProfileList = nil then
    FProfileList := TFhirCanonicalList.Create;
  result := FProfileList;
end;

Function TFhirElementDefinitionType.GetHasProfileList : boolean;
begin
  result := (FProfileList <> nil) and (FProfileList.count > 0);
end;

Function TFhirElementDefinitionType.GetTargetProfileList : TFhirCanonicalList;
begin
  if FTargetProfileList = nil then
    FTargetProfileList := TFhirCanonicalList.Create;
  result := FTargetProfileList;
end;

Function TFhirElementDefinitionType.GetHasTargetProfileList : boolean;
begin
  result := (FTargetProfileList <> nil) and (FTargetProfileList.count > 0);
end;

Function TFhirElementDefinitionType.GetAggregation : TFhirEnumList;
begin
  if FAggregation = nil then
    FAggregation := TFHIREnumList.Create(SYSTEMS_TFhirResourceAggregationModeEnum, CODES_TFhirResourceAggregationModeEnum);
  result := FAggregation;
end;

Function TFhirElementDefinitionType.GetHasAggregation : boolean;
begin
  result := (FAggregation <> nil) and (FAggregation.count > 0);
end;

Function TFhirElementDefinitionType.GetAggregationST : TFhirResourceAggregationModeEnumList;
  var i : integer;
begin
  result := [];
  if Faggregation <> nil then
    for i := 0 to Faggregation.count - 1 do
      result := result + [TFhirResourceAggregationModeEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceAggregationModeEnum, Faggregation[i].value))];
end;

Procedure TFhirElementDefinitionType.SetAggregationST(value : TFhirResourceAggregationModeEnumList);
var a : TFhirResourceAggregationModeEnum;
begin
  if Faggregation = nil then
    Faggregation := TFhirEnumList.create(SYSTEMS_TFhirResourceAggregationModeEnum, CODES_TFhirResourceAggregationModeEnum);
  Faggregation.clear;
  for a := low(TFhirResourceAggregationModeEnum) to high(TFhirResourceAggregationModeEnum) do
    if a in value then
      begin
         if Faggregation = nil then
           Faggregation := TFhirEnumList.create(SYSTEMS_TFhirResourceAggregationModeEnum, CODES_TFhirResourceAggregationModeEnum);
         Faggregation.add(TFhirEnum.create(SYSTEMS_TFhirResourceAggregationModeEnum[a], CODES_TFhirResourceAggregationModeEnum[a]));
      end;
end;

Procedure TFhirElementDefinitionType.SetVersioning(value : TFhirEnum);
begin
  FVersioning.free;
  FVersioning := value;
end;

Function TFhirElementDefinitionType.GetVersioningST : TFhirReferenceVersionRulesEnum;
begin
  if FVersioning = nil then
    result := TFhirReferenceVersionRulesEnum(0)
  else
    result := TFhirReferenceVersionRulesEnum(StringArrayIndexOfSensitive(CODES_TFhirReferenceVersionRulesEnum, FVersioning.value));
end;

Procedure TFhirElementDefinitionType.SetVersioningST(value : TFhirReferenceVersionRulesEnum);
begin
  if ord(value) = 0 then
    VersioningElement := nil
  else
    VersioningElement := TFhirEnum.create(SYSTEMS_TFhirReferenceVersionRulesEnum[value], CODES_TFhirReferenceVersionRulesEnum[value]);
end;

function TFhirElementDefinitionType.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FprofileList.sizeInBytes);
  inc(result, FtargetProfileList.sizeInBytes);
  inc(result, FAggregation.sizeInBytes);
  inc(result, FVersioning.sizeInBytes);
end;

{ TFhirElementDefinitionTypeListEnumerator }

Constructor TFhirElementDefinitionTypeListEnumerator.Create(list : TFhirElementDefinitionTypeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirElementDefinitionTypeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirElementDefinitionTypeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirElementDefinitionTypeListEnumerator.GetCurrent : TFhirElementDefinitionType;
begin
  Result := FList[FIndex];
end;

function TFhirElementDefinitionTypeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirElementDefinitionTypeList }
procedure TFhirElementDefinitionTypeList.AddItem(value: TFhirElementDefinitionType);
begin
  assert(value.ClassName = 'TFhirElementDefinitionType', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirElementDefinitionType');
  add(value);
end;

function TFhirElementDefinitionTypeList.Append: TFhirElementDefinitionType;
begin
  result := TFhirElementDefinitionType.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirElementDefinitionTypeList.ClearItems;
begin
  Clear;
end;

function TFhirElementDefinitionTypeList.GetEnumerator : TFhirElementDefinitionTypeListEnumerator;
begin
  result := TFhirElementDefinitionTypeListEnumerator.Create(self.link);
end;

function TFhirElementDefinitionTypeList.Clone: TFhirElementDefinitionTypeList;
begin
  result := TFhirElementDefinitionTypeList(inherited Clone);
end;

function TFhirElementDefinitionTypeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirElementDefinitionTypeList.GetItemN(index: Integer): TFhirElementDefinitionType;
begin
  result := TFhirElementDefinitionType(ObjectByIndex[index]);
end;

function TFhirElementDefinitionTypeList.ItemClass: TFslObjectClass;
begin
  result := TFhirElementDefinitionType;
end;
function TFhirElementDefinitionTypeList.IndexOf(value: TFhirElementDefinitionType): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirElementDefinitionTypeList.Insert(index: Integer): TFhirElementDefinitionType;
begin
  result := TFhirElementDefinitionType.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirElementDefinitionTypeList.InsertItem(index: Integer; value: TFhirElementDefinitionType);
begin
  assert(value is TFhirElementDefinitionType);
  Inherited Insert(index, value);
end;

function TFhirElementDefinitionTypeList.Item(index: Integer): TFhirElementDefinitionType;
begin
  result := TFhirElementDefinitionType(ObjectByIndex[index]);
end;

function TFhirElementDefinitionTypeList.Link: TFhirElementDefinitionTypeList;
begin
  result := TFhirElementDefinitionTypeList(inherited Link);
end;

procedure TFhirElementDefinitionTypeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirElementDefinitionTypeList.SetItemByIndex(index: Integer; value: TFhirElementDefinitionType);
begin
  assert(value is TFhirElementDefinitionType);
  FhirElementDefinitionTypes[index] := value;
end;

procedure TFhirElementDefinitionTypeList.SetItemN(index: Integer; value: TFhirElementDefinitionType);
begin
  assert(value is TFhirElementDefinitionType);
  ObjectByIndex[index] := value;
end;

{ TFhirElementDefinitionExample }

constructor TFhirElementDefinitionExample.Create;
begin
  inherited;
end;

destructor TFhirElementDefinitionExample.Destroy;
begin
  FLabel_.free;
  FValue.free;
  inherited;
end;

procedure TFhirElementDefinitionExample.Assign(oSource : TFslObject);
begin
  inherited;
  label_Element := TFhirElementDefinitionExample(oSource).label_Element.Clone;
  value := TFhirElementDefinitionExample(oSource).value.Clone;
end;

procedure TFhirElementDefinitionExample.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'label') Then
     list.add(self.link, 'label', FLabel_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirElementDefinitionExample.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'label', 'string', false, TFhirString, FLabel_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage', false, TFhirType, FValue.Link));{2}
end;

function TFhirElementDefinitionExample.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'label') then
  begin
    Label_Element := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirElementDefinitionExample.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirElementDefinitionExample.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'label') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirElementDefinitionExample.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'label') then result := 'string'
  else if (propName = 'value[x]') then result := 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirElementDefinitionExample.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'label') then Label_Element := nil
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then ValueElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirElementDefinitionExample.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'label') then Label_Element := asString(new){5b}
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then ValueElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirElementDefinitionExample.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirElementDefinitionExample.fhirType : string;
begin
  result := 'example';
end;

function TFhirElementDefinitionExample.Link : TFhirElementDefinitionExample;
begin
  result := TFhirElementDefinitionExample(inherited Link);
end;

function TFhirElementDefinitionExample.Clone : TFhirElementDefinitionExample;
begin
  result := TFhirElementDefinitionExample(inherited Clone);
end;

function TFhirElementDefinitionExample.equals(other : TObject) : boolean; 
var
  o : TFhirElementDefinitionExample;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirElementDefinitionExample)) then
    result := false
  else
  begin
    o := TFhirElementDefinitionExample(other);
    result := compareDeep(label_Element, o.label_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirElementDefinitionExample.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLabel_) and isEmptyProp(FValue);
end;

procedure TFhirElementDefinitionExample.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('label');
  fields.add('value[x]');
end;

{ TFhirElementDefinitionExample }

Procedure TFhirElementDefinitionExample.SetLabel_(value : TFhirString);
begin
  FLabel_.free;
  FLabel_ := value;
end;

Function TFhirElementDefinitionExample.GetLabel_ST : String;
begin
  if FLabel_ = nil then
    result := ''
  else
    result := FLabel_.value;
end;

Procedure TFhirElementDefinitionExample.SetLabel_ST(value : String);
begin
  if value <> '' then
  begin
    if FLabel_ = nil then
      FLabel_ := TFhirString.create;
    FLabel_.value := value
  end
  else if FLabel_ <> nil then
    FLabel_.value := '';
end;

Procedure TFhirElementDefinitionExample.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

function TFhirElementDefinitionExample.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLabel_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirElementDefinitionExampleListEnumerator }

Constructor TFhirElementDefinitionExampleListEnumerator.Create(list : TFhirElementDefinitionExampleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirElementDefinitionExampleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirElementDefinitionExampleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirElementDefinitionExampleListEnumerator.GetCurrent : TFhirElementDefinitionExample;
begin
  Result := FList[FIndex];
end;

function TFhirElementDefinitionExampleListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirElementDefinitionExampleList }
procedure TFhirElementDefinitionExampleList.AddItem(value: TFhirElementDefinitionExample);
begin
  assert(value.ClassName = 'TFhirElementDefinitionExample', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirElementDefinitionExample');
  add(value);
end;

function TFhirElementDefinitionExampleList.Append: TFhirElementDefinitionExample;
begin
  result := TFhirElementDefinitionExample.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirElementDefinitionExampleList.ClearItems;
begin
  Clear;
end;

function TFhirElementDefinitionExampleList.GetEnumerator : TFhirElementDefinitionExampleListEnumerator;
begin
  result := TFhirElementDefinitionExampleListEnumerator.Create(self.link);
end;

function TFhirElementDefinitionExampleList.Clone: TFhirElementDefinitionExampleList;
begin
  result := TFhirElementDefinitionExampleList(inherited Clone);
end;

function TFhirElementDefinitionExampleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirElementDefinitionExampleList.GetItemN(index: Integer): TFhirElementDefinitionExample;
begin
  result := TFhirElementDefinitionExample(ObjectByIndex[index]);
end;

function TFhirElementDefinitionExampleList.ItemClass: TFslObjectClass;
begin
  result := TFhirElementDefinitionExample;
end;
function TFhirElementDefinitionExampleList.IndexOf(value: TFhirElementDefinitionExample): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirElementDefinitionExampleList.Insert(index: Integer): TFhirElementDefinitionExample;
begin
  result := TFhirElementDefinitionExample.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirElementDefinitionExampleList.InsertItem(index: Integer; value: TFhirElementDefinitionExample);
begin
  assert(value is TFhirElementDefinitionExample);
  Inherited Insert(index, value);
end;

function TFhirElementDefinitionExampleList.Item(index: Integer): TFhirElementDefinitionExample;
begin
  result := TFhirElementDefinitionExample(ObjectByIndex[index]);
end;

function TFhirElementDefinitionExampleList.Link: TFhirElementDefinitionExampleList;
begin
  result := TFhirElementDefinitionExampleList(inherited Link);
end;

procedure TFhirElementDefinitionExampleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirElementDefinitionExampleList.SetItemByIndex(index: Integer; value: TFhirElementDefinitionExample);
begin
  assert(value is TFhirElementDefinitionExample);
  FhirElementDefinitionExamples[index] := value;
end;

procedure TFhirElementDefinitionExampleList.SetItemN(index: Integer; value: TFhirElementDefinitionExample);
begin
  assert(value is TFhirElementDefinitionExample);
  ObjectByIndex[index] := value;
end;

{ TFhirElementDefinitionConstraint }

constructor TFhirElementDefinitionConstraint.Create;
begin
  inherited;
end;

destructor TFhirElementDefinitionConstraint.Destroy;
begin
  FKey.free;
  FRequirements.free;
  FSeverity.free;
  FHuman.free;
  FExpression.free;
  FXpath.free;
  FSource.free;
  inherited;
end;

procedure TFhirElementDefinitionConstraint.Assign(oSource : TFslObject);
begin
  inherited;
  keyElement := TFhirElementDefinitionConstraint(oSource).keyElement.Clone;
  requirementsElement := TFhirElementDefinitionConstraint(oSource).requirementsElement.Clone;
  FSeverity := TFhirElementDefinitionConstraint(oSource).FSeverity.Link;
  humanElement := TFhirElementDefinitionConstraint(oSource).humanElement.Clone;
  expressionElement := TFhirElementDefinitionConstraint(oSource).expressionElement.Clone;
  xpathElement := TFhirElementDefinitionConstraint(oSource).xpathElement.Clone;
  sourceElement := TFhirElementDefinitionConstraint(oSource).sourceElement.Clone;
end;

procedure TFhirElementDefinitionConstraint.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'key') Then
     list.add(self.link, 'key', FKey.Link);
  if (child_name = 'requirements') Then
     list.add(self.link, 'requirements', FRequirements.Link);
  if (child_name = 'severity') Then
     list.add(self.link, 'severity', FSeverity.Link);
  if (child_name = 'human') Then
     list.add(self.link, 'human', FHuman.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
  if (child_name = 'xpath') Then
     list.add(self.link, 'xpath', FXpath.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
end;

procedure TFhirElementDefinitionConstraint.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'key', 'id', false, TFhirId, FKey.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requirements', 'string', false, TFhirString, FRequirements.Link));{2}
  oList.add(TFHIRProperty.create(self, 'severity', 'code', false, TFHIREnum, FSeverity.Link));{1}
  oList.add(TFHIRProperty.create(self, 'human', 'string', false, TFhirString, FHuman.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expression', 'string', false, TFhirString, FExpression.Link));{2}
  oList.add(TFHIRProperty.create(self, 'xpath', 'string', false, TFhirString, FXpath.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'canonical', false, TFhirCanonical, FSource.Link));{2}
end;

function TFhirElementDefinitionConstraint.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'key') then
  begin
    KeyElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requirements') then
  begin
    RequirementsElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'severity') then
  begin
    SeverityElement := asEnum(SYSTEMS_TFhirConstraintSeverityEnum, CODES_TFhirConstraintSeverityEnum, propValue);
    result := propValue
  end
  else if (propName = 'human') then
  begin
    HumanElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    ExpressionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'xpath') then
  begin
    XpathElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceElement := asCanonical(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirElementDefinitionConstraint.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirElementDefinitionConstraint.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'key') then result := TFhirId.create() {5b}
  else if (propName = 'requirements') then result := TFhirString.create() {5b}
  else if (propName = 'human') then result := TFhirString.create() {5b}
  else if (propName = 'expression') then result := TFhirString.create() {5b}
  else if (propName = 'xpath') then result := TFhirString.create() {5b}
  else if (propName = 'source') then result := TFhirCanonical.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirElementDefinitionConstraint.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'key') then result := 'id'
  else if (propName = 'requirements') then result := 'string'
  else if (propName = 'severity') then result := 'code'
  else if (propName = 'human') then result := 'string'
  else if (propName = 'expression') then result := 'string'
  else if (propName = 'xpath') then result := 'string'
  else if (propName = 'source') then result := 'canonical'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirElementDefinitionConstraint.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'key') then KeyElement := nil
  else if (propName = 'requirements') then RequirementsElement := nil
  else if (propName = 'severity') then SeverityElement := nil
  else if (propName = 'human') then HumanElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else if (propName = 'xpath') then XpathElement := nil
  else if (propName = 'source') then SourceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirElementDefinitionConstraint.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'key') then KeyElement := asId(new){5b}
  else if (propName = 'requirements') then RequirementsElement := asString(new){5b}
  else if (propName = 'severity') then SeverityElement := asEnum(SYSTEMS_TFhirConstraintSeverityEnum, CODES_TFhirConstraintSeverityEnum, new){4}
  else if (propName = 'human') then HumanElement := asString(new){5b}
  else if (propName = 'expression') then ExpressionElement := asString(new){5b}
  else if (propName = 'xpath') then XpathElement := asString(new){5b}
  else if (propName = 'source') then SourceElement := asCanonical(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirElementDefinitionConstraint.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirElementDefinitionConstraint.fhirType : string;
begin
  result := 'constraint';
end;

function TFhirElementDefinitionConstraint.Link : TFhirElementDefinitionConstraint;
begin
  result := TFhirElementDefinitionConstraint(inherited Link);
end;

function TFhirElementDefinitionConstraint.Clone : TFhirElementDefinitionConstraint;
begin
  result := TFhirElementDefinitionConstraint(inherited Clone);
end;

function TFhirElementDefinitionConstraint.equals(other : TObject) : boolean; 
var
  o : TFhirElementDefinitionConstraint;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirElementDefinitionConstraint)) then
    result := false
  else
  begin
    o := TFhirElementDefinitionConstraint(other);
    result := compareDeep(keyElement, o.keyElement, true) and compareDeep(requirementsElement, o.requirementsElement, true) and 
      compareDeep(severityElement, o.severityElement, true) and compareDeep(humanElement, o.humanElement, true) and 
      compareDeep(expressionElement, o.expressionElement, true) and compareDeep(xpathElement, o.xpathElement, true) and 
      compareDeep(sourceElement, o.sourceElement, true);
  end;
end;

function TFhirElementDefinitionConstraint.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FKey) and isEmptyProp(FRequirements) and isEmptyProp(FSeverity) and isEmptyProp(FHuman) and isEmptyProp(FExpression) and isEmptyProp(FXpath) and isEmptyProp(FSource);
end;

procedure TFhirElementDefinitionConstraint.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('key');
  fields.add('requirements');
  fields.add('severity');
  fields.add('human');
  fields.add('expression');
  fields.add('xpath');
  fields.add('source');
end;

{ TFhirElementDefinitionConstraint }

Procedure TFhirElementDefinitionConstraint.SetKey(value : TFhirId);
begin
  FKey.free;
  FKey := value;
end;

Function TFhirElementDefinitionConstraint.GetKeyST : String;
begin
  if FKey = nil then
    result := ''
  else
    result := FKey.value;
end;

Procedure TFhirElementDefinitionConstraint.SetKeyST(value : String);
begin
  if value <> '' then
  begin
    if FKey = nil then
      FKey := TFhirId.create;
    FKey.value := value
  end
  else if FKey <> nil then
    FKey.value := '';
end;

Procedure TFhirElementDefinitionConstraint.SetRequirements(value : TFhirString);
begin
  FRequirements.free;
  FRequirements := value;
end;

Function TFhirElementDefinitionConstraint.GetRequirementsST : String;
begin
  if FRequirements = nil then
    result := ''
  else
    result := FRequirements.value;
end;

Procedure TFhirElementDefinitionConstraint.SetRequirementsST(value : String);
begin
  if value <> '' then
  begin
    if FRequirements = nil then
      FRequirements := TFhirString.create;
    FRequirements.value := value
  end
  else if FRequirements <> nil then
    FRequirements.value := '';
end;

Procedure TFhirElementDefinitionConstraint.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

Function TFhirElementDefinitionConstraint.GetSeverityST : TFhirConstraintSeverityEnum;
begin
  if FSeverity = nil then
    result := TFhirConstraintSeverityEnum(0)
  else
    result := TFhirConstraintSeverityEnum(StringArrayIndexOfSensitive(CODES_TFhirConstraintSeverityEnum, FSeverity.value));
end;

Procedure TFhirElementDefinitionConstraint.SetSeverityST(value : TFhirConstraintSeverityEnum);
begin
  if ord(value) = 0 then
    SeverityElement := nil
  else
    SeverityElement := TFhirEnum.create(SYSTEMS_TFhirConstraintSeverityEnum[value], CODES_TFhirConstraintSeverityEnum[value]);
end;

Procedure TFhirElementDefinitionConstraint.SetHuman(value : TFhirString);
begin
  FHuman.free;
  FHuman := value;
end;

Function TFhirElementDefinitionConstraint.GetHumanST : String;
begin
  if FHuman = nil then
    result := ''
  else
    result := FHuman.value;
end;

Procedure TFhirElementDefinitionConstraint.SetHumanST(value : String);
begin
  if value <> '' then
  begin
    if FHuman = nil then
      FHuman := TFhirString.create;
    FHuman.value := value
  end
  else if FHuman <> nil then
    FHuman.value := '';
end;

Procedure TFhirElementDefinitionConstraint.SetExpression(value : TFhirString);
begin
  FExpression.free;
  FExpression := value;
end;

Function TFhirElementDefinitionConstraint.GetExpressionST : String;
begin
  if FExpression = nil then
    result := ''
  else
    result := FExpression.value;
end;

Procedure TFhirElementDefinitionConstraint.SetExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FExpression = nil then
      FExpression := TFhirString.create;
    FExpression.value := value
  end
  else if FExpression <> nil then
    FExpression.value := '';
end;

Procedure TFhirElementDefinitionConstraint.SetXpath(value : TFhirString);
begin
  FXpath.free;
  FXpath := value;
end;

Function TFhirElementDefinitionConstraint.GetXpathST : String;
begin
  if FXpath = nil then
    result := ''
  else
    result := FXpath.value;
end;

Procedure TFhirElementDefinitionConstraint.SetXpathST(value : String);
begin
  if value <> '' then
  begin
    if FXpath = nil then
      FXpath := TFhirString.create;
    FXpath.value := value
  end
  else if FXpath <> nil then
    FXpath.value := '';
end;

Procedure TFhirElementDefinitionConstraint.SetSource(value : TFhirCanonical);
begin
  FSource.free;
  FSource := value;
end;

Function TFhirElementDefinitionConstraint.GetSourceST : String;
begin
  if FSource = nil then
    result := ''
  else
    result := FSource.value;
end;

Procedure TFhirElementDefinitionConstraint.SetSourceST(value : String);
begin
  if value <> '' then
  begin
    if FSource = nil then
      FSource := TFhirCanonical.create;
    FSource.value := value
  end
  else if FSource <> nil then
    FSource.value := '';
end;

function TFhirElementDefinitionConstraint.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FKey.sizeInBytes);
  inc(result, FRequirements.sizeInBytes);
  inc(result, FSeverity.sizeInBytes);
  inc(result, FHuman.sizeInBytes);
  inc(result, FExpression.sizeInBytes);
  inc(result, FXpath.sizeInBytes);
  inc(result, FSource.sizeInBytes);
end;

{ TFhirElementDefinitionConstraintListEnumerator }

Constructor TFhirElementDefinitionConstraintListEnumerator.Create(list : TFhirElementDefinitionConstraintList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirElementDefinitionConstraintListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirElementDefinitionConstraintListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirElementDefinitionConstraintListEnumerator.GetCurrent : TFhirElementDefinitionConstraint;
begin
  Result := FList[FIndex];
end;

function TFhirElementDefinitionConstraintListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirElementDefinitionConstraintList }
procedure TFhirElementDefinitionConstraintList.AddItem(value: TFhirElementDefinitionConstraint);
begin
  assert(value.ClassName = 'TFhirElementDefinitionConstraint', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirElementDefinitionConstraint');
  add(value);
end;

function TFhirElementDefinitionConstraintList.Append: TFhirElementDefinitionConstraint;
begin
  result := TFhirElementDefinitionConstraint.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirElementDefinitionConstraintList.ClearItems;
begin
  Clear;
end;

function TFhirElementDefinitionConstraintList.GetEnumerator : TFhirElementDefinitionConstraintListEnumerator;
begin
  result := TFhirElementDefinitionConstraintListEnumerator.Create(self.link);
end;

function TFhirElementDefinitionConstraintList.Clone: TFhirElementDefinitionConstraintList;
begin
  result := TFhirElementDefinitionConstraintList(inherited Clone);
end;

function TFhirElementDefinitionConstraintList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirElementDefinitionConstraintList.GetItemN(index: Integer): TFhirElementDefinitionConstraint;
begin
  result := TFhirElementDefinitionConstraint(ObjectByIndex[index]);
end;

function TFhirElementDefinitionConstraintList.ItemClass: TFslObjectClass;
begin
  result := TFhirElementDefinitionConstraint;
end;
function TFhirElementDefinitionConstraintList.IndexOf(value: TFhirElementDefinitionConstraint): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirElementDefinitionConstraintList.Insert(index: Integer): TFhirElementDefinitionConstraint;
begin
  result := TFhirElementDefinitionConstraint.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirElementDefinitionConstraintList.InsertItem(index: Integer; value: TFhirElementDefinitionConstraint);
begin
  assert(value is TFhirElementDefinitionConstraint);
  Inherited Insert(index, value);
end;

function TFhirElementDefinitionConstraintList.Item(index: Integer): TFhirElementDefinitionConstraint;
begin
  result := TFhirElementDefinitionConstraint(ObjectByIndex[index]);
end;

function TFhirElementDefinitionConstraintList.Link: TFhirElementDefinitionConstraintList;
begin
  result := TFhirElementDefinitionConstraintList(inherited Link);
end;

procedure TFhirElementDefinitionConstraintList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirElementDefinitionConstraintList.SetItemByIndex(index: Integer; value: TFhirElementDefinitionConstraint);
begin
  assert(value is TFhirElementDefinitionConstraint);
  FhirElementDefinitionConstraints[index] := value;
end;

procedure TFhirElementDefinitionConstraintList.SetItemN(index: Integer; value: TFhirElementDefinitionConstraint);
begin
  assert(value is TFhirElementDefinitionConstraint);
  ObjectByIndex[index] := value;
end;

{ TFhirElementDefinitionBinding }

constructor TFhirElementDefinitionBinding.Create;
begin
  inherited;
end;

destructor TFhirElementDefinitionBinding.Destroy;
begin
  FStrength.free;
  FDescription.free;
  FValueSet.free;
  inherited;
end;

procedure TFhirElementDefinitionBinding.Assign(oSource : TFslObject);
begin
  inherited;
  FStrength := TFhirElementDefinitionBinding(oSource).FStrength.Link;
  descriptionElement := TFhirElementDefinitionBinding(oSource).descriptionElement.Clone;
  valueSetElement := TFhirElementDefinitionBinding(oSource).valueSetElement.Clone;
end;

procedure TFhirElementDefinitionBinding.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'strength') Then
     list.add(self.link, 'strength', FStrength.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'valueSet') Then
     list.add(self.link, 'valueSet', FValueSet.Link);
end;

procedure TFhirElementDefinitionBinding.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'strength', 'code', false, TFHIREnum, FStrength.Link));{1}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'valueSet', 'canonical', false, TFhirCanonical, FValueSet.Link));{2}
end;

function TFhirElementDefinitionBinding.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'strength') then
  begin
    StrengthElement := asEnum(SYSTEMS_TFhirBindingStrengthEnum, CODES_TFhirBindingStrengthEnum, propValue);
    result := propValue
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'valueSet') then
  begin
    ValueSetElement := asCanonical(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirElementDefinitionBinding.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirElementDefinitionBinding.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'valueSet') then result := TFhirCanonical.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirElementDefinitionBinding.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'strength') then result := 'code'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'valueSet') then result := 'canonical'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirElementDefinitionBinding.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'strength') then StrengthElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'valueSet') then ValueSetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirElementDefinitionBinding.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'strength') then StrengthElement := asEnum(SYSTEMS_TFhirBindingStrengthEnum, CODES_TFhirBindingStrengthEnum, new){4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'valueSet') then ValueSetElement := asCanonical(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirElementDefinitionBinding.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirElementDefinitionBinding.fhirType : string;
begin
  result := 'binding';
end;

function TFhirElementDefinitionBinding.Link : TFhirElementDefinitionBinding;
begin
  result := TFhirElementDefinitionBinding(inherited Link);
end;

function TFhirElementDefinitionBinding.Clone : TFhirElementDefinitionBinding;
begin
  result := TFhirElementDefinitionBinding(inherited Clone);
end;

function TFhirElementDefinitionBinding.equals(other : TObject) : boolean; 
var
  o : TFhirElementDefinitionBinding;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirElementDefinitionBinding)) then
    result := false
  else
  begin
    o := TFhirElementDefinitionBinding(other);
    result := compareDeep(strengthElement, o.strengthElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(valueSetElement, o.valueSetElement, true);
  end;
end;

function TFhirElementDefinitionBinding.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStrength) and isEmptyProp(FDescription) and isEmptyProp(FValueSet);
end;

procedure TFhirElementDefinitionBinding.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('strength');
  fields.add('description');
  fields.add('valueSet');
end;

{ TFhirElementDefinitionBinding }

Procedure TFhirElementDefinitionBinding.SetStrength(value : TFhirEnum);
begin
  FStrength.free;
  FStrength := value;
end;

Function TFhirElementDefinitionBinding.GetStrengthST : TFhirBindingStrengthEnum;
begin
  if FStrength = nil then
    result := TFhirBindingStrengthEnum(0)
  else
    result := TFhirBindingStrengthEnum(StringArrayIndexOfSensitive(CODES_TFhirBindingStrengthEnum, FStrength.value));
end;

Procedure TFhirElementDefinitionBinding.SetStrengthST(value : TFhirBindingStrengthEnum);
begin
  if ord(value) = 0 then
    StrengthElement := nil
  else
    StrengthElement := TFhirEnum.create(SYSTEMS_TFhirBindingStrengthEnum[value], CODES_TFhirBindingStrengthEnum[value]);
end;

Procedure TFhirElementDefinitionBinding.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirElementDefinitionBinding.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirElementDefinitionBinding.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirElementDefinitionBinding.SetValueSet(value : TFhirCanonical);
begin
  FValueSet.free;
  FValueSet := value;
end;

Function TFhirElementDefinitionBinding.GetValueSetST : String;
begin
  if FValueSet = nil then
    result := ''
  else
    result := FValueSet.value;
end;

Procedure TFhirElementDefinitionBinding.SetValueSetST(value : String);
begin
  if value <> '' then
  begin
    if FValueSet = nil then
      FValueSet := TFhirCanonical.create;
    FValueSet.value := value
  end
  else if FValueSet <> nil then
    FValueSet.value := '';
end;

function TFhirElementDefinitionBinding.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStrength.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FValueSet.sizeInBytes);
end;

{ TFhirElementDefinitionBindingListEnumerator }

Constructor TFhirElementDefinitionBindingListEnumerator.Create(list : TFhirElementDefinitionBindingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirElementDefinitionBindingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirElementDefinitionBindingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirElementDefinitionBindingListEnumerator.GetCurrent : TFhirElementDefinitionBinding;
begin
  Result := FList[FIndex];
end;

function TFhirElementDefinitionBindingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirElementDefinitionBindingList }
procedure TFhirElementDefinitionBindingList.AddItem(value: TFhirElementDefinitionBinding);
begin
  assert(value.ClassName = 'TFhirElementDefinitionBinding', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirElementDefinitionBinding');
  add(value);
end;

function TFhirElementDefinitionBindingList.Append: TFhirElementDefinitionBinding;
begin
  result := TFhirElementDefinitionBinding.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirElementDefinitionBindingList.ClearItems;
begin
  Clear;
end;

function TFhirElementDefinitionBindingList.GetEnumerator : TFhirElementDefinitionBindingListEnumerator;
begin
  result := TFhirElementDefinitionBindingListEnumerator.Create(self.link);
end;

function TFhirElementDefinitionBindingList.Clone: TFhirElementDefinitionBindingList;
begin
  result := TFhirElementDefinitionBindingList(inherited Clone);
end;

function TFhirElementDefinitionBindingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirElementDefinitionBindingList.GetItemN(index: Integer): TFhirElementDefinitionBinding;
begin
  result := TFhirElementDefinitionBinding(ObjectByIndex[index]);
end;

function TFhirElementDefinitionBindingList.ItemClass: TFslObjectClass;
begin
  result := TFhirElementDefinitionBinding;
end;
function TFhirElementDefinitionBindingList.IndexOf(value: TFhirElementDefinitionBinding): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirElementDefinitionBindingList.Insert(index: Integer): TFhirElementDefinitionBinding;
begin
  result := TFhirElementDefinitionBinding.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirElementDefinitionBindingList.InsertItem(index: Integer; value: TFhirElementDefinitionBinding);
begin
  assert(value is TFhirElementDefinitionBinding);
  Inherited Insert(index, value);
end;

function TFhirElementDefinitionBindingList.Item(index: Integer): TFhirElementDefinitionBinding;
begin
  result := TFhirElementDefinitionBinding(ObjectByIndex[index]);
end;

function TFhirElementDefinitionBindingList.Link: TFhirElementDefinitionBindingList;
begin
  result := TFhirElementDefinitionBindingList(inherited Link);
end;

procedure TFhirElementDefinitionBindingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirElementDefinitionBindingList.SetItemByIndex(index: Integer; value: TFhirElementDefinitionBinding);
begin
  assert(value is TFhirElementDefinitionBinding);
  FhirElementDefinitionBindings[index] := value;
end;

procedure TFhirElementDefinitionBindingList.SetItemN(index: Integer; value: TFhirElementDefinitionBinding);
begin
  assert(value is TFhirElementDefinitionBinding);
  ObjectByIndex[index] := value;
end;

{ TFhirElementDefinitionMapping }

constructor TFhirElementDefinitionMapping.Create;
begin
  inherited;
end;

destructor TFhirElementDefinitionMapping.Destroy;
begin
  FIdentity.free;
  FLanguage.free;
  FMap.free;
  FComment.free;
  inherited;
end;

procedure TFhirElementDefinitionMapping.Assign(oSource : TFslObject);
begin
  inherited;
  identityElement := TFhirElementDefinitionMapping(oSource).identityElement.Clone;
  languageElement := TFhirElementDefinitionMapping(oSource).languageElement.Clone;
  mapElement := TFhirElementDefinitionMapping(oSource).mapElement.Clone;
  commentElement := TFhirElementDefinitionMapping(oSource).commentElement.Clone;
end;

procedure TFhirElementDefinitionMapping.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identity') Then
     list.add(self.link, 'identity', FIdentity.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'map') Then
     list.add(self.link, 'map', FMap.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirElementDefinitionMapping.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identity', 'id', false, TFhirId, FIdentity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'language', 'code', false, TFhirCode, FLanguage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'map', 'string', false, TFhirString, FMap.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
end;

function TFhirElementDefinitionMapping.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identity') then
  begin
    IdentityElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    LanguageElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'map') then
  begin
    MapElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirElementDefinitionMapping.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirElementDefinitionMapping.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identity') then result := TFhirId.create() {5b}
  else if (propName = 'language') then result := TFhirCode.create() {5b}
  else if (propName = 'map') then result := TFhirString.create() {5b}
  else if (propName = 'comment') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirElementDefinitionMapping.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identity') then result := 'id'
  else if (propName = 'language') then result := 'code'
  else if (propName = 'map') then result := 'string'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirElementDefinitionMapping.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identity') then IdentityElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else if (propName = 'map') then MapElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirElementDefinitionMapping.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identity') then IdentityElement := asId(new){5b}
  else if (propName = 'language') then LanguageElement := asCode(new){5b}
  else if (propName = 'map') then MapElement := asString(new){5b}
  else if (propName = 'comment') then CommentElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirElementDefinitionMapping.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirElementDefinitionMapping.fhirType : string;
begin
  result := 'mapping';
end;

function TFhirElementDefinitionMapping.Link : TFhirElementDefinitionMapping;
begin
  result := TFhirElementDefinitionMapping(inherited Link);
end;

function TFhirElementDefinitionMapping.Clone : TFhirElementDefinitionMapping;
begin
  result := TFhirElementDefinitionMapping(inherited Clone);
end;

function TFhirElementDefinitionMapping.equals(other : TObject) : boolean; 
var
  o : TFhirElementDefinitionMapping;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirElementDefinitionMapping)) then
    result := false
  else
  begin
    o := TFhirElementDefinitionMapping(other);
    result := compareDeep(identityElement, o.identityElement, true) and compareDeep(languageElement, o.languageElement, true) and 
      compareDeep(mapElement, o.mapElement, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirElementDefinitionMapping.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentity) and isEmptyProp(FLanguage) and isEmptyProp(FMap) and isEmptyProp(FComment);
end;

procedure TFhirElementDefinitionMapping.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('identity');
  fields.add('language');
  fields.add('map');
  fields.add('comment');
end;

{ TFhirElementDefinitionMapping }

Procedure TFhirElementDefinitionMapping.SetIdentity(value : TFhirId);
begin
  FIdentity.free;
  FIdentity := value;
end;

Function TFhirElementDefinitionMapping.GetIdentityST : String;
begin
  if FIdentity = nil then
    result := ''
  else
    result := FIdentity.value;
end;

Procedure TFhirElementDefinitionMapping.SetIdentityST(value : String);
begin
  if value <> '' then
  begin
    if FIdentity = nil then
      FIdentity := TFhirId.create;
    FIdentity.value := value
  end
  else if FIdentity <> nil then
    FIdentity.value := '';
end;

Procedure TFhirElementDefinitionMapping.SetLanguage(value : TFhirCode);
begin
  FLanguage.free;
  FLanguage := value;
end;

Function TFhirElementDefinitionMapping.GetLanguageST : String;
begin
  if FLanguage = nil then
    result := ''
  else
    result := FLanguage.value;
end;

Procedure TFhirElementDefinitionMapping.SetLanguageST(value : String);
begin
  if value <> '' then
  begin
    if FLanguage = nil then
      FLanguage := TFhirCode.create;
    FLanguage.value := value
  end
  else if FLanguage <> nil then
    FLanguage.value := '';
end;

Procedure TFhirElementDefinitionMapping.SetMap(value : TFhirString);
begin
  FMap.free;
  FMap := value;
end;

Function TFhirElementDefinitionMapping.GetMapST : String;
begin
  if FMap = nil then
    result := ''
  else
    result := FMap.value;
end;

Procedure TFhirElementDefinitionMapping.SetMapST(value : String);
begin
  if value <> '' then
  begin
    if FMap = nil then
      FMap := TFhirString.create;
    FMap.value := value
  end
  else if FMap <> nil then
    FMap.value := '';
end;

Procedure TFhirElementDefinitionMapping.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirElementDefinitionMapping.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirElementDefinitionMapping.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

function TFhirElementDefinitionMapping.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentity.sizeInBytes);
  inc(result, FLanguage.sizeInBytes);
  inc(result, FMap.sizeInBytes);
  inc(result, FComment.sizeInBytes);
end;

{ TFhirElementDefinitionMappingListEnumerator }

Constructor TFhirElementDefinitionMappingListEnumerator.Create(list : TFhirElementDefinitionMappingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirElementDefinitionMappingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirElementDefinitionMappingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirElementDefinitionMappingListEnumerator.GetCurrent : TFhirElementDefinitionMapping;
begin
  Result := FList[FIndex];
end;

function TFhirElementDefinitionMappingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirElementDefinitionMappingList }
procedure TFhirElementDefinitionMappingList.AddItem(value: TFhirElementDefinitionMapping);
begin
  assert(value.ClassName = 'TFhirElementDefinitionMapping', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirElementDefinitionMapping');
  add(value);
end;

function TFhirElementDefinitionMappingList.Append: TFhirElementDefinitionMapping;
begin
  result := TFhirElementDefinitionMapping.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirElementDefinitionMappingList.ClearItems;
begin
  Clear;
end;

function TFhirElementDefinitionMappingList.GetEnumerator : TFhirElementDefinitionMappingListEnumerator;
begin
  result := TFhirElementDefinitionMappingListEnumerator.Create(self.link);
end;

function TFhirElementDefinitionMappingList.Clone: TFhirElementDefinitionMappingList;
begin
  result := TFhirElementDefinitionMappingList(inherited Clone);
end;

function TFhirElementDefinitionMappingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirElementDefinitionMappingList.GetItemN(index: Integer): TFhirElementDefinitionMapping;
begin
  result := TFhirElementDefinitionMapping(ObjectByIndex[index]);
end;

function TFhirElementDefinitionMappingList.ItemClass: TFslObjectClass;
begin
  result := TFhirElementDefinitionMapping;
end;
function TFhirElementDefinitionMappingList.IndexOf(value: TFhirElementDefinitionMapping): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirElementDefinitionMappingList.Insert(index: Integer): TFhirElementDefinitionMapping;
begin
  result := TFhirElementDefinitionMapping.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirElementDefinitionMappingList.InsertItem(index: Integer; value: TFhirElementDefinitionMapping);
begin
  assert(value is TFhirElementDefinitionMapping);
  Inherited Insert(index, value);
end;

function TFhirElementDefinitionMappingList.Item(index: Integer): TFhirElementDefinitionMapping;
begin
  result := TFhirElementDefinitionMapping(ObjectByIndex[index]);
end;

function TFhirElementDefinitionMappingList.Link: TFhirElementDefinitionMappingList;
begin
  result := TFhirElementDefinitionMappingList(inherited Link);
end;

procedure TFhirElementDefinitionMappingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirElementDefinitionMappingList.SetItemByIndex(index: Integer; value: TFhirElementDefinitionMapping);
begin
  assert(value is TFhirElementDefinitionMapping);
  FhirElementDefinitionMappings[index] := value;
end;

procedure TFhirElementDefinitionMappingList.SetItemN(index: Integer; value: TFhirElementDefinitionMapping);
begin
  assert(value is TFhirElementDefinitionMapping);
  ObjectByIndex[index] := value;
end;

{ TFhirElementDefinition }

constructor TFhirElementDefinition.Create;
begin
  inherited;
end;

destructor TFhirElementDefinition.Destroy;
begin
  FPath.free;
  FRepresentation.Free;
  FSliceName.free;
  FSliceIsConstraining.free;
  FLabel_.free;
  FCodeList.Free;
  FSlicing.free;
  FShort.free;
  FDefinition.free;
  FComment.free;
  FRequirements.free;
  FAliasList.Free;
  FMin.free;
  FMax.free;
  FBase.free;
  FContentReference.free;
  FType_List.Free;
  FDefaultValue.free;
  FMeaningWhenMissing.free;
  FOrderMeaning.free;
  FFixed.free;
  FPattern.free;
  FExampleList.Free;
  FMinValue.free;
  FMaxValue.free;
  FMaxLength.free;
  FConditionList.Free;
  FConstraintList.Free;
  FMustSupport.free;
  FIsModifier.free;
  FIsModifierReason.free;
  FIsSummary.free;
  FBinding.free;
  FMappingList.Free;
  inherited;
end;

procedure TFhirElementDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  pathElement := TFhirElementDefinition(oSource).pathElement.Clone;
  if (TFhirElementDefinition(oSource).FRepresentation = nil) then
  begin
    FRepresentation.free;
    FRepresentation := nil;
  end
  else
  begin
    FRepresentation := TFHIREnumList.Create(SYSTEMS_TFhirPropertyRepresentationEnum, CODES_TFhirPropertyRepresentationEnum);
    FRepresentation.Assign(TFhirElementDefinition(oSource).FRepresentation);
  end;
  sliceNameElement := TFhirElementDefinition(oSource).sliceNameElement.Clone;
  sliceIsConstrainingElement := TFhirElementDefinition(oSource).sliceIsConstrainingElement.Clone;
  label_Element := TFhirElementDefinition(oSource).label_Element.Clone;
  if (TFhirElementDefinition(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodingList.Create;
    FCodeList.Assign(TFhirElementDefinition(oSource).FCodeList);
  end;
  slicing := TFhirElementDefinition(oSource).slicing.Clone;
  shortElement := TFhirElementDefinition(oSource).shortElement.Clone;
  definitionElement := TFhirElementDefinition(oSource).definitionElement.Clone;
  commentElement := TFhirElementDefinition(oSource).commentElement.Clone;
  requirementsElement := TFhirElementDefinition(oSource).requirementsElement.Clone;
  if (TFhirElementDefinition(oSource).FAliasList = nil) then
  begin
    FAliasList.free;
    FAliasList := nil;
  end
  else
  begin
    if FAliasList = nil then
      FAliasList := TFhirStringList.Create;
    FAliasList.Assign(TFhirElementDefinition(oSource).FAliasList);
  end;
  minElement := TFhirElementDefinition(oSource).minElement.Clone;
  maxElement := TFhirElementDefinition(oSource).maxElement.Clone;
  base := TFhirElementDefinition(oSource).base.Clone;
  contentReferenceElement := TFhirElementDefinition(oSource).contentReferenceElement.Clone;
  if (TFhirElementDefinition(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirElementDefinitionTypeList.Create;
    FType_List.Assign(TFhirElementDefinition(oSource).FType_List);
  end;
  defaultValue := TFhirElementDefinition(oSource).defaultValue.Clone;
  meaningWhenMissingElement := TFhirElementDefinition(oSource).meaningWhenMissingElement.Clone;
  orderMeaningElement := TFhirElementDefinition(oSource).orderMeaningElement.Clone;
  fixed := TFhirElementDefinition(oSource).fixed.Clone;
  pattern := TFhirElementDefinition(oSource).pattern.Clone;
  if (TFhirElementDefinition(oSource).FExampleList = nil) then
  begin
    FExampleList.free;
    FExampleList := nil;
  end
  else
  begin
    if FExampleList = nil then
      FExampleList := TFhirElementDefinitionExampleList.Create;
    FExampleList.Assign(TFhirElementDefinition(oSource).FExampleList);
  end;
  minValue := TFhirElementDefinition(oSource).minValue.Clone;
  maxValue := TFhirElementDefinition(oSource).maxValue.Clone;
  maxLengthElement := TFhirElementDefinition(oSource).maxLengthElement.Clone;
  if (TFhirElementDefinition(oSource).FConditionList = nil) then
  begin
    FConditionList.free;
    FConditionList := nil;
  end
  else
  begin
    if FConditionList = nil then
      FConditionList := TFhirIdList.Create;
    FConditionList.Assign(TFhirElementDefinition(oSource).FConditionList);
  end;
  if (TFhirElementDefinition(oSource).FConstraintList = nil) then
  begin
    FConstraintList.free;
    FConstraintList := nil;
  end
  else
  begin
    if FConstraintList = nil then
      FConstraintList := TFhirElementDefinitionConstraintList.Create;
    FConstraintList.Assign(TFhirElementDefinition(oSource).FConstraintList);
  end;
  mustSupportElement := TFhirElementDefinition(oSource).mustSupportElement.Clone;
  isModifierElement := TFhirElementDefinition(oSource).isModifierElement.Clone;
  isModifierReasonElement := TFhirElementDefinition(oSource).isModifierReasonElement.Clone;
  isSummaryElement := TFhirElementDefinition(oSource).isSummaryElement.Clone;
  binding := TFhirElementDefinition(oSource).binding.Clone;
  if (TFhirElementDefinition(oSource).FMappingList = nil) then
  begin
    FMappingList.free;
    FMappingList := nil;
  end
  else
  begin
    if FMappingList = nil then
      FMappingList := TFhirElementDefinitionMappingList.Create;
    FMappingList.Assign(TFhirElementDefinition(oSource).FMappingList);
  end;
end;

procedure TFhirElementDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
  if (child_name = 'representation') Then
     list.addAll(self, 'representation', FRepresentation);
  if (child_name = 'sliceName') Then
     list.add(self.link, 'sliceName', FSliceName.Link);
  if (child_name = 'sliceIsConstraining') Then
     list.add(self.link, 'sliceIsConstraining', FSliceIsConstraining.Link);
  if (child_name = 'label') Then
     list.add(self.link, 'label', FLabel_.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'slicing') Then
     list.add(self.link, 'slicing', FSlicing.Link);
  if (child_name = 'short') Then
     list.add(self.link, 'short', FShort.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'requirements') Then
     list.add(self.link, 'requirements', FRequirements.Link);
  if (child_name = 'alias') Then
    list.addAll(self, 'alias', FAliasList);
  if (child_name = 'min') Then
     list.add(self.link, 'min', FMin.Link);
  if (child_name = 'max') Then
     list.add(self.link, 'max', FMax.Link);
  if (child_name = 'base') Then
     list.add(self.link, 'base', FBase.Link);
  if (child_name = 'contentReference') Then
     list.add(self.link, 'contentReference', FContentReference.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'defaultValue[x]') or (child_name = 'defaultValue') Then
     list.add(self.link, 'defaultValue[x]', FDefaultValue.Link);
  if (child_name = 'meaningWhenMissing') Then
     list.add(self.link, 'meaningWhenMissing', FMeaningWhenMissing.Link);
  if (child_name = 'orderMeaning') Then
     list.add(self.link, 'orderMeaning', FOrderMeaning.Link);
  if (child_name = 'fixed[x]') or (child_name = 'fixed') Then
     list.add(self.link, 'fixed[x]', FFixed.Link);
  if (child_name = 'pattern[x]') or (child_name = 'pattern') Then
     list.add(self.link, 'pattern[x]', FPattern.Link);
  if (child_name = 'example') Then
    list.addAll(self, 'example', FExampleList);
  if (child_name = 'minValue[x]') or (child_name = 'minValue') Then
     list.add(self.link, 'minValue[x]', FMinValue.Link);
  if (child_name = 'maxValue[x]') or (child_name = 'maxValue') Then
     list.add(self.link, 'maxValue[x]', FMaxValue.Link);
  if (child_name = 'maxLength') Then
     list.add(self.link, 'maxLength', FMaxLength.Link);
  if (child_name = 'condition') Then
    list.addAll(self, 'condition', FConditionList);
  if (child_name = 'constraint') Then
    list.addAll(self, 'constraint', FConstraintList);
  if (child_name = 'mustSupport') Then
     list.add(self.link, 'mustSupport', FMustSupport.Link);
  if (child_name = 'isModifier') Then
     list.add(self.link, 'isModifier', FIsModifier.Link);
  if (child_name = 'isModifierReason') Then
     list.add(self.link, 'isModifierReason', FIsModifierReason.Link);
  if (child_name = 'isSummary') Then
     list.add(self.link, 'isSummary', FIsSummary.Link);
  if (child_name = 'binding') Then
     list.add(self.link, 'binding', FBinding.Link);
  if (child_name = 'mapping') Then
    list.addAll(self, 'mapping', FMappingList);
end;

procedure TFhirElementDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));{2}
  oList.add(TFHIRProperty.create(self, 'representation', 'code', true, TFHIREnum, FRepresentation.Link)){3};
  oList.add(TFHIRProperty.create(self, 'sliceName', 'string', false, TFhirString, FSliceName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sliceIsConstraining', 'boolean', false, TFhirBoolean, FSliceIsConstraining.Link));{2}
  oList.add(TFHIRProperty.create(self, 'label', 'string', false, TFhirString, FLabel_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', true, TFhirCoding, FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'slicing', '', false, TFhirElementDefinitionSlicing, FSlicing.Link));{2}
  oList.add(TFHIRProperty.create(self, 'short', 'string', false, TFhirString, FShort.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', 'markdown', false, TFhirMarkdown, FDefinition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comment', 'markdown', false, TFhirMarkdown, FComment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requirements', 'markdown', false, TFhirMarkdown, FRequirements.Link));{2}
  oList.add(TFHIRProperty.create(self, 'alias', 'string', true, TFhirString, FAliasList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'min', 'unsignedInt', false, TFhirUnsignedInt, FMin.Link));{2}
  oList.add(TFHIRProperty.create(self, 'max', 'string', false, TFhirString, FMax.Link));{2}
  oList.add(TFHIRProperty.create(self, 'base', '', false, TFhirElementDefinitionBase, FBase.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contentReference', 'uri', false, TFhirUri, FContentReference.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', '', true, TFhirElementDefinitionType, FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'defaultValue[x]', 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage', false, TFhirType, FDefaultValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'meaningWhenMissing', 'markdown', false, TFhirMarkdown, FMeaningWhenMissing.Link));{2}
  oList.add(TFHIRProperty.create(self, 'orderMeaning', 'string', false, TFhirString, FOrderMeaning.Link));{2}
  oList.add(TFHIRProperty.create(self, 'fixed[x]', 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage', false, TFhirType, FFixed.Link));{2}
  oList.add(TFHIRProperty.create(self, 'pattern[x]', 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage', false, TFhirType, FPattern.Link));{2}
  oList.add(TFHIRProperty.create(self, 'example', '', true, TFhirElementDefinitionExample, FExampleList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'minValue[x]', 'date|dateTime|instant|time|decimal|integer|positiveInt|unsignedInt|Quantity', false, TFhirType, FMinValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxValue[x]', 'date|dateTime|instant|time|decimal|integer|positiveInt|unsignedInt|Quantity', false, TFhirType, FMaxValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxLength', 'integer', false, TFhirInteger, FMaxLength.Link));{2}
  oList.add(TFHIRProperty.create(self, 'condition', 'id', true, TFhirId, FConditionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'constraint', '', true, TFhirElementDefinitionConstraint, FConstraintList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'mustSupport', 'boolean', false, TFhirBoolean, FMustSupport.Link));{2}
  oList.add(TFHIRProperty.create(self, 'isModifier', 'boolean', false, TFhirBoolean, FIsModifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'isModifierReason', 'string', false, TFhirString, FIsModifierReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'isSummary', 'boolean', false, TFhirBoolean, FIsSummary.Link));{2}
  oList.add(TFHIRProperty.create(self, 'binding', '', false, TFhirElementDefinitionBinding, FBinding.Link));{2}
  oList.add(TFHIRProperty.create(self, 'mapping', '', true, TFhirElementDefinitionMapping, FMappingList.Link)){3};
end;

function TFhirElementDefinition.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'path') then
  begin
    PathElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'representation') then
  begin
    RepresentationList.add(asEnum(SYSTEMS_TFhirPropertyRepresentationEnum, CODES_TFhirPropertyRepresentationEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'sliceName') then
  begin
    SliceNameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'sliceIsConstraining') then
  begin
    SliceIsConstrainingElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'label') then
  begin
    Label_Element := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'slicing') then
  begin
    Slicing := propValue as TFhirElementDefinitionSlicing{4b};
    result := propValue;
  end
  else if (propName = 'short') then
  begin
    ShortElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requirements') then
  begin
    RequirementsElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'alias') then
  begin
    AliasList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'min') then
  begin
    MinElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'max') then
  begin
    MaxElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'base') then
  begin
    Base := propValue as TFhirElementDefinitionBase{4b};
    result := propValue;
  end
  else if (propName = 'contentReference') then
  begin
    ContentReferenceElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirElementDefinitionType){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'defaultValue', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then
  begin
    DefaultValue := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'meaningWhenMissing') then
  begin
    MeaningWhenMissingElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'orderMeaning') then
  begin
    OrderMeaningElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'fixed', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then
  begin
    Fixed := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'pattern', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then
  begin
    Pattern := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'example') then
  begin
    ExampleList.add(propValue as TFhirElementDefinitionExample){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'minValue', ['Date', 'DateTime', 'Instant', 'Time', 'Decimal', 'Integer', 'PositiveInt', 'UnsignedInt', 'Quantity'])) then
  begin
    MinValue := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'maxValue', ['Date', 'DateTime', 'Instant', 'Time', 'Decimal', 'Integer', 'PositiveInt', 'UnsignedInt', 'Quantity'])) then
  begin
    MaxValue := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'maxLength') then
  begin
    MaxLengthElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionList.add(asId(propValue)){2};     result := propValue;

  end
  else if (propName = 'constraint') then
  begin
    ConstraintList.add(propValue as TFhirElementDefinitionConstraint){2a};
    result := propValue;
  end
  else if (propName = 'mustSupport') then
  begin
    MustSupportElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'isModifier') then
  begin
    IsModifierElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'isModifierReason') then
  begin
    IsModifierReasonElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'isSummary') then
  begin
    IsSummaryElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'binding') then
  begin
    Binding := propValue as TFhirElementDefinitionBinding{4b};
    result := propValue;
  end
  else if (propName = 'mapping') then
  begin
    MappingList.add(propValue as TFhirElementDefinitionMapping){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirElementDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'representation') then FRepresentation.insertItem(index, asEnum(SYSTEMS_TFhirPropertyRepresentationEnum, CODES_TFhirPropertyRepresentationEnum, propValue)) {1}
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'alias') then AliasList.insertItem(index, asString(propValue)){2}
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirElementDefinitionType){2a}
  else if (propName = 'example') then ExampleList.insertItem(index, propValue as TFhirElementDefinitionExample){2a}
  else if (propName = 'condition') then ConditionList.insertItem(index, asId(propValue)){2}
  else if (propName = 'constraint') then ConstraintList.insertItem(index, propValue as TFhirElementDefinitionConstraint){2a}
  else if (propName = 'mapping') then MappingList.insertItem(index, propValue as TFhirElementDefinitionMapping){2a}
  else inherited;
end;

function TFhirElementDefinition.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'path') then result := TFhirString.create() {5b}
  else if (propName = 'sliceName') then result := TFhirString.create() {5b}
  else if (propName = 'sliceIsConstraining') then result := TFhirBoolean.create() {5b}
  else if (propName = 'label') then result := TFhirString.create() {5b}
  else if (propName = 'code') then result := CodeList.new(){2}
  else if (propName = 'slicing') then result := TFhirElementDefinitionSlicing.create(){4b}
  else if (propName = 'short') then result := TFhirString.create() {5b}
  else if (propName = 'definition') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'comment') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'requirements') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'alias') then result := AliasList.new(){2}
  else if (propName = 'min') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'max') then result := TFhirString.create() {5b}
  else if (propName = 'base') then result := TFhirElementDefinitionBase.create(){4b}
  else if (propName = 'contentReference') then result := TFhirUri.create() {5b}
  else if (propName = 'type') then result := Type_List.new(){2}
  else if (isMatchingName(propName, 'defaultValue', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then raise EFHIRException.create('Cannot make property DefaultValue'){4x}
  else if (propName = 'meaningWhenMissing') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'orderMeaning') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'fixed', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then raise EFHIRException.create('Cannot make property Fixed'){4x}
  else if (isMatchingName(propName, 'pattern', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then raise EFHIRException.create('Cannot make property Pattern'){4x}
  else if (propName = 'example') then result := ExampleList.new(){2}
  else if (isMatchingName(propName, 'minValue', ['Date', 'DateTime', 'Instant', 'Time', 'Decimal', 'Integer', 'PositiveInt', 'UnsignedInt', 'Quantity'])) then raise EFHIRException.create('Cannot make property MinValue'){4x}
  else if (isMatchingName(propName, 'maxValue', ['Date', 'DateTime', 'Instant', 'Time', 'Decimal', 'Integer', 'PositiveInt', 'UnsignedInt', 'Quantity'])) then raise EFHIRException.create('Cannot make property MaxValue'){4x}
  else if (propName = 'maxLength') then result := TFhirInteger.create() {5b}
  else if (propName = 'condition') then result := ConditionList.new(){2}
  else if (propName = 'constraint') then result := ConstraintList.new(){2}
  else if (propName = 'mustSupport') then result := TFhirBoolean.create() {5b}
  else if (propName = 'isModifier') then result := TFhirBoolean.create() {5b}
  else if (propName = 'isModifierReason') then result := TFhirString.create() {5b}
  else if (propName = 'isSummary') then result := TFhirBoolean.create() {5b}
  else if (propName = 'binding') then result := TFhirElementDefinitionBinding.create(){4b}
  else if (propName = 'mapping') then result := MappingList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirElementDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'path') then result := 'string'
  else if (propName = 'representation') then result := 'code'
  else if (propName = 'sliceName') then result := 'string'
  else if (propName = 'sliceIsConstraining') then result := 'boolean'
  else if (propName = 'label') then result := 'string'
  else if (propName = 'code') then result := 'Coding'
  else if (propName = 'slicing') then result := ''
  else if (propName = 'short') then result := 'string'
  else if (propName = 'definition') then result := 'markdown'
  else if (propName = 'comment') then result := 'markdown'
  else if (propName = 'requirements') then result := 'markdown'
  else if (propName = 'alias') then result := 'string'
  else if (propName = 'min') then result := 'unsignedInt'
  else if (propName = 'max') then result := 'string'
  else if (propName = 'base') then result := ''
  else if (propName = 'contentReference') then result := 'uri'
  else if (propName = 'type') then result := ''
  else if (propName = 'defaultValue[x]') then result := 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage'
  else if (propName = 'meaningWhenMissing') then result := 'markdown'
  else if (propName = 'orderMeaning') then result := 'string'
  else if (propName = 'fixed[x]') then result := 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage'
  else if (propName = 'pattern[x]') then result := 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage'
  else if (propName = 'example') then result := ''
  else if (propName = 'minValue[x]') then result := 'date|dateTime|instant|time|decimal|integer|positiveInt|unsignedInt|Quantity'
  else if (propName = 'maxValue[x]') then result := 'date|dateTime|instant|time|decimal|integer|positiveInt|unsignedInt|Quantity'
  else if (propName = 'maxLength') then result := 'integer'
  else if (propName = 'condition') then result := 'id'
  else if (propName = 'constraint') then result := ''
  else if (propName = 'mustSupport') then result := 'boolean'
  else if (propName = 'isModifier') then result := 'boolean'
  else if (propName = 'isModifierReason') then result := 'string'
  else if (propName = 'isSummary') then result := 'boolean'
  else if (propName = 'binding') then result := ''
  else if (propName = 'mapping') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirElementDefinition.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'path') then PathElement := nil
  else if (propName = 'sliceName') then SliceNameElement := nil
  else if (propName = 'sliceIsConstraining') then SliceIsConstrainingElement := nil
  else if (propName = 'label') then Label_Element := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value) {2}
  else if (propName = 'slicing') then SlicingElement := nil
  else if (propName = 'short') then ShortElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else if (propName = 'requirements') then RequirementsElement := nil
  else if (propName = 'alias') then deletePropertyValue('alias', AliasList, value) {2}
  else if (propName = 'min') then MinElement := nil
  else if (propName = 'max') then MaxElement := nil
  else if (propName = 'base') then BaseElement := nil
  else if (propName = 'contentReference') then ContentReferenceElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (isMatchingName(propName, 'defaultValue', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then DefaultValueElement := nil{4x}
  else if (propName = 'meaningWhenMissing') then MeaningWhenMissingElement := nil
  else if (propName = 'orderMeaning') then OrderMeaningElement := nil
  else if (isMatchingName(propName, 'fixed', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then FixedElement := nil{4x}
  else if (isMatchingName(propName, 'pattern', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then PatternElement := nil{4x}
  else if (propName = 'example') then deletePropertyValue('example', ExampleList, value) {2}
  else if (isMatchingName(propName, 'minValue', ['Date', 'DateTime', 'Instant', 'Time', 'Decimal', 'Integer', 'PositiveInt', 'UnsignedInt', 'Quantity'])) then MinValueElement := nil{4x}
  else if (isMatchingName(propName, 'maxValue', ['Date', 'DateTime', 'Instant', 'Time', 'Decimal', 'Integer', 'PositiveInt', 'UnsignedInt', 'Quantity'])) then MaxValueElement := nil{4x}
  else if (propName = 'maxLength') then MaxLengthElement := nil
  else if (propName = 'condition') then deletePropertyValue('condition', ConditionList, value) {2}
  else if (propName = 'constraint') then deletePropertyValue('constraint', ConstraintList, value) {2}
  else if (propName = 'mustSupport') then MustSupportElement := nil
  else if (propName = 'isModifier') then IsModifierElement := nil
  else if (propName = 'isModifierReason') then IsModifierReasonElement := nil
  else if (propName = 'isSummary') then IsSummaryElement := nil
  else if (propName = 'binding') then BindingElement := nil
  else if (propName = 'mapping') then deletePropertyValue('mapping', MappingList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirElementDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'path') then PathElement := asString(new){5b}
  else if (propName = 'sliceName') then SliceNameElement := asString(new){5b}
  else if (propName = 'sliceIsConstraining') then SliceIsConstrainingElement := asBoolean(new){5b}
  else if (propName = 'label') then Label_Element := asString(new){5b}
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {2}
  else if (propName = 'slicing') then SlicingElement := new as TFhirElementDefinitionSlicing{4}
  else if (propName = 'short') then ShortElement := asString(new){5b}
  else if (propName = 'definition') then DefinitionElement := asMarkdown(new){5b}
  else if (propName = 'comment') then CommentElement := asMarkdown(new){5b}
  else if (propName = 'requirements') then RequirementsElement := asMarkdown(new){5b}
  else if (propName = 'alias') then replacePropertyValue('alias', AliasList, existing, new) {2}
  else if (propName = 'min') then MinElement := asUnsignedInt(new){5b}
  else if (propName = 'max') then MaxElement := asString(new){5b}
  else if (propName = 'base') then BaseElement := new as TFhirElementDefinitionBase{4}
  else if (propName = 'contentReference') then ContentReferenceElement := asUri(new){5b}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (isMatchingName(propName, 'defaultValue', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then DefaultValueElement := new as TFhirType{4x}
  else if (propName = 'meaningWhenMissing') then MeaningWhenMissingElement := asMarkdown(new){5b}
  else if (propName = 'orderMeaning') then OrderMeaningElement := asString(new){5b}
  else if (isMatchingName(propName, 'fixed', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then FixedElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'pattern', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage'])) then PatternElement := new as TFhirType{4x}
  else if (propName = 'example') then replacePropertyValue('example', ExampleList, existing, new) {2}
  else if (isMatchingName(propName, 'minValue', ['Date', 'DateTime', 'Instant', 'Time', 'Decimal', 'Integer', 'PositiveInt', 'UnsignedInt', 'Quantity'])) then MinValueElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'maxValue', ['Date', 'DateTime', 'Instant', 'Time', 'Decimal', 'Integer', 'PositiveInt', 'UnsignedInt', 'Quantity'])) then MaxValueElement := new as TFhirType{4x}
  else if (propName = 'maxLength') then MaxLengthElement := asInteger(new){5b}
  else if (propName = 'condition') then replacePropertyValue('condition', ConditionList, existing, new) {2}
  else if (propName = 'constraint') then replacePropertyValue('constraint', ConstraintList, existing, new) {2}
  else if (propName = 'mustSupport') then MustSupportElement := asBoolean(new){5b}
  else if (propName = 'isModifier') then IsModifierElement := asBoolean(new){5b}
  else if (propName = 'isModifierReason') then IsModifierReasonElement := asString(new){5b}
  else if (propName = 'isSummary') then IsSummaryElement := asBoolean(new){5b}
  else if (propName = 'binding') then BindingElement := new as TFhirElementDefinitionBinding{4}
  else if (propName = 'mapping') then replacePropertyValue('mapping', MappingList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirElementDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'representation') then FRepresentation.move(source, destination) {1}
  else if (propName = 'code') then CodeList.move(source, destination){2a}
  else if (propName = 'alias') then AliasList.move(source, destination){2}
  else if (propName = 'type') then Type_List.move(source, destination){2a}
  else if (propName = 'example') then ExampleList.move(source, destination){2a}
  else if (propName = 'condition') then ConditionList.move(source, destination){2}
  else if (propName = 'constraint') then ConstraintList.move(source, destination){2a}
  else if (propName = 'mapping') then MappingList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirElementDefinition.fhirType : string;
begin
  result := 'ElementDefinition';
end;

function TFhirElementDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPath) and isEmptyProp(FRepresentation) and isEmptyProp(FSliceName) and isEmptyProp(FSliceIsConstraining) and isEmptyProp(FLabel_) and isEmptyProp(FcodeList) and isEmptyProp(FSlicing) and isEmptyProp(FShort) and isEmptyProp(FDefinition) and isEmptyProp(FComment) and isEmptyProp(FRequirements) and isEmptyProp(FaliasList) and isEmptyProp(FMin) and isEmptyProp(FMax) and isEmptyProp(FBase) and isEmptyProp(FContentReference) and isEmptyProp(Ftype_List) and isEmptyProp(FDefaultValue) and isEmptyProp(FMeaningWhenMissing) and isEmptyProp(FOrderMeaning) and isEmptyProp(FFixed) and isEmptyProp(FPattern) and isEmptyProp(FexampleList) and isEmptyProp(FMinValue) and isEmptyProp(FMaxValue) and isEmptyProp(FMaxLength) and isEmptyProp(FconditionList) and isEmptyProp(FconstraintList) and isEmptyProp(FMustSupport) and isEmptyProp(FIsModifier) and isEmptyProp(FIsModifierReason) and isEmptyProp(FIsSummary) and isEmptyProp(FBinding) and isEmptyProp(FmappingList);
end;

function TFhirElementDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirElementDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirElementDefinition)) then
    result := false
  else
  begin
    o := TFhirElementDefinition(other);
    result := compareDeep(pathElement, o.pathElement, true) and compareDeep(representationList, o.representationList, true) and 
      compareDeep(sliceNameElement, o.sliceNameElement, true) and compareDeep(sliceIsConstrainingElement, o.sliceIsConstrainingElement, true) and 
      compareDeep(label_Element, o.label_Element, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(slicingElement, o.slicingElement, true) and compareDeep(shortElement, o.shortElement, true) and 
      compareDeep(definitionElement, o.definitionElement, true) and compareDeep(commentElement, o.commentElement, true) and 
      compareDeep(requirementsElement, o.requirementsElement, true) and compareDeep(aliasList, o.aliasList, true) and 
      compareDeep(minElement, o.minElement, true) and compareDeep(maxElement, o.maxElement, true) and 
      compareDeep(baseElement, o.baseElement, true) and compareDeep(contentReferenceElement, o.contentReferenceElement, true) and 
      compareDeep(type_List, o.type_List, true) and compareDeep(defaultValueElement, o.defaultValueElement, true) and 
      compareDeep(meaningWhenMissingElement, o.meaningWhenMissingElement, true) and 
      compareDeep(orderMeaningElement, o.orderMeaningElement, true) and compareDeep(fixedElement, o.fixedElement, true) and 
      compareDeep(patternElement, o.patternElement, true) and compareDeep(exampleList, o.exampleList, true) and 
      compareDeep(minValueElement, o.minValueElement, true) and compareDeep(maxValueElement, o.maxValueElement, true) and 
      compareDeep(maxLengthElement, o.maxLengthElement, true) and compareDeep(conditionList, o.conditionList, true) and 
      compareDeep(constraintList, o.constraintList, true) and compareDeep(mustSupportElement, o.mustSupportElement, true) and 
      compareDeep(isModifierElement, o.isModifierElement, true) and compareDeep(isModifierReasonElement, o.isModifierReasonElement, true) and 
      compareDeep(isSummaryElement, o.isSummaryElement, true) and compareDeep(bindingElement, o.bindingElement, true) and 
      compareDeep(mappingList, o.mappingList, true);
  end;
end;

function TFhirElementDefinition.Link : TFhirElementDefinition;
begin
  result := TFhirElementDefinition(inherited Link);
end;

function TFhirElementDefinition.Clone : TFhirElementDefinition;
begin
  result := TFhirElementDefinition(inherited Clone);
end;

procedure TFhirElementDefinition.listFieldsInOrder(fields : TStringList);
begin
  listBackboneTypeFieldsInOrder(fields);
  fields.add('path');
  fields.add('representation');
  fields.add('sliceName');
  fields.add('sliceIsConstraining');
  fields.add('label');
  fields.add('code');
  fields.add('slicing');
  fields.add('short');
  fields.add('definition');
  fields.add('comment');
  fields.add('requirements');
  fields.add('alias');
  fields.add('min');
  fields.add('max');
  fields.add('base');
  fields.add('contentReference');
  fields.add('type');
  fields.add('defaultValue[x]');
  fields.add('meaningWhenMissing');
  fields.add('orderMeaning');
  fields.add('fixed[x]');
  fields.add('pattern[x]');
  fields.add('example');
  fields.add('minValue[x]');
  fields.add('maxValue[x]');
  fields.add('maxLength');
  fields.add('condition');
  fields.add('constraint');
  fields.add('mustSupport');
  fields.add('isModifier');
  fields.add('isModifierReason');
  fields.add('isSummary');
  fields.add('binding');
  fields.add('mapping');
end;

{ TFhirElementDefinition }

Procedure TFhirElementDefinition.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

Function TFhirElementDefinition.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

Procedure TFhirElementDefinition.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

Function TFhirElementDefinition.GetRepresentation : TFhirEnumList;
begin
  if FRepresentation = nil then
    FRepresentation := TFHIREnumList.Create(SYSTEMS_TFhirPropertyRepresentationEnum, CODES_TFhirPropertyRepresentationEnum);
  result := FRepresentation;
end;

Function TFhirElementDefinition.GetHasRepresentation : boolean;
begin
  result := (FRepresentation <> nil) and (FRepresentation.count > 0);
end;

Function TFhirElementDefinition.GetRepresentationST : TFhirPropertyRepresentationEnumList;
  var i : integer;
begin
  result := [];
  if Frepresentation <> nil then
    for i := 0 to Frepresentation.count - 1 do
      result := result + [TFhirPropertyRepresentationEnum(StringArrayIndexOfSensitive(CODES_TFhirPropertyRepresentationEnum, Frepresentation[i].value))];
end;

Procedure TFhirElementDefinition.SetRepresentationST(value : TFhirPropertyRepresentationEnumList);
var a : TFhirPropertyRepresentationEnum;
begin
  if Frepresentation = nil then
    Frepresentation := TFhirEnumList.create(SYSTEMS_TFhirPropertyRepresentationEnum, CODES_TFhirPropertyRepresentationEnum);
  Frepresentation.clear;
  for a := low(TFhirPropertyRepresentationEnum) to high(TFhirPropertyRepresentationEnum) do
    if a in value then
      begin
         if Frepresentation = nil then
           Frepresentation := TFhirEnumList.create(SYSTEMS_TFhirPropertyRepresentationEnum, CODES_TFhirPropertyRepresentationEnum);
         Frepresentation.add(TFhirEnum.create(SYSTEMS_TFhirPropertyRepresentationEnum[a], CODES_TFhirPropertyRepresentationEnum[a]));
      end;
end;

Procedure TFhirElementDefinition.SetSliceName(value : TFhirString);
begin
  FSliceName.free;
  FSliceName := value;
end;

Function TFhirElementDefinition.GetSliceNameST : String;
begin
  if FSliceName = nil then
    result := ''
  else
    result := FSliceName.value;
end;

Procedure TFhirElementDefinition.SetSliceNameST(value : String);
begin
  if value <> '' then
  begin
    if FSliceName = nil then
      FSliceName := TFhirString.create;
    FSliceName.value := value
  end
  else if FSliceName <> nil then
    FSliceName.value := '';
end;

Procedure TFhirElementDefinition.SetSliceIsConstraining(value : TFhirBoolean);
begin
  FSliceIsConstraining.free;
  FSliceIsConstraining := value;
end;

Function TFhirElementDefinition.GetSliceIsConstrainingST : Boolean;
begin
  if FSliceIsConstraining = nil then
    result := false
  else
    result := FSliceIsConstraining.value;
end;

Procedure TFhirElementDefinition.SetSliceIsConstrainingST(value : Boolean);
begin
  if FSliceIsConstraining = nil then
    FSliceIsConstraining := TFhirBoolean.create;
  FSliceIsConstraining.value := value
end;

Procedure TFhirElementDefinition.SetLabel_(value : TFhirString);
begin
  FLabel_.free;
  FLabel_ := value;
end;

Function TFhirElementDefinition.GetLabel_ST : String;
begin
  if FLabel_ = nil then
    result := ''
  else
    result := FLabel_.value;
end;

Procedure TFhirElementDefinition.SetLabel_ST(value : String);
begin
  if value <> '' then
  begin
    if FLabel_ = nil then
      FLabel_ := TFhirString.create;
    FLabel_.value := value
  end
  else if FLabel_ <> nil then
    FLabel_.value := '';
end;

Function TFhirElementDefinition.GetCodeList : TFhirCodingList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodingList.Create;
  result := FCodeList;
end;

Function TFhirElementDefinition.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

Procedure TFhirElementDefinition.SetSlicing(value : TFhirElementDefinitionSlicing);
begin
  FSlicing.free;
  FSlicing := value;
end;

Procedure TFhirElementDefinition.SetShort(value : TFhirString);
begin
  FShort.free;
  FShort := value;
end;

Function TFhirElementDefinition.GetShortST : String;
begin
  if FShort = nil then
    result := ''
  else
    result := FShort.value;
end;

Procedure TFhirElementDefinition.SetShortST(value : String);
begin
  if value <> '' then
  begin
    if FShort = nil then
      FShort := TFhirString.create;
    FShort.value := value
  end
  else if FShort <> nil then
    FShort.value := '';
end;

Procedure TFhirElementDefinition.SetDefinition(value : TFhirMarkdown);
begin
  FDefinition.free;
  FDefinition := value;
end;

Function TFhirElementDefinition.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

Procedure TFhirElementDefinition.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirMarkdown.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

Procedure TFhirElementDefinition.SetComment(value : TFhirMarkdown);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirElementDefinition.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirElementDefinition.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirMarkdown.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

Procedure TFhirElementDefinition.SetRequirements(value : TFhirMarkdown);
begin
  FRequirements.free;
  FRequirements := value;
end;

Function TFhirElementDefinition.GetRequirementsST : String;
begin
  if FRequirements = nil then
    result := ''
  else
    result := FRequirements.value;
end;

Procedure TFhirElementDefinition.SetRequirementsST(value : String);
begin
  if value <> '' then
  begin
    if FRequirements = nil then
      FRequirements := TFhirMarkdown.create;
    FRequirements.value := value
  end
  else if FRequirements <> nil then
    FRequirements.value := '';
end;

Function TFhirElementDefinition.GetAliasList : TFhirStringList;
begin
  if FAliasList = nil then
    FAliasList := TFhirStringList.Create;
  result := FAliasList;
end;

Function TFhirElementDefinition.GetHasAliasList : boolean;
begin
  result := (FAliasList <> nil) and (FAliasList.count > 0);
end;

Procedure TFhirElementDefinition.SetMin(value : TFhirUnsignedInt);
begin
  FMin.free;
  FMin := value;
end;

Function TFhirElementDefinition.GetMinST : String;
begin
  if FMin = nil then
    result := ''
  else
    result := FMin.value;
end;

Procedure TFhirElementDefinition.SetMinST(value : String);
begin
  if value <> '' then
  begin
    if FMin = nil then
      FMin := TFhirUnsignedInt.create;
    FMin.value := value
  end
  else if FMin <> nil then
    FMin.value := '';
end;

Procedure TFhirElementDefinition.SetMax(value : TFhirString);
begin
  FMax.free;
  FMax := value;
end;

Function TFhirElementDefinition.GetMaxST : String;
begin
  if FMax = nil then
    result := ''
  else
    result := FMax.value;
end;

Procedure TFhirElementDefinition.SetMaxST(value : String);
begin
  if value <> '' then
  begin
    if FMax = nil then
      FMax := TFhirString.create;
    FMax.value := value
  end
  else if FMax <> nil then
    FMax.value := '';
end;

Procedure TFhirElementDefinition.SetBase(value : TFhirElementDefinitionBase);
begin
  FBase.free;
  FBase := value;
end;

Procedure TFhirElementDefinition.SetContentReference(value : TFhirUri);
begin
  FContentReference.free;
  FContentReference := value;
end;

Function TFhirElementDefinition.GetContentReferenceST : String;
begin
  if FContentReference = nil then
    result := ''
  else
    result := FContentReference.value;
end;

Procedure TFhirElementDefinition.SetContentReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FContentReference = nil then
      FContentReference := TFhirUri.create;
    FContentReference.value := value
  end
  else if FContentReference <> nil then
    FContentReference.value := '';
end;

Function TFhirElementDefinition.GetType_List : TFhirElementDefinitionTypeList;
begin
  if FType_List = nil then
    FType_List := TFhirElementDefinitionTypeList.Create;
  result := FType_List;
end;

Function TFhirElementDefinition.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Procedure TFhirElementDefinition.SetDefaultValue(value : TFhirType);
begin
  FDefaultValue.free;
  FDefaultValue := value;
end;

Procedure TFhirElementDefinition.SetMeaningWhenMissing(value : TFhirMarkdown);
begin
  FMeaningWhenMissing.free;
  FMeaningWhenMissing := value;
end;

Function TFhirElementDefinition.GetMeaningWhenMissingST : String;
begin
  if FMeaningWhenMissing = nil then
    result := ''
  else
    result := FMeaningWhenMissing.value;
end;

Procedure TFhirElementDefinition.SetMeaningWhenMissingST(value : String);
begin
  if value <> '' then
  begin
    if FMeaningWhenMissing = nil then
      FMeaningWhenMissing := TFhirMarkdown.create;
    FMeaningWhenMissing.value := value
  end
  else if FMeaningWhenMissing <> nil then
    FMeaningWhenMissing.value := '';
end;

Procedure TFhirElementDefinition.SetOrderMeaning(value : TFhirString);
begin
  FOrderMeaning.free;
  FOrderMeaning := value;
end;

Function TFhirElementDefinition.GetOrderMeaningST : String;
begin
  if FOrderMeaning = nil then
    result := ''
  else
    result := FOrderMeaning.value;
end;

Procedure TFhirElementDefinition.SetOrderMeaningST(value : String);
begin
  if value <> '' then
  begin
    if FOrderMeaning = nil then
      FOrderMeaning := TFhirString.create;
    FOrderMeaning.value := value
  end
  else if FOrderMeaning <> nil then
    FOrderMeaning.value := '';
end;

Procedure TFhirElementDefinition.SetFixed(value : TFhirType);
begin
  FFixed.free;
  FFixed := value;
end;

Procedure TFhirElementDefinition.SetPattern(value : TFhirType);
begin
  FPattern.free;
  FPattern := value;
end;

Function TFhirElementDefinition.GetExampleList : TFhirElementDefinitionExampleList;
begin
  if FExampleList = nil then
    FExampleList := TFhirElementDefinitionExampleList.Create;
  result := FExampleList;
end;

Function TFhirElementDefinition.GetHasExampleList : boolean;
begin
  result := (FExampleList <> nil) and (FExampleList.count > 0);
end;

Procedure TFhirElementDefinition.SetMinValue(value : TFhirType);
begin
  FMinValue.free;
  FMinValue := value;
end;

Procedure TFhirElementDefinition.SetMaxValue(value : TFhirType);
begin
  FMaxValue.free;
  FMaxValue := value;
end;

Procedure TFhirElementDefinition.SetMaxLength(value : TFhirInteger);
begin
  FMaxLength.free;
  FMaxLength := value;
end;

Function TFhirElementDefinition.GetMaxLengthST : String;
begin
  if FMaxLength = nil then
    result := ''
  else
    result := FMaxLength.value;
end;

Procedure TFhirElementDefinition.SetMaxLengthST(value : String);
begin
  if value <> '' then
  begin
    if FMaxLength = nil then
      FMaxLength := TFhirInteger.create;
    FMaxLength.value := value
  end
  else if FMaxLength <> nil then
    FMaxLength.value := '';
end;

Function TFhirElementDefinition.GetConditionList : TFhirIdList;
begin
  if FConditionList = nil then
    FConditionList := TFhirIdList.Create;
  result := FConditionList;
end;

Function TFhirElementDefinition.GetHasConditionList : boolean;
begin
  result := (FConditionList <> nil) and (FConditionList.count > 0);
end;

Function TFhirElementDefinition.GetConstraintList : TFhirElementDefinitionConstraintList;
begin
  if FConstraintList = nil then
    FConstraintList := TFhirElementDefinitionConstraintList.Create;
  result := FConstraintList;
end;

Function TFhirElementDefinition.GetHasConstraintList : boolean;
begin
  result := (FConstraintList <> nil) and (FConstraintList.count > 0);
end;

Procedure TFhirElementDefinition.SetMustSupport(value : TFhirBoolean);
begin
  FMustSupport.free;
  FMustSupport := value;
end;

Function TFhirElementDefinition.GetMustSupportST : Boolean;
begin
  if FMustSupport = nil then
    result := false
  else
    result := FMustSupport.value;
end;

Procedure TFhirElementDefinition.SetMustSupportST(value : Boolean);
begin
  if FMustSupport = nil then
    FMustSupport := TFhirBoolean.create;
  FMustSupport.value := value
end;

Procedure TFhirElementDefinition.SetIsModifier(value : TFhirBoolean);
begin
  FIsModifier.free;
  FIsModifier := value;
end;

Function TFhirElementDefinition.GetIsModifierST : Boolean;
begin
  if FIsModifier = nil then
    result := false
  else
    result := FIsModifier.value;
end;

Procedure TFhirElementDefinition.SetIsModifierST(value : Boolean);
begin
  if FIsModifier = nil then
    FIsModifier := TFhirBoolean.create;
  FIsModifier.value := value
end;

Procedure TFhirElementDefinition.SetIsModifierReason(value : TFhirString);
begin
  FIsModifierReason.free;
  FIsModifierReason := value;
end;

Function TFhirElementDefinition.GetIsModifierReasonST : String;
begin
  if FIsModifierReason = nil then
    result := ''
  else
    result := FIsModifierReason.value;
end;

Procedure TFhirElementDefinition.SetIsModifierReasonST(value : String);
begin
  if value <> '' then
  begin
    if FIsModifierReason = nil then
      FIsModifierReason := TFhirString.create;
    FIsModifierReason.value := value
  end
  else if FIsModifierReason <> nil then
    FIsModifierReason.value := '';
end;

Procedure TFhirElementDefinition.SetIsSummary(value : TFhirBoolean);
begin
  FIsSummary.free;
  FIsSummary := value;
end;

Function TFhirElementDefinition.GetIsSummaryST : Boolean;
begin
  if FIsSummary = nil then
    result := false
  else
    result := FIsSummary.value;
end;

Procedure TFhirElementDefinition.SetIsSummaryST(value : Boolean);
begin
  if FIsSummary = nil then
    FIsSummary := TFhirBoolean.create;
  FIsSummary.value := value
end;

Procedure TFhirElementDefinition.SetBinding(value : TFhirElementDefinitionBinding);
begin
  FBinding.free;
  FBinding := value;
end;

Function TFhirElementDefinition.GetMappingList : TFhirElementDefinitionMappingList;
begin
  if FMappingList = nil then
    FMappingList := TFhirElementDefinitionMappingList.Create;
  result := FMappingList;
end;

Function TFhirElementDefinition.GetHasMappingList : boolean;
begin
  result := (FMappingList <> nil) and (FMappingList.count > 0);
end;

function TFhirElementDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPath.sizeInBytes);
  inc(result, FRepresentation.sizeInBytes);
  inc(result, FSliceName.sizeInBytes);
  inc(result, FSliceIsConstraining.sizeInBytes);
  inc(result, FLabel_.sizeInBytes);
  inc(result, FcodeList.sizeInBytes);
  inc(result, FSlicing.sizeInBytes);
  inc(result, FShort.sizeInBytes);
  inc(result, FDefinition.sizeInBytes);
  inc(result, FComment.sizeInBytes);
  inc(result, FRequirements.sizeInBytes);
  inc(result, FaliasList.sizeInBytes);
  inc(result, FMin.sizeInBytes);
  inc(result, FMax.sizeInBytes);
  inc(result, FBase.sizeInBytes);
  inc(result, FContentReference.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FDefaultValue.sizeInBytes);
  inc(result, FMeaningWhenMissing.sizeInBytes);
  inc(result, FOrderMeaning.sizeInBytes);
  inc(result, FFixed.sizeInBytes);
  inc(result, FPattern.sizeInBytes);
  inc(result, FexampleList.sizeInBytes);
  inc(result, FMinValue.sizeInBytes);
  inc(result, FMaxValue.sizeInBytes);
  inc(result, FMaxLength.sizeInBytes);
  inc(result, FconditionList.sizeInBytes);
  inc(result, FconstraintList.sizeInBytes);
  inc(result, FMustSupport.sizeInBytes);
  inc(result, FIsModifier.sizeInBytes);
  inc(result, FIsModifierReason.sizeInBytes);
  inc(result, FIsSummary.sizeInBytes);
  inc(result, FBinding.sizeInBytes);
  inc(result, FmappingList.sizeInBytes);
end;

{ TFhirElementDefinitionListEnumerator }

Constructor TFhirElementDefinitionListEnumerator.Create(list : TFhirElementDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirElementDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirElementDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirElementDefinitionListEnumerator.GetCurrent : TFhirElementDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirElementDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirElementDefinitionList }
procedure TFhirElementDefinitionList.AddItem(value: TFhirElementDefinition);
begin
  assert(value.ClassName = 'TFhirElementDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirElementDefinition');
  add(value);
end;

function TFhirElementDefinitionList.Append: TFhirElementDefinition;
begin
  result := TFhirElementDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirElementDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirElementDefinitionList.GetEnumerator : TFhirElementDefinitionListEnumerator;
begin
  result := TFhirElementDefinitionListEnumerator.Create(self.link);
end;

function TFhirElementDefinitionList.Clone: TFhirElementDefinitionList;
begin
  result := TFhirElementDefinitionList(inherited Clone);
end;

function TFhirElementDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirElementDefinitionList.GetItemN(index: Integer): TFhirElementDefinition;
begin
  result := TFhirElementDefinition(ObjectByIndex[index]);
end;

function TFhirElementDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirElementDefinition;
end;
function TFhirElementDefinitionList.IndexOf(value: TFhirElementDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirElementDefinitionList.Insert(index: Integer): TFhirElementDefinition;
begin
  result := TFhirElementDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirElementDefinitionList.InsertItem(index: Integer; value: TFhirElementDefinition);
begin
  assert(value is TFhirElementDefinition);
  Inherited Insert(index, value);
end;

function TFhirElementDefinitionList.Item(index: Integer): TFhirElementDefinition;
begin
  result := TFhirElementDefinition(ObjectByIndex[index]);
end;

function TFhirElementDefinitionList.Link: TFhirElementDefinitionList;
begin
  result := TFhirElementDefinitionList(inherited Link);
end;

procedure TFhirElementDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirElementDefinitionList.SetItemByIndex(index: Integer; value: TFhirElementDefinition);
begin
  assert(value is TFhirElementDefinition);
  FhirElementDefinitions[index] := value;
end;

procedure TFhirElementDefinitionList.SetItemN(index: Integer; value: TFhirElementDefinition);
begin
  assert(value is TFhirElementDefinition);
  ObjectByIndex[index] := value;
end;

function TFhirUnitsOfTimeEnumListAsInteger(aSet : TFhirUnitsOfTimeEnumList) : Integer;
var
  a : TFhirUnitsOfTimeEnum;
begin
  result := 0;
  for a := low(TFhirUnitsOfTimeEnum) to high(TFhirUnitsOfTimeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirUnitsOfTimeEnumList(i : Integer) : TFhirUnitsOfTimeEnumList;
var
  aLoop : TFhirUnitsOfTimeEnum;
begin
  result := [];
  for aLoop := low(TFhirUnitsOfTimeEnum) to high(TFhirUnitsOfTimeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirDaysOfWeekEnumListAsInteger(aSet : TFhirDaysOfWeekEnumList) : Integer;
var
  a : TFhirDaysOfWeekEnum;
begin
  result := 0;
  for a := low(TFhirDaysOfWeekEnum) to high(TFhirDaysOfWeekEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirDaysOfWeekEnumList(i : Integer) : TFhirDaysOfWeekEnumList;
var
  aLoop : TFhirDaysOfWeekEnum;
begin
  result := [];
  for aLoop := low(TFhirDaysOfWeekEnum) to high(TFhirDaysOfWeekEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirEventTimingEnumListAsInteger(aSet : TFhirEventTimingEnumList) : Integer;
var
  a : TFhirEventTimingEnum;
begin
  result := 0;
  for a := low(TFhirEventTimingEnum) to high(TFhirEventTimingEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirEventTimingEnumList(i : Integer) : TFhirEventTimingEnumList;
var
  aLoop : TFhirEventTimingEnum;
begin
  result := [];
  for aLoop := low(TFhirEventTimingEnum) to high(TFhirEventTimingEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

{ TFhirTimingRepeat }

constructor TFhirTimingRepeat.Create;
begin
  inherited;
end;

destructor TFhirTimingRepeat.Destroy;
begin
  FBounds.free;
  FCount.free;
  FCountMax.free;
  FDuration.free;
  FDurationMax.free;
  FDurationUnit.free;
  FFrequency.free;
  FFrequencyMax.free;
  FPeriod.free;
  FPeriodMax.free;
  FPeriodUnit.free;
  FDayOfWeek.Free;
  FTimeOfDayList.Free;
  FWhen.Free;
  FOffset.free;
  inherited;
end;

procedure TFhirTimingRepeat.Assign(oSource : TFslObject);
begin
  inherited;
  bounds := TFhirTimingRepeat(oSource).bounds.Clone;
  countElement := TFhirTimingRepeat(oSource).countElement.Clone;
  countMaxElement := TFhirTimingRepeat(oSource).countMaxElement.Clone;
  durationElement := TFhirTimingRepeat(oSource).durationElement.Clone;
  durationMaxElement := TFhirTimingRepeat(oSource).durationMaxElement.Clone;
  FDurationUnit := TFhirTimingRepeat(oSource).FDurationUnit.Link;
  frequencyElement := TFhirTimingRepeat(oSource).frequencyElement.Clone;
  frequencyMaxElement := TFhirTimingRepeat(oSource).frequencyMaxElement.Clone;
  periodElement := TFhirTimingRepeat(oSource).periodElement.Clone;
  periodMaxElement := TFhirTimingRepeat(oSource).periodMaxElement.Clone;
  FPeriodUnit := TFhirTimingRepeat(oSource).FPeriodUnit.Link;
  if (TFhirTimingRepeat(oSource).FDayOfWeek = nil) then
  begin
    FDayOfWeek.free;
    FDayOfWeek := nil;
  end
  else
  begin
    FDayOfWeek := TFHIREnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
    FDayOfWeek.Assign(TFhirTimingRepeat(oSource).FDayOfWeek);
  end;
  if (TFhirTimingRepeat(oSource).FTimeOfDayList = nil) then
  begin
    FTimeOfDayList.free;
    FTimeOfDayList := nil;
  end
  else
  begin
    if FTimeOfDayList = nil then
      FTimeOfDayList := TFhirTimeList.Create;
    FTimeOfDayList.Assign(TFhirTimingRepeat(oSource).FTimeOfDayList);
  end;
  if (TFhirTimingRepeat(oSource).FWhen = nil) then
  begin
    FWhen.free;
    FWhen := nil;
  end
  else
  begin
    FWhen := TFHIREnumList.Create(SYSTEMS_TFhirEventTimingEnum, CODES_TFhirEventTimingEnum);
    FWhen.Assign(TFhirTimingRepeat(oSource).FWhen);
  end;
  offsetElement := TFhirTimingRepeat(oSource).offsetElement.Clone;
end;

procedure TFhirTimingRepeat.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'bounds[x]') or (child_name = 'bounds') Then
     list.add(self.link, 'bounds[x]', FBounds.Link);
  if (child_name = 'count') Then
     list.add(self.link, 'count', FCount.Link);
  if (child_name = 'countMax') Then
     list.add(self.link, 'countMax', FCountMax.Link);
  if (child_name = 'duration') Then
     list.add(self.link, 'duration', FDuration.Link);
  if (child_name = 'durationMax') Then
     list.add(self.link, 'durationMax', FDurationMax.Link);
  if (child_name = 'durationUnit') Then
     list.add(self.link, 'durationUnit', FDurationUnit.Link);
  if (child_name = 'frequency') Then
     list.add(self.link, 'frequency', FFrequency.Link);
  if (child_name = 'frequencyMax') Then
     list.add(self.link, 'frequencyMax', FFrequencyMax.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'periodMax') Then
     list.add(self.link, 'periodMax', FPeriodMax.Link);
  if (child_name = 'periodUnit') Then
     list.add(self.link, 'periodUnit', FPeriodUnit.Link);
  if (child_name = 'dayOfWeek') Then
     list.addAll(self, 'dayOfWeek', FDayOfWeek);
  if (child_name = 'timeOfDay') Then
    list.addAll(self, 'timeOfDay', FTimeOfDayList);
  if (child_name = 'when') Then
     list.addAll(self, 'when', FWhen);
  if (child_name = 'offset') Then
     list.add(self.link, 'offset', FOffset.Link);
end;

procedure TFhirTimingRepeat.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'bounds[x]', 'Duration|Range|Period', false, TFhirType, FBounds.Link));{2}
  oList.add(TFHIRProperty.create(self, 'count', 'positiveInt', false, TFhirPositiveInt, FCount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'countMax', 'positiveInt', false, TFhirPositiveInt, FCountMax.Link));{2}
  oList.add(TFHIRProperty.create(self, 'duration', 'decimal', false, TFhirDecimal, FDuration.Link));{2}
  oList.add(TFHIRProperty.create(self, 'durationMax', 'decimal', false, TFhirDecimal, FDurationMax.Link));{2}
  oList.add(TFHIRProperty.create(self, 'durationUnit', 'code', false, TFHIREnum, FDurationUnit.Link));{1}
  oList.add(TFHIRProperty.create(self, 'frequency', 'positiveInt', false, TFhirPositiveInt, FFrequency.Link));{2}
  oList.add(TFHIRProperty.create(self, 'frequencyMax', 'positiveInt', false, TFhirPositiveInt, FFrequencyMax.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'decimal', false, TFhirDecimal, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'periodMax', 'decimal', false, TFhirDecimal, FPeriodMax.Link));{2}
  oList.add(TFHIRProperty.create(self, 'periodUnit', 'code', false, TFHIREnum, FPeriodUnit.Link));{1}
  oList.add(TFHIRProperty.create(self, 'dayOfWeek', 'code', true, TFHIREnum, FDayOfWeek.Link)){3};
  oList.add(TFHIRProperty.create(self, 'timeOfDay', 'time', true, TFhirTime, FTimeOfDayList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'when', 'code', true, TFHIREnum, FWhen.Link)){3};
  oList.add(TFHIRProperty.create(self, 'offset', 'unsignedInt', false, TFhirUnsignedInt, FOffset.Link));{2}
end;

function TFhirTimingRepeat.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'bounds', ['Duration', 'Range', 'Period'])) then
  begin
    Bounds := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'count') then
  begin
    CountElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'countMax') then
  begin
    CountMaxElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'duration') then
  begin
    DurationElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'durationMax') then
  begin
    DurationMaxElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'durationUnit') then
  begin
    DurationUnitElement := asEnum(SYSTEMS_TFhirUnitsOfTimeEnum, CODES_TFhirUnitsOfTimeEnum, propValue);
    result := propValue
  end
  else if (propName = 'frequency') then
  begin
    FrequencyElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'frequencyMax') then
  begin
    FrequencyMaxElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    PeriodElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'periodMax') then
  begin
    PeriodMaxElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'periodUnit') then
  begin
    PeriodUnitElement := asEnum(SYSTEMS_TFhirUnitsOfTimeEnum, CODES_TFhirUnitsOfTimeEnum, propValue);
    result := propValue
  end
  else if (propName = 'dayOfWeek') then
  begin
    DayOfWeekList.add(asEnum(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'timeOfDay') then
  begin
    TimeOfDayList.add(asTime(propValue)){2};     result := propValue;

  end
  else if (propName = 'when') then
  begin
    WhenList.add(asEnum(SYSTEMS_TFhirEventTimingEnum, CODES_TFhirEventTimingEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'offset') then
  begin
    OffsetElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTimingRepeat.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'dayOfWeek') then FDayOfWeek.insertItem(index, asEnum(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum, propValue)) {1}
  else if (propName = 'timeOfDay') then TimeOfDayList.insertItem(index, asTime(propValue)){2}
  else if (propName = 'when') then FWhen.insertItem(index, asEnum(SYSTEMS_TFhirEventTimingEnum, CODES_TFhirEventTimingEnum, propValue)) {1}
  else inherited;
end;

function TFhirTimingRepeat.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'bounds', ['Duration', 'Range', 'Period'])) then raise EFHIRException.create('Cannot make property Bounds'){4x}
  else if (propName = 'count') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'countMax') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'duration') then result := TFhirDecimal.create() {5b}
  else if (propName = 'durationMax') then result := TFhirDecimal.create() {5b}
  else if (propName = 'frequency') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'frequencyMax') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'period') then result := TFhirDecimal.create() {5b}
  else if (propName = 'periodMax') then result := TFhirDecimal.create() {5b}
  else if (propName = 'timeOfDay') then result := TimeOfDayList.new(){2}
  else if (propName = 'offset') then result := TFhirUnsignedInt.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTimingRepeat.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'bounds[x]') then result := 'Duration|Range|Period'
  else if (propName = 'count') then result := 'positiveInt'
  else if (propName = 'countMax') then result := 'positiveInt'
  else if (propName = 'duration') then result := 'decimal'
  else if (propName = 'durationMax') then result := 'decimal'
  else if (propName = 'durationUnit') then result := 'code'
  else if (propName = 'frequency') then result := 'positiveInt'
  else if (propName = 'frequencyMax') then result := 'positiveInt'
  else if (propName = 'period') then result := 'decimal'
  else if (propName = 'periodMax') then result := 'decimal'
  else if (propName = 'periodUnit') then result := 'code'
  else if (propName = 'dayOfWeek') then result := 'code'
  else if (propName = 'timeOfDay') then result := 'time'
  else if (propName = 'when') then result := 'code'
  else if (propName = 'offset') then result := 'unsignedInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTimingRepeat.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'bounds', ['Duration', 'Range', 'Period'])) then BoundsElement := nil{4x}
  else if (propName = 'count') then CountElement := nil
  else if (propName = 'countMax') then CountMaxElement := nil
  else if (propName = 'duration') then DurationElement := nil
  else if (propName = 'durationMax') then DurationMaxElement := nil
  else if (propName = 'durationUnit') then DurationUnitElement := nil
  else if (propName = 'frequency') then FrequencyElement := nil
  else if (propName = 'frequencyMax') then FrequencyMaxElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'periodMax') then PeriodMaxElement := nil
  else if (propName = 'periodUnit') then PeriodUnitElement := nil
  else if (propName = 'timeOfDay') then deletePropertyValue('timeOfDay', TimeOfDayList, value) {2}
  else if (propName = 'offset') then OffsetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTimingRepeat.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'bounds', ['Duration', 'Range', 'Period'])) then BoundsElement := new as TFhirType{4x}
  else if (propName = 'count') then CountElement := asPositiveInt(new){5b}
  else if (propName = 'countMax') then CountMaxElement := asPositiveInt(new){5b}
  else if (propName = 'duration') then DurationElement := asDecimal(new){5b}
  else if (propName = 'durationMax') then DurationMaxElement := asDecimal(new){5b}
  else if (propName = 'durationUnit') then DurationUnitElement := asEnum(SYSTEMS_TFhirUnitsOfTimeEnum, CODES_TFhirUnitsOfTimeEnum, new){4}
  else if (propName = 'frequency') then FrequencyElement := asPositiveInt(new){5b}
  else if (propName = 'frequencyMax') then FrequencyMaxElement := asPositiveInt(new){5b}
  else if (propName = 'period') then PeriodElement := asDecimal(new){5b}
  else if (propName = 'periodMax') then PeriodMaxElement := asDecimal(new){5b}
  else if (propName = 'periodUnit') then PeriodUnitElement := asEnum(SYSTEMS_TFhirUnitsOfTimeEnum, CODES_TFhirUnitsOfTimeEnum, new){4}
  else if (propName = 'timeOfDay') then replacePropertyValue('timeOfDay', TimeOfDayList, existing, new) {2}
  else if (propName = 'offset') then OffsetElement := asUnsignedInt(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTimingRepeat.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'dayOfWeek') then FDayOfWeek.move(source, destination) {1}
  else if (propName = 'timeOfDay') then TimeOfDayList.move(source, destination){2}
  else if (propName = 'when') then FWhen.move(source, destination) {1}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTimingRepeat.fhirType : string;
begin
  result := 'repeat';
end;

function TFhirTimingRepeat.Link : TFhirTimingRepeat;
begin
  result := TFhirTimingRepeat(inherited Link);
end;

function TFhirTimingRepeat.Clone : TFhirTimingRepeat;
begin
  result := TFhirTimingRepeat(inherited Clone);
end;

function TFhirTimingRepeat.equals(other : TObject) : boolean; 
var
  o : TFhirTimingRepeat;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTimingRepeat)) then
    result := false
  else
  begin
    o := TFhirTimingRepeat(other);
    result := compareDeep(boundsElement, o.boundsElement, true) and compareDeep(countElement, o.countElement, true) and 
      compareDeep(countMaxElement, o.countMaxElement, true) and compareDeep(durationElement, o.durationElement, true) and 
      compareDeep(durationMaxElement, o.durationMaxElement, true) and compareDeep(durationUnitElement, o.durationUnitElement, true) and 
      compareDeep(frequencyElement, o.frequencyElement, true) and compareDeep(frequencyMaxElement, o.frequencyMaxElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(periodMaxElement, o.periodMaxElement, true) and 
      compareDeep(periodUnitElement, o.periodUnitElement, true) and compareDeep(dayOfWeekList, o.dayOfWeekList, true) and 
      compareDeep(timeOfDayList, o.timeOfDayList, true) and compareDeep(whenList, o.whenList, true) and 
      compareDeep(offsetElement, o.offsetElement, true);
  end;
end;

function TFhirTimingRepeat.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FBounds) and isEmptyProp(FCount) and isEmptyProp(FCountMax) and isEmptyProp(FDuration) and isEmptyProp(FDurationMax) and isEmptyProp(FDurationUnit) and isEmptyProp(FFrequency) and isEmptyProp(FFrequencyMax) and isEmptyProp(FPeriod) and isEmptyProp(FPeriodMax) and isEmptyProp(FPeriodUnit) and isEmptyProp(FDayOfWeek) and isEmptyProp(FtimeOfDayList) and isEmptyProp(FWhen) and isEmptyProp(FOffset);
end;

procedure TFhirTimingRepeat.listFieldsInOrder(fields : TStringList);
begin
  listElementFieldsInOrder(fields);
  fields.add('bounds[x]');
  fields.add('count');
  fields.add('countMax');
  fields.add('duration');
  fields.add('durationMax');
  fields.add('durationUnit');
  fields.add('frequency');
  fields.add('frequencyMax');
  fields.add('period');
  fields.add('periodMax');
  fields.add('periodUnit');
  fields.add('dayOfWeek');
  fields.add('timeOfDay');
  fields.add('when');
  fields.add('offset');
end;

{ TFhirTimingRepeat }

Procedure TFhirTimingRepeat.SetBounds(value : TFhirType);
begin
  FBounds.free;
  FBounds := value;
end;

Procedure TFhirTimingRepeat.SetCount(value : TFhirPositiveInt);
begin
  FCount.free;
  FCount := value;
end;

Function TFhirTimingRepeat.GetCountST : String;
begin
  if FCount = nil then
    result := ''
  else
    result := FCount.value;
end;

Procedure TFhirTimingRepeat.SetCountST(value : String);
begin
  if value <> '' then
  begin
    if FCount = nil then
      FCount := TFhirPositiveInt.create;
    FCount.value := value
  end
  else if FCount <> nil then
    FCount.value := '';
end;

Procedure TFhirTimingRepeat.SetCountMax(value : TFhirPositiveInt);
begin
  FCountMax.free;
  FCountMax := value;
end;

Function TFhirTimingRepeat.GetCountMaxST : String;
begin
  if FCountMax = nil then
    result := ''
  else
    result := FCountMax.value;
end;

Procedure TFhirTimingRepeat.SetCountMaxST(value : String);
begin
  if value <> '' then
  begin
    if FCountMax = nil then
      FCountMax := TFhirPositiveInt.create;
    FCountMax.value := value
  end
  else if FCountMax <> nil then
    FCountMax.value := '';
end;

Procedure TFhirTimingRepeat.SetDuration(value : TFhirDecimal);
begin
  FDuration.free;
  FDuration := value;
end;

Function TFhirTimingRepeat.GetDurationST : String;
begin
  if FDuration = nil then
    result := ''
  else
    result := FDuration.value;
end;

Procedure TFhirTimingRepeat.SetDurationST(value : String);
begin
  if value <> '' then
  begin
    if FDuration = nil then
      FDuration := TFhirDecimal.create;
    FDuration.value := value
  end
  else if FDuration <> nil then
    FDuration.value := '';
end;

Procedure TFhirTimingRepeat.SetDurationMax(value : TFhirDecimal);
begin
  FDurationMax.free;
  FDurationMax := value;
end;

Function TFhirTimingRepeat.GetDurationMaxST : String;
begin
  if FDurationMax = nil then
    result := ''
  else
    result := FDurationMax.value;
end;

Procedure TFhirTimingRepeat.SetDurationMaxST(value : String);
begin
  if value <> '' then
  begin
    if FDurationMax = nil then
      FDurationMax := TFhirDecimal.create;
    FDurationMax.value := value
  end
  else if FDurationMax <> nil then
    FDurationMax.value := '';
end;

Procedure TFhirTimingRepeat.SetDurationUnit(value : TFhirEnum);
begin
  FDurationUnit.free;
  FDurationUnit := value;
end;

Function TFhirTimingRepeat.GetDurationUnitST : TFhirUnitsOfTimeEnum;
begin
  if FDurationUnit = nil then
    result := TFhirUnitsOfTimeEnum(0)
  else
    result := TFhirUnitsOfTimeEnum(StringArrayIndexOfSensitive(CODES_TFhirUnitsOfTimeEnum, FDurationUnit.value));
end;

Procedure TFhirTimingRepeat.SetDurationUnitST(value : TFhirUnitsOfTimeEnum);
begin
  if ord(value) = 0 then
    DurationUnitElement := nil
  else
    DurationUnitElement := TFhirEnum.create(SYSTEMS_TFhirUnitsOfTimeEnum[value], CODES_TFhirUnitsOfTimeEnum[value]);
end;

Procedure TFhirTimingRepeat.SetFrequency(value : TFhirPositiveInt);
begin
  FFrequency.free;
  FFrequency := value;
end;

Function TFhirTimingRepeat.GetFrequencyST : String;
begin
  if FFrequency = nil then
    result := ''
  else
    result := FFrequency.value;
end;

Procedure TFhirTimingRepeat.SetFrequencyST(value : String);
begin
  if value <> '' then
  begin
    if FFrequency = nil then
      FFrequency := TFhirPositiveInt.create;
    FFrequency.value := value
  end
  else if FFrequency <> nil then
    FFrequency.value := '';
end;

Procedure TFhirTimingRepeat.SetFrequencyMax(value : TFhirPositiveInt);
begin
  FFrequencyMax.free;
  FFrequencyMax := value;
end;

Function TFhirTimingRepeat.GetFrequencyMaxST : String;
begin
  if FFrequencyMax = nil then
    result := ''
  else
    result := FFrequencyMax.value;
end;

Procedure TFhirTimingRepeat.SetFrequencyMaxST(value : String);
begin
  if value <> '' then
  begin
    if FFrequencyMax = nil then
      FFrequencyMax := TFhirPositiveInt.create;
    FFrequencyMax.value := value
  end
  else if FFrequencyMax <> nil then
    FFrequencyMax.value := '';
end;

Procedure TFhirTimingRepeat.SetPeriod(value : TFhirDecimal);
begin
  FPeriod.free;
  FPeriod := value;
end;

Function TFhirTimingRepeat.GetPeriodST : String;
begin
  if FPeriod = nil then
    result := ''
  else
    result := FPeriod.value;
end;

Procedure TFhirTimingRepeat.SetPeriodST(value : String);
begin
  if value <> '' then
  begin
    if FPeriod = nil then
      FPeriod := TFhirDecimal.create;
    FPeriod.value := value
  end
  else if FPeriod <> nil then
    FPeriod.value := '';
end;

Procedure TFhirTimingRepeat.SetPeriodMax(value : TFhirDecimal);
begin
  FPeriodMax.free;
  FPeriodMax := value;
end;

Function TFhirTimingRepeat.GetPeriodMaxST : String;
begin
  if FPeriodMax = nil then
    result := ''
  else
    result := FPeriodMax.value;
end;

Procedure TFhirTimingRepeat.SetPeriodMaxST(value : String);
begin
  if value <> '' then
  begin
    if FPeriodMax = nil then
      FPeriodMax := TFhirDecimal.create;
    FPeriodMax.value := value
  end
  else if FPeriodMax <> nil then
    FPeriodMax.value := '';
end;

Procedure TFhirTimingRepeat.SetPeriodUnit(value : TFhirEnum);
begin
  FPeriodUnit.free;
  FPeriodUnit := value;
end;

Function TFhirTimingRepeat.GetPeriodUnitST : TFhirUnitsOfTimeEnum;
begin
  if FPeriodUnit = nil then
    result := TFhirUnitsOfTimeEnum(0)
  else
    result := TFhirUnitsOfTimeEnum(StringArrayIndexOfSensitive(CODES_TFhirUnitsOfTimeEnum, FPeriodUnit.value));
end;

Procedure TFhirTimingRepeat.SetPeriodUnitST(value : TFhirUnitsOfTimeEnum);
begin
  if ord(value) = 0 then
    PeriodUnitElement := nil
  else
    PeriodUnitElement := TFhirEnum.create(SYSTEMS_TFhirUnitsOfTimeEnum[value], CODES_TFhirUnitsOfTimeEnum[value]);
end;

Function TFhirTimingRepeat.GetDayOfWeek : TFhirEnumList;
begin
  if FDayOfWeek = nil then
    FDayOfWeek := TFHIREnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
  result := FDayOfWeek;
end;

Function TFhirTimingRepeat.GetHasDayOfWeek : boolean;
begin
  result := (FDayOfWeek <> nil) and (FDayOfWeek.count > 0);
end;

Function TFhirTimingRepeat.GetDayOfWeekST : TFhirDaysOfWeekEnumList;
  var i : integer;
begin
  result := [];
  if FdayOfWeek <> nil then
    for i := 0 to FdayOfWeek.count - 1 do
      result := result + [TFhirDaysOfWeekEnum(StringArrayIndexOfSensitive(CODES_TFhirDaysOfWeekEnum, FdayOfWeek[i].value))];
end;

Procedure TFhirTimingRepeat.SetDayOfWeekST(value : TFhirDaysOfWeekEnumList);
var a : TFhirDaysOfWeekEnum;
begin
  if FdayOfWeek = nil then
    FdayOfWeek := TFhirEnumList.create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
  FdayOfWeek.clear;
  for a := low(TFhirDaysOfWeekEnum) to high(TFhirDaysOfWeekEnum) do
    if a in value then
      begin
         if FdayOfWeek = nil then
           FdayOfWeek := TFhirEnumList.create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
         FdayOfWeek.add(TFhirEnum.create(SYSTEMS_TFhirDaysOfWeekEnum[a], CODES_TFhirDaysOfWeekEnum[a]));
      end;
end;

Function TFhirTimingRepeat.GetTimeOfDayList : TFhirTimeList;
begin
  if FTimeOfDayList = nil then
    FTimeOfDayList := TFhirTimeList.Create;
  result := FTimeOfDayList;
end;

Function TFhirTimingRepeat.GetHasTimeOfDayList : boolean;
begin
  result := (FTimeOfDayList <> nil) and (FTimeOfDayList.count > 0);
end;

Function TFhirTimingRepeat.GetWhen : TFhirEnumList;
begin
  if FWhen = nil then
    FWhen := TFHIREnumList.Create(SYSTEMS_TFhirEventTimingEnum, CODES_TFhirEventTimingEnum);
  result := FWhen;
end;

Function TFhirTimingRepeat.GetHasWhen : boolean;
begin
  result := (FWhen <> nil) and (FWhen.count > 0);
end;

Function TFhirTimingRepeat.GetWhenST : TFhirEventTimingEnumList;
  var i : integer;
begin
  result := [];
  if Fwhen <> nil then
    for i := 0 to Fwhen.count - 1 do
      result := result + [TFhirEventTimingEnum(StringArrayIndexOfSensitive(CODES_TFhirEventTimingEnum, Fwhen[i].value))];
end;

Procedure TFhirTimingRepeat.SetWhenST(value : TFhirEventTimingEnumList);
var a : TFhirEventTimingEnum;
begin
  if Fwhen = nil then
    Fwhen := TFhirEnumList.create(SYSTEMS_TFhirEventTimingEnum, CODES_TFhirEventTimingEnum);
  Fwhen.clear;
  for a := low(TFhirEventTimingEnum) to high(TFhirEventTimingEnum) do
    if a in value then
      begin
         if Fwhen = nil then
           Fwhen := TFhirEnumList.create(SYSTEMS_TFhirEventTimingEnum, CODES_TFhirEventTimingEnum);
         Fwhen.add(TFhirEnum.create(SYSTEMS_TFhirEventTimingEnum[a], CODES_TFhirEventTimingEnum[a]));
      end;
end;

Procedure TFhirTimingRepeat.SetOffset(value : TFhirUnsignedInt);
begin
  FOffset.free;
  FOffset := value;
end;

Function TFhirTimingRepeat.GetOffsetST : String;
begin
  if FOffset = nil then
    result := ''
  else
    result := FOffset.value;
end;

Procedure TFhirTimingRepeat.SetOffsetST(value : String);
begin
  if value <> '' then
  begin
    if FOffset = nil then
      FOffset := TFhirUnsignedInt.create;
    FOffset.value := value
  end
  else if FOffset <> nil then
    FOffset.value := '';
end;

function TFhirTimingRepeat.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FBounds.sizeInBytes);
  inc(result, FCount.sizeInBytes);
  inc(result, FCountMax.sizeInBytes);
  inc(result, FDuration.sizeInBytes);
  inc(result, FDurationMax.sizeInBytes);
  inc(result, FDurationUnit.sizeInBytes);
  inc(result, FFrequency.sizeInBytes);
  inc(result, FFrequencyMax.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FPeriodMax.sizeInBytes);
  inc(result, FPeriodUnit.sizeInBytes);
  inc(result, FDayOfWeek.sizeInBytes);
  inc(result, FtimeOfDayList.sizeInBytes);
  inc(result, FWhen.sizeInBytes);
  inc(result, FOffset.sizeInBytes);
end;

{ TFhirTimingRepeatListEnumerator }

Constructor TFhirTimingRepeatListEnumerator.Create(list : TFhirTimingRepeatList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTimingRepeatListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTimingRepeatListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTimingRepeatListEnumerator.GetCurrent : TFhirTimingRepeat;
begin
  Result := FList[FIndex];
end;

function TFhirTimingRepeatListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTimingRepeatList }
procedure TFhirTimingRepeatList.AddItem(value: TFhirTimingRepeat);
begin
  assert(value.ClassName = 'TFhirTimingRepeat', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTimingRepeat');
  add(value);
end;

function TFhirTimingRepeatList.Append: TFhirTimingRepeat;
begin
  result := TFhirTimingRepeat.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTimingRepeatList.ClearItems;
begin
  Clear;
end;

function TFhirTimingRepeatList.GetEnumerator : TFhirTimingRepeatListEnumerator;
begin
  result := TFhirTimingRepeatListEnumerator.Create(self.link);
end;

function TFhirTimingRepeatList.Clone: TFhirTimingRepeatList;
begin
  result := TFhirTimingRepeatList(inherited Clone);
end;

function TFhirTimingRepeatList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTimingRepeatList.GetItemN(index: Integer): TFhirTimingRepeat;
begin
  result := TFhirTimingRepeat(ObjectByIndex[index]);
end;

function TFhirTimingRepeatList.ItemClass: TFslObjectClass;
begin
  result := TFhirTimingRepeat;
end;
function TFhirTimingRepeatList.IndexOf(value: TFhirTimingRepeat): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTimingRepeatList.Insert(index: Integer): TFhirTimingRepeat;
begin
  result := TFhirTimingRepeat.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTimingRepeatList.InsertItem(index: Integer; value: TFhirTimingRepeat);
begin
  assert(value is TFhirTimingRepeat);
  Inherited Insert(index, value);
end;

function TFhirTimingRepeatList.Item(index: Integer): TFhirTimingRepeat;
begin
  result := TFhirTimingRepeat(ObjectByIndex[index]);
end;

function TFhirTimingRepeatList.Link: TFhirTimingRepeatList;
begin
  result := TFhirTimingRepeatList(inherited Link);
end;

procedure TFhirTimingRepeatList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTimingRepeatList.SetItemByIndex(index: Integer; value: TFhirTimingRepeat);
begin
  assert(value is TFhirTimingRepeat);
  FhirTimingRepeats[index] := value;
end;

procedure TFhirTimingRepeatList.SetItemN(index: Integer; value: TFhirTimingRepeat);
begin
  assert(value is TFhirTimingRepeat);
  ObjectByIndex[index] := value;
end;

{ TFhirTiming }

constructor TFhirTiming.Create;
begin
  inherited;
end;

destructor TFhirTiming.Destroy;
begin
  FEventList.Free;
  FRepeat_.free;
  FCode.free;
  inherited;
end;

procedure TFhirTiming.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTiming(oSource).FEventList = nil) then
  begin
    FEventList.free;
    FEventList := nil;
  end
  else
  begin
    if FEventList = nil then
      FEventList := TFhirDateTimeList.Create;
    FEventList.Assign(TFhirTiming(oSource).FEventList);
  end;
  repeat_ := TFhirTiming(oSource).repeat_.Clone;
  code := TFhirTiming(oSource).code.Clone;
end;

procedure TFhirTiming.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'event') Then
    list.addAll(self, 'event', FEventList);
  if (child_name = 'repeat') Then
     list.add(self.link, 'repeat', FRepeat_.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
end;

procedure TFhirTiming.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'event', 'dateTime', true, TFhirDateTime, FEventList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'repeat', '', false, TFhirTimingRepeat, FRepeat_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
end;

function TFhirTiming.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'event') then
  begin
    EventList.add(asDateTime(propValue)){2};     result := propValue;

  end
  else if (propName = 'repeat') then
  begin
    Repeat_ := propValue as TFhirTimingRepeat{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirTiming.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'event') then EventList.insertItem(index, asDateTime(propValue)){2}
  else inherited;
end;

function TFhirTiming.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'event') then result := EventList.new(){2}
  else if (propName = 'repeat') then result := TFhirTimingRepeat.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTiming.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'event') then result := 'dateTime'
  else if (propName = 'repeat') then result := ''
  else if (propName = 'code') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTiming.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'event') then deletePropertyValue('event', EventList, value) {2}
  else if (propName = 'repeat') then Repeat_Element := nil
  else if (propName = 'code') then CodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTiming.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'event') then replacePropertyValue('event', EventList, existing, new) {2}
  else if (propName = 'repeat') then Repeat_Element := new as TFhirTimingRepeat{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTiming.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'event') then EventList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTiming.fhirType : string;
begin
  result := 'Timing';
end;

function TFhirTiming.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FeventList) and isEmptyProp(FRepeat_) and isEmptyProp(FCode);
end;

function TFhirTiming.equals(other : TObject) : boolean; 
var
  o : TFhirTiming;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTiming)) then
    result := false
  else
  begin
    o := TFhirTiming(other);
    result := compareDeep(eventList, o.eventList, true) and compareDeep(repeat_Element, o.repeat_Element, true) and 
      compareDeep(codeElement, o.codeElement, true);
  end;
end;

function TFhirTiming.Link : TFhirTiming;
begin
  result := TFhirTiming(inherited Link);
end;

function TFhirTiming.Clone : TFhirTiming;
begin
  result := TFhirTiming(inherited Clone);
end;

procedure TFhirTiming.listFieldsInOrder(fields : TStringList);
begin
  listBackboneTypeFieldsInOrder(fields);
  fields.add('event');
  fields.add('repeat');
  fields.add('code');
end;

{ TFhirTiming }

Function TFhirTiming.GetEventList : TFhirDateTimeList;
begin
  if FEventList = nil then
    FEventList := TFhirDateTimeList.Create;
  result := FEventList;
end;

Function TFhirTiming.GetHasEventList : boolean;
begin
  result := (FEventList <> nil) and (FEventList.count > 0);
end;

Procedure TFhirTiming.SetRepeat_(value : TFhirTimingRepeat);
begin
  FRepeat_.free;
  FRepeat_ := value;
end;

Procedure TFhirTiming.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirTiming.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FeventList.sizeInBytes);
  inc(result, FRepeat_.sizeInBytes);
  inc(result, FCode.sizeInBytes);
end;

{ TFhirTimingListEnumerator }

Constructor TFhirTimingListEnumerator.Create(list : TFhirTimingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTimingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTimingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTimingListEnumerator.GetCurrent : TFhirTiming;
begin
  Result := FList[FIndex];
end;

function TFhirTimingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTimingList }
procedure TFhirTimingList.AddItem(value: TFhirTiming);
begin
  assert(value.ClassName = 'TFhirTiming', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTiming');
  add(value);
end;

function TFhirTimingList.Append: TFhirTiming;
begin
  result := TFhirTiming.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTimingList.ClearItems;
begin
  Clear;
end;

function TFhirTimingList.GetEnumerator : TFhirTimingListEnumerator;
begin
  result := TFhirTimingListEnumerator.Create(self.link);
end;

function TFhirTimingList.Clone: TFhirTimingList;
begin
  result := TFhirTimingList(inherited Clone);
end;

function TFhirTimingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTimingList.GetItemN(index: Integer): TFhirTiming;
begin
  result := TFhirTiming(ObjectByIndex[index]);
end;

function TFhirTimingList.ItemClass: TFslObjectClass;
begin
  result := TFhirTiming;
end;
function TFhirTimingList.IndexOf(value: TFhirTiming): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTimingList.Insert(index: Integer): TFhirTiming;
begin
  result := TFhirTiming.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTimingList.InsertItem(index: Integer; value: TFhirTiming);
begin
  assert(value is TFhirTiming);
  Inherited Insert(index, value);
end;

function TFhirTimingList.Item(index: Integer): TFhirTiming;
begin
  result := TFhirTiming(ObjectByIndex[index]);
end;

function TFhirTimingList.Link: TFhirTimingList;
begin
  result := TFhirTimingList(inherited Link);
end;

procedure TFhirTimingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTimingList.SetItemByIndex(index: Integer; value: TFhirTiming);
begin
  assert(value is TFhirTiming);
  FhirTimings[index] := value;
end;

procedure TFhirTimingList.SetItemN(index: Integer; value: TFhirTiming);
begin
  assert(value is TFhirTiming);
  ObjectByIndex[index] := value;
end;

{ TFhirCount }

constructor TFhirCount.Create;
begin
  inherited;
end;

destructor TFhirCount.Destroy;
begin
  inherited;
end;

procedure TFhirCount.Assign(oSource : TFslObject);
begin
  inherited;
end;

procedure TFhirCount.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
end;

procedure TFhirCount.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
end;

function TFhirCount.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  result := inherited setProperty(propName, propValue);
end;

procedure TFhirCount.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCount.createPropertyValue(propName: string) : TFHIRObject;
begin
  result := inherited createPropertyValue(propName);
end;

function TFhirCount.getTypesForProperty(propName: string) : String;
begin
  result := inherited getTypesForProperty(propName);
end;

procedure TFhirCount.deleteProperty(propName : string; value : TFHIRObject);
begin
  inherited deleteProperty(propName, value);
end;

procedure TFhirCount.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCount.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCount.fhirType : string;
begin
  result := 'Count';
end;

function TFhirCount.isEmpty : boolean;
begin
  result := inherited isEmpty ;
end;

function TFhirCount.equals(other : TObject) : boolean; 
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCount)) then
    result := false
  else
    result := true;
end;

function TFhirCount.Link : TFhirCount;
begin
  result := TFhirCount(inherited Link);
end;

function TFhirCount.Clone : TFhirCount;
begin
  result := TFhirCount(inherited Clone);
end;

procedure TFhirCount.listFieldsInOrder(fields : TStringList);
begin
  listQuantityFieldsInOrder(fields);
end;

{ TFhirCount }

{ TFhirCountListEnumerator }

Constructor TFhirCountListEnumerator.Create(list : TFhirCountList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCountListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCountListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCountListEnumerator.GetCurrent : TFhirCount;
begin
  Result := FList[FIndex];
end;

function TFhirCountListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCountList }
procedure TFhirCountList.AddItem(value: TFhirCount);
begin
  assert(value.ClassName = 'TFhirCount', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCount');
  add(value);
end;

function TFhirCountList.Append: TFhirCount;
begin
  result := TFhirCount.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCountList.ClearItems;
begin
  Clear;
end;

function TFhirCountList.GetEnumerator : TFhirCountListEnumerator;
begin
  result := TFhirCountListEnumerator.Create(self.link);
end;

function TFhirCountList.Clone: TFhirCountList;
begin
  result := TFhirCountList(inherited Clone);
end;

function TFhirCountList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCountList.GetItemN(index: Integer): TFhirCount;
begin
  result := TFhirCount(ObjectByIndex[index]);
end;

function TFhirCountList.ItemClass: TFslObjectClass;
begin
  result := TFhirCount;
end;
function TFhirCountList.IndexOf(value: TFhirCount): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCountList.Insert(index: Integer): TFhirCount;
begin
  result := TFhirCount.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCountList.InsertItem(index: Integer; value: TFhirCount);
begin
  assert(value is TFhirCount);
  Inherited Insert(index, value);
end;

function TFhirCountList.Item(index: Integer): TFhirCount;
begin
  result := TFhirCount(ObjectByIndex[index]);
end;

function TFhirCountList.Link: TFhirCountList;
begin
  result := TFhirCountList(inherited Link);
end;

procedure TFhirCountList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCountList.SetItemByIndex(index: Integer; value: TFhirCount);
begin
  assert(value is TFhirCount);
  FhirCounts[index] := value;
end;

procedure TFhirCountList.SetItemN(index: Integer; value: TFhirCount);
begin
  assert(value is TFhirCount);
  ObjectByIndex[index] := value;
end;

{ TFhirAge }

constructor TFhirAge.Create;
begin
  inherited;
end;

destructor TFhirAge.Destroy;
begin
  inherited;
end;

procedure TFhirAge.Assign(oSource : TFslObject);
begin
  inherited;
end;

procedure TFhirAge.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
end;

procedure TFhirAge.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
end;

function TFhirAge.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  result := inherited setProperty(propName, propValue);
end;

procedure TFhirAge.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAge.createPropertyValue(propName: string) : TFHIRObject;
begin
  result := inherited createPropertyValue(propName);
end;

function TFhirAge.getTypesForProperty(propName: string) : String;
begin
  result := inherited getTypesForProperty(propName);
end;

procedure TFhirAge.deleteProperty(propName : string; value : TFHIRObject);
begin
  inherited deleteProperty(propName, value);
end;

procedure TFhirAge.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAge.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAge.fhirType : string;
begin
  result := 'Age';
end;

function TFhirAge.isEmpty : boolean;
begin
  result := inherited isEmpty ;
end;

function TFhirAge.equals(other : TObject) : boolean; 
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAge)) then
    result := false
  else
    result := true;
end;

function TFhirAge.Link : TFhirAge;
begin
  result := TFhirAge(inherited Link);
end;

function TFhirAge.Clone : TFhirAge;
begin
  result := TFhirAge(inherited Clone);
end;

procedure TFhirAge.listFieldsInOrder(fields : TStringList);
begin
  listQuantityFieldsInOrder(fields);
end;

{ TFhirAge }

{ TFhirAgeListEnumerator }

Constructor TFhirAgeListEnumerator.Create(list : TFhirAgeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAgeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAgeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAgeListEnumerator.GetCurrent : TFhirAge;
begin
  Result := FList[FIndex];
end;

function TFhirAgeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAgeList }
procedure TFhirAgeList.AddItem(value: TFhirAge);
begin
  assert(value.ClassName = 'TFhirAge', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAge');
  add(value);
end;

function TFhirAgeList.Append: TFhirAge;
begin
  result := TFhirAge.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAgeList.ClearItems;
begin
  Clear;
end;

function TFhirAgeList.GetEnumerator : TFhirAgeListEnumerator;
begin
  result := TFhirAgeListEnumerator.Create(self.link);
end;

function TFhirAgeList.Clone: TFhirAgeList;
begin
  result := TFhirAgeList(inherited Clone);
end;

function TFhirAgeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAgeList.GetItemN(index: Integer): TFhirAge;
begin
  result := TFhirAge(ObjectByIndex[index]);
end;

function TFhirAgeList.ItemClass: TFslObjectClass;
begin
  result := TFhirAge;
end;
function TFhirAgeList.IndexOf(value: TFhirAge): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAgeList.Insert(index: Integer): TFhirAge;
begin
  result := TFhirAge.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAgeList.InsertItem(index: Integer; value: TFhirAge);
begin
  assert(value is TFhirAge);
  Inherited Insert(index, value);
end;

function TFhirAgeList.Item(index: Integer): TFhirAge;
begin
  result := TFhirAge(ObjectByIndex[index]);
end;

function TFhirAgeList.Link: TFhirAgeList;
begin
  result := TFhirAgeList(inherited Link);
end;

procedure TFhirAgeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAgeList.SetItemByIndex(index: Integer; value: TFhirAge);
begin
  assert(value is TFhirAge);
  FhirAges[index] := value;
end;

procedure TFhirAgeList.SetItemN(index: Integer; value: TFhirAge);
begin
  assert(value is TFhirAge);
  ObjectByIndex[index] := value;
end;

{ TFhirDistance }

constructor TFhirDistance.Create;
begin
  inherited;
end;

destructor TFhirDistance.Destroy;
begin
  inherited;
end;

procedure TFhirDistance.Assign(oSource : TFslObject);
begin
  inherited;
end;

procedure TFhirDistance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
end;

procedure TFhirDistance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
end;

function TFhirDistance.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  result := inherited setProperty(propName, propValue);
end;

procedure TFhirDistance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDistance.createPropertyValue(propName: string) : TFHIRObject;
begin
  result := inherited createPropertyValue(propName);
end;

function TFhirDistance.getTypesForProperty(propName: string) : String;
begin
  result := inherited getTypesForProperty(propName);
end;

procedure TFhirDistance.deleteProperty(propName : string; value : TFHIRObject);
begin
  inherited deleteProperty(propName, value);
end;

procedure TFhirDistance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDistance.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDistance.fhirType : string;
begin
  result := 'Distance';
end;

function TFhirDistance.isEmpty : boolean;
begin
  result := inherited isEmpty ;
end;

function TFhirDistance.equals(other : TObject) : boolean; 
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDistance)) then
    result := false
  else
    result := true;
end;

function TFhirDistance.Link : TFhirDistance;
begin
  result := TFhirDistance(inherited Link);
end;

function TFhirDistance.Clone : TFhirDistance;
begin
  result := TFhirDistance(inherited Clone);
end;

procedure TFhirDistance.listFieldsInOrder(fields : TStringList);
begin
  listQuantityFieldsInOrder(fields);
end;

{ TFhirDistance }

{ TFhirDistanceListEnumerator }

Constructor TFhirDistanceListEnumerator.Create(list : TFhirDistanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDistanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDistanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDistanceListEnumerator.GetCurrent : TFhirDistance;
begin
  Result := FList[FIndex];
end;

function TFhirDistanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDistanceList }
procedure TFhirDistanceList.AddItem(value: TFhirDistance);
begin
  assert(value.ClassName = 'TFhirDistance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDistance');
  add(value);
end;

function TFhirDistanceList.Append: TFhirDistance;
begin
  result := TFhirDistance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDistanceList.ClearItems;
begin
  Clear;
end;

function TFhirDistanceList.GetEnumerator : TFhirDistanceListEnumerator;
begin
  result := TFhirDistanceListEnumerator.Create(self.link);
end;

function TFhirDistanceList.Clone: TFhirDistanceList;
begin
  result := TFhirDistanceList(inherited Clone);
end;

function TFhirDistanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDistanceList.GetItemN(index: Integer): TFhirDistance;
begin
  result := TFhirDistance(ObjectByIndex[index]);
end;

function TFhirDistanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirDistance;
end;
function TFhirDistanceList.IndexOf(value: TFhirDistance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDistanceList.Insert(index: Integer): TFhirDistance;
begin
  result := TFhirDistance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDistanceList.InsertItem(index: Integer; value: TFhirDistance);
begin
  assert(value is TFhirDistance);
  Inherited Insert(index, value);
end;

function TFhirDistanceList.Item(index: Integer): TFhirDistance;
begin
  result := TFhirDistance(ObjectByIndex[index]);
end;

function TFhirDistanceList.Link: TFhirDistanceList;
begin
  result := TFhirDistanceList(inherited Link);
end;

procedure TFhirDistanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDistanceList.SetItemByIndex(index: Integer; value: TFhirDistance);
begin
  assert(value is TFhirDistance);
  FhirDistances[index] := value;
end;

procedure TFhirDistanceList.SetItemN(index: Integer; value: TFhirDistance);
begin
  assert(value is TFhirDistance);
  ObjectByIndex[index] := value;
end;

{ TFhirDuration }

constructor TFhirDuration.Create;
begin
  inherited;
end;

destructor TFhirDuration.Destroy;
begin
  inherited;
end;

procedure TFhirDuration.Assign(oSource : TFslObject);
begin
  inherited;
end;

procedure TFhirDuration.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
end;

procedure TFhirDuration.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
end;

function TFhirDuration.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  result := inherited setProperty(propName, propValue);
end;

procedure TFhirDuration.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDuration.createPropertyValue(propName: string) : TFHIRObject;
begin
  result := inherited createPropertyValue(propName);
end;

function TFhirDuration.getTypesForProperty(propName: string) : String;
begin
  result := inherited getTypesForProperty(propName);
end;

procedure TFhirDuration.deleteProperty(propName : string; value : TFHIRObject);
begin
  inherited deleteProperty(propName, value);
end;

procedure TFhirDuration.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDuration.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDuration.fhirType : string;
begin
  result := 'Duration';
end;

function TFhirDuration.isEmpty : boolean;
begin
  result := inherited isEmpty ;
end;

function TFhirDuration.equals(other : TObject) : boolean; 
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDuration)) then
    result := false
  else
    result := true;
end;

function TFhirDuration.Link : TFhirDuration;
begin
  result := TFhirDuration(inherited Link);
end;

function TFhirDuration.Clone : TFhirDuration;
begin
  result := TFhirDuration(inherited Clone);
end;

procedure TFhirDuration.listFieldsInOrder(fields : TStringList);
begin
  listQuantityFieldsInOrder(fields);
end;

{ TFhirDuration }

{ TFhirDurationListEnumerator }

Constructor TFhirDurationListEnumerator.Create(list : TFhirDurationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDurationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDurationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDurationListEnumerator.GetCurrent : TFhirDuration;
begin
  Result := FList[FIndex];
end;

function TFhirDurationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDurationList }
procedure TFhirDurationList.AddItem(value: TFhirDuration);
begin
  assert(value.ClassName = 'TFhirDuration', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDuration');
  add(value);
end;

function TFhirDurationList.Append: TFhirDuration;
begin
  result := TFhirDuration.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDurationList.ClearItems;
begin
  Clear;
end;

function TFhirDurationList.GetEnumerator : TFhirDurationListEnumerator;
begin
  result := TFhirDurationListEnumerator.Create(self.link);
end;

function TFhirDurationList.Clone: TFhirDurationList;
begin
  result := TFhirDurationList(inherited Clone);
end;

function TFhirDurationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDurationList.GetItemN(index: Integer): TFhirDuration;
begin
  result := TFhirDuration(ObjectByIndex[index]);
end;

function TFhirDurationList.ItemClass: TFslObjectClass;
begin
  result := TFhirDuration;
end;
function TFhirDurationList.IndexOf(value: TFhirDuration): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDurationList.Insert(index: Integer): TFhirDuration;
begin
  result := TFhirDuration.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDurationList.InsertItem(index: Integer; value: TFhirDuration);
begin
  assert(value is TFhirDuration);
  Inherited Insert(index, value);
end;

function TFhirDurationList.Item(index: Integer): TFhirDuration;
begin
  result := TFhirDuration(ObjectByIndex[index]);
end;

function TFhirDurationList.Link: TFhirDurationList;
begin
  result := TFhirDurationList(inherited Link);
end;

procedure TFhirDurationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDurationList.SetItemByIndex(index: Integer; value: TFhirDuration);
begin
  assert(value is TFhirDuration);
  FhirDurations[index] := value;
end;

procedure TFhirDurationList.SetItemN(index: Integer; value: TFhirDuration);
begin
  assert(value is TFhirDuration);
  ObjectByIndex[index] := value;
end;

function TFhirAccountStatusEnumListAsInteger(aSet : TFhirAccountStatusEnumList) : Integer;
var
  a : TFhirAccountStatusEnum;
begin
  result := 0;
  for a := low(TFhirAccountStatusEnum) to high(TFhirAccountStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirAccountStatusEnumList(i : Integer) : TFhirAccountStatusEnumList;
var
  aLoop : TFhirAccountStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirAccountStatusEnum) to high(TFhirAccountStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirRequestResourceTypesEnumListAsInteger(aSet : TFhirRequestResourceTypesEnumList) : Integer;
var
  a : TFhirRequestResourceTypesEnum;
begin
  result := 0;
  for a := low(TFhirRequestResourceTypesEnum) to high(TFhirRequestResourceTypesEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirRequestResourceTypesEnumList(i : Integer) : TFhirRequestResourceTypesEnumList;
var
  aLoop : TFhirRequestResourceTypesEnum;
begin
  result := [];
  for aLoop := low(TFhirRequestResourceTypesEnum) to high(TFhirRequestResourceTypesEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirRequestIntentEnumListAsInteger(aSet : TFhirRequestIntentEnumList) : Integer;
var
  a : TFhirRequestIntentEnum;
begin
  result := 0;
  for a := low(TFhirRequestIntentEnum) to high(TFhirRequestIntentEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirRequestIntentEnumList(i : Integer) : TFhirRequestIntentEnumList;
var
  aLoop : TFhirRequestIntentEnum;
begin
  result := [];
  for aLoop := low(TFhirRequestIntentEnum) to high(TFhirRequestIntentEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirRequestPriorityEnumListAsInteger(aSet : TFhirRequestPriorityEnumList) : Integer;
var
  a : TFhirRequestPriorityEnum;
begin
  result := 0;
  for a := low(TFhirRequestPriorityEnum) to high(TFhirRequestPriorityEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirRequestPriorityEnumList(i : Integer) : TFhirRequestPriorityEnumList;
var
  aLoop : TFhirRequestPriorityEnum;
begin
  result := [];
  for aLoop := low(TFhirRequestPriorityEnum) to high(TFhirRequestPriorityEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirActionParticipantTypeEnumListAsInteger(aSet : TFhirActionParticipantTypeEnumList) : Integer;
var
  a : TFhirActionParticipantTypeEnum;
begin
  result := 0;
  for a := low(TFhirActionParticipantTypeEnum) to high(TFhirActionParticipantTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirActionParticipantTypeEnumList(i : Integer) : TFhirActionParticipantTypeEnumList;
var
  aLoop : TFhirActionParticipantTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirActionParticipantTypeEnum) to high(TFhirActionParticipantTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirAdverseEventActualityEnumListAsInteger(aSet : TFhirAdverseEventActualityEnumList) : Integer;
var
  a : TFhirAdverseEventActualityEnum;
begin
  result := 0;
  for a := low(TFhirAdverseEventActualityEnum) to high(TFhirAdverseEventActualityEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirAdverseEventActualityEnumList(i : Integer) : TFhirAdverseEventActualityEnumList;
var
  aLoop : TFhirAdverseEventActualityEnum;
begin
  result := [];
  for aLoop := low(TFhirAdverseEventActualityEnum) to high(TFhirAdverseEventActualityEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirAllergyIntoleranceTypeEnumListAsInteger(aSet : TFhirAllergyIntoleranceTypeEnumList) : Integer;
var
  a : TFhirAllergyIntoleranceTypeEnum;
begin
  result := 0;
  for a := low(TFhirAllergyIntoleranceTypeEnum) to high(TFhirAllergyIntoleranceTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirAllergyIntoleranceTypeEnumList(i : Integer) : TFhirAllergyIntoleranceTypeEnumList;
var
  aLoop : TFhirAllergyIntoleranceTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirAllergyIntoleranceTypeEnum) to high(TFhirAllergyIntoleranceTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirAllergyIntoleranceCategoryEnumListAsInteger(aSet : TFhirAllergyIntoleranceCategoryEnumList) : Integer;
var
  a : TFhirAllergyIntoleranceCategoryEnum;
begin
  result := 0;
  for a := low(TFhirAllergyIntoleranceCategoryEnum) to high(TFhirAllergyIntoleranceCategoryEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirAllergyIntoleranceCategoryEnumList(i : Integer) : TFhirAllergyIntoleranceCategoryEnumList;
var
  aLoop : TFhirAllergyIntoleranceCategoryEnum;
begin
  result := [];
  for aLoop := low(TFhirAllergyIntoleranceCategoryEnum) to high(TFhirAllergyIntoleranceCategoryEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirAllergyIntoleranceCriticalityEnumListAsInteger(aSet : TFhirAllergyIntoleranceCriticalityEnumList) : Integer;
var
  a : TFhirAllergyIntoleranceCriticalityEnum;
begin
  result := 0;
  for a := low(TFhirAllergyIntoleranceCriticalityEnum) to high(TFhirAllergyIntoleranceCriticalityEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirAllergyIntoleranceCriticalityEnumList(i : Integer) : TFhirAllergyIntoleranceCriticalityEnumList;
var
  aLoop : TFhirAllergyIntoleranceCriticalityEnum;
begin
  result := [];
  for aLoop := low(TFhirAllergyIntoleranceCriticalityEnum) to high(TFhirAllergyIntoleranceCriticalityEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirReactionEventSeverityEnumListAsInteger(aSet : TFhirReactionEventSeverityEnumList) : Integer;
var
  a : TFhirReactionEventSeverityEnum;
begin
  result := 0;
  for a := low(TFhirReactionEventSeverityEnum) to high(TFhirReactionEventSeverityEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirReactionEventSeverityEnumList(i : Integer) : TFhirReactionEventSeverityEnumList;
var
  aLoop : TFhirReactionEventSeverityEnum;
begin
  result := [];
  for aLoop := low(TFhirReactionEventSeverityEnum) to high(TFhirReactionEventSeverityEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirAppointmentstatusEnumListAsInteger(aSet : TFhirAppointmentstatusEnumList) : Integer;
var
  a : TFhirAppointmentstatusEnum;
begin
  result := 0;
  for a := low(TFhirAppointmentstatusEnum) to high(TFhirAppointmentstatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirAppointmentstatusEnumList(i : Integer) : TFhirAppointmentstatusEnumList;
var
  aLoop : TFhirAppointmentstatusEnum;
begin
  result := [];
  for aLoop := low(TFhirAppointmentstatusEnum) to high(TFhirAppointmentstatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirParticipantrequiredEnumListAsInteger(aSet : TFhirParticipantrequiredEnumList) : Integer;
var
  a : TFhirParticipantrequiredEnum;
begin
  result := 0;
  for a := low(TFhirParticipantrequiredEnum) to high(TFhirParticipantrequiredEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirParticipantrequiredEnumList(i : Integer) : TFhirParticipantrequiredEnumList;
var
  aLoop : TFhirParticipantrequiredEnum;
begin
  result := [];
  for aLoop := low(TFhirParticipantrequiredEnum) to high(TFhirParticipantrequiredEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirParticipationstatusEnumListAsInteger(aSet : TFhirParticipationstatusEnumList) : Integer;
var
  a : TFhirParticipationstatusEnum;
begin
  result := 0;
  for a := low(TFhirParticipationstatusEnum) to high(TFhirParticipationstatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirParticipationstatusEnumList(i : Integer) : TFhirParticipationstatusEnumList;
var
  aLoop : TFhirParticipationstatusEnum;
begin
  result := [];
  for aLoop := low(TFhirParticipationstatusEnum) to high(TFhirParticipationstatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirAuditEventActionEnumListAsInteger(aSet : TFhirAuditEventActionEnumList) : Integer;
var
  a : TFhirAuditEventActionEnum;
begin
  result := 0;
  for a := low(TFhirAuditEventActionEnum) to high(TFhirAuditEventActionEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirAuditEventActionEnumList(i : Integer) : TFhirAuditEventActionEnumList;
var
  aLoop : TFhirAuditEventActionEnum;
begin
  result := [];
  for aLoop := low(TFhirAuditEventActionEnum) to high(TFhirAuditEventActionEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirAuditEventOutcomeEnumListAsInteger(aSet : TFhirAuditEventOutcomeEnumList) : Integer;
var
  a : TFhirAuditEventOutcomeEnum;
begin
  result := 0;
  for a := low(TFhirAuditEventOutcomeEnum) to high(TFhirAuditEventOutcomeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirAuditEventOutcomeEnumList(i : Integer) : TFhirAuditEventOutcomeEnumList;
var
  aLoop : TFhirAuditEventOutcomeEnum;
begin
  result := [];
  for aLoop := low(TFhirAuditEventOutcomeEnum) to high(TFhirAuditEventOutcomeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirNetworkTypeEnumListAsInteger(aSet : TFhirNetworkTypeEnumList) : Integer;
var
  a : TFhirNetworkTypeEnum;
begin
  result := 0;
  for a := low(TFhirNetworkTypeEnum) to high(TFhirNetworkTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirNetworkTypeEnumList(i : Integer) : TFhirNetworkTypeEnumList;
var
  aLoop : TFhirNetworkTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirNetworkTypeEnum) to high(TFhirNetworkTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirProductCategoryEnumListAsInteger(aSet : TFhirProductCategoryEnumList) : Integer;
var
  a : TFhirProductCategoryEnum;
begin
  result := 0;
  for a := low(TFhirProductCategoryEnum) to high(TFhirProductCategoryEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirProductCategoryEnumList(i : Integer) : TFhirProductCategoryEnumList;
var
  aLoop : TFhirProductCategoryEnum;
begin
  result := [];
  for aLoop := low(TFhirProductCategoryEnum) to high(TFhirProductCategoryEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirProductStatusEnumListAsInteger(aSet : TFhirProductStatusEnumList) : Integer;
var
  a : TFhirProductStatusEnum;
begin
  result := 0;
  for a := low(TFhirProductStatusEnum) to high(TFhirProductStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirProductStatusEnumList(i : Integer) : TFhirProductStatusEnumList;
var
  aLoop : TFhirProductStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirProductStatusEnum) to high(TFhirProductStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirProductStorageScaleEnumListAsInteger(aSet : TFhirProductStorageScaleEnumList) : Integer;
var
  a : TFhirProductStorageScaleEnum;
begin
  result := 0;
  for a := low(TFhirProductStorageScaleEnum) to high(TFhirProductStorageScaleEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirProductStorageScaleEnumList(i : Integer) : TFhirProductStorageScaleEnumList;
var
  aLoop : TFhirProductStorageScaleEnum;
begin
  result := [];
  for aLoop := low(TFhirProductStorageScaleEnum) to high(TFhirProductStorageScaleEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirBundleTypeEnumListAsInteger(aSet : TFhirBundleTypeEnumList) : Integer;
var
  a : TFhirBundleTypeEnum;
begin
  result := 0;
  for a := low(TFhirBundleTypeEnum) to high(TFhirBundleTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirBundleTypeEnumList(i : Integer) : TFhirBundleTypeEnumList;
var
  aLoop : TFhirBundleTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirBundleTypeEnum) to high(TFhirBundleTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirSearchEntryModeEnumListAsInteger(aSet : TFhirSearchEntryModeEnumList) : Integer;
var
  a : TFhirSearchEntryModeEnum;
begin
  result := 0;
  for a := low(TFhirSearchEntryModeEnum) to high(TFhirSearchEntryModeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirSearchEntryModeEnumList(i : Integer) : TFhirSearchEntryModeEnumList;
var
  aLoop : TFhirSearchEntryModeEnum;
begin
  result := [];
  for aLoop := low(TFhirSearchEntryModeEnum) to high(TFhirSearchEntryModeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirHttpVerbEnumListAsInteger(aSet : TFhirHttpVerbEnumList) : Integer;
var
  a : TFhirHttpVerbEnum;
begin
  result := 0;
  for a := low(TFhirHttpVerbEnum) to high(TFhirHttpVerbEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirHttpVerbEnumList(i : Integer) : TFhirHttpVerbEnumList;
var
  aLoop : TFhirHttpVerbEnum;
begin
  result := [];
  for aLoop := low(TFhirHttpVerbEnum) to high(TFhirHttpVerbEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirCapabilityStatementKindEnumListAsInteger(aSet : TFhirCapabilityStatementKindEnumList) : Integer;
var
  a : TFhirCapabilityStatementKindEnum;
begin
  result := 0;
  for a := low(TFhirCapabilityStatementKindEnum) to high(TFhirCapabilityStatementKindEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirCapabilityStatementKindEnumList(i : Integer) : TFhirCapabilityStatementKindEnumList;
var
  aLoop : TFhirCapabilityStatementKindEnum;
begin
  result := [];
  for aLoop := low(TFhirCapabilityStatementKindEnum) to high(TFhirCapabilityStatementKindEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirFHIRVersionEnumListAsInteger(aSet : TFhirFHIRVersionEnumList) : Integer;
var
  a : TFhirFHIRVersionEnum;
begin
  result := 0;
  for a := low(TFhirFHIRVersionEnum) to high(TFhirFHIRVersionEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirFHIRVersionEnumList(i : Integer) : TFhirFHIRVersionEnumList;
var
  aLoop : TFhirFHIRVersionEnum;
begin
  result := [];
  for aLoop := low(TFhirFHIRVersionEnum) to high(TFhirFHIRVersionEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirRestfulCapabilityModeEnumListAsInteger(aSet : TFhirRestfulCapabilityModeEnumList) : Integer;
var
  a : TFhirRestfulCapabilityModeEnum;
begin
  result := 0;
  for a := low(TFhirRestfulCapabilityModeEnum) to high(TFhirRestfulCapabilityModeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirRestfulCapabilityModeEnumList(i : Integer) : TFhirRestfulCapabilityModeEnumList;
var
  aLoop : TFhirRestfulCapabilityModeEnum;
begin
  result := [];
  for aLoop := low(TFhirRestfulCapabilityModeEnum) to high(TFhirRestfulCapabilityModeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirResourceTypesEnumListAsInteger(aSet : TFhirResourceTypesEnumList) : Integer;
var
  a : TFhirResourceTypesEnum;
begin
  result := 0;
  for a := low(TFhirResourceTypesEnum) to high(TFhirResourceTypesEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirResourceTypesEnumList(i : Integer) : TFhirResourceTypesEnumList;
var
  aLoop : TFhirResourceTypesEnum;
begin
  result := [];
  for aLoop := low(TFhirResourceTypesEnum) to high(TFhirResourceTypesEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirTypeRestfulInteractionEnumListAsInteger(aSet : TFhirTypeRestfulInteractionEnumList) : Integer;
var
  a : TFhirTypeRestfulInteractionEnum;
begin
  result := 0;
  for a := low(TFhirTypeRestfulInteractionEnum) to high(TFhirTypeRestfulInteractionEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirTypeRestfulInteractionEnumList(i : Integer) : TFhirTypeRestfulInteractionEnumList;
var
  aLoop : TFhirTypeRestfulInteractionEnum;
begin
  result := [];
  for aLoop := low(TFhirTypeRestfulInteractionEnum) to high(TFhirTypeRestfulInteractionEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirVersioningPolicyEnumListAsInteger(aSet : TFhirVersioningPolicyEnumList) : Integer;
var
  a : TFhirVersioningPolicyEnum;
begin
  result := 0;
  for a := low(TFhirVersioningPolicyEnum) to high(TFhirVersioningPolicyEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirVersioningPolicyEnumList(i : Integer) : TFhirVersioningPolicyEnumList;
var
  aLoop : TFhirVersioningPolicyEnum;
begin
  result := [];
  for aLoop := low(TFhirVersioningPolicyEnum) to high(TFhirVersioningPolicyEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirConditionalReadStatusEnumListAsInteger(aSet : TFhirConditionalReadStatusEnumList) : Integer;
var
  a : TFhirConditionalReadStatusEnum;
begin
  result := 0;
  for a := low(TFhirConditionalReadStatusEnum) to high(TFhirConditionalReadStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirConditionalReadStatusEnumList(i : Integer) : TFhirConditionalReadStatusEnumList;
var
  aLoop : TFhirConditionalReadStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirConditionalReadStatusEnum) to high(TFhirConditionalReadStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirConditionalDeleteStatusEnumListAsInteger(aSet : TFhirConditionalDeleteStatusEnumList) : Integer;
var
  a : TFhirConditionalDeleteStatusEnum;
begin
  result := 0;
  for a := low(TFhirConditionalDeleteStatusEnum) to high(TFhirConditionalDeleteStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirConditionalDeleteStatusEnumList(i : Integer) : TFhirConditionalDeleteStatusEnumList;
var
  aLoop : TFhirConditionalDeleteStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirConditionalDeleteStatusEnum) to high(TFhirConditionalDeleteStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirReferenceHandlingPolicyEnumListAsInteger(aSet : TFhirReferenceHandlingPolicyEnumList) : Integer;
var
  a : TFhirReferenceHandlingPolicyEnum;
begin
  result := 0;
  for a := low(TFhirReferenceHandlingPolicyEnum) to high(TFhirReferenceHandlingPolicyEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirReferenceHandlingPolicyEnumList(i : Integer) : TFhirReferenceHandlingPolicyEnumList;
var
  aLoop : TFhirReferenceHandlingPolicyEnum;
begin
  result := [];
  for aLoop := low(TFhirReferenceHandlingPolicyEnum) to high(TFhirReferenceHandlingPolicyEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirSearchParamTypeEnumListAsInteger(aSet : TFhirSearchParamTypeEnumList) : Integer;
var
  a : TFhirSearchParamTypeEnum;
begin
  result := 0;
  for a := low(TFhirSearchParamTypeEnum) to high(TFhirSearchParamTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirSearchParamTypeEnumList(i : Integer) : TFhirSearchParamTypeEnumList;
var
  aLoop : TFhirSearchParamTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirSearchParamTypeEnum) to high(TFhirSearchParamTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirSystemRestfulInteractionEnumListAsInteger(aSet : TFhirSystemRestfulInteractionEnumList) : Integer;
var
  a : TFhirSystemRestfulInteractionEnum;
begin
  result := 0;
  for a := low(TFhirSystemRestfulInteractionEnum) to high(TFhirSystemRestfulInteractionEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirSystemRestfulInteractionEnumList(i : Integer) : TFhirSystemRestfulInteractionEnumList;
var
  aLoop : TFhirSystemRestfulInteractionEnum;
begin
  result := [];
  for aLoop := low(TFhirSystemRestfulInteractionEnum) to high(TFhirSystemRestfulInteractionEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirEventCapabilityModeEnumListAsInteger(aSet : TFhirEventCapabilityModeEnumList) : Integer;
var
  a : TFhirEventCapabilityModeEnum;
begin
  result := 0;
  for a := low(TFhirEventCapabilityModeEnum) to high(TFhirEventCapabilityModeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirEventCapabilityModeEnumList(i : Integer) : TFhirEventCapabilityModeEnumList;
var
  aLoop : TFhirEventCapabilityModeEnum;
begin
  result := [];
  for aLoop := low(TFhirEventCapabilityModeEnum) to high(TFhirEventCapabilityModeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirDocumentModeEnumListAsInteger(aSet : TFhirDocumentModeEnumList) : Integer;
var
  a : TFhirDocumentModeEnum;
begin
  result := 0;
  for a := low(TFhirDocumentModeEnum) to high(TFhirDocumentModeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirDocumentModeEnumList(i : Integer) : TFhirDocumentModeEnumList;
var
  aLoop : TFhirDocumentModeEnum;
begin
  result := [];
  for aLoop := low(TFhirDocumentModeEnum) to high(TFhirDocumentModeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirRequestStatusEnumListAsInteger(aSet : TFhirRequestStatusEnumList) : Integer;
var
  a : TFhirRequestStatusEnum;
begin
  result := 0;
  for a := low(TFhirRequestStatusEnum) to high(TFhirRequestStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirRequestStatusEnumList(i : Integer) : TFhirRequestStatusEnumList;
var
  aLoop : TFhirRequestStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirRequestStatusEnum) to high(TFhirRequestStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirCarePlanIntentEnumListAsInteger(aSet : TFhirCarePlanIntentEnumList) : Integer;
var
  a : TFhirCarePlanIntentEnum;
begin
  result := 0;
  for a := low(TFhirCarePlanIntentEnum) to high(TFhirCarePlanIntentEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirCarePlanIntentEnumList(i : Integer) : TFhirCarePlanIntentEnumList;
var
  aLoop : TFhirCarePlanIntentEnum;
begin
  result := [];
  for aLoop := low(TFhirCarePlanIntentEnum) to high(TFhirCarePlanIntentEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirCarePlanActivityKindEnumListAsInteger(aSet : TFhirCarePlanActivityKindEnumList) : Integer;
var
  a : TFhirCarePlanActivityKindEnum;
begin
  result := 0;
  for a := low(TFhirCarePlanActivityKindEnum) to high(TFhirCarePlanActivityKindEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirCarePlanActivityKindEnumList(i : Integer) : TFhirCarePlanActivityKindEnumList;
var
  aLoop : TFhirCarePlanActivityKindEnum;
begin
  result := [];
  for aLoop := low(TFhirCarePlanActivityKindEnum) to high(TFhirCarePlanActivityKindEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirCarePlanActivityStatusEnumListAsInteger(aSet : TFhirCarePlanActivityStatusEnumList) : Integer;
var
  a : TFhirCarePlanActivityStatusEnum;
begin
  result := 0;
  for a := low(TFhirCarePlanActivityStatusEnum) to high(TFhirCarePlanActivityStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirCarePlanActivityStatusEnumList(i : Integer) : TFhirCarePlanActivityStatusEnumList;
var
  aLoop : TFhirCarePlanActivityStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirCarePlanActivityStatusEnum) to high(TFhirCarePlanActivityStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirCareTeamStatusEnumListAsInteger(aSet : TFhirCareTeamStatusEnumList) : Integer;
var
  a : TFhirCareTeamStatusEnum;
begin
  result := 0;
  for a := low(TFhirCareTeamStatusEnum) to high(TFhirCareTeamStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirCareTeamStatusEnumList(i : Integer) : TFhirCareTeamStatusEnumList;
var
  aLoop : TFhirCareTeamStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirCareTeamStatusEnum) to high(TFhirCareTeamStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirRelationTypeEnumListAsInteger(aSet : TFhirRelationTypeEnumList) : Integer;
var
  a : TFhirRelationTypeEnum;
begin
  result := 0;
  for a := low(TFhirRelationTypeEnum) to high(TFhirRelationTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirRelationTypeEnumList(i : Integer) : TFhirRelationTypeEnumList;
var
  aLoop : TFhirRelationTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirRelationTypeEnum) to high(TFhirRelationTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirChargeitemStatusEnumListAsInteger(aSet : TFhirChargeitemStatusEnumList) : Integer;
var
  a : TFhirChargeitemStatusEnum;
begin
  result := 0;
  for a := low(TFhirChargeitemStatusEnum) to high(TFhirChargeitemStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirChargeitemStatusEnumList(i : Integer) : TFhirChargeitemStatusEnumList;
var
  aLoop : TFhirChargeitemStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirChargeitemStatusEnum) to high(TFhirChargeitemStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirInvoicePriceComponentTypeEnumListAsInteger(aSet : TFhirInvoicePriceComponentTypeEnumList) : Integer;
var
  a : TFhirInvoicePriceComponentTypeEnum;
begin
  result := 0;
  for a := low(TFhirInvoicePriceComponentTypeEnum) to high(TFhirInvoicePriceComponentTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirInvoicePriceComponentTypeEnumList(i : Integer) : TFhirInvoicePriceComponentTypeEnumList;
var
  aLoop : TFhirInvoicePriceComponentTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirInvoicePriceComponentTypeEnum) to high(TFhirInvoicePriceComponentTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirFmStatusEnumListAsInteger(aSet : TFhirFmStatusEnumList) : Integer;
var
  a : TFhirFmStatusEnum;
begin
  result := 0;
  for a := low(TFhirFmStatusEnum) to high(TFhirFmStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirFmStatusEnumList(i : Integer) : TFhirFmStatusEnumList;
var
  aLoop : TFhirFmStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirFmStatusEnum) to high(TFhirFmStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirClaimUseEnumListAsInteger(aSet : TFhirClaimUseEnumList) : Integer;
var
  a : TFhirClaimUseEnum;
begin
  result := 0;
  for a := low(TFhirClaimUseEnum) to high(TFhirClaimUseEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirClaimUseEnumList(i : Integer) : TFhirClaimUseEnumList;
var
  aLoop : TFhirClaimUseEnum;
begin
  result := [];
  for aLoop := low(TFhirClaimUseEnum) to high(TFhirClaimUseEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirRemittanceOutcomeEnumListAsInteger(aSet : TFhirRemittanceOutcomeEnumList) : Integer;
var
  a : TFhirRemittanceOutcomeEnum;
begin
  result := 0;
  for a := low(TFhirRemittanceOutcomeEnum) to high(TFhirRemittanceOutcomeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirRemittanceOutcomeEnumList(i : Integer) : TFhirRemittanceOutcomeEnumList;
var
  aLoop : TFhirRemittanceOutcomeEnum;
begin
  result := [];
  for aLoop := low(TFhirRemittanceOutcomeEnum) to high(TFhirRemittanceOutcomeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirNoteTypeEnumListAsInteger(aSet : TFhirNoteTypeEnumList) : Integer;
var
  a : TFhirNoteTypeEnum;
begin
  result := 0;
  for a := low(TFhirNoteTypeEnum) to high(TFhirNoteTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirNoteTypeEnumList(i : Integer) : TFhirNoteTypeEnumList;
var
  aLoop : TFhirNoteTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirNoteTypeEnum) to high(TFhirNoteTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirClinicalimpressionStatusEnumListAsInteger(aSet : TFhirClinicalimpressionStatusEnumList) : Integer;
var
  a : TFhirClinicalimpressionStatusEnum;
begin
  result := 0;
  for a := low(TFhirClinicalimpressionStatusEnum) to high(TFhirClinicalimpressionStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirClinicalimpressionStatusEnumList(i : Integer) : TFhirClinicalimpressionStatusEnumList;
var
  aLoop : TFhirClinicalimpressionStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirClinicalimpressionStatusEnum) to high(TFhirClinicalimpressionStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirCodesystemHierarchyMeaningEnumListAsInteger(aSet : TFhirCodesystemHierarchyMeaningEnumList) : Integer;
var
  a : TFhirCodesystemHierarchyMeaningEnum;
begin
  result := 0;
  for a := low(TFhirCodesystemHierarchyMeaningEnum) to high(TFhirCodesystemHierarchyMeaningEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirCodesystemHierarchyMeaningEnumList(i : Integer) : TFhirCodesystemHierarchyMeaningEnumList;
var
  aLoop : TFhirCodesystemHierarchyMeaningEnum;
begin
  result := [];
  for aLoop := low(TFhirCodesystemHierarchyMeaningEnum) to high(TFhirCodesystemHierarchyMeaningEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirCodesystemContentModeEnumListAsInteger(aSet : TFhirCodesystemContentModeEnumList) : Integer;
var
  a : TFhirCodesystemContentModeEnum;
begin
  result := 0;
  for a := low(TFhirCodesystemContentModeEnum) to high(TFhirCodesystemContentModeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirCodesystemContentModeEnumList(i : Integer) : TFhirCodesystemContentModeEnumList;
var
  aLoop : TFhirCodesystemContentModeEnum;
begin
  result := [];
  for aLoop := low(TFhirCodesystemContentModeEnum) to high(TFhirCodesystemContentModeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirFilterOperatorEnumListAsInteger(aSet : TFhirFilterOperatorEnumList) : Integer;
var
  a : TFhirFilterOperatorEnum;
begin
  result := 0;
  for a := low(TFhirFilterOperatorEnum) to high(TFhirFilterOperatorEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirFilterOperatorEnumList(i : Integer) : TFhirFilterOperatorEnumList;
var
  aLoop : TFhirFilterOperatorEnum;
begin
  result := [];
  for aLoop := low(TFhirFilterOperatorEnum) to high(TFhirFilterOperatorEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirConceptPropertyTypeEnumListAsInteger(aSet : TFhirConceptPropertyTypeEnumList) : Integer;
var
  a : TFhirConceptPropertyTypeEnum;
begin
  result := 0;
  for a := low(TFhirConceptPropertyTypeEnum) to high(TFhirConceptPropertyTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirConceptPropertyTypeEnumList(i : Integer) : TFhirConceptPropertyTypeEnumList;
var
  aLoop : TFhirConceptPropertyTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirConceptPropertyTypeEnum) to high(TFhirConceptPropertyTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirEventStatusEnumListAsInteger(aSet : TFhirEventStatusEnumList) : Integer;
var
  a : TFhirEventStatusEnum;
begin
  result := 0;
  for a := low(TFhirEventStatusEnum) to high(TFhirEventStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirEventStatusEnumList(i : Integer) : TFhirEventStatusEnumList;
var
  aLoop : TFhirEventStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirEventStatusEnum) to high(TFhirEventStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirCompartmentTypeEnumListAsInteger(aSet : TFhirCompartmentTypeEnumList) : Integer;
var
  a : TFhirCompartmentTypeEnum;
begin
  result := 0;
  for a := low(TFhirCompartmentTypeEnum) to high(TFhirCompartmentTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirCompartmentTypeEnumList(i : Integer) : TFhirCompartmentTypeEnumList;
var
  aLoop : TFhirCompartmentTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirCompartmentTypeEnum) to high(TFhirCompartmentTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirCompositionStatusEnumListAsInteger(aSet : TFhirCompositionStatusEnumList) : Integer;
var
  a : TFhirCompositionStatusEnum;
begin
  result := 0;
  for a := low(TFhirCompositionStatusEnum) to high(TFhirCompositionStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirCompositionStatusEnumList(i : Integer) : TFhirCompositionStatusEnumList;
var
  aLoop : TFhirCompositionStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirCompositionStatusEnum) to high(TFhirCompositionStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirV3ConfidentialityClassificationEnumListAsInteger(aSet : TFhirV3ConfidentialityClassificationEnumList) : Integer;
var
  a : TFhirV3ConfidentialityClassificationEnum;
begin
  result := 0;
  for a := low(TFhirV3ConfidentialityClassificationEnum) to high(TFhirV3ConfidentialityClassificationEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirV3ConfidentialityClassificationEnumList(i : Integer) : TFhirV3ConfidentialityClassificationEnumList;
var
  aLoop : TFhirV3ConfidentialityClassificationEnum;
begin
  result := [];
  for aLoop := low(TFhirV3ConfidentialityClassificationEnum) to high(TFhirV3ConfidentialityClassificationEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirCompositionAttestationModeEnumListAsInteger(aSet : TFhirCompositionAttestationModeEnumList) : Integer;
var
  a : TFhirCompositionAttestationModeEnum;
begin
  result := 0;
  for a := low(TFhirCompositionAttestationModeEnum) to high(TFhirCompositionAttestationModeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirCompositionAttestationModeEnumList(i : Integer) : TFhirCompositionAttestationModeEnumList;
var
  aLoop : TFhirCompositionAttestationModeEnum;
begin
  result := [];
  for aLoop := low(TFhirCompositionAttestationModeEnum) to high(TFhirCompositionAttestationModeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirDocumentRelationshipTypeEnumListAsInteger(aSet : TFhirDocumentRelationshipTypeEnumList) : Integer;
var
  a : TFhirDocumentRelationshipTypeEnum;
begin
  result := 0;
  for a := low(TFhirDocumentRelationshipTypeEnum) to high(TFhirDocumentRelationshipTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirDocumentRelationshipTypeEnumList(i : Integer) : TFhirDocumentRelationshipTypeEnumList;
var
  aLoop : TFhirDocumentRelationshipTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirDocumentRelationshipTypeEnum) to high(TFhirDocumentRelationshipTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirListModeEnumListAsInteger(aSet : TFhirListModeEnumList) : Integer;
var
  a : TFhirListModeEnum;
begin
  result := 0;
  for a := low(TFhirListModeEnum) to high(TFhirListModeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirListModeEnumList(i : Integer) : TFhirListModeEnumList;
var
  aLoop : TFhirListModeEnum;
begin
  result := [];
  for aLoop := low(TFhirListModeEnum) to high(TFhirListModeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirConceptMapEquivalenceEnumListAsInteger(aSet : TFhirConceptMapEquivalenceEnumList) : Integer;
var
  a : TFhirConceptMapEquivalenceEnum;
begin
  result := 0;
  for a := low(TFhirConceptMapEquivalenceEnum) to high(TFhirConceptMapEquivalenceEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirConceptMapEquivalenceEnumList(i : Integer) : TFhirConceptMapEquivalenceEnumList;
var
  aLoop : TFhirConceptMapEquivalenceEnum;
begin
  result := [];
  for aLoop := low(TFhirConceptMapEquivalenceEnum) to high(TFhirConceptMapEquivalenceEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirConceptmapUnmappedModeEnumListAsInteger(aSet : TFhirConceptmapUnmappedModeEnumList) : Integer;
var
  a : TFhirConceptmapUnmappedModeEnum;
begin
  result := 0;
  for a := low(TFhirConceptmapUnmappedModeEnum) to high(TFhirConceptmapUnmappedModeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirConceptmapUnmappedModeEnumList(i : Integer) : TFhirConceptmapUnmappedModeEnumList;
var
  aLoop : TFhirConceptmapUnmappedModeEnum;
begin
  result := [];
  for aLoop := low(TFhirConceptmapUnmappedModeEnum) to high(TFhirConceptmapUnmappedModeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirConsentStateCodesEnumListAsInteger(aSet : TFhirConsentStateCodesEnumList) : Integer;
var
  a : TFhirConsentStateCodesEnum;
begin
  result := 0;
  for a := low(TFhirConsentStateCodesEnum) to high(TFhirConsentStateCodesEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirConsentStateCodesEnumList(i : Integer) : TFhirConsentStateCodesEnumList;
var
  aLoop : TFhirConsentStateCodesEnum;
begin
  result := [];
  for aLoop := low(TFhirConsentStateCodesEnum) to high(TFhirConsentStateCodesEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirConsentProvisionTypeEnumListAsInteger(aSet : TFhirConsentProvisionTypeEnumList) : Integer;
var
  a : TFhirConsentProvisionTypeEnum;
begin
  result := 0;
  for a := low(TFhirConsentProvisionTypeEnum) to high(TFhirConsentProvisionTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirConsentProvisionTypeEnumList(i : Integer) : TFhirConsentProvisionTypeEnumList;
var
  aLoop : TFhirConsentProvisionTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirConsentProvisionTypeEnum) to high(TFhirConsentProvisionTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirConsentDataMeaningEnumListAsInteger(aSet : TFhirConsentDataMeaningEnumList) : Integer;
var
  a : TFhirConsentDataMeaningEnum;
begin
  result := 0;
  for a := low(TFhirConsentDataMeaningEnum) to high(TFhirConsentDataMeaningEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirConsentDataMeaningEnumList(i : Integer) : TFhirConsentDataMeaningEnumList;
var
  aLoop : TFhirConsentDataMeaningEnum;
begin
  result := [];
  for aLoop := low(TFhirConsentDataMeaningEnum) to high(TFhirConsentDataMeaningEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirContractStatusEnumListAsInteger(aSet : TFhirContractStatusEnumList) : Integer;
var
  a : TFhirContractStatusEnum;
begin
  result := 0;
  for a := low(TFhirContractStatusEnum) to high(TFhirContractStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirContractStatusEnumList(i : Integer) : TFhirContractStatusEnumList;
var
  aLoop : TFhirContractStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirContractStatusEnum) to high(TFhirContractStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirContractPublicationstatusEnumListAsInteger(aSet : TFhirContractPublicationstatusEnumList) : Integer;
var
  a : TFhirContractPublicationstatusEnum;
begin
  result := 0;
  for a := low(TFhirContractPublicationstatusEnum) to high(TFhirContractPublicationstatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirContractPublicationstatusEnumList(i : Integer) : TFhirContractPublicationstatusEnumList;
var
  aLoop : TFhirContractPublicationstatusEnum;
begin
  result := [];
  for aLoop := low(TFhirContractPublicationstatusEnum) to high(TFhirContractPublicationstatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirEligibilityrequestPurposeEnumListAsInteger(aSet : TFhirEligibilityrequestPurposeEnumList) : Integer;
var
  a : TFhirEligibilityrequestPurposeEnum;
begin
  result := 0;
  for a := low(TFhirEligibilityrequestPurposeEnum) to high(TFhirEligibilityrequestPurposeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirEligibilityrequestPurposeEnumList(i : Integer) : TFhirEligibilityrequestPurposeEnumList;
var
  aLoop : TFhirEligibilityrequestPurposeEnum;
begin
  result := [];
  for aLoop := low(TFhirEligibilityrequestPurposeEnum) to high(TFhirEligibilityrequestPurposeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirEligibilityresponsePurposeEnumListAsInteger(aSet : TFhirEligibilityresponsePurposeEnumList) : Integer;
var
  a : TFhirEligibilityresponsePurposeEnum;
begin
  result := 0;
  for a := low(TFhirEligibilityresponsePurposeEnum) to high(TFhirEligibilityresponsePurposeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirEligibilityresponsePurposeEnumList(i : Integer) : TFhirEligibilityresponsePurposeEnumList;
var
  aLoop : TFhirEligibilityresponsePurposeEnum;
begin
  result := [];
  for aLoop := low(TFhirEligibilityresponsePurposeEnum) to high(TFhirEligibilityresponsePurposeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirObservationStatusEnumListAsInteger(aSet : TFhirObservationStatusEnumList) : Integer;
var
  a : TFhirObservationStatusEnum;
begin
  result := 0;
  for a := low(TFhirObservationStatusEnum) to high(TFhirObservationStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirObservationStatusEnumList(i : Integer) : TFhirObservationStatusEnumList;
var
  aLoop : TFhirObservationStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirObservationStatusEnum) to high(TFhirObservationStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirDetectedissueSeverityEnumListAsInteger(aSet : TFhirDetectedissueSeverityEnumList) : Integer;
var
  a : TFhirDetectedissueSeverityEnum;
begin
  result := 0;
  for a := low(TFhirDetectedissueSeverityEnum) to high(TFhirDetectedissueSeverityEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirDetectedissueSeverityEnumList(i : Integer) : TFhirDetectedissueSeverityEnumList;
var
  aLoop : TFhirDetectedissueSeverityEnum;
begin
  result := [];
  for aLoop := low(TFhirDetectedissueSeverityEnum) to high(TFhirDetectedissueSeverityEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirUdiEntryTypeEnumListAsInteger(aSet : TFhirUdiEntryTypeEnumList) : Integer;
var
  a : TFhirUdiEntryTypeEnum;
begin
  result := 0;
  for a := low(TFhirUdiEntryTypeEnum) to high(TFhirUdiEntryTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirUdiEntryTypeEnumList(i : Integer) : TFhirUdiEntryTypeEnumList;
var
  aLoop : TFhirUdiEntryTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirUdiEntryTypeEnum) to high(TFhirUdiEntryTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirDeviceStatusEnumListAsInteger(aSet : TFhirDeviceStatusEnumList) : Integer;
var
  a : TFhirDeviceStatusEnum;
begin
  result := 0;
  for a := low(TFhirDeviceStatusEnum) to high(TFhirDeviceStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirDeviceStatusEnumList(i : Integer) : TFhirDeviceStatusEnumList;
var
  aLoop : TFhirDeviceStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirDeviceStatusEnum) to high(TFhirDeviceStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirDeviceNametypeEnumListAsInteger(aSet : TFhirDeviceNametypeEnumList) : Integer;
var
  a : TFhirDeviceNametypeEnum;
begin
  result := 0;
  for a := low(TFhirDeviceNametypeEnum) to high(TFhirDeviceNametypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirDeviceNametypeEnumList(i : Integer) : TFhirDeviceNametypeEnumList;
var
  aLoop : TFhirDeviceNametypeEnum;
begin
  result := [];
  for aLoop := low(TFhirDeviceNametypeEnum) to high(TFhirDeviceNametypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirMetricOperationalStatusEnumListAsInteger(aSet : TFhirMetricOperationalStatusEnumList) : Integer;
var
  a : TFhirMetricOperationalStatusEnum;
begin
  result := 0;
  for a := low(TFhirMetricOperationalStatusEnum) to high(TFhirMetricOperationalStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirMetricOperationalStatusEnumList(i : Integer) : TFhirMetricOperationalStatusEnumList;
var
  aLoop : TFhirMetricOperationalStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirMetricOperationalStatusEnum) to high(TFhirMetricOperationalStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirMetricColorEnumListAsInteger(aSet : TFhirMetricColorEnumList) : Integer;
var
  a : TFhirMetricColorEnum;
begin
  result := 0;
  for a := low(TFhirMetricColorEnum) to high(TFhirMetricColorEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirMetricColorEnumList(i : Integer) : TFhirMetricColorEnumList;
var
  aLoop : TFhirMetricColorEnum;
begin
  result := [];
  for aLoop := low(TFhirMetricColorEnum) to high(TFhirMetricColorEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirMetricCategoryEnumListAsInteger(aSet : TFhirMetricCategoryEnumList) : Integer;
var
  a : TFhirMetricCategoryEnum;
begin
  result := 0;
  for a := low(TFhirMetricCategoryEnum) to high(TFhirMetricCategoryEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirMetricCategoryEnumList(i : Integer) : TFhirMetricCategoryEnumList;
var
  aLoop : TFhirMetricCategoryEnum;
begin
  result := [];
  for aLoop := low(TFhirMetricCategoryEnum) to high(TFhirMetricCategoryEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirMetricCalibrationTypeEnumListAsInteger(aSet : TFhirMetricCalibrationTypeEnumList) : Integer;
var
  a : TFhirMetricCalibrationTypeEnum;
begin
  result := 0;
  for a := low(TFhirMetricCalibrationTypeEnum) to high(TFhirMetricCalibrationTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirMetricCalibrationTypeEnumList(i : Integer) : TFhirMetricCalibrationTypeEnumList;
var
  aLoop : TFhirMetricCalibrationTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirMetricCalibrationTypeEnum) to high(TFhirMetricCalibrationTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirMetricCalibrationStateEnumListAsInteger(aSet : TFhirMetricCalibrationStateEnumList) : Integer;
var
  a : TFhirMetricCalibrationStateEnum;
begin
  result := 0;
  for a := low(TFhirMetricCalibrationStateEnum) to high(TFhirMetricCalibrationStateEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirMetricCalibrationStateEnumList(i : Integer) : TFhirMetricCalibrationStateEnumList;
var
  aLoop : TFhirMetricCalibrationStateEnum;
begin
  result := [];
  for aLoop := low(TFhirMetricCalibrationStateEnum) to high(TFhirMetricCalibrationStateEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirDeviceStatementStatusEnumListAsInteger(aSet : TFhirDeviceStatementStatusEnumList) : Integer;
var
  a : TFhirDeviceStatementStatusEnum;
begin
  result := 0;
  for a := low(TFhirDeviceStatementStatusEnum) to high(TFhirDeviceStatementStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirDeviceStatementStatusEnumList(i : Integer) : TFhirDeviceStatementStatusEnumList;
var
  aLoop : TFhirDeviceStatementStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirDeviceStatementStatusEnum) to high(TFhirDeviceStatementStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirDiagnosticReportStatusEnumListAsInteger(aSet : TFhirDiagnosticReportStatusEnumList) : Integer;
var
  a : TFhirDiagnosticReportStatusEnum;
begin
  result := 0;
  for a := low(TFhirDiagnosticReportStatusEnum) to high(TFhirDiagnosticReportStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirDiagnosticReportStatusEnumList(i : Integer) : TFhirDiagnosticReportStatusEnumList;
var
  aLoop : TFhirDiagnosticReportStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirDiagnosticReportStatusEnum) to high(TFhirDiagnosticReportStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirDocumentReferenceStatusEnumListAsInteger(aSet : TFhirDocumentReferenceStatusEnumList) : Integer;
var
  a : TFhirDocumentReferenceStatusEnum;
begin
  result := 0;
  for a := low(TFhirDocumentReferenceStatusEnum) to high(TFhirDocumentReferenceStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirDocumentReferenceStatusEnumList(i : Integer) : TFhirDocumentReferenceStatusEnumList;
var
  aLoop : TFhirDocumentReferenceStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirDocumentReferenceStatusEnum) to high(TFhirDocumentReferenceStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirExposureStateEnumListAsInteger(aSet : TFhirExposureStateEnumList) : Integer;
var
  a : TFhirExposureStateEnum;
begin
  result := 0;
  for a := low(TFhirExposureStateEnum) to high(TFhirExposureStateEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirExposureStateEnumList(i : Integer) : TFhirExposureStateEnumList;
var
  aLoop : TFhirExposureStateEnum;
begin
  result := [];
  for aLoop := low(TFhirExposureStateEnum) to high(TFhirExposureStateEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirEncounterStatusEnumListAsInteger(aSet : TFhirEncounterStatusEnumList) : Integer;
var
  a : TFhirEncounterStatusEnum;
begin
  result := 0;
  for a := low(TFhirEncounterStatusEnum) to high(TFhirEncounterStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirEncounterStatusEnumList(i : Integer) : TFhirEncounterStatusEnumList;
var
  aLoop : TFhirEncounterStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirEncounterStatusEnum) to high(TFhirEncounterStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirEncounterLocationStatusEnumListAsInteger(aSet : TFhirEncounterLocationStatusEnumList) : Integer;
var
  a : TFhirEncounterLocationStatusEnum;
begin
  result := 0;
  for a := low(TFhirEncounterLocationStatusEnum) to high(TFhirEncounterLocationStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirEncounterLocationStatusEnumList(i : Integer) : TFhirEncounterLocationStatusEnumList;
var
  aLoop : TFhirEncounterLocationStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirEncounterLocationStatusEnum) to high(TFhirEncounterLocationStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirEndpointStatusEnumListAsInteger(aSet : TFhirEndpointStatusEnumList) : Integer;
var
  a : TFhirEndpointStatusEnum;
begin
  result := 0;
  for a := low(TFhirEndpointStatusEnum) to high(TFhirEndpointStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirEndpointStatusEnumList(i : Integer) : TFhirEndpointStatusEnumList;
var
  aLoop : TFhirEndpointStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirEndpointStatusEnum) to high(TFhirEndpointStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirEpisodeOfCareStatusEnumListAsInteger(aSet : TFhirEpisodeOfCareStatusEnumList) : Integer;
var
  a : TFhirEpisodeOfCareStatusEnum;
begin
  result := 0;
  for a := low(TFhirEpisodeOfCareStatusEnum) to high(TFhirEpisodeOfCareStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirEpisodeOfCareStatusEnumList(i : Integer) : TFhirEpisodeOfCareStatusEnumList;
var
  aLoop : TFhirEpisodeOfCareStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirEpisodeOfCareStatusEnum) to high(TFhirEpisodeOfCareStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirVariableTypeEnumListAsInteger(aSet : TFhirVariableTypeEnumList) : Integer;
var
  a : TFhirVariableTypeEnum;
begin
  result := 0;
  for a := low(TFhirVariableTypeEnum) to high(TFhirVariableTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirVariableTypeEnumList(i : Integer) : TFhirVariableTypeEnumList;
var
  aLoop : TFhirVariableTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirVariableTypeEnum) to high(TFhirVariableTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirGroupMeasureEnumListAsInteger(aSet : TFhirGroupMeasureEnumList) : Integer;
var
  a : TFhirGroupMeasureEnum;
begin
  result := 0;
  for a := low(TFhirGroupMeasureEnum) to high(TFhirGroupMeasureEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirGroupMeasureEnumList(i : Integer) : TFhirGroupMeasureEnumList;
var
  aLoop : TFhirGroupMeasureEnum;
begin
  result := [];
  for aLoop := low(TFhirGroupMeasureEnum) to high(TFhirGroupMeasureEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirExamplescenarioActorTypeEnumListAsInteger(aSet : TFhirExamplescenarioActorTypeEnumList) : Integer;
var
  a : TFhirExamplescenarioActorTypeEnum;
begin
  result := 0;
  for a := low(TFhirExamplescenarioActorTypeEnum) to high(TFhirExamplescenarioActorTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirExamplescenarioActorTypeEnumList(i : Integer) : TFhirExamplescenarioActorTypeEnumList;
var
  aLoop : TFhirExamplescenarioActorTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirExamplescenarioActorTypeEnum) to high(TFhirExamplescenarioActorTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirExplanationofbenefitStatusEnumListAsInteger(aSet : TFhirExplanationofbenefitStatusEnumList) : Integer;
var
  a : TFhirExplanationofbenefitStatusEnum;
begin
  result := 0;
  for a := low(TFhirExplanationofbenefitStatusEnum) to high(TFhirExplanationofbenefitStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirExplanationofbenefitStatusEnumList(i : Integer) : TFhirExplanationofbenefitStatusEnumList;
var
  aLoop : TFhirExplanationofbenefitStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirExplanationofbenefitStatusEnum) to high(TFhirExplanationofbenefitStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirHistoryStatusEnumListAsInteger(aSet : TFhirHistoryStatusEnumList) : Integer;
var
  a : TFhirHistoryStatusEnum;
begin
  result := 0;
  for a := low(TFhirHistoryStatusEnum) to high(TFhirHistoryStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirHistoryStatusEnumList(i : Integer) : TFhirHistoryStatusEnumList;
var
  aLoop : TFhirHistoryStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirHistoryStatusEnum) to high(TFhirHistoryStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirFlagStatusEnumListAsInteger(aSet : TFhirFlagStatusEnumList) : Integer;
var
  a : TFhirFlagStatusEnum;
begin
  result := 0;
  for a := low(TFhirFlagStatusEnum) to high(TFhirFlagStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirFlagStatusEnumList(i : Integer) : TFhirFlagStatusEnumList;
var
  aLoop : TFhirFlagStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirFlagStatusEnum) to high(TFhirFlagStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirGoalStatusEnumListAsInteger(aSet : TFhirGoalStatusEnumList) : Integer;
var
  a : TFhirGoalStatusEnum;
begin
  result := 0;
  for a := low(TFhirGoalStatusEnum) to high(TFhirGoalStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirGoalStatusEnumList(i : Integer) : TFhirGoalStatusEnumList;
var
  aLoop : TFhirGoalStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirGoalStatusEnum) to high(TFhirGoalStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirGraphCompartmentUseEnumListAsInteger(aSet : TFhirGraphCompartmentUseEnumList) : Integer;
var
  a : TFhirGraphCompartmentUseEnum;
begin
  result := 0;
  for a := low(TFhirGraphCompartmentUseEnum) to high(TFhirGraphCompartmentUseEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirGraphCompartmentUseEnumList(i : Integer) : TFhirGraphCompartmentUseEnumList;
var
  aLoop : TFhirGraphCompartmentUseEnum;
begin
  result := [];
  for aLoop := low(TFhirGraphCompartmentUseEnum) to high(TFhirGraphCompartmentUseEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirGraphCompartmentRuleEnumListAsInteger(aSet : TFhirGraphCompartmentRuleEnumList) : Integer;
var
  a : TFhirGraphCompartmentRuleEnum;
begin
  result := 0;
  for a := low(TFhirGraphCompartmentRuleEnum) to high(TFhirGraphCompartmentRuleEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirGraphCompartmentRuleEnumList(i : Integer) : TFhirGraphCompartmentRuleEnumList;
var
  aLoop : TFhirGraphCompartmentRuleEnum;
begin
  result := [];
  for aLoop := low(TFhirGraphCompartmentRuleEnum) to high(TFhirGraphCompartmentRuleEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirGroupTypeEnumListAsInteger(aSet : TFhirGroupTypeEnumList) : Integer;
var
  a : TFhirGroupTypeEnum;
begin
  result := 0;
  for a := low(TFhirGroupTypeEnum) to high(TFhirGroupTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirGroupTypeEnumList(i : Integer) : TFhirGroupTypeEnumList;
var
  aLoop : TFhirGroupTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirGroupTypeEnum) to high(TFhirGroupTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirGuidanceResponseStatusEnumListAsInteger(aSet : TFhirGuidanceResponseStatusEnumList) : Integer;
var
  a : TFhirGuidanceResponseStatusEnum;
begin
  result := 0;
  for a := low(TFhirGuidanceResponseStatusEnum) to high(TFhirGuidanceResponseStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirGuidanceResponseStatusEnumList(i : Integer) : TFhirGuidanceResponseStatusEnumList;
var
  aLoop : TFhirGuidanceResponseStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirGuidanceResponseStatusEnum) to high(TFhirGuidanceResponseStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirImagingstudyStatusEnumListAsInteger(aSet : TFhirImagingstudyStatusEnumList) : Integer;
var
  a : TFhirImagingstudyStatusEnum;
begin
  result := 0;
  for a := low(TFhirImagingstudyStatusEnum) to high(TFhirImagingstudyStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirImagingstudyStatusEnumList(i : Integer) : TFhirImagingstudyStatusEnumList;
var
  aLoop : TFhirImagingstudyStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirImagingstudyStatusEnum) to high(TFhirImagingstudyStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirImmunizationStatusEnumListAsInteger(aSet : TFhirImmunizationStatusEnumList) : Integer;
var
  a : TFhirImmunizationStatusEnum;
begin
  result := 0;
  for a := low(TFhirImmunizationStatusEnum) to high(TFhirImmunizationStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirImmunizationStatusEnumList(i : Integer) : TFhirImmunizationStatusEnumList;
var
  aLoop : TFhirImmunizationStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirImmunizationStatusEnum) to high(TFhirImmunizationStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirImmunizationEvaluationStatusEnumListAsInteger(aSet : TFhirImmunizationEvaluationStatusEnumList) : Integer;
var
  a : TFhirImmunizationEvaluationStatusEnum;
begin
  result := 0;
  for a := low(TFhirImmunizationEvaluationStatusEnum) to high(TFhirImmunizationEvaluationStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirImmunizationEvaluationStatusEnumList(i : Integer) : TFhirImmunizationEvaluationStatusEnumList;
var
  aLoop : TFhirImmunizationEvaluationStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirImmunizationEvaluationStatusEnum) to high(TFhirImmunizationEvaluationStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirSpdxLicenseEnumListAsInteger(aSet : TFhirSpdxLicenseEnumList) : Integer;
var
  a : TFhirSpdxLicenseEnum;
begin
  result := 0;
  for a := low(TFhirSpdxLicenseEnum) to high(TFhirSpdxLicenseEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirSpdxLicenseEnumList(i : Integer) : TFhirSpdxLicenseEnumList;
var
  aLoop : TFhirSpdxLicenseEnum;
begin
  result := [];
  for aLoop := low(TFhirSpdxLicenseEnum) to high(TFhirSpdxLicenseEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirGuidePageGenerationEnumListAsInteger(aSet : TFhirGuidePageGenerationEnumList) : Integer;
var
  a : TFhirGuidePageGenerationEnum;
begin
  result := 0;
  for a := low(TFhirGuidePageGenerationEnum) to high(TFhirGuidePageGenerationEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirGuidePageGenerationEnumList(i : Integer) : TFhirGuidePageGenerationEnumList;
var
  aLoop : TFhirGuidePageGenerationEnum;
begin
  result := [];
  for aLoop := low(TFhirGuidePageGenerationEnum) to high(TFhirGuidePageGenerationEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirGuideParameterCodeEnumListAsInteger(aSet : TFhirGuideParameterCodeEnumList) : Integer;
var
  a : TFhirGuideParameterCodeEnum;
begin
  result := 0;
  for a := low(TFhirGuideParameterCodeEnum) to high(TFhirGuideParameterCodeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirGuideParameterCodeEnumList(i : Integer) : TFhirGuideParameterCodeEnumList;
var
  aLoop : TFhirGuideParameterCodeEnum;
begin
  result := [];
  for aLoop := low(TFhirGuideParameterCodeEnum) to high(TFhirGuideParameterCodeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirInvoiceStatusEnumListAsInteger(aSet : TFhirInvoiceStatusEnumList) : Integer;
var
  a : TFhirInvoiceStatusEnum;
begin
  result := 0;
  for a := low(TFhirInvoiceStatusEnum) to high(TFhirInvoiceStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirInvoiceStatusEnumList(i : Integer) : TFhirInvoiceStatusEnumList;
var
  aLoop : TFhirInvoiceStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirInvoiceStatusEnum) to high(TFhirInvoiceStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirLinkageTypeEnumListAsInteger(aSet : TFhirLinkageTypeEnumList) : Integer;
var
  a : TFhirLinkageTypeEnum;
begin
  result := 0;
  for a := low(TFhirLinkageTypeEnum) to high(TFhirLinkageTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirLinkageTypeEnumList(i : Integer) : TFhirLinkageTypeEnumList;
var
  aLoop : TFhirLinkageTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirLinkageTypeEnum) to high(TFhirLinkageTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirListStatusEnumListAsInteger(aSet : TFhirListStatusEnumList) : Integer;
var
  a : TFhirListStatusEnum;
begin
  result := 0;
  for a := low(TFhirListStatusEnum) to high(TFhirListStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirListStatusEnumList(i : Integer) : TFhirListStatusEnumList;
var
  aLoop : TFhirListStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirListStatusEnum) to high(TFhirListStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirLocationStatusEnumListAsInteger(aSet : TFhirLocationStatusEnumList) : Integer;
var
  a : TFhirLocationStatusEnum;
begin
  result := 0;
  for a := low(TFhirLocationStatusEnum) to high(TFhirLocationStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirLocationStatusEnumList(i : Integer) : TFhirLocationStatusEnumList;
var
  aLoop : TFhirLocationStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirLocationStatusEnum) to high(TFhirLocationStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirLocationModeEnumListAsInteger(aSet : TFhirLocationModeEnumList) : Integer;
var
  a : TFhirLocationModeEnum;
begin
  result := 0;
  for a := low(TFhirLocationModeEnum) to high(TFhirLocationModeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirLocationModeEnumList(i : Integer) : TFhirLocationModeEnumList;
var
  aLoop : TFhirLocationModeEnum;
begin
  result := [];
  for aLoop := low(TFhirLocationModeEnum) to high(TFhirLocationModeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirMeasureReportStatusEnumListAsInteger(aSet : TFhirMeasureReportStatusEnumList) : Integer;
var
  a : TFhirMeasureReportStatusEnum;
begin
  result := 0;
  for a := low(TFhirMeasureReportStatusEnum) to high(TFhirMeasureReportStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirMeasureReportStatusEnumList(i : Integer) : TFhirMeasureReportStatusEnumList;
var
  aLoop : TFhirMeasureReportStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirMeasureReportStatusEnum) to high(TFhirMeasureReportStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirMeasureReportTypeEnumListAsInteger(aSet : TFhirMeasureReportTypeEnumList) : Integer;
var
  a : TFhirMeasureReportTypeEnum;
begin
  result := 0;
  for a := low(TFhirMeasureReportTypeEnum) to high(TFhirMeasureReportTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirMeasureReportTypeEnumList(i : Integer) : TFhirMeasureReportTypeEnumList;
var
  aLoop : TFhirMeasureReportTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirMeasureReportTypeEnum) to high(TFhirMeasureReportTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirMedicationStatusEnumListAsInteger(aSet : TFhirMedicationStatusEnumList) : Integer;
var
  a : TFhirMedicationStatusEnum;
begin
  result := 0;
  for a := low(TFhirMedicationStatusEnum) to high(TFhirMedicationStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirMedicationStatusEnumList(i : Integer) : TFhirMedicationStatusEnumList;
var
  aLoop : TFhirMedicationStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirMedicationStatusEnum) to high(TFhirMedicationStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirMedicationrequestStatusEnumListAsInteger(aSet : TFhirMedicationrequestStatusEnumList) : Integer;
var
  a : TFhirMedicationrequestStatusEnum;
begin
  result := 0;
  for a := low(TFhirMedicationrequestStatusEnum) to high(TFhirMedicationrequestStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirMedicationrequestStatusEnumList(i : Integer) : TFhirMedicationrequestStatusEnumList;
var
  aLoop : TFhirMedicationrequestStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirMedicationrequestStatusEnum) to high(TFhirMedicationrequestStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirMedicationrequestIntentEnumListAsInteger(aSet : TFhirMedicationrequestIntentEnumList) : Integer;
var
  a : TFhirMedicationrequestIntentEnum;
begin
  result := 0;
  for a := low(TFhirMedicationrequestIntentEnum) to high(TFhirMedicationrequestIntentEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirMedicationrequestIntentEnumList(i : Integer) : TFhirMedicationrequestIntentEnumList;
var
  aLoop : TFhirMedicationrequestIntentEnum;
begin
  result := [];
  for aLoop := low(TFhirMedicationrequestIntentEnum) to high(TFhirMedicationrequestIntentEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirMedicationStatementStatusEnumListAsInteger(aSet : TFhirMedicationStatementStatusEnumList) : Integer;
var
  a : TFhirMedicationStatementStatusEnum;
begin
  result := 0;
  for a := low(TFhirMedicationStatementStatusEnum) to high(TFhirMedicationStatementStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirMedicationStatementStatusEnumList(i : Integer) : TFhirMedicationStatementStatusEnumList;
var
  aLoop : TFhirMedicationStatementStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirMedicationStatementStatusEnum) to high(TFhirMedicationStatementStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirMessageSignificanceCategoryEnumListAsInteger(aSet : TFhirMessageSignificanceCategoryEnumList) : Integer;
var
  a : TFhirMessageSignificanceCategoryEnum;
begin
  result := 0;
  for a := low(TFhirMessageSignificanceCategoryEnum) to high(TFhirMessageSignificanceCategoryEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirMessageSignificanceCategoryEnumList(i : Integer) : TFhirMessageSignificanceCategoryEnumList;
var
  aLoop : TFhirMessageSignificanceCategoryEnum;
begin
  result := [];
  for aLoop := low(TFhirMessageSignificanceCategoryEnum) to high(TFhirMessageSignificanceCategoryEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirMessageheaderResponseRequestEnumListAsInteger(aSet : TFhirMessageheaderResponseRequestEnumList) : Integer;
var
  a : TFhirMessageheaderResponseRequestEnum;
begin
  result := 0;
  for a := low(TFhirMessageheaderResponseRequestEnum) to high(TFhirMessageheaderResponseRequestEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirMessageheaderResponseRequestEnumList(i : Integer) : TFhirMessageheaderResponseRequestEnumList;
var
  aLoop : TFhirMessageheaderResponseRequestEnum;
begin
  result := [];
  for aLoop := low(TFhirMessageheaderResponseRequestEnum) to high(TFhirMessageheaderResponseRequestEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirResponseCodeEnumListAsInteger(aSet : TFhirResponseCodeEnumList) : Integer;
var
  a : TFhirResponseCodeEnum;
begin
  result := 0;
  for a := low(TFhirResponseCodeEnum) to high(TFhirResponseCodeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirResponseCodeEnumList(i : Integer) : TFhirResponseCodeEnumList;
var
  aLoop : TFhirResponseCodeEnum;
begin
  result := [];
  for aLoop := low(TFhirResponseCodeEnum) to high(TFhirResponseCodeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirSequenceTypeEnumListAsInteger(aSet : TFhirSequenceTypeEnumList) : Integer;
var
  a : TFhirSequenceTypeEnum;
begin
  result := 0;
  for a := low(TFhirSequenceTypeEnum) to high(TFhirSequenceTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirSequenceTypeEnumList(i : Integer) : TFhirSequenceTypeEnumList;
var
  aLoop : TFhirSequenceTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirSequenceTypeEnum) to high(TFhirSequenceTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirOrientationTypeEnumListAsInteger(aSet : TFhirOrientationTypeEnumList) : Integer;
var
  a : TFhirOrientationTypeEnum;
begin
  result := 0;
  for a := low(TFhirOrientationTypeEnum) to high(TFhirOrientationTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirOrientationTypeEnumList(i : Integer) : TFhirOrientationTypeEnumList;
var
  aLoop : TFhirOrientationTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirOrientationTypeEnum) to high(TFhirOrientationTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirStrandTypeEnumListAsInteger(aSet : TFhirStrandTypeEnumList) : Integer;
var
  a : TFhirStrandTypeEnum;
begin
  result := 0;
  for a := low(TFhirStrandTypeEnum) to high(TFhirStrandTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirStrandTypeEnumList(i : Integer) : TFhirStrandTypeEnumList;
var
  aLoop : TFhirStrandTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirStrandTypeEnum) to high(TFhirStrandTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirQualityTypeEnumListAsInteger(aSet : TFhirQualityTypeEnumList) : Integer;
var
  a : TFhirQualityTypeEnum;
begin
  result := 0;
  for a := low(TFhirQualityTypeEnum) to high(TFhirQualityTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirQualityTypeEnumList(i : Integer) : TFhirQualityTypeEnumList;
var
  aLoop : TFhirQualityTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirQualityTypeEnum) to high(TFhirQualityTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirRepositoryTypeEnumListAsInteger(aSet : TFhirRepositoryTypeEnumList) : Integer;
var
  a : TFhirRepositoryTypeEnum;
begin
  result := 0;
  for a := low(TFhirRepositoryTypeEnum) to high(TFhirRepositoryTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirRepositoryTypeEnumList(i : Integer) : TFhirRepositoryTypeEnumList;
var
  aLoop : TFhirRepositoryTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirRepositoryTypeEnum) to high(TFhirRepositoryTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirNamingsystemTypeEnumListAsInteger(aSet : TFhirNamingsystemTypeEnumList) : Integer;
var
  a : TFhirNamingsystemTypeEnum;
begin
  result := 0;
  for a := low(TFhirNamingsystemTypeEnum) to high(TFhirNamingsystemTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirNamingsystemTypeEnumList(i : Integer) : TFhirNamingsystemTypeEnumList;
var
  aLoop : TFhirNamingsystemTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirNamingsystemTypeEnum) to high(TFhirNamingsystemTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirNamingsystemIdentifierTypeEnumListAsInteger(aSet : TFhirNamingsystemIdentifierTypeEnumList) : Integer;
var
  a : TFhirNamingsystemIdentifierTypeEnum;
begin
  result := 0;
  for a := low(TFhirNamingsystemIdentifierTypeEnum) to high(TFhirNamingsystemIdentifierTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirNamingsystemIdentifierTypeEnumList(i : Integer) : TFhirNamingsystemIdentifierTypeEnumList;
var
  aLoop : TFhirNamingsystemIdentifierTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirNamingsystemIdentifierTypeEnum) to high(TFhirNamingsystemIdentifierTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirPermittedDataTypeEnumListAsInteger(aSet : TFhirPermittedDataTypeEnumList) : Integer;
var
  a : TFhirPermittedDataTypeEnum;
begin
  result := 0;
  for a := low(TFhirPermittedDataTypeEnum) to high(TFhirPermittedDataTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirPermittedDataTypeEnumList(i : Integer) : TFhirPermittedDataTypeEnumList;
var
  aLoop : TFhirPermittedDataTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirPermittedDataTypeEnum) to high(TFhirPermittedDataTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirObservationRangeCategoryEnumListAsInteger(aSet : TFhirObservationRangeCategoryEnumList) : Integer;
var
  a : TFhirObservationRangeCategoryEnum;
begin
  result := 0;
  for a := low(TFhirObservationRangeCategoryEnum) to high(TFhirObservationRangeCategoryEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirObservationRangeCategoryEnumList(i : Integer) : TFhirObservationRangeCategoryEnumList;
var
  aLoop : TFhirObservationRangeCategoryEnum;
begin
  result := [];
  for aLoop := low(TFhirObservationRangeCategoryEnum) to high(TFhirObservationRangeCategoryEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirAdministrativeGenderEnumListAsInteger(aSet : TFhirAdministrativeGenderEnumList) : Integer;
var
  a : TFhirAdministrativeGenderEnum;
begin
  result := 0;
  for a := low(TFhirAdministrativeGenderEnum) to high(TFhirAdministrativeGenderEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirAdministrativeGenderEnumList(i : Integer) : TFhirAdministrativeGenderEnumList;
var
  aLoop : TFhirAdministrativeGenderEnum;
begin
  result := [];
  for aLoop := low(TFhirAdministrativeGenderEnum) to high(TFhirAdministrativeGenderEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirOperationKindEnumListAsInteger(aSet : TFhirOperationKindEnumList) : Integer;
var
  a : TFhirOperationKindEnum;
begin
  result := 0;
  for a := low(TFhirOperationKindEnum) to high(TFhirOperationKindEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirOperationKindEnumList(i : Integer) : TFhirOperationKindEnumList;
var
  aLoop : TFhirOperationKindEnum;
begin
  result := [];
  for aLoop := low(TFhirOperationKindEnum) to high(TFhirOperationKindEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirIssueSeverityEnumListAsInteger(aSet : TFhirIssueSeverityEnumList) : Integer;
var
  a : TFhirIssueSeverityEnum;
begin
  result := 0;
  for a := low(TFhirIssueSeverityEnum) to high(TFhirIssueSeverityEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirIssueSeverityEnumList(i : Integer) : TFhirIssueSeverityEnumList;
var
  aLoop : TFhirIssueSeverityEnum;
begin
  result := [];
  for aLoop := low(TFhirIssueSeverityEnum) to high(TFhirIssueSeverityEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirIssueTypeEnumListAsInteger(aSet : TFhirIssueTypeEnumList) : Integer;
var
  a : TFhirIssueTypeEnum;
begin
  result := 0;
  for a := low(TFhirIssueTypeEnum) to high(TFhirIssueTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirIssueTypeEnumList(i : Integer) : TFhirIssueTypeEnumList;
var
  aLoop : TFhirIssueTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirIssueTypeEnum) to high(TFhirIssueTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirLinkTypeEnumListAsInteger(aSet : TFhirLinkTypeEnumList) : Integer;
var
  a : TFhirLinkTypeEnum;
begin
  result := 0;
  for a := low(TFhirLinkTypeEnum) to high(TFhirLinkTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirLinkTypeEnumList(i : Integer) : TFhirLinkTypeEnumList;
var
  aLoop : TFhirLinkTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirLinkTypeEnum) to high(TFhirLinkTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirIdentityAssuranceLevelEnumListAsInteger(aSet : TFhirIdentityAssuranceLevelEnumList) : Integer;
var
  a : TFhirIdentityAssuranceLevelEnum;
begin
  result := 0;
  for a := low(TFhirIdentityAssuranceLevelEnum) to high(TFhirIdentityAssuranceLevelEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirIdentityAssuranceLevelEnumList(i : Integer) : TFhirIdentityAssuranceLevelEnumList;
var
  aLoop : TFhirIdentityAssuranceLevelEnum;
begin
  result := [];
  for aLoop := low(TFhirIdentityAssuranceLevelEnum) to high(TFhirIdentityAssuranceLevelEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirActionConditionKindEnumListAsInteger(aSet : TFhirActionConditionKindEnumList) : Integer;
var
  a : TFhirActionConditionKindEnum;
begin
  result := 0;
  for a := low(TFhirActionConditionKindEnum) to high(TFhirActionConditionKindEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirActionConditionKindEnumList(i : Integer) : TFhirActionConditionKindEnumList;
var
  aLoop : TFhirActionConditionKindEnum;
begin
  result := [];
  for aLoop := low(TFhirActionConditionKindEnum) to high(TFhirActionConditionKindEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirActionRelationshipTypeEnumListAsInteger(aSet : TFhirActionRelationshipTypeEnumList) : Integer;
var
  a : TFhirActionRelationshipTypeEnum;
begin
  result := 0;
  for a := low(TFhirActionRelationshipTypeEnum) to high(TFhirActionRelationshipTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirActionRelationshipTypeEnumList(i : Integer) : TFhirActionRelationshipTypeEnumList;
var
  aLoop : TFhirActionRelationshipTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirActionRelationshipTypeEnum) to high(TFhirActionRelationshipTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirActionGroupingBehaviorEnumListAsInteger(aSet : TFhirActionGroupingBehaviorEnumList) : Integer;
var
  a : TFhirActionGroupingBehaviorEnum;
begin
  result := 0;
  for a := low(TFhirActionGroupingBehaviorEnum) to high(TFhirActionGroupingBehaviorEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirActionGroupingBehaviorEnumList(i : Integer) : TFhirActionGroupingBehaviorEnumList;
var
  aLoop : TFhirActionGroupingBehaviorEnum;
begin
  result := [];
  for aLoop := low(TFhirActionGroupingBehaviorEnum) to high(TFhirActionGroupingBehaviorEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirActionSelectionBehaviorEnumListAsInteger(aSet : TFhirActionSelectionBehaviorEnumList) : Integer;
var
  a : TFhirActionSelectionBehaviorEnum;
begin
  result := 0;
  for a := low(TFhirActionSelectionBehaviorEnum) to high(TFhirActionSelectionBehaviorEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirActionSelectionBehaviorEnumList(i : Integer) : TFhirActionSelectionBehaviorEnumList;
var
  aLoop : TFhirActionSelectionBehaviorEnum;
begin
  result := [];
  for aLoop := low(TFhirActionSelectionBehaviorEnum) to high(TFhirActionSelectionBehaviorEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirActionRequiredBehaviorEnumListAsInteger(aSet : TFhirActionRequiredBehaviorEnumList) : Integer;
var
  a : TFhirActionRequiredBehaviorEnum;
begin
  result := 0;
  for a := low(TFhirActionRequiredBehaviorEnum) to high(TFhirActionRequiredBehaviorEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirActionRequiredBehaviorEnumList(i : Integer) : TFhirActionRequiredBehaviorEnumList;
var
  aLoop : TFhirActionRequiredBehaviorEnum;
begin
  result := [];
  for aLoop := low(TFhirActionRequiredBehaviorEnum) to high(TFhirActionRequiredBehaviorEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirActionPrecheckBehaviorEnumListAsInteger(aSet : TFhirActionPrecheckBehaviorEnumList) : Integer;
var
  a : TFhirActionPrecheckBehaviorEnum;
begin
  result := 0;
  for a := low(TFhirActionPrecheckBehaviorEnum) to high(TFhirActionPrecheckBehaviorEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirActionPrecheckBehaviorEnumList(i : Integer) : TFhirActionPrecheckBehaviorEnumList;
var
  aLoop : TFhirActionPrecheckBehaviorEnum;
begin
  result := [];
  for aLoop := low(TFhirActionPrecheckBehaviorEnum) to high(TFhirActionPrecheckBehaviorEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirActionCardinalityBehaviorEnumListAsInteger(aSet : TFhirActionCardinalityBehaviorEnumList) : Integer;
var
  a : TFhirActionCardinalityBehaviorEnum;
begin
  result := 0;
  for a := low(TFhirActionCardinalityBehaviorEnum) to high(TFhirActionCardinalityBehaviorEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirActionCardinalityBehaviorEnumList(i : Integer) : TFhirActionCardinalityBehaviorEnumList;
var
  aLoop : TFhirActionCardinalityBehaviorEnum;
begin
  result := [];
  for aLoop := low(TFhirActionCardinalityBehaviorEnum) to high(TFhirActionCardinalityBehaviorEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirProvenanceEntityRoleEnumListAsInteger(aSet : TFhirProvenanceEntityRoleEnumList) : Integer;
var
  a : TFhirProvenanceEntityRoleEnum;
begin
  result := 0;
  for a := low(TFhirProvenanceEntityRoleEnum) to high(TFhirProvenanceEntityRoleEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirProvenanceEntityRoleEnumList(i : Integer) : TFhirProvenanceEntityRoleEnumList;
var
  aLoop : TFhirProvenanceEntityRoleEnum;
begin
  result := [];
  for aLoop := low(TFhirProvenanceEntityRoleEnum) to high(TFhirProvenanceEntityRoleEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirItemTypeEnumListAsInteger(aSet : TFhirItemTypeEnumList) : Integer;
var
  a : TFhirItemTypeEnum;
begin
  result := 0;
  for a := low(TFhirItemTypeEnum) to high(TFhirItemTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirItemTypeEnumList(i : Integer) : TFhirItemTypeEnumList;
var
  aLoop : TFhirItemTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirItemTypeEnum) to high(TFhirItemTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirQuestionnaireEnableOperatorEnumListAsInteger(aSet : TFhirQuestionnaireEnableOperatorEnumList) : Integer;
var
  a : TFhirQuestionnaireEnableOperatorEnum;
begin
  result := 0;
  for a := low(TFhirQuestionnaireEnableOperatorEnum) to high(TFhirQuestionnaireEnableOperatorEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirQuestionnaireEnableOperatorEnumList(i : Integer) : TFhirQuestionnaireEnableOperatorEnumList;
var
  aLoop : TFhirQuestionnaireEnableOperatorEnum;
begin
  result := [];
  for aLoop := low(TFhirQuestionnaireEnableOperatorEnum) to high(TFhirQuestionnaireEnableOperatorEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirQuestionnaireEnableBehaviorEnumListAsInteger(aSet : TFhirQuestionnaireEnableBehaviorEnumList) : Integer;
var
  a : TFhirQuestionnaireEnableBehaviorEnum;
begin
  result := 0;
  for a := low(TFhirQuestionnaireEnableBehaviorEnum) to high(TFhirQuestionnaireEnableBehaviorEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirQuestionnaireEnableBehaviorEnumList(i : Integer) : TFhirQuestionnaireEnableBehaviorEnumList;
var
  aLoop : TFhirQuestionnaireEnableBehaviorEnum;
begin
  result := [];
  for aLoop := low(TFhirQuestionnaireEnableBehaviorEnum) to high(TFhirQuestionnaireEnableBehaviorEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirQuestionnaireAnswersStatusEnumListAsInteger(aSet : TFhirQuestionnaireAnswersStatusEnumList) : Integer;
var
  a : TFhirQuestionnaireAnswersStatusEnum;
begin
  result := 0;
  for a := low(TFhirQuestionnaireAnswersStatusEnum) to high(TFhirQuestionnaireAnswersStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirQuestionnaireAnswersStatusEnumList(i : Integer) : TFhirQuestionnaireAnswersStatusEnumList;
var
  aLoop : TFhirQuestionnaireAnswersStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirQuestionnaireAnswersStatusEnum) to high(TFhirQuestionnaireAnswersStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirResearchElementTypeEnumListAsInteger(aSet : TFhirResearchElementTypeEnumList) : Integer;
var
  a : TFhirResearchElementTypeEnum;
begin
  result := 0;
  for a := low(TFhirResearchElementTypeEnum) to high(TFhirResearchElementTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirResearchElementTypeEnumList(i : Integer) : TFhirResearchElementTypeEnumList;
var
  aLoop : TFhirResearchElementTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirResearchElementTypeEnum) to high(TFhirResearchElementTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirResearchStudyStatusEnumListAsInteger(aSet : TFhirResearchStudyStatusEnumList) : Integer;
var
  a : TFhirResearchStudyStatusEnum;
begin
  result := 0;
  for a := low(TFhirResearchStudyStatusEnum) to high(TFhirResearchStudyStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirResearchStudyStatusEnumList(i : Integer) : TFhirResearchStudyStatusEnumList;
var
  aLoop : TFhirResearchStudyStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirResearchStudyStatusEnum) to high(TFhirResearchStudyStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirResearchSubjectStatusEnumListAsInteger(aSet : TFhirResearchSubjectStatusEnumList) : Integer;
var
  a : TFhirResearchSubjectStatusEnum;
begin
  result := 0;
  for a := low(TFhirResearchSubjectStatusEnum) to high(TFhirResearchSubjectStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirResearchSubjectStatusEnumList(i : Integer) : TFhirResearchSubjectStatusEnumList;
var
  aLoop : TFhirResearchSubjectStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirResearchSubjectStatusEnum) to high(TFhirResearchSubjectStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirSearchXpathUsageEnumListAsInteger(aSet : TFhirSearchXpathUsageEnumList) : Integer;
var
  a : TFhirSearchXpathUsageEnum;
begin
  result := 0;
  for a := low(TFhirSearchXpathUsageEnum) to high(TFhirSearchXpathUsageEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirSearchXpathUsageEnumList(i : Integer) : TFhirSearchXpathUsageEnumList;
var
  aLoop : TFhirSearchXpathUsageEnum;
begin
  result := [];
  for aLoop := low(TFhirSearchXpathUsageEnum) to high(TFhirSearchXpathUsageEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirSearchComparatorEnumListAsInteger(aSet : TFhirSearchComparatorEnumList) : Integer;
var
  a : TFhirSearchComparatorEnum;
begin
  result := 0;
  for a := low(TFhirSearchComparatorEnum) to high(TFhirSearchComparatorEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirSearchComparatorEnumList(i : Integer) : TFhirSearchComparatorEnumList;
var
  aLoop : TFhirSearchComparatorEnum;
begin
  result := [];
  for aLoop := low(TFhirSearchComparatorEnum) to high(TFhirSearchComparatorEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirSearchModifierCodeEnumListAsInteger(aSet : TFhirSearchModifierCodeEnumList) : Integer;
var
  a : TFhirSearchModifierCodeEnum;
begin
  result := 0;
  for a := low(TFhirSearchModifierCodeEnum) to high(TFhirSearchModifierCodeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirSearchModifierCodeEnumList(i : Integer) : TFhirSearchModifierCodeEnumList;
var
  aLoop : TFhirSearchModifierCodeEnum;
begin
  result := [];
  for aLoop := low(TFhirSearchModifierCodeEnum) to high(TFhirSearchModifierCodeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirSlotstatusEnumListAsInteger(aSet : TFhirSlotstatusEnumList) : Integer;
var
  a : TFhirSlotstatusEnum;
begin
  result := 0;
  for a := low(TFhirSlotstatusEnum) to high(TFhirSlotstatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirSlotstatusEnumList(i : Integer) : TFhirSlotstatusEnumList;
var
  aLoop : TFhirSlotstatusEnum;
begin
  result := [];
  for aLoop := low(TFhirSlotstatusEnum) to high(TFhirSlotstatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirSpecimenStatusEnumListAsInteger(aSet : TFhirSpecimenStatusEnumList) : Integer;
var
  a : TFhirSpecimenStatusEnum;
begin
  result := 0;
  for a := low(TFhirSpecimenStatusEnum) to high(TFhirSpecimenStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirSpecimenStatusEnumList(i : Integer) : TFhirSpecimenStatusEnumList;
var
  aLoop : TFhirSpecimenStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirSpecimenStatusEnum) to high(TFhirSpecimenStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirSpecimenContainedPreferenceEnumListAsInteger(aSet : TFhirSpecimenContainedPreferenceEnumList) : Integer;
var
  a : TFhirSpecimenContainedPreferenceEnum;
begin
  result := 0;
  for a := low(TFhirSpecimenContainedPreferenceEnum) to high(TFhirSpecimenContainedPreferenceEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirSpecimenContainedPreferenceEnumList(i : Integer) : TFhirSpecimenContainedPreferenceEnumList;
var
  aLoop : TFhirSpecimenContainedPreferenceEnum;
begin
  result := [];
  for aLoop := low(TFhirSpecimenContainedPreferenceEnum) to high(TFhirSpecimenContainedPreferenceEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirStructureDefinitionKindEnumListAsInteger(aSet : TFhirStructureDefinitionKindEnumList) : Integer;
var
  a : TFhirStructureDefinitionKindEnum;
begin
  result := 0;
  for a := low(TFhirStructureDefinitionKindEnum) to high(TFhirStructureDefinitionKindEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirStructureDefinitionKindEnumList(i : Integer) : TFhirStructureDefinitionKindEnumList;
var
  aLoop : TFhirStructureDefinitionKindEnum;
begin
  result := [];
  for aLoop := low(TFhirStructureDefinitionKindEnum) to high(TFhirStructureDefinitionKindEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirExtensionContextTypeEnumListAsInteger(aSet : TFhirExtensionContextTypeEnumList) : Integer;
var
  a : TFhirExtensionContextTypeEnum;
begin
  result := 0;
  for a := low(TFhirExtensionContextTypeEnum) to high(TFhirExtensionContextTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirExtensionContextTypeEnumList(i : Integer) : TFhirExtensionContextTypeEnumList;
var
  aLoop : TFhirExtensionContextTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirExtensionContextTypeEnum) to high(TFhirExtensionContextTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirTypeDerivationRuleEnumListAsInteger(aSet : TFhirTypeDerivationRuleEnumList) : Integer;
var
  a : TFhirTypeDerivationRuleEnum;
begin
  result := 0;
  for a := low(TFhirTypeDerivationRuleEnum) to high(TFhirTypeDerivationRuleEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirTypeDerivationRuleEnumList(i : Integer) : TFhirTypeDerivationRuleEnumList;
var
  aLoop : TFhirTypeDerivationRuleEnum;
begin
  result := [];
  for aLoop := low(TFhirTypeDerivationRuleEnum) to high(TFhirTypeDerivationRuleEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirMapModelModeEnumListAsInteger(aSet : TFhirMapModelModeEnumList) : Integer;
var
  a : TFhirMapModelModeEnum;
begin
  result := 0;
  for a := low(TFhirMapModelModeEnum) to high(TFhirMapModelModeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirMapModelModeEnumList(i : Integer) : TFhirMapModelModeEnumList;
var
  aLoop : TFhirMapModelModeEnum;
begin
  result := [];
  for aLoop := low(TFhirMapModelModeEnum) to high(TFhirMapModelModeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirMapGroupTypeModeEnumListAsInteger(aSet : TFhirMapGroupTypeModeEnumList) : Integer;
var
  a : TFhirMapGroupTypeModeEnum;
begin
  result := 0;
  for a := low(TFhirMapGroupTypeModeEnum) to high(TFhirMapGroupTypeModeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirMapGroupTypeModeEnumList(i : Integer) : TFhirMapGroupTypeModeEnumList;
var
  aLoop : TFhirMapGroupTypeModeEnum;
begin
  result := [];
  for aLoop := low(TFhirMapGroupTypeModeEnum) to high(TFhirMapGroupTypeModeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirMapInputModeEnumListAsInteger(aSet : TFhirMapInputModeEnumList) : Integer;
var
  a : TFhirMapInputModeEnum;
begin
  result := 0;
  for a := low(TFhirMapInputModeEnum) to high(TFhirMapInputModeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirMapInputModeEnumList(i : Integer) : TFhirMapInputModeEnumList;
var
  aLoop : TFhirMapInputModeEnum;
begin
  result := [];
  for aLoop := low(TFhirMapInputModeEnum) to high(TFhirMapInputModeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirMapSourceListModeEnumListAsInteger(aSet : TFhirMapSourceListModeEnumList) : Integer;
var
  a : TFhirMapSourceListModeEnum;
begin
  result := 0;
  for a := low(TFhirMapSourceListModeEnum) to high(TFhirMapSourceListModeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirMapSourceListModeEnumList(i : Integer) : TFhirMapSourceListModeEnumList;
var
  aLoop : TFhirMapSourceListModeEnum;
begin
  result := [];
  for aLoop := low(TFhirMapSourceListModeEnum) to high(TFhirMapSourceListModeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirMapContextTypeEnumListAsInteger(aSet : TFhirMapContextTypeEnumList) : Integer;
var
  a : TFhirMapContextTypeEnum;
begin
  result := 0;
  for a := low(TFhirMapContextTypeEnum) to high(TFhirMapContextTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirMapContextTypeEnumList(i : Integer) : TFhirMapContextTypeEnumList;
var
  aLoop : TFhirMapContextTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirMapContextTypeEnum) to high(TFhirMapContextTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirMapTargetListModeEnumListAsInteger(aSet : TFhirMapTargetListModeEnumList) : Integer;
var
  a : TFhirMapTargetListModeEnum;
begin
  result := 0;
  for a := low(TFhirMapTargetListModeEnum) to high(TFhirMapTargetListModeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirMapTargetListModeEnumList(i : Integer) : TFhirMapTargetListModeEnumList;
var
  aLoop : TFhirMapTargetListModeEnum;
begin
  result := [];
  for aLoop := low(TFhirMapTargetListModeEnum) to high(TFhirMapTargetListModeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirMapTransformEnumListAsInteger(aSet : TFhirMapTransformEnumList) : Integer;
var
  a : TFhirMapTransformEnum;
begin
  result := 0;
  for a := low(TFhirMapTransformEnum) to high(TFhirMapTransformEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirMapTransformEnumList(i : Integer) : TFhirMapTransformEnumList;
var
  aLoop : TFhirMapTransformEnum;
begin
  result := [];
  for aLoop := low(TFhirMapTransformEnum) to high(TFhirMapTransformEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirSubscriptionStatusEnumListAsInteger(aSet : TFhirSubscriptionStatusEnumList) : Integer;
var
  a : TFhirSubscriptionStatusEnum;
begin
  result := 0;
  for a := low(TFhirSubscriptionStatusEnum) to high(TFhirSubscriptionStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirSubscriptionStatusEnumList(i : Integer) : TFhirSubscriptionStatusEnumList;
var
  aLoop : TFhirSubscriptionStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirSubscriptionStatusEnum) to high(TFhirSubscriptionStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirSubscriptionChannelTypeEnumListAsInteger(aSet : TFhirSubscriptionChannelTypeEnumList) : Integer;
var
  a : TFhirSubscriptionChannelTypeEnum;
begin
  result := 0;
  for a := low(TFhirSubscriptionChannelTypeEnum) to high(TFhirSubscriptionChannelTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirSubscriptionChannelTypeEnumList(i : Integer) : TFhirSubscriptionChannelTypeEnumList;
var
  aLoop : TFhirSubscriptionChannelTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirSubscriptionChannelTypeEnum) to high(TFhirSubscriptionChannelTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirSubstanceStatusEnumListAsInteger(aSet : TFhirSubstanceStatusEnumList) : Integer;
var
  a : TFhirSubstanceStatusEnum;
begin
  result := 0;
  for a := low(TFhirSubstanceStatusEnum) to high(TFhirSubstanceStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirSubstanceStatusEnumList(i : Integer) : TFhirSubstanceStatusEnumList;
var
  aLoop : TFhirSubstanceStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirSubstanceStatusEnum) to high(TFhirSubstanceStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirSupplydeliveryStatusEnumListAsInteger(aSet : TFhirSupplydeliveryStatusEnumList) : Integer;
var
  a : TFhirSupplydeliveryStatusEnum;
begin
  result := 0;
  for a := low(TFhirSupplydeliveryStatusEnum) to high(TFhirSupplydeliveryStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirSupplydeliveryStatusEnumList(i : Integer) : TFhirSupplydeliveryStatusEnumList;
var
  aLoop : TFhirSupplydeliveryStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirSupplydeliveryStatusEnum) to high(TFhirSupplydeliveryStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirSupplyrequestStatusEnumListAsInteger(aSet : TFhirSupplyrequestStatusEnumList) : Integer;
var
  a : TFhirSupplyrequestStatusEnum;
begin
  result := 0;
  for a := low(TFhirSupplyrequestStatusEnum) to high(TFhirSupplyrequestStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirSupplyrequestStatusEnumList(i : Integer) : TFhirSupplyrequestStatusEnumList;
var
  aLoop : TFhirSupplyrequestStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirSupplyrequestStatusEnum) to high(TFhirSupplyrequestStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirTaskStatusEnumListAsInteger(aSet : TFhirTaskStatusEnumList) : Integer;
var
  a : TFhirTaskStatusEnum;
begin
  result := 0;
  for a := low(TFhirTaskStatusEnum) to high(TFhirTaskStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirTaskStatusEnumList(i : Integer) : TFhirTaskStatusEnumList;
var
  aLoop : TFhirTaskStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirTaskStatusEnum) to high(TFhirTaskStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirTaskIntentEnumListAsInteger(aSet : TFhirTaskIntentEnumList) : Integer;
var
  a : TFhirTaskIntentEnum;
begin
  result := 0;
  for a := low(TFhirTaskIntentEnum) to high(TFhirTaskIntentEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirTaskIntentEnumList(i : Integer) : TFhirTaskIntentEnumList;
var
  aLoop : TFhirTaskIntentEnum;
begin
  result := [];
  for aLoop := low(TFhirTaskIntentEnum) to high(TFhirTaskIntentEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirCodeSearchSupportEnumListAsInteger(aSet : TFhirCodeSearchSupportEnumList) : Integer;
var
  a : TFhirCodeSearchSupportEnum;
begin
  result := 0;
  for a := low(TFhirCodeSearchSupportEnum) to high(TFhirCodeSearchSupportEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirCodeSearchSupportEnumList(i : Integer) : TFhirCodeSearchSupportEnumList;
var
  aLoop : TFhirCodeSearchSupportEnum;
begin
  result := [];
  for aLoop := low(TFhirCodeSearchSupportEnum) to high(TFhirCodeSearchSupportEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirReportStatusCodesEnumListAsInteger(aSet : TFhirReportStatusCodesEnumList) : Integer;
var
  a : TFhirReportStatusCodesEnum;
begin
  result := 0;
  for a := low(TFhirReportStatusCodesEnum) to high(TFhirReportStatusCodesEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirReportStatusCodesEnumList(i : Integer) : TFhirReportStatusCodesEnumList;
var
  aLoop : TFhirReportStatusCodesEnum;
begin
  result := [];
  for aLoop := low(TFhirReportStatusCodesEnum) to high(TFhirReportStatusCodesEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirReportResultCodesEnumListAsInteger(aSet : TFhirReportResultCodesEnumList) : Integer;
var
  a : TFhirReportResultCodesEnum;
begin
  result := 0;
  for a := low(TFhirReportResultCodesEnum) to high(TFhirReportResultCodesEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirReportResultCodesEnumList(i : Integer) : TFhirReportResultCodesEnumList;
var
  aLoop : TFhirReportResultCodesEnum;
begin
  result := [];
  for aLoop := low(TFhirReportResultCodesEnum) to high(TFhirReportResultCodesEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirReportParticipantTypeEnumListAsInteger(aSet : TFhirReportParticipantTypeEnumList) : Integer;
var
  a : TFhirReportParticipantTypeEnum;
begin
  result := 0;
  for a := low(TFhirReportParticipantTypeEnum) to high(TFhirReportParticipantTypeEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirReportParticipantTypeEnumList(i : Integer) : TFhirReportParticipantTypeEnumList;
var
  aLoop : TFhirReportParticipantTypeEnum;
begin
  result := [];
  for aLoop := low(TFhirReportParticipantTypeEnum) to high(TFhirReportParticipantTypeEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirReportActionResultCodesEnumListAsInteger(aSet : TFhirReportActionResultCodesEnumList) : Integer;
var
  a : TFhirReportActionResultCodesEnum;
begin
  result := 0;
  for a := low(TFhirReportActionResultCodesEnum) to high(TFhirReportActionResultCodesEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirReportActionResultCodesEnumList(i : Integer) : TFhirReportActionResultCodesEnumList;
var
  aLoop : TFhirReportActionResultCodesEnum;
begin
  result := [];
  for aLoop := low(TFhirReportActionResultCodesEnum) to high(TFhirReportActionResultCodesEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirHttpOperationsEnumListAsInteger(aSet : TFhirHttpOperationsEnumList) : Integer;
var
  a : TFhirHttpOperationsEnum;
begin
  result := 0;
  for a := low(TFhirHttpOperationsEnum) to high(TFhirHttpOperationsEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirHttpOperationsEnumList(i : Integer) : TFhirHttpOperationsEnumList;
var
  aLoop : TFhirHttpOperationsEnum;
begin
  result := [];
  for aLoop := low(TFhirHttpOperationsEnum) to high(TFhirHttpOperationsEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirAssertDirectionCodesEnumListAsInteger(aSet : TFhirAssertDirectionCodesEnumList) : Integer;
var
  a : TFhirAssertDirectionCodesEnum;
begin
  result := 0;
  for a := low(TFhirAssertDirectionCodesEnum) to high(TFhirAssertDirectionCodesEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirAssertDirectionCodesEnumList(i : Integer) : TFhirAssertDirectionCodesEnumList;
var
  aLoop : TFhirAssertDirectionCodesEnum;
begin
  result := [];
  for aLoop := low(TFhirAssertDirectionCodesEnum) to high(TFhirAssertDirectionCodesEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirAssertOperatorCodesEnumListAsInteger(aSet : TFhirAssertOperatorCodesEnumList) : Integer;
var
  a : TFhirAssertOperatorCodesEnum;
begin
  result := 0;
  for a := low(TFhirAssertOperatorCodesEnum) to high(TFhirAssertOperatorCodesEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirAssertOperatorCodesEnumList(i : Integer) : TFhirAssertOperatorCodesEnumList;
var
  aLoop : TFhirAssertOperatorCodesEnum;
begin
  result := [];
  for aLoop := low(TFhirAssertOperatorCodesEnum) to high(TFhirAssertOperatorCodesEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirAssertResponseCodeTypesEnumListAsInteger(aSet : TFhirAssertResponseCodeTypesEnumList) : Integer;
var
  a : TFhirAssertResponseCodeTypesEnum;
begin
  result := 0;
  for a := low(TFhirAssertResponseCodeTypesEnum) to high(TFhirAssertResponseCodeTypesEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirAssertResponseCodeTypesEnumList(i : Integer) : TFhirAssertResponseCodeTypesEnumList;
var
  aLoop : TFhirAssertResponseCodeTypesEnum;
begin
  result := [];
  for aLoop := low(TFhirAssertResponseCodeTypesEnum) to high(TFhirAssertResponseCodeTypesEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirVerificationresultStatusEnumListAsInteger(aSet : TFhirVerificationresultStatusEnumList) : Integer;
var
  a : TFhirVerificationresultStatusEnum;
begin
  result := 0;
  for a := low(TFhirVerificationresultStatusEnum) to high(TFhirVerificationresultStatusEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirVerificationresultStatusEnumList(i : Integer) : TFhirVerificationresultStatusEnumList;
var
  aLoop : TFhirVerificationresultStatusEnum;
begin
  result := [];
  for aLoop := low(TFhirVerificationresultStatusEnum) to high(TFhirVerificationresultStatusEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirVisionEyeCodesEnumListAsInteger(aSet : TFhirVisionEyeCodesEnumList) : Integer;
var
  a : TFhirVisionEyeCodesEnum;
begin
  result := 0;
  for a := low(TFhirVisionEyeCodesEnum) to high(TFhirVisionEyeCodesEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirVisionEyeCodesEnumList(i : Integer) : TFhirVisionEyeCodesEnumList;
var
  aLoop : TFhirVisionEyeCodesEnum;
begin
  result := [];
  for aLoop := low(TFhirVisionEyeCodesEnum) to high(TFhirVisionEyeCodesEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function TFhirVisionBaseCodesEnumListAsInteger(aSet : TFhirVisionBaseCodesEnumList) : Integer;
var
  a : TFhirVisionBaseCodesEnum;
begin
  result := 0;
  for a := low(TFhirVisionBaseCodesEnum) to high(TFhirVisionBaseCodesEnum) do
  begin
    assert(ord(a) < 32);
    if a in aSet then
      result := result + 1 shl (ord(a));
  end;
end;

function IntegerAsTFhirVisionBaseCodesEnumList(i : Integer) : TFhirVisionBaseCodesEnumList;
var
  aLoop : TFhirVisionBaseCodesEnum;
begin
  result := [];
  for aLoop := low(TFhirVisionBaseCodesEnum) to high(TFhirVisionBaseCodesEnum) Do
  begin
    assert(ord(aLoop) < 32);
    if i and (1 shl (ord(aLoop))) > 0 Then
      result := result + [aLoop];
  end;
 end;

function asEnum(systems, values: array of String; obj : TFHIRObject) : TFHIREnum;
begin
  if obj is TFHIREnum then
    result := obj as TFHIREnum
  else if obj is TFHIRCode then
  begin
    result := TFHIREnum.create(systems[StringArrayIndexOf(values, TFHIRCode(obj).value)], TFHIRCode(obj).value);
    obj.Free;
  end
  else if obj is TFHIRString then
  begin
    result := TFHIREnum.create(systems[StringArrayIndexOf(values, TFHIRString(obj).value)], TFHIRString(obj).value);
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIRCode"')
  end;
end;
function asDate(obj : TFHIRObject) : TFHIRDate;
begin
  if obj is TFHIRDate then
    result := obj as TFHIRDate
  else if obj is TFHIRMMElement then
  begin
    result := TFHIRDate.create(TFslDateTime.fromXml(TFHIRMMElement(obj).value));
    obj.Free;
  end
  else if (obj is TFHIRObject) and (TFHIRObject(obj).isPrimitive) then
  begin
    result := TFHIRDate.create(TFslDateTime.fromXml(TFHIRObject(obj).primitiveValue));
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIRDate"')
  end;
end;
function asDateTime(obj : TFHIRObject) : TFHIRDateTime;
begin
  if obj is TFHIRDateTime then
    result := obj as TFHIRDateTime
  else if obj is TFHIRMMElement then
  begin
    result := TFHIRDateTime.create(TFslDateTime.fromXml(TFHIRMMElement(obj).value));
    obj.Free;
  end
  else if (obj is TFHIRObject) and (TFHIRObject(obj).isPrimitive) then
  begin
    result := TFHIRDateTime.create(TFslDateTime.fromXml(TFHIRObject(obj).primitiveValue));
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIRDateTime"')
  end;
end;
function asString(obj : TFHIRObject) : TFHIRString;
begin
  if obj is TFHIRString then
    result := obj as TFHIRString
  else if obj is TFHIRMMElement then
  begin
    result := TFHIRString.create(TFHIRMMElement(obj).value);
    obj.Free;
  end
  else if (obj is TFHIRObject) and (TFHIRObject(obj).isPrimitive) then
  begin
    result := TFHIRString.create(TFHIRObject(obj).primitiveValue);
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIRString"')
  end;
end;
function asInteger(obj : TFHIRObject) : TFHIRInteger;
begin
  if obj is TFHIRInteger then
    result := obj as TFHIRInteger
  else if obj is TFHIRMMElement then
  begin
    result := TFHIRInteger.create(TFHIRMMElement(obj).value);
    obj.Free;
  end
  else if (obj is TFHIRObject) and (TFHIRObject(obj).isPrimitive) then
  begin
    result := TFHIRInteger.create(TFHIRObject(obj).primitiveValue);
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIRInteger"')
  end;
end;
function asUri(obj : TFHIRObject) : TFHIRUri;
begin
  if obj is TFHIRUri then
    result := obj as TFHIRUri
  else if obj is TFHIRMMElement then
  begin
    result := TFHIRUri.create(TFHIRMMElement(obj).value);
    obj.Free;
  end
  else if (obj is TFHIRObject) and (TFHIRObject(obj).isPrimitive) then
  begin
    result := TFHIRUri.create(TFHIRObject(obj).primitiveValue);
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIRUri"')
  end;
end;
function asInstant(obj : TFHIRObject) : TFHIRInstant;
begin
  if obj is TFHIRInstant then
    result := obj as TFHIRInstant
  else if obj is TFHIRMMElement then
  begin
    result := TFHIRInstant.create(TFslDateTime.fromXml(TFHIRMMElement(obj).value));
    obj.Free;
  end
  else if (obj is TFHIRObject) and (TFHIRObject(obj).isPrimitive) then
  begin
    result := TFHIRInstant.create(TFslDateTime.fromXml(TFHIRObject(obj).primitiveValue));
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIRInstant"')
  end;
end;
function asXhtml(obj : TFHIRObject) : TFHIRXhtml;
begin
  if obj is TFHIRXhtml then
    result := obj as TFHIRXhtml
  else if obj is TFHIRMMElement then
  begin
    result := TFHIRXhtml.create(TFHIRMMElement(obj).value);
    obj.Free;
  end
  else if (obj is TFHIRObject) and (TFHIRObject(obj).isPrimitive) then
  begin
    result := TFHIRXhtml.create(TFHIRObject(obj).primitiveValue);
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIRXhtml"')
  end;
end;
function asBoolean(obj : TFHIRObject) : TFHIRBoolean;
begin
  if obj is TFHIRBoolean then
    result := obj as TFHIRBoolean
  else if obj is TFHIRMMElement then
  begin
    result := TFHIRBoolean.create(TFHIRMMElement(obj).value = 'true');
    obj.Free;
  end
  else if (obj is TFHIRObject) and (TFHIRObject(obj).isPrimitive) then
  begin
    result := TFHIRBoolean.create(TFHIRObject(obj).primitiveValue = 'true');
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIRBoolean"')
  end;
end;
function asBase64Binary(obj : TFHIRObject) : TFHIRBase64Binary;
begin
  if obj is TFHIRBase64Binary then
    result := obj as TFHIRBase64Binary
  else if obj is TFHIRMMElement then
  begin
    result := TFHIRBase64Binary.create(DecodeBase64(TFHIRMMElement(obj).value));
    obj.Free;
  end
  else if (obj is TFHIRObject) and (TFHIRObject(obj).isPrimitive) then
  begin
    result := TFHIRBase64Binary.create(DecodeBase64(TFHIRObject(obj).primitiveValue));
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIRBase64Binary"')
  end;
end;
function asTime(obj : TFHIRObject) : TFHIRTime;
begin
  if obj is TFHIRTime then
    result := obj as TFHIRTime
  else if obj is TFHIRMMElement then
  begin
    result := TFHIRTime.create(TFHIRMMElement(obj).value);
    obj.Free;
  end
  else if (obj is TFHIRObject) and (TFHIRObject(obj).isPrimitive) then
  begin
    result := TFHIRTime.create(TFHIRObject(obj).primitiveValue);
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIRTime"')
  end;
end;
function asDecimal(obj : TFHIRObject) : TFHIRDecimal;
begin
  if obj is TFHIRDecimal then
    result := obj as TFHIRDecimal
  else if obj is TFHIRMMElement then
  begin
    result := TFHIRDecimal.create(TFHIRMMElement(obj).value);
    obj.Free;
  end
  else if (obj is TFHIRObject) and (TFHIRObject(obj).isPrimitive) then
  begin
    result := TFHIRDecimal.create(TFHIRObject(obj).primitiveValue);
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIRDecimal"')
  end;
end;
function asCode(obj : TFHIRObject) : TFHIRCode;
begin
  if obj is TFHIRCode then
    result := obj as TFHIRCode
  else if obj is TFHIRMMElement then
  begin
    result := TFHIRCode.create(TFHIRMMElement(obj).value);
    obj.Free;
  end
  else if (obj is TFHIRObject) and (TFHIRObject(obj).isPrimitive) then
  begin
    result := TFHIRCode.create(TFHIRObject(obj).primitiveValue);
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIRCode"')
  end;
end;
function asCanonical(obj : TFHIRObject) : TFHIRCanonical;
begin
  if obj is TFHIRCanonical then
    result := obj as TFHIRCanonical
  else if obj is TFHIRMMElement then
  begin
    result := TFHIRCanonical.create(TFHIRMMElement(obj).value);
    obj.Free;
  end
  else if (obj is TFHIRObject) and (TFHIRObject(obj).isPrimitive) then
  begin
    result := TFHIRCanonical.create(TFHIRObject(obj).primitiveValue);
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIRCanonical"')
  end;
end;
function asOid(obj : TFHIRObject) : TFHIROid;
begin
  if obj is TFHIROid then
    result := obj as TFHIROid
  else if obj is TFHIRMMElement then
  begin
    result := TFHIROid.create(TFHIRMMElement(obj).value);
    obj.Free;
  end
  else if (obj is TFHIRObject) and (TFHIRObject(obj).isPrimitive) then
  begin
    result := TFHIROid.create(TFHIRObject(obj).primitiveValue);
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIROid"')
  end;
end;
function asUuid(obj : TFHIRObject) : TFHIRUuid;
begin
  if obj is TFHIRUuid then
    result := obj as TFHIRUuid
  else if obj is TFHIRMMElement then
  begin
    result := TFHIRUuid.create(TFHIRMMElement(obj).value);
    obj.Free;
  end
  else if (obj is TFHIRObject) and (TFHIRObject(obj).isPrimitive) then
  begin
    result := TFHIRUuid.create(TFHIRObject(obj).primitiveValue);
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIRUuid"')
  end;
end;
function asUrl(obj : TFHIRObject) : TFHIRUrl;
begin
  if obj is TFHIRUrl then
    result := obj as TFHIRUrl
  else if obj is TFHIRMMElement then
  begin
    result := TFHIRUrl.create(TFHIRMMElement(obj).value);
    obj.Free;
  end
  else if (obj is TFHIRObject) and (TFHIRObject(obj).isPrimitive) then
  begin
    result := TFHIRUrl.create(TFHIRObject(obj).primitiveValue);
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIRUrl"')
  end;
end;
function asMarkdown(obj : TFHIRObject) : TFHIRMarkdown;
begin
  if obj is TFHIRMarkdown then
    result := obj as TFHIRMarkdown
  else if obj is TFHIRMMElement then
  begin
    result := TFHIRMarkdown.create(TFHIRMMElement(obj).value);
    obj.Free;
  end
  else if (obj is TFHIRObject) and (TFHIRObject(obj).isPrimitive) then
  begin
    result := TFHIRMarkdown.create(TFHIRObject(obj).primitiveValue);
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIRMarkdown"')
  end;
end;
function asUnsignedInt(obj : TFHIRObject) : TFHIRUnsignedInt;
begin
  if obj is TFHIRUnsignedInt then
    result := obj as TFHIRUnsignedInt
  else if obj is TFHIRMMElement then
  begin
    result := TFHIRUnsignedInt.create(TFHIRMMElement(obj).value);
    obj.Free;
  end
  else if (obj is TFHIRObject) and (TFHIRObject(obj).isPrimitive) then
  begin
    result := TFHIRUnsignedInt.create(TFHIRObject(obj).primitiveValue);
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIRUnsignedInt"')
  end;
end;
function asId(obj : TFHIRObject) : TFHIRId;
begin
  if obj is TFHIRId then
    result := obj as TFHIRId
  else if obj is TFHIRMMElement then
  begin
    result := TFHIRId.create(TFHIRMMElement(obj).value);
    obj.Free;
  end
  else if (obj is TFHIRObject) and (TFHIRObject(obj).isPrimitive) then
  begin
    result := TFHIRId.create(TFHIRObject(obj).primitiveValue);
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIRId"')
  end;
end;
function asPositiveInt(obj : TFHIRObject) : TFHIRPositiveInt;
begin
  if obj is TFHIRPositiveInt then
    result := obj as TFHIRPositiveInt
  else if obj is TFHIRMMElement then
  begin
    result := TFHIRPositiveInt.create(TFHIRMMElement(obj).value);
    obj.Free;
  end
  else if (obj is TFHIRObject) and (TFHIRObject(obj).isPrimitive) then
  begin
    result := TFHIRPositiveInt.create(TFHIRObject(obj).primitiveValue);
    obj.Free;
  end
  else
  begin
    obj.Free;
    raise EFhirException.Create('Type mismatch: cannot convert from "'+obj.className+'" to "TFHIRPositiveInt"')
  end;
end;

end.

