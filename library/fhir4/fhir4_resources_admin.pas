unit fhir4_resources_admin;

{$I fhir4.inc}

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to
     endorse or promote products derived from this software without specific
     prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

}

{$I fhir.inc}

interface

// FHIR v4.0.0 generated 2019-01-21T22:41:56+11:00

uses
  SysUtils, Classes,
  fsl_base, fsl_utilities, fsl_stream,
  fhir_objects, fhir_utilities, 
  fhir4_base, fhir4_types, fhir4_resources_base;

Type
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
  TFhirBiologicallyDerivedProductCollection = class;
  TFhirBiologicallyDerivedProductCollectionList = class;
  TFhirBiologicallyDerivedProductProcessing = class;
  TFhirBiologicallyDerivedProductProcessingList = class;
  TFhirBiologicallyDerivedProductManipulation = class;
  TFhirBiologicallyDerivedProductManipulationList = class;
  TFhirBiologicallyDerivedProductStorage = class;
  TFhirBiologicallyDerivedProductStorageList = class;
  TFhirBiologicallyDerivedProduct = class;
  TFhirBiologicallyDerivedProductList = class;
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_CATALOGENTRY}
  TFhirCatalogEntryRelatedEntry = class;
  TFhirCatalogEntryRelatedEntryList = class;
  TFhirCatalogEntry = class;
  TFhirCatalogEntryList = class;
{$ENDIF FHIR_CATALOGENTRY}
{$IFDEF FHIR_DEVICE}
  TFhirDeviceUdiCarrier = class;
  TFhirDeviceUdiCarrierList = class;
  TFhirDeviceDeviceName = class;
  TFhirDeviceDeviceNameList = class;
  TFhirDeviceSpecialization = class;
  TFhirDeviceSpecializationList = class;
  TFhirDeviceVersion = class;
  TFhirDeviceVersionList = class;
  TFhirDeviceProperty = class;
  TFhirDevicePropertyList = class;
  TFhirDevice = class;
  TFhirDeviceList = class;
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEMETRIC}
  TFhirDeviceMetricCalibration = class;
  TFhirDeviceMetricCalibrationList = class;
  TFhirDeviceMetric = class;
  TFhirDeviceMetricList = class;
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_ENCOUNTER}
  TFhirEncounterStatusHistory = class;
  TFhirEncounterStatusHistoryList = class;
  TFhirEncounterClassHistory = class;
  TFhirEncounterClassHistoryList = class;
  TFhirEncounterParticipant = class;
  TFhirEncounterParticipantList = class;
  TFhirEncounterDiagnosis = class;
  TFhirEncounterDiagnosisList = class;
  TFhirEncounterHospitalization = class;
  TFhirEncounterHospitalizationList = class;
  TFhirEncounterLocation = class;
  TFhirEncounterLocationList = class;
  TFhirEncounter = class;
  TFhirEncounterList = class;
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  TFhirEndpoint = class;
  TFhirEndpointList = class;
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_EPISODEOFCARE}
  TFhirEpisodeOfCareStatusHistory = class;
  TFhirEpisodeOfCareStatusHistoryList = class;
  TFhirEpisodeOfCareDiagnosis = class;
  TFhirEpisodeOfCareDiagnosisList = class;
  TFhirEpisodeOfCare = class;
  TFhirEpisodeOfCareList = class;
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_GROUP}
  TFhirGroupCharacteristic = class;
  TFhirGroupCharacteristicList = class;
  TFhirGroupMember = class;
  TFhirGroupMemberList = class;
  TFhirGroup = class;
  TFhirGroupList = class;
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
  TFhirHealthcareServiceEligibility = class;
  TFhirHealthcareServiceEligibilityList = class;
  TFhirHealthcareServiceAvailableTime = class;
  TFhirHealthcareServiceAvailableTimeList = class;
  TFhirHealthcareServiceNotAvailable = class;
  TFhirHealthcareServiceNotAvailableList = class;
  TFhirHealthcareService = class;
  TFhirHealthcareServiceList = class;
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_LOCATION}
  TFhirLocationPosition = class;
  TFhirLocationPositionList = class;
  TFhirLocationHoursOfOperation = class;
  TFhirLocationHoursOfOperationList = class;
  TFhirLocation = class;
  TFhirLocationList = class;
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_ORGANIZATION}
  TFhirOrganizationContact = class;
  TFhirOrganizationContactList = class;
  TFhirOrganization = class;
  TFhirOrganizationList = class;
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
  TFhirOrganizationAffiliation = class;
  TFhirOrganizationAffiliationList = class;
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
  TFhirPatientContact = class;
  TFhirPatientContactList = class;
  TFhirPatientCommunication = class;
  TFhirPatientCommunicationList = class;
  TFhirPatientLink = class;
  TFhirPatientLinkList = class;
  TFhirPatient = class;
  TFhirPatientList = class;
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PERSON}
  TFhirPersonLink = class;
  TFhirPersonLinkList = class;
  TFhirPerson = class;
  TFhirPersonList = class;
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
  TFhirPractitionerQualification = class;
  TFhirPractitionerQualificationList = class;
  TFhirPractitioner = class;
  TFhirPractitionerList = class;
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  TFhirPractitionerRoleAvailableTime = class;
  TFhirPractitionerRoleAvailableTimeList = class;
  TFhirPractitionerRoleNotAvailable = class;
  TFhirPractitionerRoleNotAvailableList = class;
  TFhirPractitionerRole = class;
  TFhirPractitionerRoleList = class;
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_RELATEDPERSON}
  TFhirRelatedPersonCommunication = class;
  TFhirRelatedPersonCommunicationList = class;
  TFhirRelatedPerson = class;
  TFhirRelatedPersonList = class;
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_SCHEDULE}
  TFhirSchedule = class;
  TFhirScheduleList = class;
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SLOT}
  TFhirSlot = class;
  TFhirSlotList = class;
{$ENDIF FHIR_SLOT}

{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}

  // How this product was collected.
  TFhirBiologicallyDerivedProductCollection = class (TFhirBackboneElement)
  protected
    FCollector : TFhirReference{TFhirPractitioner};
    FSource : TFhirReference{TFhirPatient};
    FCollected : TFhirType;
    Procedure SetCollector(value : TFhirReference{TFhirPractitioner});
    Procedure SetSource(value : TFhirReference{TFhirPatient});
    Procedure SetCollected(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBiologicallyDerivedProductCollection; overload;
    function Clone : TFhirBiologicallyDerivedProductCollection; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Healthcare professional who is performing the collection. (defined for API consistency)
    property collector : TFhirReference{TFhirPractitioner} read FCollector write SetCollector;
    // Healthcare professional who is performing the collection.
    property collectorElement : TFhirReference{TFhirPractitioner} read FCollector write SetCollector;

    // Typed access to The patient or entity, such as a hospital or vendor in the case of a processed/manipulated/manufactured product, providing the product. (defined for API consistency)
    property source : TFhirReference{TFhirPatient} read FSource write SetSource;
    // The patient or entity, such as a hospital or vendor in the case of a processed/manipulated/manufactured product, providing the product.
    property sourceElement : TFhirReference{TFhirPatient} read FSource write SetSource;

    // Typed access to Time of product collection. (defined for API consistency)
    property collected : TFhirType read FCollected write SetCollected;
    // Time of product collection.
    property collectedElement : TFhirType read FCollected write SetCollected;

  end;

  TFhirBiologicallyDerivedProductCollectionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBiologicallyDerivedProductCollectionList;
    function GetCurrent : TFhirBiologicallyDerivedProductCollection;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBiologicallyDerivedProductCollectionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBiologicallyDerivedProductCollection read GetCurrent;
  end;

  TFhirBiologicallyDerivedProductCollectionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBiologicallyDerivedProductCollection;
    procedure SetItemN(index : Integer; value : TFhirBiologicallyDerivedProductCollection);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBiologicallyDerivedProductCollectionList; Overload;
    function Clone : TFhirBiologicallyDerivedProductCollectionList; Overload;
    function GetEnumerator : TFhirBiologicallyDerivedProductCollectionListEnumerator;
    

    //  Add a FhirBiologicallyDerivedProductCollection to the end of the list.
    function Append : TFhirBiologicallyDerivedProductCollection;

    
    // Add an already existing FhirBiologicallyDerivedProductCollection to the end of the list.
function AddItem(value : TFhirBiologicallyDerivedProductCollection): TFhirBiologicallyDerivedProductCollection; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBiologicallyDerivedProductCollection) : Integer;
    

    // Insert FhirBiologicallyDerivedProductCollection before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBiologicallyDerivedProductCollection;
    

    // Insert an existing FhirBiologicallyDerivedProductCollection before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBiologicallyDerivedProductCollection);
    
    // Get the iIndexth FhirBiologicallyDerivedProductCollection. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBiologicallyDerivedProductCollection);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBiologicallyDerivedProductCollection;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirBiologicallyDerivedProductCollections[index : Integer] : TFhirBiologicallyDerivedProductCollection read GetItemN write SetItemN; default;
  End;

  // Any processing of the product during collection that does not change the fundamental nature of the product. For example adding anti-coagulants during the collection of Peripheral Blood Stem Cells.
  TFhirBiologicallyDerivedProductProcessing = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FProcedure_ : TFhirCodeableConcept;
    FAdditive : TFhirReference{TFhirSubstance};
    FTime : TFhirType;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetProcedure_(value : TFhirCodeableConcept);
    Procedure SetAdditive(value : TFhirReference{TFhirSubstance});
    Procedure SetTime(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBiologicallyDerivedProductProcessing; overload;
    function Clone : TFhirBiologicallyDerivedProductProcessing; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Description of of processing.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of of processing.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Procesing code. (defined for API consistency)
    property procedure_ : TFhirCodeableConcept read FProcedure_ write SetProcedure_;
    // Procesing code.
    property procedure_Element : TFhirCodeableConcept read FProcedure_ write SetProcedure_;

    // Typed access to Substance added during processing. (defined for API consistency)
    property additive : TFhirReference{TFhirSubstance} read FAdditive write SetAdditive;
    // Substance added during processing.
    property additiveElement : TFhirReference{TFhirSubstance} read FAdditive write SetAdditive;

    // Typed access to Time of processing. (defined for API consistency)
    property time : TFhirType read FTime write SetTime;
    // Time of processing.
    property timeElement : TFhirType read FTime write SetTime;

  end;

  TFhirBiologicallyDerivedProductProcessingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBiologicallyDerivedProductProcessingList;
    function GetCurrent : TFhirBiologicallyDerivedProductProcessing;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBiologicallyDerivedProductProcessingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBiologicallyDerivedProductProcessing read GetCurrent;
  end;

  TFhirBiologicallyDerivedProductProcessingList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBiologicallyDerivedProductProcessing;
    procedure SetItemN(index : Integer; value : TFhirBiologicallyDerivedProductProcessing);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBiologicallyDerivedProductProcessingList; Overload;
    function Clone : TFhirBiologicallyDerivedProductProcessingList; Overload;
    function GetEnumerator : TFhirBiologicallyDerivedProductProcessingListEnumerator;
    

    //  Add a FhirBiologicallyDerivedProductProcessing to the end of the list.
    function Append : TFhirBiologicallyDerivedProductProcessing;

    
    // Add an already existing FhirBiologicallyDerivedProductProcessing to the end of the list.
function AddItem(value : TFhirBiologicallyDerivedProductProcessing): TFhirBiologicallyDerivedProductProcessing; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBiologicallyDerivedProductProcessing) : Integer;
    

    // Insert FhirBiologicallyDerivedProductProcessing before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBiologicallyDerivedProductProcessing;
    

    // Insert an existing FhirBiologicallyDerivedProductProcessing before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBiologicallyDerivedProductProcessing);
    
    // Get the iIndexth FhirBiologicallyDerivedProductProcessing. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBiologicallyDerivedProductProcessing);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBiologicallyDerivedProductProcessing;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirBiologicallyDerivedProductProcessings[index : Integer] : TFhirBiologicallyDerivedProductProcessing read GetItemN write SetItemN; default;
  End;

  // Any manipulation of product post-collection that is intended to alter the product.  For example a buffy-coat enrichment or CD8 reduction of Peripheral Blood Stem Cells to make it more suitable for infusion.
  TFhirBiologicallyDerivedProductManipulation = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FTime : TFhirType;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetTime(value : TFhirType);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBiologicallyDerivedProductManipulation; overload;
    function Clone : TFhirBiologicallyDerivedProductManipulation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Description of manipulation.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of manipulation.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Time of manipulation. (defined for API consistency)
    property time : TFhirType read FTime write SetTime;
    // Time of manipulation.
    property timeElement : TFhirType read FTime write SetTime;

  end;

  TFhirBiologicallyDerivedProductManipulationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBiologicallyDerivedProductManipulationList;
    function GetCurrent : TFhirBiologicallyDerivedProductManipulation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBiologicallyDerivedProductManipulationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBiologicallyDerivedProductManipulation read GetCurrent;
  end;

  TFhirBiologicallyDerivedProductManipulationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBiologicallyDerivedProductManipulation;
    procedure SetItemN(index : Integer; value : TFhirBiologicallyDerivedProductManipulation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBiologicallyDerivedProductManipulationList; Overload;
    function Clone : TFhirBiologicallyDerivedProductManipulationList; Overload;
    function GetEnumerator : TFhirBiologicallyDerivedProductManipulationListEnumerator;
    

    //  Add a FhirBiologicallyDerivedProductManipulation to the end of the list.
    function Append : TFhirBiologicallyDerivedProductManipulation;

    
    // Add an already existing FhirBiologicallyDerivedProductManipulation to the end of the list.
function AddItem(value : TFhirBiologicallyDerivedProductManipulation): TFhirBiologicallyDerivedProductManipulation; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBiologicallyDerivedProductManipulation) : Integer;
    

    // Insert FhirBiologicallyDerivedProductManipulation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBiologicallyDerivedProductManipulation;
    

    // Insert an existing FhirBiologicallyDerivedProductManipulation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBiologicallyDerivedProductManipulation);
    
    // Get the iIndexth FhirBiologicallyDerivedProductManipulation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBiologicallyDerivedProductManipulation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBiologicallyDerivedProductManipulation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirBiologicallyDerivedProductManipulations[index : Integer] : TFhirBiologicallyDerivedProductManipulation read GetItemN write SetItemN; default;
  End;

  // Product storage.
  TFhirBiologicallyDerivedProductStorage = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FTemperature : TFhirDecimal;
    FScale : TFhirEnum;
    FDuration : TFhirPeriod;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetTemperature(value : TFhirDecimal);
    Function GetTemperatureST : String;
    Procedure SetTemperatureST(value : String);
    Procedure SetScale(value : TFhirEnum);
    Function GetScaleST : TFhirProductStorageScaleEnum;
    Procedure SetScaleST(value : TFhirProductStorageScaleEnum);
    Procedure SetDuration(value : TFhirPeriod);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBiologicallyDerivedProductStorage; overload;
    function Clone : TFhirBiologicallyDerivedProductStorage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Description of storage.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of storage.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Storage temperature.
    property temperature : String read GetTemperatureST write SetTemperatureST;
    // Storage temperature.
    property temperatureElement : TFhirDecimal read FTemperature write SetTemperature;

    // Temperature scale used.
    property scale : TFhirProductStorageScaleEnum read GetScaleST write SetScaleST;
    property scaleElement : TFhirEnum read FScale write SetScale;

    // Typed access to Storage timeperiod. (defined for API consistency)
    property duration : TFhirPeriod read FDuration write SetDuration;
    // Storage timeperiod.
    property durationElement : TFhirPeriod read FDuration write SetDuration;

  end;

  TFhirBiologicallyDerivedProductStorageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBiologicallyDerivedProductStorageList;
    function GetCurrent : TFhirBiologicallyDerivedProductStorage;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBiologicallyDerivedProductStorageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBiologicallyDerivedProductStorage read GetCurrent;
  end;

  TFhirBiologicallyDerivedProductStorageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBiologicallyDerivedProductStorage;
    procedure SetItemN(index : Integer; value : TFhirBiologicallyDerivedProductStorage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBiologicallyDerivedProductStorageList; Overload;
    function Clone : TFhirBiologicallyDerivedProductStorageList; Overload;
    function GetEnumerator : TFhirBiologicallyDerivedProductStorageListEnumerator;
    

    //  Add a FhirBiologicallyDerivedProductStorage to the end of the list.
    function Append : TFhirBiologicallyDerivedProductStorage;

    
    // Add an already existing FhirBiologicallyDerivedProductStorage to the end of the list.
function AddItem(value : TFhirBiologicallyDerivedProductStorage): TFhirBiologicallyDerivedProductStorage; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBiologicallyDerivedProductStorage) : Integer;
    

    // Insert FhirBiologicallyDerivedProductStorage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBiologicallyDerivedProductStorage;
    

    // Insert an existing FhirBiologicallyDerivedProductStorage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBiologicallyDerivedProductStorage);
    
    // Get the iIndexth FhirBiologicallyDerivedProductStorage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBiologicallyDerivedProductStorage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBiologicallyDerivedProductStorage;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirBiologicallyDerivedProductStorages[index : Integer] : TFhirBiologicallyDerivedProductStorage read GetItemN write SetItemN; default;
  End;

  // A material substance originating from a biological entity intended to be transplanted or infused into another (possibly the same) biological entity.
  TFhirBiologicallyDerivedProduct = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FProductCategory : TFhirEnum;
    FProductCode : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FrequestList : TFhirReferenceList{TFhirServiceRequest};
    FQuantity : TFhirInteger;
    FparentList : TFhirReferenceList{TFhirBiologicallyDerivedProduct};
    FCollection : TFhirBiologicallyDerivedProductCollection;
    FprocessingList : TFhirBiologicallyDerivedProductProcessingList;
    FManipulation : TFhirBiologicallyDerivedProductManipulation;
    FstorageList : TFhirBiologicallyDerivedProductStorageList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetProductCategory(value : TFhirEnum);
    Function GetProductCategoryST : TFhirProductCategoryEnum;
    Procedure SetProductCategoryST(value : TFhirProductCategoryEnum);
    Procedure SetProductCode(value : TFhirCodeableConcept);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirProductStatusEnum;
    Procedure SetStatusST(value : TFhirProductStatusEnum);
    function GetRequestList : TFhirReferenceList{TFhirServiceRequest};
    function GetHasRequestList : Boolean;
    Procedure SetQuantity(value : TFhirInteger);
    Function GetQuantityST : String;
    Procedure SetQuantityST(value : String);
    function GetParentList : TFhirReferenceList{TFhirBiologicallyDerivedProduct};
    function GetHasParentList : Boolean;
    Procedure SetCollection(value : TFhirBiologicallyDerivedProductCollection);
    function GetProcessingList : TFhirBiologicallyDerivedProductProcessingList;
    function GetHasProcessingList : Boolean;
    Procedure SetManipulation(value : TFhirBiologicallyDerivedProductManipulation);
    function GetStorageList : TFhirBiologicallyDerivedProductStorageList;
    function GetHasStorageList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBiologicallyDerivedProduct; overload;
    function Clone : TFhirBiologicallyDerivedProduct; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // This records identifiers associated with this biologically derived product instance that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Broad category of this product.
    property productCategory : TFhirProductCategoryEnum read GetProductCategoryST write SetProductCategoryST;
    property productCategoryElement : TFhirEnum read FProductCategory write SetProductCategory;

    // Typed access to A code that identifies the kind of this biologically derived product (SNOMED Ctcode). (defined for API consistency)
    property productCode : TFhirCodeableConcept read FProductCode write SetProductCode;
    // A code that identifies the kind of this biologically derived product (SNOMED Ctcode).
    property productCodeElement : TFhirCodeableConcept read FProductCode write SetProductCode;

    // Whether the product is currently available.
    property status : TFhirProductStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Procedure request to obtain this biologically derived product.
    property requestList : TFhirReferenceList{TFhirServiceRequest} read GetRequestList;
    property hasRequestList : boolean read GetHasRequestList;

    // Typed access to Number of discrete units within this product.
    property quantity : String read GetQuantityST write SetQuantityST;
    // Number of discrete units within this product.
    property quantityElement : TFhirInteger read FQuantity write SetQuantity;

    // Parent product (if any).
    property parentList : TFhirReferenceList{TFhirBiologicallyDerivedProduct} read GetParentList;
    property hasParentList : boolean read GetHasParentList;

    // Typed access to How this product was collected. (defined for API consistency)
    property collection : TFhirBiologicallyDerivedProductCollection read FCollection write SetCollection;
    // How this product was collected.
    property collectionElement : TFhirBiologicallyDerivedProductCollection read FCollection write SetCollection;

    // Any processing of the product during collection that does not change the fundamental nature of the product. For example adding anti-coagulants during the collection of Peripheral Blood Stem Cells.
    property processingList : TFhirBiologicallyDerivedProductProcessingList read GetProcessingList;
    property hasProcessingList : boolean read GetHasProcessingList;

    // Typed access to Any manipulation of product post-collection that is intended to alter the product.  For example a buffy-coat enrichment or CD8 reduction of Peripheral Blood Stem Cells to make it more suitable for infusion. (defined for API consistency)
    property manipulation : TFhirBiologicallyDerivedProductManipulation read FManipulation write SetManipulation;
    // Any manipulation of product post-collection that is intended to alter the product.  For example a buffy-coat enrichment or CD8 reduction of Peripheral Blood Stem Cells to make it more suitable for infusion.
    property manipulationElement : TFhirBiologicallyDerivedProductManipulation read FManipulation write SetManipulation;

    // Product storage.
    property storageList : TFhirBiologicallyDerivedProductStorageList read GetStorageList;
    property hasStorageList : boolean read GetHasStorageList;

  end;

  TFhirBiologicallyDerivedProductListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBiologicallyDerivedProductList;
    function GetCurrent : TFhirBiologicallyDerivedProduct;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBiologicallyDerivedProductList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBiologicallyDerivedProduct read GetCurrent;
  end;

  TFhirBiologicallyDerivedProductList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBiologicallyDerivedProduct;
    procedure SetItemN(index : Integer; value : TFhirBiologicallyDerivedProduct);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBiologicallyDerivedProductList; Overload;
    function Clone : TFhirBiologicallyDerivedProductList; Overload;
    function GetEnumerator : TFhirBiologicallyDerivedProductListEnumerator;
    

    //  Add a FhirBiologicallyDerivedProduct to the end of the list.
    function Append : TFhirBiologicallyDerivedProduct;

    
    // Add an already existing FhirBiologicallyDerivedProduct to the end of the list.
function AddItem(value : TFhirBiologicallyDerivedProduct): TFhirBiologicallyDerivedProduct; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBiologicallyDerivedProduct) : Integer;
    

    // Insert FhirBiologicallyDerivedProduct before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBiologicallyDerivedProduct;
    

    // Insert an existing FhirBiologicallyDerivedProduct before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBiologicallyDerivedProduct);
    
    // Get the iIndexth FhirBiologicallyDerivedProduct. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBiologicallyDerivedProduct);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBiologicallyDerivedProduct;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirBiologicallyDerivedProducts[index : Integer] : TFhirBiologicallyDerivedProduct read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}

{$IFDEF FHIR_CATALOGENTRY}

  // Used for example, to point to a substance, or to a device used to administer a medication.
  TFhirCatalogEntryRelatedEntry = class (TFhirBackboneElement)
  protected
    FRelationtype : TFhirEnum;
    FItem : TFhirReference{TFhirCatalogEntry};
    Procedure SetRelationtype(value : TFhirEnum);
    Function GetRelationtypeST : TFhirRelationTypeEnum;
    Procedure SetRelationtypeST(value : TFhirRelationTypeEnum);
    Procedure SetItem(value : TFhirReference{TFhirCatalogEntry});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCatalogEntryRelatedEntry; overload;
    function Clone : TFhirCatalogEntryRelatedEntry; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The type of relation to the related item: child, parent, packageContent, containerPackage, usedIn, uses, requires, etc.
    property relationtype : TFhirRelationTypeEnum read GetRelationtypeST write SetRelationtypeST;
    property relationtypeElement : TFhirEnum read FRelationtype write SetRelationtype;

    // Typed access to The reference to the related item. (defined for API consistency)
    property item : TFhirReference{TFhirCatalogEntry} read FItem write SetItem;
    // The reference to the related item.
    property itemElement : TFhirReference{TFhirCatalogEntry} read FItem write SetItem;

  end;

  TFhirCatalogEntryRelatedEntryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCatalogEntryRelatedEntryList;
    function GetCurrent : TFhirCatalogEntryRelatedEntry;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCatalogEntryRelatedEntryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCatalogEntryRelatedEntry read GetCurrent;
  end;

  TFhirCatalogEntryRelatedEntryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCatalogEntryRelatedEntry;
    procedure SetItemN(index : Integer; value : TFhirCatalogEntryRelatedEntry);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCatalogEntryRelatedEntryList; Overload;
    function Clone : TFhirCatalogEntryRelatedEntryList; Overload;
    function GetEnumerator : TFhirCatalogEntryRelatedEntryListEnumerator;
    

    //  Add a FhirCatalogEntryRelatedEntry to the end of the list.
    function Append : TFhirCatalogEntryRelatedEntry;

    
    // Add an already existing FhirCatalogEntryRelatedEntry to the end of the list.
function AddItem(value : TFhirCatalogEntryRelatedEntry): TFhirCatalogEntryRelatedEntry; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCatalogEntryRelatedEntry) : Integer;
    

    // Insert FhirCatalogEntryRelatedEntry before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCatalogEntryRelatedEntry;
    

    // Insert an existing FhirCatalogEntryRelatedEntry before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCatalogEntryRelatedEntry);
    
    // Get the iIndexth FhirCatalogEntryRelatedEntry. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCatalogEntryRelatedEntry);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCatalogEntryRelatedEntry;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCatalogEntryRelatedEntries[index : Integer] : TFhirCatalogEntryRelatedEntry read GetItemN write SetItemN; default;
  End;

  // Catalog entries are wrappers that contextualize items included in a catalog.
  TFhirCatalogEntry = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCodeableConcept;
    FOrderable : TFhirBoolean;
    FReferencedItem : TFhirReference{TFhirMedication};
    FadditionalIdentifierList : TFhirIdentifierList;
    FclassificationList : TFhirCodeableConceptList;
    FStatus : TFhirEnum;
    FValidityPeriod : TFhirPeriod;
    FValidTo : TFhirDateTime;
    FLastUpdated : TFhirDateTime;
    FadditionalCharacteristicList : TFhirCodeableConceptList;
    FadditionalClassificationList : TFhirCodeableConceptList;
    FrelatedEntryList : TFhirCatalogEntryRelatedEntryList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetOrderable(value : TFhirBoolean);
    Function GetOrderableST : Boolean;
    Procedure SetOrderableST(value : Boolean);
    Procedure SetReferencedItem(value : TFhirReference{TFhirMedication});
    function GetAdditionalIdentifierList : TFhirIdentifierList;
    function GetHasAdditionalIdentifierList : Boolean;
    function GetClassificationList : TFhirCodeableConceptList;
    function GetHasClassificationList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirPublicationStatusEnum;
    Procedure SetStatusST(value : TFhirPublicationStatusEnum);
    Procedure SetValidityPeriod(value : TFhirPeriod);
    Procedure SetValidTo(value : TFhirDateTime);
    Function GetValidToST : TFslDateTime;
    Procedure SetValidToST(value : TFslDateTime);
    Procedure SetLastUpdated(value : TFhirDateTime);
    Function GetLastUpdatedST : TFslDateTime;
    Procedure SetLastUpdatedST(value : TFslDateTime);
    function GetAdditionalCharacteristicList : TFhirCodeableConceptList;
    function GetHasAdditionalCharacteristicList : Boolean;
    function GetAdditionalClassificationList : TFhirCodeableConceptList;
    function GetHasAdditionalClassificationList : Boolean;
    function GetRelatedEntryList : TFhirCatalogEntryRelatedEntryList;
    function GetHasRelatedEntryList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCatalogEntry; overload;
    function Clone : TFhirCatalogEntry; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Used in supporting different identifiers for the same product, e.g. manufacturer code and retailer code.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The type of item - medication, device, service, protocol or other. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of item - medication, device, service, protocol or other.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Whether the entry represents an orderable item.
    property orderable : Boolean read GetOrderableST write SetOrderableST;
    // Whether the entry represents an orderable item.
    property orderableElement : TFhirBoolean read FOrderable write SetOrderable;

    // Typed access to The item in a catalog or definition. (defined for API consistency)
    property referencedItem : TFhirReference{TFhirMedication} read FReferencedItem write SetReferencedItem;
    // The item in a catalog or definition.
    property referencedItemElement : TFhirReference{TFhirMedication} read FReferencedItem write SetReferencedItem;

    // Used in supporting related concepts, e.g. NDC to RxNorm.
    property additionalIdentifierList : TFhirIdentifierList read GetAdditionalIdentifierList;
    property hasAdditionalIdentifierList : boolean read GetHasAdditionalIdentifierList;

    // Classes of devices, or ATC for medication.
    property classificationList : TFhirCodeableConceptList read GetClassificationList;
    property hasClassificationList : boolean read GetHasClassificationList;

    // Used to support catalog exchange even for unsupported products, e.g. getting list of medications even if not prescribable.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The time period in which this catalog entry is expected to be active. (defined for API consistency)
    property validityPeriod : TFhirPeriod read FValidityPeriod write SetValidityPeriod;
    // The time period in which this catalog entry is expected to be active.
    property validityPeriodElement : TFhirPeriod read FValidityPeriod write SetValidityPeriod;

    // Typed access to The date until which this catalog entry is expected to be active.
    property validTo : TFslDateTime read GetValidToST write SetValidToST;
    // The date until which this catalog entry is expected to be active.
    property validToElement : TFhirDateTime read FValidTo write SetValidTo;

    // Typed access to Typically date of issue is different from the beginning of the validity. This can be used to see when an item was last updated.
    property lastUpdated : TFslDateTime read GetLastUpdatedST write SetLastUpdatedST;
    // Typically date of issue is different from the beginning of the validity. This can be used to see when an item was last updated.
    property lastUpdatedElement : TFhirDateTime read FLastUpdated write SetLastUpdated;

    // Used for examplefor Out of Formulary, or any specifics.
    property additionalCharacteristicList : TFhirCodeableConceptList read GetAdditionalCharacteristicList;
    property hasAdditionalCharacteristicList : boolean read GetHasAdditionalCharacteristicList;

    // User for example for ATC classification, or.
    property additionalClassificationList : TFhirCodeableConceptList read GetAdditionalClassificationList;
    property hasAdditionalClassificationList : boolean read GetHasAdditionalClassificationList;

    // Used for example, to point to a substance, or to a device used to administer a medication.
    property relatedEntryList : TFhirCatalogEntryRelatedEntryList read GetRelatedEntryList;
    property hasRelatedEntryList : boolean read GetHasRelatedEntryList;

  end;

  TFhirCatalogEntryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCatalogEntryList;
    function GetCurrent : TFhirCatalogEntry;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCatalogEntryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCatalogEntry read GetCurrent;
  end;

  TFhirCatalogEntryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCatalogEntry;
    procedure SetItemN(index : Integer; value : TFhirCatalogEntry);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCatalogEntryList; Overload;
    function Clone : TFhirCatalogEntryList; Overload;
    function GetEnumerator : TFhirCatalogEntryListEnumerator;
    

    //  Add a FhirCatalogEntry to the end of the list.
    function Append : TFhirCatalogEntry;

    
    // Add an already existing FhirCatalogEntry to the end of the list.
function AddItem(value : TFhirCatalogEntry): TFhirCatalogEntry; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCatalogEntry) : Integer;
    

    // Insert FhirCatalogEntry before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCatalogEntry;
    

    // Insert an existing FhirCatalogEntry before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCatalogEntry);
    
    // Get the iIndexth FhirCatalogEntry. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCatalogEntry);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCatalogEntry;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirCatalogEntries[index : Integer] : TFhirCatalogEntry read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CATALOGENTRY}

{$IFDEF FHIR_DEVICE}

  // Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
  TFhirDeviceUdiCarrier = class (TFhirBackboneElement)
  protected
    FDeviceIdentifier : TFhirString;
    FIssuer : TFhirUri;
    FJurisdiction : TFhirUri;
    FCarrierAIDC : TFhirBase64Binary;
    FCarrierHRF : TFhirString;
    FEntryType : TFhirEnum;
    Procedure SetDeviceIdentifier(value : TFhirString);
    Function GetDeviceIdentifierST : String;
    Procedure SetDeviceIdentifierST(value : String);
    Procedure SetIssuer(value : TFhirUri);
    Function GetIssuerST : String;
    Procedure SetIssuerST(value : String);
    Procedure SetJurisdiction(value : TFhirUri);
    Function GetJurisdictionST : String;
    Procedure SetJurisdictionST(value : String);
    Procedure SetCarrierAIDC(value : TFhirBase64Binary);
    Function GetCarrierAIDCST : TBytes;
    Procedure SetCarrierAIDCST(value : TBytes);
    Procedure SetCarrierHRF(value : TFhirString);
    Function GetCarrierHRFST : String;
    Procedure SetCarrierHRFST(value : String);
    Procedure SetEntryType(value : TFhirEnum);
    Function GetEntryTypeST : TFhirUdiEntryTypeEnum;
    Procedure SetEntryTypeST(value : TFhirUdiEntryTypeEnum);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceUdiCarrier; overload;
    function Clone : TFhirDeviceUdiCarrier; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The device identifier (DI) is a mandatory, fixed portion of a UDI that identifies the labeler and the specific version or model of a device.
    property deviceIdentifier : String read GetDeviceIdentifierST write SetDeviceIdentifierST;
    // The device identifier (DI) is a mandatory, fixed portion of a UDI that identifies the labeler and the specific version or model of a device.
    property deviceIdentifierElement : TFhirString read FDeviceIdentifier write SetDeviceIdentifier;

    // Typed access to Organization that is charged with issuing UDIs for devices.  For example, the US FDA issuers include : 1) GS1:  http://hl7.org/fhir/NamingSystem/gs1-di,  2) HIBCC: http://hl7.org/fhir/NamingSystem/hibcc-dI,  3) ICCBBA for blood containers: http://hl7.org/fhir/NamingSystem/iccbba-blood-di,  4) ICCBA for other devices: http://hl7.org/fhir/NamingSystem/iccbba-other-di.
    property issuer : String read GetIssuerST write SetIssuerST;
    // Organization that is charged with issuing UDIs for devices.  For example, the US FDA issuers include : 1) GS1:  http://hl7.org/fhir/NamingSystem/gs1-di,  2) HIBCC: http://hl7.org/fhir/NamingSystem/hibcc-dI,  3) ICCBBA for blood containers: http://hl7.org/fhir/NamingSystem/iccbba-blood-di,  4) ICCBA for other devices: http://hl7.org/fhir/NamingSystem/iccbba-other-di.
    property issuerElement : TFhirUri read FIssuer write SetIssuer;

    // Typed access to The identity of the authoritative source for UDI generation within a  jurisdiction.  All UDIs are globally unique within a single namespace with the appropriate repository uri as the system.  For example,  UDIs of devices managed in the U.S. by the FDA, the value is  http://hl7.org/fhir/NamingSystem/fda-udi.
    property jurisdiction : String read GetJurisdictionST write SetJurisdictionST;
    // The identity of the authoritative source for UDI generation within a  jurisdiction.  All UDIs are globally unique within a single namespace with the appropriate repository uri as the system.  For example,  UDIs of devices managed in the U.S. by the FDA, the value is  http://hl7.org/fhir/NamingSystem/fda-udi.
    property jurisdictionElement : TFhirUri read FJurisdiction write SetJurisdiction;

    // Typed access to The full UDI carrier of the Automatic Identification and Data Capture (AIDC) technology representation of the barcode string as printed on the packaging of the device - e.g., a barcode or RFID.   Because of limitations on character sets in XML and the need to round-trip JSON data through XML, AIDC Formats *SHALL* be base64 encoded.
    property carrierAIDC : TBytes read GetCarrierAIDCST write SetCarrierAIDCST;
    // The full UDI carrier of the Automatic Identification and Data Capture (AIDC) technology representation of the barcode string as printed on the packaging of the device - e.g., a barcode or RFID.   Because of limitations on character sets in XML and the need to round-trip JSON data through XML, AIDC Formats *SHALL* be base64 encoded.
    property carrierAIDCElement : TFhirBase64Binary read FCarrierAIDC write SetCarrierAIDC;

    // Typed access to The full UDI carrier as the human readable form (HRF) representation of the barcode string as printed on the packaging of the device.
    property carrierHRF : String read GetCarrierHRFST write SetCarrierHRFST;
    // The full UDI carrier as the human readable form (HRF) representation of the barcode string as printed on the packaging of the device.
    property carrierHRFElement : TFhirString read FCarrierHRF write SetCarrierHRF;

    // A coded entry to indicate how the data was entered.
    property entryType : TFhirUdiEntryTypeEnum read GetEntryTypeST write SetEntryTypeST;
    property entryTypeElement : TFhirEnum read FEntryType write SetEntryType;

  end;

  TFhirDeviceUdiCarrierListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceUdiCarrierList;
    function GetCurrent : TFhirDeviceUdiCarrier;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceUdiCarrierList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceUdiCarrier read GetCurrent;
  end;

  TFhirDeviceUdiCarrierList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDeviceUdiCarrier;
    procedure SetItemN(index : Integer; value : TFhirDeviceUdiCarrier);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDeviceUdiCarrierList; Overload;
    function Clone : TFhirDeviceUdiCarrierList; Overload;
    function GetEnumerator : TFhirDeviceUdiCarrierListEnumerator;
    

    //  Add a FhirDeviceUdiCarrier to the end of the list.
    function Append : TFhirDeviceUdiCarrier;

    
    // Add an already existing FhirDeviceUdiCarrier to the end of the list.
function AddItem(value : TFhirDeviceUdiCarrier): TFhirDeviceUdiCarrier; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceUdiCarrier) : Integer;
    

    // Insert FhirDeviceUdiCarrier before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceUdiCarrier;
    

    // Insert an existing FhirDeviceUdiCarrier before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceUdiCarrier);
    
    // Get the iIndexth FhirDeviceUdiCarrier. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceUdiCarrier);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceUdiCarrier;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDeviceUdiCarriers[index : Integer] : TFhirDeviceUdiCarrier read GetItemN write SetItemN; default;
  End;

  // This represents the manufacturer's name of the device as provided by the device, from a UDI label, or by a person describing the Device.  This typically would be used when a person provides the name(s) or when the device represents one of the names available from DeviceDefinition.
  TFhirDeviceDeviceName = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FType_ : TFhirEnum;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirDeviceNametypeEnum;
    Procedure SetType_ST(value : TFhirDeviceNametypeEnum);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDeviceName; overload;
    function Clone : TFhirDeviceDeviceName; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The name of the device.
    property name : String read GetNameST write SetNameST;
    // The name of the device.
    property nameElement : TFhirString read FName write SetName;

    // The type of deviceName. UDILabelName | UserFriendlyName | PatientReportedName | ManufactureDeviceName | ModelName.
    property type_ : TFhirDeviceNametypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

  end;

  TFhirDeviceDeviceNameListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDeviceNameList;
    function GetCurrent : TFhirDeviceDeviceName;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDeviceNameList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDeviceName read GetCurrent;
  end;

  TFhirDeviceDeviceNameList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDeviceDeviceName;
    procedure SetItemN(index : Integer; value : TFhirDeviceDeviceName);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDeviceDeviceNameList; Overload;
    function Clone : TFhirDeviceDeviceNameList; Overload;
    function GetEnumerator : TFhirDeviceDeviceNameListEnumerator;
    

    //  Add a FhirDeviceDeviceName to the end of the list.
    function Append : TFhirDeviceDeviceName;

    
    // Add an already existing FhirDeviceDeviceName to the end of the list.
function AddItem(value : TFhirDeviceDeviceName): TFhirDeviceDeviceName; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDeviceName) : Integer;
    

    // Insert FhirDeviceDeviceName before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDeviceName;
    

    // Insert an existing FhirDeviceDeviceName before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDeviceName);
    
    // Get the iIndexth FhirDeviceDeviceName. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDeviceName);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDeviceName;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDeviceDeviceNames[index : Integer] : TFhirDeviceDeviceName read GetItemN write SetItemN; default;
  End;

  // The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication.
  TFhirDeviceSpecialization = class (TFhirBackboneElement)
  protected
    FSystemType : TFhirCodeableConcept;
    FVersion : TFhirString;
    Procedure SetSystemType(value : TFhirCodeableConcept);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceSpecialization; overload;
    function Clone : TFhirDeviceSpecialization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The standard that is used to operate and communicate. (defined for API consistency)
    property systemType : TFhirCodeableConcept read FSystemType write SetSystemType;
    // The standard that is used to operate and communicate.
    property systemTypeElement : TFhirCodeableConcept read FSystemType write SetSystemType;

    // Typed access to The version of the standard that is used to operate and communicate.
    property version : String read GetVersionST write SetVersionST;
    // The version of the standard that is used to operate and communicate.
    property versionElement : TFhirString read FVersion write SetVersion;

  end;

  TFhirDeviceSpecializationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceSpecializationList;
    function GetCurrent : TFhirDeviceSpecialization;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceSpecializationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceSpecialization read GetCurrent;
  end;

  TFhirDeviceSpecializationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDeviceSpecialization;
    procedure SetItemN(index : Integer; value : TFhirDeviceSpecialization);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDeviceSpecializationList; Overload;
    function Clone : TFhirDeviceSpecializationList; Overload;
    function GetEnumerator : TFhirDeviceSpecializationListEnumerator;
    

    //  Add a FhirDeviceSpecialization to the end of the list.
    function Append : TFhirDeviceSpecialization;

    
    // Add an already existing FhirDeviceSpecialization to the end of the list.
function AddItem(value : TFhirDeviceSpecialization): TFhirDeviceSpecialization; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceSpecialization) : Integer;
    

    // Insert FhirDeviceSpecialization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceSpecialization;
    

    // Insert an existing FhirDeviceSpecialization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceSpecialization);
    
    // Get the iIndexth FhirDeviceSpecialization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceSpecialization);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceSpecialization;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDeviceSpecializations[index : Integer] : TFhirDeviceSpecialization read GetItemN write SetItemN; default;
  End;

  // The actual design of the device or software version running on the device.
  TFhirDeviceVersion = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FComponent : TFhirIdentifier;
    FValue : TFhirString;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetComponent(value : TFhirIdentifier);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceVersion; overload;
    function Clone : TFhirDeviceVersion; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The type of the device version. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of the device version.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A single component of the device version. (defined for API consistency)
    property component : TFhirIdentifier read FComponent write SetComponent;
    // A single component of the device version.
    property componentElement : TFhirIdentifier read FComponent write SetComponent;

    // Typed access to The version text.
    property value : String read GetValueST write SetValueST;
    // The version text.
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirDeviceVersionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceVersionList;
    function GetCurrent : TFhirDeviceVersion;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceVersionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceVersion read GetCurrent;
  end;

  TFhirDeviceVersionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDeviceVersion;
    procedure SetItemN(index : Integer; value : TFhirDeviceVersion);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDeviceVersionList; Overload;
    function Clone : TFhirDeviceVersionList; Overload;
    function GetEnumerator : TFhirDeviceVersionListEnumerator;
    

    //  Add a FhirDeviceVersion to the end of the list.
    function Append : TFhirDeviceVersion;

    
    // Add an already existing FhirDeviceVersion to the end of the list.
function AddItem(value : TFhirDeviceVersion): TFhirDeviceVersion; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceVersion) : Integer;
    

    // Insert FhirDeviceVersion before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceVersion;
    

    // Insert an existing FhirDeviceVersion before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceVersion);
    
    // Get the iIndexth FhirDeviceVersion. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceVersion);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceVersion;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDeviceVersions[index : Integer] : TFhirDeviceVersion read GetItemN write SetItemN; default;
  End;

  // The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties.
  TFhirDeviceProperty = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FvalueQuantityList : TFhirQuantityList;
    FvalueCodeList : TFhirCodeableConceptList;
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetValueQuantityList : TFhirQuantityList;
    function GetHasValueQuantityList : Boolean;
    function GetValueCodeList : TFhirCodeableConceptList;
    function GetHasValueCodeList : Boolean;
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceProperty; overload;
    function Clone : TFhirDeviceProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Code that specifies the property DeviceDefinitionPropetyCode (Extensible). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Code that specifies the property DeviceDefinitionPropetyCode (Extensible).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Property value as a quantity.
    property valueQuantityList : TFhirQuantityList read GetValueQuantityList;
    property hasValueQuantityList : boolean read GetHasValueQuantityList;

    // Property value as a code, e.g., NTP4 (synced to NTP).
    property valueCodeList : TFhirCodeableConceptList read GetValueCodeList;
    property hasValueCodeList : boolean read GetHasValueCodeList;

  end;

  TFhirDevicePropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDevicePropertyList;
    function GetCurrent : TFhirDeviceProperty;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDevicePropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceProperty read GetCurrent;
  end;

  TFhirDevicePropertyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDeviceProperty;
    procedure SetItemN(index : Integer; value : TFhirDeviceProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDevicePropertyList; Overload;
    function Clone : TFhirDevicePropertyList; Overload;
    function GetEnumerator : TFhirDevicePropertyListEnumerator;
    

    //  Add a FhirDeviceProperty to the end of the list.
    function Append : TFhirDeviceProperty;

    
    // Add an already existing FhirDeviceProperty to the end of the list.
function AddItem(value : TFhirDeviceProperty): TFhirDeviceProperty; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceProperty) : Integer;
    

    // Insert FhirDeviceProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceProperty;
    

    // Insert an existing FhirDeviceProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceProperty);
    
    // Get the iIndexth FhirDeviceProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceProperty;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDeviceProperties[index : Integer] : TFhirDeviceProperty read GetItemN write SetItemN; default;
  End;

  // A type of a manufactured item that is used in the provision of healthcare without being substantially changed through that activity. The device may be a medical or non-medical device.
  TFhirDevice = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FDefinition : TFhirReference{TFhirDeviceDefinition};
    FudiCarrierList : TFhirDeviceUdiCarrierList;
    FStatus : TFhirEnum;
    FstatusReasonList : TFhirCodeableConceptList;
    FDistinctIdentifier : TFhirString;
    FManufacturer : TFhirString;
    FManufactureDate : TFhirDateTime;
    FExpirationDate : TFhirDateTime;
    FLotNumber : TFhirString;
    FSerialNumber : TFhirString;
    FdeviceNameList : TFhirDeviceDeviceNameList;
    FModelNumber : TFhirString;
    FPartNumber : TFhirString;
    FType_ : TFhirCodeableConcept;
    FspecializationList : TFhirDeviceSpecializationList;
    FversionList : TFhirDeviceVersionList;
    Fproperty_List : TFhirDevicePropertyList;
    FPatient : TFhirReference{TFhirPatient};
    FOwner : TFhirReference{TFhirOrganization};
    FcontactList : TFhirContactPointList;
    FLocation : TFhirReference{TFhirLocation};
    FUrl : TFhirUri;
    FnoteList : TFhirAnnotationList;
    FsafetyList : TFhirCodeableConceptList;
    FParent : TFhirReference{TFhirDevice};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetDefinition(value : TFhirReference{TFhirDeviceDefinition});
    function GetUdiCarrierList : TFhirDeviceUdiCarrierList;
    function GetHasUdiCarrierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirDeviceStatusEnum;
    Procedure SetStatusST(value : TFhirDeviceStatusEnum);
    function GetStatusReasonList : TFhirCodeableConceptList;
    function GetHasStatusReasonList : Boolean;
    Procedure SetDistinctIdentifier(value : TFhirString);
    Function GetDistinctIdentifierST : String;
    Procedure SetDistinctIdentifierST(value : String);
    Procedure SetManufacturer(value : TFhirString);
    Function GetManufacturerST : String;
    Procedure SetManufacturerST(value : String);
    Procedure SetManufactureDate(value : TFhirDateTime);
    Function GetManufactureDateST : TFslDateTime;
    Procedure SetManufactureDateST(value : TFslDateTime);
    Procedure SetExpirationDate(value : TFhirDateTime);
    Function GetExpirationDateST : TFslDateTime;
    Procedure SetExpirationDateST(value : TFslDateTime);
    Procedure SetLotNumber(value : TFhirString);
    Function GetLotNumberST : String;
    Procedure SetLotNumberST(value : String);
    Procedure SetSerialNumber(value : TFhirString);
    Function GetSerialNumberST : String;
    Procedure SetSerialNumberST(value : String);
    function GetDeviceNameList : TFhirDeviceDeviceNameList;
    function GetHasDeviceNameList : Boolean;
    Procedure SetModelNumber(value : TFhirString);
    Function GetModelNumberST : String;
    Procedure SetModelNumberST(value : String);
    Procedure SetPartNumber(value : TFhirString);
    Function GetPartNumberST : String;
    Procedure SetPartNumberST(value : String);
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetSpecializationList : TFhirDeviceSpecializationList;
    function GetHasSpecializationList : Boolean;
    function GetVersionList : TFhirDeviceVersionList;
    function GetHasVersionList : Boolean;
    function GetProperty_List : TFhirDevicePropertyList;
    function GetHasProperty_List : Boolean;
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetOwner(value : TFhirReference{TFhirOrganization});
    function GetContactList : TFhirContactPointList;
    function GetHasContactList : Boolean;
    Procedure SetLocation(value : TFhirReference{TFhirLocation});
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetSafetyList : TFhirCodeableConceptList;
    function GetHasSafetyList : Boolean;
    Procedure SetParent(value : TFhirReference{TFhirDevice});
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDevice; overload;
    function Clone : TFhirDevice; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Unique instance identifiers assigned to a device by manufacturers other organizations or owners.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The reference to the definition for the device. (defined for API consistency)
    property definition : TFhirReference{TFhirDeviceDefinition} read FDefinition write SetDefinition;
    // The reference to the definition for the device.
    property definitionElement : TFhirReference{TFhirDeviceDefinition} read FDefinition write SetDefinition;

    // Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
    property udiCarrierList : TFhirDeviceUdiCarrierList read GetUdiCarrierList;
    property hasUdiCarrierList : boolean read GetHasUdiCarrierList;

    // Status of the Device availability.
    property status : TFhirDeviceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Reason for the dtatus of the Device availability.
    property statusReasonList : TFhirCodeableConceptList read GetStatusReasonList;
    property hasStatusReasonList : boolean read GetHasStatusReasonList;

    // Typed access to The distinct identification string as required by regulation for a human cell, tissue, or cellular and tissue-based product.
    property distinctIdentifier : String read GetDistinctIdentifierST write SetDistinctIdentifierST;
    // The distinct identification string as required by regulation for a human cell, tissue, or cellular and tissue-based product.
    property distinctIdentifierElement : TFhirString read FDistinctIdentifier write SetDistinctIdentifier;

    // Typed access to A name of the manufacturer.
    property manufacturer : String read GetManufacturerST write SetManufacturerST;
    // A name of the manufacturer.
    property manufacturerElement : TFhirString read FManufacturer write SetManufacturer;

    // Typed access to The date and time when the device was manufactured.
    property manufactureDate : TFslDateTime read GetManufactureDateST write SetManufactureDateST;
    // The date and time when the device was manufactured.
    property manufactureDateElement : TFhirDateTime read FManufactureDate write SetManufactureDate;

    // Typed access to The date and time beyond which this device is no longer valid or should not be used (if applicable).
    property expirationDate : TFslDateTime read GetExpirationDateST write SetExpirationDateST;
    // The date and time beyond which this device is no longer valid or should not be used (if applicable).
    property expirationDateElement : TFhirDateTime read FExpirationDate write SetExpirationDate;

    // Typed access to Lot number assigned by the manufacturer.
    property lotNumber : String read GetLotNumberST write SetLotNumberST;
    // Lot number assigned by the manufacturer.
    property lotNumberElement : TFhirString read FLotNumber write SetLotNumber;

    // Typed access to The serial number assigned by the organization when the device was manufactured.
    property serialNumber : String read GetSerialNumberST write SetSerialNumberST;
    // The serial number assigned by the organization when the device was manufactured.
    property serialNumberElement : TFhirString read FSerialNumber write SetSerialNumber;

    // This represents the manufacturer's name of the device as provided by the device, from a UDI label, or by a person describing the Device.  This typically would be used when a person provides the name(s) or when the device represents one of the names available from DeviceDefinition.
    property deviceNameList : TFhirDeviceDeviceNameList read GetDeviceNameList;
    property hasDeviceNameList : boolean read GetHasDeviceNameList;

    // Typed access to The model number for the device.
    property modelNumber : String read GetModelNumberST write SetModelNumberST;
    // The model number for the device.
    property modelNumberElement : TFhirString read FModelNumber write SetModelNumber;

    // Typed access to The part number of the device.
    property partNumber : String read GetPartNumberST write SetPartNumberST;
    // The part number of the device.
    property partNumberElement : TFhirString read FPartNumber write SetPartNumber;

    // Typed access to The kind or type of device. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind or type of device.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication.
    property specializationList : TFhirDeviceSpecializationList read GetSpecializationList;
    property hasSpecializationList : boolean read GetHasSpecializationList;

    // The actual design of the device or software version running on the device.
    property versionList : TFhirDeviceVersionList read GetVersionList;
    property hasVersionList : boolean read GetHasVersionList;

    // The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties.
    property property_List : TFhirDevicePropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // Typed access to Patient information, If the device is affixed to a person. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // Patient information, If the device is affixed to a person.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to An organization that is responsible for the provision and ongoing maintenance of the device. (defined for API consistency)
    property owner : TFhirReference{TFhirOrganization} read FOwner write SetOwner;
    // An organization that is responsible for the provision and ongoing maintenance of the device.
    property ownerElement : TFhirReference{TFhirOrganization} read FOwner write SetOwner;

    // Contact details for an organization or a particular human that is responsible for the device.
    property contactList : TFhirContactPointList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The place where the device can be found. (defined for API consistency)
    property location : TFhirReference{TFhirLocation} read FLocation write SetLocation;
    // The place where the device can be found.
    property locationElement : TFhirReference{TFhirLocation} read FLocation write SetLocation;

    // Typed access to A network address on which the device may be contacted directly.
    property url : String read GetUrlST write SetUrlST;
    // A network address on which the device may be contacted directly.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Descriptive information, usage information or implantation information that is not captured in an existing element.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Provides additional safety characteristics about a medical device.  For example devices containing latex.
    property safetyList : TFhirCodeableConceptList read GetSafetyList;
    property hasSafetyList : boolean read GetHasSafetyList;

    // Typed access to The parent device. (defined for API consistency)
    property parent : TFhirReference{TFhirDevice} read FParent write SetParent;
    // The parent device.
    property parentElement : TFhirReference{TFhirDevice} read FParent write SetParent;

  end;

  TFhirDeviceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceList;
    function GetCurrent : TFhirDevice;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDevice read GetCurrent;
  end;

  TFhirDeviceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDevice;
    procedure SetItemN(index : Integer; value : TFhirDevice);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDeviceList; Overload;
    function Clone : TFhirDeviceList; Overload;
    function GetEnumerator : TFhirDeviceListEnumerator;
    

    //  Add a FhirDevice to the end of the list.
    function Append : TFhirDevice;

    
    // Add an already existing FhirDevice to the end of the list.
function AddItem(value : TFhirDevice): TFhirDevice; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDevice) : Integer;
    

    // Insert FhirDevice before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDevice;
    

    // Insert an existing FhirDevice before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDevice);
    
    // Get the iIndexth FhirDevice. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDevice);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDevice;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDevices[index : Integer] : TFhirDevice read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DEVICE}

{$IFDEF FHIR_DEVICEMETRIC}

  // Describes the calibrations that have been performed or that are required to be performed.
  TFhirDeviceMetricCalibration = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FState : TFhirEnum;
    FTime : TFhirInstant;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirMetricCalibrationTypeEnum;
    Procedure SetType_ST(value : TFhirMetricCalibrationTypeEnum);
    Procedure SetState(value : TFhirEnum);
    Function GetStateST : TFhirMetricCalibrationStateEnum;
    Procedure SetStateST(value : TFhirMetricCalibrationStateEnum);
    Procedure SetTime(value : TFhirInstant);
    Function GetTimeST : TFslDateTime;
    Procedure SetTimeST(value : TFslDateTime);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceMetricCalibration; overload;
    function Clone : TFhirDeviceMetricCalibration; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Describes the type of the calibration method.
    property type_ : TFhirMetricCalibrationTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Describes the state of the calibration.
    property state : TFhirMetricCalibrationStateEnum read GetStateST write SetStateST;
    property stateElement : TFhirEnum read FState write SetState;

    // Typed access to Describes the time last calibration has been performed.
    property time : TFslDateTime read GetTimeST write SetTimeST;
    // Describes the time last calibration has been performed.
    property timeElement : TFhirInstant read FTime write SetTime;

  end;

  TFhirDeviceMetricCalibrationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceMetricCalibrationList;
    function GetCurrent : TFhirDeviceMetricCalibration;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceMetricCalibrationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceMetricCalibration read GetCurrent;
  end;

  TFhirDeviceMetricCalibrationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDeviceMetricCalibration;
    procedure SetItemN(index : Integer; value : TFhirDeviceMetricCalibration);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDeviceMetricCalibrationList; Overload;
    function Clone : TFhirDeviceMetricCalibrationList; Overload;
    function GetEnumerator : TFhirDeviceMetricCalibrationListEnumerator;
    

    //  Add a FhirDeviceMetricCalibration to the end of the list.
    function Append : TFhirDeviceMetricCalibration;

    
    // Add an already existing FhirDeviceMetricCalibration to the end of the list.
function AddItem(value : TFhirDeviceMetricCalibration): TFhirDeviceMetricCalibration; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceMetricCalibration) : Integer;
    

    // Insert FhirDeviceMetricCalibration before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceMetricCalibration;
    

    // Insert an existing FhirDeviceMetricCalibration before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceMetricCalibration);
    
    // Get the iIndexth FhirDeviceMetricCalibration. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceMetricCalibration);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceMetricCalibration;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDeviceMetricCalibrations[index : Integer] : TFhirDeviceMetricCalibration read GetItemN write SetItemN; default;
  End;

  // Describes a measurement, calculation or setting capability of a medical device.
  TFhirDeviceMetric = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCodeableConcept;
    FUnit_ : TFhirCodeableConcept;
    FSource : TFhirReference{TFhirDevice};
    FParent : TFhirReference{TFhirDevice};
    FOperationalStatus : TFhirEnum;
    FColor : TFhirEnum;
    FCategory : TFhirEnum;
    FMeasurementPeriod : TFhirTiming;
    FcalibrationList : TFhirDeviceMetricCalibrationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetUnit_(value : TFhirCodeableConcept);
    Procedure SetSource(value : TFhirReference{TFhirDevice});
    Procedure SetParent(value : TFhirReference{TFhirDevice});
    Procedure SetOperationalStatus(value : TFhirEnum);
    Function GetOperationalStatusST : TFhirMetricOperationalStatusEnum;
    Procedure SetOperationalStatusST(value : TFhirMetricOperationalStatusEnum);
    Procedure SetColor(value : TFhirEnum);
    Function GetColorST : TFhirMetricColorEnum;
    Procedure SetColorST(value : TFhirMetricColorEnum);
    Procedure SetCategory(value : TFhirEnum);
    Function GetCategoryST : TFhirMetricCategoryEnum;
    Procedure SetCategoryST(value : TFhirMetricCategoryEnum);
    Procedure SetMeasurementPeriod(value : TFhirTiming);
    function GetCalibrationList : TFhirDeviceMetricCalibrationList;
    function GetHasCalibrationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceMetric; overload;
    function Clone : TFhirDeviceMetric; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Unique instance identifiers assigned to a device by the device or gateway software, manufacturers, other organizations or owners. For example: handle ID.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Describes the type of the metric. For example: Heart Rate, PEEP Setting, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Describes the type of the metric. For example: Heart Rate, PEEP Setting, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Describes the unit that an observed value determined for this metric will have. For example: Percent, Seconds, etc. (defined for API consistency)
    property unit_ : TFhirCodeableConcept read FUnit_ write SetUnit_;
    // Describes the unit that an observed value determined for this metric will have. For example: Percent, Seconds, etc.
    property unit_Element : TFhirCodeableConcept read FUnit_ write SetUnit_;

    // Typed access to Describes the link to the  Device that this DeviceMetric belongs to and that contains administrative device information such as manufacturer, serial number, etc. (defined for API consistency)
    property source : TFhirReference{TFhirDevice} read FSource write SetSource;
    // Describes the link to the  Device that this DeviceMetric belongs to and that contains administrative device information such as manufacturer, serial number, etc.
    property sourceElement : TFhirReference{TFhirDevice} read FSource write SetSource;

    // Typed access to Describes the link to the  Device that this DeviceMetric belongs to and that provide information about the location of this DeviceMetric in the containment structure of the parent Device. An example would be a Device that represents a Channel. This reference can be used by a client application to distinguish DeviceMetrics that have the same type, but should be interpreted based on their containment location. (defined for API consistency)
    property parent : TFhirReference{TFhirDevice} read FParent write SetParent;
    // Describes the link to the  Device that this DeviceMetric belongs to and that provide information about the location of this DeviceMetric in the containment structure of the parent Device. An example would be a Device that represents a Channel. This reference can be used by a client application to distinguish DeviceMetrics that have the same type, but should be interpreted based on their containment location.
    property parentElement : TFhirReference{TFhirDevice} read FParent write SetParent;

    // Indicates current operational state of the device. For example: On, Off, Standby, etc.
    property operationalStatus : TFhirMetricOperationalStatusEnum read GetOperationalStatusST write SetOperationalStatusST;
    property operationalStatusElement : TFhirEnum read FOperationalStatus write SetOperationalStatus;

    // Describes the color representation for the metric. This is often used to aid clinicians to track and identify parameter types by color. In practice, consider a Patient Monitor that has ECG/HR and Pleth for example; the parameters are displayed in different characteristic colors, such as HR-blue, BP-green, and PR and SpO2- magenta.
    property color : TFhirMetricColorEnum read GetColorST write SetColorST;
    property colorElement : TFhirEnum read FColor write SetColor;

    // Indicates the category of the observation generation process. A DeviceMetric can be for example a setting, measurement, or calculation.
    property category : TFhirMetricCategoryEnum read GetCategoryST write SetCategoryST;
    property categoryElement : TFhirEnum read FCategory write SetCategory;

    // Typed access to Describes the measurement repetition time. This is not necessarily the same as the update period. The measurement repetition time can range from milliseconds up to hours. An example for a measurement repetition time in the range of milliseconds is the sampling rate of an ECG. An example for a measurement repetition time in the range of hours is a NIBP that is triggered automatically every hour. The update period may be different than the measurement repetition time, if the device does not update the {$IFNDEF FPC}Published{$ENDIF} observed value with the same frequency as it was measured. (defined for API consistency)
    property measurementPeriod : TFhirTiming read FMeasurementPeriod write SetMeasurementPeriod;
    // Describes the measurement repetition time. This is not necessarily the same as the update period. The measurement repetition time can range from milliseconds up to hours. An example for a measurement repetition time in the range of milliseconds is the sampling rate of an ECG. An example for a measurement repetition time in the range of hours is a NIBP that is triggered automatically every hour. The update period may be different than the measurement repetition time, if the device does not update the {$IFNDEF FPC}Published{$ENDIF} observed value with the same frequency as it was measured.
    property measurementPeriodElement : TFhirTiming read FMeasurementPeriod write SetMeasurementPeriod;

    // Describes the calibrations that have been performed or that are required to be performed.
    property calibrationList : TFhirDeviceMetricCalibrationList read GetCalibrationList;
    property hasCalibrationList : boolean read GetHasCalibrationList;

  end;

  TFhirDeviceMetricListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceMetricList;
    function GetCurrent : TFhirDeviceMetric;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceMetricList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceMetric read GetCurrent;
  end;

  TFhirDeviceMetricList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDeviceMetric;
    procedure SetItemN(index : Integer; value : TFhirDeviceMetric);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDeviceMetricList; Overload;
    function Clone : TFhirDeviceMetricList; Overload;
    function GetEnumerator : TFhirDeviceMetricListEnumerator;
    

    //  Add a FhirDeviceMetric to the end of the list.
    function Append : TFhirDeviceMetric;

    
    // Add an already existing FhirDeviceMetric to the end of the list.
function AddItem(value : TFhirDeviceMetric): TFhirDeviceMetric; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceMetric) : Integer;
    

    // Insert FhirDeviceMetric before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceMetric;
    

    // Insert an existing FhirDeviceMetric before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceMetric);
    
    // Get the iIndexth FhirDeviceMetric. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceMetric);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceMetric;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirDeviceMetrics[index : Integer] : TFhirDeviceMetric read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DEVICEMETRIC}

{$IFDEF FHIR_ENCOUNTER}

  // The status history permits the encounter resource to contain the status history without needing to read through the historical versions of the resource, or even have the server store them.
  TFhirEncounterStatusHistory = class (TFhirBackboneElement)
  protected
    FStatus : TFhirEnum;
    FPeriod : TFhirPeriod;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirEncounterStatusEnum;
    Procedure SetStatusST(value : TFhirEncounterStatusEnum);
    Procedure SetPeriod(value : TFhirPeriod);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterStatusHistory; overload;
    function Clone : TFhirEncounterStatusHistory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // planned | arrived | triaged | in-progress | onleave | finished | cancelled +.
    property status : TFhirEncounterStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The time that the episode was in the specified status. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The time that the episode was in the specified status.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirEncounterStatusHistoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterStatusHistoryList;
    function GetCurrent : TFhirEncounterStatusHistory;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterStatusHistoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterStatusHistory read GetCurrent;
  end;

  TFhirEncounterStatusHistoryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEncounterStatusHistory;
    procedure SetItemN(index : Integer; value : TFhirEncounterStatusHistory);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEncounterStatusHistoryList; Overload;
    function Clone : TFhirEncounterStatusHistoryList; Overload;
    function GetEnumerator : TFhirEncounterStatusHistoryListEnumerator;
    

    //  Add a FhirEncounterStatusHistory to the end of the list.
    function Append : TFhirEncounterStatusHistory;

    
    // Add an already existing FhirEncounterStatusHistory to the end of the list.
function AddItem(value : TFhirEncounterStatusHistory): TFhirEncounterStatusHistory; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterStatusHistory) : Integer;
    

    // Insert FhirEncounterStatusHistory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterStatusHistory;
    

    // Insert an existing FhirEncounterStatusHistory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterStatusHistory);
    
    // Get the iIndexth FhirEncounterStatusHistory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterStatusHistory);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterStatusHistory;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEncounterStatusHistories[index : Integer] : TFhirEncounterStatusHistory read GetItemN write SetItemN; default;
  End;

  // The class history permits the tracking of the encounters transitions without needing to go  through the resource history.  This would be used for a case where an admission starts of as an emergency encounter, then transitions into an inpatient scenario. Doing this and not restarting a new encounter ensures that any lab/diagnostic results can more easily follow the patient and not require re-processing and not get lost or cancelled during a kind of discharge from emergency to inpatient.
  TFhirEncounterClassHistory = class (TFhirBackboneElement)
  protected
    FClass_ : TFhirCoding;
    FPeriod : TFhirPeriod;
    Procedure SetClass_(value : TFhirCoding);
    Procedure SetPeriod(value : TFhirPeriod);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterClassHistory; overload;
    function Clone : TFhirEncounterClassHistory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to inpatient | outpatient | ambulatory | emergency +. (defined for API consistency)
    property class_ : TFhirCoding read FClass_ write SetClass_;
    // inpatient | outpatient | ambulatory | emergency +.
    property class_Element : TFhirCoding read FClass_ write SetClass_;

    // Typed access to The time that the episode was in the specified class. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The time that the episode was in the specified class.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirEncounterClassHistoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterClassHistoryList;
    function GetCurrent : TFhirEncounterClassHistory;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterClassHistoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterClassHistory read GetCurrent;
  end;

  TFhirEncounterClassHistoryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEncounterClassHistory;
    procedure SetItemN(index : Integer; value : TFhirEncounterClassHistory);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEncounterClassHistoryList; Overload;
    function Clone : TFhirEncounterClassHistoryList; Overload;
    function GetEnumerator : TFhirEncounterClassHistoryListEnumerator;
    

    //  Add a FhirEncounterClassHistory to the end of the list.
    function Append : TFhirEncounterClassHistory;

    
    // Add an already existing FhirEncounterClassHistory to the end of the list.
function AddItem(value : TFhirEncounterClassHistory): TFhirEncounterClassHistory; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterClassHistory) : Integer;
    

    // Insert FhirEncounterClassHistory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterClassHistory;
    

    // Insert an existing FhirEncounterClassHistory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterClassHistory);
    
    // Get the iIndexth FhirEncounterClassHistory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterClassHistory);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterClassHistory;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEncounterClassHistories[index : Integer] : TFhirEncounterClassHistory read GetItemN write SetItemN; default;
  End;

  // The list of people responsible for providing the service.
  TFhirEncounterParticipant = class (TFhirBackboneElement)
  protected
    Ftype_List : TFhirCodeableConceptList;
    FPeriod : TFhirPeriod;
    FIndividual : TFhirReference{TFhirPractitioner};
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetIndividual(value : TFhirReference{TFhirPractitioner});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterParticipant; overload;
    function Clone : TFhirEncounterParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Role of participant in encounter.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to The period of time that the specified participant participated in the encounter. These can overlap or be sub-sets of the overall encounter's period. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time that the specified participant participated in the encounter. These can overlap or be sub-sets of the overall encounter's period.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Persons involved in the encounter other than the patient. (defined for API consistency)
    property individual : TFhirReference{TFhirPractitioner} read FIndividual write SetIndividual;
    // Persons involved in the encounter other than the patient.
    property individualElement : TFhirReference{TFhirPractitioner} read FIndividual write SetIndividual;

  end;

  TFhirEncounterParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterParticipantList;
    function GetCurrent : TFhirEncounterParticipant;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterParticipant read GetCurrent;
  end;

  TFhirEncounterParticipantList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEncounterParticipant;
    procedure SetItemN(index : Integer; value : TFhirEncounterParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEncounterParticipantList; Overload;
    function Clone : TFhirEncounterParticipantList; Overload;
    function GetEnumerator : TFhirEncounterParticipantListEnumerator;
    

    //  Add a FhirEncounterParticipant to the end of the list.
    function Append : TFhirEncounterParticipant;

    
    // Add an already existing FhirEncounterParticipant to the end of the list.
function AddItem(value : TFhirEncounterParticipant): TFhirEncounterParticipant; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterParticipant) : Integer;
    

    // Insert FhirEncounterParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterParticipant;
    

    // Insert an existing FhirEncounterParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterParticipant);
    
    // Get the iIndexth FhirEncounterParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterParticipant;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEncounterParticipants[index : Integer] : TFhirEncounterParticipant read GetItemN write SetItemN; default;
  End;

  // The list of diagnosis relevant to this encounter.
  TFhirEncounterDiagnosis = class (TFhirBackboneElement)
  protected
    FCondition : TFhirReference{TFhirCondition};
    FUse : TFhirCodeableConcept;
    FRank : TFhirPositiveInt;
    Procedure SetCondition(value : TFhirReference{TFhirCondition});
    Procedure SetUse(value : TFhirCodeableConcept);
    Procedure SetRank(value : TFhirPositiveInt);
    Function GetRankST : String;
    Procedure SetRankST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterDiagnosis; overload;
    function Clone : TFhirEncounterDiagnosis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Reason the encounter takes place, as specified using information from another resource. For admissions, this is the admission diagnosis. The indication will typically be a Condition (with other resources referenced in the evidence.detail), or a Procedure. (defined for API consistency)
    property condition : TFhirReference{TFhirCondition} read FCondition write SetCondition;
    // Reason the encounter takes place, as specified using information from another resource. For admissions, this is the admission diagnosis. The indication will typically be a Condition (with other resources referenced in the evidence.detail), or a Procedure.
    property conditionElement : TFhirReference{TFhirCondition} read FCondition write SetCondition;

    // Typed access to Role that this diagnosis has within the encounter (e.g. admission, billing, discharge ?). (defined for API consistency)
    property use : TFhirCodeableConcept read FUse write SetUse;
    // Role that this diagnosis has within the encounter (e.g. admission, billing, discharge ?).
    property useElement : TFhirCodeableConcept read FUse write SetUse;

    // Typed access to Ranking of the diagnosis (for each role type).
    property rank : String read GetRankST write SetRankST;
    // Ranking of the diagnosis (for each role type).
    property rankElement : TFhirPositiveInt read FRank write SetRank;

  end;

  TFhirEncounterDiagnosisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterDiagnosisList;
    function GetCurrent : TFhirEncounterDiagnosis;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterDiagnosisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterDiagnosis read GetCurrent;
  end;

  TFhirEncounterDiagnosisList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEncounterDiagnosis;
    procedure SetItemN(index : Integer; value : TFhirEncounterDiagnosis);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEncounterDiagnosisList; Overload;
    function Clone : TFhirEncounterDiagnosisList; Overload;
    function GetEnumerator : TFhirEncounterDiagnosisListEnumerator;
    

    //  Add a FhirEncounterDiagnosis to the end of the list.
    function Append : TFhirEncounterDiagnosis;

    
    // Add an already existing FhirEncounterDiagnosis to the end of the list.
function AddItem(value : TFhirEncounterDiagnosis): TFhirEncounterDiagnosis; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterDiagnosis) : Integer;
    

    // Insert FhirEncounterDiagnosis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterDiagnosis;
    

    // Insert an existing FhirEncounterDiagnosis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterDiagnosis);
    
    // Get the iIndexth FhirEncounterDiagnosis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterDiagnosis);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterDiagnosis;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEncounterDiagnoses[index : Integer] : TFhirEncounterDiagnosis read GetItemN write SetItemN; default;
  End;

  // Details about the admission to a healthcare service.
  TFhirEncounterHospitalization = class (TFhirBackboneElement)
  protected
    FPreAdmissionIdentifier : TFhirIdentifier;
    FOrigin : TFhirReference{TFhirLocation};
    FAdmitSource : TFhirCodeableConcept;
    FReAdmission : TFhirCodeableConcept;
    FdietPreferenceList : TFhirCodeableConceptList;
    FspecialCourtesyList : TFhirCodeableConceptList;
    FspecialArrangementList : TFhirCodeableConceptList;
    FDestination : TFhirReference{TFhirLocation};
    FDischargeDisposition : TFhirCodeableConcept;
    Procedure SetPreAdmissionIdentifier(value : TFhirIdentifier);
    Procedure SetOrigin(value : TFhirReference{TFhirLocation});
    Procedure SetAdmitSource(value : TFhirCodeableConcept);
    Procedure SetReAdmission(value : TFhirCodeableConcept);
    function GetDietPreferenceList : TFhirCodeableConceptList;
    function GetHasDietPreferenceList : Boolean;
    function GetSpecialCourtesyList : TFhirCodeableConceptList;
    function GetHasSpecialCourtesyList : Boolean;
    function GetSpecialArrangementList : TFhirCodeableConceptList;
    function GetHasSpecialArrangementList : Boolean;
    Procedure SetDestination(value : TFhirReference{TFhirLocation});
    Procedure SetDischargeDisposition(value : TFhirCodeableConcept);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterHospitalization; overload;
    function Clone : TFhirEncounterHospitalization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Pre-admission identifier. (defined for API consistency)
    property preAdmissionIdentifier : TFhirIdentifier read FPreAdmissionIdentifier write SetPreAdmissionIdentifier;
    // Pre-admission identifier.
    property preAdmissionIdentifierElement : TFhirIdentifier read FPreAdmissionIdentifier write SetPreAdmissionIdentifier;

    // Typed access to The location/organization from which the patient came before admission. (defined for API consistency)
    property origin : TFhirReference{TFhirLocation} read FOrigin write SetOrigin;
    // The location/organization from which the patient came before admission.
    property originElement : TFhirReference{TFhirLocation} read FOrigin write SetOrigin;

    // Typed access to From where patient was admitted (physician referral, transfer). (defined for API consistency)
    property admitSource : TFhirCodeableConcept read FAdmitSource write SetAdmitSource;
    // From where patient was admitted (physician referral, transfer).
    property admitSourceElement : TFhirCodeableConcept read FAdmitSource write SetAdmitSource;

    // Typed access to Whether this hospitalization is a readmission and why if known. (defined for API consistency)
    property reAdmission : TFhirCodeableConcept read FReAdmission write SetReAdmission;
    // Whether this hospitalization is a readmission and why if known.
    property reAdmissionElement : TFhirCodeableConcept read FReAdmission write SetReAdmission;

    // Diet preferences reported by the patient.
    property dietPreferenceList : TFhirCodeableConceptList read GetDietPreferenceList;
    property hasDietPreferenceList : boolean read GetHasDietPreferenceList;

    // Special courtesies (VIP, board member).
    property specialCourtesyList : TFhirCodeableConceptList read GetSpecialCourtesyList;
    property hasSpecialCourtesyList : boolean read GetHasSpecialCourtesyList;

    // Any special requests that have been made for this hospitalization encounter, such as the provision of specific equipment or other things.
    property specialArrangementList : TFhirCodeableConceptList read GetSpecialArrangementList;
    property hasSpecialArrangementList : boolean read GetHasSpecialArrangementList;

    // Typed access to Location/organization to which the patient is discharged. (defined for API consistency)
    property destination : TFhirReference{TFhirLocation} read FDestination write SetDestination;
    // Location/organization to which the patient is discharged.
    property destinationElement : TFhirReference{TFhirLocation} read FDestination write SetDestination;

    // Typed access to Category or kind of location after discharge. (defined for API consistency)
    property dischargeDisposition : TFhirCodeableConcept read FDischargeDisposition write SetDischargeDisposition;
    // Category or kind of location after discharge.
    property dischargeDispositionElement : TFhirCodeableConcept read FDischargeDisposition write SetDischargeDisposition;

  end;

  TFhirEncounterHospitalizationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterHospitalizationList;
    function GetCurrent : TFhirEncounterHospitalization;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterHospitalizationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterHospitalization read GetCurrent;
  end;

  TFhirEncounterHospitalizationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEncounterHospitalization;
    procedure SetItemN(index : Integer; value : TFhirEncounterHospitalization);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEncounterHospitalizationList; Overload;
    function Clone : TFhirEncounterHospitalizationList; Overload;
    function GetEnumerator : TFhirEncounterHospitalizationListEnumerator;
    

    //  Add a FhirEncounterHospitalization to the end of the list.
    function Append : TFhirEncounterHospitalization;

    
    // Add an already existing FhirEncounterHospitalization to the end of the list.
function AddItem(value : TFhirEncounterHospitalization): TFhirEncounterHospitalization; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterHospitalization) : Integer;
    

    // Insert FhirEncounterHospitalization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterHospitalization;
    

    // Insert an existing FhirEncounterHospitalization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterHospitalization);
    
    // Get the iIndexth FhirEncounterHospitalization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterHospitalization);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterHospitalization;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEncounterHospitalizations[index : Integer] : TFhirEncounterHospitalization read GetItemN write SetItemN; default;
  End;

  // List of locations where  the patient has been during this encounter.
  TFhirEncounterLocation = class (TFhirBackboneElement)
  protected
    FLocation : TFhirReference{TFhirLocation};
    FStatus : TFhirEnum;
    FPhysicalType : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    Procedure SetLocation(value : TFhirReference{TFhirLocation});
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirEncounterLocationStatusEnum;
    Procedure SetStatusST(value : TFhirEncounterLocationStatusEnum);
    Procedure SetPhysicalType(value : TFhirCodeableConcept);
    Procedure SetPeriod(value : TFhirPeriod);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterLocation; overload;
    function Clone : TFhirEncounterLocation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The location where the encounter takes place. (defined for API consistency)
    property location : TFhirReference{TFhirLocation} read FLocation write SetLocation;
    // The location where the encounter takes place.
    property locationElement : TFhirReference{TFhirLocation} read FLocation write SetLocation;

    // The status of the participants' presence at the specified location during the period specified. If the participant is no longer at the location, then the period will have an end date/time.
    property status : TFhirEncounterLocationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to This will be used to specify the required levels (bed/ward/room/etc.) desired to be recorded to simplify either messaging or query. (defined for API consistency)
    property physicalType : TFhirCodeableConcept read FPhysicalType write SetPhysicalType;
    // This will be used to specify the required levels (bed/ward/room/etc.) desired to be recorded to simplify either messaging or query.
    property physicalTypeElement : TFhirCodeableConcept read FPhysicalType write SetPhysicalType;

    // Typed access to Time period during which the patient was present at the location. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Time period during which the patient was present at the location.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirEncounterLocationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterLocationList;
    function GetCurrent : TFhirEncounterLocation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterLocationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterLocation read GetCurrent;
  end;

  TFhirEncounterLocationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEncounterLocation;
    procedure SetItemN(index : Integer; value : TFhirEncounterLocation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEncounterLocationList; Overload;
    function Clone : TFhirEncounterLocationList; Overload;
    function GetEnumerator : TFhirEncounterLocationListEnumerator;
    

    //  Add a FhirEncounterLocation to the end of the list.
    function Append : TFhirEncounterLocation;

    
    // Add an already existing FhirEncounterLocation to the end of the list.
function AddItem(value : TFhirEncounterLocation): TFhirEncounterLocation; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterLocation) : Integer;
    

    // Insert FhirEncounterLocation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterLocation;
    

    // Insert an existing FhirEncounterLocation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterLocation);
    
    // Get the iIndexth FhirEncounterLocation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterLocation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterLocation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEncounterLocations[index : Integer] : TFhirEncounterLocation read GetItemN write SetItemN; default;
  End;

  // An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient.
  TFhirEncounter = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FstatusHistoryList : TFhirEncounterStatusHistoryList;
    FClass_ : TFhirCoding;
    FclassHistoryList : TFhirEncounterClassHistoryList;
    Ftype_List : TFhirCodeableConceptList;
    FServiceType : TFhirCodeableConcept;
    FPriority : TFhirCodeableConcept;
    FSubject : TFhirReference{TFhirPatient};
    FepisodeOfCareList : TFhirReferenceList{TFhirEpisodeOfCare};
    FbasedOnList : TFhirReferenceList{TFhirServiceRequest};
    FparticipantList : TFhirEncounterParticipantList;
    FappointmentList : TFhirReferenceList{TFhirAppointment};
    FPeriod : TFhirPeriod;
    FLength : TFhirDuration;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList{TFhirCondition};
    FdiagnosisList : TFhirEncounterDiagnosisList;
    FaccountList : TFhirReferenceList{TFhirAccount};
    FHospitalization : TFhirEncounterHospitalization;
    FlocationList : TFhirEncounterLocationList;
    FServiceProvider : TFhirReference{TFhirOrganization};
    FPartOf : TFhirReference{TFhirEncounter};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirEncounterStatusEnum;
    Procedure SetStatusST(value : TFhirEncounterStatusEnum);
    function GetStatusHistoryList : TFhirEncounterStatusHistoryList;
    function GetHasStatusHistoryList : Boolean;
    Procedure SetClass_(value : TFhirCoding);
    function GetClassHistoryList : TFhirEncounterClassHistoryList;
    function GetHasClassHistoryList : Boolean;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    Procedure SetServiceType(value : TFhirCodeableConcept);
    Procedure SetPriority(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{TFhirPatient});
    function GetEpisodeOfCareList : TFhirReferenceList{TFhirEpisodeOfCare};
    function GetHasEpisodeOfCareList : Boolean;
    function GetBasedOnList : TFhirReferenceList{TFhirServiceRequest};
    function GetHasBasedOnList : Boolean;
    function GetParticipantList : TFhirEncounterParticipantList;
    function GetHasParticipantList : Boolean;
    function GetAppointmentList : TFhirReferenceList{TFhirAppointment};
    function GetHasAppointmentList : Boolean;
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetLength(value : TFhirDuration);
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList{TFhirCondition};
    function GetHasReasonReferenceList : Boolean;
    function GetDiagnosisList : TFhirEncounterDiagnosisList;
    function GetHasDiagnosisList : Boolean;
    function GetAccountList : TFhirReferenceList{TFhirAccount};
    function GetHasAccountList : Boolean;
    Procedure SetHospitalization(value : TFhirEncounterHospitalization);
    function GetLocationList : TFhirEncounterLocationList;
    function GetHasLocationList : Boolean;
    Procedure SetServiceProvider(value : TFhirReference{TFhirOrganization});
    Procedure SetPartOf(value : TFhirReference{TFhirEncounter});
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounter; overload;
    function Clone : TFhirEncounter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifier(s) by which this encounter is known.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // planned | arrived | triaged | in-progress | onleave | finished | cancelled +.
    property status : TFhirEncounterStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The status history permits the encounter resource to contain the status history without needing to read through the historical versions of the resource, or even have the server store them.
    property statusHistoryList : TFhirEncounterStatusHistoryList read GetStatusHistoryList;
    property hasStatusHistoryList : boolean read GetHasStatusHistoryList;

    // Typed access to Concepts representing classification of patient encounter such as ambulatory (outpatient), inpatient, emergency, home health or others due to local variations. (defined for API consistency)
    property class_ : TFhirCoding read FClass_ write SetClass_;
    // Concepts representing classification of patient encounter such as ambulatory (outpatient), inpatient, emergency, home health or others due to local variations.
    property class_Element : TFhirCoding read FClass_ write SetClass_;

    // The class history permits the tracking of the encounters transitions without needing to go  through the resource history.  This would be used for a case where an admission starts of as an emergency encounter, then transitions into an inpatient scenario. Doing this and not restarting a new encounter ensures that any lab/diagnostic results can more easily follow the patient and not require re-processing and not get lost or cancelled during a kind of discharge from emergency to inpatient.
    property classHistoryList : TFhirEncounterClassHistoryList read GetClassHistoryList;
    property hasClassHistoryList : boolean read GetHasClassHistoryList;

    // Specific type of encounter (e.g. e-mail consultation, surgical day-care, skilled nursing, rehabilitation).
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to Broad categorization of the service that is to be provided (e.g. cardiology). (defined for API consistency)
    property serviceType : TFhirCodeableConcept read FServiceType write SetServiceType;
    // Broad categorization of the service that is to be provided (e.g. cardiology).
    property serviceTypeElement : TFhirCodeableConcept read FServiceType write SetServiceType;

    // Typed access to Indicates the urgency of the encounter. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // Indicates the urgency of the encounter.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Typed access to The patient or group present at the encounter. (defined for API consistency)
    property subject : TFhirReference{TFhirPatient} read FSubject write SetSubject;
    // The patient or group present at the encounter.
    property subjectElement : TFhirReference{TFhirPatient} read FSubject write SetSubject;

    // Where a specific encounter should be classified as a part of a specific episode(s) of care this field should be used. This association can facilitate grouping of related encounters together for a specific purpose, such as government reporting, issue tracking, association via a common problem.  The association is recorded on the encounter as these are typically created after the episode of care and grouped on entry rather than editing the episode of care to append another encounter to it (the episode of care could span years).
    property episodeOfCareList : TFhirReferenceList{TFhirEpisodeOfCare} read GetEpisodeOfCareList;
    property hasEpisodeOfCareList : boolean read GetHasEpisodeOfCareList;

    // The request this encounter satisfies (e.g. incoming referral or procedure request).
    property basedOnList : TFhirReferenceList{TFhirServiceRequest} read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // The list of people responsible for providing the service.
    property participantList : TFhirEncounterParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // The appointment that scheduled this encounter.
    property appointmentList : TFhirReferenceList{TFhirAppointment} read GetAppointmentList;
    property hasAppointmentList : boolean read GetHasAppointmentList;

    // Typed access to The start and end time of the encounter. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The start and end time of the encounter.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Quantity of time the encounter lasted. This excludes the time during leaves of absence. (defined for API consistency)
    property length : TFhirDuration read FLength write SetLength;
    // Quantity of time the encounter lasted. This excludes the time during leaves of absence.
    property lengthElement : TFhirDuration read FLength write SetLength;

    // Reason the encounter takes place, expressed as a code. For admissions, this can be used for a coded admission diagnosis.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Reason the encounter takes place, expressed as a code. For admissions, this can be used for a coded admission diagnosis.
    property reasonReferenceList : TFhirReferenceList{TFhirCondition} read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // The list of diagnosis relevant to this encounter.
    property diagnosisList : TFhirEncounterDiagnosisList read GetDiagnosisList;
    property hasDiagnosisList : boolean read GetHasDiagnosisList;

    // The set of accounts that may be used for billing for this Encounter.
    property accountList : TFhirReferenceList{TFhirAccount} read GetAccountList;
    property hasAccountList : boolean read GetHasAccountList;

    // Typed access to Details about the admission to a healthcare service. (defined for API consistency)
    property hospitalization : TFhirEncounterHospitalization read FHospitalization write SetHospitalization;
    // Details about the admission to a healthcare service.
    property hospitalizationElement : TFhirEncounterHospitalization read FHospitalization write SetHospitalization;

    // List of locations where  the patient has been during this encounter.
    property locationList : TFhirEncounterLocationList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // Typed access to The organization that is primarily responsible for this Encounter's services. This MAY be the same as the organization on the Patient record, however it could be different, such as if the actor performing the services was from an external organization (which may be billed seperately) for an external consultation.  Refer to the example bundle showing an abbreviated set of Encounters for a colonoscopy. (defined for API consistency)
    property serviceProvider : TFhirReference{TFhirOrganization} read FServiceProvider write SetServiceProvider;
    // The organization that is primarily responsible for this Encounter's services. This MAY be the same as the organization on the Patient record, however it could be different, such as if the actor performing the services was from an external organization (which may be billed seperately) for an external consultation.  Refer to the example bundle showing an abbreviated set of Encounters for a colonoscopy.
    property serviceProviderElement : TFhirReference{TFhirOrganization} read FServiceProvider write SetServiceProvider;

    // Typed access to Another Encounter of which this encounter is a part of (administratively or in time). (defined for API consistency)
    property partOf : TFhirReference{TFhirEncounter} read FPartOf write SetPartOf;
    // Another Encounter of which this encounter is a part of (administratively or in time).
    property partOfElement : TFhirReference{TFhirEncounter} read FPartOf write SetPartOf;

  end;

  TFhirEncounterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterList;
    function GetCurrent : TFhirEncounter;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounter read GetCurrent;
  end;

  TFhirEncounterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEncounter;
    procedure SetItemN(index : Integer; value : TFhirEncounter);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEncounterList; Overload;
    function Clone : TFhirEncounterList; Overload;
    function GetEnumerator : TFhirEncounterListEnumerator;
    

    //  Add a FhirEncounter to the end of the list.
    function Append : TFhirEncounter;

    
    // Add an already existing FhirEncounter to the end of the list.
function AddItem(value : TFhirEncounter): TFhirEncounter; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounter) : Integer;
    

    // Insert FhirEncounter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounter;
    

    // Insert an existing FhirEncounter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounter);
    
    // Get the iIndexth FhirEncounter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounter;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEncounters[index : Integer] : TFhirEncounter read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ENCOUNTER}

{$IFDEF FHIR_ENDPOINT}

  // The technical details of an endpoint that can be used for electronic services, such as for web services providing XDS.b or a REST endpoint for another FHIR server. This may include any security context information.
  TFhirEndpoint = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FConnectionType : TFhirCoding;
    FName : TFhirString;
    FManagingOrganization : TFhirReference{TFhirOrganization};
    FcontactList : TFhirContactPointList;
    FPeriod : TFhirPeriod;
    FpayloadTypeList : TFhirCodeableConceptList;
    FpayloadMimeTypeList : TFhirCodeList;
    FAddress : TFhirUrl;
    FheaderList : TFhirStringList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirEndpointStatusEnum;
    Procedure SetStatusST(value : TFhirEndpointStatusEnum);
    Procedure SetConnectionType(value : TFhirCoding);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetManagingOrganization(value : TFhirReference{TFhirOrganization});
    function GetContactList : TFhirContactPointList;
    function GetHasContactList : Boolean;
    Procedure SetPeriod(value : TFhirPeriod);
    function GetPayloadTypeList : TFhirCodeableConceptList;
    function GetHasPayloadTypeList : Boolean;
    function GetPayloadMimeTypeList : TFhirCodeList;
    function GetHasPayloadMimeTypeList : Boolean;
    Procedure SetAddress(value : TFhirUrl);
    Function GetAddressST : String;
    Procedure SetAddressST(value : String);
    function GetHeaderList : TFhirStringList;
    function GetHasHeaderList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEndpoint; overload;
    function Clone : TFhirEndpoint; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifier for the organization that is used to identify the endpoint across multiple disparate systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // active | suspended | error | off | test.
    property status : TFhirEndpointStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A coded value that represents the technical details of the usage of this endpoint, such as what WSDLs should be used in what way. (e.g. XDS.b/DICOM/cds-hook). (defined for API consistency)
    property connectionType : TFhirCoding read FConnectionType write SetConnectionType;
    // A coded value that represents the technical details of the usage of this endpoint, such as what WSDLs should be used in what way. (e.g. XDS.b/DICOM/cds-hook).
    property connectionTypeElement : TFhirCoding read FConnectionType write SetConnectionType;

    // Typed access to A friendly name that this endpoint can be referred to with.
    property name : String read GetNameST write SetNameST;
    // A friendly name that this endpoint can be referred to with.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The organization that manages this endpoint (even if technically another organization is hosting this in the cloud, it is the organization associated with the data). (defined for API consistency)
    property managingOrganization : TFhirReference{TFhirOrganization} read FManagingOrganization write SetManagingOrganization;
    // The organization that manages this endpoint (even if technically another organization is hosting this in the cloud, it is the organization associated with the data).
    property managingOrganizationElement : TFhirReference{TFhirOrganization} read FManagingOrganization write SetManagingOrganization;

    // Contact details for a human to contact about the subscription. The primary use of this for system administrator troubleshooting.
    property contactList : TFhirContactPointList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The interval during which the endpoint is expected to be operational. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The interval during which the endpoint is expected to be operational.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // The payload type describes the acceptable content that can be communicated on the endpoint.
    property payloadTypeList : TFhirCodeableConceptList read GetPayloadTypeList;
    property hasPayloadTypeList : boolean read GetHasPayloadTypeList;

    // The mime type to send the payload in - e.g. application/fhir+xml, application/fhir+json. If the mime type is not specified, then the sender could send any content (including no content depending on the connectionType).
    property payloadMimeTypeList : TFhirCodeList read GetPayloadMimeTypeList;
    property hasPayloadMimeTypeList : boolean read GetHasPayloadMimeTypeList;

    // Typed access to The uri that describes the actual end-point to connect to.
    property address : String read GetAddressST write SetAddressST;
    // The uri that describes the actual end-point to connect to.
    property addressElement : TFhirUrl read FAddress write SetAddress;

    // Additional headers / information to send as part of the notification.
    property headerList : TFhirStringList read GetHeaderList;
    property hasHeaderList : boolean read GetHasHeaderList;

  end;

  TFhirEndpointListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEndpointList;
    function GetCurrent : TFhirEndpoint;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEndpointList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEndpoint read GetCurrent;
  end;

  TFhirEndpointList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEndpoint;
    procedure SetItemN(index : Integer; value : TFhirEndpoint);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEndpointList; Overload;
    function Clone : TFhirEndpointList; Overload;
    function GetEnumerator : TFhirEndpointListEnumerator;
    

    //  Add a FhirEndpoint to the end of the list.
    function Append : TFhirEndpoint;

    
    // Add an already existing FhirEndpoint to the end of the list.
function AddItem(value : TFhirEndpoint): TFhirEndpoint; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEndpoint) : Integer;
    

    // Insert FhirEndpoint before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEndpoint;
    

    // Insert an existing FhirEndpoint before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEndpoint);
    
    // Get the iIndexth FhirEndpoint. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEndpoint);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEndpoint;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEndpoints[index : Integer] : TFhirEndpoint read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ENDPOINT}

{$IFDEF FHIR_EPISODEOFCARE}

  // The history of statuses that the EpisodeOfCare has been through (without requiring processing the history of the resource).
  TFhirEpisodeOfCareStatusHistory = class (TFhirBackboneElement)
  protected
    FStatus : TFhirEnum;
    FPeriod : TFhirPeriod;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirEpisodeOfCareStatusEnum;
    Procedure SetStatusST(value : TFhirEpisodeOfCareStatusEnum);
    Procedure SetPeriod(value : TFhirPeriod);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEpisodeOfCareStatusHistory; overload;
    function Clone : TFhirEpisodeOfCareStatusHistory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // planned | waitlist | active | onhold | finished | cancelled.
    property status : TFhirEpisodeOfCareStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The period during this EpisodeOfCare that the specific status applied. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period during this EpisodeOfCare that the specific status applied.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirEpisodeOfCareStatusHistoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEpisodeOfCareStatusHistoryList;
    function GetCurrent : TFhirEpisodeOfCareStatusHistory;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEpisodeOfCareStatusHistoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEpisodeOfCareStatusHistory read GetCurrent;
  end;

  TFhirEpisodeOfCareStatusHistoryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEpisodeOfCareStatusHistory;
    procedure SetItemN(index : Integer; value : TFhirEpisodeOfCareStatusHistory);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEpisodeOfCareStatusHistoryList; Overload;
    function Clone : TFhirEpisodeOfCareStatusHistoryList; Overload;
    function GetEnumerator : TFhirEpisodeOfCareStatusHistoryListEnumerator;
    

    //  Add a FhirEpisodeOfCareStatusHistory to the end of the list.
    function Append : TFhirEpisodeOfCareStatusHistory;

    
    // Add an already existing FhirEpisodeOfCareStatusHistory to the end of the list.
function AddItem(value : TFhirEpisodeOfCareStatusHistory): TFhirEpisodeOfCareStatusHistory; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEpisodeOfCareStatusHistory) : Integer;
    

    // Insert FhirEpisodeOfCareStatusHistory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEpisodeOfCareStatusHistory;
    

    // Insert an existing FhirEpisodeOfCareStatusHistory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEpisodeOfCareStatusHistory);
    
    // Get the iIndexth FhirEpisodeOfCareStatusHistory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEpisodeOfCareStatusHistory);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEpisodeOfCareStatusHistory;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEpisodeOfCareStatusHistories[index : Integer] : TFhirEpisodeOfCareStatusHistory read GetItemN write SetItemN; default;
  End;

  // The list of diagnosis relevant to this episode of care.
  TFhirEpisodeOfCareDiagnosis = class (TFhirBackboneElement)
  protected
    FCondition : TFhirReference{TFhirCondition};
    FRole : TFhirCodeableConcept;
    FRank : TFhirPositiveInt;
    Procedure SetCondition(value : TFhirReference{TFhirCondition});
    Procedure SetRole(value : TFhirCodeableConcept);
    Procedure SetRank(value : TFhirPositiveInt);
    Function GetRankST : String;
    Procedure SetRankST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEpisodeOfCareDiagnosis; overload;
    function Clone : TFhirEpisodeOfCareDiagnosis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A list of conditions/problems/diagnoses that this episode of care is intended to be providing care for. (defined for API consistency)
    property condition : TFhirReference{TFhirCondition} read FCondition write SetCondition;
    // A list of conditions/problems/diagnoses that this episode of care is intended to be providing care for.
    property conditionElement : TFhirReference{TFhirCondition} read FCondition write SetCondition;

    // Typed access to Role that this diagnosis has within the episode of care (e.g. admission, billing, discharge ?). (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Role that this diagnosis has within the episode of care (e.g. admission, billing, discharge ?).
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to Ranking of the diagnosis (for each role type).
    property rank : String read GetRankST write SetRankST;
    // Ranking of the diagnosis (for each role type).
    property rankElement : TFhirPositiveInt read FRank write SetRank;

  end;

  TFhirEpisodeOfCareDiagnosisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEpisodeOfCareDiagnosisList;
    function GetCurrent : TFhirEpisodeOfCareDiagnosis;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEpisodeOfCareDiagnosisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEpisodeOfCareDiagnosis read GetCurrent;
  end;

  TFhirEpisodeOfCareDiagnosisList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEpisodeOfCareDiagnosis;
    procedure SetItemN(index : Integer; value : TFhirEpisodeOfCareDiagnosis);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEpisodeOfCareDiagnosisList; Overload;
    function Clone : TFhirEpisodeOfCareDiagnosisList; Overload;
    function GetEnumerator : TFhirEpisodeOfCareDiagnosisListEnumerator;
    

    //  Add a FhirEpisodeOfCareDiagnosis to the end of the list.
    function Append : TFhirEpisodeOfCareDiagnosis;

    
    // Add an already existing FhirEpisodeOfCareDiagnosis to the end of the list.
function AddItem(value : TFhirEpisodeOfCareDiagnosis): TFhirEpisodeOfCareDiagnosis; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEpisodeOfCareDiagnosis) : Integer;
    

    // Insert FhirEpisodeOfCareDiagnosis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEpisodeOfCareDiagnosis;
    

    // Insert an existing FhirEpisodeOfCareDiagnosis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEpisodeOfCareDiagnosis);
    
    // Get the iIndexth FhirEpisodeOfCareDiagnosis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEpisodeOfCareDiagnosis);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEpisodeOfCareDiagnosis;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEpisodeOfCareDiagnoses[index : Integer] : TFhirEpisodeOfCareDiagnosis read GetItemN write SetItemN; default;
  End;

  // An association between a patient and an organization / healthcare provider(s) during which time encounters may occur. The managing organization assumes a level of responsibility for the patient during this time.
  TFhirEpisodeOfCare = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FstatusHistoryList : TFhirEpisodeOfCareStatusHistoryList;
    Ftype_List : TFhirCodeableConceptList;
    FdiagnosisList : TFhirEpisodeOfCareDiagnosisList;
    FPatient : TFhirReference{TFhirPatient};
    FManagingOrganization : TFhirReference{TFhirOrganization};
    FPeriod : TFhirPeriod;
    FreferralRequestList : TFhirReferenceList{TFhirServiceRequest};
    FCareManager : TFhirReference{TFhirPractitioner};
    FteamList : TFhirReferenceList{TFhirCareTeam};
    FaccountList : TFhirReferenceList{TFhirAccount};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirEpisodeOfCareStatusEnum;
    Procedure SetStatusST(value : TFhirEpisodeOfCareStatusEnum);
    function GetStatusHistoryList : TFhirEpisodeOfCareStatusHistoryList;
    function GetHasStatusHistoryList : Boolean;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetDiagnosisList : TFhirEpisodeOfCareDiagnosisList;
    function GetHasDiagnosisList : Boolean;
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetManagingOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetPeriod(value : TFhirPeriod);
    function GetReferralRequestList : TFhirReferenceList{TFhirServiceRequest};
    function GetHasReferralRequestList : Boolean;
    Procedure SetCareManager(value : TFhirReference{TFhirPractitioner});
    function GetTeamList : TFhirReferenceList{TFhirCareTeam};
    function GetHasTeamList : Boolean;
    function GetAccountList : TFhirReferenceList{TFhirAccount};
    function GetHasAccountList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEpisodeOfCare; overload;
    function Clone : TFhirEpisodeOfCare; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The EpisodeOfCare may be known by different identifiers for different contexts of use, such as when an external agency is tracking the Episode for funding purposes.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // planned | waitlist | active | onhold | finished | cancelled.
    property status : TFhirEpisodeOfCareStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The history of statuses that the EpisodeOfCare has been through (without requiring processing the history of the resource).
    property statusHistoryList : TFhirEpisodeOfCareStatusHistoryList read GetStatusHistoryList;
    property hasStatusHistoryList : boolean read GetHasStatusHistoryList;

    // A classification of the type of episode of care; e.g. specialist referral, disease management, type of funded care.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // The list of diagnosis relevant to this episode of care.
    property diagnosisList : TFhirEpisodeOfCareDiagnosisList read GetDiagnosisList;
    property hasDiagnosisList : boolean read GetHasDiagnosisList;

    // Typed access to The patient who is the focus of this episode of care. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The patient who is the focus of this episode of care.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The organization that has assumed the specific responsibilities for the specified duration. (defined for API consistency)
    property managingOrganization : TFhirReference{TFhirOrganization} read FManagingOrganization write SetManagingOrganization;
    // The organization that has assumed the specific responsibilities for the specified duration.
    property managingOrganizationElement : TFhirReference{TFhirOrganization} read FManagingOrganization write SetManagingOrganization;

    // Typed access to The interval during which the managing organization assumes the defined responsibility. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The interval during which the managing organization assumes the defined responsibility.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Referral Request(s) that are fulfilled by this EpisodeOfCare, incoming referrals.
    property referralRequestList : TFhirReferenceList{TFhirServiceRequest} read GetReferralRequestList;
    property hasReferralRequestList : boolean read GetHasReferralRequestList;

    // Typed access to The practitioner that is the care manager/care coordinator for this patient. (defined for API consistency)
    property careManager : TFhirReference{TFhirPractitioner} read FCareManager write SetCareManager;
    // The practitioner that is the care manager/care coordinator for this patient.
    property careManagerElement : TFhirReference{TFhirPractitioner} read FCareManager write SetCareManager;

    // The list of practitioners that may be facilitating this episode of care for specific purposes.
    property teamList : TFhirReferenceList{TFhirCareTeam} read GetTeamList;
    property hasTeamList : boolean read GetHasTeamList;

    // The set of accounts that may be used for billing for this EpisodeOfCare.
    property accountList : TFhirReferenceList{TFhirAccount} read GetAccountList;
    property hasAccountList : boolean read GetHasAccountList;

  end;

  TFhirEpisodeOfCareListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEpisodeOfCareList;
    function GetCurrent : TFhirEpisodeOfCare;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEpisodeOfCareList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEpisodeOfCare read GetCurrent;
  end;

  TFhirEpisodeOfCareList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirEpisodeOfCare;
    procedure SetItemN(index : Integer; value : TFhirEpisodeOfCare);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirEpisodeOfCareList; Overload;
    function Clone : TFhirEpisodeOfCareList; Overload;
    function GetEnumerator : TFhirEpisodeOfCareListEnumerator;
    

    //  Add a FhirEpisodeOfCare to the end of the list.
    function Append : TFhirEpisodeOfCare;

    
    // Add an already existing FhirEpisodeOfCare to the end of the list.
function AddItem(value : TFhirEpisodeOfCare): TFhirEpisodeOfCare; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEpisodeOfCare) : Integer;
    

    // Insert FhirEpisodeOfCare before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEpisodeOfCare;
    

    // Insert an existing FhirEpisodeOfCare before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEpisodeOfCare);
    
    // Get the iIndexth FhirEpisodeOfCare. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEpisodeOfCare);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEpisodeOfCare;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirEpisodeOfCares[index : Integer] : TFhirEpisodeOfCare read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_EPISODEOFCARE}

{$IFDEF FHIR_GROUP}

  // Identifies traits whose presence r absence is shared by members of the group.
  TFhirGroupCharacteristic = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirType;
    FExclude : TFhirBoolean;
    FPeriod : TFhirPeriod;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirType);
    Procedure SetExclude(value : TFhirBoolean);
    Function GetExcludeST : Boolean;
    Procedure SetExcludeST(value : Boolean);
    Procedure SetPeriod(value : TFhirPeriod);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGroupCharacteristic; overload;
    function Clone : TFhirGroupCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A code that identifies the kind of trait being asserted. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies the kind of trait being asserted.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The value of the trait that holds (or does not hold - see 'exclude') for members of the group. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // The value of the trait that holds (or does not hold - see 'exclude') for members of the group.
    property valueElement : TFhirType read FValue write SetValue;

    // Typed access to If true, indicates the characteristic is one that is NOT held by members of the group.
    property exclude : Boolean read GetExcludeST write SetExcludeST;
    // If true, indicates the characteristic is one that is NOT held by members of the group.
    property excludeElement : TFhirBoolean read FExclude write SetExclude;

    // Typed access to The period over which the characteristic is tested; e.g. the patient had an operation during the month of June. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period over which the characteristic is tested; e.g. the patient had an operation during the month of June.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirGroupCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGroupCharacteristicList;
    function GetCurrent : TFhirGroupCharacteristic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirGroupCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGroupCharacteristic read GetCurrent;
  end;

  TFhirGroupCharacteristicList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirGroupCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirGroupCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirGroupCharacteristicList; Overload;
    function Clone : TFhirGroupCharacteristicList; Overload;
    function GetEnumerator : TFhirGroupCharacteristicListEnumerator;
    

    //  Add a FhirGroupCharacteristic to the end of the list.
    function Append : TFhirGroupCharacteristic;

    
    // Add an already existing FhirGroupCharacteristic to the end of the list.
function AddItem(value : TFhirGroupCharacteristic): TFhirGroupCharacteristic; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGroupCharacteristic) : Integer;
    

    // Insert FhirGroupCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGroupCharacteristic;
    

    // Insert an existing FhirGroupCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGroupCharacteristic);
    
    // Get the iIndexth FhirGroupCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGroupCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGroupCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirGroupCharacteristics[index : Integer] : TFhirGroupCharacteristic read GetItemN write SetItemN; default;
  End;

  // Identifies the resource instances that are members of the group.
  TFhirGroupMember = class (TFhirBackboneElement)
  protected
    FEntity : TFhirReference{TFhirPatient};
    FPeriod : TFhirPeriod;
    FInactive : TFhirBoolean;
    Procedure SetEntity(value : TFhirReference{TFhirPatient});
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetInactive(value : TFhirBoolean);
    Function GetInactiveST : Boolean;
    Procedure SetInactiveST(value : Boolean);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGroupMember; overload;
    function Clone : TFhirGroupMember; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A reference to the entity that is a member of the group. Must be consistent with Group.type. If the entity is another group, then the type must be the same. (defined for API consistency)
    property entity : TFhirReference{TFhirPatient} read FEntity write SetEntity;
    // A reference to the entity that is a member of the group. Must be consistent with Group.type. If the entity is another group, then the type must be the same.
    property entityElement : TFhirReference{TFhirPatient} read FEntity write SetEntity;

    // Typed access to The period that the member was in the group, if known. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period that the member was in the group, if known.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to A flag to indicate that the member is no longer in the group, but previously may have been a member.
    property inactive : Boolean read GetInactiveST write SetInactiveST;
    // A flag to indicate that the member is no longer in the group, but previously may have been a member.
    property inactiveElement : TFhirBoolean read FInactive write SetInactive;

  end;

  TFhirGroupMemberListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGroupMemberList;
    function GetCurrent : TFhirGroupMember;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirGroupMemberList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGroupMember read GetCurrent;
  end;

  TFhirGroupMemberList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirGroupMember;
    procedure SetItemN(index : Integer; value : TFhirGroupMember);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirGroupMemberList; Overload;
    function Clone : TFhirGroupMemberList; Overload;
    function GetEnumerator : TFhirGroupMemberListEnumerator;
    

    //  Add a FhirGroupMember to the end of the list.
    function Append : TFhirGroupMember;

    
    // Add an already existing FhirGroupMember to the end of the list.
function AddItem(value : TFhirGroupMember): TFhirGroupMember; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGroupMember) : Integer;
    

    // Insert FhirGroupMember before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGroupMember;
    

    // Insert an existing FhirGroupMember before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGroupMember);
    
    // Get the iIndexth FhirGroupMember. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGroupMember);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGroupMember;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirGroupMembers[index : Integer] : TFhirGroupMember read GetItemN write SetItemN; default;
  End;

  // Represents a defined collection of entities that may be discussed or acted upon collectively but which are not expected to act collectively, and are not formally or legally recognized; i.e. a collection of entities that isn't an Organization.
  TFhirGroup = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FType_ : TFhirEnum;
    FActual : TFhirBoolean;
    FCode : TFhirCodeableConcept;
    FName : TFhirString;
    FQuantity : TFhirUnsignedInt;
    FManagingEntity : TFhirReference{TFhirOrganization};
    FcharacteristicList : TFhirGroupCharacteristicList;
    FmemberList : TFhirGroupMemberList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetActive(value : TFhirBoolean);
    Function GetActiveST : Boolean;
    Procedure SetActiveST(value : Boolean);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirGroupTypeEnum;
    Procedure SetType_ST(value : TFhirGroupTypeEnum);
    Procedure SetActual(value : TFhirBoolean);
    Function GetActualST : Boolean;
    Procedure SetActualST(value : Boolean);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetQuantity(value : TFhirUnsignedInt);
    Function GetQuantityST : String;
    Procedure SetQuantityST(value : String);
    Procedure SetManagingEntity(value : TFhirReference{TFhirOrganization});
    function GetCharacteristicList : TFhirGroupCharacteristicList;
    function GetHasCharacteristicList : Boolean;
    function GetMemberList : TFhirGroupMemberList;
    function GetHasMemberList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGroup; overload;
    function Clone : TFhirGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A unique business identifier for this group.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Indicates whether the record for the group is available for use or is merely being retained for historical purposes.
    property active : Boolean read GetActiveST write SetActiveST;
    // Indicates whether the record for the group is available for use or is merely being retained for historical purposes.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Identifies the broad classification of the kind of resources the group includes.
    property type_ : TFhirGroupTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to If true, indicates that the resource refers to a specific group of real individuals.  If false, the group defines a set of intended individuals.
    property actual : Boolean read GetActualST write SetActualST;
    // If true, indicates that the resource refers to a specific group of real individuals.  If false, the group defines a set of intended individuals.
    property actualElement : TFhirBoolean read FActual write SetActual;

    // Typed access to Provides a specific type of resource the group includes; e.g. "cow", "syringe", etc. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Provides a specific type of resource the group includes; e.g. "cow", "syringe", etc.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to A label assigned to the group for human identification and communication.
    property name : String read GetNameST write SetNameST;
    // A label assigned to the group for human identification and communication.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A count of the number of resource instances that are part of the group.
    property quantity : String read GetQuantityST write SetQuantityST;
    // A count of the number of resource instances that are part of the group.
    property quantityElement : TFhirUnsignedInt read FQuantity write SetQuantity;

    // Typed access to Entity responsible for defining and maintaining Group characteristics and/or registered members. (defined for API consistency)
    property managingEntity : TFhirReference{TFhirOrganization} read FManagingEntity write SetManagingEntity;
    // Entity responsible for defining and maintaining Group characteristics and/or registered members.
    property managingEntityElement : TFhirReference{TFhirOrganization} read FManagingEntity write SetManagingEntity;

    // Identifies traits whose presence r absence is shared by members of the group.
    property characteristicList : TFhirGroupCharacteristicList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

    // Identifies the resource instances that are members of the group.
    property memberList : TFhirGroupMemberList read GetMemberList;
    property hasMemberList : boolean read GetHasMemberList;

  end;

  TFhirGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGroupList;
    function GetCurrent : TFhirGroup;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGroup read GetCurrent;
  end;

  TFhirGroupList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirGroup;
    procedure SetItemN(index : Integer; value : TFhirGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirGroupList; Overload;
    function Clone : TFhirGroupList; Overload;
    function GetEnumerator : TFhirGroupListEnumerator;
    

    //  Add a FhirGroup to the end of the list.
    function Append : TFhirGroup;

    
    // Add an already existing FhirGroup to the end of the list.
function AddItem(value : TFhirGroup): TFhirGroup; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGroup) : Integer;
    

    // Insert FhirGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGroup;
    

    // Insert an existing FhirGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGroup);
    
    // Get the iIndexth FhirGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGroup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGroup;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirGroups[index : Integer] : TFhirGroup read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_GROUP}

{$IFDEF FHIR_HEALTHCARESERVICE}

  // Does this service have specific eligibility requirements that need to be met in order to use the service?
  TFhirHealthcareServiceEligibility = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FComment : TFhirMarkdown;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetComment(value : TFhirMarkdown);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirHealthcareServiceEligibility; overload;
    function Clone : TFhirHealthcareServiceEligibility; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Coded value for the eligibility. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Coded value for the eligibility.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Describes the eligibility conditions for the service.
    property comment : String read GetCommentST write SetCommentST;
    // Describes the eligibility conditions for the service.
    property commentElement : TFhirMarkdown read FComment write SetComment;

  end;

  TFhirHealthcareServiceEligibilityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirHealthcareServiceEligibilityList;
    function GetCurrent : TFhirHealthcareServiceEligibility;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirHealthcareServiceEligibilityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirHealthcareServiceEligibility read GetCurrent;
  end;

  TFhirHealthcareServiceEligibilityList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirHealthcareServiceEligibility;
    procedure SetItemN(index : Integer; value : TFhirHealthcareServiceEligibility);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirHealthcareServiceEligibilityList; Overload;
    function Clone : TFhirHealthcareServiceEligibilityList; Overload;
    function GetEnumerator : TFhirHealthcareServiceEligibilityListEnumerator;
    

    //  Add a FhirHealthcareServiceEligibility to the end of the list.
    function Append : TFhirHealthcareServiceEligibility;

    
    // Add an already existing FhirHealthcareServiceEligibility to the end of the list.
function AddItem(value : TFhirHealthcareServiceEligibility): TFhirHealthcareServiceEligibility; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirHealthcareServiceEligibility) : Integer;
    

    // Insert FhirHealthcareServiceEligibility before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirHealthcareServiceEligibility;
    

    // Insert an existing FhirHealthcareServiceEligibility before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirHealthcareServiceEligibility);
    
    // Get the iIndexth FhirHealthcareServiceEligibility. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirHealthcareServiceEligibility);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirHealthcareServiceEligibility;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirHealthcareServiceEligibilities[index : Integer] : TFhirHealthcareServiceEligibility read GetItemN write SetItemN; default;
  End;

  // A collection of times that the Service Site is available.
  TFhirHealthcareServiceAvailableTime = class (TFhirBackboneElement)
  protected
    FDaysOfWeek : TFhirEnumList;
    FAllDay : TFhirBoolean;
    FAvailableStartTime : TFhirTime;
    FAvailableEndTime : TFhirTime;
    function GetDaysOfWeek : TFhirEnumList;
    function GetHasDaysOfWeek : Boolean;
    Function GetDaysOfWeekST : TFhirDaysOfWeekEnumList;
    Procedure SetDaysOfWeekST(value : TFhirDaysOfWeekEnumList);
    Procedure SetAllDay(value : TFhirBoolean);
    Function GetAllDayST : Boolean;
    Procedure SetAllDayST(value : Boolean);
    Procedure SetAvailableStartTime(value : TFhirTime);
    Function GetAvailableStartTimeST : String;
    Procedure SetAvailableStartTimeST(value : String);
    Procedure SetAvailableEndTime(value : TFhirTime);
    Function GetAvailableEndTimeST : String;
    Procedure SetAvailableEndTimeST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirHealthcareServiceAvailableTime; overload;
    function Clone : TFhirHealthcareServiceAvailableTime; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Indicates which days of the week are available between the start and end Times.
    property daysOfWeek : TFhirDaysOfWeekEnumList read GetDaysOfWeekST write SetDaysOfWeekST;
    property daysOfWeekList : TFhirEnumList read GetDaysOfWeek;
    property hasDaysOfWeek : boolean read GetHasDaysOfWeek;
    // Typed access to Is this always available? (hence times are irrelevant) e.g. 24 hour service.
    property allDay : Boolean read GetAllDayST write SetAllDayST;
    // Is this always available? (hence times are irrelevant) e.g. 24 hour service.
    property allDayElement : TFhirBoolean read FAllDay write SetAllDay;

    // Typed access to The opening time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableStartTime : String read GetAvailableStartTimeST write SetAvailableStartTimeST;
    // The opening time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableStartTimeElement : TFhirTime read FAvailableStartTime write SetAvailableStartTime;

    // Typed access to The closing time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableEndTime : String read GetAvailableEndTimeST write SetAvailableEndTimeST;
    // The closing time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableEndTimeElement : TFhirTime read FAvailableEndTime write SetAvailableEndTime;

  end;

  TFhirHealthcareServiceAvailableTimeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirHealthcareServiceAvailableTimeList;
    function GetCurrent : TFhirHealthcareServiceAvailableTime;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirHealthcareServiceAvailableTimeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirHealthcareServiceAvailableTime read GetCurrent;
  end;

  TFhirHealthcareServiceAvailableTimeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirHealthcareServiceAvailableTime;
    procedure SetItemN(index : Integer; value : TFhirHealthcareServiceAvailableTime);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirHealthcareServiceAvailableTimeList; Overload;
    function Clone : TFhirHealthcareServiceAvailableTimeList; Overload;
    function GetEnumerator : TFhirHealthcareServiceAvailableTimeListEnumerator;
    

    //  Add a FhirHealthcareServiceAvailableTime to the end of the list.
    function Append : TFhirHealthcareServiceAvailableTime;

    
    // Add an already existing FhirHealthcareServiceAvailableTime to the end of the list.
function AddItem(value : TFhirHealthcareServiceAvailableTime): TFhirHealthcareServiceAvailableTime; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirHealthcareServiceAvailableTime) : Integer;
    

    // Insert FhirHealthcareServiceAvailableTime before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirHealthcareServiceAvailableTime;
    

    // Insert an existing FhirHealthcareServiceAvailableTime before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirHealthcareServiceAvailableTime);
    
    // Get the iIndexth FhirHealthcareServiceAvailableTime. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirHealthcareServiceAvailableTime);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirHealthcareServiceAvailableTime;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirHealthcareServiceAvailableTimes[index : Integer] : TFhirHealthcareServiceAvailableTime read GetItemN write SetItemN; default;
  End;

  // The HealthcareService is not available during this period of time due to the provided reason.
  TFhirHealthcareServiceNotAvailable = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FDuring : TFhirPeriod;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetDuring(value : TFhirPeriod);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirHealthcareServiceNotAvailable; overload;
    function Clone : TFhirHealthcareServiceNotAvailable; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The reason that can be presented to the user as to why this time is not available.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The reason that can be presented to the user as to why this time is not available.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Service is not available (seasonally or for a public holiday) from this date. (defined for API consistency)
    property during : TFhirPeriod read FDuring write SetDuring;
    // Service is not available (seasonally or for a public holiday) from this date.
    property duringElement : TFhirPeriod read FDuring write SetDuring;

  end;

  TFhirHealthcareServiceNotAvailableListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirHealthcareServiceNotAvailableList;
    function GetCurrent : TFhirHealthcareServiceNotAvailable;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirHealthcareServiceNotAvailableList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirHealthcareServiceNotAvailable read GetCurrent;
  end;

  TFhirHealthcareServiceNotAvailableList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirHealthcareServiceNotAvailable;
    procedure SetItemN(index : Integer; value : TFhirHealthcareServiceNotAvailable);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirHealthcareServiceNotAvailableList; Overload;
    function Clone : TFhirHealthcareServiceNotAvailableList; Overload;
    function GetEnumerator : TFhirHealthcareServiceNotAvailableListEnumerator;
    

    //  Add a FhirHealthcareServiceNotAvailable to the end of the list.
    function Append : TFhirHealthcareServiceNotAvailable;

    
    // Add an already existing FhirHealthcareServiceNotAvailable to the end of the list.
function AddItem(value : TFhirHealthcareServiceNotAvailable): TFhirHealthcareServiceNotAvailable; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirHealthcareServiceNotAvailable) : Integer;
    

    // Insert FhirHealthcareServiceNotAvailable before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirHealthcareServiceNotAvailable;
    

    // Insert an existing FhirHealthcareServiceNotAvailable before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirHealthcareServiceNotAvailable);
    
    // Get the iIndexth FhirHealthcareServiceNotAvailable. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirHealthcareServiceNotAvailable);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirHealthcareServiceNotAvailable;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirHealthcareServiceNotAvailables[index : Integer] : TFhirHealthcareServiceNotAvailable read GetItemN write SetItemN; default;
  End;

  // The details of a healthcare service available at a location.
  TFhirHealthcareService = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FProvidedBy : TFhirReference{TFhirOrganization};
    FcategoryList : TFhirCodeableConceptList;
    Ftype_List : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FlocationList : TFhirReferenceList{TFhirLocation};
    FName : TFhirString;
    FComment : TFhirString;
    FExtraDetails : TFhirMarkdown;
    FPhoto : TFhirAttachment;
    FtelecomList : TFhirContactPointList;
    FcoverageAreaList : TFhirReferenceList{TFhirLocation};
    FserviceProvisionCodeList : TFhirCodeableConceptList;
    FeligibilityList : TFhirHealthcareServiceEligibilityList;
    Fprogram_List : TFhirCodeableConceptList;
    FcharacteristicList : TFhirCodeableConceptList;
    FcommunicationList : TFhirCodeableConceptList;
    FreferralMethodList : TFhirCodeableConceptList;
    FAppointmentRequired : TFhirBoolean;
    FavailableTimeList : TFhirHealthcareServiceAvailableTimeList;
    FnotAvailableList : TFhirHealthcareServiceNotAvailableList;
    FAvailabilityExceptions : TFhirString;
    FendpointList : TFhirReferenceList{TFhirEndpoint};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetActive(value : TFhirBoolean);
    Function GetActiveST : Boolean;
    Procedure SetActiveST(value : Boolean);
    Procedure SetProvidedBy(value : TFhirReference{TFhirOrganization});
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    function GetLocationList : TFhirReferenceList{TFhirLocation};
    function GetHasLocationList : Boolean;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);
    Procedure SetExtraDetails(value : TFhirMarkdown);
    Function GetExtraDetailsST : String;
    Procedure SetExtraDetailsST(value : String);
    Procedure SetPhoto(value : TFhirAttachment);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    function GetCoverageAreaList : TFhirReferenceList{TFhirLocation};
    function GetHasCoverageAreaList : Boolean;
    function GetServiceProvisionCodeList : TFhirCodeableConceptList;
    function GetHasServiceProvisionCodeList : Boolean;
    function GetEligibilityList : TFhirHealthcareServiceEligibilityList;
    function GetHasEligibilityList : Boolean;
    function GetProgram_List : TFhirCodeableConceptList;
    function GetHasProgram_List : Boolean;
    function GetCharacteristicList : TFhirCodeableConceptList;
    function GetHasCharacteristicList : Boolean;
    function GetCommunicationList : TFhirCodeableConceptList;
    function GetHasCommunicationList : Boolean;
    function GetReferralMethodList : TFhirCodeableConceptList;
    function GetHasReferralMethodList : Boolean;
    Procedure SetAppointmentRequired(value : TFhirBoolean);
    Function GetAppointmentRequiredST : Boolean;
    Procedure SetAppointmentRequiredST(value : Boolean);
    function GetAvailableTimeList : TFhirHealthcareServiceAvailableTimeList;
    function GetHasAvailableTimeList : Boolean;
    function GetNotAvailableList : TFhirHealthcareServiceNotAvailableList;
    function GetHasNotAvailableList : Boolean;
    Procedure SetAvailabilityExceptions(value : TFhirString);
    Function GetAvailabilityExceptionsST : String;
    Procedure SetAvailabilityExceptionsST(value : String);
    function GetEndpointList : TFhirReferenceList{TFhirEndpoint};
    function GetHasEndpointList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirHealthcareService; overload;
    function Clone : TFhirHealthcareService; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // External identifiers for this item.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to This flag is used to mark the record to not be used. This is not used when a center is closed for maintenance, or for holidays, the notAvailable period is to be used for this.
    property active : Boolean read GetActiveST write SetActiveST;
    // This flag is used to mark the record to not be used. This is not used when a center is closed for maintenance, or for holidays, the notAvailable period is to be used for this.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to The organization that provides this healthcare service. (defined for API consistency)
    property providedBy : TFhirReference{TFhirOrganization} read FProvidedBy write SetProvidedBy;
    // The organization that provides this healthcare service.
    property providedByElement : TFhirReference{TFhirOrganization} read FProvidedBy write SetProvidedBy;

    // Identifies the broad category of service being performed or delivered.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // The specific type of service that may be delivered or performed.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Collection of specialties handled by the service site. This is more of a medical term.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // The location(s) where this healthcare service may be provided.
    property locationList : TFhirReferenceList{TFhirLocation} read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // Typed access to Further description of the service as it would be presented to a consumer while searching.
    property name : String read GetNameST write SetNameST;
    // Further description of the service as it would be presented to a consumer while searching.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Any additional description of the service and/or any specific issues not covered by the other attributes, which can be displayed as further detail under the serviceName.
    property comment : String read GetCommentST write SetCommentST;
    // Any additional description of the service and/or any specific issues not covered by the other attributes, which can be displayed as further detail under the serviceName.
    property commentElement : TFhirString read FComment write SetComment;

    // Typed access to Extra details about the service that can't be placed in the other fields.
    property extraDetails : String read GetExtraDetailsST write SetExtraDetailsST;
    // Extra details about the service that can't be placed in the other fields.
    property extraDetailsElement : TFhirMarkdown read FExtraDetails write SetExtraDetails;

    // Typed access to If there is a photo/symbol associated with this HealthcareService, it may be included here to facilitate quick identification of the service in a list. (defined for API consistency)
    property photo : TFhirAttachment read FPhoto write SetPhoto;
    // If there is a photo/symbol associated with this HealthcareService, it may be included here to facilitate quick identification of the service in a list.
    property photoElement : TFhirAttachment read FPhoto write SetPhoto;

    // List of contacts related to this specific healthcare service.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // The location(s) that this service is available to (not where the service is provided).
    property coverageAreaList : TFhirReferenceList{TFhirLocation} read GetCoverageAreaList;
    property hasCoverageAreaList : boolean read GetHasCoverageAreaList;

    // The code(s) that detail the conditions under which the healthcare service is available/offered.
    property serviceProvisionCodeList : TFhirCodeableConceptList read GetServiceProvisionCodeList;
    property hasServiceProvisionCodeList : boolean read GetHasServiceProvisionCodeList;

    // Does this service have specific eligibility requirements that need to be met in order to use the service?
    property eligibilityList : TFhirHealthcareServiceEligibilityList read GetEligibilityList;
    property hasEligibilityList : boolean read GetHasEligibilityList;

    // Programs that this service is applicable to.
    property program_List : TFhirCodeableConceptList read GetProgram_List;
    property hasProgram_List : boolean read GetHasProgram_List;

    // Collection of characteristics (attributes).
    property characteristicList : TFhirCodeableConceptList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

    // Some services are specifically made available in multiple languages, this property permits a directory to declare the languages this is offered in. Typically this is only provided where a service operates in communities with mixed languages used.
    property communicationList : TFhirCodeableConceptList read GetCommunicationList;
    property hasCommunicationList : boolean read GetHasCommunicationList;

    // Ways that the service accepts referrals, if this is not provided then it is implied that no referral is required.
    property referralMethodList : TFhirCodeableConceptList read GetReferralMethodList;
    property hasReferralMethodList : boolean read GetHasReferralMethodList;

    // Typed access to Indicates whether or not a prospective consumer will require an appointment for a particular service at a site to be provided by the Organization. Indicates if an appointment is required for access to this service.
    property appointmentRequired : Boolean read GetAppointmentRequiredST write SetAppointmentRequiredST;
    // Indicates whether or not a prospective consumer will require an appointment for a particular service at a site to be provided by the Organization. Indicates if an appointment is required for access to this service.
    property appointmentRequiredElement : TFhirBoolean read FAppointmentRequired write SetAppointmentRequired;

    // A collection of times that the Service Site is available.
    property availableTimeList : TFhirHealthcareServiceAvailableTimeList read GetAvailableTimeList;
    property hasAvailableTimeList : boolean read GetHasAvailableTimeList;

    // The HealthcareService is not available during this period of time due to the provided reason.
    property notAvailableList : TFhirHealthcareServiceNotAvailableList read GetNotAvailableList;
    property hasNotAvailableList : boolean read GetHasNotAvailableList;

    // Typed access to A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
    property availabilityExceptions : String read GetAvailabilityExceptionsST write SetAvailabilityExceptionsST;
    // A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
    property availabilityExceptionsElement : TFhirString read FAvailabilityExceptions write SetAvailabilityExceptions;

    // Technical endpoints providing access to services operated for the specific healthcare services defined at this resource.
    property endpointList : TFhirReferenceList{TFhirEndpoint} read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

  end;

  TFhirHealthcareServiceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirHealthcareServiceList;
    function GetCurrent : TFhirHealthcareService;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirHealthcareServiceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirHealthcareService read GetCurrent;
  end;

  TFhirHealthcareServiceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirHealthcareService;
    procedure SetItemN(index : Integer; value : TFhirHealthcareService);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirHealthcareServiceList; Overload;
    function Clone : TFhirHealthcareServiceList; Overload;
    function GetEnumerator : TFhirHealthcareServiceListEnumerator;
    

    //  Add a FhirHealthcareService to the end of the list.
    function Append : TFhirHealthcareService;

    
    // Add an already existing FhirHealthcareService to the end of the list.
function AddItem(value : TFhirHealthcareService): TFhirHealthcareService; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirHealthcareService) : Integer;
    

    // Insert FhirHealthcareService before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirHealthcareService;
    

    // Insert an existing FhirHealthcareService before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirHealthcareService);
    
    // Get the iIndexth FhirHealthcareService. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirHealthcareService);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirHealthcareService;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirHealthcareServices[index : Integer] : TFhirHealthcareService read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_HEALTHCARESERVICE}

{$IFDEF FHIR_LOCATION}

  // The absolute geographic location of the Location, expressed using the WGS84 datum (This is the same co-ordinate system used in KML).
  TFhirLocationPosition = class (TFhirBackboneElement)
  protected
    FLongitude : TFhirDecimal;
    FLatitude : TFhirDecimal;
    FAltitude : TFhirDecimal;
    Procedure SetLongitude(value : TFhirDecimal);
    Function GetLongitudeST : String;
    Procedure SetLongitudeST(value : String);
    Procedure SetLatitude(value : TFhirDecimal);
    Function GetLatitudeST : String;
    Procedure SetLatitudeST(value : String);
    Procedure SetAltitude(value : TFhirDecimal);
    Function GetAltitudeST : String;
    Procedure SetAltitudeST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLocationPosition; overload;
    function Clone : TFhirLocationPosition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Longitude. The value domain and the interpretation are the same as for the text of the longitude element in KML (see notes below).
    property longitude : String read GetLongitudeST write SetLongitudeST;
    // Longitude. The value domain and the interpretation are the same as for the text of the longitude element in KML (see notes below).
    property longitudeElement : TFhirDecimal read FLongitude write SetLongitude;

    // Typed access to Latitude. The value domain and the interpretation are the same as for the text of the latitude element in KML (see notes below).
    property latitude : String read GetLatitudeST write SetLatitudeST;
    // Latitude. The value domain and the interpretation are the same as for the text of the latitude element in KML (see notes below).
    property latitudeElement : TFhirDecimal read FLatitude write SetLatitude;

    // Typed access to Altitude. The value domain and the interpretation are the same as for the text of the altitude element in KML (see notes below).
    property altitude : String read GetAltitudeST write SetAltitudeST;
    // Altitude. The value domain and the interpretation are the same as for the text of the altitude element in KML (see notes below).
    property altitudeElement : TFhirDecimal read FAltitude write SetAltitude;

  end;

  TFhirLocationPositionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLocationPositionList;
    function GetCurrent : TFhirLocationPosition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirLocationPositionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLocationPosition read GetCurrent;
  end;

  TFhirLocationPositionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirLocationPosition;
    procedure SetItemN(index : Integer; value : TFhirLocationPosition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirLocationPositionList; Overload;
    function Clone : TFhirLocationPositionList; Overload;
    function GetEnumerator : TFhirLocationPositionListEnumerator;
    

    //  Add a FhirLocationPosition to the end of the list.
    function Append : TFhirLocationPosition;

    
    // Add an already existing FhirLocationPosition to the end of the list.
function AddItem(value : TFhirLocationPosition): TFhirLocationPosition; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLocationPosition) : Integer;
    

    // Insert FhirLocationPosition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLocationPosition;
    

    // Insert an existing FhirLocationPosition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLocationPosition);
    
    // Get the iIndexth FhirLocationPosition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLocationPosition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirLocationPosition;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirLocationPositions[index : Integer] : TFhirLocationPosition read GetItemN write SetItemN; default;
  End;

  // What days/times during a week is this location usually open.
  TFhirLocationHoursOfOperation = class (TFhirBackboneElement)
  protected
    FDaysOfWeek : TFhirEnumList;
    FAllDay : TFhirBoolean;
    FOpeningTime : TFhirTime;
    FClosingTime : TFhirTime;
    function GetDaysOfWeek : TFhirEnumList;
    function GetHasDaysOfWeek : Boolean;
    Function GetDaysOfWeekST : TFhirDaysOfWeekEnumList;
    Procedure SetDaysOfWeekST(value : TFhirDaysOfWeekEnumList);
    Procedure SetAllDay(value : TFhirBoolean);
    Function GetAllDayST : Boolean;
    Procedure SetAllDayST(value : Boolean);
    Procedure SetOpeningTime(value : TFhirTime);
    Function GetOpeningTimeST : String;
    Procedure SetOpeningTimeST(value : String);
    Procedure SetClosingTime(value : TFhirTime);
    Function GetClosingTimeST : String;
    Procedure SetClosingTimeST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLocationHoursOfOperation; overload;
    function Clone : TFhirLocationHoursOfOperation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Indicates which days of the week are available between the start and end Times.
    property daysOfWeek : TFhirDaysOfWeekEnumList read GetDaysOfWeekST write SetDaysOfWeekST;
    property daysOfWeekList : TFhirEnumList read GetDaysOfWeek;
    property hasDaysOfWeek : boolean read GetHasDaysOfWeek;
    // Typed access to The Location is open all day.
    property allDay : Boolean read GetAllDayST write SetAllDayST;
    // The Location is open all day.
    property allDayElement : TFhirBoolean read FAllDay write SetAllDay;

    // Typed access to Time that the Location opens.
    property openingTime : String read GetOpeningTimeST write SetOpeningTimeST;
    // Time that the Location opens.
    property openingTimeElement : TFhirTime read FOpeningTime write SetOpeningTime;

    // Typed access to Time that the Location closes.
    property closingTime : String read GetClosingTimeST write SetClosingTimeST;
    // Time that the Location closes.
    property closingTimeElement : TFhirTime read FClosingTime write SetClosingTime;

  end;

  TFhirLocationHoursOfOperationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLocationHoursOfOperationList;
    function GetCurrent : TFhirLocationHoursOfOperation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirLocationHoursOfOperationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLocationHoursOfOperation read GetCurrent;
  end;

  TFhirLocationHoursOfOperationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirLocationHoursOfOperation;
    procedure SetItemN(index : Integer; value : TFhirLocationHoursOfOperation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirLocationHoursOfOperationList; Overload;
    function Clone : TFhirLocationHoursOfOperationList; Overload;
    function GetEnumerator : TFhirLocationHoursOfOperationListEnumerator;
    

    //  Add a FhirLocationHoursOfOperation to the end of the list.
    function Append : TFhirLocationHoursOfOperation;

    
    // Add an already existing FhirLocationHoursOfOperation to the end of the list.
function AddItem(value : TFhirLocationHoursOfOperation): TFhirLocationHoursOfOperation; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLocationHoursOfOperation) : Integer;
    

    // Insert FhirLocationHoursOfOperation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLocationHoursOfOperation;
    

    // Insert an existing FhirLocationHoursOfOperation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLocationHoursOfOperation);
    
    // Get the iIndexth FhirLocationHoursOfOperation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLocationHoursOfOperation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirLocationHoursOfOperation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirLocationHoursOfOperations[index : Integer] : TFhirLocationHoursOfOperation read GetItemN write SetItemN; default;
  End;

  // Details and position information for a physical place where services are provided and resources and participants may be stored, found, contained, or accommodated.
  TFhirLocation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FOperationalStatus : TFhirCoding;
    FName : TFhirString;
    FaliasList : TFhirStringList;
    FDescription : TFhirString;
    FMode : TFhirEnum;
    Ftype_List : TFhirCodeableConceptList;
    FtelecomList : TFhirContactPointList;
    FAddress : TFhirAddress;
    FPhysicalType : TFhirCodeableConcept;
    FPosition : TFhirLocationPosition;
    FManagingOrganization : TFhirReference{TFhirOrganization};
    FPartOf : TFhirReference{TFhirLocation};
    FhoursOfOperationList : TFhirLocationHoursOfOperationList;
    FAvailabilityExceptions : TFhirString;
    FendpointList : TFhirReferenceList{TFhirEndpoint};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirLocationStatusEnum;
    Procedure SetStatusST(value : TFhirLocationStatusEnum);
    Procedure SetOperationalStatus(value : TFhirCoding);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    function GetAliasList : TFhirStringList;
    function GetHasAliasList : Boolean;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirLocationModeEnum;
    Procedure SetModeST(value : TFhirLocationModeEnum);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    Procedure SetAddress(value : TFhirAddress);
    Procedure SetPhysicalType(value : TFhirCodeableConcept);
    Procedure SetPosition(value : TFhirLocationPosition);
    Procedure SetManagingOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetPartOf(value : TFhirReference{TFhirLocation});
    function GetHoursOfOperationList : TFhirLocationHoursOfOperationList;
    function GetHasHoursOfOperationList : Boolean;
    Procedure SetAvailabilityExceptions(value : TFhirString);
    Function GetAvailabilityExceptionsST : String;
    Procedure SetAvailabilityExceptionsST(value : String);
    function GetEndpointList : TFhirReferenceList{TFhirEndpoint};
    function GetHasEndpointList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLocation; overload;
    function Clone : TFhirLocation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Unique code or number identifying the location to its users.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status property covers the general availability of the resource, not the current value which may be covered by the operationStatus, or by a schedule/slots if they are configured for the location.
    property status : TFhirLocationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The operational status covers operation values most relevant to beds (but can also apply to rooms/units/chairs/etc. such as an isolation unit/dialysis chair). This typically covers concepts such as contamination, housekeeping, and other activities like maintenance. (defined for API consistency)
    property operationalStatus : TFhirCoding read FOperationalStatus write SetOperationalStatus;
    // The operational status covers operation values most relevant to beds (but can also apply to rooms/units/chairs/etc. such as an isolation unit/dialysis chair). This typically covers concepts such as contamination, housekeeping, and other activities like maintenance.
    property operationalStatusElement : TFhirCoding read FOperationalStatus write SetOperationalStatus;

    // Typed access to Name of the location as used by humans. Does not need to be unique.
    property name : String read GetNameST write SetNameST;
    // Name of the location as used by humans. Does not need to be unique.
    property nameElement : TFhirString read FName write SetName;

    // A list of alternate names that the location is known as, or was known as, in the past.
    property aliasList : TFhirStringList read GetAliasList;
    property hasAliasList : boolean read GetHasAliasList;

    // Typed access to Description of the Location, which helps in finding or referencing the place.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of the Location, which helps in finding or referencing the place.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Indicates whether a resource instance represents a specific location or a class of locations.
    property mode : TFhirLocationModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Indicates the type of function performed at the location.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // The contact details of communication devices available at the location. This can include phone numbers, fax numbers, mobile numbers, email addresses and web sites.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Typed access to Physical location. (defined for API consistency)
    property address : TFhirAddress read FAddress write SetAddress;
    // Physical location.
    property addressElement : TFhirAddress read FAddress write SetAddress;

    // Typed access to Physical form of the location, e.g. building, room, vehicle, road. (defined for API consistency)
    property physicalType : TFhirCodeableConcept read FPhysicalType write SetPhysicalType;
    // Physical form of the location, e.g. building, room, vehicle, road.
    property physicalTypeElement : TFhirCodeableConcept read FPhysicalType write SetPhysicalType;

    // Typed access to The absolute geographic location of the Location, expressed using the WGS84 datum (This is the same co-ordinate system used in KML). (defined for API consistency)
    property position : TFhirLocationPosition read FPosition write SetPosition;
    // The absolute geographic location of the Location, expressed using the WGS84 datum (This is the same co-ordinate system used in KML).
    property positionElement : TFhirLocationPosition read FPosition write SetPosition;

    // Typed access to The organization responsible for the provisioning and upkeep of the location. (defined for API consistency)
    property managingOrganization : TFhirReference{TFhirOrganization} read FManagingOrganization write SetManagingOrganization;
    // The organization responsible for the provisioning and upkeep of the location.
    property managingOrganizationElement : TFhirReference{TFhirOrganization} read FManagingOrganization write SetManagingOrganization;

    // Typed access to Another Location of which this Location is physically a part of. (defined for API consistency)
    property partOf : TFhirReference{TFhirLocation} read FPartOf write SetPartOf;
    // Another Location of which this Location is physically a part of.
    property partOfElement : TFhirReference{TFhirLocation} read FPartOf write SetPartOf;

    // What days/times during a week is this location usually open.
    property hoursOfOperationList : TFhirLocationHoursOfOperationList read GetHoursOfOperationList;
    property hasHoursOfOperationList : boolean read GetHasHoursOfOperationList;

    // Typed access to A description of when the locations opening ours are different to normal, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as detailed in the opening hours Times.
    property availabilityExceptions : String read GetAvailabilityExceptionsST write SetAvailabilityExceptionsST;
    // A description of when the locations opening ours are different to normal, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as detailed in the opening hours Times.
    property availabilityExceptionsElement : TFhirString read FAvailabilityExceptions write SetAvailabilityExceptions;

    // Technical endpoints providing access to services operated for the location.
    property endpointList : TFhirReferenceList{TFhirEndpoint} read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

  end;

  TFhirLocationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLocationList;
    function GetCurrent : TFhirLocation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirLocationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLocation read GetCurrent;
  end;

  TFhirLocationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirLocation;
    procedure SetItemN(index : Integer; value : TFhirLocation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirLocationList; Overload;
    function Clone : TFhirLocationList; Overload;
    function GetEnumerator : TFhirLocationListEnumerator;
    

    //  Add a FhirLocation to the end of the list.
    function Append : TFhirLocation;

    
    // Add an already existing FhirLocation to the end of the list.
function AddItem(value : TFhirLocation): TFhirLocation; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLocation) : Integer;
    

    // Insert FhirLocation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLocation;
    

    // Insert an existing FhirLocation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLocation);
    
    // Get the iIndexth FhirLocation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLocation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirLocation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirLocations[index : Integer] : TFhirLocation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_LOCATION}

{$IFDEF FHIR_ORGANIZATION}

  // Contact for the organization for a certain purpose.
  TFhirOrganizationContact = class (TFhirBackboneElement)
  protected
    FPurpose : TFhirCodeableConcept;
    FName : TFhirHumanName;
    FtelecomList : TFhirContactPointList;
    FAddress : TFhirAddress;
    Procedure SetPurpose(value : TFhirCodeableConcept);
    Procedure SetName(value : TFhirHumanName);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    Procedure SetAddress(value : TFhirAddress);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOrganizationContact; overload;
    function Clone : TFhirOrganizationContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Indicates a purpose for which the contact can be reached. (defined for API consistency)
    property purpose : TFhirCodeableConcept read FPurpose write SetPurpose;
    // Indicates a purpose for which the contact can be reached.
    property purposeElement : TFhirCodeableConcept read FPurpose write SetPurpose;

    // Typed access to A name associated with the contact. (defined for API consistency)
    property name : TFhirHumanName read FName write SetName;
    // A name associated with the contact.
    property nameElement : TFhirHumanName read FName write SetName;

    // A contact detail (e.g. a telephone number or an email address) by which the party may be contacted.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Typed access to Visiting or postal addresses for the contact. (defined for API consistency)
    property address : TFhirAddress read FAddress write SetAddress;
    // Visiting or postal addresses for the contact.
    property addressElement : TFhirAddress read FAddress write SetAddress;

  end;

  TFhirOrganizationContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOrganizationContactList;
    function GetCurrent : TFhirOrganizationContact;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirOrganizationContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOrganizationContact read GetCurrent;
  end;

  TFhirOrganizationContactList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOrganizationContact;
    procedure SetItemN(index : Integer; value : TFhirOrganizationContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOrganizationContactList; Overload;
    function Clone : TFhirOrganizationContactList; Overload;
    function GetEnumerator : TFhirOrganizationContactListEnumerator;
    

    //  Add a FhirOrganizationContact to the end of the list.
    function Append : TFhirOrganizationContact;

    
    // Add an already existing FhirOrganizationContact to the end of the list.
function AddItem(value : TFhirOrganizationContact): TFhirOrganizationContact; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOrganizationContact) : Integer;
    

    // Insert FhirOrganizationContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOrganizationContact;
    

    // Insert an existing FhirOrganizationContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOrganizationContact);
    
    // Get the iIndexth FhirOrganizationContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOrganizationContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOrganizationContact;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirOrganizationContacts[index : Integer] : TFhirOrganizationContact read GetItemN write SetItemN; default;
  End;

  // A formally or informally recognized grouping of people or organizations formed for the purpose of achieving some form of collective action.  Includes companies, institutions, corporations, departments, community groups, healthcare practice groups, payer/insurer, etc.
  TFhirOrganization = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    Ftype_List : TFhirCodeableConceptList;
    FName : TFhirString;
    FaliasList : TFhirStringList;
    FtelecomList : TFhirContactPointList;
    FaddressList : TFhirAddressList;
    FPartOf : TFhirReference{TFhirOrganization};
    FcontactList : TFhirOrganizationContactList;
    FendpointList : TFhirReferenceList{TFhirEndpoint};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetActive(value : TFhirBoolean);
    Function GetActiveST : Boolean;
    Procedure SetActiveST(value : Boolean);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    function GetAliasList : TFhirStringList;
    function GetHasAliasList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    Procedure SetPartOf(value : TFhirReference{TFhirOrganization});
    function GetContactList : TFhirOrganizationContactList;
    function GetHasContactList : Boolean;
    function GetEndpointList : TFhirReferenceList{TFhirEndpoint};
    function GetHasEndpointList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOrganization; overload;
    function Clone : TFhirOrganization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifier for the organization that is used to identify the organization across multiple disparate systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether the organization's record is still in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether the organization's record is still in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // The kind(s) of organization that this is.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to A name associated with the organization.
    property name : String read GetNameST write SetNameST;
    // A name associated with the organization.
    property nameElement : TFhirString read FName write SetName;

    // A list of alternate names that the organization is known as, or was known as in the past.
    property aliasList : TFhirStringList read GetAliasList;
    property hasAliasList : boolean read GetHasAliasList;

    // A contact detail for the organization.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // An address for the organization.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Typed access to The organization of which this organization forms a part. (defined for API consistency)
    property partOf : TFhirReference{TFhirOrganization} read FPartOf write SetPartOf;
    // The organization of which this organization forms a part.
    property partOfElement : TFhirReference{TFhirOrganization} read FPartOf write SetPartOf;

    // Contact for the organization for a certain purpose.
    property contactList : TFhirOrganizationContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Technical endpoints providing access to services operated for the organization.
    property endpointList : TFhirReferenceList{TFhirEndpoint} read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

  end;

  TFhirOrganizationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOrganizationList;
    function GetCurrent : TFhirOrganization;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirOrganizationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOrganization read GetCurrent;
  end;

  TFhirOrganizationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOrganization;
    procedure SetItemN(index : Integer; value : TFhirOrganization);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOrganizationList; Overload;
    function Clone : TFhirOrganizationList; Overload;
    function GetEnumerator : TFhirOrganizationListEnumerator;
    

    //  Add a FhirOrganization to the end of the list.
    function Append : TFhirOrganization;

    
    // Add an already existing FhirOrganization to the end of the list.
function AddItem(value : TFhirOrganization): TFhirOrganization; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOrganization) : Integer;
    

    // Insert FhirOrganization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOrganization;
    

    // Insert an existing FhirOrganization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOrganization);
    
    // Get the iIndexth FhirOrganization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOrganization);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOrganization;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirOrganizations[index : Integer] : TFhirOrganization read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ORGANIZATION}

{$IFDEF FHIR_ORGANIZATIONAFFILIATION}

  // Defines an affiliation/assotiation/relationship between 2 distinct oganizations, that is not a part-of relationship/sub-division relationship.
  TFhirOrganizationAffiliation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FPeriod : TFhirPeriod;
    FOrganization : TFhirReference{TFhirOrganization};
    FParticipatingOrganization : TFhirReference{TFhirOrganization};
    FnetworkList : TFhirReferenceList{TFhirOrganization};
    FcodeList : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FlocationList : TFhirReferenceList{TFhirLocation};
    FhealthcareServiceList : TFhirReferenceList{TFhirHealthcareService};
    FtelecomList : TFhirContactPointList;
    FendpointList : TFhirReferenceList{TFhirEndpoint};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetActive(value : TFhirBoolean);
    Function GetActiveST : Boolean;
    Procedure SetActiveST(value : Boolean);
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetParticipatingOrganization(value : TFhirReference{TFhirOrganization});
    function GetNetworkList : TFhirReferenceList{TFhirOrganization};
    function GetHasNetworkList : Boolean;
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    function GetLocationList : TFhirReferenceList{TFhirLocation};
    function GetHasLocationList : Boolean;
    function GetHealthcareServiceList : TFhirReferenceList{TFhirHealthcareService};
    function GetHasHealthcareServiceList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    function GetEndpointList : TFhirReferenceList{TFhirEndpoint};
    function GetHasEndpointList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOrganizationAffiliation; overload;
    function Clone : TFhirOrganizationAffiliation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Business identifiers that are specific to this role.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this organization affiliation record is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this organization affiliation record is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to The period during which the participatingOrganization is affiliated with the primary organization. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period during which the participatingOrganization is affiliated with the primary organization.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Organization where the role is available (primary organization/has members). (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // Organization where the role is available (primary organization/has members).
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to The Participating Organization provides/performs the role(s) defined by the code to the Primary Organization (e.g. providing services or is a member of). (defined for API consistency)
    property participatingOrganization : TFhirReference{TFhirOrganization} read FParticipatingOrganization write SetParticipatingOrganization;
    // The Participating Organization provides/performs the role(s) defined by the code to the Primary Organization (e.g. providing services or is a member of).
    property participatingOrganizationElement : TFhirReference{TFhirOrganization} read FParticipatingOrganization write SetParticipatingOrganization;

    // Health insurance provider network in which the participatingOrganization provides the role's services (if defined) at the indicated locations (if defined).
    property networkList : TFhirReferenceList{TFhirOrganization} read GetNetworkList;
    property hasNetworkList : boolean read GetHasNetworkList;

    // Definition of the role the participatingOrganization plays in the association.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Specific specialty of the participatingOrganization in the context of the role.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // The location(s) at which the role occurs.
    property locationList : TFhirReferenceList{TFhirLocation} read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // Healthcare services provided through the role.
    property healthcareServiceList : TFhirReferenceList{TFhirHealthcareService} read GetHealthcareServiceList;
    property hasHealthcareServiceList : boolean read GetHasHealthcareServiceList;

    // Contact details at the participatingOrganization relevant to this Affiliation.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Technical endpoints providing access to services operated for this role.
    property endpointList : TFhirReferenceList{TFhirEndpoint} read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

  end;

  TFhirOrganizationAffiliationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOrganizationAffiliationList;
    function GetCurrent : TFhirOrganizationAffiliation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirOrganizationAffiliationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOrganizationAffiliation read GetCurrent;
  end;

  TFhirOrganizationAffiliationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOrganizationAffiliation;
    procedure SetItemN(index : Integer; value : TFhirOrganizationAffiliation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOrganizationAffiliationList; Overload;
    function Clone : TFhirOrganizationAffiliationList; Overload;
    function GetEnumerator : TFhirOrganizationAffiliationListEnumerator;
    

    //  Add a FhirOrganizationAffiliation to the end of the list.
    function Append : TFhirOrganizationAffiliation;

    
    // Add an already existing FhirOrganizationAffiliation to the end of the list.
function AddItem(value : TFhirOrganizationAffiliation): TFhirOrganizationAffiliation; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOrganizationAffiliation) : Integer;
    

    // Insert FhirOrganizationAffiliation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOrganizationAffiliation;
    

    // Insert an existing FhirOrganizationAffiliation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOrganizationAffiliation);
    
    // Get the iIndexth FhirOrganizationAffiliation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOrganizationAffiliation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOrganizationAffiliation;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirOrganizationAffiliations[index : Integer] : TFhirOrganizationAffiliation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ORGANIZATIONAFFILIATION}

{$IFDEF FHIR_PATIENT}

  // A contact party (e.g. guardian, partner, friend) for the patient.
  TFhirPatientContact = class (TFhirBackboneElement)
  protected
    FrelationshipList : TFhirCodeableConceptList;
    FName : TFhirHumanName;
    FtelecomList : TFhirContactPointList;
    FAddress : TFhirAddress;
    FGender : TFhirEnum;
    FOrganization : TFhirReference{TFhirOrganization};
    FPeriod : TFhirPeriod;
    function GetRelationshipList : TFhirCodeableConceptList;
    function GetHasRelationshipList : Boolean;
    Procedure SetName(value : TFhirHumanName);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    Procedure SetAddress(value : TFhirAddress);
    Procedure SetGender(value : TFhirEnum);
    Function GetGenderST : TFhirAdministrativeGenderEnum;
    Procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetPeriod(value : TFhirPeriod);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPatientContact; overload;
    function Clone : TFhirPatientContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The nature of the relationship between the patient and the contact person.
    property relationshipList : TFhirCodeableConceptList read GetRelationshipList;
    property hasRelationshipList : boolean read GetHasRelationshipList;

    // Typed access to A name associated with the contact person. (defined for API consistency)
    property name : TFhirHumanName read FName write SetName;
    // A name associated with the contact person.
    property nameElement : TFhirHumanName read FName write SetName;

    // A contact detail for the person, e.g. a telephone number or an email address.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Typed access to Address for the contact person. (defined for API consistency)
    property address : TFhirAddress read FAddress write SetAddress;
    // Address for the contact person.
    property addressElement : TFhirAddress read FAddress write SetAddress;

    // Administrative Gender - the gender that the contact person is considered to have for administration and record keeping purposes.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to Organization on behalf of which the contact is acting or for which the contact is working. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // Organization on behalf of which the contact is acting or for which the contact is working.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Typed access to The period during which this contact person or organization is valid to be contacted relating to this patient. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period during which this contact person or organization is valid to be contacted relating to this patient.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirPatientContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPatientContactList;
    function GetCurrent : TFhirPatientContact;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPatientContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPatientContact read GetCurrent;
  end;

  TFhirPatientContactList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPatientContact;
    procedure SetItemN(index : Integer; value : TFhirPatientContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPatientContactList; Overload;
    function Clone : TFhirPatientContactList; Overload;
    function GetEnumerator : TFhirPatientContactListEnumerator;
    

    //  Add a FhirPatientContact to the end of the list.
    function Append : TFhirPatientContact;

    
    // Add an already existing FhirPatientContact to the end of the list.
function AddItem(value : TFhirPatientContact): TFhirPatientContact; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPatientContact) : Integer;
    

    // Insert FhirPatientContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPatientContact;
    

    // Insert an existing FhirPatientContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPatientContact);
    
    // Get the iIndexth FhirPatientContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPatientContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPatientContact;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirPatientContacts[index : Integer] : TFhirPatientContact read GetItemN write SetItemN; default;
  End;

  // A language which may be used to communicate with the patient about his or her health.
  TFhirPatientCommunication = class (TFhirBackboneElement)
  protected
    FLanguage : TFhirCodeableConcept;
    FPreferred : TFhirBoolean;
    Procedure SetLanguage(value : TFhirCodeableConcept);
    Procedure SetPreferred(value : TFhirBoolean);
    Function GetPreferredST : Boolean;
    Procedure SetPreferredST(value : Boolean);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPatientCommunication; overload;
    function Clone : TFhirPatientCommunication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

    // Typed access to Indicates whether or not the patient prefers this language (over other languages he masters up a certain level).
    property preferred : Boolean read GetPreferredST write SetPreferredST;
    // Indicates whether or not the patient prefers this language (over other languages he masters up a certain level).
    property preferredElement : TFhirBoolean read FPreferred write SetPreferred;

  end;

  TFhirPatientCommunicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPatientCommunicationList;
    function GetCurrent : TFhirPatientCommunication;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPatientCommunicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPatientCommunication read GetCurrent;
  end;

  TFhirPatientCommunicationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPatientCommunication;
    procedure SetItemN(index : Integer; value : TFhirPatientCommunication);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPatientCommunicationList; Overload;
    function Clone : TFhirPatientCommunicationList; Overload;
    function GetEnumerator : TFhirPatientCommunicationListEnumerator;
    

    //  Add a FhirPatientCommunication to the end of the list.
    function Append : TFhirPatientCommunication;

    
    // Add an already existing FhirPatientCommunication to the end of the list.
function AddItem(value : TFhirPatientCommunication): TFhirPatientCommunication; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPatientCommunication) : Integer;
    

    // Insert FhirPatientCommunication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPatientCommunication;
    

    // Insert an existing FhirPatientCommunication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPatientCommunication);
    
    // Get the iIndexth FhirPatientCommunication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPatientCommunication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPatientCommunication;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirPatientCommunications[index : Integer] : TFhirPatientCommunication read GetItemN write SetItemN; default;
  End;

  // Link to another patient resource that concerns the same actual patient.
  TFhirPatientLink = class (TFhirBackboneElement)
  protected
    FOther : TFhirReference{TFhirPatient};
    FType_ : TFhirEnum;
    Procedure SetOther(value : TFhirReference{TFhirPatient});
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirLinkTypeEnum;
    Procedure SetType_ST(value : TFhirLinkTypeEnum);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPatientLink; overload;
    function Clone : TFhirPatientLink; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The other patient resource that the link refers to. (defined for API consistency)
    property other : TFhirReference{TFhirPatient} read FOther write SetOther;
    // The other patient resource that the link refers to.
    property otherElement : TFhirReference{TFhirPatient} read FOther write SetOther;

    // The type of link between this patient resource and another patient resource.
    property type_ : TFhirLinkTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

  end;

  TFhirPatientLinkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPatientLinkList;
    function GetCurrent : TFhirPatientLink;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPatientLinkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPatientLink read GetCurrent;
  end;

  TFhirPatientLinkList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPatientLink;
    procedure SetItemN(index : Integer; value : TFhirPatientLink);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPatientLinkList; Overload;
    function Clone : TFhirPatientLinkList; Overload;
    function GetEnumerator : TFhirPatientLinkListEnumerator;
    

    //  Add a FhirPatientLink to the end of the list.
    function Append : TFhirPatientLink;

    
    // Add an already existing FhirPatientLink to the end of the list.
function AddItem(value : TFhirPatientLink): TFhirPatientLink; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPatientLink) : Integer;
    

    // Insert FhirPatientLink before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPatientLink;
    

    // Insert an existing FhirPatientLink before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPatientLink);
    
    // Get the iIndexth FhirPatientLink. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPatientLink);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPatientLink;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirPatientLinks[index : Integer] : TFhirPatientLink read GetItemN write SetItemN; default;
  End;

  // Demographics and other administrative information about an individual or animal receiving care or other health-related services.
  TFhirPatient = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FnameList : TFhirHumanNameList;
    FtelecomList : TFhirContactPointList;
    FGender : TFhirEnum;
    FBirthDate : TFhirDate;
    FDeceased : TFhirType;
    FaddressList : TFhirAddressList;
    FMaritalStatus : TFhirCodeableConcept;
    FMultipleBirth : TFhirType;
    FphotoList : TFhirAttachmentList;
    FcontactList : TFhirPatientContactList;
    FcommunicationList : TFhirPatientCommunicationList;
    FgeneralPractitionerList : TFhirReferenceList{TFhirOrganization};
    FManagingOrganization : TFhirReference{TFhirOrganization};
    Flink_List : TFhirPatientLinkList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetActive(value : TFhirBoolean);
    Function GetActiveST : Boolean;
    Procedure SetActiveST(value : Boolean);
    function GetNameList : TFhirHumanNameList;
    function GetHasNameList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    Procedure SetGender(value : TFhirEnum);
    Function GetGenderST : TFhirAdministrativeGenderEnum;
    Procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    Procedure SetBirthDate(value : TFhirDate);
    Function GetBirthDateST : TFslDateTime;
    Procedure SetBirthDateST(value : TFslDateTime);
    Procedure SetDeceased(value : TFhirType);
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    Procedure SetMaritalStatus(value : TFhirCodeableConcept);
    Procedure SetMultipleBirth(value : TFhirType);
    function GetPhotoList : TFhirAttachmentList;
    function GetHasPhotoList : Boolean;
    function GetContactList : TFhirPatientContactList;
    function GetHasContactList : Boolean;
    function GetCommunicationList : TFhirPatientCommunicationList;
    function GetHasCommunicationList : Boolean;
    function GetGeneralPractitionerList : TFhirReferenceList{TFhirOrganization};
    function GetHasGeneralPractitionerList : Boolean;
    Procedure SetManagingOrganization(value : TFhirReference{TFhirOrganization});
    function GetLink_List : TFhirPatientLinkList;
    function GetHasLink_List : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPatient; overload;
    function Clone : TFhirPatient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // An identifier for this patient.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this patient record is in active use.  Many systems use this property to mark as non-current patients, such as those that have not been seen for a period of time based on an organization's business rules.  It is often used to filter patient lists to exclude inactive patients  Deceased patients may also be marked as inactive for the same reasons, but may be active for some time after death.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this patient record is in active use.  Many systems use this property to mark as non-current patients, such as those that have not been seen for a period of time based on an organization's business rules.  It is often used to filter patient lists to exclude inactive patients  Deceased patients may also be marked as inactive for the same reasons, but may be active for some time after death.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // A name associated with the individual.
    property nameList : TFhirHumanNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // A contact detail (e.g. a telephone number or an email address) by which the individual may be contacted.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Administrative Gender - the gender that the patient is considered to have for administration and record keeping purposes.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to The date of birth for the individual.
    property birthDate : TFslDateTime read GetBirthDateST write SetBirthDateST;
    // The date of birth for the individual.
    property birthDateElement : TFhirDate read FBirthDate write SetBirthDate;

    // Typed access to Indicates if the individual is deceased or not. (defined for API consistency)
    property deceased : TFhirType read FDeceased write SetDeceased;
    // Indicates if the individual is deceased or not.
    property deceasedElement : TFhirType read FDeceased write SetDeceased;

    // An address for the individual.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Typed access to This field contains a patient's most recent marital (civil) status. (defined for API consistency)
    property maritalStatus : TFhirCodeableConcept read FMaritalStatus write SetMaritalStatus;
    // This field contains a patient's most recent marital (civil) status.
    property maritalStatusElement : TFhirCodeableConcept read FMaritalStatus write SetMaritalStatus;

    // Typed access to Indicates whether the patient is part of a multiple (boolean) or indicates the actual birth order (integer). (defined for API consistency)
    property multipleBirth : TFhirType read FMultipleBirth write SetMultipleBirth;
    // Indicates whether the patient is part of a multiple (boolean) or indicates the actual birth order (integer).
    property multipleBirthElement : TFhirType read FMultipleBirth write SetMultipleBirth;

    // Image of the patient.
    property photoList : TFhirAttachmentList read GetPhotoList;
    property hasPhotoList : boolean read GetHasPhotoList;

    // A contact party (e.g. guardian, partner, friend) for the patient.
    property contactList : TFhirPatientContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // A language which may be used to communicate with the patient about his or her health.
    property communicationList : TFhirPatientCommunicationList read GetCommunicationList;
    property hasCommunicationList : boolean read GetHasCommunicationList;

    // Patient's nominated care provider.
    property generalPractitionerList : TFhirReferenceList{TFhirOrganization} read GetGeneralPractitionerList;
    property hasGeneralPractitionerList : boolean read GetHasGeneralPractitionerList;

    // Typed access to Organization that is the custodian of the patient record. (defined for API consistency)
    property managingOrganization : TFhirReference{TFhirOrganization} read FManagingOrganization write SetManagingOrganization;
    // Organization that is the custodian of the patient record.
    property managingOrganizationElement : TFhirReference{TFhirOrganization} read FManagingOrganization write SetManagingOrganization;

    // Link to another patient resource that concerns the same actual patient.
    property link_List : TFhirPatientLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

  end;

  TFhirPatientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPatientList;
    function GetCurrent : TFhirPatient;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPatientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPatient read GetCurrent;
  end;

  TFhirPatientList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPatient;
    procedure SetItemN(index : Integer; value : TFhirPatient);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPatientList; Overload;
    function Clone : TFhirPatientList; Overload;
    function GetEnumerator : TFhirPatientListEnumerator;
    

    //  Add a FhirPatient to the end of the list.
    function Append : TFhirPatient;

    
    // Add an already existing FhirPatient to the end of the list.
function AddItem(value : TFhirPatient): TFhirPatient; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPatient) : Integer;
    

    // Insert FhirPatient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPatient;
    

    // Insert an existing FhirPatient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPatient);
    
    // Get the iIndexth FhirPatient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPatient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPatient;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirPatients[index : Integer] : TFhirPatient read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PATIENT}

{$IFDEF FHIR_PERSON}

  // Link to a resource that concerns the same actual person.
  TFhirPersonLink = class (TFhirBackboneElement)
  protected
    FTarget : TFhirReference{TFhirPatient};
    FAssurance : TFhirEnum;
    Procedure SetTarget(value : TFhirReference{TFhirPatient});
    Procedure SetAssurance(value : TFhirEnum);
    Function GetAssuranceST : TFhirIdentityAssuranceLevelEnum;
    Procedure SetAssuranceST(value : TFhirIdentityAssuranceLevelEnum);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPersonLink; overload;
    function Clone : TFhirPersonLink; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The resource to which this actual person is associated. (defined for API consistency)
    property target : TFhirReference{TFhirPatient} read FTarget write SetTarget;
    // The resource to which this actual person is associated.
    property targetElement : TFhirReference{TFhirPatient} read FTarget write SetTarget;

    // Level of assurance that this link is associated with the target resource.
    property assurance : TFhirIdentityAssuranceLevelEnum read GetAssuranceST write SetAssuranceST;
    property assuranceElement : TFhirEnum read FAssurance write SetAssurance;

  end;

  TFhirPersonLinkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPersonLinkList;
    function GetCurrent : TFhirPersonLink;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPersonLinkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPersonLink read GetCurrent;
  end;

  TFhirPersonLinkList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPersonLink;
    procedure SetItemN(index : Integer; value : TFhirPersonLink);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPersonLinkList; Overload;
    function Clone : TFhirPersonLinkList; Overload;
    function GetEnumerator : TFhirPersonLinkListEnumerator;
    

    //  Add a FhirPersonLink to the end of the list.
    function Append : TFhirPersonLink;

    
    // Add an already existing FhirPersonLink to the end of the list.
function AddItem(value : TFhirPersonLink): TFhirPersonLink; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPersonLink) : Integer;
    

    // Insert FhirPersonLink before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPersonLink;
    

    // Insert an existing FhirPersonLink before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPersonLink);
    
    // Get the iIndexth FhirPersonLink. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPersonLink);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPersonLink;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirPersonLinks[index : Integer] : TFhirPersonLink read GetItemN write SetItemN; default;
  End;

  // Demographics and administrative information about a person independent of a specific health-related context.
  TFhirPerson = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FnameList : TFhirHumanNameList;
    FtelecomList : TFhirContactPointList;
    FGender : TFhirEnum;
    FBirthDate : TFhirDate;
    FaddressList : TFhirAddressList;
    FPhoto : TFhirAttachment;
    FManagingOrganization : TFhirReference{TFhirOrganization};
    FActive : TFhirBoolean;
    Flink_List : TFhirPersonLinkList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetNameList : TFhirHumanNameList;
    function GetHasNameList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    Procedure SetGender(value : TFhirEnum);
    Function GetGenderST : TFhirAdministrativeGenderEnum;
    Procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    Procedure SetBirthDate(value : TFhirDate);
    Function GetBirthDateST : TFslDateTime;
    Procedure SetBirthDateST(value : TFslDateTime);
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    Procedure SetPhoto(value : TFhirAttachment);
    Procedure SetManagingOrganization(value : TFhirReference{TFhirOrganization});
    Procedure SetActive(value : TFhirBoolean);
    Function GetActiveST : Boolean;
    Procedure SetActiveST(value : Boolean);
    function GetLink_List : TFhirPersonLinkList;
    function GetHasLink_List : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPerson; overload;
    function Clone : TFhirPerson; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifier for a person within a particular scope.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A name associated with the person.
    property nameList : TFhirHumanNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // A contact detail for the person, e.g. a telephone number or an email address.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Administrative Gender.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to The birth date for the person.
    property birthDate : TFslDateTime read GetBirthDateST write SetBirthDateST;
    // The birth date for the person.
    property birthDateElement : TFhirDate read FBirthDate write SetBirthDate;

    // One or more addresses for the person.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Typed access to An image that can be displayed as a thumbnail of the person to enhance the identification of the individual. (defined for API consistency)
    property photo : TFhirAttachment read FPhoto write SetPhoto;
    // An image that can be displayed as a thumbnail of the person to enhance the identification of the individual.
    property photoElement : TFhirAttachment read FPhoto write SetPhoto;

    // Typed access to The organization that is the custodian of the person record. (defined for API consistency)
    property managingOrganization : TFhirReference{TFhirOrganization} read FManagingOrganization write SetManagingOrganization;
    // The organization that is the custodian of the person record.
    property managingOrganizationElement : TFhirReference{TFhirOrganization} read FManagingOrganization write SetManagingOrganization;

    // Typed access to Whether this person's record is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this person's record is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Link to a resource that concerns the same actual person.
    property link_List : TFhirPersonLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

  end;

  TFhirPersonListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPersonList;
    function GetCurrent : TFhirPerson;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPersonList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPerson read GetCurrent;
  end;

  TFhirPersonList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPerson;
    procedure SetItemN(index : Integer; value : TFhirPerson);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPersonList; Overload;
    function Clone : TFhirPersonList; Overload;
    function GetEnumerator : TFhirPersonListEnumerator;
    

    //  Add a FhirPerson to the end of the list.
    function Append : TFhirPerson;

    
    // Add an already existing FhirPerson to the end of the list.
function AddItem(value : TFhirPerson): TFhirPerson; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPerson) : Integer;
    

    // Insert FhirPerson before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPerson;
    

    // Insert an existing FhirPerson before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPerson);
    
    // Get the iIndexth FhirPerson. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPerson);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPerson;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirPeople[index : Integer] : TFhirPerson read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PERSON}

{$IFDEF FHIR_PRACTITIONER}

  // The official certifications, training, and licenses that authorize or otherwise pertain to the provision of care by the practitioner.  For example, a medical license issued by a medical board authorizing the practitioner to practice medicine within a certian locality.
  TFhirPractitionerQualification = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FCode : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    FIssuer : TFhirReference{TFhirOrganization};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetIssuer(value : TFhirReference{TFhirOrganization});
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPractitionerQualification; overload;
    function Clone : TFhirPractitionerQualification; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // An identifier that applies to this person's qualification in this role.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Coded representation of the qualification. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Coded representation of the qualification.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Period during which the qualification is valid. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Period during which the qualification is valid.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Organization that regulates and issues the qualification. (defined for API consistency)
    property issuer : TFhirReference{TFhirOrganization} read FIssuer write SetIssuer;
    // Organization that regulates and issues the qualification.
    property issuerElement : TFhirReference{TFhirOrganization} read FIssuer write SetIssuer;

  end;

  TFhirPractitionerQualificationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPractitionerQualificationList;
    function GetCurrent : TFhirPractitionerQualification;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPractitionerQualificationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPractitionerQualification read GetCurrent;
  end;

  TFhirPractitionerQualificationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPractitionerQualification;
    procedure SetItemN(index : Integer; value : TFhirPractitionerQualification);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPractitionerQualificationList; Overload;
    function Clone : TFhirPractitionerQualificationList; Overload;
    function GetEnumerator : TFhirPractitionerQualificationListEnumerator;
    

    //  Add a FhirPractitionerQualification to the end of the list.
    function Append : TFhirPractitionerQualification;

    
    // Add an already existing FhirPractitionerQualification to the end of the list.
function AddItem(value : TFhirPractitionerQualification): TFhirPractitionerQualification; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPractitionerQualification) : Integer;
    

    // Insert FhirPractitionerQualification before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPractitionerQualification;
    

    // Insert an existing FhirPractitionerQualification before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPractitionerQualification);
    
    // Get the iIndexth FhirPractitionerQualification. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPractitionerQualification);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPractitionerQualification;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirPractitionerQualifications[index : Integer] : TFhirPractitionerQualification read GetItemN write SetItemN; default;
  End;

  // A person who is directly or indirectly involved in the provisioning of healthcare.
  TFhirPractitioner = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FnameList : TFhirHumanNameList;
    FtelecomList : TFhirContactPointList;
    FaddressList : TFhirAddressList;
    FGender : TFhirEnum;
    FBirthDate : TFhirDate;
    FphotoList : TFhirAttachmentList;
    FqualificationList : TFhirPractitionerQualificationList;
    FcommunicationList : TFhirCodeableConceptList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetActive(value : TFhirBoolean);
    Function GetActiveST : Boolean;
    Procedure SetActiveST(value : Boolean);
    function GetNameList : TFhirHumanNameList;
    function GetHasNameList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    Procedure SetGender(value : TFhirEnum);
    Function GetGenderST : TFhirAdministrativeGenderEnum;
    Procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    Procedure SetBirthDate(value : TFhirDate);
    Function GetBirthDateST : TFslDateTime;
    Procedure SetBirthDateST(value : TFslDateTime);
    function GetPhotoList : TFhirAttachmentList;
    function GetHasPhotoList : Boolean;
    function GetQualificationList : TFhirPractitionerQualificationList;
    function GetHasQualificationList : Boolean;
    function GetCommunicationList : TFhirCodeableConceptList;
    function GetHasCommunicationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPractitioner; overload;
    function Clone : TFhirPractitioner; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // An identifier that applies to this person in this role.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this practitioner's record is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this practitioner's record is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // The name(s) associated with the practitioner.
    property nameList : TFhirHumanNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // A contact detail for the practitioner, e.g. a telephone number or an email address.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Address(es) of the practitioner that are not role specific (typically home address).  Work addresses are not typically entered in this property as they are usually role dependent.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to The date of birth for the practitioner.
    property birthDate : TFslDateTime read GetBirthDateST write SetBirthDateST;
    // The date of birth for the practitioner.
    property birthDateElement : TFhirDate read FBirthDate write SetBirthDate;

    // Image of the person.
    property photoList : TFhirAttachmentList read GetPhotoList;
    property hasPhotoList : boolean read GetHasPhotoList;

    // The official certifications, training, and licenses that authorize or otherwise pertain to the provision of care by the practitioner.  For example, a medical license issued by a medical board authorizing the practitioner to practice medicine within a certian locality.
    property qualificationList : TFhirPractitionerQualificationList read GetQualificationList;
    property hasQualificationList : boolean read GetHasQualificationList;

    // A language the practitioner can use in patient communication.
    property communicationList : TFhirCodeableConceptList read GetCommunicationList;
    property hasCommunicationList : boolean read GetHasCommunicationList;

  end;

  TFhirPractitionerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPractitionerList;
    function GetCurrent : TFhirPractitioner;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPractitionerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPractitioner read GetCurrent;
  end;

  TFhirPractitionerList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPractitioner;
    procedure SetItemN(index : Integer; value : TFhirPractitioner);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPractitionerList; Overload;
    function Clone : TFhirPractitionerList; Overload;
    function GetEnumerator : TFhirPractitionerListEnumerator;
    

    //  Add a FhirPractitioner to the end of the list.
    function Append : TFhirPractitioner;

    
    // Add an already existing FhirPractitioner to the end of the list.
function AddItem(value : TFhirPractitioner): TFhirPractitioner; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPractitioner) : Integer;
    

    // Insert FhirPractitioner before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPractitioner;
    

    // Insert an existing FhirPractitioner before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPractitioner);
    
    // Get the iIndexth FhirPractitioner. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPractitioner);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPractitioner;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirPractitioners[index : Integer] : TFhirPractitioner read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PRACTITIONER}

{$IFDEF FHIR_PRACTITIONERROLE}

  // A collection of times the practitioner is available or performing this role at the location and/or healthcareservice.
  TFhirPractitionerRoleAvailableTime = class (TFhirBackboneElement)
  protected
    FDaysOfWeek : TFhirEnumList;
    FAllDay : TFhirBoolean;
    FAvailableStartTime : TFhirTime;
    FAvailableEndTime : TFhirTime;
    function GetDaysOfWeek : TFhirEnumList;
    function GetHasDaysOfWeek : Boolean;
    Function GetDaysOfWeekST : TFhirDaysOfWeekEnumList;
    Procedure SetDaysOfWeekST(value : TFhirDaysOfWeekEnumList);
    Procedure SetAllDay(value : TFhirBoolean);
    Function GetAllDayST : Boolean;
    Procedure SetAllDayST(value : Boolean);
    Procedure SetAvailableStartTime(value : TFhirTime);
    Function GetAvailableStartTimeST : String;
    Procedure SetAvailableStartTimeST(value : String);
    Procedure SetAvailableEndTime(value : TFhirTime);
    Function GetAvailableEndTimeST : String;
    Procedure SetAvailableEndTimeST(value : String);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPractitionerRoleAvailableTime; overload;
    function Clone : TFhirPractitionerRoleAvailableTime; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Indicates which days of the week are available between the start and end Times.
    property daysOfWeek : TFhirDaysOfWeekEnumList read GetDaysOfWeekST write SetDaysOfWeekST;
    property daysOfWeekList : TFhirEnumList read GetDaysOfWeek;
    property hasDaysOfWeek : boolean read GetHasDaysOfWeek;
    // Typed access to Is this always available? (hence times are irrelevant) e.g. 24 hour service.
    property allDay : Boolean read GetAllDayST write SetAllDayST;
    // Is this always available? (hence times are irrelevant) e.g. 24 hour service.
    property allDayElement : TFhirBoolean read FAllDay write SetAllDay;

    // Typed access to The opening time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableStartTime : String read GetAvailableStartTimeST write SetAvailableStartTimeST;
    // The opening time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableStartTimeElement : TFhirTime read FAvailableStartTime write SetAvailableStartTime;

    // Typed access to The closing time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableEndTime : String read GetAvailableEndTimeST write SetAvailableEndTimeST;
    // The closing time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableEndTimeElement : TFhirTime read FAvailableEndTime write SetAvailableEndTime;

  end;

  TFhirPractitionerRoleAvailableTimeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPractitionerRoleAvailableTimeList;
    function GetCurrent : TFhirPractitionerRoleAvailableTime;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPractitionerRoleAvailableTimeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPractitionerRoleAvailableTime read GetCurrent;
  end;

  TFhirPractitionerRoleAvailableTimeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPractitionerRoleAvailableTime;
    procedure SetItemN(index : Integer; value : TFhirPractitionerRoleAvailableTime);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPractitionerRoleAvailableTimeList; Overload;
    function Clone : TFhirPractitionerRoleAvailableTimeList; Overload;
    function GetEnumerator : TFhirPractitionerRoleAvailableTimeListEnumerator;
    

    //  Add a FhirPractitionerRoleAvailableTime to the end of the list.
    function Append : TFhirPractitionerRoleAvailableTime;

    
    // Add an already existing FhirPractitionerRoleAvailableTime to the end of the list.
function AddItem(value : TFhirPractitionerRoleAvailableTime): TFhirPractitionerRoleAvailableTime; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPractitionerRoleAvailableTime) : Integer;
    

    // Insert FhirPractitionerRoleAvailableTime before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPractitionerRoleAvailableTime;
    

    // Insert an existing FhirPractitionerRoleAvailableTime before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPractitionerRoleAvailableTime);
    
    // Get the iIndexth FhirPractitionerRoleAvailableTime. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPractitionerRoleAvailableTime);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPractitionerRoleAvailableTime;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirPractitionerRoleAvailableTimes[index : Integer] : TFhirPractitionerRoleAvailableTime read GetItemN write SetItemN; default;
  End;

  // The practitioner is not available or performing this role during this period of time due to the provided reason.
  TFhirPractitionerRoleNotAvailable = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FDuring : TFhirPeriod;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetDuring(value : TFhirPeriod);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPractitionerRoleNotAvailable; overload;
    function Clone : TFhirPractitionerRoleNotAvailable; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The reason that can be presented to the user as to why this time is not available.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The reason that can be presented to the user as to why this time is not available.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Service is not available (seasonally or for a public holiday) from this date. (defined for API consistency)
    property during : TFhirPeriod read FDuring write SetDuring;
    // Service is not available (seasonally or for a public holiday) from this date.
    property duringElement : TFhirPeriod read FDuring write SetDuring;

  end;

  TFhirPractitionerRoleNotAvailableListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPractitionerRoleNotAvailableList;
    function GetCurrent : TFhirPractitionerRoleNotAvailable;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPractitionerRoleNotAvailableList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPractitionerRoleNotAvailable read GetCurrent;
  end;

  TFhirPractitionerRoleNotAvailableList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPractitionerRoleNotAvailable;
    procedure SetItemN(index : Integer; value : TFhirPractitionerRoleNotAvailable);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPractitionerRoleNotAvailableList; Overload;
    function Clone : TFhirPractitionerRoleNotAvailableList; Overload;
    function GetEnumerator : TFhirPractitionerRoleNotAvailableListEnumerator;
    

    //  Add a FhirPractitionerRoleNotAvailable to the end of the list.
    function Append : TFhirPractitionerRoleNotAvailable;

    
    // Add an already existing FhirPractitionerRoleNotAvailable to the end of the list.
function AddItem(value : TFhirPractitionerRoleNotAvailable): TFhirPractitionerRoleNotAvailable; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPractitionerRoleNotAvailable) : Integer;
    

    // Insert FhirPractitionerRoleNotAvailable before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPractitionerRoleNotAvailable;
    

    // Insert an existing FhirPractitionerRoleNotAvailable before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPractitionerRoleNotAvailable);
    
    // Get the iIndexth FhirPractitionerRoleNotAvailable. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPractitionerRoleNotAvailable);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPractitionerRoleNotAvailable;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirPractitionerRoleNotAvailables[index : Integer] : TFhirPractitionerRoleNotAvailable read GetItemN write SetItemN; default;
  End;

  // A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.
  TFhirPractitionerRole = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FPeriod : TFhirPeriod;
    FPractitioner : TFhirReference{TFhirPractitioner};
    FOrganization : TFhirReference{TFhirOrganization};
    FcodeList : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FlocationList : TFhirReferenceList{TFhirLocation};
    FhealthcareServiceList : TFhirReferenceList{TFhirHealthcareService};
    FtelecomList : TFhirContactPointList;
    FavailableTimeList : TFhirPractitionerRoleAvailableTimeList;
    FnotAvailableList : TFhirPractitionerRoleNotAvailableList;
    FAvailabilityExceptions : TFhirString;
    FendpointList : TFhirReferenceList{TFhirEndpoint};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetActive(value : TFhirBoolean);
    Function GetActiveST : Boolean;
    Procedure SetActiveST(value : Boolean);
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetPractitioner(value : TFhirReference{TFhirPractitioner});
    Procedure SetOrganization(value : TFhirReference{TFhirOrganization});
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    function GetLocationList : TFhirReferenceList{TFhirLocation};
    function GetHasLocationList : Boolean;
    function GetHealthcareServiceList : TFhirReferenceList{TFhirHealthcareService};
    function GetHasHealthcareServiceList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    function GetAvailableTimeList : TFhirPractitionerRoleAvailableTimeList;
    function GetHasAvailableTimeList : Boolean;
    function GetNotAvailableList : TFhirPractitionerRoleNotAvailableList;
    function GetHasNotAvailableList : Boolean;
    Procedure SetAvailabilityExceptions(value : TFhirString);
    Function GetAvailabilityExceptionsST : String;
    Procedure SetAvailabilityExceptionsST(value : String);
    function GetEndpointList : TFhirReferenceList{TFhirEndpoint};
    function GetHasEndpointList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPractitionerRole; overload;
    function Clone : TFhirPractitionerRole; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Business Identifiers that are specific to a role/location.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this practitioner role record is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this practitioner role record is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to The period during which the person is authorized to act as a practitioner in these role(s) for the organization. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period during which the person is authorized to act as a practitioner in these role(s) for the organization.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Practitioner that is able to provide the defined services for the organization. (defined for API consistency)
    property practitioner : TFhirReference{TFhirPractitioner} read FPractitioner write SetPractitioner;
    // Practitioner that is able to provide the defined services for the organization.
    property practitionerElement : TFhirReference{TFhirPractitioner} read FPractitioner write SetPractitioner;

    // Typed access to The organization where the Practitioner performs the roles associated. (defined for API consistency)
    property organization : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;
    // The organization where the Practitioner performs the roles associated.
    property organizationElement : TFhirReference{TFhirOrganization} read FOrganization write SetOrganization;

    // Roles which this practitioner is authorized to perform for the organization.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Specific specialty of the practitioner.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // The location(s) at which this practitioner provides care.
    property locationList : TFhirReferenceList{TFhirLocation} read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // The list of healthcare services that this worker provides for this role's Organization/Location(s).
    property healthcareServiceList : TFhirReferenceList{TFhirHealthcareService} read GetHealthcareServiceList;
    property hasHealthcareServiceList : boolean read GetHasHealthcareServiceList;

    // Contact details that are specific to the role/location/service.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // A collection of times the practitioner is available or performing this role at the location and/or healthcareservice.
    property availableTimeList : TFhirPractitionerRoleAvailableTimeList read GetAvailableTimeList;
    property hasAvailableTimeList : boolean read GetHasAvailableTimeList;

    // The practitioner is not available or performing this role during this period of time due to the provided reason.
    property notAvailableList : TFhirPractitionerRoleNotAvailableList read GetNotAvailableList;
    property hasNotAvailableList : boolean read GetHasNotAvailableList;

    // Typed access to A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
    property availabilityExceptions : String read GetAvailabilityExceptionsST write SetAvailabilityExceptionsST;
    // A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
    property availabilityExceptionsElement : TFhirString read FAvailabilityExceptions write SetAvailabilityExceptions;

    // Technical endpoints providing access to services operated for the practitioner with this role.
    property endpointList : TFhirReferenceList{TFhirEndpoint} read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

  end;

  TFhirPractitionerRoleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPractitionerRoleList;
    function GetCurrent : TFhirPractitionerRole;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPractitionerRoleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPractitionerRole read GetCurrent;
  end;

  TFhirPractitionerRoleList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPractitionerRole;
    procedure SetItemN(index : Integer; value : TFhirPractitionerRole);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPractitionerRoleList; Overload;
    function Clone : TFhirPractitionerRoleList; Overload;
    function GetEnumerator : TFhirPractitionerRoleListEnumerator;
    

    //  Add a FhirPractitionerRole to the end of the list.
    function Append : TFhirPractitionerRole;

    
    // Add an already existing FhirPractitionerRole to the end of the list.
function AddItem(value : TFhirPractitionerRole): TFhirPractitionerRole; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPractitionerRole) : Integer;
    

    // Insert FhirPractitionerRole before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPractitionerRole;
    

    // Insert an existing FhirPractitionerRole before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPractitionerRole);
    
    // Get the iIndexth FhirPractitionerRole. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPractitionerRole);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPractitionerRole;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirPractitionerRoles[index : Integer] : TFhirPractitionerRole read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PRACTITIONERROLE}

{$IFDEF FHIR_RELATEDPERSON}

  // A language which may be used to communicate with about the patient's health.
  TFhirRelatedPersonCommunication = class (TFhirBackboneElement)
  protected
    FLanguage : TFhirCodeableConcept;
    FPreferred : TFhirBoolean;
    Procedure SetLanguage(value : TFhirCodeableConcept);
    Procedure SetPreferred(value : TFhirBoolean);
    Function GetPreferredST : Boolean;
    Procedure SetPreferredST(value : Boolean);
  
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRelatedPersonCommunication; overload;
    function Clone : TFhirRelatedPersonCommunication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

    // Typed access to Indicates whether or not the patient prefers this language (over other languages he masters up a certain level).
    property preferred : Boolean read GetPreferredST write SetPreferredST;
    // Indicates whether or not the patient prefers this language (over other languages he masters up a certain level).
    property preferredElement : TFhirBoolean read FPreferred write SetPreferred;

  end;

  TFhirRelatedPersonCommunicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRelatedPersonCommunicationList;
    function GetCurrent : TFhirRelatedPersonCommunication;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRelatedPersonCommunicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRelatedPersonCommunication read GetCurrent;
  end;

  TFhirRelatedPersonCommunicationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRelatedPersonCommunication;
    procedure SetItemN(index : Integer; value : TFhirRelatedPersonCommunication);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRelatedPersonCommunicationList; Overload;
    function Clone : TFhirRelatedPersonCommunicationList; Overload;
    function GetEnumerator : TFhirRelatedPersonCommunicationListEnumerator;
    

    //  Add a FhirRelatedPersonCommunication to the end of the list.
    function Append : TFhirRelatedPersonCommunication;

    
    // Add an already existing FhirRelatedPersonCommunication to the end of the list.
function AddItem(value : TFhirRelatedPersonCommunication): TFhirRelatedPersonCommunication; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRelatedPersonCommunication) : Integer;
    

    // Insert FhirRelatedPersonCommunication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRelatedPersonCommunication;
    

    // Insert an existing FhirRelatedPersonCommunication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRelatedPersonCommunication);
    
    // Get the iIndexth FhirRelatedPersonCommunication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRelatedPersonCommunication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRelatedPersonCommunication;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirRelatedPersonCommunications[index : Integer] : TFhirRelatedPersonCommunication read GetItemN write SetItemN; default;
  End;

  // Information about a person that is involved in the care for a patient, but who is not the target of healthcare, nor has a formal responsibility in the care process.
  TFhirRelatedPerson = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FPatient : TFhirReference{TFhirPatient};
    FrelationshipList : TFhirCodeableConceptList;
    FnameList : TFhirHumanNameList;
    FtelecomList : TFhirContactPointList;
    FGender : TFhirEnum;
    FBirthDate : TFhirDate;
    FaddressList : TFhirAddressList;
    FphotoList : TFhirAttachmentList;
    FPeriod : TFhirPeriod;
    FcommunicationList : TFhirRelatedPersonCommunicationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetActive(value : TFhirBoolean);
    Function GetActiveST : Boolean;
    Procedure SetActiveST(value : Boolean);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    function GetRelationshipList : TFhirCodeableConceptList;
    function GetHasRelationshipList : Boolean;
    function GetNameList : TFhirHumanNameList;
    function GetHasNameList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    Procedure SetGender(value : TFhirEnum);
    Function GetGenderST : TFhirAdministrativeGenderEnum;
    Procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    Procedure SetBirthDate(value : TFhirDate);
    Function GetBirthDateST : TFslDateTime;
    Procedure SetBirthDateST(value : TFslDateTime);
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    function GetPhotoList : TFhirAttachmentList;
    function GetHasPhotoList : Boolean;
    Procedure SetPeriod(value : TFhirPeriod);
    function GetCommunicationList : TFhirRelatedPersonCommunicationList;
    function GetHasCommunicationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRelatedPerson; overload;
    function Clone : TFhirRelatedPerson; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifier for a person within a particular scope.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this related person record is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this related person record is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to The patient this person is related to. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The patient this person is related to.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // The nature of the relationship between a patient and the related person.
    property relationshipList : TFhirCodeableConceptList read GetRelationshipList;
    property hasRelationshipList : boolean read GetHasRelationshipList;

    // A name associated with the person.
    property nameList : TFhirHumanNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // A contact detail for the person, e.g. a telephone number or an email address.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to The date on which the related person was born.
    property birthDate : TFslDateTime read GetBirthDateST write SetBirthDateST;
    // The date on which the related person was born.
    property birthDateElement : TFhirDate read FBirthDate write SetBirthDate;

    // Address where the related person can be contacted or visited.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Image of the person.
    property photoList : TFhirAttachmentList read GetPhotoList;
    property hasPhotoList : boolean read GetHasPhotoList;

    // Typed access to The period of time during which this relationship is or was active. If there are no dates defined, then the interval is unknown. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time during which this relationship is or was active. If there are no dates defined, then the interval is unknown.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // A language which may be used to communicate with about the patient's health.
    property communicationList : TFhirRelatedPersonCommunicationList read GetCommunicationList;
    property hasCommunicationList : boolean read GetHasCommunicationList;

  end;

  TFhirRelatedPersonListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRelatedPersonList;
    function GetCurrent : TFhirRelatedPerson;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRelatedPersonList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRelatedPerson read GetCurrent;
  end;

  TFhirRelatedPersonList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRelatedPerson;
    procedure SetItemN(index : Integer; value : TFhirRelatedPerson);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRelatedPersonList; Overload;
    function Clone : TFhirRelatedPersonList; Overload;
    function GetEnumerator : TFhirRelatedPersonListEnumerator;
    

    //  Add a FhirRelatedPerson to the end of the list.
    function Append : TFhirRelatedPerson;

    
    // Add an already existing FhirRelatedPerson to the end of the list.
function AddItem(value : TFhirRelatedPerson): TFhirRelatedPerson; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRelatedPerson) : Integer;
    

    // Insert FhirRelatedPerson before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRelatedPerson;
    

    // Insert an existing FhirRelatedPerson before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRelatedPerson);
    
    // Get the iIndexth FhirRelatedPerson. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRelatedPerson);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRelatedPerson;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirRelatedPeople[index : Integer] : TFhirRelatedPerson read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RELATEDPERSON}

{$IFDEF FHIR_SCHEDULE}

  // A container for slots of time that may be available for booking appointments.
  TFhirSchedule = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FserviceCategoryList : TFhirCodeableConceptList;
    FserviceTypeList : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FactorList : TFhirReferenceList{TFhirPatient};
    FPlanningHorizon : TFhirPeriod;
    FComment : TFhirString;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetActive(value : TFhirBoolean);
    Function GetActiveST : Boolean;
    Procedure SetActiveST(value : Boolean);
    function GetServiceCategoryList : TFhirCodeableConceptList;
    function GetHasServiceCategoryList : Boolean;
    function GetServiceTypeList : TFhirCodeableConceptList;
    function GetHasServiceTypeList : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    function GetActorList : TFhirReferenceList{TFhirPatient};
    function GetHasActorList : Boolean;
    Procedure SetPlanningHorizon(value : TFhirPeriod);
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSchedule; overload;
    function Clone : TFhirSchedule; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // External Ids for this item.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this schedule record is in active use or should not be used (such as was entered in error).
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this schedule record is in active use or should not be used (such as was entered in error).
    property activeElement : TFhirBoolean read FActive write SetActive;

    // A broad categorization of the service that is to be performed during this appointment.
    property serviceCategoryList : TFhirCodeableConceptList read GetServiceCategoryList;
    property hasServiceCategoryList : boolean read GetHasServiceCategoryList;

    // The specific service that is to be performed during this appointment.
    property serviceTypeList : TFhirCodeableConceptList read GetServiceTypeList;
    property hasServiceTypeList : boolean read GetHasServiceTypeList;

    // The specialty of a practitioner that would be required to perform the service requested in this appointment.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // Slots that reference this schedule resource provide the availability details to these referenced resource(s).
    property actorList : TFhirReferenceList{TFhirPatient} read GetActorList;
    property hasActorList : boolean read GetHasActorList;

    // Typed access to The period of time that the slots that reference this Schedule resource cover (even if none exist). These  cover the amount of time that an organization's planning horizon; the interval for which they are currently accepting appointments. This does not define a "template" for planning outside these dates. (defined for API consistency)
    property planningHorizon : TFhirPeriod read FPlanningHorizon write SetPlanningHorizon;
    // The period of time that the slots that reference this Schedule resource cover (even if none exist). These  cover the amount of time that an organization's planning horizon; the interval for which they are currently accepting appointments. This does not define a "template" for planning outside these dates.
    property planningHorizonElement : TFhirPeriod read FPlanningHorizon write SetPlanningHorizon;

    // Typed access to Comments on the availability to describe any extended information. Such as custom constraints on the slots that may be associated.
    property comment : String read GetCommentST write SetCommentST;
    // Comments on the availability to describe any extended information. Such as custom constraints on the slots that may be associated.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirScheduleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirScheduleList;
    function GetCurrent : TFhirSchedule;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirScheduleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSchedule read GetCurrent;
  end;

  TFhirScheduleList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSchedule;
    procedure SetItemN(index : Integer; value : TFhirSchedule);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirScheduleList; Overload;
    function Clone : TFhirScheduleList; Overload;
    function GetEnumerator : TFhirScheduleListEnumerator;
    

    //  Add a FhirSchedule to the end of the list.
    function Append : TFhirSchedule;

    
    // Add an already existing FhirSchedule to the end of the list.
function AddItem(value : TFhirSchedule): TFhirSchedule; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSchedule) : Integer;
    

    // Insert FhirSchedule before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSchedule;
    

    // Insert an existing FhirSchedule before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSchedule);
    
    // Get the iIndexth FhirSchedule. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSchedule);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSchedule;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSchedules[index : Integer] : TFhirSchedule read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SCHEDULE}

{$IFDEF FHIR_SLOT}

  // A slot of time on a schedule that may be available for booking appointments.
  TFhirSlot = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FserviceCategoryList : TFhirCodeableConceptList;
    FserviceTypeList : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FAppointmentType : TFhirCodeableConcept;
    FSchedule : TFhirReference{TFhirSchedule};
    FStatus : TFhirEnum;
    FStart : TFhirInstant;
    FEnd_ : TFhirInstant;
    FOverbooked : TFhirBoolean;
    FComment : TFhirString;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetServiceCategoryList : TFhirCodeableConceptList;
    function GetHasServiceCategoryList : Boolean;
    function GetServiceTypeList : TFhirCodeableConceptList;
    function GetHasServiceTypeList : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    Procedure SetAppointmentType(value : TFhirCodeableConcept);
    Procedure SetSchedule(value : TFhirReference{TFhirSchedule});
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirSlotstatusEnum;
    Procedure SetStatusST(value : TFhirSlotstatusEnum);
    Procedure SetStart(value : TFhirInstant);
    Function GetStartST : TFslDateTime;
    Procedure SetStartST(value : TFslDateTime);
    Procedure SetEnd_(value : TFhirInstant);
    Function GetEnd_ST : TFslDateTime;
    Procedure SetEnd_ST(value : TFslDateTime);
    Procedure SetOverbooked(value : TFhirBoolean);
    Function GetOverbookedST : Boolean;
    Procedure SetOverbookedST(value : Boolean);
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);
  
    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSlot; overload;
    function Clone : TFhirSlot; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // External Ids for this item.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A broad categorization of the service that is to be performed during this appointment.
    property serviceCategoryList : TFhirCodeableConceptList read GetServiceCategoryList;
    property hasServiceCategoryList : boolean read GetHasServiceCategoryList;

    // The type of appointments that can be booked into this slot (ideally this would be an identifiable service - which is at a location, rather than the location itself). If provided then this overrides the value provided on the availability resource.
    property serviceTypeList : TFhirCodeableConceptList read GetServiceTypeList;
    property hasServiceTypeList : boolean read GetHasServiceTypeList;

    // The specialty of a practitioner that would be required to perform the service requested in this appointment.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // Typed access to The style of appointment or patient that may be booked in the slot (not service type). (defined for API consistency)
    property appointmentType : TFhirCodeableConcept read FAppointmentType write SetAppointmentType;
    // The style of appointment or patient that may be booked in the slot (not service type).
    property appointmentTypeElement : TFhirCodeableConcept read FAppointmentType write SetAppointmentType;

    // Typed access to The schedule resource that this slot defines an interval of status information. (defined for API consistency)
    property schedule : TFhirReference{TFhirSchedule} read FSchedule write SetSchedule;
    // The schedule resource that this slot defines an interval of status information.
    property scheduleElement : TFhirReference{TFhirSchedule} read FSchedule write SetSchedule;

    // busy | free | busy-unavailable | busy-tentative | entered-in-error.
    property status : TFhirSlotstatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Date/Time that the slot is to begin.
    property start : TFslDateTime read GetStartST write SetStartST;
    // Date/Time that the slot is to begin.
    property startElement : TFhirInstant read FStart write SetStart;

    // Typed access to Date/Time that the slot is to conclude.
    property end_ : TFslDateTime read GetEnd_ST write SetEnd_ST;
    // Date/Time that the slot is to conclude.
    property end_Element : TFhirInstant read FEnd_ write SetEnd_;

    // Typed access to This slot has already been overbooked, appointments are unlikely to be accepted for this time.
    property overbooked : Boolean read GetOverbookedST write SetOverbookedST;
    // This slot has already been overbooked, appointments are unlikely to be accepted for this time.
    property overbookedElement : TFhirBoolean read FOverbooked write SetOverbooked;

    // Typed access to Comments on the slot to describe any extended information. Such as custom constraints on the slot.
    property comment : String read GetCommentST write SetCommentST;
    // Comments on the slot to describe any extended information. Such as custom constraints on the slot.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirSlotListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSlotList;
    function GetCurrent : TFhirSlot;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSlotList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSlot read GetCurrent;
  end;

  TFhirSlotList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSlot;
    procedure SetItemN(index : Integer; value : TFhirSlot);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSlotList; Overload;
    function Clone : TFhirSlotList; Overload;
    function GetEnumerator : TFhirSlotListEnumerator;
    

    //  Add a FhirSlot to the end of the list.
    function Append : TFhirSlot;

    
    // Add an already existing FhirSlot to the end of the list.
function AddItem(value : TFhirSlot): TFhirSlot; overload;

    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSlot) : Integer;
    

    // Insert FhirSlot before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSlot;
    

    // Insert an existing FhirSlot before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSlot);
    
    // Get the iIndexth FhirSlot. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSlot);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSlot;
    
    // The number of items in the collection
    function Count : Integer; Overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    Property FhirSlots[index : Integer] : TFhirSlot read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SLOT}

implementation

uses
  fhir4_utilities;

{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}

{ TFhirBiologicallyDerivedProductCollection }

constructor TFhirBiologicallyDerivedProductCollection.Create;
begin
  inherited;
end;

destructor TFhirBiologicallyDerivedProductCollection.Destroy;
begin
  FCollector.free;
  FSource.free;
  FCollected.free;
  inherited;
end;

procedure TFhirBiologicallyDerivedProductCollection.Assign(oSource : TFslObject);
begin
  inherited;
  collector := TFhirBiologicallyDerivedProductCollection(oSource).collector.Clone;
  source := TFhirBiologicallyDerivedProductCollection(oSource).source.Clone;
  collected := TFhirBiologicallyDerivedProductCollection(oSource).collected.Clone;
end;

procedure TFhirBiologicallyDerivedProductCollection.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'collector') Then
     list.add(self.link, 'collector', FCollector.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'collected[x]') or (child_name = 'collected') Then
     list.add(self.link, 'collected[x]', FCollected.Link);
end;

procedure TFhirBiologicallyDerivedProductCollection.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'collector', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FCollector.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'source', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FSource.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'collected[x]', 'dateTime|Period', false, TFhirType, FCollected.Link));{2}
end;

function TFhirBiologicallyDerivedProductCollection.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'collector') then
  begin
    Collector := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then
  begin
    Collected := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBiologicallyDerivedProductCollection.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBiologicallyDerivedProductCollection.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'collector') then result := TFhirReference{TFhirPractitioner}.Create(){4b}
  else if (propName = 'source') then result := TFhirReference{TFhirPatient}.Create(){4b}
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then raise EFHIRException.Create('Cannot make property Collected'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBiologicallyDerivedProductCollection.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'collector') then result := 'Reference'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'collected[x]') then result := 'dateTime|Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBiologicallyDerivedProductCollection.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'collector') then CollectorElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then CollectedElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBiologicallyDerivedProductCollection.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'collector') then CollectorElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'source') then SourceElement := new as TFhirReference{TFhirPatient}{4}
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then CollectedElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBiologicallyDerivedProductCollection.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBiologicallyDerivedProductCollection.fhirType : string;
begin
  result := 'collection';
end;

function TFhirBiologicallyDerivedProductCollection.Link : TFhirBiologicallyDerivedProductCollection;
begin
  result := TFhirBiologicallyDerivedProductCollection(inherited Link);
end;

function TFhirBiologicallyDerivedProductCollection.Clone : TFhirBiologicallyDerivedProductCollection;
begin
  result := TFhirBiologicallyDerivedProductCollection(inherited Clone);
end;

function TFhirBiologicallyDerivedProductCollection.equals(other : TObject) : boolean; 
var
  o : TFhirBiologicallyDerivedProductCollection;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBiologicallyDerivedProductCollection)) then
    result := false
  else
  begin
    o := TFhirBiologicallyDerivedProductCollection(other);
    result := compareDeep(collectorElement, o.collectorElement, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(collectedElement, o.collectedElement, true);
  end;
end;

function TFhirBiologicallyDerivedProductCollection.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCollector) and isEmptyProp(FSource) and isEmptyProp(FCollected);
end;

procedure TFhirBiologicallyDerivedProductCollection.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('collector');
  fields.add('source');
  fields.add('collected[x]');
end;

{ TFhirBiologicallyDerivedProductCollection }

Procedure TFhirBiologicallyDerivedProductCollection.SetCollector(value : TFhirReference{TFhirPractitioner});
begin
  FCollector.free;
  FCollector := value;
end;

Procedure TFhirBiologicallyDerivedProductCollection.SetSource(value : TFhirReference{TFhirPatient});
begin
  FSource.free;
  FSource := value;
end;

Procedure TFhirBiologicallyDerivedProductCollection.SetCollected(value : TFhirType);
begin
  FCollected.free;
  FCollected := value;
end;

function TFhirBiologicallyDerivedProductCollection.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FCollector.sizeInBytes(magic));
  inc(result, FSource.sizeInBytes(magic));
  inc(result, FCollected.sizeInBytes(magic));
end;

{ TFhirBiologicallyDerivedProductCollectionListEnumerator }

Constructor TFhirBiologicallyDerivedProductCollectionListEnumerator.Create(list : TFhirBiologicallyDerivedProductCollectionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBiologicallyDerivedProductCollectionListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirBiologicallyDerivedProductCollectionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBiologicallyDerivedProductCollectionListEnumerator.GetCurrent : TFhirBiologicallyDerivedProductCollection;
begin
  Result := FList[FIndex];
end;

function TFhirBiologicallyDerivedProductCollectionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBiologicallyDerivedProductCollectionList }
function TFhirBiologicallyDerivedProductCollectionList.AddItem(value: TFhirBiologicallyDerivedProductCollection): TFhirBiologicallyDerivedProductCollection;
begin
  add(value);
  result := value;
end;

function TFhirBiologicallyDerivedProductCollectionList.Append: TFhirBiologicallyDerivedProductCollection;
begin
  result := TFhirBiologicallyDerivedProductCollection.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductCollectionList.ClearItems;
begin
  Clear;
end;

function TFhirBiologicallyDerivedProductCollectionList.GetEnumerator : TFhirBiologicallyDerivedProductCollectionListEnumerator;
begin
  result := TFhirBiologicallyDerivedProductCollectionListEnumerator.Create(self.link);
end;

function TFhirBiologicallyDerivedProductCollectionList.Clone: TFhirBiologicallyDerivedProductCollectionList;
begin
  result := TFhirBiologicallyDerivedProductCollectionList(inherited Clone);
end;

function TFhirBiologicallyDerivedProductCollectionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBiologicallyDerivedProductCollectionList.GetItemN(index: Integer): TFhirBiologicallyDerivedProductCollection;
begin
  result := TFhirBiologicallyDerivedProductCollection(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductCollectionList.ItemClass: TFslObjectClass;
begin
  result := TFhirBiologicallyDerivedProductCollection;
end;
function TFhirBiologicallyDerivedProductCollectionList.IndexOf(value: TFhirBiologicallyDerivedProductCollection): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBiologicallyDerivedProductCollectionList.Insert(index: Integer): TFhirBiologicallyDerivedProductCollection;
begin
  result := TFhirBiologicallyDerivedProductCollection.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductCollectionList.InsertItem(index: Integer; value: TFhirBiologicallyDerivedProductCollection);
begin
  assert(value is TFhirBiologicallyDerivedProductCollection);
  Inherited Insert(index, value);
end;

function TFhirBiologicallyDerivedProductCollectionList.Item(index: Integer): TFhirBiologicallyDerivedProductCollection;
begin
  result := TFhirBiologicallyDerivedProductCollection(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductCollectionList.Link: TFhirBiologicallyDerivedProductCollectionList;
begin
  result := TFhirBiologicallyDerivedProductCollectionList(inherited Link);
end;

procedure TFhirBiologicallyDerivedProductCollectionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBiologicallyDerivedProductCollectionList.SetItemByIndex(index: Integer; value: TFhirBiologicallyDerivedProductCollection);
begin
  assert(value is TFhirBiologicallyDerivedProductCollection);
  FhirBiologicallyDerivedProductCollections[index] := value;
end;

procedure TFhirBiologicallyDerivedProductCollectionList.SetItemN(index: Integer; value: TFhirBiologicallyDerivedProductCollection);
begin
  assert(value is TFhirBiologicallyDerivedProductCollection);
  ObjectByIndex[index] := value;
end;

{ TFhirBiologicallyDerivedProductProcessing }

constructor TFhirBiologicallyDerivedProductProcessing.Create;
begin
  inherited;
end;

destructor TFhirBiologicallyDerivedProductProcessing.Destroy;
begin
  FDescription.free;
  FProcedure_.free;
  FAdditive.free;
  FTime.free;
  inherited;
end;

procedure TFhirBiologicallyDerivedProductProcessing.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirBiologicallyDerivedProductProcessing(oSource).descriptionElement.Clone;
  procedure_ := TFhirBiologicallyDerivedProductProcessing(oSource).procedure_.Clone;
  additive := TFhirBiologicallyDerivedProductProcessing(oSource).additive.Clone;
  time := TFhirBiologicallyDerivedProductProcessing(oSource).time.Clone;
end;

procedure TFhirBiologicallyDerivedProductProcessing.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'procedure') Then
     list.add(self.link, 'procedure', FProcedure_.Link);
  if (child_name = 'additive') Then
     list.add(self.link, 'additive', FAdditive.Link);
  if (child_name = 'time[x]') or (child_name = 'time') Then
     list.add(self.link, 'time[x]', FTime.Link);
end;

procedure TFhirBiologicallyDerivedProductProcessing.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'procedure', 'CodeableConcept', false, TFhirCodeableConcept, FProcedure_.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'additive', 'Reference(Substance)', false, TFhirReference{TFhirSubstance}, FAdditive.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'time[x]', 'dateTime|Period', false, TFhirType, FTime.Link));{2}
end;

function TFhirBiologicallyDerivedProductProcessing.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'procedure') then
  begin
    Procedure_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'additive') then
  begin
    Additive := propValue as TFhirReference{TFhirSubstance}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then
  begin
    Time := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBiologicallyDerivedProductProcessing.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBiologicallyDerivedProductProcessing.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.Create() {5b}
  else if (propName = 'procedure') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'additive') then result := TFhirReference{TFhirSubstance}.Create(){4b}
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then raise EFHIRException.Create('Cannot make property Time'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBiologicallyDerivedProductProcessing.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'procedure') then result := 'CodeableConcept'
  else if (propName = 'additive') then result := 'Reference'
  else if (propName = 'time[x]') then result := 'dateTime|Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBiologicallyDerivedProductProcessing.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'procedure') then Procedure_Element := nil
  else if (propName = 'additive') then AdditiveElement := nil
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then TimeElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBiologicallyDerivedProductProcessing.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'procedure') then Procedure_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'additive') then AdditiveElement := new as TFhirReference{TFhirSubstance}{4}
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then TimeElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBiologicallyDerivedProductProcessing.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBiologicallyDerivedProductProcessing.fhirType : string;
begin
  result := 'processing';
end;

function TFhirBiologicallyDerivedProductProcessing.Link : TFhirBiologicallyDerivedProductProcessing;
begin
  result := TFhirBiologicallyDerivedProductProcessing(inherited Link);
end;

function TFhirBiologicallyDerivedProductProcessing.Clone : TFhirBiologicallyDerivedProductProcessing;
begin
  result := TFhirBiologicallyDerivedProductProcessing(inherited Clone);
end;

function TFhirBiologicallyDerivedProductProcessing.equals(other : TObject) : boolean; 
var
  o : TFhirBiologicallyDerivedProductProcessing;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBiologicallyDerivedProductProcessing)) then
    result := false
  else
  begin
    o := TFhirBiologicallyDerivedProductProcessing(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(procedure_Element, o.procedure_Element, true) and 
      compareDeep(additiveElement, o.additiveElement, true) and compareDeep(timeElement, o.timeElement, true);
  end;
end;

function TFhirBiologicallyDerivedProductProcessing.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FProcedure_) and isEmptyProp(FAdditive) and isEmptyProp(FTime);
end;

procedure TFhirBiologicallyDerivedProductProcessing.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('procedure');
  fields.add('additive');
  fields.add('time[x]');
end;

{ TFhirBiologicallyDerivedProductProcessing }

Procedure TFhirBiologicallyDerivedProductProcessing.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirBiologicallyDerivedProductProcessing.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirBiologicallyDerivedProductProcessing.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.Create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirBiologicallyDerivedProductProcessing.SetProcedure_(value : TFhirCodeableConcept);
begin
  FProcedure_.free;
  FProcedure_ := value;
end;

Procedure TFhirBiologicallyDerivedProductProcessing.SetAdditive(value : TFhirReference{TFhirSubstance});
begin
  FAdditive.free;
  FAdditive := value;
end;

Procedure TFhirBiologicallyDerivedProductProcessing.SetTime(value : TFhirType);
begin
  FTime.free;
  FTime := value;
end;

function TFhirBiologicallyDerivedProductProcessing.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FDescription.sizeInBytes(magic));
  inc(result, FProcedure_.sizeInBytes(magic));
  inc(result, FAdditive.sizeInBytes(magic));
  inc(result, FTime.sizeInBytes(magic));
end;

{ TFhirBiologicallyDerivedProductProcessingListEnumerator }

Constructor TFhirBiologicallyDerivedProductProcessingListEnumerator.Create(list : TFhirBiologicallyDerivedProductProcessingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBiologicallyDerivedProductProcessingListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirBiologicallyDerivedProductProcessingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBiologicallyDerivedProductProcessingListEnumerator.GetCurrent : TFhirBiologicallyDerivedProductProcessing;
begin
  Result := FList[FIndex];
end;

function TFhirBiologicallyDerivedProductProcessingListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBiologicallyDerivedProductProcessingList }
function TFhirBiologicallyDerivedProductProcessingList.AddItem(value: TFhirBiologicallyDerivedProductProcessing): TFhirBiologicallyDerivedProductProcessing;
begin
  add(value);
  result := value;
end;

function TFhirBiologicallyDerivedProductProcessingList.Append: TFhirBiologicallyDerivedProductProcessing;
begin
  result := TFhirBiologicallyDerivedProductProcessing.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductProcessingList.ClearItems;
begin
  Clear;
end;

function TFhirBiologicallyDerivedProductProcessingList.GetEnumerator : TFhirBiologicallyDerivedProductProcessingListEnumerator;
begin
  result := TFhirBiologicallyDerivedProductProcessingListEnumerator.Create(self.link);
end;

function TFhirBiologicallyDerivedProductProcessingList.Clone: TFhirBiologicallyDerivedProductProcessingList;
begin
  result := TFhirBiologicallyDerivedProductProcessingList(inherited Clone);
end;

function TFhirBiologicallyDerivedProductProcessingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBiologicallyDerivedProductProcessingList.GetItemN(index: Integer): TFhirBiologicallyDerivedProductProcessing;
begin
  result := TFhirBiologicallyDerivedProductProcessing(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductProcessingList.ItemClass: TFslObjectClass;
begin
  result := TFhirBiologicallyDerivedProductProcessing;
end;
function TFhirBiologicallyDerivedProductProcessingList.IndexOf(value: TFhirBiologicallyDerivedProductProcessing): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBiologicallyDerivedProductProcessingList.Insert(index: Integer): TFhirBiologicallyDerivedProductProcessing;
begin
  result := TFhirBiologicallyDerivedProductProcessing.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductProcessingList.InsertItem(index: Integer; value: TFhirBiologicallyDerivedProductProcessing);
begin
  assert(value is TFhirBiologicallyDerivedProductProcessing);
  Inherited Insert(index, value);
end;

function TFhirBiologicallyDerivedProductProcessingList.Item(index: Integer): TFhirBiologicallyDerivedProductProcessing;
begin
  result := TFhirBiologicallyDerivedProductProcessing(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductProcessingList.Link: TFhirBiologicallyDerivedProductProcessingList;
begin
  result := TFhirBiologicallyDerivedProductProcessingList(inherited Link);
end;

procedure TFhirBiologicallyDerivedProductProcessingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBiologicallyDerivedProductProcessingList.SetItemByIndex(index: Integer; value: TFhirBiologicallyDerivedProductProcessing);
begin
  assert(value is TFhirBiologicallyDerivedProductProcessing);
  FhirBiologicallyDerivedProductProcessings[index] := value;
end;

procedure TFhirBiologicallyDerivedProductProcessingList.SetItemN(index: Integer; value: TFhirBiologicallyDerivedProductProcessing);
begin
  assert(value is TFhirBiologicallyDerivedProductProcessing);
  ObjectByIndex[index] := value;
end;

{ TFhirBiologicallyDerivedProductManipulation }

constructor TFhirBiologicallyDerivedProductManipulation.Create;
begin
  inherited;
end;

destructor TFhirBiologicallyDerivedProductManipulation.Destroy;
begin
  FDescription.free;
  FTime.free;
  inherited;
end;

procedure TFhirBiologicallyDerivedProductManipulation.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirBiologicallyDerivedProductManipulation(oSource).descriptionElement.Clone;
  time := TFhirBiologicallyDerivedProductManipulation(oSource).time.Clone;
end;

procedure TFhirBiologicallyDerivedProductManipulation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'time[x]') or (child_name = 'time') Then
     list.add(self.link, 'time[x]', FTime.Link);
end;

procedure TFhirBiologicallyDerivedProductManipulation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'time[x]', 'dateTime|Period', false, TFhirType, FTime.Link));{2}
end;

function TFhirBiologicallyDerivedProductManipulation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then
  begin
    Time := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBiologicallyDerivedProductManipulation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBiologicallyDerivedProductManipulation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.Create() {5b}
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then raise EFHIRException.Create('Cannot make property Time'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBiologicallyDerivedProductManipulation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'time[x]') then result := 'dateTime|Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBiologicallyDerivedProductManipulation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then TimeElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBiologicallyDerivedProductManipulation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then TimeElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBiologicallyDerivedProductManipulation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBiologicallyDerivedProductManipulation.fhirType : string;
begin
  result := 'manipulation';
end;

function TFhirBiologicallyDerivedProductManipulation.Link : TFhirBiologicallyDerivedProductManipulation;
begin
  result := TFhirBiologicallyDerivedProductManipulation(inherited Link);
end;

function TFhirBiologicallyDerivedProductManipulation.Clone : TFhirBiologicallyDerivedProductManipulation;
begin
  result := TFhirBiologicallyDerivedProductManipulation(inherited Clone);
end;

function TFhirBiologicallyDerivedProductManipulation.equals(other : TObject) : boolean; 
var
  o : TFhirBiologicallyDerivedProductManipulation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBiologicallyDerivedProductManipulation)) then
    result := false
  else
  begin
    o := TFhirBiologicallyDerivedProductManipulation(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(timeElement, o.timeElement, true);
  end;
end;

function TFhirBiologicallyDerivedProductManipulation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FTime);
end;

procedure TFhirBiologicallyDerivedProductManipulation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('time[x]');
end;

{ TFhirBiologicallyDerivedProductManipulation }

Procedure TFhirBiologicallyDerivedProductManipulation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirBiologicallyDerivedProductManipulation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirBiologicallyDerivedProductManipulation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.Create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirBiologicallyDerivedProductManipulation.SetTime(value : TFhirType);
begin
  FTime.free;
  FTime := value;
end;

function TFhirBiologicallyDerivedProductManipulation.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FDescription.sizeInBytes(magic));
  inc(result, FTime.sizeInBytes(magic));
end;

{ TFhirBiologicallyDerivedProductManipulationListEnumerator }

Constructor TFhirBiologicallyDerivedProductManipulationListEnumerator.Create(list : TFhirBiologicallyDerivedProductManipulationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBiologicallyDerivedProductManipulationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirBiologicallyDerivedProductManipulationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBiologicallyDerivedProductManipulationListEnumerator.GetCurrent : TFhirBiologicallyDerivedProductManipulation;
begin
  Result := FList[FIndex];
end;

function TFhirBiologicallyDerivedProductManipulationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBiologicallyDerivedProductManipulationList }
function TFhirBiologicallyDerivedProductManipulationList.AddItem(value: TFhirBiologicallyDerivedProductManipulation): TFhirBiologicallyDerivedProductManipulation;
begin
  add(value);
  result := value;
end;

function TFhirBiologicallyDerivedProductManipulationList.Append: TFhirBiologicallyDerivedProductManipulation;
begin
  result := TFhirBiologicallyDerivedProductManipulation.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductManipulationList.ClearItems;
begin
  Clear;
end;

function TFhirBiologicallyDerivedProductManipulationList.GetEnumerator : TFhirBiologicallyDerivedProductManipulationListEnumerator;
begin
  result := TFhirBiologicallyDerivedProductManipulationListEnumerator.Create(self.link);
end;

function TFhirBiologicallyDerivedProductManipulationList.Clone: TFhirBiologicallyDerivedProductManipulationList;
begin
  result := TFhirBiologicallyDerivedProductManipulationList(inherited Clone);
end;

function TFhirBiologicallyDerivedProductManipulationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBiologicallyDerivedProductManipulationList.GetItemN(index: Integer): TFhirBiologicallyDerivedProductManipulation;
begin
  result := TFhirBiologicallyDerivedProductManipulation(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductManipulationList.ItemClass: TFslObjectClass;
begin
  result := TFhirBiologicallyDerivedProductManipulation;
end;
function TFhirBiologicallyDerivedProductManipulationList.IndexOf(value: TFhirBiologicallyDerivedProductManipulation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBiologicallyDerivedProductManipulationList.Insert(index: Integer): TFhirBiologicallyDerivedProductManipulation;
begin
  result := TFhirBiologicallyDerivedProductManipulation.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductManipulationList.InsertItem(index: Integer; value: TFhirBiologicallyDerivedProductManipulation);
begin
  assert(value is TFhirBiologicallyDerivedProductManipulation);
  Inherited Insert(index, value);
end;

function TFhirBiologicallyDerivedProductManipulationList.Item(index: Integer): TFhirBiologicallyDerivedProductManipulation;
begin
  result := TFhirBiologicallyDerivedProductManipulation(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductManipulationList.Link: TFhirBiologicallyDerivedProductManipulationList;
begin
  result := TFhirBiologicallyDerivedProductManipulationList(inherited Link);
end;

procedure TFhirBiologicallyDerivedProductManipulationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBiologicallyDerivedProductManipulationList.SetItemByIndex(index: Integer; value: TFhirBiologicallyDerivedProductManipulation);
begin
  assert(value is TFhirBiologicallyDerivedProductManipulation);
  FhirBiologicallyDerivedProductManipulations[index] := value;
end;

procedure TFhirBiologicallyDerivedProductManipulationList.SetItemN(index: Integer; value: TFhirBiologicallyDerivedProductManipulation);
begin
  assert(value is TFhirBiologicallyDerivedProductManipulation);
  ObjectByIndex[index] := value;
end;

{ TFhirBiologicallyDerivedProductStorage }

constructor TFhirBiologicallyDerivedProductStorage.Create;
begin
  inherited;
end;

destructor TFhirBiologicallyDerivedProductStorage.Destroy;
begin
  FDescription.free;
  FTemperature.free;
  FScale.free;
  FDuration.free;
  inherited;
end;

procedure TFhirBiologicallyDerivedProductStorage.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirBiologicallyDerivedProductStorage(oSource).descriptionElement.Clone;
  temperatureElement := TFhirBiologicallyDerivedProductStorage(oSource).temperatureElement.Clone;
  FScale := TFhirBiologicallyDerivedProductStorage(oSource).FScale.Link;
  duration := TFhirBiologicallyDerivedProductStorage(oSource).duration.Clone;
end;

procedure TFhirBiologicallyDerivedProductStorage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'temperature') Then
     list.add(self.link, 'temperature', FTemperature.Link);
  if (child_name = 'scale') Then
     list.add(self.link, 'scale', FScale.Link);
  if (child_name = 'duration') Then
     list.add(self.link, 'duration', FDuration.Link);
end;

procedure TFhirBiologicallyDerivedProductStorage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'temperature', 'decimal', false, TFhirDecimal, FTemperature.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'scale', 'code', false, TFHIREnum, FScale.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'duration', 'Period', false, TFhirPeriod, FDuration.Link));{2}
end;

function TFhirBiologicallyDerivedProductStorage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'temperature') then
  begin
    TemperatureElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'scale') then
  begin
    ScaleElement := asEnum(SYSTEMS_TFhirProductStorageScaleEnum, CODES_TFhirProductStorageScaleEnum, propValue);
    result := propValue
  end
  else if (propName = 'duration') then
  begin
    Duration := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBiologicallyDerivedProductStorage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBiologicallyDerivedProductStorage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.Create() {5b}
  else if (propName = 'temperature') then result := TFhirDecimal.Create() {5b}
  else if (propName = 'duration') then result := TFhirPeriod.Create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBiologicallyDerivedProductStorage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'temperature') then result := 'decimal'
  else if (propName = 'scale') then result := 'code'
  else if (propName = 'duration') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBiologicallyDerivedProductStorage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'temperature') then TemperatureElement := nil
  else if (propName = 'scale') then ScaleElement := nil
  else if (propName = 'duration') then DurationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBiologicallyDerivedProductStorage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'temperature') then TemperatureElement := asDecimal(new){5b}
  else if (propName = 'scale') then ScaleElement := asEnum(SYSTEMS_TFhirProductStorageScaleEnum, CODES_TFhirProductStorageScaleEnum, new){4}
  else if (propName = 'duration') then DurationElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBiologicallyDerivedProductStorage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBiologicallyDerivedProductStorage.fhirType : string;
begin
  result := 'storage';
end;

function TFhirBiologicallyDerivedProductStorage.Link : TFhirBiologicallyDerivedProductStorage;
begin
  result := TFhirBiologicallyDerivedProductStorage(inherited Link);
end;

function TFhirBiologicallyDerivedProductStorage.Clone : TFhirBiologicallyDerivedProductStorage;
begin
  result := TFhirBiologicallyDerivedProductStorage(inherited Clone);
end;

function TFhirBiologicallyDerivedProductStorage.equals(other : TObject) : boolean; 
var
  o : TFhirBiologicallyDerivedProductStorage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBiologicallyDerivedProductStorage)) then
    result := false
  else
  begin
    o := TFhirBiologicallyDerivedProductStorage(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(temperatureElement, o.temperatureElement, true) and 
      compareDeep(scaleElement, o.scaleElement, true) and compareDeep(durationElement, o.durationElement, true);
  end;
end;

function TFhirBiologicallyDerivedProductStorage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FTemperature) and isEmptyProp(FScale) and isEmptyProp(FDuration);
end;

procedure TFhirBiologicallyDerivedProductStorage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('temperature');
  fields.add('scale');
  fields.add('duration');
end;

{ TFhirBiologicallyDerivedProductStorage }

Procedure TFhirBiologicallyDerivedProductStorage.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirBiologicallyDerivedProductStorage.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirBiologicallyDerivedProductStorage.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.Create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirBiologicallyDerivedProductStorage.SetTemperature(value : TFhirDecimal);
begin
  FTemperature.free;
  FTemperature := value;
end;

Function TFhirBiologicallyDerivedProductStorage.GetTemperatureST : String;
begin
  if FTemperature = nil then
    result := ''
  else
    result := FTemperature.value;
end;

Procedure TFhirBiologicallyDerivedProductStorage.SetTemperatureST(value : String);
begin
  if value <> '' then
  begin
    if FTemperature = nil then
      FTemperature := TFhirDecimal.Create;
    FTemperature.value := value
  end
  else if FTemperature <> nil then
    FTemperature.value := '';
end;

Procedure TFhirBiologicallyDerivedProductStorage.SetScale(value : TFhirEnum);
begin
  FScale.free;
  FScale := value;
end;

Function TFhirBiologicallyDerivedProductStorage.GetScaleST : TFhirProductStorageScaleEnum;
begin
  if FScale = nil then
    result := TFhirProductStorageScaleEnum(0)
  else
    result := TFhirProductStorageScaleEnum(StringArrayIndexOfSensitive(CODES_TFhirProductStorageScaleEnum, FScale.value));
end;

Procedure TFhirBiologicallyDerivedProductStorage.SetScaleST(value : TFhirProductStorageScaleEnum);
begin
  if ord(value) = 0 then
    ScaleElement := nil
  else
    ScaleElement := TFhirEnum.Create(SYSTEMS_TFhirProductStorageScaleEnum[value], CODES_TFhirProductStorageScaleEnum[value]);
end;

Procedure TFhirBiologicallyDerivedProductStorage.SetDuration(value : TFhirPeriod);
begin
  FDuration.free;
  FDuration := value;
end;

function TFhirBiologicallyDerivedProductStorage.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FDescription.sizeInBytes(magic));
  inc(result, FTemperature.sizeInBytes(magic));
  inc(result, FScale.sizeInBytes(magic));
  inc(result, FDuration.sizeInBytes(magic));
end;

{ TFhirBiologicallyDerivedProductStorageListEnumerator }

Constructor TFhirBiologicallyDerivedProductStorageListEnumerator.Create(list : TFhirBiologicallyDerivedProductStorageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBiologicallyDerivedProductStorageListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirBiologicallyDerivedProductStorageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBiologicallyDerivedProductStorageListEnumerator.GetCurrent : TFhirBiologicallyDerivedProductStorage;
begin
  Result := FList[FIndex];
end;

function TFhirBiologicallyDerivedProductStorageListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBiologicallyDerivedProductStorageList }
function TFhirBiologicallyDerivedProductStorageList.AddItem(value: TFhirBiologicallyDerivedProductStorage): TFhirBiologicallyDerivedProductStorage;
begin
  add(value);
  result := value;
end;

function TFhirBiologicallyDerivedProductStorageList.Append: TFhirBiologicallyDerivedProductStorage;
begin
  result := TFhirBiologicallyDerivedProductStorage.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductStorageList.ClearItems;
begin
  Clear;
end;

function TFhirBiologicallyDerivedProductStorageList.GetEnumerator : TFhirBiologicallyDerivedProductStorageListEnumerator;
begin
  result := TFhirBiologicallyDerivedProductStorageListEnumerator.Create(self.link);
end;

function TFhirBiologicallyDerivedProductStorageList.Clone: TFhirBiologicallyDerivedProductStorageList;
begin
  result := TFhirBiologicallyDerivedProductStorageList(inherited Clone);
end;

function TFhirBiologicallyDerivedProductStorageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBiologicallyDerivedProductStorageList.GetItemN(index: Integer): TFhirBiologicallyDerivedProductStorage;
begin
  result := TFhirBiologicallyDerivedProductStorage(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductStorageList.ItemClass: TFslObjectClass;
begin
  result := TFhirBiologicallyDerivedProductStorage;
end;
function TFhirBiologicallyDerivedProductStorageList.IndexOf(value: TFhirBiologicallyDerivedProductStorage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBiologicallyDerivedProductStorageList.Insert(index: Integer): TFhirBiologicallyDerivedProductStorage;
begin
  result := TFhirBiologicallyDerivedProductStorage.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductStorageList.InsertItem(index: Integer; value: TFhirBiologicallyDerivedProductStorage);
begin
  assert(value is TFhirBiologicallyDerivedProductStorage);
  Inherited Insert(index, value);
end;

function TFhirBiologicallyDerivedProductStorageList.Item(index: Integer): TFhirBiologicallyDerivedProductStorage;
begin
  result := TFhirBiologicallyDerivedProductStorage(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductStorageList.Link: TFhirBiologicallyDerivedProductStorageList;
begin
  result := TFhirBiologicallyDerivedProductStorageList(inherited Link);
end;

procedure TFhirBiologicallyDerivedProductStorageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBiologicallyDerivedProductStorageList.SetItemByIndex(index: Integer; value: TFhirBiologicallyDerivedProductStorage);
begin
  assert(value is TFhirBiologicallyDerivedProductStorage);
  FhirBiologicallyDerivedProductStorages[index] := value;
end;

procedure TFhirBiologicallyDerivedProductStorageList.SetItemN(index: Integer; value: TFhirBiologicallyDerivedProductStorage);
begin
  assert(value is TFhirBiologicallyDerivedProductStorage);
  ObjectByIndex[index] := value;
end;

{ TFhirBiologicallyDerivedProduct }

constructor TFhirBiologicallyDerivedProduct.Create;
begin
  inherited;
end;

destructor TFhirBiologicallyDerivedProduct.Destroy;
begin
  FIdentifierList.free;
  FProductCategory.free;
  FProductCode.free;
  FStatus.free;
  FRequestList.free;
  FQuantity.free;
  FParentList.free;
  FCollection.free;
  FProcessingList.free;
  FManipulation.free;
  FStorageList.free;
  inherited;
end;

function TFhirBiologicallyDerivedProduct.GetResourceType : TFhirResourceType;
begin
  result := frtBiologicallyDerivedProduct;
end;

procedure TFhirBiologicallyDerivedProduct.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirBiologicallyDerivedProduct(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirBiologicallyDerivedProduct(oSource).FIdentifierList);
  end;
  FProductCategory := TFhirBiologicallyDerivedProduct(oSource).FProductCategory.Link;
  productCode := TFhirBiologicallyDerivedProduct(oSource).productCode.Clone;
  FStatus := TFhirBiologicallyDerivedProduct(oSource).FStatus.Link;
  if (TFhirBiologicallyDerivedProduct(oSource).FRequestList = nil) then
  begin
    FRequestList.free;
    FRequestList := nil;
  end
  else
  begin
    if FRequestList = nil then
      FRequestList := TFhirReferenceList{TFhirServiceRequest}.Create;
    FRequestList.Assign(TFhirBiologicallyDerivedProduct(oSource).FRequestList);
  end;
  quantityElement := TFhirBiologicallyDerivedProduct(oSource).quantityElement.Clone;
  if (TFhirBiologicallyDerivedProduct(oSource).FParentList = nil) then
  begin
    FParentList.free;
    FParentList := nil;
  end
  else
  begin
    if FParentList = nil then
      FParentList := TFhirReferenceList{TFhirBiologicallyDerivedProduct}.Create;
    FParentList.Assign(TFhirBiologicallyDerivedProduct(oSource).FParentList);
  end;
  collection := TFhirBiologicallyDerivedProduct(oSource).collection.Clone;
  if (TFhirBiologicallyDerivedProduct(oSource).FProcessingList = nil) then
  begin
    FProcessingList.free;
    FProcessingList := nil;
  end
  else
  begin
    if FProcessingList = nil then
      FProcessingList := TFhirBiologicallyDerivedProductProcessingList.Create;
    FProcessingList.Assign(TFhirBiologicallyDerivedProduct(oSource).FProcessingList);
  end;
  manipulation := TFhirBiologicallyDerivedProduct(oSource).manipulation.Clone;
  if (TFhirBiologicallyDerivedProduct(oSource).FStorageList = nil) then
  begin
    FStorageList.free;
    FStorageList := nil;
  end
  else
  begin
    if FStorageList = nil then
      FStorageList := TFhirBiologicallyDerivedProductStorageList.Create;
    FStorageList.Assign(TFhirBiologicallyDerivedProduct(oSource).FStorageList);
  end;
end;

procedure TFhirBiologicallyDerivedProduct.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'productCategory') Then
     list.add(self.link, 'productCategory', FProductCategory.Link);
  if (child_name = 'productCode') Then
     list.add(self.link, 'productCode', FProductCode.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'request') Then
    list.addAll(self, 'request', FRequestList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'parent') Then
    list.addAll(self, 'parent', FParentList);
  if (child_name = 'collection') Then
     list.add(self.link, 'collection', FCollection.Link);
  if (child_name = 'processing') Then
    list.addAll(self, 'processing', FProcessingList);
  if (child_name = 'manipulation') Then
     list.add(self.link, 'manipulation', FManipulation.Link);
  if (child_name = 'storage') Then
    list.addAll(self, 'storage', FStorageList);
end;

procedure TFhirBiologicallyDerivedProduct.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'productCategory', 'code', false, TFHIREnum, FProductCategory.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'productCode', 'CodeableConcept', false, TFhirCodeableConcept, FProductCode.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'request', 'Reference(ServiceRequest)', true, TFhirReference{TFhirServiceRequest}, FRequestList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'quantity', 'integer', false, TFhirInteger, FQuantity.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'parent', 'Reference(BiologicallyDerivedProduct)', true, TFhirReference{TFhirBiologicallyDerivedProduct}, FParentList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'collection', '', false, TFhirBiologicallyDerivedProductCollection, FCollection.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'processing', '', true, TFhirBiologicallyDerivedProductProcessing, FProcessingList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'manipulation', '', false, TFhirBiologicallyDerivedProductManipulation, FManipulation.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'storage', '', true, TFhirBiologicallyDerivedProductStorage, FStorageList.Link)){3};
end;

function TFhirBiologicallyDerivedProduct.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'productCategory') then
  begin
    ProductCategoryElement := asEnum(SYSTEMS_TFhirProductCategoryEnum, CODES_TFhirProductCategoryEnum, propValue);
    result := propValue
  end
  else if (propName = 'productCode') then
  begin
    ProductCode := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirProductStatusEnum, CODES_TFhirProductStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'request') then
  begin
    RequestList.add(propValue as TFhirReference{TFhirServiceRequest}){2a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    QuantityElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    ParentList.add(propValue as TFhirReference{TFhirBiologicallyDerivedProduct}){2a};
    result := propValue;
  end
  else if (propName = 'collection') then
  begin
    Collection := propValue as TFhirBiologicallyDerivedProductCollection{4b};
    result := propValue;
  end
  else if (propName = 'processing') then
  begin
    ProcessingList.add(propValue as TFhirBiologicallyDerivedProductProcessing){2a};
    result := propValue;
  end
  else if (propName = 'manipulation') then
  begin
    Manipulation := propValue as TFhirBiologicallyDerivedProductManipulation{4b};
    result := propValue;
  end
  else if (propName = 'storage') then
  begin
    StorageList.add(propValue as TFhirBiologicallyDerivedProductStorage){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirBiologicallyDerivedProduct.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'request') then RequestList.insertItem(index, propValue as TFhirReference{TFhirServiceRequest}){2a}
  else if (propName = 'parent') then ParentList.insertItem(index, propValue as TFhirReference{TFhirBiologicallyDerivedProduct}){2a}
  else if (propName = 'processing') then ProcessingList.insertItem(index, propValue as TFhirBiologicallyDerivedProductProcessing){2a}
  else if (propName = 'storage') then StorageList.insertItem(index, propValue as TFhirBiologicallyDerivedProductStorage){2a}
  else inherited;
end;

function TFhirBiologicallyDerivedProduct.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'productCode') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'request') then result := RequestList.new(){2}
  else if (propName = 'quantity') then result := TFhirInteger.Create() {5b}
  else if (propName = 'parent') then result := ParentList.new(){2}
  else if (propName = 'collection') then result := TFhirBiologicallyDerivedProductCollection.Create(){4b}
  else if (propName = 'processing') then result := ProcessingList.new(){2}
  else if (propName = 'manipulation') then result := TFhirBiologicallyDerivedProductManipulation.Create(){4b}
  else if (propName = 'storage') then result := StorageList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBiologicallyDerivedProduct.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'productCategory') then result := 'code'
  else if (propName = 'productCode') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'quantity') then result := 'integer'
  else if (propName = 'parent') then result := 'Reference'
  else if (propName = 'collection') then result := ''
  else if (propName = 'processing') then result := ''
  else if (propName = 'manipulation') then result := ''
  else if (propName = 'storage') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBiologicallyDerivedProduct.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'productCategory') then ProductCategoryElement := nil
  else if (propName = 'productCode') then ProductCodeElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'request') then deletePropertyValue('request', RequestList, value) {2}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'parent') then deletePropertyValue('parent', ParentList, value) {2}
  else if (propName = 'collection') then CollectionElement := nil
  else if (propName = 'processing') then deletePropertyValue('processing', ProcessingList, value) {2}
  else if (propName = 'manipulation') then ManipulationElement := nil
  else if (propName = 'storage') then deletePropertyValue('storage', StorageList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBiologicallyDerivedProduct.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'productCategory') then ProductCategoryElement := asEnum(SYSTEMS_TFhirProductCategoryEnum, CODES_TFhirProductCategoryEnum, new){4}
  else if (propName = 'productCode') then ProductCodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirProductStatusEnum, CODES_TFhirProductStatusEnum, new){4}
  else if (propName = 'request') then replacePropertyValue('request', RequestList, existing, new) {2}
  else if (propName = 'quantity') then QuantityElement := asInteger(new){5b}
  else if (propName = 'parent') then replacePropertyValue('parent', ParentList, existing, new) {2}
  else if (propName = 'collection') then CollectionElement := new as TFhirBiologicallyDerivedProductCollection{4}
  else if (propName = 'processing') then replacePropertyValue('processing', ProcessingList, existing, new) {2}
  else if (propName = 'manipulation') then ManipulationElement := new as TFhirBiologicallyDerivedProductManipulation{4}
  else if (propName = 'storage') then replacePropertyValue('storage', StorageList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBiologicallyDerivedProduct.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'request') then RequestList.move(source, destination){2a}
  else if (propName = 'parent') then ParentList.move(source, destination){2a}
  else if (propName = 'processing') then ProcessingList.move(source, destination){2a}
  else if (propName = 'storage') then StorageList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBiologicallyDerivedProduct.fhirType : string;
begin
  result := 'BiologicallyDerivedProduct';
end;

function TFhirBiologicallyDerivedProduct.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FProductCategory) and isEmptyProp(FProductCode) and isEmptyProp(FStatus) and isEmptyProp(FrequestList) and isEmptyProp(FQuantity) and isEmptyProp(FparentList) and isEmptyProp(FCollection) and isEmptyProp(FprocessingList) and isEmptyProp(FManipulation) and isEmptyProp(FstorageList);
end;

function TFhirBiologicallyDerivedProduct.equals(other : TObject) : boolean; 
var
  o : TFhirBiologicallyDerivedProduct;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBiologicallyDerivedProduct)) then
    result := false
  else
  begin
    o := TFhirBiologicallyDerivedProduct(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(productCategoryElement, o.productCategoryElement, true) and 
      compareDeep(productCodeElement, o.productCodeElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(requestList, o.requestList, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(parentList, o.parentList, true) and compareDeep(collectionElement, o.collectionElement, true) and 
      compareDeep(processingList, o.processingList, true) and compareDeep(manipulationElement, o.manipulationElement, true) and 
      compareDeep(storageList, o.storageList, true);
  end;
end;

function TFhirBiologicallyDerivedProduct.Link : TFhirBiologicallyDerivedProduct;
begin
  result := TFhirBiologicallyDerivedProduct(inherited Link);
end;

function TFhirBiologicallyDerivedProduct.Clone : TFhirBiologicallyDerivedProduct;
begin
  result := TFhirBiologicallyDerivedProduct(inherited Clone);
end;

procedure TFhirBiologicallyDerivedProduct.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('productCategory');
  fields.add('productCode');
  fields.add('status');
  fields.add('request');
  fields.add('quantity');
  fields.add('parent');
  fields.add('collection');
  fields.add('processing');
  fields.add('manipulation');
  fields.add('storage');
end;

{ TFhirBiologicallyDerivedProduct }

Function TFhirBiologicallyDerivedProduct.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirBiologicallyDerivedProduct.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirBiologicallyDerivedProduct.SetProductCategory(value : TFhirEnum);
begin
  FProductCategory.free;
  FProductCategory := value;
end;

Function TFhirBiologicallyDerivedProduct.GetProductCategoryST : TFhirProductCategoryEnum;
begin
  if FProductCategory = nil then
    result := TFhirProductCategoryEnum(0)
  else
    result := TFhirProductCategoryEnum(StringArrayIndexOfSensitive(CODES_TFhirProductCategoryEnum, FProductCategory.value));
end;

Procedure TFhirBiologicallyDerivedProduct.SetProductCategoryST(value : TFhirProductCategoryEnum);
begin
  if ord(value) = 0 then
    ProductCategoryElement := nil
  else
    ProductCategoryElement := TFhirEnum.Create(SYSTEMS_TFhirProductCategoryEnum[value], CODES_TFhirProductCategoryEnum[value]);
end;

Procedure TFhirBiologicallyDerivedProduct.SetProductCode(value : TFhirCodeableConcept);
begin
  FProductCode.free;
  FProductCode := value;
end;

Procedure TFhirBiologicallyDerivedProduct.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirBiologicallyDerivedProduct.GetStatusST : TFhirProductStatusEnum;
begin
  if FStatus = nil then
    result := TFhirProductStatusEnum(0)
  else
    result := TFhirProductStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirProductStatusEnum, FStatus.value));
end;

Procedure TFhirBiologicallyDerivedProduct.SetStatusST(value : TFhirProductStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.Create(SYSTEMS_TFhirProductStatusEnum[value], CODES_TFhirProductStatusEnum[value]);
end;

Function TFhirBiologicallyDerivedProduct.GetRequestList : TFhirReferenceList{TFhirServiceRequest};
begin
  if FRequestList = nil then
    FRequestList := TFhirReferenceList{TFhirServiceRequest}.Create;
  result := FRequestList;
end;

Function TFhirBiologicallyDerivedProduct.GetHasRequestList : boolean;
begin
  result := (FRequestList <> nil) and (FRequestList.count > 0);
end;

Procedure TFhirBiologicallyDerivedProduct.SetQuantity(value : TFhirInteger);
begin
  FQuantity.free;
  FQuantity := value;
end;

Function TFhirBiologicallyDerivedProduct.GetQuantityST : String;
begin
  if FQuantity = nil then
    result := ''
  else
    result := FQuantity.value;
end;

Procedure TFhirBiologicallyDerivedProduct.SetQuantityST(value : String);
begin
  if value <> '' then
  begin
    if FQuantity = nil then
      FQuantity := TFhirInteger.Create;
    FQuantity.value := value
  end
  else if FQuantity <> nil then
    FQuantity.value := '';
end;

Function TFhirBiologicallyDerivedProduct.GetParentList : TFhirReferenceList{TFhirBiologicallyDerivedProduct};
begin
  if FParentList = nil then
    FParentList := TFhirReferenceList{TFhirBiologicallyDerivedProduct}.Create;
  result := FParentList;
end;

Function TFhirBiologicallyDerivedProduct.GetHasParentList : boolean;
begin
  result := (FParentList <> nil) and (FParentList.count > 0);
end;

Procedure TFhirBiologicallyDerivedProduct.SetCollection(value : TFhirBiologicallyDerivedProductCollection);
begin
  FCollection.free;
  FCollection := value;
end;

Function TFhirBiologicallyDerivedProduct.GetProcessingList : TFhirBiologicallyDerivedProductProcessingList;
begin
  if FProcessingList = nil then
    FProcessingList := TFhirBiologicallyDerivedProductProcessingList.Create;
  result := FProcessingList;
end;

Function TFhirBiologicallyDerivedProduct.GetHasProcessingList : boolean;
begin
  result := (FProcessingList <> nil) and (FProcessingList.count > 0);
end;

Procedure TFhirBiologicallyDerivedProduct.SetManipulation(value : TFhirBiologicallyDerivedProductManipulation);
begin
  FManipulation.free;
  FManipulation := value;
end;

Function TFhirBiologicallyDerivedProduct.GetStorageList : TFhirBiologicallyDerivedProductStorageList;
begin
  if FStorageList = nil then
    FStorageList := TFhirBiologicallyDerivedProductStorageList.Create;
  result := FStorageList;
end;

Function TFhirBiologicallyDerivedProduct.GetHasStorageList : boolean;
begin
  result := (FStorageList <> nil) and (FStorageList.count > 0);
end;

function TFhirBiologicallyDerivedProduct.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FidentifierList.sizeInBytes(magic));
  inc(result, FProductCategory.sizeInBytes(magic));
  inc(result, FProductCode.sizeInBytes(magic));
  inc(result, FStatus.sizeInBytes(magic));
  inc(result, FrequestList.sizeInBytes(magic));
  inc(result, FQuantity.sizeInBytes(magic));
  inc(result, FparentList.sizeInBytes(magic));
  inc(result, FCollection.sizeInBytes(magic));
  inc(result, FprocessingList.sizeInBytes(magic));
  inc(result, FManipulation.sizeInBytes(magic));
  inc(result, FstorageList.sizeInBytes(magic));
end;

{ TFhirBiologicallyDerivedProductListEnumerator }

Constructor TFhirBiologicallyDerivedProductListEnumerator.Create(list : TFhirBiologicallyDerivedProductList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBiologicallyDerivedProductListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirBiologicallyDerivedProductListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBiologicallyDerivedProductListEnumerator.GetCurrent : TFhirBiologicallyDerivedProduct;
begin
  Result := FList[FIndex];
end;

function TFhirBiologicallyDerivedProductListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBiologicallyDerivedProductList }
function TFhirBiologicallyDerivedProductList.AddItem(value: TFhirBiologicallyDerivedProduct): TFhirBiologicallyDerivedProduct;
begin
  add(value);
  result := value;
end;

function TFhirBiologicallyDerivedProductList.Append: TFhirBiologicallyDerivedProduct;
begin
  result := TFhirBiologicallyDerivedProduct.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductList.ClearItems;
begin
  Clear;
end;

function TFhirBiologicallyDerivedProductList.GetEnumerator : TFhirBiologicallyDerivedProductListEnumerator;
begin
  result := TFhirBiologicallyDerivedProductListEnumerator.Create(self.link);
end;

function TFhirBiologicallyDerivedProductList.Clone: TFhirBiologicallyDerivedProductList;
begin
  result := TFhirBiologicallyDerivedProductList(inherited Clone);
end;

function TFhirBiologicallyDerivedProductList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBiologicallyDerivedProductList.GetItemN(index: Integer): TFhirBiologicallyDerivedProduct;
begin
  result := TFhirBiologicallyDerivedProduct(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductList.ItemClass: TFslObjectClass;
begin
  result := TFhirBiologicallyDerivedProduct;
end;
function TFhirBiologicallyDerivedProductList.IndexOf(value: TFhirBiologicallyDerivedProduct): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBiologicallyDerivedProductList.Insert(index: Integer): TFhirBiologicallyDerivedProduct;
begin
  result := TFhirBiologicallyDerivedProduct.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductList.InsertItem(index: Integer; value: TFhirBiologicallyDerivedProduct);
begin
  assert(value is TFhirBiologicallyDerivedProduct);
  Inherited Insert(index, value);
end;

function TFhirBiologicallyDerivedProductList.Item(index: Integer): TFhirBiologicallyDerivedProduct;
begin
  result := TFhirBiologicallyDerivedProduct(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductList.Link: TFhirBiologicallyDerivedProductList;
begin
  result := TFhirBiologicallyDerivedProductList(inherited Link);
end;

procedure TFhirBiologicallyDerivedProductList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBiologicallyDerivedProductList.SetItemByIndex(index: Integer; value: TFhirBiologicallyDerivedProduct);
begin
  assert(value is TFhirBiologicallyDerivedProduct);
  FhirBiologicallyDerivedProducts[index] := value;
end;

procedure TFhirBiologicallyDerivedProductList.SetItemN(index: Integer; value: TFhirBiologicallyDerivedProduct);
begin
  assert(value is TFhirBiologicallyDerivedProduct);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}

{$IFDEF FHIR_CATALOGENTRY}

{ TFhirCatalogEntryRelatedEntry }

constructor TFhirCatalogEntryRelatedEntry.Create;
begin
  inherited;
end;

destructor TFhirCatalogEntryRelatedEntry.Destroy;
begin
  FRelationtype.free;
  FItem.free;
  inherited;
end;

procedure TFhirCatalogEntryRelatedEntry.Assign(oSource : TFslObject);
begin
  inherited;
  FRelationtype := TFhirCatalogEntryRelatedEntry(oSource).FRelationtype.Link;
  item := TFhirCatalogEntryRelatedEntry(oSource).item.Clone;
end;

procedure TFhirCatalogEntryRelatedEntry.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'relationtype') Then
     list.add(self.link, 'relationtype', FRelationtype.Link);
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
end;

procedure TFhirCatalogEntryRelatedEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'relationtype', 'code', false, TFHIREnum, FRelationtype.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'item', 'Reference(CatalogEntry)', false, TFhirReference{TFhirCatalogEntry}, FItem.Link));{2}
end;

function TFhirCatalogEntryRelatedEntry.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'relationtype') then
  begin
    RelationtypeElement := asEnum(SYSTEMS_TFhirRelationTypeEnum, CODES_TFhirRelationTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'item') then
  begin
    Item := propValue as TFhirReference{TFhirCatalogEntry}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCatalogEntryRelatedEntry.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCatalogEntryRelatedEntry.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'item') then result := TFhirReference{TFhirCatalogEntry}.Create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCatalogEntryRelatedEntry.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'relationtype') then result := 'code'
  else if (propName = 'item') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCatalogEntryRelatedEntry.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'relationtype') then RelationtypeElement := nil
  else if (propName = 'item') then ItemElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCatalogEntryRelatedEntry.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'relationtype') then RelationtypeElement := asEnum(SYSTEMS_TFhirRelationTypeEnum, CODES_TFhirRelationTypeEnum, new){4}
  else if (propName = 'item') then ItemElement := new as TFhirReference{TFhirCatalogEntry}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCatalogEntryRelatedEntry.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCatalogEntryRelatedEntry.fhirType : string;
begin
  result := 'relatedEntry';
end;

function TFhirCatalogEntryRelatedEntry.Link : TFhirCatalogEntryRelatedEntry;
begin
  result := TFhirCatalogEntryRelatedEntry(inherited Link);
end;

function TFhirCatalogEntryRelatedEntry.Clone : TFhirCatalogEntryRelatedEntry;
begin
  result := TFhirCatalogEntryRelatedEntry(inherited Clone);
end;

function TFhirCatalogEntryRelatedEntry.equals(other : TObject) : boolean; 
var
  o : TFhirCatalogEntryRelatedEntry;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCatalogEntryRelatedEntry)) then
    result := false
  else
  begin
    o := TFhirCatalogEntryRelatedEntry(other);
    result := compareDeep(relationtypeElement, o.relationtypeElement, true) and 
      compareDeep(itemElement, o.itemElement, true);
  end;
end;

function TFhirCatalogEntryRelatedEntry.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRelationtype) and isEmptyProp(FItem);
end;

procedure TFhirCatalogEntryRelatedEntry.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('relationtype');
  fields.add('item');
end;

{ TFhirCatalogEntryRelatedEntry }

Procedure TFhirCatalogEntryRelatedEntry.SetRelationtype(value : TFhirEnum);
begin
  FRelationtype.free;
  FRelationtype := value;
end;

Function TFhirCatalogEntryRelatedEntry.GetRelationtypeST : TFhirRelationTypeEnum;
begin
  if FRelationtype = nil then
    result := TFhirRelationTypeEnum(0)
  else
    result := TFhirRelationTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirRelationTypeEnum, FRelationtype.value));
end;

Procedure TFhirCatalogEntryRelatedEntry.SetRelationtypeST(value : TFhirRelationTypeEnum);
begin
  if ord(value) = 0 then
    RelationtypeElement := nil
  else
    RelationtypeElement := TFhirEnum.Create(SYSTEMS_TFhirRelationTypeEnum[value], CODES_TFhirRelationTypeEnum[value]);
end;

Procedure TFhirCatalogEntryRelatedEntry.SetItem(value : TFhirReference{TFhirCatalogEntry});
begin
  FItem.free;
  FItem := value;
end;

function TFhirCatalogEntryRelatedEntry.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FRelationtype.sizeInBytes(magic));
  inc(result, FItem.sizeInBytes(magic));
end;

{ TFhirCatalogEntryRelatedEntryListEnumerator }

Constructor TFhirCatalogEntryRelatedEntryListEnumerator.Create(list : TFhirCatalogEntryRelatedEntryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCatalogEntryRelatedEntryListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirCatalogEntryRelatedEntryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCatalogEntryRelatedEntryListEnumerator.GetCurrent : TFhirCatalogEntryRelatedEntry;
begin
  Result := FList[FIndex];
end;

function TFhirCatalogEntryRelatedEntryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCatalogEntryRelatedEntryList }
function TFhirCatalogEntryRelatedEntryList.AddItem(value: TFhirCatalogEntryRelatedEntry): TFhirCatalogEntryRelatedEntry;
begin
  add(value);
  result := value;
end;

function TFhirCatalogEntryRelatedEntryList.Append: TFhirCatalogEntryRelatedEntry;
begin
  result := TFhirCatalogEntryRelatedEntry.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCatalogEntryRelatedEntryList.ClearItems;
begin
  Clear;
end;

function TFhirCatalogEntryRelatedEntryList.GetEnumerator : TFhirCatalogEntryRelatedEntryListEnumerator;
begin
  result := TFhirCatalogEntryRelatedEntryListEnumerator.Create(self.link);
end;

function TFhirCatalogEntryRelatedEntryList.Clone: TFhirCatalogEntryRelatedEntryList;
begin
  result := TFhirCatalogEntryRelatedEntryList(inherited Clone);
end;

function TFhirCatalogEntryRelatedEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCatalogEntryRelatedEntryList.GetItemN(index: Integer): TFhirCatalogEntryRelatedEntry;
begin
  result := TFhirCatalogEntryRelatedEntry(ObjectByIndex[index]);
end;

function TFhirCatalogEntryRelatedEntryList.ItemClass: TFslObjectClass;
begin
  result := TFhirCatalogEntryRelatedEntry;
end;
function TFhirCatalogEntryRelatedEntryList.IndexOf(value: TFhirCatalogEntryRelatedEntry): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCatalogEntryRelatedEntryList.Insert(index: Integer): TFhirCatalogEntryRelatedEntry;
begin
  result := TFhirCatalogEntryRelatedEntry.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCatalogEntryRelatedEntryList.InsertItem(index: Integer; value: TFhirCatalogEntryRelatedEntry);
begin
  assert(value is TFhirCatalogEntryRelatedEntry);
  Inherited Insert(index, value);
end;

function TFhirCatalogEntryRelatedEntryList.Item(index: Integer): TFhirCatalogEntryRelatedEntry;
begin
  result := TFhirCatalogEntryRelatedEntry(ObjectByIndex[index]);
end;

function TFhirCatalogEntryRelatedEntryList.Link: TFhirCatalogEntryRelatedEntryList;
begin
  result := TFhirCatalogEntryRelatedEntryList(inherited Link);
end;

procedure TFhirCatalogEntryRelatedEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCatalogEntryRelatedEntryList.SetItemByIndex(index: Integer; value: TFhirCatalogEntryRelatedEntry);
begin
  assert(value is TFhirCatalogEntryRelatedEntry);
  FhirCatalogEntryRelatedEntries[index] := value;
end;

procedure TFhirCatalogEntryRelatedEntryList.SetItemN(index: Integer; value: TFhirCatalogEntryRelatedEntry);
begin
  assert(value is TFhirCatalogEntryRelatedEntry);
  ObjectByIndex[index] := value;
end;

{ TFhirCatalogEntry }

constructor TFhirCatalogEntry.Create;
begin
  inherited;
end;

destructor TFhirCatalogEntry.Destroy;
begin
  FIdentifierList.free;
  FType_.free;
  FOrderable.free;
  FReferencedItem.free;
  FAdditionalIdentifierList.free;
  FClassificationList.free;
  FStatus.free;
  FValidityPeriod.free;
  FValidTo.free;
  FLastUpdated.free;
  FAdditionalCharacteristicList.free;
  FAdditionalClassificationList.free;
  FRelatedEntryList.free;
  inherited;
end;

function TFhirCatalogEntry.GetResourceType : TFhirResourceType;
begin
  result := frtCatalogEntry;
end;

procedure TFhirCatalogEntry.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCatalogEntry(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCatalogEntry(oSource).FIdentifierList);
  end;
  type_ := TFhirCatalogEntry(oSource).type_.Clone;
  orderableElement := TFhirCatalogEntry(oSource).orderableElement.Clone;
  referencedItem := TFhirCatalogEntry(oSource).referencedItem.Clone;
  if (TFhirCatalogEntry(oSource).FAdditionalIdentifierList = nil) then
  begin
    FAdditionalIdentifierList.free;
    FAdditionalIdentifierList := nil;
  end
  else
  begin
    if FAdditionalIdentifierList = nil then
      FAdditionalIdentifierList := TFhirIdentifierList.Create;
    FAdditionalIdentifierList.Assign(TFhirCatalogEntry(oSource).FAdditionalIdentifierList);
  end;
  if (TFhirCatalogEntry(oSource).FClassificationList = nil) then
  begin
    FClassificationList.free;
    FClassificationList := nil;
  end
  else
  begin
    if FClassificationList = nil then
      FClassificationList := TFhirCodeableConceptList.Create;
    FClassificationList.Assign(TFhirCatalogEntry(oSource).FClassificationList);
  end;
  FStatus := TFhirCatalogEntry(oSource).FStatus.Link;
  validityPeriod := TFhirCatalogEntry(oSource).validityPeriod.Clone;
  validToElement := TFhirCatalogEntry(oSource).validToElement.Clone;
  lastUpdatedElement := TFhirCatalogEntry(oSource).lastUpdatedElement.Clone;
  if (TFhirCatalogEntry(oSource).FAdditionalCharacteristicList = nil) then
  begin
    FAdditionalCharacteristicList.free;
    FAdditionalCharacteristicList := nil;
  end
  else
  begin
    if FAdditionalCharacteristicList = nil then
      FAdditionalCharacteristicList := TFhirCodeableConceptList.Create;
    FAdditionalCharacteristicList.Assign(TFhirCatalogEntry(oSource).FAdditionalCharacteristicList);
  end;
  if (TFhirCatalogEntry(oSource).FAdditionalClassificationList = nil) then
  begin
    FAdditionalClassificationList.free;
    FAdditionalClassificationList := nil;
  end
  else
  begin
    if FAdditionalClassificationList = nil then
      FAdditionalClassificationList := TFhirCodeableConceptList.Create;
    FAdditionalClassificationList.Assign(TFhirCatalogEntry(oSource).FAdditionalClassificationList);
  end;
  if (TFhirCatalogEntry(oSource).FRelatedEntryList = nil) then
  begin
    FRelatedEntryList.free;
    FRelatedEntryList := nil;
  end
  else
  begin
    if FRelatedEntryList = nil then
      FRelatedEntryList := TFhirCatalogEntryRelatedEntryList.Create;
    FRelatedEntryList.Assign(TFhirCatalogEntry(oSource).FRelatedEntryList);
  end;
end;

procedure TFhirCatalogEntry.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'orderable') Then
     list.add(self.link, 'orderable', FOrderable.Link);
  if (child_name = 'referencedItem') Then
     list.add(self.link, 'referencedItem', FReferencedItem.Link);
  if (child_name = 'additionalIdentifier') Then
    list.addAll(self, 'additionalIdentifier', FAdditionalIdentifierList);
  if (child_name = 'classification') Then
    list.addAll(self, 'classification', FClassificationList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'validityPeriod') Then
     list.add(self.link, 'validityPeriod', FValidityPeriod.Link);
  if (child_name = 'validTo') Then
     list.add(self.link, 'validTo', FValidTo.Link);
  if (child_name = 'lastUpdated') Then
     list.add(self.link, 'lastUpdated', FLastUpdated.Link);
  if (child_name = 'additionalCharacteristic') Then
    list.addAll(self, 'additionalCharacteristic', FAdditionalCharacteristicList);
  if (child_name = 'additionalClassification') Then
    list.addAll(self, 'additionalClassification', FAdditionalClassificationList);
  if (child_name = 'relatedEntry') Then
    list.addAll(self, 'relatedEntry', FRelatedEntryList);
end;

procedure TFhirCatalogEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'orderable', 'boolean', false, TFhirBoolean, FOrderable.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'referencedItem', 'Reference(Medication)', false, TFhirReference{TFhirMedication}, FReferencedItem.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'additionalIdentifier', 'Identifier', true, TFhirIdentifier, FAdditionalIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'classification', 'CodeableConcept', true, TFhirCodeableConcept, FClassificationList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'validityPeriod', 'Period', false, TFhirPeriod, FValidityPeriod.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'validTo', 'dateTime', false, TFhirDateTime, FValidTo.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'lastUpdated', 'dateTime', false, TFhirDateTime, FLastUpdated.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'additionalCharacteristic', 'CodeableConcept', true, TFhirCodeableConcept, FAdditionalCharacteristicList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'additionalClassification', 'CodeableConcept', true, TFhirCodeableConcept, FAdditionalClassificationList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'relatedEntry', '', true, TFhirCatalogEntryRelatedEntry, FRelatedEntryList.Link)){3};
end;

function TFhirCatalogEntry.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'orderable') then
  begin
    OrderableElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'referencedItem') then
  begin
    ReferencedItem := propValue as TFhirReference{TFhirMedication}{4b};
    result := propValue;
  end
  else if (propName = 'additionalIdentifier') then
  begin
    AdditionalIdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'classification') then
  begin
    ClassificationList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'validityPeriod') then
  begin
    ValidityPeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'validTo') then
  begin
    ValidToElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lastUpdated') then
  begin
    LastUpdatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'additionalCharacteristic') then
  begin
    AdditionalCharacteristicList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'additionalClassification') then
  begin
    AdditionalClassificationList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'relatedEntry') then
  begin
    RelatedEntryList.add(propValue as TFhirCatalogEntryRelatedEntry){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirCatalogEntry.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'additionalIdentifier') then AdditionalIdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'classification') then ClassificationList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'additionalCharacteristic') then AdditionalCharacteristicList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'additionalClassification') then AdditionalClassificationList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'relatedEntry') then RelatedEntryList.insertItem(index, propValue as TFhirCatalogEntryRelatedEntry){2a}
  else inherited;
end;

function TFhirCatalogEntry.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'orderable') then result := TFhirBoolean.Create() {5b}
  else if (propName = 'referencedItem') then result := TFhirReference{TFhirMedication}.Create(){4b}
  else if (propName = 'additionalIdentifier') then result := AdditionalIdentifierList.new(){2}
  else if (propName = 'classification') then result := ClassificationList.new(){2}
  else if (propName = 'validityPeriod') then result := TFhirPeriod.Create(){4b}
  else if (propName = 'validTo') then result := TFhirDateTime.Create() {5b}
  else if (propName = 'lastUpdated') then result := TFhirDateTime.Create() {5b}
  else if (propName = 'additionalCharacteristic') then result := AdditionalCharacteristicList.new(){2}
  else if (propName = 'additionalClassification') then result := AdditionalClassificationList.new(){2}
  else if (propName = 'relatedEntry') then result := RelatedEntryList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCatalogEntry.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'orderable') then result := 'boolean'
  else if (propName = 'referencedItem') then result := 'Reference'
  else if (propName = 'additionalIdentifier') then result := 'Identifier'
  else if (propName = 'classification') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'validityPeriod') then result := 'Period'
  else if (propName = 'validTo') then result := 'dateTime'
  else if (propName = 'lastUpdated') then result := 'dateTime'
  else if (propName = 'additionalCharacteristic') then result := 'CodeableConcept'
  else if (propName = 'additionalClassification') then result := 'CodeableConcept'
  else if (propName = 'relatedEntry') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCatalogEntry.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'orderable') then OrderableElement := nil
  else if (propName = 'referencedItem') then ReferencedItemElement := nil
  else if (propName = 'additionalIdentifier') then deletePropertyValue('additionalIdentifier', AdditionalIdentifierList, value) {2}
  else if (propName = 'classification') then deletePropertyValue('classification', ClassificationList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'validityPeriod') then ValidityPeriodElement := nil
  else if (propName = 'validTo') then ValidToElement := nil
  else if (propName = 'lastUpdated') then LastUpdatedElement := nil
  else if (propName = 'additionalCharacteristic') then deletePropertyValue('additionalCharacteristic', AdditionalCharacteristicList, value) {2}
  else if (propName = 'additionalClassification') then deletePropertyValue('additionalClassification', AdditionalClassificationList, value) {2}
  else if (propName = 'relatedEntry') then deletePropertyValue('relatedEntry', RelatedEntryList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCatalogEntry.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'orderable') then OrderableElement := asBoolean(new){5b}
  else if (propName = 'referencedItem') then ReferencedItemElement := new as TFhirReference{TFhirMedication}{4}
  else if (propName = 'additionalIdentifier') then replacePropertyValue('additionalIdentifier', AdditionalIdentifierList, existing, new) {2}
  else if (propName = 'classification') then replacePropertyValue('classification', ClassificationList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new){4}
  else if (propName = 'validityPeriod') then ValidityPeriodElement := new as TFhirPeriod{4}
  else if (propName = 'validTo') then ValidToElement := asDateTime(new){5b}
  else if (propName = 'lastUpdated') then LastUpdatedElement := asDateTime(new){5b}
  else if (propName = 'additionalCharacteristic') then replacePropertyValue('additionalCharacteristic', AdditionalCharacteristicList, existing, new) {2}
  else if (propName = 'additionalClassification') then replacePropertyValue('additionalClassification', AdditionalClassificationList, existing, new) {2}
  else if (propName = 'relatedEntry') then replacePropertyValue('relatedEntry', RelatedEntryList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCatalogEntry.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'additionalIdentifier') then AdditionalIdentifierList.move(source, destination){2a}
  else if (propName = 'classification') then ClassificationList.move(source, destination){2a}
  else if (propName = 'additionalCharacteristic') then AdditionalCharacteristicList.move(source, destination){2a}
  else if (propName = 'additionalClassification') then AdditionalClassificationList.move(source, destination){2a}
  else if (propName = 'relatedEntry') then RelatedEntryList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCatalogEntry.fhirType : string;
begin
  result := 'CatalogEntry';
end;

function TFhirCatalogEntry.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FOrderable) and isEmptyProp(FReferencedItem) and isEmptyProp(FadditionalIdentifierList) and isEmptyProp(FclassificationList) and isEmptyProp(FStatus) and isEmptyProp(FValidityPeriod) and isEmptyProp(FValidTo) and isEmptyProp(FLastUpdated) and isEmptyProp(FadditionalCharacteristicList) and isEmptyProp(FadditionalClassificationList) and isEmptyProp(FrelatedEntryList);
end;

function TFhirCatalogEntry.equals(other : TObject) : boolean; 
var
  o : TFhirCatalogEntry;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCatalogEntry)) then
    result := false
  else
  begin
    o := TFhirCatalogEntry(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(orderableElement, o.orderableElement, true) and compareDeep(referencedItemElement, o.referencedItemElement, true) and 
      compareDeep(additionalIdentifierList, o.additionalIdentifierList, true) and compareDeep(classificationList, o.classificationList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(validityPeriodElement, o.validityPeriodElement, true) and 
      compareDeep(validToElement, o.validToElement, true) and compareDeep(lastUpdatedElement, o.lastUpdatedElement, true) and 
      compareDeep(additionalCharacteristicList, o.additionalCharacteristicList, true) and 
      compareDeep(additionalClassificationList, o.additionalClassificationList, true) and 
      compareDeep(relatedEntryList, o.relatedEntryList, true);
  end;
end;

function TFhirCatalogEntry.Link : TFhirCatalogEntry;
begin
  result := TFhirCatalogEntry(inherited Link);
end;

function TFhirCatalogEntry.Clone : TFhirCatalogEntry;
begin
  result := TFhirCatalogEntry(inherited Clone);
end;

procedure TFhirCatalogEntry.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('orderable');
  fields.add('referencedItem');
  fields.add('additionalIdentifier');
  fields.add('classification');
  fields.add('status');
  fields.add('validityPeriod');
  fields.add('validTo');
  fields.add('lastUpdated');
  fields.add('additionalCharacteristic');
  fields.add('additionalClassification');
  fields.add('relatedEntry');
end;

{ TFhirCatalogEntry }

Function TFhirCatalogEntry.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirCatalogEntry.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirCatalogEntry.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirCatalogEntry.SetOrderable(value : TFhirBoolean);
begin
  FOrderable.free;
  FOrderable := value;
end;

Function TFhirCatalogEntry.GetOrderableST : Boolean;
begin
  if FOrderable = nil then
    result := false
  else
    result := FOrderable.value;
end;

Procedure TFhirCatalogEntry.SetOrderableST(value : Boolean);
begin
  if FOrderable = nil then
    FOrderable := TFhirBoolean.Create;
  FOrderable.value := value
end;

Procedure TFhirCatalogEntry.SetReferencedItem(value : TFhirReference{TFhirMedication});
begin
  FReferencedItem.free;
  FReferencedItem := value;
end;

Function TFhirCatalogEntry.GetAdditionalIdentifierList : TFhirIdentifierList;
begin
  if FAdditionalIdentifierList = nil then
    FAdditionalIdentifierList := TFhirIdentifierList.Create;
  result := FAdditionalIdentifierList;
end;

Function TFhirCatalogEntry.GetHasAdditionalIdentifierList : boolean;
begin
  result := (FAdditionalIdentifierList <> nil) and (FAdditionalIdentifierList.count > 0);
end;

Function TFhirCatalogEntry.GetClassificationList : TFhirCodeableConceptList;
begin
  if FClassificationList = nil then
    FClassificationList := TFhirCodeableConceptList.Create;
  result := FClassificationList;
end;

Function TFhirCatalogEntry.GetHasClassificationList : boolean;
begin
  result := (FClassificationList <> nil) and (FClassificationList.count > 0);
end;

Procedure TFhirCatalogEntry.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirCatalogEntry.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

Procedure TFhirCatalogEntry.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.Create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

Procedure TFhirCatalogEntry.SetValidityPeriod(value : TFhirPeriod);
begin
  FValidityPeriod.free;
  FValidityPeriod := value;
end;

Procedure TFhirCatalogEntry.SetValidTo(value : TFhirDateTime);
begin
  FValidTo.free;
  FValidTo := value;
end;

Function TFhirCatalogEntry.GetValidToST : TFslDateTime;
begin
  if FValidTo = nil then
    result := TFslDateTime.makeNull
  else
    result := FValidTo.value;
end;

Procedure TFhirCatalogEntry.SetValidToST(value : TFslDateTime);
begin
  if FValidTo = nil then
    FValidTo := TFhirDateTime.Create;
  FValidTo.value := value
end;

Procedure TFhirCatalogEntry.SetLastUpdated(value : TFhirDateTime);
begin
  FLastUpdated.free;
  FLastUpdated := value;
end;

Function TFhirCatalogEntry.GetLastUpdatedST : TFslDateTime;
begin
  if FLastUpdated = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastUpdated.value;
end;

Procedure TFhirCatalogEntry.SetLastUpdatedST(value : TFslDateTime);
begin
  if FLastUpdated = nil then
    FLastUpdated := TFhirDateTime.Create;
  FLastUpdated.value := value
end;

Function TFhirCatalogEntry.GetAdditionalCharacteristicList : TFhirCodeableConceptList;
begin
  if FAdditionalCharacteristicList = nil then
    FAdditionalCharacteristicList := TFhirCodeableConceptList.Create;
  result := FAdditionalCharacteristicList;
end;

Function TFhirCatalogEntry.GetHasAdditionalCharacteristicList : boolean;
begin
  result := (FAdditionalCharacteristicList <> nil) and (FAdditionalCharacteristicList.count > 0);
end;

Function TFhirCatalogEntry.GetAdditionalClassificationList : TFhirCodeableConceptList;
begin
  if FAdditionalClassificationList = nil then
    FAdditionalClassificationList := TFhirCodeableConceptList.Create;
  result := FAdditionalClassificationList;
end;

Function TFhirCatalogEntry.GetHasAdditionalClassificationList : boolean;
begin
  result := (FAdditionalClassificationList <> nil) and (FAdditionalClassificationList.count > 0);
end;

Function TFhirCatalogEntry.GetRelatedEntryList : TFhirCatalogEntryRelatedEntryList;
begin
  if FRelatedEntryList = nil then
    FRelatedEntryList := TFhirCatalogEntryRelatedEntryList.Create;
  result := FRelatedEntryList;
end;

Function TFhirCatalogEntry.GetHasRelatedEntryList : boolean;
begin
  result := (FRelatedEntryList <> nil) and (FRelatedEntryList.count > 0);
end;

function TFhirCatalogEntry.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FidentifierList.sizeInBytes(magic));
  inc(result, FType_.sizeInBytes(magic));
  inc(result, FOrderable.sizeInBytes(magic));
  inc(result, FReferencedItem.sizeInBytes(magic));
  inc(result, FadditionalIdentifierList.sizeInBytes(magic));
  inc(result, FclassificationList.sizeInBytes(magic));
  inc(result, FStatus.sizeInBytes(magic));
  inc(result, FValidityPeriod.sizeInBytes(magic));
  inc(result, FValidTo.sizeInBytes(magic));
  inc(result, FLastUpdated.sizeInBytes(magic));
  inc(result, FadditionalCharacteristicList.sizeInBytes(magic));
  inc(result, FadditionalClassificationList.sizeInBytes(magic));
  inc(result, FrelatedEntryList.sizeInBytes(magic));
end;

{ TFhirCatalogEntryListEnumerator }

Constructor TFhirCatalogEntryListEnumerator.Create(list : TFhirCatalogEntryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCatalogEntryListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirCatalogEntryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCatalogEntryListEnumerator.GetCurrent : TFhirCatalogEntry;
begin
  Result := FList[FIndex];
end;

function TFhirCatalogEntryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCatalogEntryList }
function TFhirCatalogEntryList.AddItem(value: TFhirCatalogEntry): TFhirCatalogEntry;
begin
  add(value);
  result := value;
end;

function TFhirCatalogEntryList.Append: TFhirCatalogEntry;
begin
  result := TFhirCatalogEntry.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCatalogEntryList.ClearItems;
begin
  Clear;
end;

function TFhirCatalogEntryList.GetEnumerator : TFhirCatalogEntryListEnumerator;
begin
  result := TFhirCatalogEntryListEnumerator.Create(self.link);
end;

function TFhirCatalogEntryList.Clone: TFhirCatalogEntryList;
begin
  result := TFhirCatalogEntryList(inherited Clone);
end;

function TFhirCatalogEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCatalogEntryList.GetItemN(index: Integer): TFhirCatalogEntry;
begin
  result := TFhirCatalogEntry(ObjectByIndex[index]);
end;

function TFhirCatalogEntryList.ItemClass: TFslObjectClass;
begin
  result := TFhirCatalogEntry;
end;
function TFhirCatalogEntryList.IndexOf(value: TFhirCatalogEntry): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCatalogEntryList.Insert(index: Integer): TFhirCatalogEntry;
begin
  result := TFhirCatalogEntry.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCatalogEntryList.InsertItem(index: Integer; value: TFhirCatalogEntry);
begin
  assert(value is TFhirCatalogEntry);
  Inherited Insert(index, value);
end;

function TFhirCatalogEntryList.Item(index: Integer): TFhirCatalogEntry;
begin
  result := TFhirCatalogEntry(ObjectByIndex[index]);
end;

function TFhirCatalogEntryList.Link: TFhirCatalogEntryList;
begin
  result := TFhirCatalogEntryList(inherited Link);
end;

procedure TFhirCatalogEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCatalogEntryList.SetItemByIndex(index: Integer; value: TFhirCatalogEntry);
begin
  assert(value is TFhirCatalogEntry);
  FhirCatalogEntries[index] := value;
end;

procedure TFhirCatalogEntryList.SetItemN(index: Integer; value: TFhirCatalogEntry);
begin
  assert(value is TFhirCatalogEntry);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CATALOGENTRY}

{$IFDEF FHIR_DEVICE}

{ TFhirDeviceUdiCarrier }

constructor TFhirDeviceUdiCarrier.Create;
begin
  inherited;
end;

destructor TFhirDeviceUdiCarrier.Destroy;
begin
  FDeviceIdentifier.free;
  FIssuer.free;
  FJurisdiction.free;
  FCarrierAIDC.free;
  FCarrierHRF.free;
  FEntryType.free;
  inherited;
end;

procedure TFhirDeviceUdiCarrier.Assign(oSource : TFslObject);
begin
  inherited;
  deviceIdentifierElement := TFhirDeviceUdiCarrier(oSource).deviceIdentifierElement.Clone;
  issuerElement := TFhirDeviceUdiCarrier(oSource).issuerElement.Clone;
  jurisdictionElement := TFhirDeviceUdiCarrier(oSource).jurisdictionElement.Clone;
  carrierAIDCElement := TFhirDeviceUdiCarrier(oSource).carrierAIDCElement.Clone;
  carrierHRFElement := TFhirDeviceUdiCarrier(oSource).carrierHRFElement.Clone;
  FEntryType := TFhirDeviceUdiCarrier(oSource).FEntryType.Link;
end;

procedure TFhirDeviceUdiCarrier.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'deviceIdentifier') Then
     list.add(self.link, 'deviceIdentifier', FDeviceIdentifier.Link);
  if (child_name = 'issuer') Then
     list.add(self.link, 'issuer', FIssuer.Link);
  if (child_name = 'jurisdiction') Then
     list.add(self.link, 'jurisdiction', FJurisdiction.Link);
  if (child_name = 'carrierAIDC') Then
     list.add(self.link, 'carrierAIDC', FCarrierAIDC.Link);
  if (child_name = 'carrierHRF') Then
     list.add(self.link, 'carrierHRF', FCarrierHRF.Link);
  if (child_name = 'entryType') Then
     list.add(self.link, 'entryType', FEntryType.Link);
end;

procedure TFhirDeviceUdiCarrier.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'deviceIdentifier', 'string', false, TFhirString, FDeviceIdentifier.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'issuer', 'uri', false, TFhirUri, FIssuer.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'jurisdiction', 'uri', false, TFhirUri, FJurisdiction.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'carrierAIDC', 'base64Binary', false, TFhirBase64Binary, FCarrierAIDC.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'carrierHRF', 'string', false, TFhirString, FCarrierHRF.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'entryType', 'code', false, TFHIREnum, FEntryType.Link));{1}
end;

function TFhirDeviceUdiCarrier.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'deviceIdentifier') then
  begin
    DeviceIdentifierElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'issuer') then
  begin
    IssuerElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'carrierAIDC') then
  begin
    CarrierAIDCElement := asBase64Binary(propValue){5a};
    result := propValue;
  end
  else if (propName = 'carrierHRF') then
  begin
    CarrierHRFElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'entryType') then
  begin
    EntryTypeElement := asEnum(SYSTEMS_TFhirUdiEntryTypeEnum, CODES_TFhirUdiEntryTypeEnum, propValue);
    result := propValue
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceUdiCarrier.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceUdiCarrier.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'deviceIdentifier') then result := TFhirString.Create() {5b}
  else if (propName = 'issuer') then result := TFhirUri.Create() {5b}
  else if (propName = 'jurisdiction') then result := TFhirUri.Create() {5b}
  else if (propName = 'carrierAIDC') then result := TFhirBase64Binary.Create() {5b}
  else if (propName = 'carrierHRF') then result := TFhirString.Create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceUdiCarrier.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'deviceIdentifier') then result := 'string'
  else if (propName = 'issuer') then result := 'uri'
  else if (propName = 'jurisdiction') then result := 'uri'
  else if (propName = 'carrierAIDC') then result := 'base64Binary'
  else if (propName = 'carrierHRF') then result := 'string'
  else if (propName = 'entryType') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceUdiCarrier.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'deviceIdentifier') then DeviceIdentifierElement := nil
  else if (propName = 'issuer') then IssuerElement := nil
  else if (propName = 'jurisdiction') then JurisdictionElement := nil
  else if (propName = 'carrierAIDC') then CarrierAIDCElement := nil
  else if (propName = 'carrierHRF') then CarrierHRFElement := nil
  else if (propName = 'entryType') then EntryTypeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceUdiCarrier.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'deviceIdentifier') then DeviceIdentifierElement := asString(new){5b}
  else if (propName = 'issuer') then IssuerElement := asUri(new){5b}
  else if (propName = 'jurisdiction') then JurisdictionElement := asUri(new){5b}
  else if (propName = 'carrierAIDC') then CarrierAIDCElement := asBase64Binary(new){5b}
  else if (propName = 'carrierHRF') then CarrierHRFElement := asString(new){5b}
  else if (propName = 'entryType') then EntryTypeElement := asEnum(SYSTEMS_TFhirUdiEntryTypeEnum, CODES_TFhirUdiEntryTypeEnum, new){4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceUdiCarrier.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceUdiCarrier.fhirType : string;
begin
  result := 'udiCarrier';
end;

function TFhirDeviceUdiCarrier.Link : TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier(inherited Link);
end;

function TFhirDeviceUdiCarrier.Clone : TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier(inherited Clone);
end;

function TFhirDeviceUdiCarrier.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceUdiCarrier;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceUdiCarrier)) then
    result := false
  else
  begin
    o := TFhirDeviceUdiCarrier(other);
    result := compareDeep(deviceIdentifierElement, o.deviceIdentifierElement, true) and 
      compareDeep(issuerElement, o.issuerElement, true) and compareDeep(jurisdictionElement, o.jurisdictionElement, true) and 
      compareDeep(carrierAIDCElement, o.carrierAIDCElement, true) and compareDeep(carrierHRFElement, o.carrierHRFElement, true) and 
      compareDeep(entryTypeElement, o.entryTypeElement, true);
  end;
end;

function TFhirDeviceUdiCarrier.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDeviceIdentifier) and isEmptyProp(FIssuer) and isEmptyProp(FJurisdiction) and isEmptyProp(FCarrierAIDC) and isEmptyProp(FCarrierHRF) and isEmptyProp(FEntryType);
end;

procedure TFhirDeviceUdiCarrier.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('deviceIdentifier');
  fields.add('issuer');
  fields.add('jurisdiction');
  fields.add('carrierAIDC');
  fields.add('carrierHRF');
  fields.add('entryType');
end;

{ TFhirDeviceUdiCarrier }

Procedure TFhirDeviceUdiCarrier.SetDeviceIdentifier(value : TFhirString);
begin
  FDeviceIdentifier.free;
  FDeviceIdentifier := value;
end;

Function TFhirDeviceUdiCarrier.GetDeviceIdentifierST : String;
begin
  if FDeviceIdentifier = nil then
    result := ''
  else
    result := FDeviceIdentifier.value;
end;

Procedure TFhirDeviceUdiCarrier.SetDeviceIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FDeviceIdentifier = nil then
      FDeviceIdentifier := TFhirString.Create;
    FDeviceIdentifier.value := value
  end
  else if FDeviceIdentifier <> nil then
    FDeviceIdentifier.value := '';
end;

Procedure TFhirDeviceUdiCarrier.SetIssuer(value : TFhirUri);
begin
  FIssuer.free;
  FIssuer := value;
end;

Function TFhirDeviceUdiCarrier.GetIssuerST : String;
begin
  if FIssuer = nil then
    result := ''
  else
    result := FIssuer.value;
end;

Procedure TFhirDeviceUdiCarrier.SetIssuerST(value : String);
begin
  if value <> '' then
  begin
    if FIssuer = nil then
      FIssuer := TFhirUri.Create;
    FIssuer.value := value
  end
  else if FIssuer <> nil then
    FIssuer.value := '';
end;

Procedure TFhirDeviceUdiCarrier.SetJurisdiction(value : TFhirUri);
begin
  FJurisdiction.free;
  FJurisdiction := value;
end;

Function TFhirDeviceUdiCarrier.GetJurisdictionST : String;
begin
  if FJurisdiction = nil then
    result := ''
  else
    result := FJurisdiction.value;
end;

Procedure TFhirDeviceUdiCarrier.SetJurisdictionST(value : String);
begin
  if value <> '' then
  begin
    if FJurisdiction = nil then
      FJurisdiction := TFhirUri.Create;
    FJurisdiction.value := value
  end
  else if FJurisdiction <> nil then
    FJurisdiction.value := '';
end;

Procedure TFhirDeviceUdiCarrier.SetCarrierAIDC(value : TFhirBase64Binary);
begin
  FCarrierAIDC.free;
  FCarrierAIDC := value;
end;

Function TFhirDeviceUdiCarrier.GetCarrierAIDCST : TBytes;
begin
  if FCarrierAIDC = nil then
    result := nil
  else
    result := FCarrierAIDC.value;
end;

Procedure TFhirDeviceUdiCarrier.SetCarrierAIDCST(value : TBytes);
begin
  if value <> nil then
  begin
    if FCarrierAIDC = nil then
      FCarrierAIDC := TFhirBase64Binary.Create;
    FCarrierAIDC.value := value
  end
  else if FCarrierAIDC <> nil then
    FCarrierAIDC.value := nil;
end;

Procedure TFhirDeviceUdiCarrier.SetCarrierHRF(value : TFhirString);
begin
  FCarrierHRF.free;
  FCarrierHRF := value;
end;

Function TFhirDeviceUdiCarrier.GetCarrierHRFST : String;
begin
  if FCarrierHRF = nil then
    result := ''
  else
    result := FCarrierHRF.value;
end;

Procedure TFhirDeviceUdiCarrier.SetCarrierHRFST(value : String);
begin
  if value <> '' then
  begin
    if FCarrierHRF = nil then
      FCarrierHRF := TFhirString.Create;
    FCarrierHRF.value := value
  end
  else if FCarrierHRF <> nil then
    FCarrierHRF.value := '';
end;

Procedure TFhirDeviceUdiCarrier.SetEntryType(value : TFhirEnum);
begin
  FEntryType.free;
  FEntryType := value;
end;

Function TFhirDeviceUdiCarrier.GetEntryTypeST : TFhirUdiEntryTypeEnum;
begin
  if FEntryType = nil then
    result := TFhirUdiEntryTypeEnum(0)
  else
    result := TFhirUdiEntryTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirUdiEntryTypeEnum, FEntryType.value));
end;

Procedure TFhirDeviceUdiCarrier.SetEntryTypeST(value : TFhirUdiEntryTypeEnum);
begin
  if ord(value) = 0 then
    EntryTypeElement := nil
  else
    EntryTypeElement := TFhirEnum.Create(SYSTEMS_TFhirUdiEntryTypeEnum[value], CODES_TFhirUdiEntryTypeEnum[value]);
end;

function TFhirDeviceUdiCarrier.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FDeviceIdentifier.sizeInBytes(magic));
  inc(result, FIssuer.sizeInBytes(magic));
  inc(result, FJurisdiction.sizeInBytes(magic));
  inc(result, FCarrierAIDC.sizeInBytes(magic));
  inc(result, FCarrierHRF.sizeInBytes(magic));
  inc(result, FEntryType.sizeInBytes(magic));
end;

{ TFhirDeviceUdiCarrierListEnumerator }

Constructor TFhirDeviceUdiCarrierListEnumerator.Create(list : TFhirDeviceUdiCarrierList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceUdiCarrierListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceUdiCarrierListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceUdiCarrierListEnumerator.GetCurrent : TFhirDeviceUdiCarrier;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceUdiCarrierListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceUdiCarrierList }
function TFhirDeviceUdiCarrierList.AddItem(value: TFhirDeviceUdiCarrier): TFhirDeviceUdiCarrier;
begin
  add(value);
  result := value;
end;

function TFhirDeviceUdiCarrierList.Append: TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceUdiCarrierList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceUdiCarrierList.GetEnumerator : TFhirDeviceUdiCarrierListEnumerator;
begin
  result := TFhirDeviceUdiCarrierListEnumerator.Create(self.link);
end;

function TFhirDeviceUdiCarrierList.Clone: TFhirDeviceUdiCarrierList;
begin
  result := TFhirDeviceUdiCarrierList(inherited Clone);
end;

function TFhirDeviceUdiCarrierList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceUdiCarrierList.GetItemN(index: Integer): TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier(ObjectByIndex[index]);
end;

function TFhirDeviceUdiCarrierList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceUdiCarrier;
end;
function TFhirDeviceUdiCarrierList.IndexOf(value: TFhirDeviceUdiCarrier): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceUdiCarrierList.Insert(index: Integer): TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceUdiCarrierList.InsertItem(index: Integer; value: TFhirDeviceUdiCarrier);
begin
  assert(value is TFhirDeviceUdiCarrier);
  Inherited Insert(index, value);
end;

function TFhirDeviceUdiCarrierList.Item(index: Integer): TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier(ObjectByIndex[index]);
end;

function TFhirDeviceUdiCarrierList.Link: TFhirDeviceUdiCarrierList;
begin
  result := TFhirDeviceUdiCarrierList(inherited Link);
end;

procedure TFhirDeviceUdiCarrierList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceUdiCarrierList.SetItemByIndex(index: Integer; value: TFhirDeviceUdiCarrier);
begin
  assert(value is TFhirDeviceUdiCarrier);
  FhirDeviceUdiCarriers[index] := value;
end;

procedure TFhirDeviceUdiCarrierList.SetItemN(index: Integer; value: TFhirDeviceUdiCarrier);
begin
  assert(value is TFhirDeviceUdiCarrier);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDeviceName }

constructor TFhirDeviceDeviceName.Create;
begin
  inherited;
end;

destructor TFhirDeviceDeviceName.Destroy;
begin
  FName.free;
  FType_.free;
  inherited;
end;

procedure TFhirDeviceDeviceName.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirDeviceDeviceName(oSource).nameElement.Clone;
  FType_ := TFhirDeviceDeviceName(oSource).FType_.Link;
end;

procedure TFhirDeviceDeviceName.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirDeviceDeviceName.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
end;

function TFhirDeviceDeviceName.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirDeviceNametypeEnum, CODES_TFhirDeviceNametypeEnum, propValue);
    result := propValue
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDeviceName.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDeviceName.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.Create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDeviceName.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDeviceName.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDeviceName.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirDeviceNametypeEnum, CODES_TFhirDeviceNametypeEnum, new){4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDeviceName.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDeviceName.fhirType : string;
begin
  result := 'deviceName';
end;

function TFhirDeviceDeviceName.Link : TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName(inherited Link);
end;

function TFhirDeviceDeviceName.Clone : TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName(inherited Clone);
end;

function TFhirDeviceDeviceName.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDeviceName;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDeviceName)) then
    result := false
  else
  begin
    o := TFhirDeviceDeviceName(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirDeviceDeviceName.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FType_);
end;

procedure TFhirDeviceDeviceName.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('type');
end;

{ TFhirDeviceDeviceName }

Procedure TFhirDeviceDeviceName.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirDeviceDeviceName.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirDeviceDeviceName.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.Create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirDeviceDeviceName.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirDeviceDeviceName.GetType_ST : TFhirDeviceNametypeEnum;
begin
  if FType_ = nil then
    result := TFhirDeviceNametypeEnum(0)
  else
    result := TFhirDeviceNametypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceNametypeEnum, FType_.value));
end;

Procedure TFhirDeviceDeviceName.SetType_ST(value : TFhirDeviceNametypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.Create(SYSTEMS_TFhirDeviceNametypeEnum[value], CODES_TFhirDeviceNametypeEnum[value]);
end;

function TFhirDeviceDeviceName.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FName.sizeInBytes(magic));
  inc(result, FType_.sizeInBytes(magic));
end;

{ TFhirDeviceDeviceNameListEnumerator }

Constructor TFhirDeviceDeviceNameListEnumerator.Create(list : TFhirDeviceDeviceNameList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDeviceNameListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceDeviceNameListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDeviceNameListEnumerator.GetCurrent : TFhirDeviceDeviceName;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDeviceNameListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDeviceNameList }
function TFhirDeviceDeviceNameList.AddItem(value: TFhirDeviceDeviceName): TFhirDeviceDeviceName;
begin
  add(value);
  result := value;
end;

function TFhirDeviceDeviceNameList.Append: TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDeviceNameList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDeviceNameList.GetEnumerator : TFhirDeviceDeviceNameListEnumerator;
begin
  result := TFhirDeviceDeviceNameListEnumerator.Create(self.link);
end;

function TFhirDeviceDeviceNameList.Clone: TFhirDeviceDeviceNameList;
begin
  result := TFhirDeviceDeviceNameList(inherited Clone);
end;

function TFhirDeviceDeviceNameList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDeviceNameList.GetItemN(index: Integer): TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName(ObjectByIndex[index]);
end;

function TFhirDeviceDeviceNameList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDeviceName;
end;
function TFhirDeviceDeviceNameList.IndexOf(value: TFhirDeviceDeviceName): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDeviceNameList.Insert(index: Integer): TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDeviceNameList.InsertItem(index: Integer; value: TFhirDeviceDeviceName);
begin
  assert(value is TFhirDeviceDeviceName);
  Inherited Insert(index, value);
end;

function TFhirDeviceDeviceNameList.Item(index: Integer): TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName(ObjectByIndex[index]);
end;

function TFhirDeviceDeviceNameList.Link: TFhirDeviceDeviceNameList;
begin
  result := TFhirDeviceDeviceNameList(inherited Link);
end;

procedure TFhirDeviceDeviceNameList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDeviceNameList.SetItemByIndex(index: Integer; value: TFhirDeviceDeviceName);
begin
  assert(value is TFhirDeviceDeviceName);
  FhirDeviceDeviceNames[index] := value;
end;

procedure TFhirDeviceDeviceNameList.SetItemN(index: Integer; value: TFhirDeviceDeviceName);
begin
  assert(value is TFhirDeviceDeviceName);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceSpecialization }

constructor TFhirDeviceSpecialization.Create;
begin
  inherited;
end;

destructor TFhirDeviceSpecialization.Destroy;
begin
  FSystemType.free;
  FVersion.free;
  inherited;
end;

procedure TFhirDeviceSpecialization.Assign(oSource : TFslObject);
begin
  inherited;
  systemType := TFhirDeviceSpecialization(oSource).systemType.Clone;
  versionElement := TFhirDeviceSpecialization(oSource).versionElement.Clone;
end;

procedure TFhirDeviceSpecialization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'systemType') Then
     list.add(self.link, 'systemType', FSystemType.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
end;

procedure TFhirDeviceSpecialization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'systemType', 'CodeableConcept', false, TFhirCodeableConcept, FSystemType.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
end;

function TFhirDeviceSpecialization.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'systemType') then
  begin
    SystemType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceSpecialization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceSpecialization.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'systemType') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'version') then result := TFhirString.Create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceSpecialization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'systemType') then result := 'CodeableConcept'
  else if (propName = 'version') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceSpecialization.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'systemType') then SystemTypeElement := nil
  else if (propName = 'version') then VersionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceSpecialization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'systemType') then SystemTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceSpecialization.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceSpecialization.fhirType : string;
begin
  result := 'specialization';
end;

function TFhirDeviceSpecialization.Link : TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization(inherited Link);
end;

function TFhirDeviceSpecialization.Clone : TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization(inherited Clone);
end;

function TFhirDeviceSpecialization.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceSpecialization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceSpecialization)) then
    result := false
  else
  begin
    o := TFhirDeviceSpecialization(other);
    result := compareDeep(systemTypeElement, o.systemTypeElement, true) and compareDeep(versionElement, o.versionElement, true);
  end;
end;

function TFhirDeviceSpecialization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSystemType) and isEmptyProp(FVersion);
end;

procedure TFhirDeviceSpecialization.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('systemType');
  fields.add('version');
end;

{ TFhirDeviceSpecialization }

Procedure TFhirDeviceSpecialization.SetSystemType(value : TFhirCodeableConcept);
begin
  FSystemType.free;
  FSystemType := value;
end;

Procedure TFhirDeviceSpecialization.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirDeviceSpecialization.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirDeviceSpecialization.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.Create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

function TFhirDeviceSpecialization.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FSystemType.sizeInBytes(magic));
  inc(result, FVersion.sizeInBytes(magic));
end;

{ TFhirDeviceSpecializationListEnumerator }

Constructor TFhirDeviceSpecializationListEnumerator.Create(list : TFhirDeviceSpecializationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceSpecializationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceSpecializationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceSpecializationListEnumerator.GetCurrent : TFhirDeviceSpecialization;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceSpecializationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceSpecializationList }
function TFhirDeviceSpecializationList.AddItem(value: TFhirDeviceSpecialization): TFhirDeviceSpecialization;
begin
  add(value);
  result := value;
end;

function TFhirDeviceSpecializationList.Append: TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceSpecializationList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceSpecializationList.GetEnumerator : TFhirDeviceSpecializationListEnumerator;
begin
  result := TFhirDeviceSpecializationListEnumerator.Create(self.link);
end;

function TFhirDeviceSpecializationList.Clone: TFhirDeviceSpecializationList;
begin
  result := TFhirDeviceSpecializationList(inherited Clone);
end;

function TFhirDeviceSpecializationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceSpecializationList.GetItemN(index: Integer): TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization(ObjectByIndex[index]);
end;

function TFhirDeviceSpecializationList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceSpecialization;
end;
function TFhirDeviceSpecializationList.IndexOf(value: TFhirDeviceSpecialization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceSpecializationList.Insert(index: Integer): TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceSpecializationList.InsertItem(index: Integer; value: TFhirDeviceSpecialization);
begin
  assert(value is TFhirDeviceSpecialization);
  Inherited Insert(index, value);
end;

function TFhirDeviceSpecializationList.Item(index: Integer): TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization(ObjectByIndex[index]);
end;

function TFhirDeviceSpecializationList.Link: TFhirDeviceSpecializationList;
begin
  result := TFhirDeviceSpecializationList(inherited Link);
end;

procedure TFhirDeviceSpecializationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceSpecializationList.SetItemByIndex(index: Integer; value: TFhirDeviceSpecialization);
begin
  assert(value is TFhirDeviceSpecialization);
  FhirDeviceSpecializations[index] := value;
end;

procedure TFhirDeviceSpecializationList.SetItemN(index: Integer; value: TFhirDeviceSpecialization);
begin
  assert(value is TFhirDeviceSpecialization);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceVersion }

constructor TFhirDeviceVersion.Create;
begin
  inherited;
end;

destructor TFhirDeviceVersion.Destroy;
begin
  FType_.free;
  FComponent.free;
  FValue.free;
  inherited;
end;

procedure TFhirDeviceVersion.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirDeviceVersion(oSource).type_.Clone;
  component := TFhirDeviceVersion(oSource).component.Clone;
  valueElement := TFhirDeviceVersion(oSource).valueElement.Clone;
end;

procedure TFhirDeviceVersion.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'component') Then
     list.add(self.link, 'component', FComponent.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirDeviceVersion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'component', 'Identifier', false, TFhirIdentifier, FComponent.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'value', 'string', false, TFhirString, FValue.Link));{2}
end;

function TFhirDeviceVersion.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'component') then
  begin
    Component := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceVersion.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceVersion.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'component') then result := TFhirIdentifier.Create(){4b}
  else if (propName = 'value') then result := TFhirString.Create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceVersion.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'component') then result := 'Identifier'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceVersion.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'component') then ComponentElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceVersion.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'component') then ComponentElement := new as TFhirIdentifier{4}
  else if (propName = 'value') then ValueElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceVersion.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceVersion.fhirType : string;
begin
  result := 'version';
end;

function TFhirDeviceVersion.Link : TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion(inherited Link);
end;

function TFhirDeviceVersion.Clone : TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion(inherited Clone);
end;

function TFhirDeviceVersion.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceVersion;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceVersion)) then
    result := false
  else
  begin
    o := TFhirDeviceVersion(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(componentElement, o.componentElement, true) and 
      compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirDeviceVersion.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FComponent) and isEmptyProp(FValue);
end;

procedure TFhirDeviceVersion.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('component');
  fields.add('value');
end;

{ TFhirDeviceVersion }

Procedure TFhirDeviceVersion.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirDeviceVersion.SetComponent(value : TFhirIdentifier);
begin
  FComponent.free;
  FComponent := value;
end;

Procedure TFhirDeviceVersion.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirDeviceVersion.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirDeviceVersion.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.Create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirDeviceVersion.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FType_.sizeInBytes(magic));
  inc(result, FComponent.sizeInBytes(magic));
  inc(result, FValue.sizeInBytes(magic));
end;

{ TFhirDeviceVersionListEnumerator }

Constructor TFhirDeviceVersionListEnumerator.Create(list : TFhirDeviceVersionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceVersionListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceVersionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceVersionListEnumerator.GetCurrent : TFhirDeviceVersion;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceVersionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceVersionList }
function TFhirDeviceVersionList.AddItem(value: TFhirDeviceVersion): TFhirDeviceVersion;
begin
  add(value);
  result := value;
end;

function TFhirDeviceVersionList.Append: TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceVersionList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceVersionList.GetEnumerator : TFhirDeviceVersionListEnumerator;
begin
  result := TFhirDeviceVersionListEnumerator.Create(self.link);
end;

function TFhirDeviceVersionList.Clone: TFhirDeviceVersionList;
begin
  result := TFhirDeviceVersionList(inherited Clone);
end;

function TFhirDeviceVersionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceVersionList.GetItemN(index: Integer): TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion(ObjectByIndex[index]);
end;

function TFhirDeviceVersionList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceVersion;
end;
function TFhirDeviceVersionList.IndexOf(value: TFhirDeviceVersion): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceVersionList.Insert(index: Integer): TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceVersionList.InsertItem(index: Integer; value: TFhirDeviceVersion);
begin
  assert(value is TFhirDeviceVersion);
  Inherited Insert(index, value);
end;

function TFhirDeviceVersionList.Item(index: Integer): TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion(ObjectByIndex[index]);
end;

function TFhirDeviceVersionList.Link: TFhirDeviceVersionList;
begin
  result := TFhirDeviceVersionList(inherited Link);
end;

procedure TFhirDeviceVersionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceVersionList.SetItemByIndex(index: Integer; value: TFhirDeviceVersion);
begin
  assert(value is TFhirDeviceVersion);
  FhirDeviceVersions[index] := value;
end;

procedure TFhirDeviceVersionList.SetItemN(index: Integer; value: TFhirDeviceVersion);
begin
  assert(value is TFhirDeviceVersion);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceProperty }

constructor TFhirDeviceProperty.Create;
begin
  inherited;
end;

destructor TFhirDeviceProperty.Destroy;
begin
  FType_.free;
  FValueQuantityList.free;
  FValueCodeList.free;
  inherited;
end;

procedure TFhirDeviceProperty.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirDeviceProperty(oSource).type_.Clone;
  if (TFhirDeviceProperty(oSource).FValueQuantityList = nil) then
  begin
    FValueQuantityList.free;
    FValueQuantityList := nil;
  end
  else
  begin
    if FValueQuantityList = nil then
      FValueQuantityList := TFhirQuantityList.Create;
    FValueQuantityList.Assign(TFhirDeviceProperty(oSource).FValueQuantityList);
  end;
  if (TFhirDeviceProperty(oSource).FValueCodeList = nil) then
  begin
    FValueCodeList.free;
    FValueCodeList := nil;
  end
  else
  begin
    if FValueCodeList = nil then
      FValueCodeList := TFhirCodeableConceptList.Create;
    FValueCodeList.Assign(TFhirDeviceProperty(oSource).FValueCodeList);
  end;
end;

procedure TFhirDeviceProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'valueQuantity') Then
    list.addAll(self, 'valueQuantity', FValueQuantityList);
  if (child_name = 'valueCode') Then
    list.addAll(self, 'valueCode', FValueCodeList);
end;

procedure TFhirDeviceProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'valueQuantity', 'Quantity', true, TFhirQuantity, FValueQuantityList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'valueCode', 'CodeableConcept', true, TFhirCodeableConcept, FValueCodeList.Link)){3};
end;

function TFhirDeviceProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'valueQuantity') then
  begin
    ValueQuantityList.add(propValue as TFhirQuantity){2a};
    result := propValue;
  end
  else if (propName = 'valueCode') then
  begin
    ValueCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'valueQuantity') then ValueQuantityList.insertItem(index, propValue as TFhirQuantity){2a}
  else if (propName = 'valueCode') then ValueCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirDeviceProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'valueQuantity') then result := ValueQuantityList.new(){2}
  else if (propName = 'valueCode') then result := ValueCodeList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'valueQuantity') then result := 'Quantity'
  else if (propName = 'valueCode') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'valueQuantity') then deletePropertyValue('valueQuantity', ValueQuantityList, value) {2}
  else if (propName = 'valueCode') then deletePropertyValue('valueCode', ValueCodeList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'valueQuantity') then replacePropertyValue('valueQuantity', ValueQuantityList, existing, new) {2}
  else if (propName = 'valueCode') then replacePropertyValue('valueCode', ValueCodeList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceProperty.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'valueQuantity') then ValueQuantityList.move(source, destination){2a}
  else if (propName = 'valueCode') then ValueCodeList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceProperty.fhirType : string;
begin
  result := 'property';
end;

function TFhirDeviceProperty.Link : TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty(inherited Link);
end;

function TFhirDeviceProperty.Clone : TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty(inherited Clone);
end;

function TFhirDeviceProperty.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceProperty)) then
    result := false
  else
  begin
    o := TFhirDeviceProperty(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueQuantityList, o.valueQuantityList, true) and 
      compareDeep(valueCodeList, o.valueCodeList, true);
  end;
end;

function TFhirDeviceProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FvalueQuantityList) and isEmptyProp(FvalueCodeList);
end;

procedure TFhirDeviceProperty.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('valueQuantity');
  fields.add('valueCode');
end;

{ TFhirDeviceProperty }

Procedure TFhirDeviceProperty.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirDeviceProperty.GetValueQuantityList : TFhirQuantityList;
begin
  if FValueQuantityList = nil then
    FValueQuantityList := TFhirQuantityList.Create;
  result := FValueQuantityList;
end;

Function TFhirDeviceProperty.GetHasValueQuantityList : boolean;
begin
  result := (FValueQuantityList <> nil) and (FValueQuantityList.count > 0);
end;

Function TFhirDeviceProperty.GetValueCodeList : TFhirCodeableConceptList;
begin
  if FValueCodeList = nil then
    FValueCodeList := TFhirCodeableConceptList.Create;
  result := FValueCodeList;
end;

Function TFhirDeviceProperty.GetHasValueCodeList : boolean;
begin
  result := (FValueCodeList <> nil) and (FValueCodeList.count > 0);
end;

function TFhirDeviceProperty.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FType_.sizeInBytes(magic));
  inc(result, FvalueQuantityList.sizeInBytes(magic));
  inc(result, FvalueCodeList.sizeInBytes(magic));
end;

{ TFhirDevicePropertyListEnumerator }

Constructor TFhirDevicePropertyListEnumerator.Create(list : TFhirDevicePropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDevicePropertyListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDevicePropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDevicePropertyListEnumerator.GetCurrent : TFhirDeviceProperty;
begin
  Result := FList[FIndex];
end;

function TFhirDevicePropertyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDevicePropertyList }
function TFhirDevicePropertyList.AddItem(value: TFhirDeviceProperty): TFhirDeviceProperty;
begin
  add(value);
  result := value;
end;

function TFhirDevicePropertyList.Append: TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDevicePropertyList.ClearItems;
begin
  Clear;
end;

function TFhirDevicePropertyList.GetEnumerator : TFhirDevicePropertyListEnumerator;
begin
  result := TFhirDevicePropertyListEnumerator.Create(self.link);
end;

function TFhirDevicePropertyList.Clone: TFhirDevicePropertyList;
begin
  result := TFhirDevicePropertyList(inherited Clone);
end;

function TFhirDevicePropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDevicePropertyList.GetItemN(index: Integer): TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty(ObjectByIndex[index]);
end;

function TFhirDevicePropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceProperty;
end;
function TFhirDevicePropertyList.IndexOf(value: TFhirDeviceProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDevicePropertyList.Insert(index: Integer): TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDevicePropertyList.InsertItem(index: Integer; value: TFhirDeviceProperty);
begin
  assert(value is TFhirDeviceProperty);
  Inherited Insert(index, value);
end;

function TFhirDevicePropertyList.Item(index: Integer): TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty(ObjectByIndex[index]);
end;

function TFhirDevicePropertyList.Link: TFhirDevicePropertyList;
begin
  result := TFhirDevicePropertyList(inherited Link);
end;

procedure TFhirDevicePropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDevicePropertyList.SetItemByIndex(index: Integer; value: TFhirDeviceProperty);
begin
  assert(value is TFhirDeviceProperty);
  FhirDeviceProperties[index] := value;
end;

procedure TFhirDevicePropertyList.SetItemN(index: Integer; value: TFhirDeviceProperty);
begin
  assert(value is TFhirDeviceProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirDevice }

constructor TFhirDevice.Create;
begin
  inherited;
end;

destructor TFhirDevice.Destroy;
begin
  FIdentifierList.free;
  FDefinition.free;
  FUdiCarrierList.free;
  FStatus.free;
  FStatusReasonList.free;
  FDistinctIdentifier.free;
  FManufacturer.free;
  FManufactureDate.free;
  FExpirationDate.free;
  FLotNumber.free;
  FSerialNumber.free;
  FDeviceNameList.free;
  FModelNumber.free;
  FPartNumber.free;
  FType_.free;
  FSpecializationList.free;
  FVersionList.free;
  FProperty_List.free;
  FPatient.free;
  FOwner.free;
  FContactList.free;
  FLocation.free;
  FUrl.free;
  FNoteList.free;
  FSafetyList.free;
  FParent.free;
  inherited;
end;

function TFhirDevice.GetResourceType : TFhirResourceType;
begin
  result := frtDevice;
end;

procedure TFhirDevice.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDevice(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDevice(oSource).FIdentifierList);
  end;
  definition := TFhirDevice(oSource).definition.Clone;
  if (TFhirDevice(oSource).FUdiCarrierList = nil) then
  begin
    FUdiCarrierList.free;
    FUdiCarrierList := nil;
  end
  else
  begin
    if FUdiCarrierList = nil then
      FUdiCarrierList := TFhirDeviceUdiCarrierList.Create;
    FUdiCarrierList.Assign(TFhirDevice(oSource).FUdiCarrierList);
  end;
  FStatus := TFhirDevice(oSource).FStatus.Link;
  if (TFhirDevice(oSource).FStatusReasonList = nil) then
  begin
    FStatusReasonList.free;
    FStatusReasonList := nil;
  end
  else
  begin
    if FStatusReasonList = nil then
      FStatusReasonList := TFhirCodeableConceptList.Create;
    FStatusReasonList.Assign(TFhirDevice(oSource).FStatusReasonList);
  end;
  distinctIdentifierElement := TFhirDevice(oSource).distinctIdentifierElement.Clone;
  manufacturerElement := TFhirDevice(oSource).manufacturerElement.Clone;
  manufactureDateElement := TFhirDevice(oSource).manufactureDateElement.Clone;
  expirationDateElement := TFhirDevice(oSource).expirationDateElement.Clone;
  lotNumberElement := TFhirDevice(oSource).lotNumberElement.Clone;
  serialNumberElement := TFhirDevice(oSource).serialNumberElement.Clone;
  if (TFhirDevice(oSource).FDeviceNameList = nil) then
  begin
    FDeviceNameList.free;
    FDeviceNameList := nil;
  end
  else
  begin
    if FDeviceNameList = nil then
      FDeviceNameList := TFhirDeviceDeviceNameList.Create;
    FDeviceNameList.Assign(TFhirDevice(oSource).FDeviceNameList);
  end;
  modelNumberElement := TFhirDevice(oSource).modelNumberElement.Clone;
  partNumberElement := TFhirDevice(oSource).partNumberElement.Clone;
  type_ := TFhirDevice(oSource).type_.Clone;
  if (TFhirDevice(oSource).FSpecializationList = nil) then
  begin
    FSpecializationList.free;
    FSpecializationList := nil;
  end
  else
  begin
    if FSpecializationList = nil then
      FSpecializationList := TFhirDeviceSpecializationList.Create;
    FSpecializationList.Assign(TFhirDevice(oSource).FSpecializationList);
  end;
  if (TFhirDevice(oSource).FVersionList = nil) then
  begin
    FVersionList.free;
    FVersionList := nil;
  end
  else
  begin
    if FVersionList = nil then
      FVersionList := TFhirDeviceVersionList.Create;
    FVersionList.Assign(TFhirDevice(oSource).FVersionList);
  end;
  if (TFhirDevice(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirDevicePropertyList.Create;
    FProperty_List.Assign(TFhirDevice(oSource).FProperty_List);
  end;
  patient := TFhirDevice(oSource).patient.Clone;
  owner := TFhirDevice(oSource).owner.Clone;
  if (TFhirDevice(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactPointList.Create;
    FContactList.Assign(TFhirDevice(oSource).FContactList);
  end;
  location := TFhirDevice(oSource).location.Clone;
  urlElement := TFhirDevice(oSource).urlElement.Clone;
  if (TFhirDevice(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirDevice(oSource).FNoteList);
  end;
  if (TFhirDevice(oSource).FSafetyList = nil) then
  begin
    FSafetyList.free;
    FSafetyList := nil;
  end
  else
  begin
    if FSafetyList = nil then
      FSafetyList := TFhirCodeableConceptList.Create;
    FSafetyList.Assign(TFhirDevice(oSource).FSafetyList);
  end;
  parent := TFhirDevice(oSource).parent.Clone;
end;

procedure TFhirDevice.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'udiCarrier') Then
    list.addAll(self, 'udiCarrier', FUdiCarrierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
    list.addAll(self, 'statusReason', FStatusReasonList);
  if (child_name = 'distinctIdentifier') Then
     list.add(self.link, 'distinctIdentifier', FDistinctIdentifier.Link);
  if (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer', FManufacturer.Link);
  if (child_name = 'manufactureDate') Then
     list.add(self.link, 'manufactureDate', FManufactureDate.Link);
  if (child_name = 'expirationDate') Then
     list.add(self.link, 'expirationDate', FExpirationDate.Link);
  if (child_name = 'lotNumber') Then
     list.add(self.link, 'lotNumber', FLotNumber.Link);
  if (child_name = 'serialNumber') Then
     list.add(self.link, 'serialNumber', FSerialNumber.Link);
  if (child_name = 'deviceName') Then
    list.addAll(self, 'deviceName', FDeviceNameList);
  if (child_name = 'modelNumber') Then
     list.add(self.link, 'modelNumber', FModelNumber.Link);
  if (child_name = 'partNumber') Then
     list.add(self.link, 'partNumber', FPartNumber.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'specialization') Then
    list.addAll(self, 'specialization', FSpecializationList);
  if (child_name = 'version') Then
    list.addAll(self, 'version', FVersionList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'owner') Then
     list.add(self.link, 'owner', FOwner.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'safety') Then
    list.addAll(self, 'safety', FSafetyList);
  if (child_name = 'parent') Then
     list.add(self.link, 'parent', FParent.Link);
end;

procedure TFhirDevice.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'definition', 'Reference(DeviceDefinition)', false, TFhirReference{TFhirDeviceDefinition}, FDefinition.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'udiCarrier', '', true, TFhirDeviceUdiCarrier, FUdiCarrierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'statusReason', 'CodeableConcept', true, TFhirCodeableConcept, FStatusReasonList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'distinctIdentifier', 'string', false, TFhirString, FDistinctIdentifier.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'manufacturer', 'string', false, TFhirString, FManufacturer.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'manufactureDate', 'dateTime', false, TFhirDateTime, FManufactureDate.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'expirationDate', 'dateTime', false, TFhirDateTime, FExpirationDate.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'lotNumber', 'string', false, TFhirString, FLotNumber.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'serialNumber', 'string', false, TFhirString, FSerialNumber.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'deviceName', '', true, TFhirDeviceDeviceName, FDeviceNameList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'modelNumber', 'string', false, TFhirString, FModelNumber.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'partNumber', 'string', false, TFhirString, FPartNumber.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'specialization', '', true, TFhirDeviceSpecialization, FSpecializationList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'version', '', true, TFhirDeviceVersion, FVersionList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'property', '', true, TFhirDeviceProperty, FProperty_List.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'owner', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOwner.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'contact', 'ContactPoint', true, TFhirContactPoint, FContactList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'location', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FLocation.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'safety', 'CodeableConcept', true, TFhirCodeableConcept, FSafetyList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'parent', 'Reference(Device)', false, TFhirReference{TFhirDevice}, FParent.Link));{2}
end;

function TFhirDevice.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    Definition := propValue as TFhirReference{TFhirDeviceDefinition}{4b};
    result := propValue;
  end
  else if (propName = 'udiCarrier') then
  begin
    UdiCarrierList.add(propValue as TFhirDeviceUdiCarrier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirDeviceStatusEnum, CODES_TFhirDeviceStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'statusReason') then
  begin
    StatusReasonList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'distinctIdentifier') then
  begin
    DistinctIdentifierElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'manufactureDate') then
  begin
    ManufactureDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'expirationDate') then
  begin
    ExpirationDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lotNumber') then
  begin
    LotNumberElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'serialNumber') then
  begin
    SerialNumberElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'deviceName') then
  begin
    DeviceNameList.add(propValue as TFhirDeviceDeviceName){2a};
    result := propValue;
  end
  else if (propName = 'modelNumber') then
  begin
    ModelNumberElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'partNumber') then
  begin
    PartNumberElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'specialization') then
  begin
    SpecializationList.add(propValue as TFhirDeviceSpecialization){2a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionList.add(propValue as TFhirDeviceVersion){2a};
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirDeviceProperty){2a};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'owner') then
  begin
    Owner := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'safety') then
  begin
    SafetyList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    Parent := propValue as TFhirReference{TFhirDevice}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirDevice.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'udiCarrier') then UdiCarrierList.insertItem(index, propValue as TFhirDeviceUdiCarrier){2a}
  else if (propName = 'statusReason') then StatusReasonList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'deviceName') then DeviceNameList.insertItem(index, propValue as TFhirDeviceDeviceName){2a}
  else if (propName = 'specialization') then SpecializationList.insertItem(index, propValue as TFhirDeviceSpecialization){2a}
  else if (propName = 'version') then VersionList.insertItem(index, propValue as TFhirDeviceVersion){2a}
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirDeviceProperty){2a}
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactPoint){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'safety') then SafetyList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirDevice.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'definition') then result := TFhirReference{TFhirDeviceDefinition}.Create(){4b}
  else if (propName = 'udiCarrier') then result := UdiCarrierList.new(){2}
  else if (propName = 'statusReason') then result := StatusReasonList.new(){2}
  else if (propName = 'distinctIdentifier') then result := TFhirString.Create() {5b}
  else if (propName = 'manufacturer') then result := TFhirString.Create() {5b}
  else if (propName = 'manufactureDate') then result := TFhirDateTime.Create() {5b}
  else if (propName = 'expirationDate') then result := TFhirDateTime.Create() {5b}
  else if (propName = 'lotNumber') then result := TFhirString.Create() {5b}
  else if (propName = 'serialNumber') then result := TFhirString.Create() {5b}
  else if (propName = 'deviceName') then result := DeviceNameList.new(){2}
  else if (propName = 'modelNumber') then result := TFhirString.Create() {5b}
  else if (propName = 'partNumber') then result := TFhirString.Create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'specialization') then result := SpecializationList.new(){2}
  else if (propName = 'version') then result := VersionList.new(){2}
  else if (propName = 'property') then result := Property_List.new(){2}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.Create(){4b}
  else if (propName = 'owner') then result := TFhirReference{TFhirOrganization}.Create(){4b}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'location') then result := TFhirReference{TFhirLocation}.Create(){4b}
  else if (propName = 'url') then result := TFhirUri.Create() {5b}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'safety') then result := SafetyList.new(){2}
  else if (propName = 'parent') then result := TFhirReference{TFhirDevice}.Create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDevice.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'definition') then result := 'Reference'
  else if (propName = 'udiCarrier') then result := ''
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'distinctIdentifier') then result := 'string'
  else if (propName = 'manufacturer') then result := 'string'
  else if (propName = 'manufactureDate') then result := 'dateTime'
  else if (propName = 'expirationDate') then result := 'dateTime'
  else if (propName = 'lotNumber') then result := 'string'
  else if (propName = 'serialNumber') then result := 'string'
  else if (propName = 'deviceName') then result := ''
  else if (propName = 'modelNumber') then result := 'string'
  else if (propName = 'partNumber') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'specialization') then result := ''
  else if (propName = 'version') then result := ''
  else if (propName = 'property') then result := ''
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'owner') then result := 'Reference'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'safety') then result := 'CodeableConcept'
  else if (propName = 'parent') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDevice.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'udiCarrier') then deletePropertyValue('udiCarrier', UdiCarrierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then deletePropertyValue('statusReason', StatusReasonList, value) {2}
  else if (propName = 'distinctIdentifier') then DistinctIdentifierElement := nil
  else if (propName = 'manufacturer') then ManufacturerElement := nil
  else if (propName = 'manufactureDate') then ManufactureDateElement := nil
  else if (propName = 'expirationDate') then ExpirationDateElement := nil
  else if (propName = 'lotNumber') then LotNumberElement := nil
  else if (propName = 'serialNumber') then SerialNumberElement := nil
  else if (propName = 'deviceName') then deletePropertyValue('deviceName', DeviceNameList, value) {2}
  else if (propName = 'modelNumber') then ModelNumberElement := nil
  else if (propName = 'partNumber') then PartNumberElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'specialization') then deletePropertyValue('specialization', SpecializationList, value) {2}
  else if (propName = 'version') then deletePropertyValue('version', VersionList, value) {2}
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value) {2}
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'owner') then OwnerElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'safety') then deletePropertyValue('safety', SafetyList, value) {2}
  else if (propName = 'parent') then ParentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDevice.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'definition') then DefinitionElement := new as TFhirReference{TFhirDeviceDefinition}{4}
  else if (propName = 'udiCarrier') then replacePropertyValue('udiCarrier', UdiCarrierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirDeviceStatusEnum, CODES_TFhirDeviceStatusEnum, new){4}
  else if (propName = 'statusReason') then replacePropertyValue('statusReason', StatusReasonList, existing, new) {2}
  else if (propName = 'distinctIdentifier') then DistinctIdentifierElement := asString(new){5b}
  else if (propName = 'manufacturer') then ManufacturerElement := asString(new){5b}
  else if (propName = 'manufactureDate') then ManufactureDateElement := asDateTime(new){5b}
  else if (propName = 'expirationDate') then ExpirationDateElement := asDateTime(new){5b}
  else if (propName = 'lotNumber') then LotNumberElement := asString(new){5b}
  else if (propName = 'serialNumber') then SerialNumberElement := asString(new){5b}
  else if (propName = 'deviceName') then replacePropertyValue('deviceName', DeviceNameList, existing, new) {2}
  else if (propName = 'modelNumber') then ModelNumberElement := asString(new){5b}
  else if (propName = 'partNumber') then PartNumberElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'specialization') then replacePropertyValue('specialization', SpecializationList, existing, new) {2}
  else if (propName = 'version') then replacePropertyValue('version', VersionList, existing, new) {2}
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new) {2}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'owner') then OwnerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'location') then LocationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'safety') then replacePropertyValue('safety', SafetyList, existing, new) {2}
  else if (propName = 'parent') then ParentElement := new as TFhirReference{TFhirDevice}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDevice.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'udiCarrier') then UdiCarrierList.move(source, destination){2a}
  else if (propName = 'statusReason') then StatusReasonList.move(source, destination){2a}
  else if (propName = 'deviceName') then DeviceNameList.move(source, destination){2a}
  else if (propName = 'specialization') then SpecializationList.move(source, destination){2a}
  else if (propName = 'version') then VersionList.move(source, destination){2a}
  else if (propName = 'property') then Property_List.move(source, destination){2a}
  else if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'safety') then SafetyList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDevice.fhirType : string;
begin
  result := 'Device';
end;

function TFhirDevice.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FDefinition) and isEmptyProp(FudiCarrierList) and isEmptyProp(FStatus) and isEmptyProp(FstatusReasonList) and isEmptyProp(FDistinctIdentifier) and isEmptyProp(FManufacturer) and isEmptyProp(FManufactureDate) and isEmptyProp(FExpirationDate) and isEmptyProp(FLotNumber) and isEmptyProp(FSerialNumber) and isEmptyProp(FdeviceNameList) and isEmptyProp(FModelNumber) and isEmptyProp(FPartNumber) and isEmptyProp(FType_) and isEmptyProp(FspecializationList) and isEmptyProp(FversionList) and isEmptyProp(Fproperty_List) and isEmptyProp(FPatient) and isEmptyProp(FOwner) and isEmptyProp(FcontactList) and isEmptyProp(FLocation) and isEmptyProp(FUrl) and isEmptyProp(FnoteList) and isEmptyProp(FsafetyList) and isEmptyProp(FParent);
end;

function TFhirDevice.equals(other : TObject) : boolean; 
var
  o : TFhirDevice;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDevice)) then
    result := false
  else
  begin
    o := TFhirDevice(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(definitionElement, o.definitionElement, true) and 
      compareDeep(udiCarrierList, o.udiCarrierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusReasonList, o.statusReasonList, true) and compareDeep(distinctIdentifierElement, o.distinctIdentifierElement, true) and 
      compareDeep(manufacturerElement, o.manufacturerElement, true) and compareDeep(manufactureDateElement, o.manufactureDateElement, true) and 
      compareDeep(expirationDateElement, o.expirationDateElement, true) and compareDeep(lotNumberElement, o.lotNumberElement, true) and 
      compareDeep(serialNumberElement, o.serialNumberElement, true) and compareDeep(deviceNameList, o.deviceNameList, true) and 
      compareDeep(modelNumberElement, o.modelNumberElement, true) and compareDeep(partNumberElement, o.partNumberElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(specializationList, o.specializationList, true) and 
      compareDeep(versionList, o.versionList, true) and compareDeep(property_List, o.property_List, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(ownerElement, o.ownerElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(urlElement, o.urlElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(safetyList, o.safetyList, true) and compareDeep(parentElement, o.parentElement, true);
  end;
end;

function TFhirDevice.Link : TFhirDevice;
begin
  result := TFhirDevice(inherited Link);
end;

function TFhirDevice.Clone : TFhirDevice;
begin
  result := TFhirDevice(inherited Clone);
end;

procedure TFhirDevice.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('definition');
  fields.add('udiCarrier');
  fields.add('status');
  fields.add('statusReason');
  fields.add('distinctIdentifier');
  fields.add('manufacturer');
  fields.add('manufactureDate');
  fields.add('expirationDate');
  fields.add('lotNumber');
  fields.add('serialNumber');
  fields.add('deviceName');
  fields.add('modelNumber');
  fields.add('partNumber');
  fields.add('type');
  fields.add('specialization');
  fields.add('version');
  fields.add('property');
  fields.add('patient');
  fields.add('owner');
  fields.add('contact');
  fields.add('location');
  fields.add('url');
  fields.add('note');
  fields.add('safety');
  fields.add('parent');
end;

{ TFhirDevice }

Function TFhirDevice.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirDevice.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirDevice.SetDefinition(value : TFhirReference{TFhirDeviceDefinition});
begin
  FDefinition.free;
  FDefinition := value;
end;

Function TFhirDevice.GetUdiCarrierList : TFhirDeviceUdiCarrierList;
begin
  if FUdiCarrierList = nil then
    FUdiCarrierList := TFhirDeviceUdiCarrierList.Create;
  result := FUdiCarrierList;
end;

Function TFhirDevice.GetHasUdiCarrierList : boolean;
begin
  result := (FUdiCarrierList <> nil) and (FUdiCarrierList.count > 0);
end;

Procedure TFhirDevice.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDevice.GetStatusST : TFhirDeviceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirDeviceStatusEnum(0)
  else
    result := TFhirDeviceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceStatusEnum, FStatus.value));
end;

Procedure TFhirDevice.SetStatusST(value : TFhirDeviceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.Create(SYSTEMS_TFhirDeviceStatusEnum[value], CODES_TFhirDeviceStatusEnum[value]);
end;

Function TFhirDevice.GetStatusReasonList : TFhirCodeableConceptList;
begin
  if FStatusReasonList = nil then
    FStatusReasonList := TFhirCodeableConceptList.Create;
  result := FStatusReasonList;
end;

Function TFhirDevice.GetHasStatusReasonList : boolean;
begin
  result := (FStatusReasonList <> nil) and (FStatusReasonList.count > 0);
end;

Procedure TFhirDevice.SetDistinctIdentifier(value : TFhirString);
begin
  FDistinctIdentifier.free;
  FDistinctIdentifier := value;
end;

Function TFhirDevice.GetDistinctIdentifierST : String;
begin
  if FDistinctIdentifier = nil then
    result := ''
  else
    result := FDistinctIdentifier.value;
end;

Procedure TFhirDevice.SetDistinctIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FDistinctIdentifier = nil then
      FDistinctIdentifier := TFhirString.Create;
    FDistinctIdentifier.value := value
  end
  else if FDistinctIdentifier <> nil then
    FDistinctIdentifier.value := '';
end;

Procedure TFhirDevice.SetManufacturer(value : TFhirString);
begin
  FManufacturer.free;
  FManufacturer := value;
end;

Function TFhirDevice.GetManufacturerST : String;
begin
  if FManufacturer = nil then
    result := ''
  else
    result := FManufacturer.value;
end;

Procedure TFhirDevice.SetManufacturerST(value : String);
begin
  if value <> '' then
  begin
    if FManufacturer = nil then
      FManufacturer := TFhirString.Create;
    FManufacturer.value := value
  end
  else if FManufacturer <> nil then
    FManufacturer.value := '';
end;

Procedure TFhirDevice.SetManufactureDate(value : TFhirDateTime);
begin
  FManufactureDate.free;
  FManufactureDate := value;
end;

Function TFhirDevice.GetManufactureDateST : TFslDateTime;
begin
  if FManufactureDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FManufactureDate.value;
end;

Procedure TFhirDevice.SetManufactureDateST(value : TFslDateTime);
begin
  if FManufactureDate = nil then
    FManufactureDate := TFhirDateTime.Create;
  FManufactureDate.value := value
end;

Procedure TFhirDevice.SetExpirationDate(value : TFhirDateTime);
begin
  FExpirationDate.free;
  FExpirationDate := value;
end;

Function TFhirDevice.GetExpirationDateST : TFslDateTime;
begin
  if FExpirationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpirationDate.value;
end;

Procedure TFhirDevice.SetExpirationDateST(value : TFslDateTime);
begin
  if FExpirationDate = nil then
    FExpirationDate := TFhirDateTime.Create;
  FExpirationDate.value := value
end;

Procedure TFhirDevice.SetLotNumber(value : TFhirString);
begin
  FLotNumber.free;
  FLotNumber := value;
end;

Function TFhirDevice.GetLotNumberST : String;
begin
  if FLotNumber = nil then
    result := ''
  else
    result := FLotNumber.value;
end;

Procedure TFhirDevice.SetLotNumberST(value : String);
begin
  if value <> '' then
  begin
    if FLotNumber = nil then
      FLotNumber := TFhirString.Create;
    FLotNumber.value := value
  end
  else if FLotNumber <> nil then
    FLotNumber.value := '';
end;

Procedure TFhirDevice.SetSerialNumber(value : TFhirString);
begin
  FSerialNumber.free;
  FSerialNumber := value;
end;

Function TFhirDevice.GetSerialNumberST : String;
begin
  if FSerialNumber = nil then
    result := ''
  else
    result := FSerialNumber.value;
end;

Procedure TFhirDevice.SetSerialNumberST(value : String);
begin
  if value <> '' then
  begin
    if FSerialNumber = nil then
      FSerialNumber := TFhirString.Create;
    FSerialNumber.value := value
  end
  else if FSerialNumber <> nil then
    FSerialNumber.value := '';
end;

Function TFhirDevice.GetDeviceNameList : TFhirDeviceDeviceNameList;
begin
  if FDeviceNameList = nil then
    FDeviceNameList := TFhirDeviceDeviceNameList.Create;
  result := FDeviceNameList;
end;

Function TFhirDevice.GetHasDeviceNameList : boolean;
begin
  result := (FDeviceNameList <> nil) and (FDeviceNameList.count > 0);
end;

Procedure TFhirDevice.SetModelNumber(value : TFhirString);
begin
  FModelNumber.free;
  FModelNumber := value;
end;

Function TFhirDevice.GetModelNumberST : String;
begin
  if FModelNumber = nil then
    result := ''
  else
    result := FModelNumber.value;
end;

Procedure TFhirDevice.SetModelNumberST(value : String);
begin
  if value <> '' then
  begin
    if FModelNumber = nil then
      FModelNumber := TFhirString.Create;
    FModelNumber.value := value
  end
  else if FModelNumber <> nil then
    FModelNumber.value := '';
end;

Procedure TFhirDevice.SetPartNumber(value : TFhirString);
begin
  FPartNumber.free;
  FPartNumber := value;
end;

Function TFhirDevice.GetPartNumberST : String;
begin
  if FPartNumber = nil then
    result := ''
  else
    result := FPartNumber.value;
end;

Procedure TFhirDevice.SetPartNumberST(value : String);
begin
  if value <> '' then
  begin
    if FPartNumber = nil then
      FPartNumber := TFhirString.Create;
    FPartNumber.value := value
  end
  else if FPartNumber <> nil then
    FPartNumber.value := '';
end;

Procedure TFhirDevice.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirDevice.GetSpecializationList : TFhirDeviceSpecializationList;
begin
  if FSpecializationList = nil then
    FSpecializationList := TFhirDeviceSpecializationList.Create;
  result := FSpecializationList;
end;

Function TFhirDevice.GetHasSpecializationList : boolean;
begin
  result := (FSpecializationList <> nil) and (FSpecializationList.count > 0);
end;

Function TFhirDevice.GetVersionList : TFhirDeviceVersionList;
begin
  if FVersionList = nil then
    FVersionList := TFhirDeviceVersionList.Create;
  result := FVersionList;
end;

Function TFhirDevice.GetHasVersionList : boolean;
begin
  result := (FVersionList <> nil) and (FVersionList.count > 0);
end;

Function TFhirDevice.GetProperty_List : TFhirDevicePropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirDevicePropertyList.Create;
  result := FProperty_List;
end;

Function TFhirDevice.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

Procedure TFhirDevice.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirDevice.SetOwner(value : TFhirReference{TFhirOrganization});
begin
  FOwner.free;
  FOwner := value;
end;

Function TFhirDevice.GetContactList : TFhirContactPointList;
begin
  if FContactList = nil then
    FContactList := TFhirContactPointList.Create;
  result := FContactList;
end;

Function TFhirDevice.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Procedure TFhirDevice.SetLocation(value : TFhirReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Procedure TFhirDevice.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirDevice.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirDevice.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.Create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Function TFhirDevice.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirDevice.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirDevice.GetSafetyList : TFhirCodeableConceptList;
begin
  if FSafetyList = nil then
    FSafetyList := TFhirCodeableConceptList.Create;
  result := FSafetyList;
end;

Function TFhirDevice.GetHasSafetyList : boolean;
begin
  result := (FSafetyList <> nil) and (FSafetyList.count > 0);
end;

Procedure TFhirDevice.SetParent(value : TFhirReference{TFhirDevice});
begin
  FParent.free;
  FParent := value;
end;

function TFhirDevice.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FidentifierList.sizeInBytes(magic));
  inc(result, FDefinition.sizeInBytes(magic));
  inc(result, FudiCarrierList.sizeInBytes(magic));
  inc(result, FStatus.sizeInBytes(magic));
  inc(result, FstatusReasonList.sizeInBytes(magic));
  inc(result, FDistinctIdentifier.sizeInBytes(magic));
  inc(result, FManufacturer.sizeInBytes(magic));
  inc(result, FManufactureDate.sizeInBytes(magic));
  inc(result, FExpirationDate.sizeInBytes(magic));
  inc(result, FLotNumber.sizeInBytes(magic));
  inc(result, FSerialNumber.sizeInBytes(magic));
  inc(result, FdeviceNameList.sizeInBytes(magic));
  inc(result, FModelNumber.sizeInBytes(magic));
  inc(result, FPartNumber.sizeInBytes(magic));
  inc(result, FType_.sizeInBytes(magic));
  inc(result, FspecializationList.sizeInBytes(magic));
  inc(result, FversionList.sizeInBytes(magic));
  inc(result, Fproperty_List.sizeInBytes(magic));
  inc(result, FPatient.sizeInBytes(magic));
  inc(result, FOwner.sizeInBytes(magic));
  inc(result, FcontactList.sizeInBytes(magic));
  inc(result, FLocation.sizeInBytes(magic));
  inc(result, FUrl.sizeInBytes(magic));
  inc(result, FnoteList.sizeInBytes(magic));
  inc(result, FsafetyList.sizeInBytes(magic));
end;

{ TFhirDeviceListEnumerator }

Constructor TFhirDeviceListEnumerator.Create(list : TFhirDeviceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceListEnumerator.GetCurrent : TFhirDevice;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceList }
function TFhirDeviceList.AddItem(value: TFhirDevice): TFhirDevice;
begin
  add(value);
  result := value;
end;

function TFhirDeviceList.Append: TFhirDevice;
begin
  result := TFhirDevice.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceList.GetEnumerator : TFhirDeviceListEnumerator;
begin
  result := TFhirDeviceListEnumerator.Create(self.link);
end;

function TFhirDeviceList.Clone: TFhirDeviceList;
begin
  result := TFhirDeviceList(inherited Clone);
end;

function TFhirDeviceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceList.GetItemN(index: Integer): TFhirDevice;
begin
  result := TFhirDevice(ObjectByIndex[index]);
end;

function TFhirDeviceList.ItemClass: TFslObjectClass;
begin
  result := TFhirDevice;
end;
function TFhirDeviceList.IndexOf(value: TFhirDevice): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceList.Insert(index: Integer): TFhirDevice;
begin
  result := TFhirDevice.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceList.InsertItem(index: Integer; value: TFhirDevice);
begin
  assert(value is TFhirDevice);
  Inherited Insert(index, value);
end;

function TFhirDeviceList.Item(index: Integer): TFhirDevice;
begin
  result := TFhirDevice(ObjectByIndex[index]);
end;

function TFhirDeviceList.Link: TFhirDeviceList;
begin
  result := TFhirDeviceList(inherited Link);
end;

procedure TFhirDeviceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceList.SetItemByIndex(index: Integer; value: TFhirDevice);
begin
  assert(value is TFhirDevice);
  FhirDevices[index] := value;
end;

procedure TFhirDeviceList.SetItemN(index: Integer; value: TFhirDevice);
begin
  assert(value is TFhirDevice);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DEVICE}

{$IFDEF FHIR_DEVICEMETRIC}

{ TFhirDeviceMetricCalibration }

constructor TFhirDeviceMetricCalibration.Create;
begin
  inherited;
end;

destructor TFhirDeviceMetricCalibration.Destroy;
begin
  FType_.free;
  FState.free;
  FTime.free;
  inherited;
end;

procedure TFhirDeviceMetricCalibration.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirDeviceMetricCalibration(oSource).FType_.Link;
  FState := TFhirDeviceMetricCalibration(oSource).FState.Link;
  timeElement := TFhirDeviceMetricCalibration(oSource).timeElement.Clone;
end;

procedure TFhirDeviceMetricCalibration.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'state') Then
     list.add(self.link, 'state', FState.Link);
  if (child_name = 'time') Then
     list.add(self.link, 'time', FTime.Link);
end;

procedure TFhirDeviceMetricCalibration.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'state', 'code', false, TFHIREnum, FState.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'time', 'instant', false, TFhirInstant, FTime.Link));{2}
end;

function TFhirDeviceMetricCalibration.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirMetricCalibrationTypeEnum, CODES_TFhirMetricCalibrationTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'state') then
  begin
    StateElement := asEnum(SYSTEMS_TFhirMetricCalibrationStateEnum, CODES_TFhirMetricCalibrationStateEnum, propValue);
    result := propValue
  end
  else if (propName = 'time') then
  begin
    TimeElement := asInstant(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceMetricCalibration.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceMetricCalibration.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'time') then result := TFhirInstant.Create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceMetricCalibration.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'state') then result := 'code'
  else if (propName = 'time') then result := 'instant'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceMetricCalibration.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'state') then StateElement := nil
  else if (propName = 'time') then TimeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceMetricCalibration.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirMetricCalibrationTypeEnum, CODES_TFhirMetricCalibrationTypeEnum, new){4}
  else if (propName = 'state') then StateElement := asEnum(SYSTEMS_TFhirMetricCalibrationStateEnum, CODES_TFhirMetricCalibrationStateEnum, new){4}
  else if (propName = 'time') then TimeElement := asInstant(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceMetricCalibration.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceMetricCalibration.fhirType : string;
begin
  result := 'calibration';
end;

function TFhirDeviceMetricCalibration.Link : TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration(inherited Link);
end;

function TFhirDeviceMetricCalibration.Clone : TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration(inherited Clone);
end;

function TFhirDeviceMetricCalibration.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceMetricCalibration;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceMetricCalibration)) then
    result := false
  else
  begin
    o := TFhirDeviceMetricCalibration(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(stateElement, o.stateElement, true) and 
      compareDeep(timeElement, o.timeElement, true);
  end;
end;

function TFhirDeviceMetricCalibration.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FState) and isEmptyProp(FTime);
end;

procedure TFhirDeviceMetricCalibration.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('state');
  fields.add('time');
end;

{ TFhirDeviceMetricCalibration }

Procedure TFhirDeviceMetricCalibration.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirDeviceMetricCalibration.GetType_ST : TFhirMetricCalibrationTypeEnum;
begin
  if FType_ = nil then
    result := TFhirMetricCalibrationTypeEnum(0)
  else
    result := TFhirMetricCalibrationTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirMetricCalibrationTypeEnum, FType_.value));
end;

Procedure TFhirDeviceMetricCalibration.SetType_ST(value : TFhirMetricCalibrationTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.Create(SYSTEMS_TFhirMetricCalibrationTypeEnum[value], CODES_TFhirMetricCalibrationTypeEnum[value]);
end;

Procedure TFhirDeviceMetricCalibration.SetState(value : TFhirEnum);
begin
  FState.free;
  FState := value;
end;

Function TFhirDeviceMetricCalibration.GetStateST : TFhirMetricCalibrationStateEnum;
begin
  if FState = nil then
    result := TFhirMetricCalibrationStateEnum(0)
  else
    result := TFhirMetricCalibrationStateEnum(StringArrayIndexOfSensitive(CODES_TFhirMetricCalibrationStateEnum, FState.value));
end;

Procedure TFhirDeviceMetricCalibration.SetStateST(value : TFhirMetricCalibrationStateEnum);
begin
  if ord(value) = 0 then
    StateElement := nil
  else
    StateElement := TFhirEnum.Create(SYSTEMS_TFhirMetricCalibrationStateEnum[value], CODES_TFhirMetricCalibrationStateEnum[value]);
end;

Procedure TFhirDeviceMetricCalibration.SetTime(value : TFhirInstant);
begin
  FTime.free;
  FTime := value;
end;

Function TFhirDeviceMetricCalibration.GetTimeST : TFslDateTime;
begin
  if FTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FTime.value;
end;

Procedure TFhirDeviceMetricCalibration.SetTimeST(value : TFslDateTime);
begin
  if FTime = nil then
    FTime := TFhirInstant.Create;
  FTime.value := value
end;

function TFhirDeviceMetricCalibration.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FType_.sizeInBytes(magic));
  inc(result, FState.sizeInBytes(magic));
  inc(result, FTime.sizeInBytes(magic));
end;

{ TFhirDeviceMetricCalibrationListEnumerator }

Constructor TFhirDeviceMetricCalibrationListEnumerator.Create(list : TFhirDeviceMetricCalibrationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceMetricCalibrationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceMetricCalibrationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceMetricCalibrationListEnumerator.GetCurrent : TFhirDeviceMetricCalibration;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceMetricCalibrationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceMetricCalibrationList }
function TFhirDeviceMetricCalibrationList.AddItem(value: TFhirDeviceMetricCalibration): TFhirDeviceMetricCalibration;
begin
  add(value);
  result := value;
end;

function TFhirDeviceMetricCalibrationList.Append: TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceMetricCalibrationList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceMetricCalibrationList.GetEnumerator : TFhirDeviceMetricCalibrationListEnumerator;
begin
  result := TFhirDeviceMetricCalibrationListEnumerator.Create(self.link);
end;

function TFhirDeviceMetricCalibrationList.Clone: TFhirDeviceMetricCalibrationList;
begin
  result := TFhirDeviceMetricCalibrationList(inherited Clone);
end;

function TFhirDeviceMetricCalibrationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceMetricCalibrationList.GetItemN(index: Integer): TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration(ObjectByIndex[index]);
end;

function TFhirDeviceMetricCalibrationList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceMetricCalibration;
end;
function TFhirDeviceMetricCalibrationList.IndexOf(value: TFhirDeviceMetricCalibration): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceMetricCalibrationList.Insert(index: Integer): TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceMetricCalibrationList.InsertItem(index: Integer; value: TFhirDeviceMetricCalibration);
begin
  assert(value is TFhirDeviceMetricCalibration);
  Inherited Insert(index, value);
end;

function TFhirDeviceMetricCalibrationList.Item(index: Integer): TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration(ObjectByIndex[index]);
end;

function TFhirDeviceMetricCalibrationList.Link: TFhirDeviceMetricCalibrationList;
begin
  result := TFhirDeviceMetricCalibrationList(inherited Link);
end;

procedure TFhirDeviceMetricCalibrationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceMetricCalibrationList.SetItemByIndex(index: Integer; value: TFhirDeviceMetricCalibration);
begin
  assert(value is TFhirDeviceMetricCalibration);
  FhirDeviceMetricCalibrations[index] := value;
end;

procedure TFhirDeviceMetricCalibrationList.SetItemN(index: Integer; value: TFhirDeviceMetricCalibration);
begin
  assert(value is TFhirDeviceMetricCalibration);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceMetric }

constructor TFhirDeviceMetric.Create;
begin
  inherited;
end;

destructor TFhirDeviceMetric.Destroy;
begin
  FIdentifierList.free;
  FType_.free;
  FUnit_.free;
  FSource.free;
  FParent.free;
  FOperationalStatus.free;
  FColor.free;
  FCategory.free;
  FMeasurementPeriod.free;
  FCalibrationList.free;
  inherited;
end;

function TFhirDeviceMetric.GetResourceType : TFhirResourceType;
begin
  result := frtDeviceMetric;
end;

procedure TFhirDeviceMetric.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDeviceMetric(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDeviceMetric(oSource).FIdentifierList);
  end;
  type_ := TFhirDeviceMetric(oSource).type_.Clone;
  unit_ := TFhirDeviceMetric(oSource).unit_.Clone;
  source := TFhirDeviceMetric(oSource).source.Clone;
  parent := TFhirDeviceMetric(oSource).parent.Clone;
  FOperationalStatus := TFhirDeviceMetric(oSource).FOperationalStatus.Link;
  FColor := TFhirDeviceMetric(oSource).FColor.Link;
  FCategory := TFhirDeviceMetric(oSource).FCategory.Link;
  measurementPeriod := TFhirDeviceMetric(oSource).measurementPeriod.Clone;
  if (TFhirDeviceMetric(oSource).FCalibrationList = nil) then
  begin
    FCalibrationList.free;
    FCalibrationList := nil;
  end
  else
  begin
    if FCalibrationList = nil then
      FCalibrationList := TFhirDeviceMetricCalibrationList.Create;
    FCalibrationList.Assign(TFhirDeviceMetric(oSource).FCalibrationList);
  end;
end;

procedure TFhirDeviceMetric.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'unit') Then
     list.add(self.link, 'unit', FUnit_.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'parent') Then
     list.add(self.link, 'parent', FParent.Link);
  if (child_name = 'operationalStatus') Then
     list.add(self.link, 'operationalStatus', FOperationalStatus.Link);
  if (child_name = 'color') Then
     list.add(self.link, 'color', FColor.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'measurementPeriod') Then
     list.add(self.link, 'measurementPeriod', FMeasurementPeriod.Link);
  if (child_name = 'calibration') Then
    list.addAll(self, 'calibration', FCalibrationList);
end;

procedure TFhirDeviceMetric.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'unit', 'CodeableConcept', false, TFhirCodeableConcept, FUnit_.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'source', 'Reference(Device)', false, TFhirReference{TFhirDevice}, FSource.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'parent', 'Reference(Device)', false, TFhirReference{TFhirDevice}, FParent.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'operationalStatus', 'code', false, TFHIREnum, FOperationalStatus.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'color', 'code', false, TFHIREnum, FColor.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'category', 'code', false, TFHIREnum, FCategory.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'measurementPeriod', 'Timing', false, TFhirTiming, FMeasurementPeriod.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'calibration', '', true, TFhirDeviceMetricCalibration, FCalibrationList.Link)){3};
end;

function TFhirDeviceMetric.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'unit') then
  begin
    Unit_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference{TFhirDevice}{4b};
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    Parent := propValue as TFhirReference{TFhirDevice}{4b};
    result := propValue;
  end
  else if (propName = 'operationalStatus') then
  begin
    OperationalStatusElement := asEnum(SYSTEMS_TFhirMetricOperationalStatusEnum, CODES_TFhirMetricOperationalStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'color') then
  begin
    ColorElement := asEnum(SYSTEMS_TFhirMetricColorEnum, CODES_TFhirMetricColorEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    CategoryElement := asEnum(SYSTEMS_TFhirMetricCategoryEnum, CODES_TFhirMetricCategoryEnum, propValue);
    result := propValue
  end
  else if (propName = 'measurementPeriod') then
  begin
    MeasurementPeriod := propValue as TFhirTiming{4b};
    result := propValue;
  end
  else if (propName = 'calibration') then
  begin
    CalibrationList.add(propValue as TFhirDeviceMetricCalibration){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirDeviceMetric.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'calibration') then CalibrationList.insertItem(index, propValue as TFhirDeviceMetricCalibration){2a}
  else inherited;
end;

function TFhirDeviceMetric.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'unit') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'source') then result := TFhirReference{TFhirDevice}.Create(){4b}
  else if (propName = 'parent') then result := TFhirReference{TFhirDevice}.Create(){4b}
  else if (propName = 'measurementPeriod') then result := TFhirTiming.Create(){4b}
  else if (propName = 'calibration') then result := CalibrationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceMetric.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'unit') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'parent') then result := 'Reference'
  else if (propName = 'operationalStatus') then result := 'code'
  else if (propName = 'color') then result := 'code'
  else if (propName = 'category') then result := 'code'
  else if (propName = 'measurementPeriod') then result := 'Timing'
  else if (propName = 'calibration') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceMetric.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'unit') then Unit_Element := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'parent') then ParentElement := nil
  else if (propName = 'operationalStatus') then OperationalStatusElement := nil
  else if (propName = 'color') then ColorElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'measurementPeriod') then MeasurementPeriodElement := nil
  else if (propName = 'calibration') then deletePropertyValue('calibration', CalibrationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceMetric.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'unit') then Unit_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'source') then SourceElement := new as TFhirReference{TFhirDevice}{4}
  else if (propName = 'parent') then ParentElement := new as TFhirReference{TFhirDevice}{4}
  else if (propName = 'operationalStatus') then OperationalStatusElement := asEnum(SYSTEMS_TFhirMetricOperationalStatusEnum, CODES_TFhirMetricOperationalStatusEnum, new){4}
  else if (propName = 'color') then ColorElement := asEnum(SYSTEMS_TFhirMetricColorEnum, CODES_TFhirMetricColorEnum, new){4}
  else if (propName = 'category') then CategoryElement := asEnum(SYSTEMS_TFhirMetricCategoryEnum, CODES_TFhirMetricCategoryEnum, new){4}
  else if (propName = 'measurementPeriod') then MeasurementPeriodElement := new as TFhirTiming{4}
  else if (propName = 'calibration') then replacePropertyValue('calibration', CalibrationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceMetric.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'calibration') then CalibrationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceMetric.fhirType : string;
begin
  result := 'DeviceMetric';
end;

function TFhirDeviceMetric.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FUnit_) and isEmptyProp(FSource) and isEmptyProp(FParent) and isEmptyProp(FOperationalStatus) and isEmptyProp(FColor) and isEmptyProp(FCategory) and isEmptyProp(FMeasurementPeriod) and isEmptyProp(FcalibrationList);
end;

function TFhirDeviceMetric.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceMetric;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceMetric)) then
    result := false
  else
  begin
    o := TFhirDeviceMetric(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(unit_Element, o.unit_Element, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(parentElement, o.parentElement, true) and compareDeep(operationalStatusElement, o.operationalStatusElement, true) and 
      compareDeep(colorElement, o.colorElement, true) and compareDeep(categoryElement, o.categoryElement, true) and 
      compareDeep(measurementPeriodElement, o.measurementPeriodElement, true) and compareDeep(calibrationList, o.calibrationList, true);
  end;
end;

function TFhirDeviceMetric.Link : TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric(inherited Link);
end;

function TFhirDeviceMetric.Clone : TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric(inherited Clone);
end;

procedure TFhirDeviceMetric.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('unit');
  fields.add('source');
  fields.add('parent');
  fields.add('operationalStatus');
  fields.add('color');
  fields.add('category');
  fields.add('measurementPeriod');
  fields.add('calibration');
end;

{ TFhirDeviceMetric }

Function TFhirDeviceMetric.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirDeviceMetric.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirDeviceMetric.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirDeviceMetric.SetUnit_(value : TFhirCodeableConcept);
begin
  FUnit_.free;
  FUnit_ := value;
end;

Procedure TFhirDeviceMetric.SetSource(value : TFhirReference{TFhirDevice});
begin
  FSource.free;
  FSource := value;
end;

Procedure TFhirDeviceMetric.SetParent(value : TFhirReference{TFhirDevice});
begin
  FParent.free;
  FParent := value;
end;

Procedure TFhirDeviceMetric.SetOperationalStatus(value : TFhirEnum);
begin
  FOperationalStatus.free;
  FOperationalStatus := value;
end;

Function TFhirDeviceMetric.GetOperationalStatusST : TFhirMetricOperationalStatusEnum;
begin
  if FOperationalStatus = nil then
    result := TFhirMetricOperationalStatusEnum(0)
  else
    result := TFhirMetricOperationalStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirMetricOperationalStatusEnum, FOperationalStatus.value));
end;

Procedure TFhirDeviceMetric.SetOperationalStatusST(value : TFhirMetricOperationalStatusEnum);
begin
  if ord(value) = 0 then
    OperationalStatusElement := nil
  else
    OperationalStatusElement := TFhirEnum.Create(SYSTEMS_TFhirMetricOperationalStatusEnum[value], CODES_TFhirMetricOperationalStatusEnum[value]);
end;

Procedure TFhirDeviceMetric.SetColor(value : TFhirEnum);
begin
  FColor.free;
  FColor := value;
end;

Function TFhirDeviceMetric.GetColorST : TFhirMetricColorEnum;
begin
  if FColor = nil then
    result := TFhirMetricColorEnum(0)
  else
    result := TFhirMetricColorEnum(StringArrayIndexOfSensitive(CODES_TFhirMetricColorEnum, FColor.value));
end;

Procedure TFhirDeviceMetric.SetColorST(value : TFhirMetricColorEnum);
begin
  if ord(value) = 0 then
    ColorElement := nil
  else
    ColorElement := TFhirEnum.Create(SYSTEMS_TFhirMetricColorEnum[value], CODES_TFhirMetricColorEnum[value]);
end;

Procedure TFhirDeviceMetric.SetCategory(value : TFhirEnum);
begin
  FCategory.free;
  FCategory := value;
end;

Function TFhirDeviceMetric.GetCategoryST : TFhirMetricCategoryEnum;
begin
  if FCategory = nil then
    result := TFhirMetricCategoryEnum(0)
  else
    result := TFhirMetricCategoryEnum(StringArrayIndexOfSensitive(CODES_TFhirMetricCategoryEnum, FCategory.value));
end;

Procedure TFhirDeviceMetric.SetCategoryST(value : TFhirMetricCategoryEnum);
begin
  if ord(value) = 0 then
    CategoryElement := nil
  else
    CategoryElement := TFhirEnum.Create(SYSTEMS_TFhirMetricCategoryEnum[value], CODES_TFhirMetricCategoryEnum[value]);
end;

Procedure TFhirDeviceMetric.SetMeasurementPeriod(value : TFhirTiming);
begin
  FMeasurementPeriod.free;
  FMeasurementPeriod := value;
end;

Function TFhirDeviceMetric.GetCalibrationList : TFhirDeviceMetricCalibrationList;
begin
  if FCalibrationList = nil then
    FCalibrationList := TFhirDeviceMetricCalibrationList.Create;
  result := FCalibrationList;
end;

Function TFhirDeviceMetric.GetHasCalibrationList : boolean;
begin
  result := (FCalibrationList <> nil) and (FCalibrationList.count > 0);
end;

function TFhirDeviceMetric.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FidentifierList.sizeInBytes(magic));
  inc(result, FType_.sizeInBytes(magic));
  inc(result, FUnit_.sizeInBytes(magic));
  inc(result, FSource.sizeInBytes(magic));
  inc(result, FOperationalStatus.sizeInBytes(magic));
  inc(result, FColor.sizeInBytes(magic));
  inc(result, FCategory.sizeInBytes(magic));
  inc(result, FMeasurementPeriod.sizeInBytes(magic));
  inc(result, FcalibrationList.sizeInBytes(magic));
end;

{ TFhirDeviceMetricListEnumerator }

Constructor TFhirDeviceMetricListEnumerator.Create(list : TFhirDeviceMetricList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceMetricListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceMetricListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceMetricListEnumerator.GetCurrent : TFhirDeviceMetric;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceMetricListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceMetricList }
function TFhirDeviceMetricList.AddItem(value: TFhirDeviceMetric): TFhirDeviceMetric;
begin
  add(value);
  result := value;
end;

function TFhirDeviceMetricList.Append: TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceMetricList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceMetricList.GetEnumerator : TFhirDeviceMetricListEnumerator;
begin
  result := TFhirDeviceMetricListEnumerator.Create(self.link);
end;

function TFhirDeviceMetricList.Clone: TFhirDeviceMetricList;
begin
  result := TFhirDeviceMetricList(inherited Clone);
end;

function TFhirDeviceMetricList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceMetricList.GetItemN(index: Integer): TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric(ObjectByIndex[index]);
end;

function TFhirDeviceMetricList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceMetric;
end;
function TFhirDeviceMetricList.IndexOf(value: TFhirDeviceMetric): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceMetricList.Insert(index: Integer): TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceMetricList.InsertItem(index: Integer; value: TFhirDeviceMetric);
begin
  assert(value is TFhirDeviceMetric);
  Inherited Insert(index, value);
end;

function TFhirDeviceMetricList.Item(index: Integer): TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric(ObjectByIndex[index]);
end;

function TFhirDeviceMetricList.Link: TFhirDeviceMetricList;
begin
  result := TFhirDeviceMetricList(inherited Link);
end;

procedure TFhirDeviceMetricList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceMetricList.SetItemByIndex(index: Integer; value: TFhirDeviceMetric);
begin
  assert(value is TFhirDeviceMetric);
  FhirDeviceMetrics[index] := value;
end;

procedure TFhirDeviceMetricList.SetItemN(index: Integer; value: TFhirDeviceMetric);
begin
  assert(value is TFhirDeviceMetric);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DEVICEMETRIC}

{$IFDEF FHIR_ENCOUNTER}

{ TFhirEncounterStatusHistory }

constructor TFhirEncounterStatusHistory.Create;
begin
  inherited;
end;

destructor TFhirEncounterStatusHistory.Destroy;
begin
  FStatus.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEncounterStatusHistory.Assign(oSource : TFslObject);
begin
  inherited;
  FStatus := TFhirEncounterStatusHistory(oSource).FStatus.Link;
  period := TFhirEncounterStatusHistory(oSource).period.Clone;
end;

procedure TFhirEncounterStatusHistory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirEncounterStatusHistory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
end;

function TFhirEncounterStatusHistory.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEncounterStatusEnum, CODES_TFhirEncounterStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterStatusHistory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEncounterStatusHistory.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'period') then result := TFhirPeriod.Create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterStatusHistory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterStatusHistory.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterStatusHistory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEncounterStatusEnum, CODES_TFhirEncounterStatusEnum, new){4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterStatusHistory.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterStatusHistory.fhirType : string;
begin
  result := 'statusHistory';
end;

function TFhirEncounterStatusHistory.Link : TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory(inherited Link);
end;

function TFhirEncounterStatusHistory.Clone : TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory(inherited Clone);
end;

function TFhirEncounterStatusHistory.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterStatusHistory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterStatusHistory)) then
    result := false
  else
  begin
    o := TFhirEncounterStatusHistory(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirEncounterStatusHistory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FPeriod);
end;

procedure TFhirEncounterStatusHistory.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('status');
  fields.add('period');
end;

{ TFhirEncounterStatusHistory }

Procedure TFhirEncounterStatusHistory.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirEncounterStatusHistory.GetStatusST : TFhirEncounterStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEncounterStatusEnum(0)
  else
    result := TFhirEncounterStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEncounterStatusEnum, FStatus.value));
end;

Procedure TFhirEncounterStatusHistory.SetStatusST(value : TFhirEncounterStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.Create(SYSTEMS_TFhirEncounterStatusEnum[value], CODES_TFhirEncounterStatusEnum[value]);
end;

Procedure TFhirEncounterStatusHistory.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirEncounterStatusHistory.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FStatus.sizeInBytes(magic));
  inc(result, FPeriod.sizeInBytes(magic));
end;

{ TFhirEncounterStatusHistoryListEnumerator }

Constructor TFhirEncounterStatusHistoryListEnumerator.Create(list : TFhirEncounterStatusHistoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterStatusHistoryListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirEncounterStatusHistoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterStatusHistoryListEnumerator.GetCurrent : TFhirEncounterStatusHistory;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterStatusHistoryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterStatusHistoryList }
function TFhirEncounterStatusHistoryList.AddItem(value: TFhirEncounterStatusHistory): TFhirEncounterStatusHistory;
begin
  add(value);
  result := value;
end;

function TFhirEncounterStatusHistoryList.Append: TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterStatusHistoryList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterStatusHistoryList.GetEnumerator : TFhirEncounterStatusHistoryListEnumerator;
begin
  result := TFhirEncounterStatusHistoryListEnumerator.Create(self.link);
end;

function TFhirEncounterStatusHistoryList.Clone: TFhirEncounterStatusHistoryList;
begin
  result := TFhirEncounterStatusHistoryList(inherited Clone);
end;

function TFhirEncounterStatusHistoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterStatusHistoryList.GetItemN(index: Integer): TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory(ObjectByIndex[index]);
end;

function TFhirEncounterStatusHistoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterStatusHistory;
end;
function TFhirEncounterStatusHistoryList.IndexOf(value: TFhirEncounterStatusHistory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterStatusHistoryList.Insert(index: Integer): TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterStatusHistoryList.InsertItem(index: Integer; value: TFhirEncounterStatusHistory);
begin
  assert(value is TFhirEncounterStatusHistory);
  Inherited Insert(index, value);
end;

function TFhirEncounterStatusHistoryList.Item(index: Integer): TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory(ObjectByIndex[index]);
end;

function TFhirEncounterStatusHistoryList.Link: TFhirEncounterStatusHistoryList;
begin
  result := TFhirEncounterStatusHistoryList(inherited Link);
end;

procedure TFhirEncounterStatusHistoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterStatusHistoryList.SetItemByIndex(index: Integer; value: TFhirEncounterStatusHistory);
begin
  assert(value is TFhirEncounterStatusHistory);
  FhirEncounterStatusHistories[index] := value;
end;

procedure TFhirEncounterStatusHistoryList.SetItemN(index: Integer; value: TFhirEncounterStatusHistory);
begin
  assert(value is TFhirEncounterStatusHistory);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterClassHistory }

constructor TFhirEncounterClassHistory.Create;
begin
  inherited;
end;

destructor TFhirEncounterClassHistory.Destroy;
begin
  FClass_.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEncounterClassHistory.Assign(oSource : TFslObject);
begin
  inherited;
  class_ := TFhirEncounterClassHistory(oSource).class_.Clone;
  period := TFhirEncounterClassHistory(oSource).period.Clone;
end;

procedure TFhirEncounterClassHistory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'class') Then
     list.add(self.link, 'class', FClass_.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirEncounterClassHistory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'class', 'Coding', false, TFhirCoding, FClass_.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
end;

function TFhirEncounterClassHistory.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'class') then
  begin
    Class_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterClassHistory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEncounterClassHistory.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'class') then result := TFhirCoding.Create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.Create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterClassHistory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'class') then result := 'Coding'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterClassHistory.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'class') then Class_Element := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterClassHistory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'class') then Class_Element := new as TFhirCoding{4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterClassHistory.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterClassHistory.fhirType : string;
begin
  result := 'classHistory';
end;

function TFhirEncounterClassHistory.Link : TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory(inherited Link);
end;

function TFhirEncounterClassHistory.Clone : TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory(inherited Clone);
end;

function TFhirEncounterClassHistory.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterClassHistory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterClassHistory)) then
    result := false
  else
  begin
    o := TFhirEncounterClassHistory(other);
    result := compareDeep(class_Element, o.class_Element, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirEncounterClassHistory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FClass_) and isEmptyProp(FPeriod);
end;

procedure TFhirEncounterClassHistory.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('class');
  fields.add('period');
end;

{ TFhirEncounterClassHistory }

Procedure TFhirEncounterClassHistory.SetClass_(value : TFhirCoding);
begin
  FClass_.free;
  FClass_ := value;
end;

Procedure TFhirEncounterClassHistory.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirEncounterClassHistory.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FClass_.sizeInBytes(magic));
  inc(result, FPeriod.sizeInBytes(magic));
end;

{ TFhirEncounterClassHistoryListEnumerator }

Constructor TFhirEncounterClassHistoryListEnumerator.Create(list : TFhirEncounterClassHistoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterClassHistoryListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirEncounterClassHistoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterClassHistoryListEnumerator.GetCurrent : TFhirEncounterClassHistory;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterClassHistoryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterClassHistoryList }
function TFhirEncounterClassHistoryList.AddItem(value: TFhirEncounterClassHistory): TFhirEncounterClassHistory;
begin
  add(value);
  result := value;
end;

function TFhirEncounterClassHistoryList.Append: TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterClassHistoryList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterClassHistoryList.GetEnumerator : TFhirEncounterClassHistoryListEnumerator;
begin
  result := TFhirEncounterClassHistoryListEnumerator.Create(self.link);
end;

function TFhirEncounterClassHistoryList.Clone: TFhirEncounterClassHistoryList;
begin
  result := TFhirEncounterClassHistoryList(inherited Clone);
end;

function TFhirEncounterClassHistoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterClassHistoryList.GetItemN(index: Integer): TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory(ObjectByIndex[index]);
end;

function TFhirEncounterClassHistoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterClassHistory;
end;
function TFhirEncounterClassHistoryList.IndexOf(value: TFhirEncounterClassHistory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterClassHistoryList.Insert(index: Integer): TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterClassHistoryList.InsertItem(index: Integer; value: TFhirEncounterClassHistory);
begin
  assert(value is TFhirEncounterClassHistory);
  Inherited Insert(index, value);
end;

function TFhirEncounterClassHistoryList.Item(index: Integer): TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory(ObjectByIndex[index]);
end;

function TFhirEncounterClassHistoryList.Link: TFhirEncounterClassHistoryList;
begin
  result := TFhirEncounterClassHistoryList(inherited Link);
end;

procedure TFhirEncounterClassHistoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterClassHistoryList.SetItemByIndex(index: Integer; value: TFhirEncounterClassHistory);
begin
  assert(value is TFhirEncounterClassHistory);
  FhirEncounterClassHistories[index] := value;
end;

procedure TFhirEncounterClassHistoryList.SetItemN(index: Integer; value: TFhirEncounterClassHistory);
begin
  assert(value is TFhirEncounterClassHistory);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterParticipant }

constructor TFhirEncounterParticipant.Create;
begin
  inherited;
end;

destructor TFhirEncounterParticipant.Destroy;
begin
  FType_List.free;
  FPeriod.free;
  FIndividual.free;
  inherited;
end;

procedure TFhirEncounterParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEncounterParticipant(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirEncounterParticipant(oSource).FType_List);
  end;
  period := TFhirEncounterParticipant(oSource).period.Clone;
  individual := TFhirEncounterParticipant(oSource).individual.Clone;
end;

procedure TFhirEncounterParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'individual') Then
     list.add(self.link, 'individual', FIndividual.Link);
end;

procedure TFhirEncounterParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'individual', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FIndividual.Link));{2}
end;

function TFhirEncounterParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'individual') then
  begin
    Individual := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirEncounterParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'period') then result := TFhirPeriod.Create(){4b}
  else if (propName = 'individual') then result := TFhirReference{TFhirPractitioner}.Create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'individual') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'individual') then IndividualElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'individual') then IndividualElement := new as TFhirReference{TFhirPractitioner}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterParticipant.fhirType : string;
begin
  result := 'participant';
end;

function TFhirEncounterParticipant.Link : TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(inherited Link);
end;

function TFhirEncounterParticipant.Clone : TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(inherited Clone);
end;

function TFhirEncounterParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterParticipant)) then
    result := false
  else
  begin
    o := TFhirEncounterParticipant(other);
    result := compareDeep(type_List, o.type_List, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(individualElement, o.individualElement, true);
  end;
end;

function TFhirEncounterParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Ftype_List) and isEmptyProp(FPeriod) and isEmptyProp(FIndividual);
end;

procedure TFhirEncounterParticipant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('period');
  fields.add('individual');
end;

{ TFhirEncounterParticipant }

Function TFhirEncounterParticipant.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

Function TFhirEncounterParticipant.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Procedure TFhirEncounterParticipant.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirEncounterParticipant.SetIndividual(value : TFhirReference{TFhirPractitioner});
begin
  FIndividual.free;
  FIndividual := value;
end;

function TFhirEncounterParticipant.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, Ftype_List.sizeInBytes(magic));
  inc(result, FPeriod.sizeInBytes(magic));
  inc(result, FIndividual.sizeInBytes(magic));
end;

{ TFhirEncounterParticipantListEnumerator }

Constructor TFhirEncounterParticipantListEnumerator.Create(list : TFhirEncounterParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterParticipantListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirEncounterParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterParticipantListEnumerator.GetCurrent : TFhirEncounterParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterParticipantListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterParticipantList }
function TFhirEncounterParticipantList.AddItem(value: TFhirEncounterParticipant): TFhirEncounterParticipant;
begin
  add(value);
  result := value;
end;

function TFhirEncounterParticipantList.Append: TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterParticipantList.GetEnumerator : TFhirEncounterParticipantListEnumerator;
begin
  result := TFhirEncounterParticipantListEnumerator.Create(self.link);
end;

function TFhirEncounterParticipantList.Clone: TFhirEncounterParticipantList;
begin
  result := TFhirEncounterParticipantList(inherited Clone);
end;

function TFhirEncounterParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterParticipantList.GetItemN(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(ObjectByIndex[index]);
end;

function TFhirEncounterParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterParticipant;
end;
function TFhirEncounterParticipantList.IndexOf(value: TFhirEncounterParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterParticipantList.Insert(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterParticipantList.InsertItem(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  Inherited Insert(index, value);
end;

function TFhirEncounterParticipantList.Item(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(ObjectByIndex[index]);
end;

function TFhirEncounterParticipantList.Link: TFhirEncounterParticipantList;
begin
  result := TFhirEncounterParticipantList(inherited Link);
end;

procedure TFhirEncounterParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterParticipantList.SetItemByIndex(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  FhirEncounterParticipants[index] := value;
end;

procedure TFhirEncounterParticipantList.SetItemN(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterDiagnosis }

constructor TFhirEncounterDiagnosis.Create;
begin
  inherited;
end;

destructor TFhirEncounterDiagnosis.Destroy;
begin
  FCondition.free;
  FUse.free;
  FRank.free;
  inherited;
end;

procedure TFhirEncounterDiagnosis.Assign(oSource : TFslObject);
begin
  inherited;
  condition := TFhirEncounterDiagnosis(oSource).condition.Clone;
  use := TFhirEncounterDiagnosis(oSource).use.Clone;
  rankElement := TFhirEncounterDiagnosis(oSource).rankElement.Clone;
end;

procedure TFhirEncounterDiagnosis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'condition') Then
     list.add(self.link, 'condition', FCondition.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'rank') Then
     list.add(self.link, 'rank', FRank.Link);
end;

procedure TFhirEncounterDiagnosis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'condition', 'Reference(Condition)', false, TFhirReference{TFhirCondition}, FCondition.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'use', 'CodeableConcept', false, TFhirCodeableConcept, FUse.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'rank', 'positiveInt', false, TFhirPositiveInt, FRank.Link));{2}
end;

function TFhirEncounterDiagnosis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'condition') then
  begin
    Condition := propValue as TFhirReference{TFhirCondition}{4b};
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    Use := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'rank') then
  begin
    RankElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterDiagnosis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEncounterDiagnosis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'condition') then result := TFhirReference{TFhirCondition}.Create(){4b}
  else if (propName = 'use') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'rank') then result := TFhirPositiveInt.Create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterDiagnosis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'condition') then result := 'Reference'
  else if (propName = 'use') then result := 'CodeableConcept'
  else if (propName = 'rank') then result := 'positiveInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterDiagnosis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'condition') then ConditionElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'rank') then RankElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterDiagnosis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'condition') then ConditionElement := new as TFhirReference{TFhirCondition}{4}
  else if (propName = 'use') then UseElement := new as TFhirCodeableConcept{4}
  else if (propName = 'rank') then RankElement := asPositiveInt(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterDiagnosis.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterDiagnosis.fhirType : string;
begin
  result := 'diagnosis';
end;

function TFhirEncounterDiagnosis.Link : TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis(inherited Link);
end;

function TFhirEncounterDiagnosis.Clone : TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis(inherited Clone);
end;

function TFhirEncounterDiagnosis.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterDiagnosis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterDiagnosis)) then
    result := false
  else
  begin
    o := TFhirEncounterDiagnosis(other);
    result := compareDeep(conditionElement, o.conditionElement, true) and compareDeep(useElement, o.useElement, true) and 
      compareDeep(rankElement, o.rankElement, true);
  end;
end;

function TFhirEncounterDiagnosis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCondition) and isEmptyProp(FUse) and isEmptyProp(FRank);
end;

procedure TFhirEncounterDiagnosis.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('condition');
  fields.add('use');
  fields.add('rank');
end;

{ TFhirEncounterDiagnosis }

Procedure TFhirEncounterDiagnosis.SetCondition(value : TFhirReference{TFhirCondition});
begin
  FCondition.free;
  FCondition := value;
end;

Procedure TFhirEncounterDiagnosis.SetUse(value : TFhirCodeableConcept);
begin
  FUse.free;
  FUse := value;
end;

Procedure TFhirEncounterDiagnosis.SetRank(value : TFhirPositiveInt);
begin
  FRank.free;
  FRank := value;
end;

Function TFhirEncounterDiagnosis.GetRankST : String;
begin
  if FRank = nil then
    result := ''
  else
    result := FRank.value;
end;

Procedure TFhirEncounterDiagnosis.SetRankST(value : String);
begin
  if value <> '' then
  begin
    if FRank = nil then
      FRank := TFhirPositiveInt.Create;
    FRank.value := value
  end
  else if FRank <> nil then
    FRank.value := '';
end;

function TFhirEncounterDiagnosis.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FCondition.sizeInBytes(magic));
  inc(result, FUse.sizeInBytes(magic));
  inc(result, FRank.sizeInBytes(magic));
end;

{ TFhirEncounterDiagnosisListEnumerator }

Constructor TFhirEncounterDiagnosisListEnumerator.Create(list : TFhirEncounterDiagnosisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterDiagnosisListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirEncounterDiagnosisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterDiagnosisListEnumerator.GetCurrent : TFhirEncounterDiagnosis;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterDiagnosisListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterDiagnosisList }
function TFhirEncounterDiagnosisList.AddItem(value: TFhirEncounterDiagnosis): TFhirEncounterDiagnosis;
begin
  add(value);
  result := value;
end;

function TFhirEncounterDiagnosisList.Append: TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterDiagnosisList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterDiagnosisList.GetEnumerator : TFhirEncounterDiagnosisListEnumerator;
begin
  result := TFhirEncounterDiagnosisListEnumerator.Create(self.link);
end;

function TFhirEncounterDiagnosisList.Clone: TFhirEncounterDiagnosisList;
begin
  result := TFhirEncounterDiagnosisList(inherited Clone);
end;

function TFhirEncounterDiagnosisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterDiagnosisList.GetItemN(index: Integer): TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis(ObjectByIndex[index]);
end;

function TFhirEncounterDiagnosisList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterDiagnosis;
end;
function TFhirEncounterDiagnosisList.IndexOf(value: TFhirEncounterDiagnosis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterDiagnosisList.Insert(index: Integer): TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterDiagnosisList.InsertItem(index: Integer; value: TFhirEncounterDiagnosis);
begin
  assert(value is TFhirEncounterDiagnosis);
  Inherited Insert(index, value);
end;

function TFhirEncounterDiagnosisList.Item(index: Integer): TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis(ObjectByIndex[index]);
end;

function TFhirEncounterDiagnosisList.Link: TFhirEncounterDiagnosisList;
begin
  result := TFhirEncounterDiagnosisList(inherited Link);
end;

procedure TFhirEncounterDiagnosisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterDiagnosisList.SetItemByIndex(index: Integer; value: TFhirEncounterDiagnosis);
begin
  assert(value is TFhirEncounterDiagnosis);
  FhirEncounterDiagnoses[index] := value;
end;

procedure TFhirEncounterDiagnosisList.SetItemN(index: Integer; value: TFhirEncounterDiagnosis);
begin
  assert(value is TFhirEncounterDiagnosis);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterHospitalization }

constructor TFhirEncounterHospitalization.Create;
begin
  inherited;
end;

destructor TFhirEncounterHospitalization.Destroy;
begin
  FPreAdmissionIdentifier.free;
  FOrigin.free;
  FAdmitSource.free;
  FReAdmission.free;
  FDietPreferenceList.free;
  FSpecialCourtesyList.free;
  FSpecialArrangementList.free;
  FDestination.free;
  FDischargeDisposition.free;
  inherited;
end;

procedure TFhirEncounterHospitalization.Assign(oSource : TFslObject);
begin
  inherited;
  preAdmissionIdentifier := TFhirEncounterHospitalization(oSource).preAdmissionIdentifier.Clone;
  origin := TFhirEncounterHospitalization(oSource).origin.Clone;
  admitSource := TFhirEncounterHospitalization(oSource).admitSource.Clone;
  reAdmission := TFhirEncounterHospitalization(oSource).reAdmission.Clone;
  if (TFhirEncounterHospitalization(oSource).FDietPreferenceList = nil) then
  begin
    FDietPreferenceList.free;
    FDietPreferenceList := nil;
  end
  else
  begin
    if FDietPreferenceList = nil then
      FDietPreferenceList := TFhirCodeableConceptList.Create;
    FDietPreferenceList.Assign(TFhirEncounterHospitalization(oSource).FDietPreferenceList);
  end;
  if (TFhirEncounterHospitalization(oSource).FSpecialCourtesyList = nil) then
  begin
    FSpecialCourtesyList.free;
    FSpecialCourtesyList := nil;
  end
  else
  begin
    if FSpecialCourtesyList = nil then
      FSpecialCourtesyList := TFhirCodeableConceptList.Create;
    FSpecialCourtesyList.Assign(TFhirEncounterHospitalization(oSource).FSpecialCourtesyList);
  end;
  if (TFhirEncounterHospitalization(oSource).FSpecialArrangementList = nil) then
  begin
    FSpecialArrangementList.free;
    FSpecialArrangementList := nil;
  end
  else
  begin
    if FSpecialArrangementList = nil then
      FSpecialArrangementList := TFhirCodeableConceptList.Create;
    FSpecialArrangementList.Assign(TFhirEncounterHospitalization(oSource).FSpecialArrangementList);
  end;
  destination := TFhirEncounterHospitalization(oSource).destination.Clone;
  dischargeDisposition := TFhirEncounterHospitalization(oSource).dischargeDisposition.Clone;
end;

procedure TFhirEncounterHospitalization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'preAdmissionIdentifier') Then
     list.add(self.link, 'preAdmissionIdentifier', FPreAdmissionIdentifier.Link);
  if (child_name = 'origin') Then
     list.add(self.link, 'origin', FOrigin.Link);
  if (child_name = 'admitSource') Then
     list.add(self.link, 'admitSource', FAdmitSource.Link);
  if (child_name = 'reAdmission') Then
     list.add(self.link, 'reAdmission', FReAdmission.Link);
  if (child_name = 'dietPreference') Then
    list.addAll(self, 'dietPreference', FDietPreferenceList);
  if (child_name = 'specialCourtesy') Then
    list.addAll(self, 'specialCourtesy', FSpecialCourtesyList);
  if (child_name = 'specialArrangement') Then
    list.addAll(self, 'specialArrangement', FSpecialArrangementList);
  if (child_name = 'destination') Then
     list.add(self.link, 'destination', FDestination.Link);
  if (child_name = 'dischargeDisposition') Then
     list.add(self.link, 'dischargeDisposition', FDischargeDisposition.Link);
end;

procedure TFhirEncounterHospitalization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'preAdmissionIdentifier', 'Identifier', false, TFhirIdentifier, FPreAdmissionIdentifier.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'origin', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FOrigin.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'admitSource', 'CodeableConcept', false, TFhirCodeableConcept, FAdmitSource.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'reAdmission', 'CodeableConcept', false, TFhirCodeableConcept, FReAdmission.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'dietPreference', 'CodeableConcept', true, TFhirCodeableConcept, FDietPreferenceList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'specialCourtesy', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialCourtesyList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'specialArrangement', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialArrangementList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'destination', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FDestination.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'dischargeDisposition', 'CodeableConcept', false, TFhirCodeableConcept, FDischargeDisposition.Link));{2}
end;

function TFhirEncounterHospitalization.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'preAdmissionIdentifier') then
  begin
    PreAdmissionIdentifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'origin') then
  begin
    Origin := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'admitSource') then
  begin
    AdmitSource := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reAdmission') then
  begin
    ReAdmission := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'dietPreference') then
  begin
    DietPreferenceList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'specialCourtesy') then
  begin
    SpecialCourtesyList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'specialArrangement') then
  begin
    SpecialArrangementList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    Destination := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'dischargeDisposition') then
  begin
    DischargeDisposition := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterHospitalization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'dietPreference') then DietPreferenceList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'specialCourtesy') then SpecialCourtesyList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'specialArrangement') then SpecialArrangementList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirEncounterHospitalization.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'preAdmissionIdentifier') then result := TFhirIdentifier.Create(){4b}
  else if (propName = 'origin') then result := TFhirReference{TFhirLocation}.Create(){4b}
  else if (propName = 'admitSource') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'reAdmission') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'dietPreference') then result := DietPreferenceList.new(){2}
  else if (propName = 'specialCourtesy') then result := SpecialCourtesyList.new(){2}
  else if (propName = 'specialArrangement') then result := SpecialArrangementList.new(){2}
  else if (propName = 'destination') then result := TFhirReference{TFhirLocation}.Create(){4b}
  else if (propName = 'dischargeDisposition') then result := TFhirCodeableConcept.Create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterHospitalization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'preAdmissionIdentifier') then result := 'Identifier'
  else if (propName = 'origin') then result := 'Reference'
  else if (propName = 'admitSource') then result := 'CodeableConcept'
  else if (propName = 'reAdmission') then result := 'CodeableConcept'
  else if (propName = 'dietPreference') then result := 'CodeableConcept'
  else if (propName = 'specialCourtesy') then result := 'CodeableConcept'
  else if (propName = 'specialArrangement') then result := 'CodeableConcept'
  else if (propName = 'destination') then result := 'Reference'
  else if (propName = 'dischargeDisposition') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterHospitalization.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'preAdmissionIdentifier') then PreAdmissionIdentifierElement := nil
  else if (propName = 'origin') then OriginElement := nil
  else if (propName = 'admitSource') then AdmitSourceElement := nil
  else if (propName = 'reAdmission') then ReAdmissionElement := nil
  else if (propName = 'dietPreference') then deletePropertyValue('dietPreference', DietPreferenceList, value) {2}
  else if (propName = 'specialCourtesy') then deletePropertyValue('specialCourtesy', SpecialCourtesyList, value) {2}
  else if (propName = 'specialArrangement') then deletePropertyValue('specialArrangement', SpecialArrangementList, value) {2}
  else if (propName = 'destination') then DestinationElement := nil
  else if (propName = 'dischargeDisposition') then DischargeDispositionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterHospitalization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'preAdmissionIdentifier') then PreAdmissionIdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'origin') then OriginElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'admitSource') then AdmitSourceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'reAdmission') then ReAdmissionElement := new as TFhirCodeableConcept{4}
  else if (propName = 'dietPreference') then replacePropertyValue('dietPreference', DietPreferenceList, existing, new) {2}
  else if (propName = 'specialCourtesy') then replacePropertyValue('specialCourtesy', SpecialCourtesyList, existing, new) {2}
  else if (propName = 'specialArrangement') then replacePropertyValue('specialArrangement', SpecialArrangementList, existing, new) {2}
  else if (propName = 'destination') then DestinationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'dischargeDisposition') then DischargeDispositionElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterHospitalization.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'dietPreference') then DietPreferenceList.move(source, destination){2a}
  else if (propName = 'specialCourtesy') then SpecialCourtesyList.move(source, destination){2a}
  else if (propName = 'specialArrangement') then SpecialArrangementList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterHospitalization.fhirType : string;
begin
  result := 'hospitalization';
end;

function TFhirEncounterHospitalization.Link : TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(inherited Link);
end;

function TFhirEncounterHospitalization.Clone : TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(inherited Clone);
end;

function TFhirEncounterHospitalization.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterHospitalization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterHospitalization)) then
    result := false
  else
  begin
    o := TFhirEncounterHospitalization(other);
    result := compareDeep(preAdmissionIdentifierElement, o.preAdmissionIdentifierElement, true) and 
      compareDeep(originElement, o.originElement, true) and compareDeep(admitSourceElement, o.admitSourceElement, true) and 
      compareDeep(reAdmissionElement, o.reAdmissionElement, true) and compareDeep(dietPreferenceList, o.dietPreferenceList, true) and 
      compareDeep(specialCourtesyList, o.specialCourtesyList, true) and compareDeep(specialArrangementList, o.specialArrangementList, true) and 
      compareDeep(destinationElement, o.destinationElement, true) and compareDeep(dischargeDispositionElement, o.dischargeDispositionElement, true);
  end;
end;

function TFhirEncounterHospitalization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPreAdmissionIdentifier) and isEmptyProp(FOrigin) and isEmptyProp(FAdmitSource) and isEmptyProp(FReAdmission) and isEmptyProp(FdietPreferenceList) and isEmptyProp(FspecialCourtesyList) and isEmptyProp(FspecialArrangementList) and isEmptyProp(FDestination) and isEmptyProp(FDischargeDisposition);
end;

procedure TFhirEncounterHospitalization.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('preAdmissionIdentifier');
  fields.add('origin');
  fields.add('admitSource');
  fields.add('reAdmission');
  fields.add('dietPreference');
  fields.add('specialCourtesy');
  fields.add('specialArrangement');
  fields.add('destination');
  fields.add('dischargeDisposition');
end;

{ TFhirEncounterHospitalization }

Procedure TFhirEncounterHospitalization.SetPreAdmissionIdentifier(value : TFhirIdentifier);
begin
  FPreAdmissionIdentifier.free;
  FPreAdmissionIdentifier := value;
end;

Procedure TFhirEncounterHospitalization.SetOrigin(value : TFhirReference{TFhirLocation});
begin
  FOrigin.free;
  FOrigin := value;
end;

Procedure TFhirEncounterHospitalization.SetAdmitSource(value : TFhirCodeableConcept);
begin
  FAdmitSource.free;
  FAdmitSource := value;
end;

Procedure TFhirEncounterHospitalization.SetReAdmission(value : TFhirCodeableConcept);
begin
  FReAdmission.free;
  FReAdmission := value;
end;

Function TFhirEncounterHospitalization.GetDietPreferenceList : TFhirCodeableConceptList;
begin
  if FDietPreferenceList = nil then
    FDietPreferenceList := TFhirCodeableConceptList.Create;
  result := FDietPreferenceList;
end;

Function TFhirEncounterHospitalization.GetHasDietPreferenceList : boolean;
begin
  result := (FDietPreferenceList <> nil) and (FDietPreferenceList.count > 0);
end;

Function TFhirEncounterHospitalization.GetSpecialCourtesyList : TFhirCodeableConceptList;
begin
  if FSpecialCourtesyList = nil then
    FSpecialCourtesyList := TFhirCodeableConceptList.Create;
  result := FSpecialCourtesyList;
end;

Function TFhirEncounterHospitalization.GetHasSpecialCourtesyList : boolean;
begin
  result := (FSpecialCourtesyList <> nil) and (FSpecialCourtesyList.count > 0);
end;

Function TFhirEncounterHospitalization.GetSpecialArrangementList : TFhirCodeableConceptList;
begin
  if FSpecialArrangementList = nil then
    FSpecialArrangementList := TFhirCodeableConceptList.Create;
  result := FSpecialArrangementList;
end;

Function TFhirEncounterHospitalization.GetHasSpecialArrangementList : boolean;
begin
  result := (FSpecialArrangementList <> nil) and (FSpecialArrangementList.count > 0);
end;

Procedure TFhirEncounterHospitalization.SetDestination(value : TFhirReference{TFhirLocation});
begin
  FDestination.free;
  FDestination := value;
end;

Procedure TFhirEncounterHospitalization.SetDischargeDisposition(value : TFhirCodeableConcept);
begin
  FDischargeDisposition.free;
  FDischargeDisposition := value;
end;

function TFhirEncounterHospitalization.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FPreAdmissionIdentifier.sizeInBytes(magic));
  inc(result, FOrigin.sizeInBytes(magic));
  inc(result, FAdmitSource.sizeInBytes(magic));
  inc(result, FReAdmission.sizeInBytes(magic));
  inc(result, FdietPreferenceList.sizeInBytes(magic));
  inc(result, FspecialCourtesyList.sizeInBytes(magic));
  inc(result, FspecialArrangementList.sizeInBytes(magic));
  inc(result, FDestination.sizeInBytes(magic));
  inc(result, FDischargeDisposition.sizeInBytes(magic));
end;

{ TFhirEncounterHospitalizationListEnumerator }

Constructor TFhirEncounterHospitalizationListEnumerator.Create(list : TFhirEncounterHospitalizationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterHospitalizationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirEncounterHospitalizationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterHospitalizationListEnumerator.GetCurrent : TFhirEncounterHospitalization;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterHospitalizationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterHospitalizationList }
function TFhirEncounterHospitalizationList.AddItem(value: TFhirEncounterHospitalization): TFhirEncounterHospitalization;
begin
  add(value);
  result := value;
end;

function TFhirEncounterHospitalizationList.Append: TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterHospitalizationList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterHospitalizationList.GetEnumerator : TFhirEncounterHospitalizationListEnumerator;
begin
  result := TFhirEncounterHospitalizationListEnumerator.Create(self.link);
end;

function TFhirEncounterHospitalizationList.Clone: TFhirEncounterHospitalizationList;
begin
  result := TFhirEncounterHospitalizationList(inherited Clone);
end;

function TFhirEncounterHospitalizationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterHospitalizationList.GetItemN(index: Integer): TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(ObjectByIndex[index]);
end;

function TFhirEncounterHospitalizationList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterHospitalization;
end;
function TFhirEncounterHospitalizationList.IndexOf(value: TFhirEncounterHospitalization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterHospitalizationList.Insert(index: Integer): TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterHospitalizationList.InsertItem(index: Integer; value: TFhirEncounterHospitalization);
begin
  assert(value is TFhirEncounterHospitalization);
  Inherited Insert(index, value);
end;

function TFhirEncounterHospitalizationList.Item(index: Integer): TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(ObjectByIndex[index]);
end;

function TFhirEncounterHospitalizationList.Link: TFhirEncounterHospitalizationList;
begin
  result := TFhirEncounterHospitalizationList(inherited Link);
end;

procedure TFhirEncounterHospitalizationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterHospitalizationList.SetItemByIndex(index: Integer; value: TFhirEncounterHospitalization);
begin
  assert(value is TFhirEncounterHospitalization);
  FhirEncounterHospitalizations[index] := value;
end;

procedure TFhirEncounterHospitalizationList.SetItemN(index: Integer; value: TFhirEncounterHospitalization);
begin
  assert(value is TFhirEncounterHospitalization);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterLocation }

constructor TFhirEncounterLocation.Create;
begin
  inherited;
end;

destructor TFhirEncounterLocation.Destroy;
begin
  FLocation.free;
  FStatus.free;
  FPhysicalType.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEncounterLocation.Assign(oSource : TFslObject);
begin
  inherited;
  location := TFhirEncounterLocation(oSource).location.Clone;
  FStatus := TFhirEncounterLocation(oSource).FStatus.Link;
  physicalType := TFhirEncounterLocation(oSource).physicalType.Clone;
  period := TFhirEncounterLocation(oSource).period.Clone;
end;

procedure TFhirEncounterLocation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'physicalType') Then
     list.add(self.link, 'physicalType', FPhysicalType.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirEncounterLocation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'location', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FLocation.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'physicalType', 'CodeableConcept', false, TFhirCodeableConcept, FPhysicalType.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
end;

function TFhirEncounterLocation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'location') then
  begin
    Location := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEncounterLocationStatusEnum, CODES_TFhirEncounterLocationStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'physicalType') then
  begin
    PhysicalType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterLocation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEncounterLocation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'location') then result := TFhirReference{TFhirLocation}.Create(){4b}
  else if (propName = 'physicalType') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.Create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterLocation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'location') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'physicalType') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterLocation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'location') then LocationElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'physicalType') then PhysicalTypeElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterLocation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'location') then LocationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEncounterLocationStatusEnum, CODES_TFhirEncounterLocationStatusEnum, new){4}
  else if (propName = 'physicalType') then PhysicalTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterLocation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterLocation.fhirType : string;
begin
  result := 'location';
end;

function TFhirEncounterLocation.Link : TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(inherited Link);
end;

function TFhirEncounterLocation.Clone : TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(inherited Clone);
end;

function TFhirEncounterLocation.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterLocation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterLocation)) then
    result := false
  else
  begin
    o := TFhirEncounterLocation(other);
    result := compareDeep(locationElement, o.locationElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(physicalTypeElement, o.physicalTypeElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirEncounterLocation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLocation) and isEmptyProp(FStatus) and isEmptyProp(FPhysicalType) and isEmptyProp(FPeriod);
end;

procedure TFhirEncounterLocation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('location');
  fields.add('status');
  fields.add('physicalType');
  fields.add('period');
end;

{ TFhirEncounterLocation }

Procedure TFhirEncounterLocation.SetLocation(value : TFhirReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Procedure TFhirEncounterLocation.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirEncounterLocation.GetStatusST : TFhirEncounterLocationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEncounterLocationStatusEnum(0)
  else
    result := TFhirEncounterLocationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEncounterLocationStatusEnum, FStatus.value));
end;

Procedure TFhirEncounterLocation.SetStatusST(value : TFhirEncounterLocationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.Create(SYSTEMS_TFhirEncounterLocationStatusEnum[value], CODES_TFhirEncounterLocationStatusEnum[value]);
end;

Procedure TFhirEncounterLocation.SetPhysicalType(value : TFhirCodeableConcept);
begin
  FPhysicalType.free;
  FPhysicalType := value;
end;

Procedure TFhirEncounterLocation.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirEncounterLocation.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FLocation.sizeInBytes(magic));
  inc(result, FStatus.sizeInBytes(magic));
  inc(result, FPhysicalType.sizeInBytes(magic));
  inc(result, FPeriod.sizeInBytes(magic));
end;

{ TFhirEncounterLocationListEnumerator }

Constructor TFhirEncounterLocationListEnumerator.Create(list : TFhirEncounterLocationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterLocationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirEncounterLocationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterLocationListEnumerator.GetCurrent : TFhirEncounterLocation;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterLocationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterLocationList }
function TFhirEncounterLocationList.AddItem(value: TFhirEncounterLocation): TFhirEncounterLocation;
begin
  add(value);
  result := value;
end;

function TFhirEncounterLocationList.Append: TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterLocationList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterLocationList.GetEnumerator : TFhirEncounterLocationListEnumerator;
begin
  result := TFhirEncounterLocationListEnumerator.Create(self.link);
end;

function TFhirEncounterLocationList.Clone: TFhirEncounterLocationList;
begin
  result := TFhirEncounterLocationList(inherited Clone);
end;

function TFhirEncounterLocationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterLocationList.GetItemN(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(ObjectByIndex[index]);
end;

function TFhirEncounterLocationList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterLocation;
end;
function TFhirEncounterLocationList.IndexOf(value: TFhirEncounterLocation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterLocationList.Insert(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterLocationList.InsertItem(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  Inherited Insert(index, value);
end;

function TFhirEncounterLocationList.Item(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(ObjectByIndex[index]);
end;

function TFhirEncounterLocationList.Link: TFhirEncounterLocationList;
begin
  result := TFhirEncounterLocationList(inherited Link);
end;

procedure TFhirEncounterLocationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterLocationList.SetItemByIndex(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  FhirEncounterLocations[index] := value;
end;

procedure TFhirEncounterLocationList.SetItemN(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounter }

constructor TFhirEncounter.Create;
begin
  inherited;
end;

destructor TFhirEncounter.Destroy;
begin
  FIdentifierList.free;
  FStatus.free;
  FStatusHistoryList.free;
  FClass_.free;
  FClassHistoryList.free;
  FType_List.free;
  FServiceType.free;
  FPriority.free;
  FSubject.free;
  FEpisodeOfCareList.free;
  FBasedOnList.free;
  FParticipantList.free;
  FAppointmentList.free;
  FPeriod.free;
  FLength.free;
  FReasonCodeList.free;
  FReasonReferenceList.free;
  FDiagnosisList.free;
  FAccountList.free;
  FHospitalization.free;
  FLocationList.free;
  FServiceProvider.free;
  FPartOf.free;
  inherited;
end;

function TFhirEncounter.GetResourceType : TFhirResourceType;
begin
  result := frtEncounter;
end;

procedure TFhirEncounter.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEncounter(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEncounter(oSource).FIdentifierList);
  end;
  FStatus := TFhirEncounter(oSource).FStatus.Link;
  if (TFhirEncounter(oSource).FStatusHistoryList = nil) then
  begin
    FStatusHistoryList.free;
    FStatusHistoryList := nil;
  end
  else
  begin
    if FStatusHistoryList = nil then
      FStatusHistoryList := TFhirEncounterStatusHistoryList.Create;
    FStatusHistoryList.Assign(TFhirEncounter(oSource).FStatusHistoryList);
  end;
  class_ := TFhirEncounter(oSource).class_.Clone;
  if (TFhirEncounter(oSource).FClassHistoryList = nil) then
  begin
    FClassHistoryList.free;
    FClassHistoryList := nil;
  end
  else
  begin
    if FClassHistoryList = nil then
      FClassHistoryList := TFhirEncounterClassHistoryList.Create;
    FClassHistoryList.Assign(TFhirEncounter(oSource).FClassHistoryList);
  end;
  if (TFhirEncounter(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirEncounter(oSource).FType_List);
  end;
  serviceType := TFhirEncounter(oSource).serviceType.Clone;
  priority := TFhirEncounter(oSource).priority.Clone;
  subject := TFhirEncounter(oSource).subject.Clone;
  if (TFhirEncounter(oSource).FEpisodeOfCareList = nil) then
  begin
    FEpisodeOfCareList.free;
    FEpisodeOfCareList := nil;
  end
  else
  begin
    if FEpisodeOfCareList = nil then
      FEpisodeOfCareList := TFhirReferenceList{TFhirEpisodeOfCare}.Create;
    FEpisodeOfCareList.Assign(TFhirEncounter(oSource).FEpisodeOfCareList);
  end;
  if (TFhirEncounter(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList{TFhirServiceRequest}.Create;
    FBasedOnList.Assign(TFhirEncounter(oSource).FBasedOnList);
  end;
  if (TFhirEncounter(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirEncounterParticipantList.Create;
    FParticipantList.Assign(TFhirEncounter(oSource).FParticipantList);
  end;
  if (TFhirEncounter(oSource).FAppointmentList = nil) then
  begin
    FAppointmentList.free;
    FAppointmentList := nil;
  end
  else
  begin
    if FAppointmentList = nil then
      FAppointmentList := TFhirReferenceList{TFhirAppointment}.Create;
    FAppointmentList.Assign(TFhirEncounter(oSource).FAppointmentList);
  end;
  period := TFhirEncounter(oSource).period.Clone;
  length := TFhirEncounter(oSource).length.Clone;
  if (TFhirEncounter(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirEncounter(oSource).FReasonCodeList);
  end;
  if (TFhirEncounter(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList{TFhirCondition}.Create;
    FReasonReferenceList.Assign(TFhirEncounter(oSource).FReasonReferenceList);
  end;
  if (TFhirEncounter(oSource).FDiagnosisList = nil) then
  begin
    FDiagnosisList.free;
    FDiagnosisList := nil;
  end
  else
  begin
    if FDiagnosisList = nil then
      FDiagnosisList := TFhirEncounterDiagnosisList.Create;
    FDiagnosisList.Assign(TFhirEncounter(oSource).FDiagnosisList);
  end;
  if (TFhirEncounter(oSource).FAccountList = nil) then
  begin
    FAccountList.free;
    FAccountList := nil;
  end
  else
  begin
    if FAccountList = nil then
      FAccountList := TFhirReferenceList{TFhirAccount}.Create;
    FAccountList.Assign(TFhirEncounter(oSource).FAccountList);
  end;
  hospitalization := TFhirEncounter(oSource).hospitalization.Clone;
  if (TFhirEncounter(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirEncounterLocationList.Create;
    FLocationList.Assign(TFhirEncounter(oSource).FLocationList);
  end;
  serviceProvider := TFhirEncounter(oSource).serviceProvider.Clone;
  partOf := TFhirEncounter(oSource).partOf.Clone;
end;

procedure TFhirEncounter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusHistory') Then
    list.addAll(self, 'statusHistory', FStatusHistoryList);
  if (child_name = 'class') Then
     list.add(self.link, 'class', FClass_.Link);
  if (child_name = 'classHistory') Then
    list.addAll(self, 'classHistory', FClassHistoryList);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'serviceType') Then
     list.add(self.link, 'serviceType', FServiceType.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'episodeOfCare') Then
    list.addAll(self, 'episodeOfCare', FEpisodeOfCareList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'appointment') Then
    list.addAll(self, 'appointment', FAppointmentList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'length') Then
     list.add(self.link, 'length', FLength.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'diagnosis') Then
    list.addAll(self, 'diagnosis', FDiagnosisList);
  if (child_name = 'account') Then
    list.addAll(self, 'account', FAccountList);
  if (child_name = 'hospitalization') Then
     list.add(self.link, 'hospitalization', FHospitalization.Link);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'serviceProvider') Then
     list.add(self.link, 'serviceProvider', FServiceProvider.Link);
  if (child_name = 'partOf') Then
     list.add(self.link, 'partOf', FPartOf.Link);
end;

procedure TFhirEncounter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'statusHistory', '', true, TFhirEncounterStatusHistory, FStatusHistoryList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'class', 'Coding', false, TFhirCoding, FClass_.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'classHistory', '', true, TFhirEncounterClassHistory, FClassHistoryList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'serviceType', 'CodeableConcept', false, TFhirCodeableConcept, FServiceType.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'subject', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FSubject.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'episodeOfCare', 'Reference(EpisodeOfCare)', true, TFhirReference{TFhirEpisodeOfCare}, FEpisodeOfCareList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'basedOn', 'Reference(ServiceRequest)', true, TFhirReference{TFhirServiceRequest}, FBasedOnList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'participant', '', true, TFhirEncounterParticipant, FParticipantList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'appointment', 'Reference(Appointment)', true, TFhirReference{TFhirAppointment}, FAppointmentList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'length', 'Duration', false, TFhirDuration, FLength.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'reasonReference', 'Reference(Condition)', true, TFhirReference{TFhirCondition}, FReasonReferenceList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'diagnosis', '', true, TFhirEncounterDiagnosis, FDiagnosisList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'account', 'Reference(Account)', true, TFhirReference{TFhirAccount}, FAccountList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'hospitalization', '', false, TFhirEncounterHospitalization, FHospitalization.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'location', '', true, TFhirEncounterLocation, FLocationList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'serviceProvider', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FServiceProvider.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'partOf', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FPartOf.Link));{2}
end;

function TFhirEncounter.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEncounterStatusEnum, CODES_TFhirEncounterStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'statusHistory') then
  begin
    StatusHistoryList.add(propValue as TFhirEncounterStatusHistory){2a};
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'classHistory') then
  begin
    ClassHistoryList.add(propValue as TFhirEncounterClassHistory){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'serviceType') then
  begin
    ServiceType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'episodeOfCare') then
  begin
    EpisodeOfCareList.add(propValue as TFhirReference{TFhirEpisodeOfCare}){2a};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference{TFhirServiceRequest}){2a};
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirEncounterParticipant){2a};
    result := propValue;
  end
  else if (propName = 'appointment') then
  begin
    AppointmentList.add(propValue as TFhirReference{TFhirAppointment}){2a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'length') then
  begin
    Length := propValue as TFhirDuration{4b};
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference{TFhirCondition}){2a};
    result := propValue;
  end
  else if (propName = 'diagnosis') then
  begin
    DiagnosisList.add(propValue as TFhirEncounterDiagnosis){2a};
    result := propValue;
  end
  else if (propName = 'account') then
  begin
    AccountList.add(propValue as TFhirReference{TFhirAccount}){2a};
    result := propValue;
  end
  else if (propName = 'hospitalization') then
  begin
    Hospitalization := propValue as TFhirEncounterHospitalization{4b};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(propValue as TFhirEncounterLocation){2a};
    result := propValue;
  end
  else if (propName = 'serviceProvider') then
  begin
    ServiceProvider := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOf := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirEncounter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'statusHistory') then StatusHistoryList.insertItem(index, propValue as TFhirEncounterStatusHistory){2a}
  else if (propName = 'classHistory') then ClassHistoryList.insertItem(index, propValue as TFhirEncounterClassHistory){2a}
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'episodeOfCare') then EpisodeOfCareList.insertItem(index, propValue as TFhirReference{TFhirEpisodeOfCare}){2a}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference{TFhirServiceRequest}){2a}
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirEncounterParticipant){2a}
  else if (propName = 'appointment') then AppointmentList.insertItem(index, propValue as TFhirReference{TFhirAppointment}){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference{TFhirCondition}){2a}
  else if (propName = 'diagnosis') then DiagnosisList.insertItem(index, propValue as TFhirEncounterDiagnosis){2a}
  else if (propName = 'account') then AccountList.insertItem(index, propValue as TFhirReference{TFhirAccount}){2a}
  else if (propName = 'location') then LocationList.insertItem(index, propValue as TFhirEncounterLocation){2a}
  else inherited;
end;

function TFhirEncounter.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'statusHistory') then result := StatusHistoryList.new(){2}
  else if (propName = 'class') then result := TFhirCoding.Create(){4b}
  else if (propName = 'classHistory') then result := ClassHistoryList.new(){2}
  else if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'serviceType') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'priority') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'subject') then result := TFhirReference{TFhirPatient}.Create(){4b}
  else if (propName = 'episodeOfCare') then result := EpisodeOfCareList.new(){2}
  else if (propName = 'basedOn') then result := BasedOnList.new(){2}
  else if (propName = 'participant') then result := ParticipantList.new(){2}
  else if (propName = 'appointment') then result := AppointmentList.new(){2}
  else if (propName = 'period') then result := TFhirPeriod.Create(){4b}
  else if (propName = 'length') then result := TFhirDuration.Create(){4b}
  else if (propName = 'reasonCode') then result := ReasonCodeList.new(){2}
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new(){2}
  else if (propName = 'diagnosis') then result := DiagnosisList.new(){2}
  else if (propName = 'account') then result := AccountList.new(){2}
  else if (propName = 'hospitalization') then result := TFhirEncounterHospitalization.Create(){4b}
  else if (propName = 'location') then result := LocationList.new(){2}
  else if (propName = 'serviceProvider') then result := TFhirReference{TFhirOrganization}.Create(){4b}
  else if (propName = 'partOf') then result := TFhirReference{TFhirEncounter}.Create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusHistory') then result := ''
  else if (propName = 'class') then result := 'Coding'
  else if (propName = 'classHistory') then result := ''
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'serviceType') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'episodeOfCare') then result := 'Reference'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'participant') then result := ''
  else if (propName = 'appointment') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'length') then result := 'Duration'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'diagnosis') then result := ''
  else if (propName = 'account') then result := 'Reference'
  else if (propName = 'hospitalization') then result := ''
  else if (propName = 'location') then result := ''
  else if (propName = 'serviceProvider') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounter.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusHistory') then deletePropertyValue('statusHistory', StatusHistoryList, value) {2}
  else if (propName = 'class') then Class_Element := nil
  else if (propName = 'classHistory') then deletePropertyValue('classHistory', ClassHistoryList, value) {2}
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'serviceType') then ServiceTypeElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'episodeOfCare') then deletePropertyValue('episodeOfCare', EpisodeOfCareList, value) {2}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {2}
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value) {2}
  else if (propName = 'appointment') then deletePropertyValue('appointment', AppointmentList, value) {2}
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'length') then LengthElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value) {2}
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value) {2}
  else if (propName = 'diagnosis') then deletePropertyValue('diagnosis', DiagnosisList, value) {2}
  else if (propName = 'account') then deletePropertyValue('account', AccountList, value) {2}
  else if (propName = 'hospitalization') then HospitalizationElement := nil
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value) {2}
  else if (propName = 'serviceProvider') then ServiceProviderElement := nil
  else if (propName = 'partOf') then PartOfElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEncounterStatusEnum, CODES_TFhirEncounterStatusEnum, new){4}
  else if (propName = 'statusHistory') then replacePropertyValue('statusHistory', StatusHistoryList, existing, new) {2}
  else if (propName = 'class') then Class_Element := new as TFhirCoding{4}
  else if (propName = 'classHistory') then replacePropertyValue('classHistory', ClassHistoryList, existing, new) {2}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'serviceType') then ServiceTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'episodeOfCare') then replacePropertyValue('episodeOfCare', EpisodeOfCareList, existing, new) {2}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {2}
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new) {2}
  else if (propName = 'appointment') then replacePropertyValue('appointment', AppointmentList, existing, new) {2}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'length') then LengthElement := new as TFhirDuration{4}
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new) {2}
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new) {2}
  else if (propName = 'diagnosis') then replacePropertyValue('diagnosis', DiagnosisList, existing, new) {2}
  else if (propName = 'account') then replacePropertyValue('account', AccountList, existing, new) {2}
  else if (propName = 'hospitalization') then HospitalizationElement := new as TFhirEncounterHospitalization{4}
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new) {2}
  else if (propName = 'serviceProvider') then ServiceProviderElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'partOf') then PartOfElement := new as TFhirReference{TFhirEncounter}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounter.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'statusHistory') then StatusHistoryList.move(source, destination){2a}
  else if (propName = 'classHistory') then ClassHistoryList.move(source, destination){2a}
  else if (propName = 'type') then Type_List.move(source, destination){2a}
  else if (propName = 'episodeOfCare') then EpisodeOfCareList.move(source, destination){2a}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination){2a}
  else if (propName = 'participant') then ParticipantList.move(source, destination){2a}
  else if (propName = 'appointment') then AppointmentList.move(source, destination){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination){2a}
  else if (propName = 'diagnosis') then DiagnosisList.move(source, destination){2a}
  else if (propName = 'account') then AccountList.move(source, destination){2a}
  else if (propName = 'location') then LocationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounter.fhirType : string;
begin
  result := 'Encounter';
end;

function TFhirEncounter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FstatusHistoryList) and isEmptyProp(FClass_) and isEmptyProp(FclassHistoryList) and isEmptyProp(Ftype_List) and isEmptyProp(FServiceType) and isEmptyProp(FPriority) and isEmptyProp(FSubject) and isEmptyProp(FepisodeOfCareList) and isEmptyProp(FbasedOnList) and isEmptyProp(FparticipantList) and isEmptyProp(FappointmentList) and isEmptyProp(FPeriod) and isEmptyProp(FLength) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FdiagnosisList) and isEmptyProp(FaccountList) and isEmptyProp(FHospitalization) and isEmptyProp(FlocationList) and isEmptyProp(FServiceProvider) and isEmptyProp(FPartOf);
end;

function TFhirEncounter.equals(other : TObject) : boolean; 
var
  o : TFhirEncounter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounter)) then
    result := false
  else
  begin
    o := TFhirEncounter(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusHistoryList, o.statusHistoryList, true) and compareDeep(class_Element, o.class_Element, true) and 
      compareDeep(classHistoryList, o.classHistoryList, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(serviceTypeElement, o.serviceTypeElement, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(episodeOfCareList, o.episodeOfCareList, true) and 
      compareDeep(basedOnList, o.basedOnList, true) and compareDeep(participantList, o.participantList, true) and 
      compareDeep(appointmentList, o.appointmentList, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(lengthElement, o.lengthElement, true) and compareDeep(reasonCodeList, o.reasonCodeList, true) and 
      compareDeep(reasonReferenceList, o.reasonReferenceList, true) and compareDeep(diagnosisList, o.diagnosisList, true) and 
      compareDeep(accountList, o.accountList, true) and compareDeep(hospitalizationElement, o.hospitalizationElement, true) and 
      compareDeep(locationList, o.locationList, true) and compareDeep(serviceProviderElement, o.serviceProviderElement, true) and 
      compareDeep(partOfElement, o.partOfElement, true);
  end;
end;

function TFhirEncounter.Link : TFhirEncounter;
begin
  result := TFhirEncounter(inherited Link);
end;

function TFhirEncounter.Clone : TFhirEncounter;
begin
  result := TFhirEncounter(inherited Clone);
end;

procedure TFhirEncounter.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('statusHistory');
  fields.add('class');
  fields.add('classHistory');
  fields.add('type');
  fields.add('serviceType');
  fields.add('priority');
  fields.add('subject');
  fields.add('episodeOfCare');
  fields.add('basedOn');
  fields.add('participant');
  fields.add('appointment');
  fields.add('period');
  fields.add('length');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('diagnosis');
  fields.add('account');
  fields.add('hospitalization');
  fields.add('location');
  fields.add('serviceProvider');
  fields.add('partOf');
end;

{ TFhirEncounter }

Function TFhirEncounter.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirEncounter.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirEncounter.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirEncounter.GetStatusST : TFhirEncounterStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEncounterStatusEnum(0)
  else
    result := TFhirEncounterStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEncounterStatusEnum, FStatus.value));
end;

Procedure TFhirEncounter.SetStatusST(value : TFhirEncounterStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.Create(SYSTEMS_TFhirEncounterStatusEnum[value], CODES_TFhirEncounterStatusEnum[value]);
end;

Function TFhirEncounter.GetStatusHistoryList : TFhirEncounterStatusHistoryList;
begin
  if FStatusHistoryList = nil then
    FStatusHistoryList := TFhirEncounterStatusHistoryList.Create;
  result := FStatusHistoryList;
end;

Function TFhirEncounter.GetHasStatusHistoryList : boolean;
begin
  result := (FStatusHistoryList <> nil) and (FStatusHistoryList.count > 0);
end;

Procedure TFhirEncounter.SetClass_(value : TFhirCoding);
begin
  FClass_.free;
  FClass_ := value;
end;

Function TFhirEncounter.GetClassHistoryList : TFhirEncounterClassHistoryList;
begin
  if FClassHistoryList = nil then
    FClassHistoryList := TFhirEncounterClassHistoryList.Create;
  result := FClassHistoryList;
end;

Function TFhirEncounter.GetHasClassHistoryList : boolean;
begin
  result := (FClassHistoryList <> nil) and (FClassHistoryList.count > 0);
end;

Function TFhirEncounter.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

Function TFhirEncounter.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Procedure TFhirEncounter.SetServiceType(value : TFhirCodeableConcept);
begin
  FServiceType.free;
  FServiceType := value;
end;

Procedure TFhirEncounter.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value;
end;

Procedure TFhirEncounter.SetSubject(value : TFhirReference{TFhirPatient});
begin
  FSubject.free;
  FSubject := value;
end;

Function TFhirEncounter.GetEpisodeOfCareList : TFhirReferenceList{TFhirEpisodeOfCare};
begin
  if FEpisodeOfCareList = nil then
    FEpisodeOfCareList := TFhirReferenceList{TFhirEpisodeOfCare}.Create;
  result := FEpisodeOfCareList;
end;

Function TFhirEncounter.GetHasEpisodeOfCareList : boolean;
begin
  result := (FEpisodeOfCareList <> nil) and (FEpisodeOfCareList.count > 0);
end;

Function TFhirEncounter.GetBasedOnList : TFhirReferenceList{TFhirServiceRequest};
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList{TFhirServiceRequest}.Create;
  result := FBasedOnList;
end;

Function TFhirEncounter.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

Function TFhirEncounter.GetParticipantList : TFhirEncounterParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirEncounterParticipantList.Create;
  result := FParticipantList;
end;

Function TFhirEncounter.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

Function TFhirEncounter.GetAppointmentList : TFhirReferenceList{TFhirAppointment};
begin
  if FAppointmentList = nil then
    FAppointmentList := TFhirReferenceList{TFhirAppointment}.Create;
  result := FAppointmentList;
end;

Function TFhirEncounter.GetHasAppointmentList : boolean;
begin
  result := (FAppointmentList <> nil) and (FAppointmentList.count > 0);
end;

Procedure TFhirEncounter.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirEncounter.SetLength(value : TFhirDuration);
begin
  FLength.free;
  FLength := value;
end;

Function TFhirEncounter.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

Function TFhirEncounter.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

Function TFhirEncounter.GetReasonReferenceList : TFhirReferenceList{TFhirCondition};
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList{TFhirCondition}.Create;
  result := FReasonReferenceList;
end;

Function TFhirEncounter.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

Function TFhirEncounter.GetDiagnosisList : TFhirEncounterDiagnosisList;
begin
  if FDiagnosisList = nil then
    FDiagnosisList := TFhirEncounterDiagnosisList.Create;
  result := FDiagnosisList;
end;

Function TFhirEncounter.GetHasDiagnosisList : boolean;
begin
  result := (FDiagnosisList <> nil) and (FDiagnosisList.count > 0);
end;

Function TFhirEncounter.GetAccountList : TFhirReferenceList{TFhirAccount};
begin
  if FAccountList = nil then
    FAccountList := TFhirReferenceList{TFhirAccount}.Create;
  result := FAccountList;
end;

Function TFhirEncounter.GetHasAccountList : boolean;
begin
  result := (FAccountList <> nil) and (FAccountList.count > 0);
end;

Procedure TFhirEncounter.SetHospitalization(value : TFhirEncounterHospitalization);
begin
  FHospitalization.free;
  FHospitalization := value;
end;

Function TFhirEncounter.GetLocationList : TFhirEncounterLocationList;
begin
  if FLocationList = nil then
    FLocationList := TFhirEncounterLocationList.Create;
  result := FLocationList;
end;

Function TFhirEncounter.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

Procedure TFhirEncounter.SetServiceProvider(value : TFhirReference{TFhirOrganization});
begin
  FServiceProvider.free;
  FServiceProvider := value;
end;

Procedure TFhirEncounter.SetPartOf(value : TFhirReference{TFhirEncounter});
begin
  FPartOf.free;
  FPartOf := value;
end;

function TFhirEncounter.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FidentifierList.sizeInBytes(magic));
  inc(result, FStatus.sizeInBytes(magic));
  inc(result, FstatusHistoryList.sizeInBytes(magic));
  inc(result, FClass_.sizeInBytes(magic));
  inc(result, FclassHistoryList.sizeInBytes(magic));
  inc(result, Ftype_List.sizeInBytes(magic));
  inc(result, FServiceType.sizeInBytes(magic));
  inc(result, FPriority.sizeInBytes(magic));
  inc(result, FSubject.sizeInBytes(magic));
  inc(result, FepisodeOfCareList.sizeInBytes(magic));
  inc(result, FbasedOnList.sizeInBytes(magic));
  inc(result, FparticipantList.sizeInBytes(magic));
  inc(result, FappointmentList.sizeInBytes(magic));
  inc(result, FPeriod.sizeInBytes(magic));
  inc(result, FLength.sizeInBytes(magic));
  inc(result, FreasonCodeList.sizeInBytes(magic));
  inc(result, FreasonReferenceList.sizeInBytes(magic));
  inc(result, FdiagnosisList.sizeInBytes(magic));
  inc(result, FaccountList.sizeInBytes(magic));
  inc(result, FHospitalization.sizeInBytes(magic));
  inc(result, FlocationList.sizeInBytes(magic));
  inc(result, FServiceProvider.sizeInBytes(magic));
  inc(result, FPartOf.sizeInBytes(magic));
end;

{ TFhirEncounterListEnumerator }

Constructor TFhirEncounterListEnumerator.Create(list : TFhirEncounterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirEncounterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterListEnumerator.GetCurrent : TFhirEncounter;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterList }
function TFhirEncounterList.AddItem(value: TFhirEncounter): TFhirEncounter;
begin
  add(value);
  result := value;
end;

function TFhirEncounterList.Append: TFhirEncounter;
begin
  result := TFhirEncounter.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterList.GetEnumerator : TFhirEncounterListEnumerator;
begin
  result := TFhirEncounterListEnumerator.Create(self.link);
end;

function TFhirEncounterList.Clone: TFhirEncounterList;
begin
  result := TFhirEncounterList(inherited Clone);
end;

function TFhirEncounterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterList.GetItemN(index: Integer): TFhirEncounter;
begin
  result := TFhirEncounter(ObjectByIndex[index]);
end;

function TFhirEncounterList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounter;
end;
function TFhirEncounterList.IndexOf(value: TFhirEncounter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterList.Insert(index: Integer): TFhirEncounter;
begin
  result := TFhirEncounter.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterList.InsertItem(index: Integer; value: TFhirEncounter);
begin
  assert(value is TFhirEncounter);
  Inherited Insert(index, value);
end;

function TFhirEncounterList.Item(index: Integer): TFhirEncounter;
begin
  result := TFhirEncounter(ObjectByIndex[index]);
end;

function TFhirEncounterList.Link: TFhirEncounterList;
begin
  result := TFhirEncounterList(inherited Link);
end;

procedure TFhirEncounterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterList.SetItemByIndex(index: Integer; value: TFhirEncounter);
begin
  assert(value is TFhirEncounter);
  FhirEncounters[index] := value;
end;

procedure TFhirEncounterList.SetItemN(index: Integer; value: TFhirEncounter);
begin
  assert(value is TFhirEncounter);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ENCOUNTER}

{$IFDEF FHIR_ENDPOINT}

{ TFhirEndpoint }

constructor TFhirEndpoint.Create;
begin
  inherited;
end;

destructor TFhirEndpoint.Destroy;
begin
  FIdentifierList.free;
  FStatus.free;
  FConnectionType.free;
  FName.free;
  FManagingOrganization.free;
  FContactList.free;
  FPeriod.free;
  FPayloadTypeList.free;
  FPayloadMimeTypeList.free;
  FAddress.free;
  FHeaderList.free;
  inherited;
end;

function TFhirEndpoint.GetResourceType : TFhirResourceType;
begin
  result := frtEndpoint;
end;

procedure TFhirEndpoint.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEndpoint(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEndpoint(oSource).FIdentifierList);
  end;
  FStatus := TFhirEndpoint(oSource).FStatus.Link;
  connectionType := TFhirEndpoint(oSource).connectionType.Clone;
  nameElement := TFhirEndpoint(oSource).nameElement.Clone;
  managingOrganization := TFhirEndpoint(oSource).managingOrganization.Clone;
  if (TFhirEndpoint(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactPointList.Create;
    FContactList.Assign(TFhirEndpoint(oSource).FContactList);
  end;
  period := TFhirEndpoint(oSource).period.Clone;
  if (TFhirEndpoint(oSource).FPayloadTypeList = nil) then
  begin
    FPayloadTypeList.free;
    FPayloadTypeList := nil;
  end
  else
  begin
    if FPayloadTypeList = nil then
      FPayloadTypeList := TFhirCodeableConceptList.Create;
    FPayloadTypeList.Assign(TFhirEndpoint(oSource).FPayloadTypeList);
  end;
  if (TFhirEndpoint(oSource).FPayloadMimeTypeList = nil) then
  begin
    FPayloadMimeTypeList.free;
    FPayloadMimeTypeList := nil;
  end
  else
  begin
    if FPayloadMimeTypeList = nil then
      FPayloadMimeTypeList := TFhirCodeList.Create;
    FPayloadMimeTypeList.Assign(TFhirEndpoint(oSource).FPayloadMimeTypeList);
  end;
  addressElement := TFhirEndpoint(oSource).addressElement.Clone;
  if (TFhirEndpoint(oSource).FHeaderList = nil) then
  begin
    FHeaderList.free;
    FHeaderList := nil;
  end
  else
  begin
    if FHeaderList = nil then
      FHeaderList := TFhirStringList.Create;
    FHeaderList.Assign(TFhirEndpoint(oSource).FHeaderList);
  end;
end;

procedure TFhirEndpoint.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'connectionType') Then
     list.add(self.link, 'connectionType', FConnectionType.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'managingOrganization') Then
     list.add(self.link, 'managingOrganization', FManagingOrganization.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'payloadType') Then
    list.addAll(self, 'payloadType', FPayloadTypeList);
  if (child_name = 'payloadMimeType') Then
    list.addAll(self, 'payloadMimeType', FPayloadMimeTypeList);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
  if (child_name = 'header') Then
    list.addAll(self, 'header', FHeaderList);
end;

procedure TFhirEndpoint.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'connectionType', 'Coding', false, TFhirCoding, FConnectionType.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'managingOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FManagingOrganization.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'contact', 'ContactPoint', true, TFhirContactPoint, FContactList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'payloadType', 'CodeableConcept', true, TFhirCodeableConcept, FPayloadTypeList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'payloadMimeType', 'code', true, TFhirCode, FPayloadMimeTypeList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'address', 'url', false, TFhirUrl, FAddress.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'header', 'string', true, TFhirString, FHeaderList.Link)){3};
end;

function TFhirEndpoint.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEndpointStatusEnum, CODES_TFhirEndpointStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'connectionType') then
  begin
    ConnectionType := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'payloadType') then
  begin
    PayloadTypeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'payloadMimeType') then
  begin
    PayloadMimeTypeList.add(asCode(propValue)){2};     result := propValue;

  end
  else if (propName = 'address') then
  begin
    AddressElement := asUrl(propValue){5a};
    result := propValue;
  end
  else if (propName = 'header') then
  begin
    HeaderList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirEndpoint.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactPoint){2a}
  else if (propName = 'payloadType') then PayloadTypeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'payloadMimeType') then PayloadMimeTypeList.insertItem(index, asCode(propValue)){2}
  else if (propName = 'header') then HeaderList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirEndpoint.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'connectionType') then result := TFhirCoding.Create(){4b}
  else if (propName = 'name') then result := TFhirString.Create() {5b}
  else if (propName = 'managingOrganization') then result := TFhirReference{TFhirOrganization}.Create(){4b}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'period') then result := TFhirPeriod.Create(){4b}
  else if (propName = 'payloadType') then result := PayloadTypeList.new(){2}
  else if (propName = 'payloadMimeType') then result := PayloadMimeTypeList.new(){2}
  else if (propName = 'address') then result := TFhirUrl.Create() {5b}
  else if (propName = 'header') then result := HeaderList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEndpoint.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'connectionType') then result := 'Coding'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'payloadType') then result := 'CodeableConcept'
  else if (propName = 'payloadMimeType') then result := 'code'
  else if (propName = 'address') then result := 'url'
  else if (propName = 'header') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEndpoint.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'connectionType') then ConnectionTypeElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'payloadType') then deletePropertyValue('payloadType', PayloadTypeList, value) {2}
  else if (propName = 'payloadMimeType') then deletePropertyValue('payloadMimeType', PayloadMimeTypeList, value) {2}
  else if (propName = 'address') then AddressElement := nil
  else if (propName = 'header') then deletePropertyValue('header', HeaderList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEndpoint.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEndpointStatusEnum, CODES_TFhirEndpointStatusEnum, new){4}
  else if (propName = 'connectionType') then ConnectionTypeElement := new as TFhirCoding{4}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'payloadType') then replacePropertyValue('payloadType', PayloadTypeList, existing, new) {2}
  else if (propName = 'payloadMimeType') then replacePropertyValue('payloadMimeType', PayloadMimeTypeList, existing, new) {2}
  else if (propName = 'address') then AddressElement := asUrl(new){5b}
  else if (propName = 'header') then replacePropertyValue('header', HeaderList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEndpoint.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'payloadType') then PayloadTypeList.move(source, destination){2a}
  else if (propName = 'payloadMimeType') then PayloadMimeTypeList.move(source, destination){2}
  else if (propName = 'header') then HeaderList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEndpoint.fhirType : string;
begin
  result := 'Endpoint';
end;

function TFhirEndpoint.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FConnectionType) and isEmptyProp(FName) and isEmptyProp(FManagingOrganization) and isEmptyProp(FcontactList) and isEmptyProp(FPeriod) and isEmptyProp(FpayloadTypeList) and isEmptyProp(FpayloadMimeTypeList) and isEmptyProp(FAddress) and isEmptyProp(FheaderList);
end;

function TFhirEndpoint.equals(other : TObject) : boolean; 
var
  o : TFhirEndpoint;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEndpoint)) then
    result := false
  else
  begin
    o := TFhirEndpoint(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(connectionTypeElement, o.connectionTypeElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(managingOrganizationElement, o.managingOrganizationElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(payloadTypeList, o.payloadTypeList, true) and compareDeep(payloadMimeTypeList, o.payloadMimeTypeList, true) and 
      compareDeep(addressElement, o.addressElement, true) and compareDeep(headerList, o.headerList, true);
  end;
end;

function TFhirEndpoint.Link : TFhirEndpoint;
begin
  result := TFhirEndpoint(inherited Link);
end;

function TFhirEndpoint.Clone : TFhirEndpoint;
begin
  result := TFhirEndpoint(inherited Clone);
end;

procedure TFhirEndpoint.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('connectionType');
  fields.add('name');
  fields.add('managingOrganization');
  fields.add('contact');
  fields.add('period');
  fields.add('payloadType');
  fields.add('payloadMimeType');
  fields.add('address');
  fields.add('header');
end;

{ TFhirEndpoint }

Function TFhirEndpoint.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirEndpoint.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirEndpoint.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirEndpoint.GetStatusST : TFhirEndpointStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEndpointStatusEnum(0)
  else
    result := TFhirEndpointStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEndpointStatusEnum, FStatus.value));
end;

Procedure TFhirEndpoint.SetStatusST(value : TFhirEndpointStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.Create(SYSTEMS_TFhirEndpointStatusEnum[value], CODES_TFhirEndpointStatusEnum[value]);
end;

Procedure TFhirEndpoint.SetConnectionType(value : TFhirCoding);
begin
  FConnectionType.free;
  FConnectionType := value;
end;

Procedure TFhirEndpoint.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirEndpoint.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirEndpoint.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.Create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirEndpoint.SetManagingOrganization(value : TFhirReference{TFhirOrganization});
begin
  FManagingOrganization.free;
  FManagingOrganization := value;
end;

Function TFhirEndpoint.GetContactList : TFhirContactPointList;
begin
  if FContactList = nil then
    FContactList := TFhirContactPointList.Create;
  result := FContactList;
end;

Function TFhirEndpoint.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Procedure TFhirEndpoint.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Function TFhirEndpoint.GetPayloadTypeList : TFhirCodeableConceptList;
begin
  if FPayloadTypeList = nil then
    FPayloadTypeList := TFhirCodeableConceptList.Create;
  result := FPayloadTypeList;
end;

Function TFhirEndpoint.GetHasPayloadTypeList : boolean;
begin
  result := (FPayloadTypeList <> nil) and (FPayloadTypeList.count > 0);
end;

Function TFhirEndpoint.GetPayloadMimeTypeList : TFhirCodeList;
begin
  if FPayloadMimeTypeList = nil then
    FPayloadMimeTypeList := TFhirCodeList.Create;
  result := FPayloadMimeTypeList;
end;

Function TFhirEndpoint.GetHasPayloadMimeTypeList : boolean;
begin
  result := (FPayloadMimeTypeList <> nil) and (FPayloadMimeTypeList.count > 0);
end;

Procedure TFhirEndpoint.SetAddress(value : TFhirUrl);
begin
  FAddress.free;
  FAddress := value;
end;

Function TFhirEndpoint.GetAddressST : String;
begin
  if FAddress = nil then
    result := ''
  else
    result := FAddress.value;
end;

Procedure TFhirEndpoint.SetAddressST(value : String);
begin
  if value <> '' then
  begin
    if FAddress = nil then
      FAddress := TFhirUrl.Create;
    FAddress.value := value
  end
  else if FAddress <> nil then
    FAddress.value := '';
end;

Function TFhirEndpoint.GetHeaderList : TFhirStringList;
begin
  if FHeaderList = nil then
    FHeaderList := TFhirStringList.Create;
  result := FHeaderList;
end;

Function TFhirEndpoint.GetHasHeaderList : boolean;
begin
  result := (FHeaderList <> nil) and (FHeaderList.count > 0);
end;

function TFhirEndpoint.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FidentifierList.sizeInBytes(magic));
  inc(result, FStatus.sizeInBytes(magic));
  inc(result, FConnectionType.sizeInBytes(magic));
  inc(result, FName.sizeInBytes(magic));
  inc(result, FManagingOrganization.sizeInBytes(magic));
  inc(result, FcontactList.sizeInBytes(magic));
  inc(result, FPeriod.sizeInBytes(magic));
  inc(result, FpayloadTypeList.sizeInBytes(magic));
  inc(result, FpayloadMimeTypeList.sizeInBytes(magic));
  inc(result, FAddress.sizeInBytes(magic));
  inc(result, FheaderList.sizeInBytes(magic));
end;

{ TFhirEndpointListEnumerator }

Constructor TFhirEndpointListEnumerator.Create(list : TFhirEndpointList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEndpointListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirEndpointListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEndpointListEnumerator.GetCurrent : TFhirEndpoint;
begin
  Result := FList[FIndex];
end;

function TFhirEndpointListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEndpointList }
function TFhirEndpointList.AddItem(value: TFhirEndpoint): TFhirEndpoint;
begin
  add(value);
  result := value;
end;

function TFhirEndpointList.Append: TFhirEndpoint;
begin
  result := TFhirEndpoint.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEndpointList.ClearItems;
begin
  Clear;
end;

function TFhirEndpointList.GetEnumerator : TFhirEndpointListEnumerator;
begin
  result := TFhirEndpointListEnumerator.Create(self.link);
end;

function TFhirEndpointList.Clone: TFhirEndpointList;
begin
  result := TFhirEndpointList(inherited Clone);
end;

function TFhirEndpointList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEndpointList.GetItemN(index: Integer): TFhirEndpoint;
begin
  result := TFhirEndpoint(ObjectByIndex[index]);
end;

function TFhirEndpointList.ItemClass: TFslObjectClass;
begin
  result := TFhirEndpoint;
end;
function TFhirEndpointList.IndexOf(value: TFhirEndpoint): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEndpointList.Insert(index: Integer): TFhirEndpoint;
begin
  result := TFhirEndpoint.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEndpointList.InsertItem(index: Integer; value: TFhirEndpoint);
begin
  assert(value is TFhirEndpoint);
  Inherited Insert(index, value);
end;

function TFhirEndpointList.Item(index: Integer): TFhirEndpoint;
begin
  result := TFhirEndpoint(ObjectByIndex[index]);
end;

function TFhirEndpointList.Link: TFhirEndpointList;
begin
  result := TFhirEndpointList(inherited Link);
end;

procedure TFhirEndpointList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEndpointList.SetItemByIndex(index: Integer; value: TFhirEndpoint);
begin
  assert(value is TFhirEndpoint);
  FhirEndpoints[index] := value;
end;

procedure TFhirEndpointList.SetItemN(index: Integer; value: TFhirEndpoint);
begin
  assert(value is TFhirEndpoint);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ENDPOINT}

{$IFDEF FHIR_EPISODEOFCARE}

{ TFhirEpisodeOfCareStatusHistory }

constructor TFhirEpisodeOfCareStatusHistory.Create;
begin
  inherited;
end;

destructor TFhirEpisodeOfCareStatusHistory.Destroy;
begin
  FStatus.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEpisodeOfCareStatusHistory.Assign(oSource : TFslObject);
begin
  inherited;
  FStatus := TFhirEpisodeOfCareStatusHistory(oSource).FStatus.Link;
  period := TFhirEpisodeOfCareStatusHistory(oSource).period.Clone;
end;

procedure TFhirEpisodeOfCareStatusHistory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirEpisodeOfCareStatusHistory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
end;

function TFhirEpisodeOfCareStatusHistory.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEpisodeOfCareStatusEnum, CODES_TFhirEpisodeOfCareStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEpisodeOfCareStatusHistory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEpisodeOfCareStatusHistory.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'period') then result := TFhirPeriod.Create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEpisodeOfCareStatusHistory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEpisodeOfCareStatusHistory.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEpisodeOfCareStatusHistory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEpisodeOfCareStatusEnum, CODES_TFhirEpisodeOfCareStatusEnum, new){4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEpisodeOfCareStatusHistory.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEpisodeOfCareStatusHistory.fhirType : string;
begin
  result := 'statusHistory';
end;

function TFhirEpisodeOfCareStatusHistory.Link : TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory(inherited Link);
end;

function TFhirEpisodeOfCareStatusHistory.Clone : TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory(inherited Clone);
end;

function TFhirEpisodeOfCareStatusHistory.equals(other : TObject) : boolean; 
var
  o : TFhirEpisodeOfCareStatusHistory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEpisodeOfCareStatusHistory)) then
    result := false
  else
  begin
    o := TFhirEpisodeOfCareStatusHistory(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirEpisodeOfCareStatusHistory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FPeriod);
end;

procedure TFhirEpisodeOfCareStatusHistory.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('status');
  fields.add('period');
end;

{ TFhirEpisodeOfCareStatusHistory }

Procedure TFhirEpisodeOfCareStatusHistory.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirEpisodeOfCareStatusHistory.GetStatusST : TFhirEpisodeOfCareStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEpisodeOfCareStatusEnum(0)
  else
    result := TFhirEpisodeOfCareStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEpisodeOfCareStatusEnum, FStatus.value));
end;

Procedure TFhirEpisodeOfCareStatusHistory.SetStatusST(value : TFhirEpisodeOfCareStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.Create(SYSTEMS_TFhirEpisodeOfCareStatusEnum[value], CODES_TFhirEpisodeOfCareStatusEnum[value]);
end;

Procedure TFhirEpisodeOfCareStatusHistory.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirEpisodeOfCareStatusHistory.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FStatus.sizeInBytes(magic));
  inc(result, FPeriod.sizeInBytes(magic));
end;

{ TFhirEpisodeOfCareStatusHistoryListEnumerator }

Constructor TFhirEpisodeOfCareStatusHistoryListEnumerator.Create(list : TFhirEpisodeOfCareStatusHistoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEpisodeOfCareStatusHistoryListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirEpisodeOfCareStatusHistoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEpisodeOfCareStatusHistoryListEnumerator.GetCurrent : TFhirEpisodeOfCareStatusHistory;
begin
  Result := FList[FIndex];
end;

function TFhirEpisodeOfCareStatusHistoryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEpisodeOfCareStatusHistoryList }
function TFhirEpisodeOfCareStatusHistoryList.AddItem(value: TFhirEpisodeOfCareStatusHistory): TFhirEpisodeOfCareStatusHistory;
begin
  add(value);
  result := value;
end;

function TFhirEpisodeOfCareStatusHistoryList.Append: TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEpisodeOfCareStatusHistoryList.ClearItems;
begin
  Clear;
end;

function TFhirEpisodeOfCareStatusHistoryList.GetEnumerator : TFhirEpisodeOfCareStatusHistoryListEnumerator;
begin
  result := TFhirEpisodeOfCareStatusHistoryListEnumerator.Create(self.link);
end;

function TFhirEpisodeOfCareStatusHistoryList.Clone: TFhirEpisodeOfCareStatusHistoryList;
begin
  result := TFhirEpisodeOfCareStatusHistoryList(inherited Clone);
end;

function TFhirEpisodeOfCareStatusHistoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEpisodeOfCareStatusHistoryList.GetItemN(index: Integer): TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory(ObjectByIndex[index]);
end;

function TFhirEpisodeOfCareStatusHistoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirEpisodeOfCareStatusHistory;
end;
function TFhirEpisodeOfCareStatusHistoryList.IndexOf(value: TFhirEpisodeOfCareStatusHistory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEpisodeOfCareStatusHistoryList.Insert(index: Integer): TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEpisodeOfCareStatusHistoryList.InsertItem(index: Integer; value: TFhirEpisodeOfCareStatusHistory);
begin
  assert(value is TFhirEpisodeOfCareStatusHistory);
  Inherited Insert(index, value);
end;

function TFhirEpisodeOfCareStatusHistoryList.Item(index: Integer): TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory(ObjectByIndex[index]);
end;

function TFhirEpisodeOfCareStatusHistoryList.Link: TFhirEpisodeOfCareStatusHistoryList;
begin
  result := TFhirEpisodeOfCareStatusHistoryList(inherited Link);
end;

procedure TFhirEpisodeOfCareStatusHistoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEpisodeOfCareStatusHistoryList.SetItemByIndex(index: Integer; value: TFhirEpisodeOfCareStatusHistory);
begin
  assert(value is TFhirEpisodeOfCareStatusHistory);
  FhirEpisodeOfCareStatusHistories[index] := value;
end;

procedure TFhirEpisodeOfCareStatusHistoryList.SetItemN(index: Integer; value: TFhirEpisodeOfCareStatusHistory);
begin
  assert(value is TFhirEpisodeOfCareStatusHistory);
  ObjectByIndex[index] := value;
end;

{ TFhirEpisodeOfCareDiagnosis }

constructor TFhirEpisodeOfCareDiagnosis.Create;
begin
  inherited;
end;

destructor TFhirEpisodeOfCareDiagnosis.Destroy;
begin
  FCondition.free;
  FRole.free;
  FRank.free;
  inherited;
end;

procedure TFhirEpisodeOfCareDiagnosis.Assign(oSource : TFslObject);
begin
  inherited;
  condition := TFhirEpisodeOfCareDiagnosis(oSource).condition.Clone;
  role := TFhirEpisodeOfCareDiagnosis(oSource).role.Clone;
  rankElement := TFhirEpisodeOfCareDiagnosis(oSource).rankElement.Clone;
end;

procedure TFhirEpisodeOfCareDiagnosis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'condition') Then
     list.add(self.link, 'condition', FCondition.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'rank') Then
     list.add(self.link, 'rank', FRank.Link);
end;

procedure TFhirEpisodeOfCareDiagnosis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'condition', 'Reference(Condition)', false, TFhirReference{TFhirCondition}, FCondition.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'rank', 'positiveInt', false, TFhirPositiveInt, FRank.Link));{2}
end;

function TFhirEpisodeOfCareDiagnosis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'condition') then
  begin
    Condition := propValue as TFhirReference{TFhirCondition}{4b};
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'rank') then
  begin
    RankElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEpisodeOfCareDiagnosis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEpisodeOfCareDiagnosis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'condition') then result := TFhirReference{TFhirCondition}.Create(){4b}
  else if (propName = 'role') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'rank') then result := TFhirPositiveInt.Create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEpisodeOfCareDiagnosis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'condition') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'rank') then result := 'positiveInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEpisodeOfCareDiagnosis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'condition') then ConditionElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'rank') then RankElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEpisodeOfCareDiagnosis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'condition') then ConditionElement := new as TFhirReference{TFhirCondition}{4}
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else if (propName = 'rank') then RankElement := asPositiveInt(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEpisodeOfCareDiagnosis.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEpisodeOfCareDiagnosis.fhirType : string;
begin
  result := 'diagnosis';
end;

function TFhirEpisodeOfCareDiagnosis.Link : TFhirEpisodeOfCareDiagnosis;
begin
  result := TFhirEpisodeOfCareDiagnosis(inherited Link);
end;

function TFhirEpisodeOfCareDiagnosis.Clone : TFhirEpisodeOfCareDiagnosis;
begin
  result := TFhirEpisodeOfCareDiagnosis(inherited Clone);
end;

function TFhirEpisodeOfCareDiagnosis.equals(other : TObject) : boolean; 
var
  o : TFhirEpisodeOfCareDiagnosis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEpisodeOfCareDiagnosis)) then
    result := false
  else
  begin
    o := TFhirEpisodeOfCareDiagnosis(other);
    result := compareDeep(conditionElement, o.conditionElement, true) and compareDeep(roleElement, o.roleElement, true) and 
      compareDeep(rankElement, o.rankElement, true);
  end;
end;

function TFhirEpisodeOfCareDiagnosis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCondition) and isEmptyProp(FRole) and isEmptyProp(FRank);
end;

procedure TFhirEpisodeOfCareDiagnosis.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('condition');
  fields.add('role');
  fields.add('rank');
end;

{ TFhirEpisodeOfCareDiagnosis }

Procedure TFhirEpisodeOfCareDiagnosis.SetCondition(value : TFhirReference{TFhirCondition});
begin
  FCondition.free;
  FCondition := value;
end;

Procedure TFhirEpisodeOfCareDiagnosis.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirEpisodeOfCareDiagnosis.SetRank(value : TFhirPositiveInt);
begin
  FRank.free;
  FRank := value;
end;

Function TFhirEpisodeOfCareDiagnosis.GetRankST : String;
begin
  if FRank = nil then
    result := ''
  else
    result := FRank.value;
end;

Procedure TFhirEpisodeOfCareDiagnosis.SetRankST(value : String);
begin
  if value <> '' then
  begin
    if FRank = nil then
      FRank := TFhirPositiveInt.Create;
    FRank.value := value
  end
  else if FRank <> nil then
    FRank.value := '';
end;

function TFhirEpisodeOfCareDiagnosis.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FCondition.sizeInBytes(magic));
  inc(result, FRole.sizeInBytes(magic));
  inc(result, FRank.sizeInBytes(magic));
end;

{ TFhirEpisodeOfCareDiagnosisListEnumerator }

Constructor TFhirEpisodeOfCareDiagnosisListEnumerator.Create(list : TFhirEpisodeOfCareDiagnosisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEpisodeOfCareDiagnosisListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirEpisodeOfCareDiagnosisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEpisodeOfCareDiagnosisListEnumerator.GetCurrent : TFhirEpisodeOfCareDiagnosis;
begin
  Result := FList[FIndex];
end;

function TFhirEpisodeOfCareDiagnosisListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEpisodeOfCareDiagnosisList }
function TFhirEpisodeOfCareDiagnosisList.AddItem(value: TFhirEpisodeOfCareDiagnosis): TFhirEpisodeOfCareDiagnosis;
begin
  add(value);
  result := value;
end;

function TFhirEpisodeOfCareDiagnosisList.Append: TFhirEpisodeOfCareDiagnosis;
begin
  result := TFhirEpisodeOfCareDiagnosis.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEpisodeOfCareDiagnosisList.ClearItems;
begin
  Clear;
end;

function TFhirEpisodeOfCareDiagnosisList.GetEnumerator : TFhirEpisodeOfCareDiagnosisListEnumerator;
begin
  result := TFhirEpisodeOfCareDiagnosisListEnumerator.Create(self.link);
end;

function TFhirEpisodeOfCareDiagnosisList.Clone: TFhirEpisodeOfCareDiagnosisList;
begin
  result := TFhirEpisodeOfCareDiagnosisList(inherited Clone);
end;

function TFhirEpisodeOfCareDiagnosisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEpisodeOfCareDiagnosisList.GetItemN(index: Integer): TFhirEpisodeOfCareDiagnosis;
begin
  result := TFhirEpisodeOfCareDiagnosis(ObjectByIndex[index]);
end;

function TFhirEpisodeOfCareDiagnosisList.ItemClass: TFslObjectClass;
begin
  result := TFhirEpisodeOfCareDiagnosis;
end;
function TFhirEpisodeOfCareDiagnosisList.IndexOf(value: TFhirEpisodeOfCareDiagnosis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEpisodeOfCareDiagnosisList.Insert(index: Integer): TFhirEpisodeOfCareDiagnosis;
begin
  result := TFhirEpisodeOfCareDiagnosis.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEpisodeOfCareDiagnosisList.InsertItem(index: Integer; value: TFhirEpisodeOfCareDiagnosis);
begin
  assert(value is TFhirEpisodeOfCareDiagnosis);
  Inherited Insert(index, value);
end;

function TFhirEpisodeOfCareDiagnosisList.Item(index: Integer): TFhirEpisodeOfCareDiagnosis;
begin
  result := TFhirEpisodeOfCareDiagnosis(ObjectByIndex[index]);
end;

function TFhirEpisodeOfCareDiagnosisList.Link: TFhirEpisodeOfCareDiagnosisList;
begin
  result := TFhirEpisodeOfCareDiagnosisList(inherited Link);
end;

procedure TFhirEpisodeOfCareDiagnosisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEpisodeOfCareDiagnosisList.SetItemByIndex(index: Integer; value: TFhirEpisodeOfCareDiagnosis);
begin
  assert(value is TFhirEpisodeOfCareDiagnosis);
  FhirEpisodeOfCareDiagnoses[index] := value;
end;

procedure TFhirEpisodeOfCareDiagnosisList.SetItemN(index: Integer; value: TFhirEpisodeOfCareDiagnosis);
begin
  assert(value is TFhirEpisodeOfCareDiagnosis);
  ObjectByIndex[index] := value;
end;

{ TFhirEpisodeOfCare }

constructor TFhirEpisodeOfCare.Create;
begin
  inherited;
end;

destructor TFhirEpisodeOfCare.Destroy;
begin
  FIdentifierList.free;
  FStatus.free;
  FStatusHistoryList.free;
  FType_List.free;
  FDiagnosisList.free;
  FPatient.free;
  FManagingOrganization.free;
  FPeriod.free;
  FReferralRequestList.free;
  FCareManager.free;
  FTeamList.free;
  FAccountList.free;
  inherited;
end;

function TFhirEpisodeOfCare.GetResourceType : TFhirResourceType;
begin
  result := frtEpisodeOfCare;
end;

procedure TFhirEpisodeOfCare.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEpisodeOfCare(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEpisodeOfCare(oSource).FIdentifierList);
  end;
  FStatus := TFhirEpisodeOfCare(oSource).FStatus.Link;
  if (TFhirEpisodeOfCare(oSource).FStatusHistoryList = nil) then
  begin
    FStatusHistoryList.free;
    FStatusHistoryList := nil;
  end
  else
  begin
    if FStatusHistoryList = nil then
      FStatusHistoryList := TFhirEpisodeOfCareStatusHistoryList.Create;
    FStatusHistoryList.Assign(TFhirEpisodeOfCare(oSource).FStatusHistoryList);
  end;
  if (TFhirEpisodeOfCare(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirEpisodeOfCare(oSource).FType_List);
  end;
  if (TFhirEpisodeOfCare(oSource).FDiagnosisList = nil) then
  begin
    FDiagnosisList.free;
    FDiagnosisList := nil;
  end
  else
  begin
    if FDiagnosisList = nil then
      FDiagnosisList := TFhirEpisodeOfCareDiagnosisList.Create;
    FDiagnosisList.Assign(TFhirEpisodeOfCare(oSource).FDiagnosisList);
  end;
  patient := TFhirEpisodeOfCare(oSource).patient.Clone;
  managingOrganization := TFhirEpisodeOfCare(oSource).managingOrganization.Clone;
  period := TFhirEpisodeOfCare(oSource).period.Clone;
  if (TFhirEpisodeOfCare(oSource).FReferralRequestList = nil) then
  begin
    FReferralRequestList.free;
    FReferralRequestList := nil;
  end
  else
  begin
    if FReferralRequestList = nil then
      FReferralRequestList := TFhirReferenceList{TFhirServiceRequest}.Create;
    FReferralRequestList.Assign(TFhirEpisodeOfCare(oSource).FReferralRequestList);
  end;
  careManager := TFhirEpisodeOfCare(oSource).careManager.Clone;
  if (TFhirEpisodeOfCare(oSource).FTeamList = nil) then
  begin
    FTeamList.free;
    FTeamList := nil;
  end
  else
  begin
    if FTeamList = nil then
      FTeamList := TFhirReferenceList{TFhirCareTeam}.Create;
    FTeamList.Assign(TFhirEpisodeOfCare(oSource).FTeamList);
  end;
  if (TFhirEpisodeOfCare(oSource).FAccountList = nil) then
  begin
    FAccountList.free;
    FAccountList := nil;
  end
  else
  begin
    if FAccountList = nil then
      FAccountList := TFhirReferenceList{TFhirAccount}.Create;
    FAccountList.Assign(TFhirEpisodeOfCare(oSource).FAccountList);
  end;
end;

procedure TFhirEpisodeOfCare.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusHistory') Then
    list.addAll(self, 'statusHistory', FStatusHistoryList);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'diagnosis') Then
    list.addAll(self, 'diagnosis', FDiagnosisList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'managingOrganization') Then
     list.add(self.link, 'managingOrganization', FManagingOrganization.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'referralRequest') Then
    list.addAll(self, 'referralRequest', FReferralRequestList);
  if (child_name = 'careManager') Then
     list.add(self.link, 'careManager', FCareManager.Link);
  if (child_name = 'team') Then
    list.addAll(self, 'team', FTeamList);
  if (child_name = 'account') Then
    list.addAll(self, 'account', FAccountList);
end;

procedure TFhirEpisodeOfCare.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'statusHistory', '', true, TFhirEpisodeOfCareStatusHistory, FStatusHistoryList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'diagnosis', '', true, TFhirEpisodeOfCareDiagnosis, FDiagnosisList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'managingOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FManagingOrganization.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'referralRequest', 'Reference(ServiceRequest)', true, TFhirReference{TFhirServiceRequest}, FReferralRequestList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'careManager', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FCareManager.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'team', 'Reference(CareTeam)', true, TFhirReference{TFhirCareTeam}, FTeamList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'account', 'Reference(Account)', true, TFhirReference{TFhirAccount}, FAccountList.Link)){3};
end;

function TFhirEpisodeOfCare.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEpisodeOfCareStatusEnum, CODES_TFhirEpisodeOfCareStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'statusHistory') then
  begin
    StatusHistoryList.add(propValue as TFhirEpisodeOfCareStatusHistory){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'diagnosis') then
  begin
    DiagnosisList.add(propValue as TFhirEpisodeOfCareDiagnosis){2a};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'referralRequest') then
  begin
    ReferralRequestList.add(propValue as TFhirReference{TFhirServiceRequest}){2a};
    result := propValue;
  end
  else if (propName = 'careManager') then
  begin
    CareManager := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'team') then
  begin
    TeamList.add(propValue as TFhirReference{TFhirCareTeam}){2a};
    result := propValue;
  end
  else if (propName = 'account') then
  begin
    AccountList.add(propValue as TFhirReference{TFhirAccount}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirEpisodeOfCare.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'statusHistory') then StatusHistoryList.insertItem(index, propValue as TFhirEpisodeOfCareStatusHistory){2a}
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'diagnosis') then DiagnosisList.insertItem(index, propValue as TFhirEpisodeOfCareDiagnosis){2a}
  else if (propName = 'referralRequest') then ReferralRequestList.insertItem(index, propValue as TFhirReference{TFhirServiceRequest}){2a}
  else if (propName = 'team') then TeamList.insertItem(index, propValue as TFhirReference{TFhirCareTeam}){2a}
  else if (propName = 'account') then AccountList.insertItem(index, propValue as TFhirReference{TFhirAccount}){2a}
  else inherited;
end;

function TFhirEpisodeOfCare.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'statusHistory') then result := StatusHistoryList.new(){2}
  else if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'diagnosis') then result := DiagnosisList.new(){2}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.Create(){4b}
  else if (propName = 'managingOrganization') then result := TFhirReference{TFhirOrganization}.Create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.Create(){4b}
  else if (propName = 'referralRequest') then result := ReferralRequestList.new(){2}
  else if (propName = 'careManager') then result := TFhirReference{TFhirPractitioner}.Create(){4b}
  else if (propName = 'team') then result := TeamList.new(){2}
  else if (propName = 'account') then result := AccountList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirEpisodeOfCare.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusHistory') then result := ''
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'diagnosis') then result := ''
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'referralRequest') then result := 'Reference'
  else if (propName = 'careManager') then result := 'Reference'
  else if (propName = 'team') then result := 'Reference'
  else if (propName = 'account') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEpisodeOfCare.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusHistory') then deletePropertyValue('statusHistory', StatusHistoryList, value) {2}
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'diagnosis') then deletePropertyValue('diagnosis', DiagnosisList, value) {2}
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'referralRequest') then deletePropertyValue('referralRequest', ReferralRequestList, value) {2}
  else if (propName = 'careManager') then CareManagerElement := nil
  else if (propName = 'team') then deletePropertyValue('team', TeamList, value) {2}
  else if (propName = 'account') then deletePropertyValue('account', AccountList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEpisodeOfCare.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEpisodeOfCareStatusEnum, CODES_TFhirEpisodeOfCareStatusEnum, new){4}
  else if (propName = 'statusHistory') then replacePropertyValue('statusHistory', StatusHistoryList, existing, new) {2}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'diagnosis') then replacePropertyValue('diagnosis', DiagnosisList, existing, new) {2}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'referralRequest') then replacePropertyValue('referralRequest', ReferralRequestList, existing, new) {2}
  else if (propName = 'careManager') then CareManagerElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'team') then replacePropertyValue('team', TeamList, existing, new) {2}
  else if (propName = 'account') then replacePropertyValue('account', AccountList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEpisodeOfCare.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'statusHistory') then StatusHistoryList.move(source, destination){2a}
  else if (propName = 'type') then Type_List.move(source, destination){2a}
  else if (propName = 'diagnosis') then DiagnosisList.move(source, destination){2a}
  else if (propName = 'referralRequest') then ReferralRequestList.move(source, destination){2a}
  else if (propName = 'team') then TeamList.move(source, destination){2a}
  else if (propName = 'account') then AccountList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEpisodeOfCare.fhirType : string;
begin
  result := 'EpisodeOfCare';
end;

function TFhirEpisodeOfCare.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FstatusHistoryList) and isEmptyProp(Ftype_List) and isEmptyProp(FdiagnosisList) and isEmptyProp(FPatient) and isEmptyProp(FManagingOrganization) and isEmptyProp(FPeriod) and isEmptyProp(FreferralRequestList) and isEmptyProp(FCareManager) and isEmptyProp(FteamList) and isEmptyProp(FaccountList);
end;

function TFhirEpisodeOfCare.equals(other : TObject) : boolean; 
var
  o : TFhirEpisodeOfCare;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEpisodeOfCare)) then
    result := false
  else
  begin
    o := TFhirEpisodeOfCare(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusHistoryList, o.statusHistoryList, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(diagnosisList, o.diagnosisList, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(managingOrganizationElement, o.managingOrganizationElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(referralRequestList, o.referralRequestList, true) and 
      compareDeep(careManagerElement, o.careManagerElement, true) and compareDeep(teamList, o.teamList, true) and 
      compareDeep(accountList, o.accountList, true);
  end;
end;

function TFhirEpisodeOfCare.Link : TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare(inherited Link);
end;

function TFhirEpisodeOfCare.Clone : TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare(inherited Clone);
end;

procedure TFhirEpisodeOfCare.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('statusHistory');
  fields.add('type');
  fields.add('diagnosis');
  fields.add('patient');
  fields.add('managingOrganization');
  fields.add('period');
  fields.add('referralRequest');
  fields.add('careManager');
  fields.add('team');
  fields.add('account');
end;

{ TFhirEpisodeOfCare }

Function TFhirEpisodeOfCare.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirEpisodeOfCare.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirEpisodeOfCare.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirEpisodeOfCare.GetStatusST : TFhirEpisodeOfCareStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEpisodeOfCareStatusEnum(0)
  else
    result := TFhirEpisodeOfCareStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEpisodeOfCareStatusEnum, FStatus.value));
end;

Procedure TFhirEpisodeOfCare.SetStatusST(value : TFhirEpisodeOfCareStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.Create(SYSTEMS_TFhirEpisodeOfCareStatusEnum[value], CODES_TFhirEpisodeOfCareStatusEnum[value]);
end;

Function TFhirEpisodeOfCare.GetStatusHistoryList : TFhirEpisodeOfCareStatusHistoryList;
begin
  if FStatusHistoryList = nil then
    FStatusHistoryList := TFhirEpisodeOfCareStatusHistoryList.Create;
  result := FStatusHistoryList;
end;

Function TFhirEpisodeOfCare.GetHasStatusHistoryList : boolean;
begin
  result := (FStatusHistoryList <> nil) and (FStatusHistoryList.count > 0);
end;

Function TFhirEpisodeOfCare.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

Function TFhirEpisodeOfCare.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Function TFhirEpisodeOfCare.GetDiagnosisList : TFhirEpisodeOfCareDiagnosisList;
begin
  if FDiagnosisList = nil then
    FDiagnosisList := TFhirEpisodeOfCareDiagnosisList.Create;
  result := FDiagnosisList;
end;

Function TFhirEpisodeOfCare.GetHasDiagnosisList : boolean;
begin
  result := (FDiagnosisList <> nil) and (FDiagnosisList.count > 0);
end;

Procedure TFhirEpisodeOfCare.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirEpisodeOfCare.SetManagingOrganization(value : TFhirReference{TFhirOrganization});
begin
  FManagingOrganization.free;
  FManagingOrganization := value;
end;

Procedure TFhirEpisodeOfCare.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Function TFhirEpisodeOfCare.GetReferralRequestList : TFhirReferenceList{TFhirServiceRequest};
begin
  if FReferralRequestList = nil then
    FReferralRequestList := TFhirReferenceList{TFhirServiceRequest}.Create;
  result := FReferralRequestList;
end;

Function TFhirEpisodeOfCare.GetHasReferralRequestList : boolean;
begin
  result := (FReferralRequestList <> nil) and (FReferralRequestList.count > 0);
end;

Procedure TFhirEpisodeOfCare.SetCareManager(value : TFhirReference{TFhirPractitioner});
begin
  FCareManager.free;
  FCareManager := value;
end;

Function TFhirEpisodeOfCare.GetTeamList : TFhirReferenceList{TFhirCareTeam};
begin
  if FTeamList = nil then
    FTeamList := TFhirReferenceList{TFhirCareTeam}.Create;
  result := FTeamList;
end;

Function TFhirEpisodeOfCare.GetHasTeamList : boolean;
begin
  result := (FTeamList <> nil) and (FTeamList.count > 0);
end;

Function TFhirEpisodeOfCare.GetAccountList : TFhirReferenceList{TFhirAccount};
begin
  if FAccountList = nil then
    FAccountList := TFhirReferenceList{TFhirAccount}.Create;
  result := FAccountList;
end;

Function TFhirEpisodeOfCare.GetHasAccountList : boolean;
begin
  result := (FAccountList <> nil) and (FAccountList.count > 0);
end;

function TFhirEpisodeOfCare.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FidentifierList.sizeInBytes(magic));
  inc(result, FStatus.sizeInBytes(magic));
  inc(result, FstatusHistoryList.sizeInBytes(magic));
  inc(result, Ftype_List.sizeInBytes(magic));
  inc(result, FdiagnosisList.sizeInBytes(magic));
  inc(result, FPatient.sizeInBytes(magic));
  inc(result, FManagingOrganization.sizeInBytes(magic));
  inc(result, FPeriod.sizeInBytes(magic));
  inc(result, FreferralRequestList.sizeInBytes(magic));
  inc(result, FCareManager.sizeInBytes(magic));
  inc(result, FteamList.sizeInBytes(magic));
  inc(result, FaccountList.sizeInBytes(magic));
end;

{ TFhirEpisodeOfCareListEnumerator }

Constructor TFhirEpisodeOfCareListEnumerator.Create(list : TFhirEpisodeOfCareList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEpisodeOfCareListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirEpisodeOfCareListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEpisodeOfCareListEnumerator.GetCurrent : TFhirEpisodeOfCare;
begin
  Result := FList[FIndex];
end;

function TFhirEpisodeOfCareListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEpisodeOfCareList }
function TFhirEpisodeOfCareList.AddItem(value: TFhirEpisodeOfCare): TFhirEpisodeOfCare;
begin
  add(value);
  result := value;
end;

function TFhirEpisodeOfCareList.Append: TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEpisodeOfCareList.ClearItems;
begin
  Clear;
end;

function TFhirEpisodeOfCareList.GetEnumerator : TFhirEpisodeOfCareListEnumerator;
begin
  result := TFhirEpisodeOfCareListEnumerator.Create(self.link);
end;

function TFhirEpisodeOfCareList.Clone: TFhirEpisodeOfCareList;
begin
  result := TFhirEpisodeOfCareList(inherited Clone);
end;

function TFhirEpisodeOfCareList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEpisodeOfCareList.GetItemN(index: Integer): TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare(ObjectByIndex[index]);
end;

function TFhirEpisodeOfCareList.ItemClass: TFslObjectClass;
begin
  result := TFhirEpisodeOfCare;
end;
function TFhirEpisodeOfCareList.IndexOf(value: TFhirEpisodeOfCare): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEpisodeOfCareList.Insert(index: Integer): TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEpisodeOfCareList.InsertItem(index: Integer; value: TFhirEpisodeOfCare);
begin
  assert(value is TFhirEpisodeOfCare);
  Inherited Insert(index, value);
end;

function TFhirEpisodeOfCareList.Item(index: Integer): TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare(ObjectByIndex[index]);
end;

function TFhirEpisodeOfCareList.Link: TFhirEpisodeOfCareList;
begin
  result := TFhirEpisodeOfCareList(inherited Link);
end;

procedure TFhirEpisodeOfCareList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEpisodeOfCareList.SetItemByIndex(index: Integer; value: TFhirEpisodeOfCare);
begin
  assert(value is TFhirEpisodeOfCare);
  FhirEpisodeOfCares[index] := value;
end;

procedure TFhirEpisodeOfCareList.SetItemN(index: Integer; value: TFhirEpisodeOfCare);
begin
  assert(value is TFhirEpisodeOfCare);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_EPISODEOFCARE}

{$IFDEF FHIR_GROUP}

{ TFhirGroupCharacteristic }

constructor TFhirGroupCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirGroupCharacteristic.Destroy;
begin
  FCode.free;
  FValue.free;
  FExclude.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirGroupCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirGroupCharacteristic(oSource).code.Clone;
  value := TFhirGroupCharacteristic(oSource).value.Clone;
  excludeElement := TFhirGroupCharacteristic(oSource).excludeElement.Clone;
  period := TFhirGroupCharacteristic(oSource).period.Clone;
end;

procedure TFhirGroupCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'exclude') Then
     list.add(self.link, 'exclude', FExclude.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirGroupCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'value[x]', 'CodeableConcept|boolean|Quantity|Range|Reference', false, TFhirType, FValue.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'exclude', 'boolean', false, TFhirBoolean, FExclude.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
end;

function TFhirGroupCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'exclude') then
  begin
    ExcludeElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGroupCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirGroupCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.Create(){4b}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then raise EFHIRException.Create('Cannot make property Value'){4x}
  else if (propName = 'exclude') then result := TFhirBoolean.Create() {5b}
  else if (propName = 'period') then result := TFhirPeriod.Create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirGroupCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|boolean|Quantity|Range|Reference'
  else if (propName = 'exclude') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGroupCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then ValueElement := nil{4x}
  else if (propName = 'exclude') then ExcludeElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGroupCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then ValueElement := new as TFhirType{4x}
  else if (propName = 'exclude') then ExcludeElement := asBoolean(new){5b}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGroupCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirGroupCharacteristic.fhirType : string;
begin
  result := 'characteristic';
end;

function TFhirGroupCharacteristic.Link : TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(inherited Link);
end;

function TFhirGroupCharacteristic.Clone : TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(inherited Clone);
end;

function TFhirGroupCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirGroupCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGroupCharacteristic)) then
    result := false
  else
  begin
    o := TFhirGroupCharacteristic(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(excludeElement, o.excludeElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirGroupCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue) and isEmptyProp(FExclude) and isEmptyProp(FPeriod);
end;

procedure TFhirGroupCharacteristic.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('value[x]');
  fields.add('exclude');
  fields.add('period');
end;

{ TFhirGroupCharacteristic }

Procedure TFhirGroupCharacteristic.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirGroupCharacteristic.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Procedure TFhirGroupCharacteristic.SetExclude(value : TFhirBoolean);
begin
  FExclude.free;
  FExclude := value;
end;

Function TFhirGroupCharacteristic.GetExcludeST : Boolean;
begin
  if FExclude = nil then
    result := false
  else
    result := FExclude.value;
end;

Procedure TFhirGroupCharacteristic.SetExcludeST(value : Boolean);
begin
  if FExclude = nil then
    FExclude := TFhirBoolean.Create;
  FExclude.value := value
end;

Procedure TFhirGroupCharacteristic.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirGroupCharacteristic.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FCode.sizeInBytes(magic));
  inc(result, FValue.sizeInBytes(magic));
  inc(result, FExclude.sizeInBytes(magic));
  inc(result, FPeriod.sizeInBytes(magic));
end;

{ TFhirGroupCharacteristicListEnumerator }

Constructor TFhirGroupCharacteristicListEnumerator.Create(list : TFhirGroupCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGroupCharacteristicListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirGroupCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGroupCharacteristicListEnumerator.GetCurrent : TFhirGroupCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirGroupCharacteristicListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirGroupCharacteristicList }
function TFhirGroupCharacteristicList.AddItem(value: TFhirGroupCharacteristic): TFhirGroupCharacteristic;
begin
  add(value);
  result := value;
end;

function TFhirGroupCharacteristicList.Append: TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirGroupCharacteristicList.GetEnumerator : TFhirGroupCharacteristicListEnumerator;
begin
  result := TFhirGroupCharacteristicListEnumerator.Create(self.link);
end;

function TFhirGroupCharacteristicList.Clone: TFhirGroupCharacteristicList;
begin
  result := TFhirGroupCharacteristicList(inherited Clone);
end;

function TFhirGroupCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGroupCharacteristicList.GetItemN(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(ObjectByIndex[index]);
end;

function TFhirGroupCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirGroupCharacteristic;
end;
function TFhirGroupCharacteristicList.IndexOf(value: TFhirGroupCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGroupCharacteristicList.Insert(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupCharacteristicList.InsertItem(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirGroupCharacteristicList.Item(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(ObjectByIndex[index]);
end;

function TFhirGroupCharacteristicList.Link: TFhirGroupCharacteristicList;
begin
  result := TFhirGroupCharacteristicList(inherited Link);
end;

procedure TFhirGroupCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGroupCharacteristicList.SetItemByIndex(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  FhirGroupCharacteristics[index] := value;
end;

procedure TFhirGroupCharacteristicList.SetItemN(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirGroupMember }

constructor TFhirGroupMember.Create;
begin
  inherited;
end;

destructor TFhirGroupMember.Destroy;
begin
  FEntity.free;
  FPeriod.free;
  FInactive.free;
  inherited;
end;

procedure TFhirGroupMember.Assign(oSource : TFslObject);
begin
  inherited;
  entity := TFhirGroupMember(oSource).entity.Clone;
  period := TFhirGroupMember(oSource).period.Clone;
  inactiveElement := TFhirGroupMember(oSource).inactiveElement.Clone;
end;

procedure TFhirGroupMember.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'entity') Then
     list.add(self.link, 'entity', FEntity.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'inactive') Then
     list.add(self.link, 'inactive', FInactive.Link);
end;

procedure TFhirGroupMember.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'entity', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FEntity.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'inactive', 'boolean', false, TFhirBoolean, FInactive.Link));{2}
end;

function TFhirGroupMember.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'entity') then
  begin
    Entity := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'inactive') then
  begin
    InactiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGroupMember.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirGroupMember.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'entity') then result := TFhirReference{TFhirPatient}.Create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.Create(){4b}
  else if (propName = 'inactive') then result := TFhirBoolean.Create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirGroupMember.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'entity') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'inactive') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGroupMember.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'entity') then EntityElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'inactive') then InactiveElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGroupMember.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'entity') then EntityElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'inactive') then InactiveElement := asBoolean(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGroupMember.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirGroupMember.fhirType : string;
begin
  result := 'member';
end;

function TFhirGroupMember.Link : TFhirGroupMember;
begin
  result := TFhirGroupMember(inherited Link);
end;

function TFhirGroupMember.Clone : TFhirGroupMember;
begin
  result := TFhirGroupMember(inherited Clone);
end;

function TFhirGroupMember.equals(other : TObject) : boolean; 
var
  o : TFhirGroupMember;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGroupMember)) then
    result := false
  else
  begin
    o := TFhirGroupMember(other);
    result := compareDeep(entityElement, o.entityElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(inactiveElement, o.inactiveElement, true);
  end;
end;

function TFhirGroupMember.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEntity) and isEmptyProp(FPeriod) and isEmptyProp(FInactive);
end;

procedure TFhirGroupMember.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('entity');
  fields.add('period');
  fields.add('inactive');
end;

{ TFhirGroupMember }

Procedure TFhirGroupMember.SetEntity(value : TFhirReference{TFhirPatient});
begin
  FEntity.free;
  FEntity := value;
end;

Procedure TFhirGroupMember.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirGroupMember.SetInactive(value : TFhirBoolean);
begin
  FInactive.free;
  FInactive := value;
end;

Function TFhirGroupMember.GetInactiveST : Boolean;
begin
  if FInactive = nil then
    result := false
  else
    result := FInactive.value;
end;

Procedure TFhirGroupMember.SetInactiveST(value : Boolean);
begin
  if FInactive = nil then
    FInactive := TFhirBoolean.Create;
  FInactive.value := value
end;

function TFhirGroupMember.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FEntity.sizeInBytes(magic));
  inc(result, FPeriod.sizeInBytes(magic));
  inc(result, FInactive.sizeInBytes(magic));
end;

{ TFhirGroupMemberListEnumerator }

Constructor TFhirGroupMemberListEnumerator.Create(list : TFhirGroupMemberList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGroupMemberListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirGroupMemberListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGroupMemberListEnumerator.GetCurrent : TFhirGroupMember;
begin
  Result := FList[FIndex];
end;

function TFhirGroupMemberListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirGroupMemberList }
function TFhirGroupMemberList.AddItem(value: TFhirGroupMember): TFhirGroupMember;
begin
  add(value);
  result := value;
end;

function TFhirGroupMemberList.Append: TFhirGroupMember;
begin
  result := TFhirGroupMember.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupMemberList.ClearItems;
begin
  Clear;
end;

function TFhirGroupMemberList.GetEnumerator : TFhirGroupMemberListEnumerator;
begin
  result := TFhirGroupMemberListEnumerator.Create(self.link);
end;

function TFhirGroupMemberList.Clone: TFhirGroupMemberList;
begin
  result := TFhirGroupMemberList(inherited Clone);
end;

function TFhirGroupMemberList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGroupMemberList.GetItemN(index: Integer): TFhirGroupMember;
begin
  result := TFhirGroupMember(ObjectByIndex[index]);
end;

function TFhirGroupMemberList.ItemClass: TFslObjectClass;
begin
  result := TFhirGroupMember;
end;
function TFhirGroupMemberList.IndexOf(value: TFhirGroupMember): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGroupMemberList.Insert(index: Integer): TFhirGroupMember;
begin
  result := TFhirGroupMember.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupMemberList.InsertItem(index: Integer; value: TFhirGroupMember);
begin
  assert(value is TFhirGroupMember);
  Inherited Insert(index, value);
end;

function TFhirGroupMemberList.Item(index: Integer): TFhirGroupMember;
begin
  result := TFhirGroupMember(ObjectByIndex[index]);
end;

function TFhirGroupMemberList.Link: TFhirGroupMemberList;
begin
  result := TFhirGroupMemberList(inherited Link);
end;

procedure TFhirGroupMemberList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGroupMemberList.SetItemByIndex(index: Integer; value: TFhirGroupMember);
begin
  assert(value is TFhirGroupMember);
  FhirGroupMembers[index] := value;
end;

procedure TFhirGroupMemberList.SetItemN(index: Integer; value: TFhirGroupMember);
begin
  assert(value is TFhirGroupMember);
  ObjectByIndex[index] := value;
end;

{ TFhirGroup }

constructor TFhirGroup.Create;
begin
  inherited;
end;

destructor TFhirGroup.Destroy;
begin
  FIdentifierList.free;
  FActive.free;
  FType_.free;
  FActual.free;
  FCode.free;
  FName.free;
  FQuantity.free;
  FManagingEntity.free;
  FCharacteristicList.free;
  FMemberList.free;
  inherited;
end;

function TFhirGroup.GetResourceType : TFhirResourceType;
begin
  result := frtGroup;
end;

procedure TFhirGroup.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirGroup(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirGroup(oSource).FIdentifierList);
  end;
  activeElement := TFhirGroup(oSource).activeElement.Clone;
  FType_ := TFhirGroup(oSource).FType_.Link;
  actualElement := TFhirGroup(oSource).actualElement.Clone;
  code := TFhirGroup(oSource).code.Clone;
  nameElement := TFhirGroup(oSource).nameElement.Clone;
  quantityElement := TFhirGroup(oSource).quantityElement.Clone;
  managingEntity := TFhirGroup(oSource).managingEntity.Clone;
  if (TFhirGroup(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirGroupCharacteristicList.Create;
    FCharacteristicList.Assign(TFhirGroup(oSource).FCharacteristicList);
  end;
  if (TFhirGroup(oSource).FMemberList = nil) then
  begin
    FMemberList.free;
    FMemberList := nil;
  end
  else
  begin
    if FMemberList = nil then
      FMemberList := TFhirGroupMemberList.Create;
    FMemberList.Assign(TFhirGroup(oSource).FMemberList);
  end;
end;

procedure TFhirGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'actual') Then
     list.add(self.link, 'actual', FActual.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'managingEntity') Then
     list.add(self.link, 'managingEntity', FManagingEntity.Link);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
  if (child_name = 'member') Then
    list.addAll(self, 'member', FMemberList);
end;

procedure TFhirGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'actual', 'boolean', false, TFhirBoolean, FActual.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'quantity', 'unsignedInt', false, TFhirUnsignedInt, FQuantity.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'managingEntity', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FManagingEntity.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'characteristic', '', true, TFhirGroupCharacteristic, FCharacteristicList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'member', '', true, TFhirGroupMember, FMemberList.Link)){3};
end;

function TFhirGroup.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirGroupTypeEnum, CODES_TFhirGroupTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'actual') then
  begin
    ActualElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    QuantityElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'managingEntity') then
  begin
    ManagingEntity := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirGroupCharacteristic){2a};
    result := propValue;
  end
  else if (propName = 'member') then
  begin
    MemberList.add(propValue as TFhirGroupMember){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirGroupCharacteristic){2a}
  else if (propName = 'member') then MemberList.insertItem(index, propValue as TFhirGroupMember){2a}
  else inherited;
end;

function TFhirGroup.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'active') then result := TFhirBoolean.Create() {5b}
  else if (propName = 'actual') then result := TFhirBoolean.Create() {5b}
  else if (propName = 'code') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'name') then result := TFhirString.Create() {5b}
  else if (propName = 'quantity') then result := TFhirUnsignedInt.Create() {5b}
  else if (propName = 'managingEntity') then result := TFhirReference{TFhirOrganization}.Create(){4b}
  else if (propName = 'characteristic') then result := CharacteristicList.new(){2}
  else if (propName = 'member') then result := MemberList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'actual') then result := 'boolean'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'quantity') then result := 'unsignedInt'
  else if (propName = 'managingEntity') then result := 'Reference'
  else if (propName = 'characteristic') then result := ''
  else if (propName = 'member') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGroup.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'actual') then ActualElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'managingEntity') then ManagingEntityElement := nil
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value) {2}
  else if (propName = 'member') then deletePropertyValue('member', MemberList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'active') then ActiveElement := asBoolean(new){5b}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirGroupTypeEnum, CODES_TFhirGroupTypeEnum, new){4}
  else if (propName = 'actual') then ActualElement := asBoolean(new){5b}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'quantity') then QuantityElement := asUnsignedInt(new){5b}
  else if (propName = 'managingEntity') then ManagingEntityElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new) {2}
  else if (propName = 'member') then replacePropertyValue('member', MemberList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination){2a}
  else if (propName = 'member') then MemberList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirGroup.fhirType : string;
begin
  result := 'Group';
end;

function TFhirGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FType_) and isEmptyProp(FActual) and isEmptyProp(FCode) and isEmptyProp(FName) and isEmptyProp(FQuantity) and isEmptyProp(FManagingEntity) and isEmptyProp(FcharacteristicList) and isEmptyProp(FmemberList);
end;

function TFhirGroup.equals(other : TObject) : boolean; 
var
  o : TFhirGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGroup)) then
    result := false
  else
  begin
    o := TFhirGroup(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(actualElement, o.actualElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(managingEntityElement, o.managingEntityElement, true) and 
      compareDeep(characteristicList, o.characteristicList, true) and compareDeep(memberList, o.memberList, true);
  end;
end;

function TFhirGroup.Link : TFhirGroup;
begin
  result := TFhirGroup(inherited Link);
end;

function TFhirGroup.Clone : TFhirGroup;
begin
  result := TFhirGroup(inherited Clone);
end;

procedure TFhirGroup.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('type');
  fields.add('actual');
  fields.add('code');
  fields.add('name');
  fields.add('quantity');
  fields.add('managingEntity');
  fields.add('characteristic');
  fields.add('member');
end;

{ TFhirGroup }

Function TFhirGroup.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirGroup.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirGroup.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

Function TFhirGroup.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

Procedure TFhirGroup.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.Create;
  FActive.value := value
end;

Procedure TFhirGroup.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirGroup.GetType_ST : TFhirGroupTypeEnum;
begin
  if FType_ = nil then
    result := TFhirGroupTypeEnum(0)
  else
    result := TFhirGroupTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirGroupTypeEnum, FType_.value));
end;

Procedure TFhirGroup.SetType_ST(value : TFhirGroupTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.Create(SYSTEMS_TFhirGroupTypeEnum[value], CODES_TFhirGroupTypeEnum[value]);
end;

Procedure TFhirGroup.SetActual(value : TFhirBoolean);
begin
  FActual.free;
  FActual := value;
end;

Function TFhirGroup.GetActualST : Boolean;
begin
  if FActual = nil then
    result := false
  else
    result := FActual.value;
end;

Procedure TFhirGroup.SetActualST(value : Boolean);
begin
  if FActual = nil then
    FActual := TFhirBoolean.Create;
  FActual.value := value
end;

Procedure TFhirGroup.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirGroup.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirGroup.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirGroup.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.Create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirGroup.SetQuantity(value : TFhirUnsignedInt);
begin
  FQuantity.free;
  FQuantity := value;
end;

Function TFhirGroup.GetQuantityST : String;
begin
  if FQuantity = nil then
    result := ''
  else
    result := FQuantity.value;
end;

Procedure TFhirGroup.SetQuantityST(value : String);
begin
  if value <> '' then
  begin
    if FQuantity = nil then
      FQuantity := TFhirUnsignedInt.Create;
    FQuantity.value := value
  end
  else if FQuantity <> nil then
    FQuantity.value := '';
end;

Procedure TFhirGroup.SetManagingEntity(value : TFhirReference{TFhirOrganization});
begin
  FManagingEntity.free;
  FManagingEntity := value;
end;

Function TFhirGroup.GetCharacteristicList : TFhirGroupCharacteristicList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirGroupCharacteristicList.Create;
  result := FCharacteristicList;
end;

Function TFhirGroup.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

Function TFhirGroup.GetMemberList : TFhirGroupMemberList;
begin
  if FMemberList = nil then
    FMemberList := TFhirGroupMemberList.Create;
  result := FMemberList;
end;

Function TFhirGroup.GetHasMemberList : boolean;
begin
  result := (FMemberList <> nil) and (FMemberList.count > 0);
end;

function TFhirGroup.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FidentifierList.sizeInBytes(magic));
  inc(result, FActive.sizeInBytes(magic));
  inc(result, FType_.sizeInBytes(magic));
  inc(result, FActual.sizeInBytes(magic));
  inc(result, FCode.sizeInBytes(magic));
  inc(result, FName.sizeInBytes(magic));
  inc(result, FQuantity.sizeInBytes(magic));
  inc(result, FManagingEntity.sizeInBytes(magic));
  inc(result, FcharacteristicList.sizeInBytes(magic));
  inc(result, FmemberList.sizeInBytes(magic));
end;

{ TFhirGroupListEnumerator }

Constructor TFhirGroupListEnumerator.Create(list : TFhirGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGroupListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGroupListEnumerator.GetCurrent : TFhirGroup;
begin
  Result := FList[FIndex];
end;

function TFhirGroupListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirGroupList }
function TFhirGroupList.AddItem(value: TFhirGroup): TFhirGroup;
begin
  add(value);
  result := value;
end;

function TFhirGroupList.Append: TFhirGroup;
begin
  result := TFhirGroup.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupList.ClearItems;
begin
  Clear;
end;

function TFhirGroupList.GetEnumerator : TFhirGroupListEnumerator;
begin
  result := TFhirGroupListEnumerator.Create(self.link);
end;

function TFhirGroupList.Clone: TFhirGroupList;
begin
  result := TFhirGroupList(inherited Clone);
end;

function TFhirGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGroupList.GetItemN(index: Integer): TFhirGroup;
begin
  result := TFhirGroup(ObjectByIndex[index]);
end;

function TFhirGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirGroup;
end;
function TFhirGroupList.IndexOf(value: TFhirGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGroupList.Insert(index: Integer): TFhirGroup;
begin
  result := TFhirGroup.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupList.InsertItem(index: Integer; value: TFhirGroup);
begin
  assert(value is TFhirGroup);
  Inherited Insert(index, value);
end;

function TFhirGroupList.Item(index: Integer): TFhirGroup;
begin
  result := TFhirGroup(ObjectByIndex[index]);
end;

function TFhirGroupList.Link: TFhirGroupList;
begin
  result := TFhirGroupList(inherited Link);
end;

procedure TFhirGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGroupList.SetItemByIndex(index: Integer; value: TFhirGroup);
begin
  assert(value is TFhirGroup);
  FhirGroups[index] := value;
end;

procedure TFhirGroupList.SetItemN(index: Integer; value: TFhirGroup);
begin
  assert(value is TFhirGroup);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_GROUP}

{$IFDEF FHIR_HEALTHCARESERVICE}

{ TFhirHealthcareServiceEligibility }

constructor TFhirHealthcareServiceEligibility.Create;
begin
  inherited;
end;

destructor TFhirHealthcareServiceEligibility.Destroy;
begin
  FCode.free;
  FComment.free;
  inherited;
end;

procedure TFhirHealthcareServiceEligibility.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirHealthcareServiceEligibility(oSource).code.Clone;
  commentElement := TFhirHealthcareServiceEligibility(oSource).commentElement.Clone;
end;

procedure TFhirHealthcareServiceEligibility.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirHealthcareServiceEligibility.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'comment', 'markdown', false, TFhirMarkdown, FComment.Link));{2}
end;

function TFhirHealthcareServiceEligibility.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirHealthcareServiceEligibility.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirHealthcareServiceEligibility.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'comment') then result := TFhirMarkdown.Create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirHealthcareServiceEligibility.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'comment') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirHealthcareServiceEligibility.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirHealthcareServiceEligibility.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'comment') then CommentElement := asMarkdown(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirHealthcareServiceEligibility.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirHealthcareServiceEligibility.fhirType : string;
begin
  result := 'eligibility';
end;

function TFhirHealthcareServiceEligibility.Link : TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility(inherited Link);
end;

function TFhirHealthcareServiceEligibility.Clone : TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility(inherited Clone);
end;

function TFhirHealthcareServiceEligibility.equals(other : TObject) : boolean; 
var
  o : TFhirHealthcareServiceEligibility;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirHealthcareServiceEligibility)) then
    result := false
  else
  begin
    o := TFhirHealthcareServiceEligibility(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirHealthcareServiceEligibility.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FComment);
end;

procedure TFhirHealthcareServiceEligibility.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('comment');
end;

{ TFhirHealthcareServiceEligibility }

Procedure TFhirHealthcareServiceEligibility.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirHealthcareServiceEligibility.SetComment(value : TFhirMarkdown);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirHealthcareServiceEligibility.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirHealthcareServiceEligibility.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirMarkdown.Create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

function TFhirHealthcareServiceEligibility.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FCode.sizeInBytes(magic));
  inc(result, FComment.sizeInBytes(magic));
end;

{ TFhirHealthcareServiceEligibilityListEnumerator }

Constructor TFhirHealthcareServiceEligibilityListEnumerator.Create(list : TFhirHealthcareServiceEligibilityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirHealthcareServiceEligibilityListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirHealthcareServiceEligibilityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirHealthcareServiceEligibilityListEnumerator.GetCurrent : TFhirHealthcareServiceEligibility;
begin
  Result := FList[FIndex];
end;

function TFhirHealthcareServiceEligibilityListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirHealthcareServiceEligibilityList }
function TFhirHealthcareServiceEligibilityList.AddItem(value: TFhirHealthcareServiceEligibility): TFhirHealthcareServiceEligibility;
begin
  add(value);
  result := value;
end;

function TFhirHealthcareServiceEligibilityList.Append: TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceEligibilityList.ClearItems;
begin
  Clear;
end;

function TFhirHealthcareServiceEligibilityList.GetEnumerator : TFhirHealthcareServiceEligibilityListEnumerator;
begin
  result := TFhirHealthcareServiceEligibilityListEnumerator.Create(self.link);
end;

function TFhirHealthcareServiceEligibilityList.Clone: TFhirHealthcareServiceEligibilityList;
begin
  result := TFhirHealthcareServiceEligibilityList(inherited Clone);
end;

function TFhirHealthcareServiceEligibilityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirHealthcareServiceEligibilityList.GetItemN(index: Integer): TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceEligibilityList.ItemClass: TFslObjectClass;
begin
  result := TFhirHealthcareServiceEligibility;
end;
function TFhirHealthcareServiceEligibilityList.IndexOf(value: TFhirHealthcareServiceEligibility): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirHealthcareServiceEligibilityList.Insert(index: Integer): TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceEligibilityList.InsertItem(index: Integer; value: TFhirHealthcareServiceEligibility);
begin
  assert(value is TFhirHealthcareServiceEligibility);
  Inherited Insert(index, value);
end;

function TFhirHealthcareServiceEligibilityList.Item(index: Integer): TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceEligibilityList.Link: TFhirHealthcareServiceEligibilityList;
begin
  result := TFhirHealthcareServiceEligibilityList(inherited Link);
end;

procedure TFhirHealthcareServiceEligibilityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirHealthcareServiceEligibilityList.SetItemByIndex(index: Integer; value: TFhirHealthcareServiceEligibility);
begin
  assert(value is TFhirHealthcareServiceEligibility);
  FhirHealthcareServiceEligibilities[index] := value;
end;

procedure TFhirHealthcareServiceEligibilityList.SetItemN(index: Integer; value: TFhirHealthcareServiceEligibility);
begin
  assert(value is TFhirHealthcareServiceEligibility);
  ObjectByIndex[index] := value;
end;

{ TFhirHealthcareServiceAvailableTime }

constructor TFhirHealthcareServiceAvailableTime.Create;
begin
  inherited;
end;

destructor TFhirHealthcareServiceAvailableTime.Destroy;
begin
  FDaysOfWeek.free;
  FAllDay.free;
  FAvailableStartTime.free;
  FAvailableEndTime.free;
  inherited;
end;

procedure TFhirHealthcareServiceAvailableTime.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirHealthcareServiceAvailableTime(oSource).FDaysOfWeek = nil) then
  begin
    FDaysOfWeek.free;
    FDaysOfWeek := nil;
  end
  else
  begin
    FDaysOfWeek := TFHIREnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
    FDaysOfWeek.Assign(TFhirHealthcareServiceAvailableTime(oSource).FDaysOfWeek);
  end;
  allDayElement := TFhirHealthcareServiceAvailableTime(oSource).allDayElement.Clone;
  availableStartTimeElement := TFhirHealthcareServiceAvailableTime(oSource).availableStartTimeElement.Clone;
  availableEndTimeElement := TFhirHealthcareServiceAvailableTime(oSource).availableEndTimeElement.Clone;
end;

procedure TFhirHealthcareServiceAvailableTime.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'daysOfWeek') Then
     list.addAll(self, 'daysOfWeek', FDaysOfWeek);
  if (child_name = 'allDay') Then
     list.add(self.link, 'allDay', FAllDay.Link);
  if (child_name = 'availableStartTime') Then
     list.add(self.link, 'availableStartTime', FAvailableStartTime.Link);
  if (child_name = 'availableEndTime') Then
     list.add(self.link, 'availableEndTime', FAvailableEndTime.Link);
end;

procedure TFhirHealthcareServiceAvailableTime.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'daysOfWeek', 'code', true, TFHIREnum, FDaysOfWeek.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'allDay', 'boolean', false, TFhirBoolean, FAllDay.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'availableStartTime', 'time', false, TFhirTime, FAvailableStartTime.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'availableEndTime', 'time', false, TFhirTime, FAvailableEndTime.Link));{2}
end;

function TFhirHealthcareServiceAvailableTime.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'daysOfWeek') then
  begin
    DaysOfWeekList.add(asEnum(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'allDay') then
  begin
    AllDayElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'availableStartTime') then
  begin
    AvailableStartTimeElement := asTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'availableEndTime') then
  begin
    AvailableEndTimeElement := asTime(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirHealthcareServiceAvailableTime.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'daysOfWeek') then FDaysOfWeek.insertItem(index, asEnum(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum, propValue)) {1}
  else inherited;
end;

function TFhirHealthcareServiceAvailableTime.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'allDay') then result := TFhirBoolean.Create() {5b}
  else if (propName = 'availableStartTime') then result := TFhirTime.Create() {5b}
  else if (propName = 'availableEndTime') then result := TFhirTime.Create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirHealthcareServiceAvailableTime.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'daysOfWeek') then result := 'code'
  else if (propName = 'allDay') then result := 'boolean'
  else if (propName = 'availableStartTime') then result := 'time'
  else if (propName = 'availableEndTime') then result := 'time'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirHealthcareServiceAvailableTime.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'allDay') then AllDayElement := nil
  else if (propName = 'availableStartTime') then AvailableStartTimeElement := nil
  else if (propName = 'availableEndTime') then AvailableEndTimeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirHealthcareServiceAvailableTime.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'allDay') then AllDayElement := asBoolean(new){5b}
  else if (propName = 'availableStartTime') then AvailableStartTimeElement := asTime(new){5b}
  else if (propName = 'availableEndTime') then AvailableEndTimeElement := asTime(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirHealthcareServiceAvailableTime.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'daysOfWeek') then FDaysOfWeek.move(source, destination) {1}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirHealthcareServiceAvailableTime.fhirType : string;
begin
  result := 'availableTime';
end;

function TFhirHealthcareServiceAvailableTime.Link : TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime(inherited Link);
end;

function TFhirHealthcareServiceAvailableTime.Clone : TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime(inherited Clone);
end;

function TFhirHealthcareServiceAvailableTime.equals(other : TObject) : boolean; 
var
  o : TFhirHealthcareServiceAvailableTime;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirHealthcareServiceAvailableTime)) then
    result := false
  else
  begin
    o := TFhirHealthcareServiceAvailableTime(other);
    result := compareDeep(daysOfWeekList, o.daysOfWeekList, true) and compareDeep(allDayElement, o.allDayElement, true) and 
      compareDeep(availableStartTimeElement, o.availableStartTimeElement, true) and 
      compareDeep(availableEndTimeElement, o.availableEndTimeElement, true);
  end;
end;

function TFhirHealthcareServiceAvailableTime.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDaysOfWeek) and isEmptyProp(FAllDay) and isEmptyProp(FAvailableStartTime) and isEmptyProp(FAvailableEndTime);
end;

procedure TFhirHealthcareServiceAvailableTime.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('daysOfWeek');
  fields.add('allDay');
  fields.add('availableStartTime');
  fields.add('availableEndTime');
end;

{ TFhirHealthcareServiceAvailableTime }

Function TFhirHealthcareServiceAvailableTime.GetDaysOfWeek : TFhirEnumList;
begin
  if FDaysOfWeek = nil then
    FDaysOfWeek := TFHIREnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
  result := FDaysOfWeek;
end;

Function TFhirHealthcareServiceAvailableTime.GetHasDaysOfWeek : boolean;
begin
  result := (FDaysOfWeek <> nil) and (FDaysOfWeek.count > 0);
end;

Function TFhirHealthcareServiceAvailableTime.GetDaysOfWeekST : TFhirDaysOfWeekEnumList;
  var i : integer;
begin
  result := [];
  if FdaysOfWeek <> nil then
    for i := 0 to FdaysOfWeek.count - 1 do
      result := result + [TFhirDaysOfWeekEnum(StringArrayIndexOfSensitive(CODES_TFhirDaysOfWeekEnum, FdaysOfWeek[i].value))];
end;

Procedure TFhirHealthcareServiceAvailableTime.SetDaysOfWeekST(value : TFhirDaysOfWeekEnumList);
var a : TFhirDaysOfWeekEnum;
begin
  if FdaysOfWeek = nil then
    FdaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
  FdaysOfWeek.clear;
  for a := low(TFhirDaysOfWeekEnum) to high(TFhirDaysOfWeekEnum) do
    if a in value then
      begin
         if FdaysOfWeek = nil then
           FdaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
         FdaysOfWeek.add(TFhirEnum.Create(SYSTEMS_TFhirDaysOfWeekEnum[a], CODES_TFhirDaysOfWeekEnum[a]));
      end;
end;

Procedure TFhirHealthcareServiceAvailableTime.SetAllDay(value : TFhirBoolean);
begin
  FAllDay.free;
  FAllDay := value;
end;

Function TFhirHealthcareServiceAvailableTime.GetAllDayST : Boolean;
begin
  if FAllDay = nil then
    result := false
  else
    result := FAllDay.value;
end;

Procedure TFhirHealthcareServiceAvailableTime.SetAllDayST(value : Boolean);
begin
  if FAllDay = nil then
    FAllDay := TFhirBoolean.Create;
  FAllDay.value := value
end;

Procedure TFhirHealthcareServiceAvailableTime.SetAvailableStartTime(value : TFhirTime);
begin
  FAvailableStartTime.free;
  FAvailableStartTime := value;
end;

Function TFhirHealthcareServiceAvailableTime.GetAvailableStartTimeST : String;
begin
  if FAvailableStartTime = nil then
    result := ''
  else
    result := FAvailableStartTime.value;
end;

Procedure TFhirHealthcareServiceAvailableTime.SetAvailableStartTimeST(value : String);
begin
  if value <> '' then
  begin
    if FAvailableStartTime = nil then
      FAvailableStartTime := TFhirTime.Create;
    FAvailableStartTime.value := value
  end
  else if FAvailableStartTime <> nil then
    FAvailableStartTime.value := '';
end;

Procedure TFhirHealthcareServiceAvailableTime.SetAvailableEndTime(value : TFhirTime);
begin
  FAvailableEndTime.free;
  FAvailableEndTime := value;
end;

Function TFhirHealthcareServiceAvailableTime.GetAvailableEndTimeST : String;
begin
  if FAvailableEndTime = nil then
    result := ''
  else
    result := FAvailableEndTime.value;
end;

Procedure TFhirHealthcareServiceAvailableTime.SetAvailableEndTimeST(value : String);
begin
  if value <> '' then
  begin
    if FAvailableEndTime = nil then
      FAvailableEndTime := TFhirTime.Create;
    FAvailableEndTime.value := value
  end
  else if FAvailableEndTime <> nil then
    FAvailableEndTime.value := '';
end;

function TFhirHealthcareServiceAvailableTime.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FDaysOfWeek.sizeInBytes(magic));
  inc(result, FAllDay.sizeInBytes(magic));
  inc(result, FAvailableStartTime.sizeInBytes(magic));
  inc(result, FAvailableEndTime.sizeInBytes(magic));
end;

{ TFhirHealthcareServiceAvailableTimeListEnumerator }

Constructor TFhirHealthcareServiceAvailableTimeListEnumerator.Create(list : TFhirHealthcareServiceAvailableTimeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirHealthcareServiceAvailableTimeListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirHealthcareServiceAvailableTimeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirHealthcareServiceAvailableTimeListEnumerator.GetCurrent : TFhirHealthcareServiceAvailableTime;
begin
  Result := FList[FIndex];
end;

function TFhirHealthcareServiceAvailableTimeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirHealthcareServiceAvailableTimeList }
function TFhirHealthcareServiceAvailableTimeList.AddItem(value: TFhirHealthcareServiceAvailableTime): TFhirHealthcareServiceAvailableTime;
begin
  add(value);
  result := value;
end;

function TFhirHealthcareServiceAvailableTimeList.Append: TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceAvailableTimeList.ClearItems;
begin
  Clear;
end;

function TFhirHealthcareServiceAvailableTimeList.GetEnumerator : TFhirHealthcareServiceAvailableTimeListEnumerator;
begin
  result := TFhirHealthcareServiceAvailableTimeListEnumerator.Create(self.link);
end;

function TFhirHealthcareServiceAvailableTimeList.Clone: TFhirHealthcareServiceAvailableTimeList;
begin
  result := TFhirHealthcareServiceAvailableTimeList(inherited Clone);
end;

function TFhirHealthcareServiceAvailableTimeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirHealthcareServiceAvailableTimeList.GetItemN(index: Integer): TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceAvailableTimeList.ItemClass: TFslObjectClass;
begin
  result := TFhirHealthcareServiceAvailableTime;
end;
function TFhirHealthcareServiceAvailableTimeList.IndexOf(value: TFhirHealthcareServiceAvailableTime): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirHealthcareServiceAvailableTimeList.Insert(index: Integer): TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceAvailableTimeList.InsertItem(index: Integer; value: TFhirHealthcareServiceAvailableTime);
begin
  assert(value is TFhirHealthcareServiceAvailableTime);
  Inherited Insert(index, value);
end;

function TFhirHealthcareServiceAvailableTimeList.Item(index: Integer): TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceAvailableTimeList.Link: TFhirHealthcareServiceAvailableTimeList;
begin
  result := TFhirHealthcareServiceAvailableTimeList(inherited Link);
end;

procedure TFhirHealthcareServiceAvailableTimeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirHealthcareServiceAvailableTimeList.SetItemByIndex(index: Integer; value: TFhirHealthcareServiceAvailableTime);
begin
  assert(value is TFhirHealthcareServiceAvailableTime);
  FhirHealthcareServiceAvailableTimes[index] := value;
end;

procedure TFhirHealthcareServiceAvailableTimeList.SetItemN(index: Integer; value: TFhirHealthcareServiceAvailableTime);
begin
  assert(value is TFhirHealthcareServiceAvailableTime);
  ObjectByIndex[index] := value;
end;

{ TFhirHealthcareServiceNotAvailable }

constructor TFhirHealthcareServiceNotAvailable.Create;
begin
  inherited;
end;

destructor TFhirHealthcareServiceNotAvailable.Destroy;
begin
  FDescription.free;
  FDuring.free;
  inherited;
end;

procedure TFhirHealthcareServiceNotAvailable.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirHealthcareServiceNotAvailable(oSource).descriptionElement.Clone;
  during := TFhirHealthcareServiceNotAvailable(oSource).during.Clone;
end;

procedure TFhirHealthcareServiceNotAvailable.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'during') Then
     list.add(self.link, 'during', FDuring.Link);
end;

procedure TFhirHealthcareServiceNotAvailable.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'during', 'Period', false, TFhirPeriod, FDuring.Link));{2}
end;

function TFhirHealthcareServiceNotAvailable.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'during') then
  begin
    During := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirHealthcareServiceNotAvailable.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirHealthcareServiceNotAvailable.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.Create() {5b}
  else if (propName = 'during') then result := TFhirPeriod.Create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirHealthcareServiceNotAvailable.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'during') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirHealthcareServiceNotAvailable.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'during') then DuringElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirHealthcareServiceNotAvailable.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'during') then DuringElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirHealthcareServiceNotAvailable.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirHealthcareServiceNotAvailable.fhirType : string;
begin
  result := 'notAvailable';
end;

function TFhirHealthcareServiceNotAvailable.Link : TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable(inherited Link);
end;

function TFhirHealthcareServiceNotAvailable.Clone : TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable(inherited Clone);
end;

function TFhirHealthcareServiceNotAvailable.equals(other : TObject) : boolean; 
var
  o : TFhirHealthcareServiceNotAvailable;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirHealthcareServiceNotAvailable)) then
    result := false
  else
  begin
    o := TFhirHealthcareServiceNotAvailable(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(duringElement, o.duringElement, true);
  end;
end;

function TFhirHealthcareServiceNotAvailable.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FDuring);
end;

procedure TFhirHealthcareServiceNotAvailable.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('during');
end;

{ TFhirHealthcareServiceNotAvailable }

Procedure TFhirHealthcareServiceNotAvailable.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirHealthcareServiceNotAvailable.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirHealthcareServiceNotAvailable.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.Create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirHealthcareServiceNotAvailable.SetDuring(value : TFhirPeriod);
begin
  FDuring.free;
  FDuring := value;
end;

function TFhirHealthcareServiceNotAvailable.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FDescription.sizeInBytes(magic));
  inc(result, FDuring.sizeInBytes(magic));
end;

{ TFhirHealthcareServiceNotAvailableListEnumerator }

Constructor TFhirHealthcareServiceNotAvailableListEnumerator.Create(list : TFhirHealthcareServiceNotAvailableList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirHealthcareServiceNotAvailableListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirHealthcareServiceNotAvailableListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirHealthcareServiceNotAvailableListEnumerator.GetCurrent : TFhirHealthcareServiceNotAvailable;
begin
  Result := FList[FIndex];
end;

function TFhirHealthcareServiceNotAvailableListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirHealthcareServiceNotAvailableList }
function TFhirHealthcareServiceNotAvailableList.AddItem(value: TFhirHealthcareServiceNotAvailable): TFhirHealthcareServiceNotAvailable;
begin
  add(value);
  result := value;
end;

function TFhirHealthcareServiceNotAvailableList.Append: TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceNotAvailableList.ClearItems;
begin
  Clear;
end;

function TFhirHealthcareServiceNotAvailableList.GetEnumerator : TFhirHealthcareServiceNotAvailableListEnumerator;
begin
  result := TFhirHealthcareServiceNotAvailableListEnumerator.Create(self.link);
end;

function TFhirHealthcareServiceNotAvailableList.Clone: TFhirHealthcareServiceNotAvailableList;
begin
  result := TFhirHealthcareServiceNotAvailableList(inherited Clone);
end;

function TFhirHealthcareServiceNotAvailableList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirHealthcareServiceNotAvailableList.GetItemN(index: Integer): TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceNotAvailableList.ItemClass: TFslObjectClass;
begin
  result := TFhirHealthcareServiceNotAvailable;
end;
function TFhirHealthcareServiceNotAvailableList.IndexOf(value: TFhirHealthcareServiceNotAvailable): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirHealthcareServiceNotAvailableList.Insert(index: Integer): TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceNotAvailableList.InsertItem(index: Integer; value: TFhirHealthcareServiceNotAvailable);
begin
  assert(value is TFhirHealthcareServiceNotAvailable);
  Inherited Insert(index, value);
end;

function TFhirHealthcareServiceNotAvailableList.Item(index: Integer): TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceNotAvailableList.Link: TFhirHealthcareServiceNotAvailableList;
begin
  result := TFhirHealthcareServiceNotAvailableList(inherited Link);
end;

procedure TFhirHealthcareServiceNotAvailableList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirHealthcareServiceNotAvailableList.SetItemByIndex(index: Integer; value: TFhirHealthcareServiceNotAvailable);
begin
  assert(value is TFhirHealthcareServiceNotAvailable);
  FhirHealthcareServiceNotAvailables[index] := value;
end;

procedure TFhirHealthcareServiceNotAvailableList.SetItemN(index: Integer; value: TFhirHealthcareServiceNotAvailable);
begin
  assert(value is TFhirHealthcareServiceNotAvailable);
  ObjectByIndex[index] := value;
end;

{ TFhirHealthcareService }

constructor TFhirHealthcareService.Create;
begin
  inherited;
end;

destructor TFhirHealthcareService.Destroy;
begin
  FIdentifierList.free;
  FActive.free;
  FProvidedBy.free;
  FCategoryList.free;
  FType_List.free;
  FSpecialtyList.free;
  FLocationList.free;
  FName.free;
  FComment.free;
  FExtraDetails.free;
  FPhoto.free;
  FTelecomList.free;
  FCoverageAreaList.free;
  FServiceProvisionCodeList.free;
  FEligibilityList.free;
  FProgram_List.free;
  FCharacteristicList.free;
  FCommunicationList.free;
  FReferralMethodList.free;
  FAppointmentRequired.free;
  FAvailableTimeList.free;
  FNotAvailableList.free;
  FAvailabilityExceptions.free;
  FEndpointList.free;
  inherited;
end;

function TFhirHealthcareService.GetResourceType : TFhirResourceType;
begin
  result := frtHealthcareService;
end;

procedure TFhirHealthcareService.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirHealthcareService(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirHealthcareService(oSource).FIdentifierList);
  end;
  activeElement := TFhirHealthcareService(oSource).activeElement.Clone;
  providedBy := TFhirHealthcareService(oSource).providedBy.Clone;
  if (TFhirHealthcareService(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirHealthcareService(oSource).FCategoryList);
  end;
  if (TFhirHealthcareService(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirHealthcareService(oSource).FType_List);
  end;
  if (TFhirHealthcareService(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirHealthcareService(oSource).FSpecialtyList);
  end;
  if (TFhirHealthcareService(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirReferenceList{TFhirLocation}.Create;
    FLocationList.Assign(TFhirHealthcareService(oSource).FLocationList);
  end;
  nameElement := TFhirHealthcareService(oSource).nameElement.Clone;
  commentElement := TFhirHealthcareService(oSource).commentElement.Clone;
  extraDetailsElement := TFhirHealthcareService(oSource).extraDetailsElement.Clone;
  photo := TFhirHealthcareService(oSource).photo.Clone;
  if (TFhirHealthcareService(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirHealthcareService(oSource).FTelecomList);
  end;
  if (TFhirHealthcareService(oSource).FCoverageAreaList = nil) then
  begin
    FCoverageAreaList.free;
    FCoverageAreaList := nil;
  end
  else
  begin
    if FCoverageAreaList = nil then
      FCoverageAreaList := TFhirReferenceList{TFhirLocation}.Create;
    FCoverageAreaList.Assign(TFhirHealthcareService(oSource).FCoverageAreaList);
  end;
  if (TFhirHealthcareService(oSource).FServiceProvisionCodeList = nil) then
  begin
    FServiceProvisionCodeList.free;
    FServiceProvisionCodeList := nil;
  end
  else
  begin
    if FServiceProvisionCodeList = nil then
      FServiceProvisionCodeList := TFhirCodeableConceptList.Create;
    FServiceProvisionCodeList.Assign(TFhirHealthcareService(oSource).FServiceProvisionCodeList);
  end;
  if (TFhirHealthcareService(oSource).FEligibilityList = nil) then
  begin
    FEligibilityList.free;
    FEligibilityList := nil;
  end
  else
  begin
    if FEligibilityList = nil then
      FEligibilityList := TFhirHealthcareServiceEligibilityList.Create;
    FEligibilityList.Assign(TFhirHealthcareService(oSource).FEligibilityList);
  end;
  if (TFhirHealthcareService(oSource).FProgram_List = nil) then
  begin
    FProgram_List.free;
    FProgram_List := nil;
  end
  else
  begin
    if FProgram_List = nil then
      FProgram_List := TFhirCodeableConceptList.Create;
    FProgram_List.Assign(TFhirHealthcareService(oSource).FProgram_List);
  end;
  if (TFhirHealthcareService(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirCodeableConceptList.Create;
    FCharacteristicList.Assign(TFhirHealthcareService(oSource).FCharacteristicList);
  end;
  if (TFhirHealthcareService(oSource).FCommunicationList = nil) then
  begin
    FCommunicationList.free;
    FCommunicationList := nil;
  end
  else
  begin
    if FCommunicationList = nil then
      FCommunicationList := TFhirCodeableConceptList.Create;
    FCommunicationList.Assign(TFhirHealthcareService(oSource).FCommunicationList);
  end;
  if (TFhirHealthcareService(oSource).FReferralMethodList = nil) then
  begin
    FReferralMethodList.free;
    FReferralMethodList := nil;
  end
  else
  begin
    if FReferralMethodList = nil then
      FReferralMethodList := TFhirCodeableConceptList.Create;
    FReferralMethodList.Assign(TFhirHealthcareService(oSource).FReferralMethodList);
  end;
  appointmentRequiredElement := TFhirHealthcareService(oSource).appointmentRequiredElement.Clone;
  if (TFhirHealthcareService(oSource).FAvailableTimeList = nil) then
  begin
    FAvailableTimeList.free;
    FAvailableTimeList := nil;
  end
  else
  begin
    if FAvailableTimeList = nil then
      FAvailableTimeList := TFhirHealthcareServiceAvailableTimeList.Create;
    FAvailableTimeList.Assign(TFhirHealthcareService(oSource).FAvailableTimeList);
  end;
  if (TFhirHealthcareService(oSource).FNotAvailableList = nil) then
  begin
    FNotAvailableList.free;
    FNotAvailableList := nil;
  end
  else
  begin
    if FNotAvailableList = nil then
      FNotAvailableList := TFhirHealthcareServiceNotAvailableList.Create;
    FNotAvailableList.Assign(TFhirHealthcareService(oSource).FNotAvailableList);
  end;
  availabilityExceptionsElement := TFhirHealthcareService(oSource).availabilityExceptionsElement.Clone;
  if (TFhirHealthcareService(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList{TFhirEndpoint}.Create;
    FEndpointList.Assign(TFhirHealthcareService(oSource).FEndpointList);
  end;
end;

procedure TFhirHealthcareService.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'providedBy') Then
     list.add(self.link, 'providedBy', FProvidedBy.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'extraDetails') Then
     list.add(self.link, 'extraDetails', FExtraDetails.Link);
  if (child_name = 'photo') Then
     list.add(self.link, 'photo', FPhoto.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'coverageArea') Then
    list.addAll(self, 'coverageArea', FCoverageAreaList);
  if (child_name = 'serviceProvisionCode') Then
    list.addAll(self, 'serviceProvisionCode', FServiceProvisionCodeList);
  if (child_name = 'eligibility') Then
    list.addAll(self, 'eligibility', FEligibilityList);
  if (child_name = 'program') Then
    list.addAll(self, 'program', FProgram_List);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
  if (child_name = 'communication') Then
    list.addAll(self, 'communication', FCommunicationList);
  if (child_name = 'referralMethod') Then
    list.addAll(self, 'referralMethod', FReferralMethodList);
  if (child_name = 'appointmentRequired') Then
     list.add(self.link, 'appointmentRequired', FAppointmentRequired.Link);
  if (child_name = 'availableTime') Then
    list.addAll(self, 'availableTime', FAvailableTimeList);
  if (child_name = 'notAvailable') Then
    list.addAll(self, 'notAvailable', FNotAvailableList);
  if (child_name = 'availabilityExceptions') Then
     list.add(self.link, 'availabilityExceptions', FAvailabilityExceptions.Link);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
end;

procedure TFhirHealthcareService.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'providedBy', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FProvidedBy.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'location', 'Reference(Location)', true, TFhirReference{TFhirLocation}, FLocationList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'extraDetails', 'markdown', false, TFhirMarkdown, FExtraDetails.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'photo', 'Attachment', false, TFhirAttachment, FPhoto.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'coverageArea', 'Reference(Location)', true, TFhirReference{TFhirLocation}, FCoverageAreaList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'serviceProvisionCode', 'CodeableConcept', true, TFhirCodeableConcept, FServiceProvisionCodeList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'eligibility', '', true, TFhirHealthcareServiceEligibility, FEligibilityList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'program', 'CodeableConcept', true, TFhirCodeableConcept, FProgram_List.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'characteristic', 'CodeableConcept', true, TFhirCodeableConcept, FCharacteristicList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'communication', 'CodeableConcept', true, TFhirCodeableConcept, FCommunicationList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'referralMethod', 'CodeableConcept', true, TFhirCodeableConcept, FReferralMethodList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'appointmentRequired', 'boolean', false, TFhirBoolean, FAppointmentRequired.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'availableTime', '', true, TFhirHealthcareServiceAvailableTime, FAvailableTimeList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'notAvailable', '', true, TFhirHealthcareServiceNotAvailable, FNotAvailableList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'availabilityExceptions', 'string', false, TFhirString, FAvailabilityExceptions.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'endpoint', 'Reference(Endpoint)', true, TFhirReference{TFhirEndpoint}, FEndpointList.Link)){3};
end;

function TFhirHealthcareService.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'providedBy') then
  begin
    ProvidedBy := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(propValue as TFhirReference{TFhirLocation}){2a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'extraDetails') then
  begin
    ExtraDetailsElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'photo') then
  begin
    Photo := propValue as TFhirAttachment{4b};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else if (propName = 'coverageArea') then
  begin
    CoverageAreaList.add(propValue as TFhirReference{TFhirLocation}){2a};
    result := propValue;
  end
  else if (propName = 'serviceProvisionCode') then
  begin
    ServiceProvisionCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'eligibility') then
  begin
    EligibilityList.add(propValue as TFhirHealthcareServiceEligibility){2a};
    result := propValue;
  end
  else if (propName = 'program') then
  begin
    Program_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'communication') then
  begin
    CommunicationList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'referralMethod') then
  begin
    ReferralMethodList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'appointmentRequired') then
  begin
    AppointmentRequiredElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'availableTime') then
  begin
    AvailableTimeList.add(propValue as TFhirHealthcareServiceAvailableTime){2a};
    result := propValue;
  end
  else if (propName = 'notAvailable') then
  begin
    NotAvailableList.add(propValue as TFhirHealthcareServiceNotAvailable){2a};
    result := propValue;
  end
  else if (propName = 'availabilityExceptions') then
  begin
    AvailabilityExceptionsElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference{TFhirEndpoint}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirHealthcareService.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'location') then LocationList.insertItem(index, propValue as TFhirReference{TFhirLocation}){2a}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else if (propName = 'coverageArea') then CoverageAreaList.insertItem(index, propValue as TFhirReference{TFhirLocation}){2a}
  else if (propName = 'serviceProvisionCode') then ServiceProvisionCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'eligibility') then EligibilityList.insertItem(index, propValue as TFhirHealthcareServiceEligibility){2a}
  else if (propName = 'program') then Program_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'communication') then CommunicationList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'referralMethod') then ReferralMethodList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'availableTime') then AvailableTimeList.insertItem(index, propValue as TFhirHealthcareServiceAvailableTime){2a}
  else if (propName = 'notAvailable') then NotAvailableList.insertItem(index, propValue as TFhirHealthcareServiceNotAvailable){2a}
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference{TFhirEndpoint}){2a}
  else inherited;
end;

function TFhirHealthcareService.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'active') then result := TFhirBoolean.Create() {5b}
  else if (propName = 'providedBy') then result := TFhirReference{TFhirOrganization}.Create(){4b}
  else if (propName = 'category') then result := CategoryList.new(){2}
  else if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'specialty') then result := SpecialtyList.new(){2}
  else if (propName = 'location') then result := LocationList.new(){2}
  else if (propName = 'name') then result := TFhirString.Create() {5b}
  else if (propName = 'comment') then result := TFhirString.Create() {5b}
  else if (propName = 'extraDetails') then result := TFhirMarkdown.Create() {5b}
  else if (propName = 'photo') then result := TFhirAttachment.Create(){4b}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else if (propName = 'coverageArea') then result := CoverageAreaList.new(){2}
  else if (propName = 'serviceProvisionCode') then result := ServiceProvisionCodeList.new(){2}
  else if (propName = 'eligibility') then result := EligibilityList.new(){2}
  else if (propName = 'program') then result := Program_List.new(){2}
  else if (propName = 'characteristic') then result := CharacteristicList.new(){2}
  else if (propName = 'communication') then result := CommunicationList.new(){2}
  else if (propName = 'referralMethod') then result := ReferralMethodList.new(){2}
  else if (propName = 'appointmentRequired') then result := TFhirBoolean.Create() {5b}
  else if (propName = 'availableTime') then result := AvailableTimeList.new(){2}
  else if (propName = 'notAvailable') then result := NotAvailableList.new(){2}
  else if (propName = 'availabilityExceptions') then result := TFhirString.Create() {5b}
  else if (propName = 'endpoint') then result := EndpointList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirHealthcareService.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'providedBy') then result := 'Reference'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'extraDetails') then result := 'markdown'
  else if (propName = 'photo') then result := 'Attachment'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'coverageArea') then result := 'Reference'
  else if (propName = 'serviceProvisionCode') then result := 'CodeableConcept'
  else if (propName = 'eligibility') then result := ''
  else if (propName = 'program') then result := 'CodeableConcept'
  else if (propName = 'characteristic') then result := 'CodeableConcept'
  else if (propName = 'communication') then result := 'CodeableConcept'
  else if (propName = 'referralMethod') then result := 'CodeableConcept'
  else if (propName = 'appointmentRequired') then result := 'boolean'
  else if (propName = 'availableTime') then result := ''
  else if (propName = 'notAvailable') then result := ''
  else if (propName = 'availabilityExceptions') then result := 'string'
  else if (propName = 'endpoint') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirHealthcareService.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'providedBy') then ProvidedByElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {2}
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value) {2}
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value) {2}
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else if (propName = 'extraDetails') then ExtraDetailsElement := nil
  else if (propName = 'photo') then PhotoElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else if (propName = 'coverageArea') then deletePropertyValue('coverageArea', CoverageAreaList, value) {2}
  else if (propName = 'serviceProvisionCode') then deletePropertyValue('serviceProvisionCode', ServiceProvisionCodeList, value) {2}
  else if (propName = 'eligibility') then deletePropertyValue('eligibility', EligibilityList, value) {2}
  else if (propName = 'program') then deletePropertyValue('program', Program_List, value) {2}
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value) {2}
  else if (propName = 'communication') then deletePropertyValue('communication', CommunicationList, value) {2}
  else if (propName = 'referralMethod') then deletePropertyValue('referralMethod', ReferralMethodList, value) {2}
  else if (propName = 'appointmentRequired') then AppointmentRequiredElement := nil
  else if (propName = 'availableTime') then deletePropertyValue('availableTime', AvailableTimeList, value) {2}
  else if (propName = 'notAvailable') then deletePropertyValue('notAvailable', NotAvailableList, value) {2}
  else if (propName = 'availabilityExceptions') then AvailabilityExceptionsElement := nil
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirHealthcareService.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'active') then ActiveElement := asBoolean(new){5b}
  else if (propName = 'providedBy') then ProvidedByElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {2}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new) {2}
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new) {2}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'comment') then CommentElement := asString(new){5b}
  else if (propName = 'extraDetails') then ExtraDetailsElement := asMarkdown(new){5b}
  else if (propName = 'photo') then PhotoElement := new as TFhirAttachment{4}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else if (propName = 'coverageArea') then replacePropertyValue('coverageArea', CoverageAreaList, existing, new) {2}
  else if (propName = 'serviceProvisionCode') then replacePropertyValue('serviceProvisionCode', ServiceProvisionCodeList, existing, new) {2}
  else if (propName = 'eligibility') then replacePropertyValue('eligibility', EligibilityList, existing, new) {2}
  else if (propName = 'program') then replacePropertyValue('program', Program_List, existing, new) {2}
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new) {2}
  else if (propName = 'communication') then replacePropertyValue('communication', CommunicationList, existing, new) {2}
  else if (propName = 'referralMethod') then replacePropertyValue('referralMethod', ReferralMethodList, existing, new) {2}
  else if (propName = 'appointmentRequired') then AppointmentRequiredElement := asBoolean(new){5b}
  else if (propName = 'availableTime') then replacePropertyValue('availableTime', AvailableTimeList, existing, new) {2}
  else if (propName = 'notAvailable') then replacePropertyValue('notAvailable', NotAvailableList, existing, new) {2}
  else if (propName = 'availabilityExceptions') then AvailabilityExceptionsElement := asString(new){5b}
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirHealthcareService.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'category') then CategoryList.move(source, destination){2a}
  else if (propName = 'type') then Type_List.move(source, destination){2a}
  else if (propName = 'specialty') then SpecialtyList.move(source, destination){2a}
  else if (propName = 'location') then LocationList.move(source, destination){2a}
  else if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else if (propName = 'coverageArea') then CoverageAreaList.move(source, destination){2a}
  else if (propName = 'serviceProvisionCode') then ServiceProvisionCodeList.move(source, destination){2a}
  else if (propName = 'eligibility') then EligibilityList.move(source, destination){2a}
  else if (propName = 'program') then Program_List.move(source, destination){2a}
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination){2a}
  else if (propName = 'communication') then CommunicationList.move(source, destination){2a}
  else if (propName = 'referralMethod') then ReferralMethodList.move(source, destination){2a}
  else if (propName = 'availableTime') then AvailableTimeList.move(source, destination){2a}
  else if (propName = 'notAvailable') then NotAvailableList.move(source, destination){2a}
  else if (propName = 'endpoint') then EndpointList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirHealthcareService.fhirType : string;
begin
  result := 'HealthcareService';
end;

function TFhirHealthcareService.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FProvidedBy) and isEmptyProp(FcategoryList) and isEmptyProp(Ftype_List) and isEmptyProp(FspecialtyList) and isEmptyProp(FlocationList) and isEmptyProp(FName) and isEmptyProp(FComment) and isEmptyProp(FExtraDetails) and isEmptyProp(FPhoto) and isEmptyProp(FtelecomList) and isEmptyProp(FcoverageAreaList) and isEmptyProp(FserviceProvisionCodeList) and isEmptyProp(FeligibilityList) and isEmptyProp(Fprogram_List) and isEmptyProp(FcharacteristicList) and isEmptyProp(FcommunicationList) and isEmptyProp(FreferralMethodList) and isEmptyProp(FAppointmentRequired) and isEmptyProp(FavailableTimeList) and isEmptyProp(FnotAvailableList) and isEmptyProp(FAvailabilityExceptions) and isEmptyProp(FendpointList);
end;

function TFhirHealthcareService.equals(other : TObject) : boolean; 
var
  o : TFhirHealthcareService;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirHealthcareService)) then
    result := false
  else
  begin
    o := TFhirHealthcareService(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(providedByElement, o.providedByElement, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(type_List, o.type_List, true) and compareDeep(specialtyList, o.specialtyList, true) and 
      compareDeep(locationList, o.locationList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(commentElement, o.commentElement, true) and compareDeep(extraDetailsElement, o.extraDetailsElement, true) and 
      compareDeep(photoElement, o.photoElement, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(coverageAreaList, o.coverageAreaList, true) and compareDeep(serviceProvisionCodeList, o.serviceProvisionCodeList, true) and 
      compareDeep(eligibilityList, o.eligibilityList, true) and compareDeep(program_List, o.program_List, true) and 
      compareDeep(characteristicList, o.characteristicList, true) and compareDeep(communicationList, o.communicationList, true) and 
      compareDeep(referralMethodList, o.referralMethodList, true) and compareDeep(appointmentRequiredElement, o.appointmentRequiredElement, true) and 
      compareDeep(availableTimeList, o.availableTimeList, true) and compareDeep(notAvailableList, o.notAvailableList, true) and 
      compareDeep(availabilityExceptionsElement, o.availabilityExceptionsElement, true) and 
      compareDeep(endpointList, o.endpointList, true);
  end;
end;

function TFhirHealthcareService.Link : TFhirHealthcareService;
begin
  result := TFhirHealthcareService(inherited Link);
end;

function TFhirHealthcareService.Clone : TFhirHealthcareService;
begin
  result := TFhirHealthcareService(inherited Clone);
end;

procedure TFhirHealthcareService.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('providedBy');
  fields.add('category');
  fields.add('type');
  fields.add('specialty');
  fields.add('location');
  fields.add('name');
  fields.add('comment');
  fields.add('extraDetails');
  fields.add('photo');
  fields.add('telecom');
  fields.add('coverageArea');
  fields.add('serviceProvisionCode');
  fields.add('eligibility');
  fields.add('program');
  fields.add('characteristic');
  fields.add('communication');
  fields.add('referralMethod');
  fields.add('appointmentRequired');
  fields.add('availableTime');
  fields.add('notAvailable');
  fields.add('availabilityExceptions');
  fields.add('endpoint');
end;

{ TFhirHealthcareService }

Function TFhirHealthcareService.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirHealthcareService.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirHealthcareService.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

Function TFhirHealthcareService.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

Procedure TFhirHealthcareService.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.Create;
  FActive.value := value
end;

Procedure TFhirHealthcareService.SetProvidedBy(value : TFhirReference{TFhirOrganization});
begin
  FProvidedBy.free;
  FProvidedBy := value;
end;

Function TFhirHealthcareService.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

Function TFhirHealthcareService.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

Function TFhirHealthcareService.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

Function TFhirHealthcareService.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Function TFhirHealthcareService.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

Function TFhirHealthcareService.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

Function TFhirHealthcareService.GetLocationList : TFhirReferenceList{TFhirLocation};
begin
  if FLocationList = nil then
    FLocationList := TFhirReferenceList{TFhirLocation}.Create;
  result := FLocationList;
end;

Function TFhirHealthcareService.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

Procedure TFhirHealthcareService.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirHealthcareService.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirHealthcareService.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.Create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirHealthcareService.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirHealthcareService.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirHealthcareService.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.Create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

Procedure TFhirHealthcareService.SetExtraDetails(value : TFhirMarkdown);
begin
  FExtraDetails.free;
  FExtraDetails := value;
end;

Function TFhirHealthcareService.GetExtraDetailsST : String;
begin
  if FExtraDetails = nil then
    result := ''
  else
    result := FExtraDetails.value;
end;

Procedure TFhirHealthcareService.SetExtraDetailsST(value : String);
begin
  if value <> '' then
  begin
    if FExtraDetails = nil then
      FExtraDetails := TFhirMarkdown.Create;
    FExtraDetails.value := value
  end
  else if FExtraDetails <> nil then
    FExtraDetails.value := '';
end;

Procedure TFhirHealthcareService.SetPhoto(value : TFhirAttachment);
begin
  FPhoto.free;
  FPhoto := value;
end;

Function TFhirHealthcareService.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirHealthcareService.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

Function TFhirHealthcareService.GetCoverageAreaList : TFhirReferenceList{TFhirLocation};
begin
  if FCoverageAreaList = nil then
    FCoverageAreaList := TFhirReferenceList{TFhirLocation}.Create;
  result := FCoverageAreaList;
end;

Function TFhirHealthcareService.GetHasCoverageAreaList : boolean;
begin
  result := (FCoverageAreaList <> nil) and (FCoverageAreaList.count > 0);
end;

Function TFhirHealthcareService.GetServiceProvisionCodeList : TFhirCodeableConceptList;
begin
  if FServiceProvisionCodeList = nil then
    FServiceProvisionCodeList := TFhirCodeableConceptList.Create;
  result := FServiceProvisionCodeList;
end;

Function TFhirHealthcareService.GetHasServiceProvisionCodeList : boolean;
begin
  result := (FServiceProvisionCodeList <> nil) and (FServiceProvisionCodeList.count > 0);
end;

Function TFhirHealthcareService.GetEligibilityList : TFhirHealthcareServiceEligibilityList;
begin
  if FEligibilityList = nil then
    FEligibilityList := TFhirHealthcareServiceEligibilityList.Create;
  result := FEligibilityList;
end;

Function TFhirHealthcareService.GetHasEligibilityList : boolean;
begin
  result := (FEligibilityList <> nil) and (FEligibilityList.count > 0);
end;

Function TFhirHealthcareService.GetProgram_List : TFhirCodeableConceptList;
begin
  if FProgram_List = nil then
    FProgram_List := TFhirCodeableConceptList.Create;
  result := FProgram_List;
end;

Function TFhirHealthcareService.GetHasProgram_List : boolean;
begin
  result := (FProgram_List <> nil) and (FProgram_List.count > 0);
end;

Function TFhirHealthcareService.GetCharacteristicList : TFhirCodeableConceptList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirCodeableConceptList.Create;
  result := FCharacteristicList;
end;

Function TFhirHealthcareService.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

Function TFhirHealthcareService.GetCommunicationList : TFhirCodeableConceptList;
begin
  if FCommunicationList = nil then
    FCommunicationList := TFhirCodeableConceptList.Create;
  result := FCommunicationList;
end;

Function TFhirHealthcareService.GetHasCommunicationList : boolean;
begin
  result := (FCommunicationList <> nil) and (FCommunicationList.count > 0);
end;

Function TFhirHealthcareService.GetReferralMethodList : TFhirCodeableConceptList;
begin
  if FReferralMethodList = nil then
    FReferralMethodList := TFhirCodeableConceptList.Create;
  result := FReferralMethodList;
end;

Function TFhirHealthcareService.GetHasReferralMethodList : boolean;
begin
  result := (FReferralMethodList <> nil) and (FReferralMethodList.count > 0);
end;

Procedure TFhirHealthcareService.SetAppointmentRequired(value : TFhirBoolean);
begin
  FAppointmentRequired.free;
  FAppointmentRequired := value;
end;

Function TFhirHealthcareService.GetAppointmentRequiredST : Boolean;
begin
  if FAppointmentRequired = nil then
    result := false
  else
    result := FAppointmentRequired.value;
end;

Procedure TFhirHealthcareService.SetAppointmentRequiredST(value : Boolean);
begin
  if FAppointmentRequired = nil then
    FAppointmentRequired := TFhirBoolean.Create;
  FAppointmentRequired.value := value
end;

Function TFhirHealthcareService.GetAvailableTimeList : TFhirHealthcareServiceAvailableTimeList;
begin
  if FAvailableTimeList = nil then
    FAvailableTimeList := TFhirHealthcareServiceAvailableTimeList.Create;
  result := FAvailableTimeList;
end;

Function TFhirHealthcareService.GetHasAvailableTimeList : boolean;
begin
  result := (FAvailableTimeList <> nil) and (FAvailableTimeList.count > 0);
end;

Function TFhirHealthcareService.GetNotAvailableList : TFhirHealthcareServiceNotAvailableList;
begin
  if FNotAvailableList = nil then
    FNotAvailableList := TFhirHealthcareServiceNotAvailableList.Create;
  result := FNotAvailableList;
end;

Function TFhirHealthcareService.GetHasNotAvailableList : boolean;
begin
  result := (FNotAvailableList <> nil) and (FNotAvailableList.count > 0);
end;

Procedure TFhirHealthcareService.SetAvailabilityExceptions(value : TFhirString);
begin
  FAvailabilityExceptions.free;
  FAvailabilityExceptions := value;
end;

Function TFhirHealthcareService.GetAvailabilityExceptionsST : String;
begin
  if FAvailabilityExceptions = nil then
    result := ''
  else
    result := FAvailabilityExceptions.value;
end;

Procedure TFhirHealthcareService.SetAvailabilityExceptionsST(value : String);
begin
  if value <> '' then
  begin
    if FAvailabilityExceptions = nil then
      FAvailabilityExceptions := TFhirString.Create;
    FAvailabilityExceptions.value := value
  end
  else if FAvailabilityExceptions <> nil then
    FAvailabilityExceptions.value := '';
end;

Function TFhirHealthcareService.GetEndpointList : TFhirReferenceList{TFhirEndpoint};
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList{TFhirEndpoint}.Create;
  result := FEndpointList;
end;

Function TFhirHealthcareService.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

function TFhirHealthcareService.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FidentifierList.sizeInBytes(magic));
  inc(result, FActive.sizeInBytes(magic));
  inc(result, FProvidedBy.sizeInBytes(magic));
  inc(result, FcategoryList.sizeInBytes(magic));
  inc(result, Ftype_List.sizeInBytes(magic));
  inc(result, FspecialtyList.sizeInBytes(magic));
  inc(result, FlocationList.sizeInBytes(magic));
  inc(result, FName.sizeInBytes(magic));
  inc(result, FComment.sizeInBytes(magic));
  inc(result, FExtraDetails.sizeInBytes(magic));
  inc(result, FPhoto.sizeInBytes(magic));
  inc(result, FtelecomList.sizeInBytes(magic));
  inc(result, FcoverageAreaList.sizeInBytes(magic));
  inc(result, FserviceProvisionCodeList.sizeInBytes(magic));
  inc(result, FeligibilityList.sizeInBytes(magic));
  inc(result, Fprogram_List.sizeInBytes(magic));
  inc(result, FcharacteristicList.sizeInBytes(magic));
  inc(result, FcommunicationList.sizeInBytes(magic));
  inc(result, FreferralMethodList.sizeInBytes(magic));
  inc(result, FAppointmentRequired.sizeInBytes(magic));
  inc(result, FavailableTimeList.sizeInBytes(magic));
  inc(result, FnotAvailableList.sizeInBytes(magic));
  inc(result, FAvailabilityExceptions.sizeInBytes(magic));
  inc(result, FendpointList.sizeInBytes(magic));
end;

{ TFhirHealthcareServiceListEnumerator }

Constructor TFhirHealthcareServiceListEnumerator.Create(list : TFhirHealthcareServiceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirHealthcareServiceListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirHealthcareServiceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirHealthcareServiceListEnumerator.GetCurrent : TFhirHealthcareService;
begin
  Result := FList[FIndex];
end;

function TFhirHealthcareServiceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirHealthcareServiceList }
function TFhirHealthcareServiceList.AddItem(value: TFhirHealthcareService): TFhirHealthcareService;
begin
  add(value);
  result := value;
end;

function TFhirHealthcareServiceList.Append: TFhirHealthcareService;
begin
  result := TFhirHealthcareService.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceList.ClearItems;
begin
  Clear;
end;

function TFhirHealthcareServiceList.GetEnumerator : TFhirHealthcareServiceListEnumerator;
begin
  result := TFhirHealthcareServiceListEnumerator.Create(self.link);
end;

function TFhirHealthcareServiceList.Clone: TFhirHealthcareServiceList;
begin
  result := TFhirHealthcareServiceList(inherited Clone);
end;

function TFhirHealthcareServiceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirHealthcareServiceList.GetItemN(index: Integer): TFhirHealthcareService;
begin
  result := TFhirHealthcareService(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceList.ItemClass: TFslObjectClass;
begin
  result := TFhirHealthcareService;
end;
function TFhirHealthcareServiceList.IndexOf(value: TFhirHealthcareService): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirHealthcareServiceList.Insert(index: Integer): TFhirHealthcareService;
begin
  result := TFhirHealthcareService.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceList.InsertItem(index: Integer; value: TFhirHealthcareService);
begin
  assert(value is TFhirHealthcareService);
  Inherited Insert(index, value);
end;

function TFhirHealthcareServiceList.Item(index: Integer): TFhirHealthcareService;
begin
  result := TFhirHealthcareService(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceList.Link: TFhirHealthcareServiceList;
begin
  result := TFhirHealthcareServiceList(inherited Link);
end;

procedure TFhirHealthcareServiceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirHealthcareServiceList.SetItemByIndex(index: Integer; value: TFhirHealthcareService);
begin
  assert(value is TFhirHealthcareService);
  FhirHealthcareServices[index] := value;
end;

procedure TFhirHealthcareServiceList.SetItemN(index: Integer; value: TFhirHealthcareService);
begin
  assert(value is TFhirHealthcareService);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_HEALTHCARESERVICE}

{$IFDEF FHIR_LOCATION}

{ TFhirLocationPosition }

constructor TFhirLocationPosition.Create;
begin
  inherited;
end;

destructor TFhirLocationPosition.Destroy;
begin
  FLongitude.free;
  FLatitude.free;
  FAltitude.free;
  inherited;
end;

procedure TFhirLocationPosition.Assign(oSource : TFslObject);
begin
  inherited;
  longitudeElement := TFhirLocationPosition(oSource).longitudeElement.Clone;
  latitudeElement := TFhirLocationPosition(oSource).latitudeElement.Clone;
  altitudeElement := TFhirLocationPosition(oSource).altitudeElement.Clone;
end;

procedure TFhirLocationPosition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'longitude') Then
     list.add(self.link, 'longitude', FLongitude.Link);
  if (child_name = 'latitude') Then
     list.add(self.link, 'latitude', FLatitude.Link);
  if (child_name = 'altitude') Then
     list.add(self.link, 'altitude', FAltitude.Link);
end;

procedure TFhirLocationPosition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'longitude', 'decimal', false, TFhirDecimal, FLongitude.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'latitude', 'decimal', false, TFhirDecimal, FLatitude.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'altitude', 'decimal', false, TFhirDecimal, FAltitude.Link));{2}
end;

function TFhirLocationPosition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'longitude') then
  begin
    LongitudeElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'latitude') then
  begin
    LatitudeElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'altitude') then
  begin
    AltitudeElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirLocationPosition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirLocationPosition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'longitude') then result := TFhirDecimal.Create() {5b}
  else if (propName = 'latitude') then result := TFhirDecimal.Create() {5b}
  else if (propName = 'altitude') then result := TFhirDecimal.Create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirLocationPosition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'longitude') then result := 'decimal'
  else if (propName = 'latitude') then result := 'decimal'
  else if (propName = 'altitude') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLocationPosition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'longitude') then LongitudeElement := nil
  else if (propName = 'latitude') then LatitudeElement := nil
  else if (propName = 'altitude') then AltitudeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLocationPosition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'longitude') then LongitudeElement := asDecimal(new){5b}
  else if (propName = 'latitude') then LatitudeElement := asDecimal(new){5b}
  else if (propName = 'altitude') then AltitudeElement := asDecimal(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLocationPosition.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirLocationPosition.fhirType : string;
begin
  result := 'position';
end;

function TFhirLocationPosition.Link : TFhirLocationPosition;
begin
  result := TFhirLocationPosition(inherited Link);
end;

function TFhirLocationPosition.Clone : TFhirLocationPosition;
begin
  result := TFhirLocationPosition(inherited Clone);
end;

function TFhirLocationPosition.equals(other : TObject) : boolean; 
var
  o : TFhirLocationPosition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLocationPosition)) then
    result := false
  else
  begin
    o := TFhirLocationPosition(other);
    result := compareDeep(longitudeElement, o.longitudeElement, true) and compareDeep(latitudeElement, o.latitudeElement, true) and 
      compareDeep(altitudeElement, o.altitudeElement, true);
  end;
end;

function TFhirLocationPosition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLongitude) and isEmptyProp(FLatitude) and isEmptyProp(FAltitude);
end;

procedure TFhirLocationPosition.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('longitude');
  fields.add('latitude');
  fields.add('altitude');
end;

{ TFhirLocationPosition }

Procedure TFhirLocationPosition.SetLongitude(value : TFhirDecimal);
begin
  FLongitude.free;
  FLongitude := value;
end;

Function TFhirLocationPosition.GetLongitudeST : String;
begin
  if FLongitude = nil then
    result := ''
  else
    result := FLongitude.value;
end;

Procedure TFhirLocationPosition.SetLongitudeST(value : String);
begin
  if value <> '' then
  begin
    if FLongitude = nil then
      FLongitude := TFhirDecimal.Create;
    FLongitude.value := value
  end
  else if FLongitude <> nil then
    FLongitude.value := '';
end;

Procedure TFhirLocationPosition.SetLatitude(value : TFhirDecimal);
begin
  FLatitude.free;
  FLatitude := value;
end;

Function TFhirLocationPosition.GetLatitudeST : String;
begin
  if FLatitude = nil then
    result := ''
  else
    result := FLatitude.value;
end;

Procedure TFhirLocationPosition.SetLatitudeST(value : String);
begin
  if value <> '' then
  begin
    if FLatitude = nil then
      FLatitude := TFhirDecimal.Create;
    FLatitude.value := value
  end
  else if FLatitude <> nil then
    FLatitude.value := '';
end;

Procedure TFhirLocationPosition.SetAltitude(value : TFhirDecimal);
begin
  FAltitude.free;
  FAltitude := value;
end;

Function TFhirLocationPosition.GetAltitudeST : String;
begin
  if FAltitude = nil then
    result := ''
  else
    result := FAltitude.value;
end;

Procedure TFhirLocationPosition.SetAltitudeST(value : String);
begin
  if value <> '' then
  begin
    if FAltitude = nil then
      FAltitude := TFhirDecimal.Create;
    FAltitude.value := value
  end
  else if FAltitude <> nil then
    FAltitude.value := '';
end;

function TFhirLocationPosition.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FLongitude.sizeInBytes(magic));
  inc(result, FLatitude.sizeInBytes(magic));
  inc(result, FAltitude.sizeInBytes(magic));
end;

{ TFhirLocationPositionListEnumerator }

Constructor TFhirLocationPositionListEnumerator.Create(list : TFhirLocationPositionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLocationPositionListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirLocationPositionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLocationPositionListEnumerator.GetCurrent : TFhirLocationPosition;
begin
  Result := FList[FIndex];
end;

function TFhirLocationPositionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirLocationPositionList }
function TFhirLocationPositionList.AddItem(value: TFhirLocationPosition): TFhirLocationPosition;
begin
  add(value);
  result := value;
end;

function TFhirLocationPositionList.Append: TFhirLocationPosition;
begin
  result := TFhirLocationPosition.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationPositionList.ClearItems;
begin
  Clear;
end;

function TFhirLocationPositionList.GetEnumerator : TFhirLocationPositionListEnumerator;
begin
  result := TFhirLocationPositionListEnumerator.Create(self.link);
end;

function TFhirLocationPositionList.Clone: TFhirLocationPositionList;
begin
  result := TFhirLocationPositionList(inherited Clone);
end;

function TFhirLocationPositionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLocationPositionList.GetItemN(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition(ObjectByIndex[index]);
end;

function TFhirLocationPositionList.ItemClass: TFslObjectClass;
begin
  result := TFhirLocationPosition;
end;
function TFhirLocationPositionList.IndexOf(value: TFhirLocationPosition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLocationPositionList.Insert(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationPositionList.InsertItem(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  Inherited Insert(index, value);
end;

function TFhirLocationPositionList.Item(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition(ObjectByIndex[index]);
end;

function TFhirLocationPositionList.Link: TFhirLocationPositionList;
begin
  result := TFhirLocationPositionList(inherited Link);
end;

procedure TFhirLocationPositionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLocationPositionList.SetItemByIndex(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  FhirLocationPositions[index] := value;
end;

procedure TFhirLocationPositionList.SetItemN(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  ObjectByIndex[index] := value;
end;

{ TFhirLocationHoursOfOperation }

constructor TFhirLocationHoursOfOperation.Create;
begin
  inherited;
end;

destructor TFhirLocationHoursOfOperation.Destroy;
begin
  FDaysOfWeek.free;
  FAllDay.free;
  FOpeningTime.free;
  FClosingTime.free;
  inherited;
end;

procedure TFhirLocationHoursOfOperation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirLocationHoursOfOperation(oSource).FDaysOfWeek = nil) then
  begin
    FDaysOfWeek.free;
    FDaysOfWeek := nil;
  end
  else
  begin
    FDaysOfWeek := TFHIREnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
    FDaysOfWeek.Assign(TFhirLocationHoursOfOperation(oSource).FDaysOfWeek);
  end;
  allDayElement := TFhirLocationHoursOfOperation(oSource).allDayElement.Clone;
  openingTimeElement := TFhirLocationHoursOfOperation(oSource).openingTimeElement.Clone;
  closingTimeElement := TFhirLocationHoursOfOperation(oSource).closingTimeElement.Clone;
end;

procedure TFhirLocationHoursOfOperation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'daysOfWeek') Then
     list.addAll(self, 'daysOfWeek', FDaysOfWeek);
  if (child_name = 'allDay') Then
     list.add(self.link, 'allDay', FAllDay.Link);
  if (child_name = 'openingTime') Then
     list.add(self.link, 'openingTime', FOpeningTime.Link);
  if (child_name = 'closingTime') Then
     list.add(self.link, 'closingTime', FClosingTime.Link);
end;

procedure TFhirLocationHoursOfOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'daysOfWeek', 'code', true, TFHIREnum, FDaysOfWeek.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'allDay', 'boolean', false, TFhirBoolean, FAllDay.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'openingTime', 'time', false, TFhirTime, FOpeningTime.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'closingTime', 'time', false, TFhirTime, FClosingTime.Link));{2}
end;

function TFhirLocationHoursOfOperation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'daysOfWeek') then
  begin
    DaysOfWeekList.add(asEnum(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'allDay') then
  begin
    AllDayElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'openingTime') then
  begin
    OpeningTimeElement := asTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'closingTime') then
  begin
    ClosingTimeElement := asTime(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirLocationHoursOfOperation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'daysOfWeek') then FDaysOfWeek.insertItem(index, asEnum(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum, propValue)) {1}
  else inherited;
end;

function TFhirLocationHoursOfOperation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'allDay') then result := TFhirBoolean.Create() {5b}
  else if (propName = 'openingTime') then result := TFhirTime.Create() {5b}
  else if (propName = 'closingTime') then result := TFhirTime.Create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirLocationHoursOfOperation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'daysOfWeek') then result := 'code'
  else if (propName = 'allDay') then result := 'boolean'
  else if (propName = 'openingTime') then result := 'time'
  else if (propName = 'closingTime') then result := 'time'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLocationHoursOfOperation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'allDay') then AllDayElement := nil
  else if (propName = 'openingTime') then OpeningTimeElement := nil
  else if (propName = 'closingTime') then ClosingTimeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLocationHoursOfOperation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'allDay') then AllDayElement := asBoolean(new){5b}
  else if (propName = 'openingTime') then OpeningTimeElement := asTime(new){5b}
  else if (propName = 'closingTime') then ClosingTimeElement := asTime(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLocationHoursOfOperation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'daysOfWeek') then FDaysOfWeek.move(source, destination) {1}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirLocationHoursOfOperation.fhirType : string;
begin
  result := 'hoursOfOperation';
end;

function TFhirLocationHoursOfOperation.Link : TFhirLocationHoursOfOperation;
begin
  result := TFhirLocationHoursOfOperation(inherited Link);
end;

function TFhirLocationHoursOfOperation.Clone : TFhirLocationHoursOfOperation;
begin
  result := TFhirLocationHoursOfOperation(inherited Clone);
end;

function TFhirLocationHoursOfOperation.equals(other : TObject) : boolean; 
var
  o : TFhirLocationHoursOfOperation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLocationHoursOfOperation)) then
    result := false
  else
  begin
    o := TFhirLocationHoursOfOperation(other);
    result := compareDeep(daysOfWeekList, o.daysOfWeekList, true) and compareDeep(allDayElement, o.allDayElement, true) and 
      compareDeep(openingTimeElement, o.openingTimeElement, true) and compareDeep(closingTimeElement, o.closingTimeElement, true);
  end;
end;

function TFhirLocationHoursOfOperation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDaysOfWeek) and isEmptyProp(FAllDay) and isEmptyProp(FOpeningTime) and isEmptyProp(FClosingTime);
end;

procedure TFhirLocationHoursOfOperation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('daysOfWeek');
  fields.add('allDay');
  fields.add('openingTime');
  fields.add('closingTime');
end;

{ TFhirLocationHoursOfOperation }

Function TFhirLocationHoursOfOperation.GetDaysOfWeek : TFhirEnumList;
begin
  if FDaysOfWeek = nil then
    FDaysOfWeek := TFHIREnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
  result := FDaysOfWeek;
end;

Function TFhirLocationHoursOfOperation.GetHasDaysOfWeek : boolean;
begin
  result := (FDaysOfWeek <> nil) and (FDaysOfWeek.count > 0);
end;

Function TFhirLocationHoursOfOperation.GetDaysOfWeekST : TFhirDaysOfWeekEnumList;
  var i : integer;
begin
  result := [];
  if FdaysOfWeek <> nil then
    for i := 0 to FdaysOfWeek.count - 1 do
      result := result + [TFhirDaysOfWeekEnum(StringArrayIndexOfSensitive(CODES_TFhirDaysOfWeekEnum, FdaysOfWeek[i].value))];
end;

Procedure TFhirLocationHoursOfOperation.SetDaysOfWeekST(value : TFhirDaysOfWeekEnumList);
var a : TFhirDaysOfWeekEnum;
begin
  if FdaysOfWeek = nil then
    FdaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
  FdaysOfWeek.clear;
  for a := low(TFhirDaysOfWeekEnum) to high(TFhirDaysOfWeekEnum) do
    if a in value then
      begin
         if FdaysOfWeek = nil then
           FdaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
         FdaysOfWeek.add(TFhirEnum.Create(SYSTEMS_TFhirDaysOfWeekEnum[a], CODES_TFhirDaysOfWeekEnum[a]));
      end;
end;

Procedure TFhirLocationHoursOfOperation.SetAllDay(value : TFhirBoolean);
begin
  FAllDay.free;
  FAllDay := value;
end;

Function TFhirLocationHoursOfOperation.GetAllDayST : Boolean;
begin
  if FAllDay = nil then
    result := false
  else
    result := FAllDay.value;
end;

Procedure TFhirLocationHoursOfOperation.SetAllDayST(value : Boolean);
begin
  if FAllDay = nil then
    FAllDay := TFhirBoolean.Create;
  FAllDay.value := value
end;

Procedure TFhirLocationHoursOfOperation.SetOpeningTime(value : TFhirTime);
begin
  FOpeningTime.free;
  FOpeningTime := value;
end;

Function TFhirLocationHoursOfOperation.GetOpeningTimeST : String;
begin
  if FOpeningTime = nil then
    result := ''
  else
    result := FOpeningTime.value;
end;

Procedure TFhirLocationHoursOfOperation.SetOpeningTimeST(value : String);
begin
  if value <> '' then
  begin
    if FOpeningTime = nil then
      FOpeningTime := TFhirTime.Create;
    FOpeningTime.value := value
  end
  else if FOpeningTime <> nil then
    FOpeningTime.value := '';
end;

Procedure TFhirLocationHoursOfOperation.SetClosingTime(value : TFhirTime);
begin
  FClosingTime.free;
  FClosingTime := value;
end;

Function TFhirLocationHoursOfOperation.GetClosingTimeST : String;
begin
  if FClosingTime = nil then
    result := ''
  else
    result := FClosingTime.value;
end;

Procedure TFhirLocationHoursOfOperation.SetClosingTimeST(value : String);
begin
  if value <> '' then
  begin
    if FClosingTime = nil then
      FClosingTime := TFhirTime.Create;
    FClosingTime.value := value
  end
  else if FClosingTime <> nil then
    FClosingTime.value := '';
end;

function TFhirLocationHoursOfOperation.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FDaysOfWeek.sizeInBytes(magic));
  inc(result, FAllDay.sizeInBytes(magic));
  inc(result, FOpeningTime.sizeInBytes(magic));
  inc(result, FClosingTime.sizeInBytes(magic));
end;

{ TFhirLocationHoursOfOperationListEnumerator }

Constructor TFhirLocationHoursOfOperationListEnumerator.Create(list : TFhirLocationHoursOfOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLocationHoursOfOperationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirLocationHoursOfOperationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLocationHoursOfOperationListEnumerator.GetCurrent : TFhirLocationHoursOfOperation;
begin
  Result := FList[FIndex];
end;

function TFhirLocationHoursOfOperationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirLocationHoursOfOperationList }
function TFhirLocationHoursOfOperationList.AddItem(value: TFhirLocationHoursOfOperation): TFhirLocationHoursOfOperation;
begin
  add(value);
  result := value;
end;

function TFhirLocationHoursOfOperationList.Append: TFhirLocationHoursOfOperation;
begin
  result := TFhirLocationHoursOfOperation.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationHoursOfOperationList.ClearItems;
begin
  Clear;
end;

function TFhirLocationHoursOfOperationList.GetEnumerator : TFhirLocationHoursOfOperationListEnumerator;
begin
  result := TFhirLocationHoursOfOperationListEnumerator.Create(self.link);
end;

function TFhirLocationHoursOfOperationList.Clone: TFhirLocationHoursOfOperationList;
begin
  result := TFhirLocationHoursOfOperationList(inherited Clone);
end;

function TFhirLocationHoursOfOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLocationHoursOfOperationList.GetItemN(index: Integer): TFhirLocationHoursOfOperation;
begin
  result := TFhirLocationHoursOfOperation(ObjectByIndex[index]);
end;

function TFhirLocationHoursOfOperationList.ItemClass: TFslObjectClass;
begin
  result := TFhirLocationHoursOfOperation;
end;
function TFhirLocationHoursOfOperationList.IndexOf(value: TFhirLocationHoursOfOperation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLocationHoursOfOperationList.Insert(index: Integer): TFhirLocationHoursOfOperation;
begin
  result := TFhirLocationHoursOfOperation.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationHoursOfOperationList.InsertItem(index: Integer; value: TFhirLocationHoursOfOperation);
begin
  assert(value is TFhirLocationHoursOfOperation);
  Inherited Insert(index, value);
end;

function TFhirLocationHoursOfOperationList.Item(index: Integer): TFhirLocationHoursOfOperation;
begin
  result := TFhirLocationHoursOfOperation(ObjectByIndex[index]);
end;

function TFhirLocationHoursOfOperationList.Link: TFhirLocationHoursOfOperationList;
begin
  result := TFhirLocationHoursOfOperationList(inherited Link);
end;

procedure TFhirLocationHoursOfOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLocationHoursOfOperationList.SetItemByIndex(index: Integer; value: TFhirLocationHoursOfOperation);
begin
  assert(value is TFhirLocationHoursOfOperation);
  FhirLocationHoursOfOperations[index] := value;
end;

procedure TFhirLocationHoursOfOperationList.SetItemN(index: Integer; value: TFhirLocationHoursOfOperation);
begin
  assert(value is TFhirLocationHoursOfOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirLocation }

constructor TFhirLocation.Create;
begin
  inherited;
end;

destructor TFhirLocation.Destroy;
begin
  FIdentifierList.free;
  FStatus.free;
  FOperationalStatus.free;
  FName.free;
  FAliasList.free;
  FDescription.free;
  FMode.free;
  FType_List.free;
  FTelecomList.free;
  FAddress.free;
  FPhysicalType.free;
  FPosition.free;
  FManagingOrganization.free;
  FPartOf.free;
  FHoursOfOperationList.free;
  FAvailabilityExceptions.free;
  FEndpointList.free;
  inherited;
end;

function TFhirLocation.GetResourceType : TFhirResourceType;
begin
  result := frtLocation;
end;

procedure TFhirLocation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirLocation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirLocation(oSource).FIdentifierList);
  end;
  FStatus := TFhirLocation(oSource).FStatus.Link;
  operationalStatus := TFhirLocation(oSource).operationalStatus.Clone;
  nameElement := TFhirLocation(oSource).nameElement.Clone;
  if (TFhirLocation(oSource).FAliasList = nil) then
  begin
    FAliasList.free;
    FAliasList := nil;
  end
  else
  begin
    if FAliasList = nil then
      FAliasList := TFhirStringList.Create;
    FAliasList.Assign(TFhirLocation(oSource).FAliasList);
  end;
  descriptionElement := TFhirLocation(oSource).descriptionElement.Clone;
  FMode := TFhirLocation(oSource).FMode.Link;
  if (TFhirLocation(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirLocation(oSource).FType_List);
  end;
  if (TFhirLocation(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirLocation(oSource).FTelecomList);
  end;
  address := TFhirLocation(oSource).address.Clone;
  physicalType := TFhirLocation(oSource).physicalType.Clone;
  position := TFhirLocation(oSource).position.Clone;
  managingOrganization := TFhirLocation(oSource).managingOrganization.Clone;
  partOf := TFhirLocation(oSource).partOf.Clone;
  if (TFhirLocation(oSource).FHoursOfOperationList = nil) then
  begin
    FHoursOfOperationList.free;
    FHoursOfOperationList := nil;
  end
  else
  begin
    if FHoursOfOperationList = nil then
      FHoursOfOperationList := TFhirLocationHoursOfOperationList.Create;
    FHoursOfOperationList.Assign(TFhirLocation(oSource).FHoursOfOperationList);
  end;
  availabilityExceptionsElement := TFhirLocation(oSource).availabilityExceptionsElement.Clone;
  if (TFhirLocation(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList{TFhirEndpoint}.Create;
    FEndpointList.Assign(TFhirLocation(oSource).FEndpointList);
  end;
end;

procedure TFhirLocation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'operationalStatus') Then
     list.add(self.link, 'operationalStatus', FOperationalStatus.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'alias') Then
    list.addAll(self, 'alias', FAliasList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
  if (child_name = 'physicalType') Then
     list.add(self.link, 'physicalType', FPhysicalType.Link);
  if (child_name = 'position') Then
     list.add(self.link, 'position', FPosition.Link);
  if (child_name = 'managingOrganization') Then
     list.add(self.link, 'managingOrganization', FManagingOrganization.Link);
  if (child_name = 'partOf') Then
     list.add(self.link, 'partOf', FPartOf.Link);
  if (child_name = 'hoursOfOperation') Then
    list.addAll(self, 'hoursOfOperation', FHoursOfOperationList);
  if (child_name = 'availabilityExceptions') Then
     list.add(self.link, 'availabilityExceptions', FAvailabilityExceptions.Link);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
end;

procedure TFhirLocation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'operationalStatus', 'Coding', false, TFhirCoding, FOperationalStatus.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'alias', 'string', true, TFhirString, FAliasList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'mode', 'code', false, TFHIREnum, FMode.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'address', 'Address', false, TFhirAddress, FAddress.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'physicalType', 'CodeableConcept', false, TFhirCodeableConcept, FPhysicalType.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'position', '', false, TFhirLocationPosition, FPosition.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'managingOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FManagingOrganization.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'partOf', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FPartOf.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'hoursOfOperation', '', true, TFhirLocationHoursOfOperation, FHoursOfOperationList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'availabilityExceptions', 'string', false, TFhirString, FAvailabilityExceptions.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'endpoint', 'Reference(Endpoint)', true, TFhirReference{TFhirEndpoint}, FEndpointList.Link)){3};
end;

function TFhirLocation.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirLocationStatusEnum, CODES_TFhirLocationStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'operationalStatus') then
  begin
    OperationalStatus := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'alias') then
  begin
    AliasList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirLocationModeEnum, CODES_TFhirLocationModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    Address := propValue as TFhirAddress{4b};
    result := propValue;
  end
  else if (propName = 'physicalType') then
  begin
    PhysicalType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'position') then
  begin
    Position := propValue as TFhirLocationPosition{4b};
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOf := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'hoursOfOperation') then
  begin
    HoursOfOperationList.add(propValue as TFhirLocationHoursOfOperation){2a};
    result := propValue;
  end
  else if (propName = 'availabilityExceptions') then
  begin
    AvailabilityExceptionsElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference{TFhirEndpoint}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirLocation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'alias') then AliasList.insertItem(index, asString(propValue)){2}
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else if (propName = 'hoursOfOperation') then HoursOfOperationList.insertItem(index, propValue as TFhirLocationHoursOfOperation){2a}
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference{TFhirEndpoint}){2a}
  else inherited;
end;

function TFhirLocation.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'operationalStatus') then result := TFhirCoding.Create(){4b}
  else if (propName = 'name') then result := TFhirString.Create() {5b}
  else if (propName = 'alias') then result := AliasList.new(){2}
  else if (propName = 'description') then result := TFhirString.Create() {5b}
  else if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else if (propName = 'address') then result := TFhirAddress.Create(){4b}
  else if (propName = 'physicalType') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'position') then result := TFhirLocationPosition.Create(){4b}
  else if (propName = 'managingOrganization') then result := TFhirReference{TFhirOrganization}.Create(){4b}
  else if (propName = 'partOf') then result := TFhirReference{TFhirLocation}.Create(){4b}
  else if (propName = 'hoursOfOperation') then result := HoursOfOperationList.new(){2}
  else if (propName = 'availabilityExceptions') then result := TFhirString.Create() {5b}
  else if (propName = 'endpoint') then result := EndpointList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirLocation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'operationalStatus') then result := 'Coding'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'alias') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'physicalType') then result := 'CodeableConcept'
  else if (propName = 'position') then result := ''
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'hoursOfOperation') then result := ''
  else if (propName = 'availabilityExceptions') then result := 'string'
  else if (propName = 'endpoint') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLocation.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'operationalStatus') then OperationalStatusElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'alias') then deletePropertyValue('alias', AliasList, value) {2}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else if (propName = 'address') then AddressElement := nil
  else if (propName = 'physicalType') then PhysicalTypeElement := nil
  else if (propName = 'position') then PositionElement := nil
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := nil
  else if (propName = 'partOf') then PartOfElement := nil
  else if (propName = 'hoursOfOperation') then deletePropertyValue('hoursOfOperation', HoursOfOperationList, value) {2}
  else if (propName = 'availabilityExceptions') then AvailabilityExceptionsElement := nil
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLocation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirLocationStatusEnum, CODES_TFhirLocationStatusEnum, new){4}
  else if (propName = 'operationalStatus') then OperationalStatusElement := new as TFhirCoding{4}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'alias') then replacePropertyValue('alias', AliasList, existing, new) {2}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirLocationModeEnum, CODES_TFhirLocationModeEnum, new){4}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else if (propName = 'address') then AddressElement := new as TFhirAddress{4}
  else if (propName = 'physicalType') then PhysicalTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'position') then PositionElement := new as TFhirLocationPosition{4}
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'partOf') then PartOfElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'hoursOfOperation') then replacePropertyValue('hoursOfOperation', HoursOfOperationList, existing, new) {2}
  else if (propName = 'availabilityExceptions') then AvailabilityExceptionsElement := asString(new){5b}
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLocation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'alias') then AliasList.move(source, destination){2}
  else if (propName = 'type') then Type_List.move(source, destination){2a}
  else if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else if (propName = 'hoursOfOperation') then HoursOfOperationList.move(source, destination){2a}
  else if (propName = 'endpoint') then EndpointList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirLocation.fhirType : string;
begin
  result := 'Location';
end;

function TFhirLocation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FOperationalStatus) and isEmptyProp(FName) and isEmptyProp(FaliasList) and isEmptyProp(FDescription) and isEmptyProp(FMode) and isEmptyProp(Ftype_List) and isEmptyProp(FtelecomList) and isEmptyProp(FAddress) and isEmptyProp(FPhysicalType) and isEmptyProp(FPosition) and isEmptyProp(FManagingOrganization) and isEmptyProp(FPartOf) and isEmptyProp(FhoursOfOperationList) and isEmptyProp(FAvailabilityExceptions) and isEmptyProp(FendpointList);
end;

function TFhirLocation.equals(other : TObject) : boolean; 
var
  o : TFhirLocation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLocation)) then
    result := false
  else
  begin
    o := TFhirLocation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(operationalStatusElement, o.operationalStatusElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(aliasList, o.aliasList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(modeElement, o.modeElement, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(telecomList, o.telecomList, true) and compareDeep(addressElement, o.addressElement, true) and 
      compareDeep(physicalTypeElement, o.physicalTypeElement, true) and compareDeep(positionElement, o.positionElement, true) and 
      compareDeep(managingOrganizationElement, o.managingOrganizationElement, true) and 
      compareDeep(partOfElement, o.partOfElement, true) and compareDeep(hoursOfOperationList, o.hoursOfOperationList, true) and 
      compareDeep(availabilityExceptionsElement, o.availabilityExceptionsElement, true) and 
      compareDeep(endpointList, o.endpointList, true);
  end;
end;

function TFhirLocation.Link : TFhirLocation;
begin
  result := TFhirLocation(inherited Link);
end;

function TFhirLocation.Clone : TFhirLocation;
begin
  result := TFhirLocation(inherited Clone);
end;

procedure TFhirLocation.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('operationalStatus');
  fields.add('name');
  fields.add('alias');
  fields.add('description');
  fields.add('mode');
  fields.add('type');
  fields.add('telecom');
  fields.add('address');
  fields.add('physicalType');
  fields.add('position');
  fields.add('managingOrganization');
  fields.add('partOf');
  fields.add('hoursOfOperation');
  fields.add('availabilityExceptions');
  fields.add('endpoint');
end;

{ TFhirLocation }

Function TFhirLocation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirLocation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirLocation.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirLocation.GetStatusST : TFhirLocationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirLocationStatusEnum(0)
  else
    result := TFhirLocationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirLocationStatusEnum, FStatus.value));
end;

Procedure TFhirLocation.SetStatusST(value : TFhirLocationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.Create(SYSTEMS_TFhirLocationStatusEnum[value], CODES_TFhirLocationStatusEnum[value]);
end;

Procedure TFhirLocation.SetOperationalStatus(value : TFhirCoding);
begin
  FOperationalStatus.free;
  FOperationalStatus := value;
end;

Procedure TFhirLocation.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirLocation.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirLocation.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.Create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Function TFhirLocation.GetAliasList : TFhirStringList;
begin
  if FAliasList = nil then
    FAliasList := TFhirStringList.Create;
  result := FAliasList;
end;

Function TFhirLocation.GetHasAliasList : boolean;
begin
  result := (FAliasList <> nil) and (FAliasList.count > 0);
end;

Procedure TFhirLocation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirLocation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirLocation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.Create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirLocation.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirLocation.GetModeST : TFhirLocationModeEnum;
begin
  if FMode = nil then
    result := TFhirLocationModeEnum(0)
  else
    result := TFhirLocationModeEnum(StringArrayIndexOfSensitive(CODES_TFhirLocationModeEnum, FMode.value));
end;

Procedure TFhirLocation.SetModeST(value : TFhirLocationModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.Create(SYSTEMS_TFhirLocationModeEnum[value], CODES_TFhirLocationModeEnum[value]);
end;

Function TFhirLocation.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

Function TFhirLocation.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Function TFhirLocation.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirLocation.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

Procedure TFhirLocation.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value;
end;

Procedure TFhirLocation.SetPhysicalType(value : TFhirCodeableConcept);
begin
  FPhysicalType.free;
  FPhysicalType := value;
end;

Procedure TFhirLocation.SetPosition(value : TFhirLocationPosition);
begin
  FPosition.free;
  FPosition := value;
end;

Procedure TFhirLocation.SetManagingOrganization(value : TFhirReference{TFhirOrganization});
begin
  FManagingOrganization.free;
  FManagingOrganization := value;
end;

Procedure TFhirLocation.SetPartOf(value : TFhirReference{TFhirLocation});
begin
  FPartOf.free;
  FPartOf := value;
end;

Function TFhirLocation.GetHoursOfOperationList : TFhirLocationHoursOfOperationList;
begin
  if FHoursOfOperationList = nil then
    FHoursOfOperationList := TFhirLocationHoursOfOperationList.Create;
  result := FHoursOfOperationList;
end;

Function TFhirLocation.GetHasHoursOfOperationList : boolean;
begin
  result := (FHoursOfOperationList <> nil) and (FHoursOfOperationList.count > 0);
end;

Procedure TFhirLocation.SetAvailabilityExceptions(value : TFhirString);
begin
  FAvailabilityExceptions.free;
  FAvailabilityExceptions := value;
end;

Function TFhirLocation.GetAvailabilityExceptionsST : String;
begin
  if FAvailabilityExceptions = nil then
    result := ''
  else
    result := FAvailabilityExceptions.value;
end;

Procedure TFhirLocation.SetAvailabilityExceptionsST(value : String);
begin
  if value <> '' then
  begin
    if FAvailabilityExceptions = nil then
      FAvailabilityExceptions := TFhirString.Create;
    FAvailabilityExceptions.value := value
  end
  else if FAvailabilityExceptions <> nil then
    FAvailabilityExceptions.value := '';
end;

Function TFhirLocation.GetEndpointList : TFhirReferenceList{TFhirEndpoint};
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList{TFhirEndpoint}.Create;
  result := FEndpointList;
end;

Function TFhirLocation.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

function TFhirLocation.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FidentifierList.sizeInBytes(magic));
  inc(result, FStatus.sizeInBytes(magic));
  inc(result, FOperationalStatus.sizeInBytes(magic));
  inc(result, FName.sizeInBytes(magic));
  inc(result, FaliasList.sizeInBytes(magic));
  inc(result, FDescription.sizeInBytes(magic));
  inc(result, FMode.sizeInBytes(magic));
  inc(result, Ftype_List.sizeInBytes(magic));
  inc(result, FtelecomList.sizeInBytes(magic));
  inc(result, FAddress.sizeInBytes(magic));
  inc(result, FPhysicalType.sizeInBytes(magic));
  inc(result, FPosition.sizeInBytes(magic));
  inc(result, FManagingOrganization.sizeInBytes(magic));
  inc(result, FPartOf.sizeInBytes(magic));
  inc(result, FhoursOfOperationList.sizeInBytes(magic));
  inc(result, FAvailabilityExceptions.sizeInBytes(magic));
  inc(result, FendpointList.sizeInBytes(magic));
end;

{ TFhirLocationListEnumerator }

Constructor TFhirLocationListEnumerator.Create(list : TFhirLocationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLocationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirLocationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLocationListEnumerator.GetCurrent : TFhirLocation;
begin
  Result := FList[FIndex];
end;

function TFhirLocationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirLocationList }
function TFhirLocationList.AddItem(value: TFhirLocation): TFhirLocation;
begin
  add(value);
  result := value;
end;

function TFhirLocationList.Append: TFhirLocation;
begin
  result := TFhirLocation.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationList.ClearItems;
begin
  Clear;
end;

function TFhirLocationList.GetEnumerator : TFhirLocationListEnumerator;
begin
  result := TFhirLocationListEnumerator.Create(self.link);
end;

function TFhirLocationList.Clone: TFhirLocationList;
begin
  result := TFhirLocationList(inherited Clone);
end;

function TFhirLocationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLocationList.GetItemN(index: Integer): TFhirLocation;
begin
  result := TFhirLocation(ObjectByIndex[index]);
end;

function TFhirLocationList.ItemClass: TFslObjectClass;
begin
  result := TFhirLocation;
end;
function TFhirLocationList.IndexOf(value: TFhirLocation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLocationList.Insert(index: Integer): TFhirLocation;
begin
  result := TFhirLocation.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationList.InsertItem(index: Integer; value: TFhirLocation);
begin
  assert(value is TFhirLocation);
  Inherited Insert(index, value);
end;

function TFhirLocationList.Item(index: Integer): TFhirLocation;
begin
  result := TFhirLocation(ObjectByIndex[index]);
end;

function TFhirLocationList.Link: TFhirLocationList;
begin
  result := TFhirLocationList(inherited Link);
end;

procedure TFhirLocationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLocationList.SetItemByIndex(index: Integer; value: TFhirLocation);
begin
  assert(value is TFhirLocation);
  FhirLocations[index] := value;
end;

procedure TFhirLocationList.SetItemN(index: Integer; value: TFhirLocation);
begin
  assert(value is TFhirLocation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_LOCATION}

{$IFDEF FHIR_ORGANIZATION}

{ TFhirOrganizationContact }

constructor TFhirOrganizationContact.Create;
begin
  inherited;
end;

destructor TFhirOrganizationContact.Destroy;
begin
  FPurpose.free;
  FName.free;
  FTelecomList.free;
  FAddress.free;
  inherited;
end;

procedure TFhirOrganizationContact.Assign(oSource : TFslObject);
begin
  inherited;
  purpose := TFhirOrganizationContact(oSource).purpose.Clone;
  name := TFhirOrganizationContact(oSource).name.Clone;
  if (TFhirOrganizationContact(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirOrganizationContact(oSource).FTelecomList);
  end;
  address := TFhirOrganizationContact(oSource).address.Clone;
end;

procedure TFhirOrganizationContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
end;

procedure TFhirOrganizationContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'purpose', 'CodeableConcept', false, TFhirCodeableConcept, FPurpose.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'name', 'HumanName', false, TFhirHumanName, FName.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'address', 'Address', false, TFhirAddress, FAddress.Link));{2}
end;

function TFhirOrganizationContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'purpose') then
  begin
    Purpose := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    Name := propValue as TFhirHumanName{4b};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    Address := propValue as TFhirAddress{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOrganizationContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else inherited;
end;

function TFhirOrganizationContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'purpose') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'name') then result := TFhirHumanName.Create(){4b}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else if (propName = 'address') then result := TFhirAddress.Create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOrganizationContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'purpose') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'address') then result := 'Address'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOrganizationContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else if (propName = 'address') then AddressElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOrganizationContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'name') then NameElement := new as TFhirHumanName{4}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else if (propName = 'address') then AddressElement := new as TFhirAddress{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOrganizationContact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOrganizationContact.fhirType : string;
begin
  result := 'contact';
end;

function TFhirOrganizationContact.Link : TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(inherited Link);
end;

function TFhirOrganizationContact.Clone : TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(inherited Clone);
end;

function TFhirOrganizationContact.equals(other : TObject) : boolean; 
var
  o : TFhirOrganizationContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOrganizationContact)) then
    result := false
  else
  begin
    o := TFhirOrganizationContact(other);
    result := compareDeep(purposeElement, o.purposeElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(telecomList, o.telecomList, true) and compareDeep(addressElement, o.addressElement, true);
  end;
end;

function TFhirOrganizationContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPurpose) and isEmptyProp(FName) and isEmptyProp(FtelecomList) and isEmptyProp(FAddress);
end;

procedure TFhirOrganizationContact.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('purpose');
  fields.add('name');
  fields.add('telecom');
  fields.add('address');
end;

{ TFhirOrganizationContact }

Procedure TFhirOrganizationContact.SetPurpose(value : TFhirCodeableConcept);
begin
  FPurpose.free;
  FPurpose := value;
end;

Procedure TFhirOrganizationContact.SetName(value : TFhirHumanName);
begin
  FName.free;
  FName := value;
end;

Function TFhirOrganizationContact.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirOrganizationContact.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

Procedure TFhirOrganizationContact.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value;
end;

function TFhirOrganizationContact.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FPurpose.sizeInBytes(magic));
  inc(result, FName.sizeInBytes(magic));
  inc(result, FtelecomList.sizeInBytes(magic));
  inc(result, FAddress.sizeInBytes(magic));
end;

{ TFhirOrganizationContactListEnumerator }

Constructor TFhirOrganizationContactListEnumerator.Create(list : TFhirOrganizationContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOrganizationContactListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirOrganizationContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOrganizationContactListEnumerator.GetCurrent : TFhirOrganizationContact;
begin
  Result := FList[FIndex];
end;

function TFhirOrganizationContactListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirOrganizationContactList }
function TFhirOrganizationContactList.AddItem(value: TFhirOrganizationContact): TFhirOrganizationContact;
begin
  add(value);
  result := value;
end;

function TFhirOrganizationContactList.Append: TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationContactList.ClearItems;
begin
  Clear;
end;

function TFhirOrganizationContactList.GetEnumerator : TFhirOrganizationContactListEnumerator;
begin
  result := TFhirOrganizationContactListEnumerator.Create(self.link);
end;

function TFhirOrganizationContactList.Clone: TFhirOrganizationContactList;
begin
  result := TFhirOrganizationContactList(inherited Clone);
end;

function TFhirOrganizationContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrganizationContactList.GetItemN(index: Integer): TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(ObjectByIndex[index]);
end;

function TFhirOrganizationContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirOrganizationContact;
end;
function TFhirOrganizationContactList.IndexOf(value: TFhirOrganizationContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOrganizationContactList.Insert(index: Integer): TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationContactList.InsertItem(index: Integer; value: TFhirOrganizationContact);
begin
  assert(value is TFhirOrganizationContact);
  Inherited Insert(index, value);
end;

function TFhirOrganizationContactList.Item(index: Integer): TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(ObjectByIndex[index]);
end;

function TFhirOrganizationContactList.Link: TFhirOrganizationContactList;
begin
  result := TFhirOrganizationContactList(inherited Link);
end;

procedure TFhirOrganizationContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrganizationContactList.SetItemByIndex(index: Integer; value: TFhirOrganizationContact);
begin
  assert(value is TFhirOrganizationContact);
  FhirOrganizationContacts[index] := value;
end;

procedure TFhirOrganizationContactList.SetItemN(index: Integer; value: TFhirOrganizationContact);
begin
  assert(value is TFhirOrganizationContact);
  ObjectByIndex[index] := value;
end;

{ TFhirOrganization }

constructor TFhirOrganization.Create;
begin
  inherited;
end;

destructor TFhirOrganization.Destroy;
begin
  FIdentifierList.free;
  FActive.free;
  FType_List.free;
  FName.free;
  FAliasList.free;
  FTelecomList.free;
  FAddressList.free;
  FPartOf.free;
  FContactList.free;
  FEndpointList.free;
  inherited;
end;

function TFhirOrganization.GetResourceType : TFhirResourceType;
begin
  result := frtOrganization;
end;

procedure TFhirOrganization.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirOrganization(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirOrganization(oSource).FIdentifierList);
  end;
  activeElement := TFhirOrganization(oSource).activeElement.Clone;
  if (TFhirOrganization(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirOrganization(oSource).FType_List);
  end;
  nameElement := TFhirOrganization(oSource).nameElement.Clone;
  if (TFhirOrganization(oSource).FAliasList = nil) then
  begin
    FAliasList.free;
    FAliasList := nil;
  end
  else
  begin
    if FAliasList = nil then
      FAliasList := TFhirStringList.Create;
    FAliasList.Assign(TFhirOrganization(oSource).FAliasList);
  end;
  if (TFhirOrganization(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirOrganization(oSource).FTelecomList);
  end;
  if (TFhirOrganization(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirOrganization(oSource).FAddressList);
  end;
  partOf := TFhirOrganization(oSource).partOf.Clone;
  if (TFhirOrganization(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirOrganizationContactList.Create;
    FContactList.Assign(TFhirOrganization(oSource).FContactList);
  end;
  if (TFhirOrganization(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList{TFhirEndpoint}.Create;
    FEndpointList.Assign(TFhirOrganization(oSource).FEndpointList);
  end;
end;

procedure TFhirOrganization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'alias') Then
    list.addAll(self, 'alias', FAliasList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'partOf') Then
     list.add(self.link, 'partOf', FPartOf.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
end;

procedure TFhirOrganization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'alias', 'string', true, TFhirString, FAliasList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'partOf', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FPartOf.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'contact', '', true, TFhirOrganizationContact, FContactList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'endpoint', 'Reference(Endpoint)', true, TFhirReference{TFhirEndpoint}, FEndpointList.Link)){3};
end;

function TFhirOrganization.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'alias') then
  begin
    AliasList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress){2a};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOf := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirOrganizationContact){2a};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference{TFhirEndpoint}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirOrganization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'alias') then AliasList.insertItem(index, asString(propValue)){2}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress){2a}
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirOrganizationContact){2a}
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference{TFhirEndpoint}){2a}
  else inherited;
end;

function TFhirOrganization.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'active') then result := TFhirBoolean.Create() {5b}
  else if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'name') then result := TFhirString.Create() {5b}
  else if (propName = 'alias') then result := AliasList.new(){2}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else if (propName = 'address') then result := AddressList.new(){2}
  else if (propName = 'partOf') then result := TFhirReference{TFhirOrganization}.Create(){4b}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'endpoint') then result := EndpointList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOrganization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'alias') then result := 'string'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'contact') then result := ''
  else if (propName = 'endpoint') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOrganization.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'alias') then deletePropertyValue('alias', AliasList, value) {2}
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value) {2}
  else if (propName = 'partOf') then PartOfElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOrganization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'active') then ActiveElement := asBoolean(new){5b}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'alias') then replacePropertyValue('alias', AliasList, existing, new) {2}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new) {2}
  else if (propName = 'partOf') then PartOfElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOrganization.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'type') then Type_List.move(source, destination){2a}
  else if (propName = 'alias') then AliasList.move(source, destination){2}
  else if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else if (propName = 'address') then AddressList.move(source, destination){2a}
  else if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'endpoint') then EndpointList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOrganization.fhirType : string;
begin
  result := 'Organization';
end;

function TFhirOrganization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(Ftype_List) and isEmptyProp(FName) and isEmptyProp(FaliasList) and isEmptyProp(FtelecomList) and isEmptyProp(FaddressList) and isEmptyProp(FPartOf) and isEmptyProp(FcontactList) and isEmptyProp(FendpointList);
end;

function TFhirOrganization.equals(other : TObject) : boolean; 
var
  o : TFhirOrganization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOrganization)) then
    result := false
  else
  begin
    o := TFhirOrganization(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(type_List, o.type_List, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(aliasList, o.aliasList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(addressList, o.addressList, true) and compareDeep(partOfElement, o.partOfElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(endpointList, o.endpointList, true);
  end;
end;

function TFhirOrganization.Link : TFhirOrganization;
begin
  result := TFhirOrganization(inherited Link);
end;

function TFhirOrganization.Clone : TFhirOrganization;
begin
  result := TFhirOrganization(inherited Clone);
end;

procedure TFhirOrganization.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('type');
  fields.add('name');
  fields.add('alias');
  fields.add('telecom');
  fields.add('address');
  fields.add('partOf');
  fields.add('contact');
  fields.add('endpoint');
end;

{ TFhirOrganization }

Function TFhirOrganization.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirOrganization.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirOrganization.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

Function TFhirOrganization.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

Procedure TFhirOrganization.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.Create;
  FActive.value := value
end;

Function TFhirOrganization.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

Function TFhirOrganization.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Procedure TFhirOrganization.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirOrganization.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirOrganization.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.Create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Function TFhirOrganization.GetAliasList : TFhirStringList;
begin
  if FAliasList = nil then
    FAliasList := TFhirStringList.Create;
  result := FAliasList;
end;

Function TFhirOrganization.GetHasAliasList : boolean;
begin
  result := (FAliasList <> nil) and (FAliasList.count > 0);
end;

Function TFhirOrganization.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirOrganization.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

Function TFhirOrganization.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

Function TFhirOrganization.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

Procedure TFhirOrganization.SetPartOf(value : TFhirReference{TFhirOrganization});
begin
  FPartOf.free;
  FPartOf := value;
end;

Function TFhirOrganization.GetContactList : TFhirOrganizationContactList;
begin
  if FContactList = nil then
    FContactList := TFhirOrganizationContactList.Create;
  result := FContactList;
end;

Function TFhirOrganization.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Function TFhirOrganization.GetEndpointList : TFhirReferenceList{TFhirEndpoint};
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList{TFhirEndpoint}.Create;
  result := FEndpointList;
end;

Function TFhirOrganization.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

function TFhirOrganization.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FidentifierList.sizeInBytes(magic));
  inc(result, FActive.sizeInBytes(magic));
  inc(result, Ftype_List.sizeInBytes(magic));
  inc(result, FName.sizeInBytes(magic));
  inc(result, FaliasList.sizeInBytes(magic));
  inc(result, FtelecomList.sizeInBytes(magic));
  inc(result, FaddressList.sizeInBytes(magic));
  inc(result, FPartOf.sizeInBytes(magic));
  inc(result, FcontactList.sizeInBytes(magic));
  inc(result, FendpointList.sizeInBytes(magic));
end;

{ TFhirOrganizationListEnumerator }

Constructor TFhirOrganizationListEnumerator.Create(list : TFhirOrganizationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOrganizationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirOrganizationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOrganizationListEnumerator.GetCurrent : TFhirOrganization;
begin
  Result := FList[FIndex];
end;

function TFhirOrganizationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirOrganizationList }
function TFhirOrganizationList.AddItem(value: TFhirOrganization): TFhirOrganization;
begin
  add(value);
  result := value;
end;

function TFhirOrganizationList.Append: TFhirOrganization;
begin
  result := TFhirOrganization.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationList.ClearItems;
begin
  Clear;
end;

function TFhirOrganizationList.GetEnumerator : TFhirOrganizationListEnumerator;
begin
  result := TFhirOrganizationListEnumerator.Create(self.link);
end;

function TFhirOrganizationList.Clone: TFhirOrganizationList;
begin
  result := TFhirOrganizationList(inherited Clone);
end;

function TFhirOrganizationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrganizationList.GetItemN(index: Integer): TFhirOrganization;
begin
  result := TFhirOrganization(ObjectByIndex[index]);
end;

function TFhirOrganizationList.ItemClass: TFslObjectClass;
begin
  result := TFhirOrganization;
end;
function TFhirOrganizationList.IndexOf(value: TFhirOrganization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOrganizationList.Insert(index: Integer): TFhirOrganization;
begin
  result := TFhirOrganization.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationList.InsertItem(index: Integer; value: TFhirOrganization);
begin
  assert(value is TFhirOrganization);
  Inherited Insert(index, value);
end;

function TFhirOrganizationList.Item(index: Integer): TFhirOrganization;
begin
  result := TFhirOrganization(ObjectByIndex[index]);
end;

function TFhirOrganizationList.Link: TFhirOrganizationList;
begin
  result := TFhirOrganizationList(inherited Link);
end;

procedure TFhirOrganizationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrganizationList.SetItemByIndex(index: Integer; value: TFhirOrganization);
begin
  assert(value is TFhirOrganization);
  FhirOrganizations[index] := value;
end;

procedure TFhirOrganizationList.SetItemN(index: Integer; value: TFhirOrganization);
begin
  assert(value is TFhirOrganization);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ORGANIZATION}

{$IFDEF FHIR_ORGANIZATIONAFFILIATION}

{ TFhirOrganizationAffiliation }

constructor TFhirOrganizationAffiliation.Create;
begin
  inherited;
end;

destructor TFhirOrganizationAffiliation.Destroy;
begin
  FIdentifierList.free;
  FActive.free;
  FPeriod.free;
  FOrganization.free;
  FParticipatingOrganization.free;
  FNetworkList.free;
  FCodeList.free;
  FSpecialtyList.free;
  FLocationList.free;
  FHealthcareServiceList.free;
  FTelecomList.free;
  FEndpointList.free;
  inherited;
end;

function TFhirOrganizationAffiliation.GetResourceType : TFhirResourceType;
begin
  result := frtOrganizationAffiliation;
end;

procedure TFhirOrganizationAffiliation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirOrganizationAffiliation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirOrganizationAffiliation(oSource).FIdentifierList);
  end;
  activeElement := TFhirOrganizationAffiliation(oSource).activeElement.Clone;
  period := TFhirOrganizationAffiliation(oSource).period.Clone;
  organization := TFhirOrganizationAffiliation(oSource).organization.Clone;
  participatingOrganization := TFhirOrganizationAffiliation(oSource).participatingOrganization.Clone;
  if (TFhirOrganizationAffiliation(oSource).FNetworkList = nil) then
  begin
    FNetworkList.free;
    FNetworkList := nil;
  end
  else
  begin
    if FNetworkList = nil then
      FNetworkList := TFhirReferenceList{TFhirOrganization}.Create;
    FNetworkList.Assign(TFhirOrganizationAffiliation(oSource).FNetworkList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirOrganizationAffiliation(oSource).FCodeList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirOrganizationAffiliation(oSource).FSpecialtyList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirReferenceList{TFhirLocation}.Create;
    FLocationList.Assign(TFhirOrganizationAffiliation(oSource).FLocationList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FHealthcareServiceList = nil) then
  begin
    FHealthcareServiceList.free;
    FHealthcareServiceList := nil;
  end
  else
  begin
    if FHealthcareServiceList = nil then
      FHealthcareServiceList := TFhirReferenceList{TFhirHealthcareService}.Create;
    FHealthcareServiceList.Assign(TFhirOrganizationAffiliation(oSource).FHealthcareServiceList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirOrganizationAffiliation(oSource).FTelecomList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList{TFhirEndpoint}.Create;
    FEndpointList.Assign(TFhirOrganizationAffiliation(oSource).FEndpointList);
  end;
end;

procedure TFhirOrganizationAffiliation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'participatingOrganization') Then
     list.add(self.link, 'participatingOrganization', FParticipatingOrganization.Link);
  if (child_name = 'network') Then
    list.addAll(self, 'network', FNetworkList);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'healthcareService') Then
    list.addAll(self, 'healthcareService', FHealthcareServiceList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
end;

procedure TFhirOrganizationAffiliation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'participatingOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FParticipatingOrganization.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'network', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FNetworkList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'location', 'Reference(Location)', true, TFhirReference{TFhirLocation}, FLocationList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'healthcareService', 'Reference(HealthcareService)', true, TFhirReference{TFhirHealthcareService}, FHealthcareServiceList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'endpoint', 'Reference(Endpoint)', true, TFhirReference{TFhirEndpoint}, FEndpointList.Link)){3};
end;

function TFhirOrganizationAffiliation.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'participatingOrganization') then
  begin
    ParticipatingOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    NetworkList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(propValue as TFhirReference{TFhirLocation}){2a};
    result := propValue;
  end
  else if (propName = 'healthcareService') then
  begin
    HealthcareServiceList.add(propValue as TFhirReference{TFhirHealthcareService}){2a};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference{TFhirEndpoint}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirOrganizationAffiliation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'network') then NetworkList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'location') then LocationList.insertItem(index, propValue as TFhirReference{TFhirLocation}){2a}
  else if (propName = 'healthcareService') then HealthcareServiceList.insertItem(index, propValue as TFhirReference{TFhirHealthcareService}){2a}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference{TFhirEndpoint}){2a}
  else inherited;
end;

function TFhirOrganizationAffiliation.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'active') then result := TFhirBoolean.Create() {5b}
  else if (propName = 'period') then result := TFhirPeriod.Create(){4b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.Create(){4b}
  else if (propName = 'participatingOrganization') then result := TFhirReference{TFhirOrganization}.Create(){4b}
  else if (propName = 'network') then result := NetworkList.new(){2}
  else if (propName = 'code') then result := CodeList.new(){2}
  else if (propName = 'specialty') then result := SpecialtyList.new(){2}
  else if (propName = 'location') then result := LocationList.new(){2}
  else if (propName = 'healthcareService') then result := HealthcareServiceList.new(){2}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else if (propName = 'endpoint') then result := EndpointList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOrganizationAffiliation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'participatingOrganization') then result := 'Reference'
  else if (propName = 'network') then result := 'Reference'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'healthcareService') then result := 'Reference'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'endpoint') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOrganizationAffiliation.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'participatingOrganization') then ParticipatingOrganizationElement := nil
  else if (propName = 'network') then deletePropertyValue('network', NetworkList, value) {2}
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value) {2}
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value) {2}
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value) {2}
  else if (propName = 'healthcareService') then deletePropertyValue('healthcareService', HealthcareServiceList, value) {2}
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOrganizationAffiliation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'active') then ActiveElement := asBoolean(new){5b}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'participatingOrganization') then ParticipatingOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'network') then replacePropertyValue('network', NetworkList, existing, new) {2}
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {2}
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new) {2}
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new) {2}
  else if (propName = 'healthcareService') then replacePropertyValue('healthcareService', HealthcareServiceList, existing, new) {2}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOrganizationAffiliation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'network') then NetworkList.move(source, destination){2a}
  else if (propName = 'code') then CodeList.move(source, destination){2a}
  else if (propName = 'specialty') then SpecialtyList.move(source, destination){2a}
  else if (propName = 'location') then LocationList.move(source, destination){2a}
  else if (propName = 'healthcareService') then HealthcareServiceList.move(source, destination){2a}
  else if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else if (propName = 'endpoint') then EndpointList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOrganizationAffiliation.fhirType : string;
begin
  result := 'OrganizationAffiliation';
end;

function TFhirOrganizationAffiliation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FPeriod) and isEmptyProp(FOrganization) and isEmptyProp(FParticipatingOrganization) and isEmptyProp(FnetworkList) and isEmptyProp(FcodeList) and isEmptyProp(FspecialtyList) and isEmptyProp(FlocationList) and isEmptyProp(FhealthcareServiceList) and isEmptyProp(FtelecomList) and isEmptyProp(FendpointList);
end;

function TFhirOrganizationAffiliation.equals(other : TObject) : boolean; 
var
  o : TFhirOrganizationAffiliation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOrganizationAffiliation)) then
    result := false
  else
  begin
    o := TFhirOrganizationAffiliation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(organizationElement, o.organizationElement, true) and 
      compareDeep(participatingOrganizationElement, o.participatingOrganizationElement, true) and 
      compareDeep(networkList, o.networkList, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(specialtyList, o.specialtyList, true) and compareDeep(locationList, o.locationList, true) and 
      compareDeep(healthcareServiceList, o.healthcareServiceList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(endpointList, o.endpointList, true);
  end;
end;

function TFhirOrganizationAffiliation.Link : TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation(inherited Link);
end;

function TFhirOrganizationAffiliation.Clone : TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation(inherited Clone);
end;

procedure TFhirOrganizationAffiliation.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('period');
  fields.add('organization');
  fields.add('participatingOrganization');
  fields.add('network');
  fields.add('code');
  fields.add('specialty');
  fields.add('location');
  fields.add('healthcareService');
  fields.add('telecom');
  fields.add('endpoint');
end;

{ TFhirOrganizationAffiliation }

Function TFhirOrganizationAffiliation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirOrganizationAffiliation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirOrganizationAffiliation.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

Function TFhirOrganizationAffiliation.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

Procedure TFhirOrganizationAffiliation.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.Create;
  FActive.value := value
end;

Procedure TFhirOrganizationAffiliation.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirOrganizationAffiliation.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirOrganizationAffiliation.SetParticipatingOrganization(value : TFhirReference{TFhirOrganization});
begin
  FParticipatingOrganization.free;
  FParticipatingOrganization := value;
end;

Function TFhirOrganizationAffiliation.GetNetworkList : TFhirReferenceList{TFhirOrganization};
begin
  if FNetworkList = nil then
    FNetworkList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FNetworkList;
end;

Function TFhirOrganizationAffiliation.GetHasNetworkList : boolean;
begin
  result := (FNetworkList <> nil) and (FNetworkList.count > 0);
end;

Function TFhirOrganizationAffiliation.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

Function TFhirOrganizationAffiliation.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

Function TFhirOrganizationAffiliation.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

Function TFhirOrganizationAffiliation.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

Function TFhirOrganizationAffiliation.GetLocationList : TFhirReferenceList{TFhirLocation};
begin
  if FLocationList = nil then
    FLocationList := TFhirReferenceList{TFhirLocation}.Create;
  result := FLocationList;
end;

Function TFhirOrganizationAffiliation.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

Function TFhirOrganizationAffiliation.GetHealthcareServiceList : TFhirReferenceList{TFhirHealthcareService};
begin
  if FHealthcareServiceList = nil then
    FHealthcareServiceList := TFhirReferenceList{TFhirHealthcareService}.Create;
  result := FHealthcareServiceList;
end;

Function TFhirOrganizationAffiliation.GetHasHealthcareServiceList : boolean;
begin
  result := (FHealthcareServiceList <> nil) and (FHealthcareServiceList.count > 0);
end;

Function TFhirOrganizationAffiliation.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirOrganizationAffiliation.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

Function TFhirOrganizationAffiliation.GetEndpointList : TFhirReferenceList{TFhirEndpoint};
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList{TFhirEndpoint}.Create;
  result := FEndpointList;
end;

Function TFhirOrganizationAffiliation.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

function TFhirOrganizationAffiliation.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FidentifierList.sizeInBytes(magic));
  inc(result, FActive.sizeInBytes(magic));
  inc(result, FPeriod.sizeInBytes(magic));
  inc(result, FOrganization.sizeInBytes(magic));
  inc(result, FParticipatingOrganization.sizeInBytes(magic));
  inc(result, FnetworkList.sizeInBytes(magic));
  inc(result, FcodeList.sizeInBytes(magic));
  inc(result, FspecialtyList.sizeInBytes(magic));
  inc(result, FlocationList.sizeInBytes(magic));
  inc(result, FhealthcareServiceList.sizeInBytes(magic));
  inc(result, FtelecomList.sizeInBytes(magic));
  inc(result, FendpointList.sizeInBytes(magic));
end;

{ TFhirOrganizationAffiliationListEnumerator }

Constructor TFhirOrganizationAffiliationListEnumerator.Create(list : TFhirOrganizationAffiliationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOrganizationAffiliationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirOrganizationAffiliationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOrganizationAffiliationListEnumerator.GetCurrent : TFhirOrganizationAffiliation;
begin
  Result := FList[FIndex];
end;

function TFhirOrganizationAffiliationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirOrganizationAffiliationList }
function TFhirOrganizationAffiliationList.AddItem(value: TFhirOrganizationAffiliation): TFhirOrganizationAffiliation;
begin
  add(value);
  result := value;
end;

function TFhirOrganizationAffiliationList.Append: TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationAffiliationList.ClearItems;
begin
  Clear;
end;

function TFhirOrganizationAffiliationList.GetEnumerator : TFhirOrganizationAffiliationListEnumerator;
begin
  result := TFhirOrganizationAffiliationListEnumerator.Create(self.link);
end;

function TFhirOrganizationAffiliationList.Clone: TFhirOrganizationAffiliationList;
begin
  result := TFhirOrganizationAffiliationList(inherited Clone);
end;

function TFhirOrganizationAffiliationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrganizationAffiliationList.GetItemN(index: Integer): TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation(ObjectByIndex[index]);
end;

function TFhirOrganizationAffiliationList.ItemClass: TFslObjectClass;
begin
  result := TFhirOrganizationAffiliation;
end;
function TFhirOrganizationAffiliationList.IndexOf(value: TFhirOrganizationAffiliation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOrganizationAffiliationList.Insert(index: Integer): TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationAffiliationList.InsertItem(index: Integer; value: TFhirOrganizationAffiliation);
begin
  assert(value is TFhirOrganizationAffiliation);
  Inherited Insert(index, value);
end;

function TFhirOrganizationAffiliationList.Item(index: Integer): TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation(ObjectByIndex[index]);
end;

function TFhirOrganizationAffiliationList.Link: TFhirOrganizationAffiliationList;
begin
  result := TFhirOrganizationAffiliationList(inherited Link);
end;

procedure TFhirOrganizationAffiliationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrganizationAffiliationList.SetItemByIndex(index: Integer; value: TFhirOrganizationAffiliation);
begin
  assert(value is TFhirOrganizationAffiliation);
  FhirOrganizationAffiliations[index] := value;
end;

procedure TFhirOrganizationAffiliationList.SetItemN(index: Integer; value: TFhirOrganizationAffiliation);
begin
  assert(value is TFhirOrganizationAffiliation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ORGANIZATIONAFFILIATION}

{$IFDEF FHIR_PATIENT}

{ TFhirPatientContact }

constructor TFhirPatientContact.Create;
begin
  inherited;
end;

destructor TFhirPatientContact.Destroy;
begin
  FRelationshipList.free;
  FName.free;
  FTelecomList.free;
  FAddress.free;
  FGender.free;
  FOrganization.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirPatientContact.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPatientContact(oSource).FRelationshipList = nil) then
  begin
    FRelationshipList.free;
    FRelationshipList := nil;
  end
  else
  begin
    if FRelationshipList = nil then
      FRelationshipList := TFhirCodeableConceptList.Create;
    FRelationshipList.Assign(TFhirPatientContact(oSource).FRelationshipList);
  end;
  name := TFhirPatientContact(oSource).name.Clone;
  if (TFhirPatientContact(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirPatientContact(oSource).FTelecomList);
  end;
  address := TFhirPatientContact(oSource).address.Clone;
  FGender := TFhirPatientContact(oSource).FGender.Link;
  organization := TFhirPatientContact(oSource).organization.Clone;
  period := TFhirPatientContact(oSource).period.Clone;
end;

procedure TFhirPatientContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'relationship') Then
    list.addAll(self, 'relationship', FRelationshipList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirPatientContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'relationship', 'CodeableConcept', true, TFhirCodeableConcept, FRelationshipList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'name', 'HumanName', false, TFhirHumanName, FName.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'address', 'Address', false, TFhirAddress, FAddress.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'gender', 'code', false, TFHIREnum, FGender.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
end;

function TFhirPatientContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'relationship') then
  begin
    RelationshipList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    Name := propValue as TFhirHumanName{4b};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    Address := propValue as TFhirAddress{4b};
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue);
    result := propValue
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPatientContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'relationship') then RelationshipList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else inherited;
end;

function TFhirPatientContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'relationship') then result := RelationshipList.new(){2}
  else if (propName = 'name') then result := TFhirHumanName.Create(){4b}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else if (propName = 'address') then result := TFhirAddress.Create(){4b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.Create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.Create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPatientContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPatientContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'relationship') then deletePropertyValue('relationship', RelationshipList, value) {2}
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else if (propName = 'address') then AddressElement := nil
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPatientContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'relationship') then replacePropertyValue('relationship', RelationshipList, existing, new) {2}
  else if (propName = 'name') then NameElement := new as TFhirHumanName{4}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else if (propName = 'address') then AddressElement := new as TFhirAddress{4}
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new){4}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPatientContact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'relationship') then RelationshipList.move(source, destination){2a}
  else if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPatientContact.fhirType : string;
begin
  result := 'contact';
end;

function TFhirPatientContact.Link : TFhirPatientContact;
begin
  result := TFhirPatientContact(inherited Link);
end;

function TFhirPatientContact.Clone : TFhirPatientContact;
begin
  result := TFhirPatientContact(inherited Clone);
end;

function TFhirPatientContact.equals(other : TObject) : boolean; 
var
  o : TFhirPatientContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPatientContact)) then
    result := false
  else
  begin
    o := TFhirPatientContact(other);
    result := compareDeep(relationshipList, o.relationshipList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(telecomList, o.telecomList, true) and compareDeep(addressElement, o.addressElement, true) and 
      compareDeep(genderElement, o.genderElement, true) and compareDeep(organizationElement, o.organizationElement, true) and 
      compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirPatientContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FrelationshipList) and isEmptyProp(FName) and isEmptyProp(FtelecomList) and isEmptyProp(FAddress) and isEmptyProp(FGender) and isEmptyProp(FOrganization) and isEmptyProp(FPeriod);
end;

procedure TFhirPatientContact.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('relationship');
  fields.add('name');
  fields.add('telecom');
  fields.add('address');
  fields.add('gender');
  fields.add('organization');
  fields.add('period');
end;

{ TFhirPatientContact }

Function TFhirPatientContact.GetRelationshipList : TFhirCodeableConceptList;
begin
  if FRelationshipList = nil then
    FRelationshipList := TFhirCodeableConceptList.Create;
  result := FRelationshipList;
end;

Function TFhirPatientContact.GetHasRelationshipList : boolean;
begin
  result := (FRelationshipList <> nil) and (FRelationshipList.count > 0);
end;

Procedure TFhirPatientContact.SetName(value : TFhirHumanName);
begin
  FName.free;
  FName := value;
end;

Function TFhirPatientContact.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirPatientContact.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

Procedure TFhirPatientContact.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value;
end;

Procedure TFhirPatientContact.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

Function TFhirPatientContact.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

Procedure TFhirPatientContact.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.Create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

Procedure TFhirPatientContact.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Procedure TFhirPatientContact.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirPatientContact.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FrelationshipList.sizeInBytes(magic));
  inc(result, FName.sizeInBytes(magic));
  inc(result, FtelecomList.sizeInBytes(magic));
  inc(result, FAddress.sizeInBytes(magic));
  inc(result, FGender.sizeInBytes(magic));
  inc(result, FOrganization.sizeInBytes(magic));
  inc(result, FPeriod.sizeInBytes(magic));
end;

{ TFhirPatientContactListEnumerator }

Constructor TFhirPatientContactListEnumerator.Create(list : TFhirPatientContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPatientContactListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPatientContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPatientContactListEnumerator.GetCurrent : TFhirPatientContact;
begin
  Result := FList[FIndex];
end;

function TFhirPatientContactListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPatientContactList }
function TFhirPatientContactList.AddItem(value: TFhirPatientContact): TFhirPatientContact;
begin
  add(value);
  result := value;
end;

function TFhirPatientContactList.Append: TFhirPatientContact;
begin
  result := TFhirPatientContact.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientContactList.ClearItems;
begin
  Clear;
end;

function TFhirPatientContactList.GetEnumerator : TFhirPatientContactListEnumerator;
begin
  result := TFhirPatientContactListEnumerator.Create(self.link);
end;

function TFhirPatientContactList.Clone: TFhirPatientContactList;
begin
  result := TFhirPatientContactList(inherited Clone);
end;

function TFhirPatientContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientContactList.GetItemN(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact(ObjectByIndex[index]);
end;

function TFhirPatientContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirPatientContact;
end;
function TFhirPatientContactList.IndexOf(value: TFhirPatientContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPatientContactList.Insert(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientContactList.InsertItem(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  Inherited Insert(index, value);
end;

function TFhirPatientContactList.Item(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact(ObjectByIndex[index]);
end;

function TFhirPatientContactList.Link: TFhirPatientContactList;
begin
  result := TFhirPatientContactList(inherited Link);
end;

procedure TFhirPatientContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientContactList.SetItemByIndex(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  FhirPatientContacts[index] := value;
end;

procedure TFhirPatientContactList.SetItemN(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  ObjectByIndex[index] := value;
end;

{ TFhirPatientCommunication }

constructor TFhirPatientCommunication.Create;
begin
  inherited;
end;

destructor TFhirPatientCommunication.Destroy;
begin
  FLanguage.free;
  FPreferred.free;
  inherited;
end;

procedure TFhirPatientCommunication.Assign(oSource : TFslObject);
begin
  inherited;
  language := TFhirPatientCommunication(oSource).language.Clone;
  preferredElement := TFhirPatientCommunication(oSource).preferredElement.Clone;
end;

procedure TFhirPatientCommunication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'preferred') Then
     list.add(self.link, 'preferred', FPreferred.Link);
end;

procedure TFhirPatientCommunication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'preferred', 'boolean', false, TFhirBoolean, FPreferred.Link));{2}
end;

function TFhirPatientCommunication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'preferred') then
  begin
    PreferredElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPatientCommunication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPatientCommunication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'language') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'preferred') then result := TFhirBoolean.Create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPatientCommunication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'language') then result := 'CodeableConcept'
  else if (propName = 'preferred') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPatientCommunication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := nil
  else if (propName = 'preferred') then PreferredElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPatientCommunication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept{4}
  else if (propName = 'preferred') then PreferredElement := asBoolean(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPatientCommunication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPatientCommunication.fhirType : string;
begin
  result := 'communication';
end;

function TFhirPatientCommunication.Link : TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication(inherited Link);
end;

function TFhirPatientCommunication.Clone : TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication(inherited Clone);
end;

function TFhirPatientCommunication.equals(other : TObject) : boolean; 
var
  o : TFhirPatientCommunication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPatientCommunication)) then
    result := false
  else
  begin
    o := TFhirPatientCommunication(other);
    result := compareDeep(languageElement, o.languageElement, true) and compareDeep(preferredElement, o.preferredElement, true);
  end;
end;

function TFhirPatientCommunication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLanguage) and isEmptyProp(FPreferred);
end;

procedure TFhirPatientCommunication.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('language');
  fields.add('preferred');
end;

{ TFhirPatientCommunication }

Procedure TFhirPatientCommunication.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value;
end;

Procedure TFhirPatientCommunication.SetPreferred(value : TFhirBoolean);
begin
  FPreferred.free;
  FPreferred := value;
end;

Function TFhirPatientCommunication.GetPreferredST : Boolean;
begin
  if FPreferred = nil then
    result := false
  else
    result := FPreferred.value;
end;

Procedure TFhirPatientCommunication.SetPreferredST(value : Boolean);
begin
  if FPreferred = nil then
    FPreferred := TFhirBoolean.Create;
  FPreferred.value := value
end;

function TFhirPatientCommunication.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FLanguage.sizeInBytes(magic));
  inc(result, FPreferred.sizeInBytes(magic));
end;

{ TFhirPatientCommunicationListEnumerator }

Constructor TFhirPatientCommunicationListEnumerator.Create(list : TFhirPatientCommunicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPatientCommunicationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPatientCommunicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPatientCommunicationListEnumerator.GetCurrent : TFhirPatientCommunication;
begin
  Result := FList[FIndex];
end;

function TFhirPatientCommunicationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPatientCommunicationList }
function TFhirPatientCommunicationList.AddItem(value: TFhirPatientCommunication): TFhirPatientCommunication;
begin
  add(value);
  result := value;
end;

function TFhirPatientCommunicationList.Append: TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientCommunicationList.ClearItems;
begin
  Clear;
end;

function TFhirPatientCommunicationList.GetEnumerator : TFhirPatientCommunicationListEnumerator;
begin
  result := TFhirPatientCommunicationListEnumerator.Create(self.link);
end;

function TFhirPatientCommunicationList.Clone: TFhirPatientCommunicationList;
begin
  result := TFhirPatientCommunicationList(inherited Clone);
end;

function TFhirPatientCommunicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientCommunicationList.GetItemN(index: Integer): TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication(ObjectByIndex[index]);
end;

function TFhirPatientCommunicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirPatientCommunication;
end;
function TFhirPatientCommunicationList.IndexOf(value: TFhirPatientCommunication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPatientCommunicationList.Insert(index: Integer): TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientCommunicationList.InsertItem(index: Integer; value: TFhirPatientCommunication);
begin
  assert(value is TFhirPatientCommunication);
  Inherited Insert(index, value);
end;

function TFhirPatientCommunicationList.Item(index: Integer): TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication(ObjectByIndex[index]);
end;

function TFhirPatientCommunicationList.Link: TFhirPatientCommunicationList;
begin
  result := TFhirPatientCommunicationList(inherited Link);
end;

procedure TFhirPatientCommunicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientCommunicationList.SetItemByIndex(index: Integer; value: TFhirPatientCommunication);
begin
  assert(value is TFhirPatientCommunication);
  FhirPatientCommunications[index] := value;
end;

procedure TFhirPatientCommunicationList.SetItemN(index: Integer; value: TFhirPatientCommunication);
begin
  assert(value is TFhirPatientCommunication);
  ObjectByIndex[index] := value;
end;

{ TFhirPatientLink }

constructor TFhirPatientLink.Create;
begin
  inherited;
end;

destructor TFhirPatientLink.Destroy;
begin
  FOther.free;
  FType_.free;
  inherited;
end;

procedure TFhirPatientLink.Assign(oSource : TFslObject);
begin
  inherited;
  other := TFhirPatientLink(oSource).other.Clone;
  FType_ := TFhirPatientLink(oSource).FType_.Link;
end;

procedure TFhirPatientLink.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'other') Then
     list.add(self.link, 'other', FOther.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirPatientLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'other', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FOther.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
end;

function TFhirPatientLink.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'other') then
  begin
    Other := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirLinkTypeEnum, CODES_TFhirLinkTypeEnum, propValue);
    result := propValue
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPatientLink.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPatientLink.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'other') then result := TFhirReference{TFhirPatient}.Create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPatientLink.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'other') then result := 'Reference'
  else if (propName = 'type') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPatientLink.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'other') then OtherElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPatientLink.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'other') then OtherElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirLinkTypeEnum, CODES_TFhirLinkTypeEnum, new){4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPatientLink.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPatientLink.fhirType : string;
begin
  result := 'link';
end;

function TFhirPatientLink.Link : TFhirPatientLink;
begin
  result := TFhirPatientLink(inherited Link);
end;

function TFhirPatientLink.Clone : TFhirPatientLink;
begin
  result := TFhirPatientLink(inherited Clone);
end;

function TFhirPatientLink.equals(other : TObject) : boolean; 
var
  o : TFhirPatientLink;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPatientLink)) then
    result := false
  else
  begin
    o := TFhirPatientLink(other);
    result := compareDeep(otherElement, o.otherElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirPatientLink.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOther) and isEmptyProp(FType_);
end;

procedure TFhirPatientLink.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('other');
  fields.add('type');
end;

{ TFhirPatientLink }

Procedure TFhirPatientLink.SetOther(value : TFhirReference{TFhirPatient});
begin
  FOther.free;
  FOther := value;
end;

Procedure TFhirPatientLink.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirPatientLink.GetType_ST : TFhirLinkTypeEnum;
begin
  if FType_ = nil then
    result := TFhirLinkTypeEnum(0)
  else
    result := TFhirLinkTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirLinkTypeEnum, FType_.value));
end;

Procedure TFhirPatientLink.SetType_ST(value : TFhirLinkTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.Create(SYSTEMS_TFhirLinkTypeEnum[value], CODES_TFhirLinkTypeEnum[value]);
end;

function TFhirPatientLink.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FOther.sizeInBytes(magic));
  inc(result, FType_.sizeInBytes(magic));
end;

{ TFhirPatientLinkListEnumerator }

Constructor TFhirPatientLinkListEnumerator.Create(list : TFhirPatientLinkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPatientLinkListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPatientLinkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPatientLinkListEnumerator.GetCurrent : TFhirPatientLink;
begin
  Result := FList[FIndex];
end;

function TFhirPatientLinkListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPatientLinkList }
function TFhirPatientLinkList.AddItem(value: TFhirPatientLink): TFhirPatientLink;
begin
  add(value);
  result := value;
end;

function TFhirPatientLinkList.Append: TFhirPatientLink;
begin
  result := TFhirPatientLink.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientLinkList.ClearItems;
begin
  Clear;
end;

function TFhirPatientLinkList.GetEnumerator : TFhirPatientLinkListEnumerator;
begin
  result := TFhirPatientLinkListEnumerator.Create(self.link);
end;

function TFhirPatientLinkList.Clone: TFhirPatientLinkList;
begin
  result := TFhirPatientLinkList(inherited Clone);
end;

function TFhirPatientLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientLinkList.GetItemN(index: Integer): TFhirPatientLink;
begin
  result := TFhirPatientLink(ObjectByIndex[index]);
end;

function TFhirPatientLinkList.ItemClass: TFslObjectClass;
begin
  result := TFhirPatientLink;
end;
function TFhirPatientLinkList.IndexOf(value: TFhirPatientLink): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPatientLinkList.Insert(index: Integer): TFhirPatientLink;
begin
  result := TFhirPatientLink.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientLinkList.InsertItem(index: Integer; value: TFhirPatientLink);
begin
  assert(value is TFhirPatientLink);
  Inherited Insert(index, value);
end;

function TFhirPatientLinkList.Item(index: Integer): TFhirPatientLink;
begin
  result := TFhirPatientLink(ObjectByIndex[index]);
end;

function TFhirPatientLinkList.Link: TFhirPatientLinkList;
begin
  result := TFhirPatientLinkList(inherited Link);
end;

procedure TFhirPatientLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientLinkList.SetItemByIndex(index: Integer; value: TFhirPatientLink);
begin
  assert(value is TFhirPatientLink);
  FhirPatientLinks[index] := value;
end;

procedure TFhirPatientLinkList.SetItemN(index: Integer; value: TFhirPatientLink);
begin
  assert(value is TFhirPatientLink);
  ObjectByIndex[index] := value;
end;

{ TFhirPatient }

constructor TFhirPatient.Create;
begin
  inherited;
end;

destructor TFhirPatient.Destroy;
begin
  FIdentifierList.free;
  FActive.free;
  FNameList.free;
  FTelecomList.free;
  FGender.free;
  FBirthDate.free;
  FDeceased.free;
  FAddressList.free;
  FMaritalStatus.free;
  FMultipleBirth.free;
  FPhotoList.free;
  FContactList.free;
  FCommunicationList.free;
  FGeneralPractitionerList.free;
  FManagingOrganization.free;
  FLink_List.free;
  inherited;
end;

function TFhirPatient.GetResourceType : TFhirResourceType;
begin
  result := frtPatient;
end;

procedure TFhirPatient.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPatient(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPatient(oSource).FIdentifierList);
  end;
  activeElement := TFhirPatient(oSource).activeElement.Clone;
  if (TFhirPatient(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirHumanNameList.Create;
    FNameList.Assign(TFhirPatient(oSource).FNameList);
  end;
  if (TFhirPatient(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirPatient(oSource).FTelecomList);
  end;
  FGender := TFhirPatient(oSource).FGender.Link;
  birthDateElement := TFhirPatient(oSource).birthDateElement.Clone;
  deceased := TFhirPatient(oSource).deceased.Clone;
  if (TFhirPatient(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirPatient(oSource).FAddressList);
  end;
  maritalStatus := TFhirPatient(oSource).maritalStatus.Clone;
  multipleBirth := TFhirPatient(oSource).multipleBirth.Clone;
  if (TFhirPatient(oSource).FPhotoList = nil) then
  begin
    FPhotoList.free;
    FPhotoList := nil;
  end
  else
  begin
    if FPhotoList = nil then
      FPhotoList := TFhirAttachmentList.Create;
    FPhotoList.Assign(TFhirPatient(oSource).FPhotoList);
  end;
  if (TFhirPatient(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirPatientContactList.Create;
    FContactList.Assign(TFhirPatient(oSource).FContactList);
  end;
  if (TFhirPatient(oSource).FCommunicationList = nil) then
  begin
    FCommunicationList.free;
    FCommunicationList := nil;
  end
  else
  begin
    if FCommunicationList = nil then
      FCommunicationList := TFhirPatientCommunicationList.Create;
    FCommunicationList.Assign(TFhirPatient(oSource).FCommunicationList);
  end;
  if (TFhirPatient(oSource).FGeneralPractitionerList = nil) then
  begin
    FGeneralPractitionerList.free;
    FGeneralPractitionerList := nil;
  end
  else
  begin
    if FGeneralPractitionerList = nil then
      FGeneralPractitionerList := TFhirReferenceList{TFhirOrganization}.Create;
    FGeneralPractitionerList.Assign(TFhirPatient(oSource).FGeneralPractitionerList);
  end;
  managingOrganization := TFhirPatient(oSource).managingOrganization.Clone;
  if (TFhirPatient(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirPatientLinkList.Create;
    FLink_List.Assign(TFhirPatient(oSource).FLink_List);
  end;
end;

procedure TFhirPatient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'birthDate') Then
     list.add(self.link, 'birthDate', FBirthDate.Link);
  if (child_name = 'deceased[x]') or (child_name = 'deceased') Then
     list.add(self.link, 'deceased[x]', FDeceased.Link);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'maritalStatus') Then
     list.add(self.link, 'maritalStatus', FMaritalStatus.Link);
  if (child_name = 'multipleBirth[x]') or (child_name = 'multipleBirth') Then
     list.add(self.link, 'multipleBirth[x]', FMultipleBirth.Link);
  if (child_name = 'photo') Then
    list.addAll(self, 'photo', FPhotoList);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'communication') Then
    list.addAll(self, 'communication', FCommunicationList);
  if (child_name = 'generalPractitioner') Then
    list.addAll(self, 'generalPractitioner', FGeneralPractitionerList);
  if (child_name = 'managingOrganization') Then
     list.add(self.link, 'managingOrganization', FManagingOrganization.Link);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
end;

procedure TFhirPatient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'name', 'HumanName', true, TFhirHumanName, FNameList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'gender', 'code', false, TFHIREnum, FGender.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'birthDate', 'date', false, TFhirDate, FBirthDate.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'deceased[x]', 'boolean|dateTime', false, TFhirType, FDeceased.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'maritalStatus', 'CodeableConcept', false, TFhirCodeableConcept, FMaritalStatus.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'multipleBirth[x]', 'boolean|integer', false, TFhirType, FMultipleBirth.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'photo', 'Attachment', true, TFhirAttachment, FPhotoList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'contact', '', true, TFhirPatientContact, FContactList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'communication', '', true, TFhirPatientCommunication, FCommunicationList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'generalPractitioner', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FGeneralPractitionerList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'managingOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FManagingOrganization.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'link', '', true, TFhirPatientLink, FLink_List.Link)){3};
end;

function TFhirPatient.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirHumanName){2a};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue);
    result := propValue
  end
  else if (propName = 'birthDate') then
  begin
    BirthDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then
  begin
    Deceased := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress){2a};
    result := propValue;
  end
  else if (propName = 'maritalStatus') then
  begin
    MaritalStatus := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'multipleBirth', ['Boolean', 'Integer'])) then
  begin
    MultipleBirth := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'photo') then
  begin
    PhotoList.add(propValue as TFhirAttachment){2a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirPatientContact){2a};
    result := propValue;
  end
  else if (propName = 'communication') then
  begin
    CommunicationList.add(propValue as TFhirPatientCommunication){2a};
    result := propValue;
  end
  else if (propName = 'generalPractitioner') then
  begin
    GeneralPractitionerList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirPatientLink){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirPatient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirHumanName){2a}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress){2a}
  else if (propName = 'photo') then PhotoList.insertItem(index, propValue as TFhirAttachment){2a}
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirPatientContact){2a}
  else if (propName = 'communication') then CommunicationList.insertItem(index, propValue as TFhirPatientCommunication){2a}
  else if (propName = 'generalPractitioner') then GeneralPractitionerList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirPatientLink){2a}
  else inherited;
end;

function TFhirPatient.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'active') then result := TFhirBoolean.Create() {5b}
  else if (propName = 'name') then result := NameList.new(){2}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else if (propName = 'birthDate') then result := TFhirDate.Create() {5b}
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then raise EFHIRException.Create('Cannot make property Deceased'){4x}
  else if (propName = 'address') then result := AddressList.new(){2}
  else if (propName = 'maritalStatus') then result := TFhirCodeableConcept.Create(){4b}
  else if (isMatchingName(propName, 'multipleBirth', ['Boolean', 'Integer'])) then raise EFHIRException.Create('Cannot make property MultipleBirth'){4x}
  else if (propName = 'photo') then result := PhotoList.new(){2}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'communication') then result := CommunicationList.new(){2}
  else if (propName = 'generalPractitioner') then result := GeneralPractitionerList.new(){2}
  else if (propName = 'managingOrganization') then result := TFhirReference{TFhirOrganization}.Create(){4b}
  else if (propName = 'link') then result := Link_List.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPatient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'birthDate') then result := 'date'
  else if (propName = 'deceased[x]') then result := 'boolean|dateTime'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'maritalStatus') then result := 'CodeableConcept'
  else if (propName = 'multipleBirth[x]') then result := 'boolean|integer'
  else if (propName = 'photo') then result := 'Attachment'
  else if (propName = 'contact') then result := ''
  else if (propName = 'communication') then result := ''
  else if (propName = 'generalPractitioner') then result := 'Reference'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'link') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPatient.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'name') then deletePropertyValue('name', NameList, value) {2}
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'birthDate') then BirthDateElement := nil
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then DeceasedElement := nil{4x}
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value) {2}
  else if (propName = 'maritalStatus') then MaritalStatusElement := nil
  else if (isMatchingName(propName, 'multipleBirth', ['Boolean', 'Integer'])) then MultipleBirthElement := nil{4x}
  else if (propName = 'photo') then deletePropertyValue('photo', PhotoList, value) {2}
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'communication') then deletePropertyValue('communication', CommunicationList, value) {2}
  else if (propName = 'generalPractitioner') then deletePropertyValue('generalPractitioner', GeneralPractitionerList, value) {2}
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := nil
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPatient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'active') then ActiveElement := asBoolean(new){5b}
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new) {2}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new){4}
  else if (propName = 'birthDate') then BirthDateElement := asDate(new){5b}
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then DeceasedElement := new as TFhirType{4x}
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new) {2}
  else if (propName = 'maritalStatus') then MaritalStatusElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'multipleBirth', ['Boolean', 'Integer'])) then MultipleBirthElement := new as TFhirType{4x}
  else if (propName = 'photo') then replacePropertyValue('photo', PhotoList, existing, new) {2}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'communication') then replacePropertyValue('communication', CommunicationList, existing, new) {2}
  else if (propName = 'generalPractitioner') then replacePropertyValue('generalPractitioner', GeneralPractitionerList, existing, new) {2}
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPatient.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'name') then NameList.move(source, destination){2a}
  else if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else if (propName = 'address') then AddressList.move(source, destination){2a}
  else if (propName = 'photo') then PhotoList.move(source, destination){2a}
  else if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'communication') then CommunicationList.move(source, destination){2a}
  else if (propName = 'generalPractitioner') then GeneralPractitionerList.move(source, destination){2a}
  else if (propName = 'link') then Link_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPatient.fhirType : string;
begin
  result := 'Patient';
end;

function TFhirPatient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FnameList) and isEmptyProp(FtelecomList) and isEmptyProp(FGender) and isEmptyProp(FBirthDate) and isEmptyProp(FDeceased) and isEmptyProp(FaddressList) and isEmptyProp(FMaritalStatus) and isEmptyProp(FMultipleBirth) and isEmptyProp(FphotoList) and isEmptyProp(FcontactList) and isEmptyProp(FcommunicationList) and isEmptyProp(FgeneralPractitionerList) and isEmptyProp(FManagingOrganization) and isEmptyProp(Flink_List);
end;

function TFhirPatient.equals(other : TObject) : boolean; 
var
  o : TFhirPatient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPatient)) then
    result := false
  else
  begin
    o := TFhirPatient(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(nameList, o.nameList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(genderElement, o.genderElement, true) and compareDeep(birthDateElement, o.birthDateElement, true) and 
      compareDeep(deceasedElement, o.deceasedElement, true) and compareDeep(addressList, o.addressList, true) and 
      compareDeep(maritalStatusElement, o.maritalStatusElement, true) and compareDeep(multipleBirthElement, o.multipleBirthElement, true) and 
      compareDeep(photoList, o.photoList, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(communicationList, o.communicationList, true) and compareDeep(generalPractitionerList, o.generalPractitionerList, true) and 
      compareDeep(managingOrganizationElement, o.managingOrganizationElement, true) and 
      compareDeep(link_List, o.link_List, true);
  end;
end;

function TFhirPatient.Link : TFhirPatient;
begin
  result := TFhirPatient(inherited Link);
end;

function TFhirPatient.Clone : TFhirPatient;
begin
  result := TFhirPatient(inherited Clone);
end;

procedure TFhirPatient.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('name');
  fields.add('telecom');
  fields.add('gender');
  fields.add('birthDate');
  fields.add('deceased[x]');
  fields.add('address');
  fields.add('maritalStatus');
  fields.add('multipleBirth[x]');
  fields.add('photo');
  fields.add('contact');
  fields.add('communication');
  fields.add('generalPractitioner');
  fields.add('managingOrganization');
  fields.add('link');
end;

{ TFhirPatient }

Function TFhirPatient.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirPatient.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirPatient.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

Function TFhirPatient.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

Procedure TFhirPatient.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.Create;
  FActive.value := value
end;

Function TFhirPatient.GetNameList : TFhirHumanNameList;
begin
  if FNameList = nil then
    FNameList := TFhirHumanNameList.Create;
  result := FNameList;
end;

Function TFhirPatient.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

Function TFhirPatient.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirPatient.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

Procedure TFhirPatient.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

Function TFhirPatient.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

Procedure TFhirPatient.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.Create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

Procedure TFhirPatient.SetBirthDate(value : TFhirDate);
begin
  FBirthDate.free;
  FBirthDate := value;
end;

Function TFhirPatient.GetBirthDateST : TFslDateTime;
begin
  if FBirthDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FBirthDate.value;
end;

Procedure TFhirPatient.SetBirthDateST(value : TFslDateTime);
begin
  if FBirthDate = nil then
    FBirthDate := TFhirDate.Create;
  FBirthDate.value := value
end;

Procedure TFhirPatient.SetDeceased(value : TFhirType);
begin
  FDeceased.free;
  FDeceased := value;
end;

Function TFhirPatient.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

Function TFhirPatient.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

Procedure TFhirPatient.SetMaritalStatus(value : TFhirCodeableConcept);
begin
  FMaritalStatus.free;
  FMaritalStatus := value;
end;

Procedure TFhirPatient.SetMultipleBirth(value : TFhirType);
begin
  FMultipleBirth.free;
  FMultipleBirth := value;
end;

Function TFhirPatient.GetPhotoList : TFhirAttachmentList;
begin
  if FPhotoList = nil then
    FPhotoList := TFhirAttachmentList.Create;
  result := FPhotoList;
end;

Function TFhirPatient.GetHasPhotoList : boolean;
begin
  result := (FPhotoList <> nil) and (FPhotoList.count > 0);
end;

Function TFhirPatient.GetContactList : TFhirPatientContactList;
begin
  if FContactList = nil then
    FContactList := TFhirPatientContactList.Create;
  result := FContactList;
end;

Function TFhirPatient.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Function TFhirPatient.GetCommunicationList : TFhirPatientCommunicationList;
begin
  if FCommunicationList = nil then
    FCommunicationList := TFhirPatientCommunicationList.Create;
  result := FCommunicationList;
end;

Function TFhirPatient.GetHasCommunicationList : boolean;
begin
  result := (FCommunicationList <> nil) and (FCommunicationList.count > 0);
end;

Function TFhirPatient.GetGeneralPractitionerList : TFhirReferenceList{TFhirOrganization};
begin
  if FGeneralPractitionerList = nil then
    FGeneralPractitionerList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FGeneralPractitionerList;
end;

Function TFhirPatient.GetHasGeneralPractitionerList : boolean;
begin
  result := (FGeneralPractitionerList <> nil) and (FGeneralPractitionerList.count > 0);
end;

Procedure TFhirPatient.SetManagingOrganization(value : TFhirReference{TFhirOrganization});
begin
  FManagingOrganization.free;
  FManagingOrganization := value;
end;

Function TFhirPatient.GetLink_List : TFhirPatientLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirPatientLinkList.Create;
  result := FLink_List;
end;

Function TFhirPatient.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

function TFhirPatient.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FidentifierList.sizeInBytes(magic));
  inc(result, FActive.sizeInBytes(magic));
  inc(result, FnameList.sizeInBytes(magic));
  inc(result, FtelecomList.sizeInBytes(magic));
  inc(result, FGender.sizeInBytes(magic));
  inc(result, FBirthDate.sizeInBytes(magic));
  inc(result, FDeceased.sizeInBytes(magic));
  inc(result, FaddressList.sizeInBytes(magic));
  inc(result, FMaritalStatus.sizeInBytes(magic));
  inc(result, FMultipleBirth.sizeInBytes(magic));
  inc(result, FphotoList.sizeInBytes(magic));
  inc(result, FcontactList.sizeInBytes(magic));
  inc(result, FcommunicationList.sizeInBytes(magic));
  inc(result, FgeneralPractitionerList.sizeInBytes(magic));
  inc(result, FManagingOrganization.sizeInBytes(magic));
  inc(result, Flink_List.sizeInBytes(magic));
end;

{ TFhirPatientListEnumerator }

Constructor TFhirPatientListEnumerator.Create(list : TFhirPatientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPatientListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPatientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPatientListEnumerator.GetCurrent : TFhirPatient;
begin
  Result := FList[FIndex];
end;

function TFhirPatientListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPatientList }
function TFhirPatientList.AddItem(value: TFhirPatient): TFhirPatient;
begin
  add(value);
  result := value;
end;

function TFhirPatientList.Append: TFhirPatient;
begin
  result := TFhirPatient.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientList.ClearItems;
begin
  Clear;
end;

function TFhirPatientList.GetEnumerator : TFhirPatientListEnumerator;
begin
  result := TFhirPatientListEnumerator.Create(self.link);
end;

function TFhirPatientList.Clone: TFhirPatientList;
begin
  result := TFhirPatientList(inherited Clone);
end;

function TFhirPatientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientList.GetItemN(index: Integer): TFhirPatient;
begin
  result := TFhirPatient(ObjectByIndex[index]);
end;

function TFhirPatientList.ItemClass: TFslObjectClass;
begin
  result := TFhirPatient;
end;
function TFhirPatientList.IndexOf(value: TFhirPatient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPatientList.Insert(index: Integer): TFhirPatient;
begin
  result := TFhirPatient.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientList.InsertItem(index: Integer; value: TFhirPatient);
begin
  assert(value is TFhirPatient);
  Inherited Insert(index, value);
end;

function TFhirPatientList.Item(index: Integer): TFhirPatient;
begin
  result := TFhirPatient(ObjectByIndex[index]);
end;

function TFhirPatientList.Link: TFhirPatientList;
begin
  result := TFhirPatientList(inherited Link);
end;

procedure TFhirPatientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientList.SetItemByIndex(index: Integer; value: TFhirPatient);
begin
  assert(value is TFhirPatient);
  FhirPatients[index] := value;
end;

procedure TFhirPatientList.SetItemN(index: Integer; value: TFhirPatient);
begin
  assert(value is TFhirPatient);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PATIENT}

{$IFDEF FHIR_PERSON}

{ TFhirPersonLink }

constructor TFhirPersonLink.Create;
begin
  inherited;
end;

destructor TFhirPersonLink.Destroy;
begin
  FTarget.free;
  FAssurance.free;
  inherited;
end;

procedure TFhirPersonLink.Assign(oSource : TFslObject);
begin
  inherited;
  target := TFhirPersonLink(oSource).target.Clone;
  FAssurance := TFhirPersonLink(oSource).FAssurance.Link;
end;

procedure TFhirPersonLink.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'assurance') Then
     list.add(self.link, 'assurance', FAssurance.Link);
end;

procedure TFhirPersonLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'target', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FTarget.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'assurance', 'code', false, TFHIREnum, FAssurance.Link));{1}
end;

function TFhirPersonLink.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'target') then
  begin
    Target := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'assurance') then
  begin
    AssuranceElement := asEnum(SYSTEMS_TFhirIdentityAssuranceLevelEnum, CODES_TFhirIdentityAssuranceLevelEnum, propValue);
    result := propValue
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPersonLink.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPersonLink.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'target') then result := TFhirReference{TFhirPatient}.Create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPersonLink.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'target') then result := 'Reference'
  else if (propName = 'assurance') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPersonLink.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'target') then TargetElement := nil
  else if (propName = 'assurance') then AssuranceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPersonLink.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'target') then TargetElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'assurance') then AssuranceElement := asEnum(SYSTEMS_TFhirIdentityAssuranceLevelEnum, CODES_TFhirIdentityAssuranceLevelEnum, new){4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPersonLink.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPersonLink.fhirType : string;
begin
  result := 'link';
end;

function TFhirPersonLink.Link : TFhirPersonLink;
begin
  result := TFhirPersonLink(inherited Link);
end;

function TFhirPersonLink.Clone : TFhirPersonLink;
begin
  result := TFhirPersonLink(inherited Clone);
end;

function TFhirPersonLink.equals(other : TObject) : boolean; 
var
  o : TFhirPersonLink;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPersonLink)) then
    result := false
  else
  begin
    o := TFhirPersonLink(other);
    result := compareDeep(targetElement, o.targetElement, true) and compareDeep(assuranceElement, o.assuranceElement, true);
  end;
end;

function TFhirPersonLink.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTarget) and isEmptyProp(FAssurance);
end;

procedure TFhirPersonLink.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('target');
  fields.add('assurance');
end;

{ TFhirPersonLink }

Procedure TFhirPersonLink.SetTarget(value : TFhirReference{TFhirPatient});
begin
  FTarget.free;
  FTarget := value;
end;

Procedure TFhirPersonLink.SetAssurance(value : TFhirEnum);
begin
  FAssurance.free;
  FAssurance := value;
end;

Function TFhirPersonLink.GetAssuranceST : TFhirIdentityAssuranceLevelEnum;
begin
  if FAssurance = nil then
    result := TFhirIdentityAssuranceLevelEnum(0)
  else
    result := TFhirIdentityAssuranceLevelEnum(StringArrayIndexOfSensitive(CODES_TFhirIdentityAssuranceLevelEnum, FAssurance.value));
end;

Procedure TFhirPersonLink.SetAssuranceST(value : TFhirIdentityAssuranceLevelEnum);
begin
  if ord(value) = 0 then
    AssuranceElement := nil
  else
    AssuranceElement := TFhirEnum.Create(SYSTEMS_TFhirIdentityAssuranceLevelEnum[value], CODES_TFhirIdentityAssuranceLevelEnum[value]);
end;

function TFhirPersonLink.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FTarget.sizeInBytes(magic));
  inc(result, FAssurance.sizeInBytes(magic));
end;

{ TFhirPersonLinkListEnumerator }

Constructor TFhirPersonLinkListEnumerator.Create(list : TFhirPersonLinkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPersonLinkListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPersonLinkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPersonLinkListEnumerator.GetCurrent : TFhirPersonLink;
begin
  Result := FList[FIndex];
end;

function TFhirPersonLinkListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPersonLinkList }
function TFhirPersonLinkList.AddItem(value: TFhirPersonLink): TFhirPersonLink;
begin
  add(value);
  result := value;
end;

function TFhirPersonLinkList.Append: TFhirPersonLink;
begin
  result := TFhirPersonLink.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPersonLinkList.ClearItems;
begin
  Clear;
end;

function TFhirPersonLinkList.GetEnumerator : TFhirPersonLinkListEnumerator;
begin
  result := TFhirPersonLinkListEnumerator.Create(self.link);
end;

function TFhirPersonLinkList.Clone: TFhirPersonLinkList;
begin
  result := TFhirPersonLinkList(inherited Clone);
end;

function TFhirPersonLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPersonLinkList.GetItemN(index: Integer): TFhirPersonLink;
begin
  result := TFhirPersonLink(ObjectByIndex[index]);
end;

function TFhirPersonLinkList.ItemClass: TFslObjectClass;
begin
  result := TFhirPersonLink;
end;
function TFhirPersonLinkList.IndexOf(value: TFhirPersonLink): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPersonLinkList.Insert(index: Integer): TFhirPersonLink;
begin
  result := TFhirPersonLink.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPersonLinkList.InsertItem(index: Integer; value: TFhirPersonLink);
begin
  assert(value is TFhirPersonLink);
  Inherited Insert(index, value);
end;

function TFhirPersonLinkList.Item(index: Integer): TFhirPersonLink;
begin
  result := TFhirPersonLink(ObjectByIndex[index]);
end;

function TFhirPersonLinkList.Link: TFhirPersonLinkList;
begin
  result := TFhirPersonLinkList(inherited Link);
end;

procedure TFhirPersonLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPersonLinkList.SetItemByIndex(index: Integer; value: TFhirPersonLink);
begin
  assert(value is TFhirPersonLink);
  FhirPersonLinks[index] := value;
end;

procedure TFhirPersonLinkList.SetItemN(index: Integer; value: TFhirPersonLink);
begin
  assert(value is TFhirPersonLink);
  ObjectByIndex[index] := value;
end;

{ TFhirPerson }

constructor TFhirPerson.Create;
begin
  inherited;
end;

destructor TFhirPerson.Destroy;
begin
  FIdentifierList.free;
  FNameList.free;
  FTelecomList.free;
  FGender.free;
  FBirthDate.free;
  FAddressList.free;
  FPhoto.free;
  FManagingOrganization.free;
  FActive.free;
  FLink_List.free;
  inherited;
end;

function TFhirPerson.GetResourceType : TFhirResourceType;
begin
  result := frtPerson;
end;

procedure TFhirPerson.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPerson(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPerson(oSource).FIdentifierList);
  end;
  if (TFhirPerson(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirHumanNameList.Create;
    FNameList.Assign(TFhirPerson(oSource).FNameList);
  end;
  if (TFhirPerson(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirPerson(oSource).FTelecomList);
  end;
  FGender := TFhirPerson(oSource).FGender.Link;
  birthDateElement := TFhirPerson(oSource).birthDateElement.Clone;
  if (TFhirPerson(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirPerson(oSource).FAddressList);
  end;
  photo := TFhirPerson(oSource).photo.Clone;
  managingOrganization := TFhirPerson(oSource).managingOrganization.Clone;
  activeElement := TFhirPerson(oSource).activeElement.Clone;
  if (TFhirPerson(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirPersonLinkList.Create;
    FLink_List.Assign(TFhirPerson(oSource).FLink_List);
  end;
end;

procedure TFhirPerson.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'birthDate') Then
     list.add(self.link, 'birthDate', FBirthDate.Link);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'photo') Then
     list.add(self.link, 'photo', FPhoto.Link);
  if (child_name = 'managingOrganization') Then
     list.add(self.link, 'managingOrganization', FManagingOrganization.Link);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
end;

procedure TFhirPerson.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'name', 'HumanName', true, TFhirHumanName, FNameList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'gender', 'code', false, TFHIREnum, FGender.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'birthDate', 'date', false, TFhirDate, FBirthDate.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'photo', 'Attachment', false, TFhirAttachment, FPhoto.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'managingOrganization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FManagingOrganization.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'link', '', true, TFhirPersonLink, FLink_List.Link)){3};
end;

function TFhirPerson.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirHumanName){2a};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue);
    result := propValue
  end
  else if (propName = 'birthDate') then
  begin
    BirthDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress){2a};
    result := propValue;
  end
  else if (propName = 'photo') then
  begin
    Photo := propValue as TFhirAttachment{4b};
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirPersonLink){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirPerson.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirHumanName){2a}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress){2a}
  else if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirPersonLink){2a}
  else inherited;
end;

function TFhirPerson.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'name') then result := NameList.new(){2}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else if (propName = 'birthDate') then result := TFhirDate.Create() {5b}
  else if (propName = 'address') then result := AddressList.new(){2}
  else if (propName = 'photo') then result := TFhirAttachment.Create(){4b}
  else if (propName = 'managingOrganization') then result := TFhirReference{TFhirOrganization}.Create(){4b}
  else if (propName = 'active') then result := TFhirBoolean.Create() {5b}
  else if (propName = 'link') then result := Link_List.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPerson.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'birthDate') then result := 'date'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'photo') then result := 'Attachment'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'link') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPerson.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'name') then deletePropertyValue('name', NameList, value) {2}
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'birthDate') then BirthDateElement := nil
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value) {2}
  else if (propName = 'photo') then PhotoElement := nil
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := nil
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPerson.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new) {2}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new){4}
  else if (propName = 'birthDate') then BirthDateElement := asDate(new){5b}
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new) {2}
  else if (propName = 'photo') then PhotoElement := new as TFhirAttachment{4}
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'active') then ActiveElement := asBoolean(new){5b}
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPerson.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'name') then NameList.move(source, destination){2a}
  else if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else if (propName = 'address') then AddressList.move(source, destination){2a}
  else if (propName = 'link') then Link_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPerson.fhirType : string;
begin
  result := 'Person';
end;

function TFhirPerson.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FnameList) and isEmptyProp(FtelecomList) and isEmptyProp(FGender) and isEmptyProp(FBirthDate) and isEmptyProp(FaddressList) and isEmptyProp(FPhoto) and isEmptyProp(FManagingOrganization) and isEmptyProp(FActive) and isEmptyProp(Flink_List);
end;

function TFhirPerson.equals(other : TObject) : boolean; 
var
  o : TFhirPerson;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPerson)) then
    result := false
  else
  begin
    o := TFhirPerson(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(nameList, o.nameList, true) and 
      compareDeep(telecomList, o.telecomList, true) and compareDeep(genderElement, o.genderElement, true) and 
      compareDeep(birthDateElement, o.birthDateElement, true) and compareDeep(addressList, o.addressList, true) and 
      compareDeep(photoElement, o.photoElement, true) and compareDeep(managingOrganizationElement, o.managingOrganizationElement, true) and 
      compareDeep(activeElement, o.activeElement, true) and compareDeep(link_List, o.link_List, true);
  end;
end;

function TFhirPerson.Link : TFhirPerson;
begin
  result := TFhirPerson(inherited Link);
end;

function TFhirPerson.Clone : TFhirPerson;
begin
  result := TFhirPerson(inherited Clone);
end;

procedure TFhirPerson.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('name');
  fields.add('telecom');
  fields.add('gender');
  fields.add('birthDate');
  fields.add('address');
  fields.add('photo');
  fields.add('managingOrganization');
  fields.add('active');
  fields.add('link');
end;

{ TFhirPerson }

Function TFhirPerson.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirPerson.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirPerson.GetNameList : TFhirHumanNameList;
begin
  if FNameList = nil then
    FNameList := TFhirHumanNameList.Create;
  result := FNameList;
end;

Function TFhirPerson.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

Function TFhirPerson.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirPerson.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

Procedure TFhirPerson.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

Function TFhirPerson.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

Procedure TFhirPerson.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.Create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

Procedure TFhirPerson.SetBirthDate(value : TFhirDate);
begin
  FBirthDate.free;
  FBirthDate := value;
end;

Function TFhirPerson.GetBirthDateST : TFslDateTime;
begin
  if FBirthDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FBirthDate.value;
end;

Procedure TFhirPerson.SetBirthDateST(value : TFslDateTime);
begin
  if FBirthDate = nil then
    FBirthDate := TFhirDate.Create;
  FBirthDate.value := value
end;

Function TFhirPerson.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

Function TFhirPerson.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

Procedure TFhirPerson.SetPhoto(value : TFhirAttachment);
begin
  FPhoto.free;
  FPhoto := value;
end;

Procedure TFhirPerson.SetManagingOrganization(value : TFhirReference{TFhirOrganization});
begin
  FManagingOrganization.free;
  FManagingOrganization := value;
end;

Procedure TFhirPerson.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

Function TFhirPerson.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

Procedure TFhirPerson.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.Create;
  FActive.value := value
end;

Function TFhirPerson.GetLink_List : TFhirPersonLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirPersonLinkList.Create;
  result := FLink_List;
end;

Function TFhirPerson.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

function TFhirPerson.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FidentifierList.sizeInBytes(magic));
  inc(result, FnameList.sizeInBytes(magic));
  inc(result, FtelecomList.sizeInBytes(magic));
  inc(result, FGender.sizeInBytes(magic));
  inc(result, FBirthDate.sizeInBytes(magic));
  inc(result, FaddressList.sizeInBytes(magic));
  inc(result, FPhoto.sizeInBytes(magic));
  inc(result, FManagingOrganization.sizeInBytes(magic));
  inc(result, FActive.sizeInBytes(magic));
  inc(result, Flink_List.sizeInBytes(magic));
end;

{ TFhirPersonListEnumerator }

Constructor TFhirPersonListEnumerator.Create(list : TFhirPersonList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPersonListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPersonListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPersonListEnumerator.GetCurrent : TFhirPerson;
begin
  Result := FList[FIndex];
end;

function TFhirPersonListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPersonList }
function TFhirPersonList.AddItem(value: TFhirPerson): TFhirPerson;
begin
  add(value);
  result := value;
end;

function TFhirPersonList.Append: TFhirPerson;
begin
  result := TFhirPerson.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPersonList.ClearItems;
begin
  Clear;
end;

function TFhirPersonList.GetEnumerator : TFhirPersonListEnumerator;
begin
  result := TFhirPersonListEnumerator.Create(self.link);
end;

function TFhirPersonList.Clone: TFhirPersonList;
begin
  result := TFhirPersonList(inherited Clone);
end;

function TFhirPersonList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPersonList.GetItemN(index: Integer): TFhirPerson;
begin
  result := TFhirPerson(ObjectByIndex[index]);
end;

function TFhirPersonList.ItemClass: TFslObjectClass;
begin
  result := TFhirPerson;
end;
function TFhirPersonList.IndexOf(value: TFhirPerson): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPersonList.Insert(index: Integer): TFhirPerson;
begin
  result := TFhirPerson.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPersonList.InsertItem(index: Integer; value: TFhirPerson);
begin
  assert(value is TFhirPerson);
  Inherited Insert(index, value);
end;

function TFhirPersonList.Item(index: Integer): TFhirPerson;
begin
  result := TFhirPerson(ObjectByIndex[index]);
end;

function TFhirPersonList.Link: TFhirPersonList;
begin
  result := TFhirPersonList(inherited Link);
end;

procedure TFhirPersonList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPersonList.SetItemByIndex(index: Integer; value: TFhirPerson);
begin
  assert(value is TFhirPerson);
  FhirPeople[index] := value;
end;

procedure TFhirPersonList.SetItemN(index: Integer; value: TFhirPerson);
begin
  assert(value is TFhirPerson);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PERSON}

{$IFDEF FHIR_PRACTITIONER}

{ TFhirPractitionerQualification }

constructor TFhirPractitionerQualification.Create;
begin
  inherited;
end;

destructor TFhirPractitionerQualification.Destroy;
begin
  FIdentifierList.free;
  FCode.free;
  FPeriod.free;
  FIssuer.free;
  inherited;
end;

procedure TFhirPractitionerQualification.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPractitionerQualification(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPractitionerQualification(oSource).FIdentifierList);
  end;
  code := TFhirPractitionerQualification(oSource).code.Clone;
  period := TFhirPractitionerQualification(oSource).period.Clone;
  issuer := TFhirPractitionerQualification(oSource).issuer.Clone;
end;

procedure TFhirPractitionerQualification.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'issuer') Then
     list.add(self.link, 'issuer', FIssuer.Link);
end;

procedure TFhirPractitionerQualification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'issuer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FIssuer.Link));{2}
end;

function TFhirPractitionerQualification.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'issuer') then
  begin
    Issuer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPractitionerQualification.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirPractitionerQualification.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'code') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.Create(){4b}
  else if (propName = 'issuer') then result := TFhirReference{TFhirOrganization}.Create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPractitionerQualification.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'issuer') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPractitionerQualification.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'issuer') then IssuerElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPractitionerQualification.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'issuer') then IssuerElement := new as TFhirReference{TFhirOrganization}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPractitionerQualification.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPractitionerQualification.fhirType : string;
begin
  result := 'qualification';
end;

function TFhirPractitionerQualification.Link : TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(inherited Link);
end;

function TFhirPractitionerQualification.Clone : TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(inherited Clone);
end;

function TFhirPractitionerQualification.equals(other : TObject) : boolean; 
var
  o : TFhirPractitionerQualification;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPractitionerQualification)) then
    result := false
  else
  begin
    o := TFhirPractitionerQualification(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(issuerElement, o.issuerElement, true);
  end;
end;

function TFhirPractitionerQualification.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCode) and isEmptyProp(FPeriod) and isEmptyProp(FIssuer);
end;

procedure TFhirPractitionerQualification.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('period');
  fields.add('issuer');
end;

{ TFhirPractitionerQualification }

Function TFhirPractitionerQualification.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirPractitionerQualification.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirPractitionerQualification.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirPractitionerQualification.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirPractitionerQualification.SetIssuer(value : TFhirReference{TFhirOrganization});
begin
  FIssuer.free;
  FIssuer := value;
end;

function TFhirPractitionerQualification.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FidentifierList.sizeInBytes(magic));
  inc(result, FCode.sizeInBytes(magic));
  inc(result, FPeriod.sizeInBytes(magic));
  inc(result, FIssuer.sizeInBytes(magic));
end;

{ TFhirPractitionerQualificationListEnumerator }

Constructor TFhirPractitionerQualificationListEnumerator.Create(list : TFhirPractitionerQualificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPractitionerQualificationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPractitionerQualificationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPractitionerQualificationListEnumerator.GetCurrent : TFhirPractitionerQualification;
begin
  Result := FList[FIndex];
end;

function TFhirPractitionerQualificationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPractitionerQualificationList }
function TFhirPractitionerQualificationList.AddItem(value: TFhirPractitionerQualification): TFhirPractitionerQualification;
begin
  add(value);
  result := value;
end;

function TFhirPractitionerQualificationList.Append: TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerQualificationList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerQualificationList.GetEnumerator : TFhirPractitionerQualificationListEnumerator;
begin
  result := TFhirPractitionerQualificationListEnumerator.Create(self.link);
end;

function TFhirPractitionerQualificationList.Clone: TFhirPractitionerQualificationList;
begin
  result := TFhirPractitionerQualificationList(inherited Clone);
end;

function TFhirPractitionerQualificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerQualificationList.GetItemN(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(ObjectByIndex[index]);
end;

function TFhirPractitionerQualificationList.ItemClass: TFslObjectClass;
begin
  result := TFhirPractitionerQualification;
end;
function TFhirPractitionerQualificationList.IndexOf(value: TFhirPractitionerQualification): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPractitionerQualificationList.Insert(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerQualificationList.InsertItem(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  Inherited Insert(index, value);
end;

function TFhirPractitionerQualificationList.Item(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(ObjectByIndex[index]);
end;

function TFhirPractitionerQualificationList.Link: TFhirPractitionerQualificationList;
begin
  result := TFhirPractitionerQualificationList(inherited Link);
end;

procedure TFhirPractitionerQualificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerQualificationList.SetItemByIndex(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  FhirPractitionerQualifications[index] := value;
end;

procedure TFhirPractitionerQualificationList.SetItemN(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  ObjectByIndex[index] := value;
end;

{ TFhirPractitioner }

constructor TFhirPractitioner.Create;
begin
  inherited;
end;

destructor TFhirPractitioner.Destroy;
begin
  FIdentifierList.free;
  FActive.free;
  FNameList.free;
  FTelecomList.free;
  FAddressList.free;
  FGender.free;
  FBirthDate.free;
  FPhotoList.free;
  FQualificationList.free;
  FCommunicationList.free;
  inherited;
end;

function TFhirPractitioner.GetResourceType : TFhirResourceType;
begin
  result := frtPractitioner;
end;

procedure TFhirPractitioner.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPractitioner(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPractitioner(oSource).FIdentifierList);
  end;
  activeElement := TFhirPractitioner(oSource).activeElement.Clone;
  if (TFhirPractitioner(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirHumanNameList.Create;
    FNameList.Assign(TFhirPractitioner(oSource).FNameList);
  end;
  if (TFhirPractitioner(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirPractitioner(oSource).FTelecomList);
  end;
  if (TFhirPractitioner(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirPractitioner(oSource).FAddressList);
  end;
  FGender := TFhirPractitioner(oSource).FGender.Link;
  birthDateElement := TFhirPractitioner(oSource).birthDateElement.Clone;
  if (TFhirPractitioner(oSource).FPhotoList = nil) then
  begin
    FPhotoList.free;
    FPhotoList := nil;
  end
  else
  begin
    if FPhotoList = nil then
      FPhotoList := TFhirAttachmentList.Create;
    FPhotoList.Assign(TFhirPractitioner(oSource).FPhotoList);
  end;
  if (TFhirPractitioner(oSource).FQualificationList = nil) then
  begin
    FQualificationList.free;
    FQualificationList := nil;
  end
  else
  begin
    if FQualificationList = nil then
      FQualificationList := TFhirPractitionerQualificationList.Create;
    FQualificationList.Assign(TFhirPractitioner(oSource).FQualificationList);
  end;
  if (TFhirPractitioner(oSource).FCommunicationList = nil) then
  begin
    FCommunicationList.free;
    FCommunicationList := nil;
  end
  else
  begin
    if FCommunicationList = nil then
      FCommunicationList := TFhirCodeableConceptList.Create;
    FCommunicationList.Assign(TFhirPractitioner(oSource).FCommunicationList);
  end;
end;

procedure TFhirPractitioner.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'birthDate') Then
     list.add(self.link, 'birthDate', FBirthDate.Link);
  if (child_name = 'photo') Then
    list.addAll(self, 'photo', FPhotoList);
  if (child_name = 'qualification') Then
    list.addAll(self, 'qualification', FQualificationList);
  if (child_name = 'communication') Then
    list.addAll(self, 'communication', FCommunicationList);
end;

procedure TFhirPractitioner.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'name', 'HumanName', true, TFhirHumanName, FNameList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'gender', 'code', false, TFHIREnum, FGender.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'birthDate', 'date', false, TFhirDate, FBirthDate.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'photo', 'Attachment', true, TFhirAttachment, FPhotoList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'qualification', '', true, TFhirPractitionerQualification, FQualificationList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'communication', 'CodeableConcept', true, TFhirCodeableConcept, FCommunicationList.Link)){3};
end;

function TFhirPractitioner.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirHumanName){2a};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress){2a};
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue);
    result := propValue
  end
  else if (propName = 'birthDate') then
  begin
    BirthDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'photo') then
  begin
    PhotoList.add(propValue as TFhirAttachment){2a};
    result := propValue;
  end
  else if (propName = 'qualification') then
  begin
    QualificationList.add(propValue as TFhirPractitionerQualification){2a};
    result := propValue;
  end
  else if (propName = 'communication') then
  begin
    CommunicationList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirPractitioner.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirHumanName){2a}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress){2a}
  else if (propName = 'photo') then PhotoList.insertItem(index, propValue as TFhirAttachment){2a}
  else if (propName = 'qualification') then QualificationList.insertItem(index, propValue as TFhirPractitionerQualification){2a}
  else if (propName = 'communication') then CommunicationList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirPractitioner.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'active') then result := TFhirBoolean.Create() {5b}
  else if (propName = 'name') then result := NameList.new(){2}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else if (propName = 'address') then result := AddressList.new(){2}
  else if (propName = 'birthDate') then result := TFhirDate.Create() {5b}
  else if (propName = 'photo') then result := PhotoList.new(){2}
  else if (propName = 'qualification') then result := QualificationList.new(){2}
  else if (propName = 'communication') then result := CommunicationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPractitioner.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'birthDate') then result := 'date'
  else if (propName = 'photo') then result := 'Attachment'
  else if (propName = 'qualification') then result := ''
  else if (propName = 'communication') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPractitioner.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'name') then deletePropertyValue('name', NameList, value) {2}
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value) {2}
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'birthDate') then BirthDateElement := nil
  else if (propName = 'photo') then deletePropertyValue('photo', PhotoList, value) {2}
  else if (propName = 'qualification') then deletePropertyValue('qualification', QualificationList, value) {2}
  else if (propName = 'communication') then deletePropertyValue('communication', CommunicationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPractitioner.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'active') then ActiveElement := asBoolean(new){5b}
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new) {2}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new) {2}
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new){4}
  else if (propName = 'birthDate') then BirthDateElement := asDate(new){5b}
  else if (propName = 'photo') then replacePropertyValue('photo', PhotoList, existing, new) {2}
  else if (propName = 'qualification') then replacePropertyValue('qualification', QualificationList, existing, new) {2}
  else if (propName = 'communication') then replacePropertyValue('communication', CommunicationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPractitioner.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'name') then NameList.move(source, destination){2a}
  else if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else if (propName = 'address') then AddressList.move(source, destination){2a}
  else if (propName = 'photo') then PhotoList.move(source, destination){2a}
  else if (propName = 'qualification') then QualificationList.move(source, destination){2a}
  else if (propName = 'communication') then CommunicationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPractitioner.fhirType : string;
begin
  result := 'Practitioner';
end;

function TFhirPractitioner.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FnameList) and isEmptyProp(FtelecomList) and isEmptyProp(FaddressList) and isEmptyProp(FGender) and isEmptyProp(FBirthDate) and isEmptyProp(FphotoList) and isEmptyProp(FqualificationList) and isEmptyProp(FcommunicationList);
end;

function TFhirPractitioner.equals(other : TObject) : boolean; 
var
  o : TFhirPractitioner;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPractitioner)) then
    result := false
  else
  begin
    o := TFhirPractitioner(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(nameList, o.nameList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(addressList, o.addressList, true) and compareDeep(genderElement, o.genderElement, true) and 
      compareDeep(birthDateElement, o.birthDateElement, true) and compareDeep(photoList, o.photoList, true) and 
      compareDeep(qualificationList, o.qualificationList, true) and compareDeep(communicationList, o.communicationList, true);
  end;
end;

function TFhirPractitioner.Link : TFhirPractitioner;
begin
  result := TFhirPractitioner(inherited Link);
end;

function TFhirPractitioner.Clone : TFhirPractitioner;
begin
  result := TFhirPractitioner(inherited Clone);
end;

procedure TFhirPractitioner.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('name');
  fields.add('telecom');
  fields.add('address');
  fields.add('gender');
  fields.add('birthDate');
  fields.add('photo');
  fields.add('qualification');
  fields.add('communication');
end;

{ TFhirPractitioner }

Function TFhirPractitioner.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirPractitioner.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirPractitioner.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

Function TFhirPractitioner.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

Procedure TFhirPractitioner.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.Create;
  FActive.value := value
end;

Function TFhirPractitioner.GetNameList : TFhirHumanNameList;
begin
  if FNameList = nil then
    FNameList := TFhirHumanNameList.Create;
  result := FNameList;
end;

Function TFhirPractitioner.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

Function TFhirPractitioner.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirPractitioner.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

Function TFhirPractitioner.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

Function TFhirPractitioner.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

Procedure TFhirPractitioner.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

Function TFhirPractitioner.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

Procedure TFhirPractitioner.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.Create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

Procedure TFhirPractitioner.SetBirthDate(value : TFhirDate);
begin
  FBirthDate.free;
  FBirthDate := value;
end;

Function TFhirPractitioner.GetBirthDateST : TFslDateTime;
begin
  if FBirthDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FBirthDate.value;
end;

Procedure TFhirPractitioner.SetBirthDateST(value : TFslDateTime);
begin
  if FBirthDate = nil then
    FBirthDate := TFhirDate.Create;
  FBirthDate.value := value
end;

Function TFhirPractitioner.GetPhotoList : TFhirAttachmentList;
begin
  if FPhotoList = nil then
    FPhotoList := TFhirAttachmentList.Create;
  result := FPhotoList;
end;

Function TFhirPractitioner.GetHasPhotoList : boolean;
begin
  result := (FPhotoList <> nil) and (FPhotoList.count > 0);
end;

Function TFhirPractitioner.GetQualificationList : TFhirPractitionerQualificationList;
begin
  if FQualificationList = nil then
    FQualificationList := TFhirPractitionerQualificationList.Create;
  result := FQualificationList;
end;

Function TFhirPractitioner.GetHasQualificationList : boolean;
begin
  result := (FQualificationList <> nil) and (FQualificationList.count > 0);
end;

Function TFhirPractitioner.GetCommunicationList : TFhirCodeableConceptList;
begin
  if FCommunicationList = nil then
    FCommunicationList := TFhirCodeableConceptList.Create;
  result := FCommunicationList;
end;

Function TFhirPractitioner.GetHasCommunicationList : boolean;
begin
  result := (FCommunicationList <> nil) and (FCommunicationList.count > 0);
end;

function TFhirPractitioner.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FidentifierList.sizeInBytes(magic));
  inc(result, FActive.sizeInBytes(magic));
  inc(result, FnameList.sizeInBytes(magic));
  inc(result, FtelecomList.sizeInBytes(magic));
  inc(result, FaddressList.sizeInBytes(magic));
  inc(result, FGender.sizeInBytes(magic));
  inc(result, FBirthDate.sizeInBytes(magic));
  inc(result, FphotoList.sizeInBytes(magic));
  inc(result, FqualificationList.sizeInBytes(magic));
  inc(result, FcommunicationList.sizeInBytes(magic));
end;

{ TFhirPractitionerListEnumerator }

Constructor TFhirPractitionerListEnumerator.Create(list : TFhirPractitionerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPractitionerListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPractitionerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPractitionerListEnumerator.GetCurrent : TFhirPractitioner;
begin
  Result := FList[FIndex];
end;

function TFhirPractitionerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPractitionerList }
function TFhirPractitionerList.AddItem(value: TFhirPractitioner): TFhirPractitioner;
begin
  add(value);
  result := value;
end;

function TFhirPractitionerList.Append: TFhirPractitioner;
begin
  result := TFhirPractitioner.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerList.GetEnumerator : TFhirPractitionerListEnumerator;
begin
  result := TFhirPractitionerListEnumerator.Create(self.link);
end;

function TFhirPractitionerList.Clone: TFhirPractitionerList;
begin
  result := TFhirPractitionerList(inherited Clone);
end;

function TFhirPractitionerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerList.GetItemN(index: Integer): TFhirPractitioner;
begin
  result := TFhirPractitioner(ObjectByIndex[index]);
end;

function TFhirPractitionerList.ItemClass: TFslObjectClass;
begin
  result := TFhirPractitioner;
end;
function TFhirPractitionerList.IndexOf(value: TFhirPractitioner): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPractitionerList.Insert(index: Integer): TFhirPractitioner;
begin
  result := TFhirPractitioner.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerList.InsertItem(index: Integer; value: TFhirPractitioner);
begin
  assert(value is TFhirPractitioner);
  Inherited Insert(index, value);
end;

function TFhirPractitionerList.Item(index: Integer): TFhirPractitioner;
begin
  result := TFhirPractitioner(ObjectByIndex[index]);
end;

function TFhirPractitionerList.Link: TFhirPractitionerList;
begin
  result := TFhirPractitionerList(inherited Link);
end;

procedure TFhirPractitionerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerList.SetItemByIndex(index: Integer; value: TFhirPractitioner);
begin
  assert(value is TFhirPractitioner);
  FhirPractitioners[index] := value;
end;

procedure TFhirPractitionerList.SetItemN(index: Integer; value: TFhirPractitioner);
begin
  assert(value is TFhirPractitioner);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PRACTITIONER}

{$IFDEF FHIR_PRACTITIONERROLE}

{ TFhirPractitionerRoleAvailableTime }

constructor TFhirPractitionerRoleAvailableTime.Create;
begin
  inherited;
end;

destructor TFhirPractitionerRoleAvailableTime.Destroy;
begin
  FDaysOfWeek.free;
  FAllDay.free;
  FAvailableStartTime.free;
  FAvailableEndTime.free;
  inherited;
end;

procedure TFhirPractitionerRoleAvailableTime.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPractitionerRoleAvailableTime(oSource).FDaysOfWeek = nil) then
  begin
    FDaysOfWeek.free;
    FDaysOfWeek := nil;
  end
  else
  begin
    FDaysOfWeek := TFHIREnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
    FDaysOfWeek.Assign(TFhirPractitionerRoleAvailableTime(oSource).FDaysOfWeek);
  end;
  allDayElement := TFhirPractitionerRoleAvailableTime(oSource).allDayElement.Clone;
  availableStartTimeElement := TFhirPractitionerRoleAvailableTime(oSource).availableStartTimeElement.Clone;
  availableEndTimeElement := TFhirPractitionerRoleAvailableTime(oSource).availableEndTimeElement.Clone;
end;

procedure TFhirPractitionerRoleAvailableTime.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'daysOfWeek') Then
     list.addAll(self, 'daysOfWeek', FDaysOfWeek);
  if (child_name = 'allDay') Then
     list.add(self.link, 'allDay', FAllDay.Link);
  if (child_name = 'availableStartTime') Then
     list.add(self.link, 'availableStartTime', FAvailableStartTime.Link);
  if (child_name = 'availableEndTime') Then
     list.add(self.link, 'availableEndTime', FAvailableEndTime.Link);
end;

procedure TFhirPractitionerRoleAvailableTime.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'daysOfWeek', 'code', true, TFHIREnum, FDaysOfWeek.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'allDay', 'boolean', false, TFhirBoolean, FAllDay.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'availableStartTime', 'time', false, TFhirTime, FAvailableStartTime.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'availableEndTime', 'time', false, TFhirTime, FAvailableEndTime.Link));{2}
end;

function TFhirPractitionerRoleAvailableTime.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'daysOfWeek') then
  begin
    DaysOfWeekList.add(asEnum(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'allDay') then
  begin
    AllDayElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'availableStartTime') then
  begin
    AvailableStartTimeElement := asTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'availableEndTime') then
  begin
    AvailableEndTimeElement := asTime(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPractitionerRoleAvailableTime.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'daysOfWeek') then FDaysOfWeek.insertItem(index, asEnum(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum, propValue)) {1}
  else inherited;
end;

function TFhirPractitionerRoleAvailableTime.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'allDay') then result := TFhirBoolean.Create() {5b}
  else if (propName = 'availableStartTime') then result := TFhirTime.Create() {5b}
  else if (propName = 'availableEndTime') then result := TFhirTime.Create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPractitionerRoleAvailableTime.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'daysOfWeek') then result := 'code'
  else if (propName = 'allDay') then result := 'boolean'
  else if (propName = 'availableStartTime') then result := 'time'
  else if (propName = 'availableEndTime') then result := 'time'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPractitionerRoleAvailableTime.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'allDay') then AllDayElement := nil
  else if (propName = 'availableStartTime') then AvailableStartTimeElement := nil
  else if (propName = 'availableEndTime') then AvailableEndTimeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPractitionerRoleAvailableTime.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'allDay') then AllDayElement := asBoolean(new){5b}
  else if (propName = 'availableStartTime') then AvailableStartTimeElement := asTime(new){5b}
  else if (propName = 'availableEndTime') then AvailableEndTimeElement := asTime(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPractitionerRoleAvailableTime.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'daysOfWeek') then FDaysOfWeek.move(source, destination) {1}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPractitionerRoleAvailableTime.fhirType : string;
begin
  result := 'availableTime';
end;

function TFhirPractitionerRoleAvailableTime.Link : TFhirPractitionerRoleAvailableTime;
begin
  result := TFhirPractitionerRoleAvailableTime(inherited Link);
end;

function TFhirPractitionerRoleAvailableTime.Clone : TFhirPractitionerRoleAvailableTime;
begin
  result := TFhirPractitionerRoleAvailableTime(inherited Clone);
end;

function TFhirPractitionerRoleAvailableTime.equals(other : TObject) : boolean; 
var
  o : TFhirPractitionerRoleAvailableTime;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPractitionerRoleAvailableTime)) then
    result := false
  else
  begin
    o := TFhirPractitionerRoleAvailableTime(other);
    result := compareDeep(daysOfWeekList, o.daysOfWeekList, true) and compareDeep(allDayElement, o.allDayElement, true) and 
      compareDeep(availableStartTimeElement, o.availableStartTimeElement, true) and 
      compareDeep(availableEndTimeElement, o.availableEndTimeElement, true);
  end;
end;

function TFhirPractitionerRoleAvailableTime.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDaysOfWeek) and isEmptyProp(FAllDay) and isEmptyProp(FAvailableStartTime) and isEmptyProp(FAvailableEndTime);
end;

procedure TFhirPractitionerRoleAvailableTime.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('daysOfWeek');
  fields.add('allDay');
  fields.add('availableStartTime');
  fields.add('availableEndTime');
end;

{ TFhirPractitionerRoleAvailableTime }

Function TFhirPractitionerRoleAvailableTime.GetDaysOfWeek : TFhirEnumList;
begin
  if FDaysOfWeek = nil then
    FDaysOfWeek := TFHIREnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
  result := FDaysOfWeek;
end;

Function TFhirPractitionerRoleAvailableTime.GetHasDaysOfWeek : boolean;
begin
  result := (FDaysOfWeek <> nil) and (FDaysOfWeek.count > 0);
end;

Function TFhirPractitionerRoleAvailableTime.GetDaysOfWeekST : TFhirDaysOfWeekEnumList;
  var i : integer;
begin
  result := [];
  if FdaysOfWeek <> nil then
    for i := 0 to FdaysOfWeek.count - 1 do
      result := result + [TFhirDaysOfWeekEnum(StringArrayIndexOfSensitive(CODES_TFhirDaysOfWeekEnum, FdaysOfWeek[i].value))];
end;

Procedure TFhirPractitionerRoleAvailableTime.SetDaysOfWeekST(value : TFhirDaysOfWeekEnumList);
var a : TFhirDaysOfWeekEnum;
begin
  if FdaysOfWeek = nil then
    FdaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
  FdaysOfWeek.clear;
  for a := low(TFhirDaysOfWeekEnum) to high(TFhirDaysOfWeekEnum) do
    if a in value then
      begin
         if FdaysOfWeek = nil then
           FdaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
         FdaysOfWeek.add(TFhirEnum.Create(SYSTEMS_TFhirDaysOfWeekEnum[a], CODES_TFhirDaysOfWeekEnum[a]));
      end;
end;

Procedure TFhirPractitionerRoleAvailableTime.SetAllDay(value : TFhirBoolean);
begin
  FAllDay.free;
  FAllDay := value;
end;

Function TFhirPractitionerRoleAvailableTime.GetAllDayST : Boolean;
begin
  if FAllDay = nil then
    result := false
  else
    result := FAllDay.value;
end;

Procedure TFhirPractitionerRoleAvailableTime.SetAllDayST(value : Boolean);
begin
  if FAllDay = nil then
    FAllDay := TFhirBoolean.Create;
  FAllDay.value := value
end;

Procedure TFhirPractitionerRoleAvailableTime.SetAvailableStartTime(value : TFhirTime);
begin
  FAvailableStartTime.free;
  FAvailableStartTime := value;
end;

Function TFhirPractitionerRoleAvailableTime.GetAvailableStartTimeST : String;
begin
  if FAvailableStartTime = nil then
    result := ''
  else
    result := FAvailableStartTime.value;
end;

Procedure TFhirPractitionerRoleAvailableTime.SetAvailableStartTimeST(value : String);
begin
  if value <> '' then
  begin
    if FAvailableStartTime = nil then
      FAvailableStartTime := TFhirTime.Create;
    FAvailableStartTime.value := value
  end
  else if FAvailableStartTime <> nil then
    FAvailableStartTime.value := '';
end;

Procedure TFhirPractitionerRoleAvailableTime.SetAvailableEndTime(value : TFhirTime);
begin
  FAvailableEndTime.free;
  FAvailableEndTime := value;
end;

Function TFhirPractitionerRoleAvailableTime.GetAvailableEndTimeST : String;
begin
  if FAvailableEndTime = nil then
    result := ''
  else
    result := FAvailableEndTime.value;
end;

Procedure TFhirPractitionerRoleAvailableTime.SetAvailableEndTimeST(value : String);
begin
  if value <> '' then
  begin
    if FAvailableEndTime = nil then
      FAvailableEndTime := TFhirTime.Create;
    FAvailableEndTime.value := value
  end
  else if FAvailableEndTime <> nil then
    FAvailableEndTime.value := '';
end;

function TFhirPractitionerRoleAvailableTime.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FDaysOfWeek.sizeInBytes(magic));
  inc(result, FAllDay.sizeInBytes(magic));
  inc(result, FAvailableStartTime.sizeInBytes(magic));
  inc(result, FAvailableEndTime.sizeInBytes(magic));
end;

{ TFhirPractitionerRoleAvailableTimeListEnumerator }

Constructor TFhirPractitionerRoleAvailableTimeListEnumerator.Create(list : TFhirPractitionerRoleAvailableTimeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPractitionerRoleAvailableTimeListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPractitionerRoleAvailableTimeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPractitionerRoleAvailableTimeListEnumerator.GetCurrent : TFhirPractitionerRoleAvailableTime;
begin
  Result := FList[FIndex];
end;

function TFhirPractitionerRoleAvailableTimeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPractitionerRoleAvailableTimeList }
function TFhirPractitionerRoleAvailableTimeList.AddItem(value: TFhirPractitionerRoleAvailableTime): TFhirPractitionerRoleAvailableTime;
begin
  add(value);
  result := value;
end;

function TFhirPractitionerRoleAvailableTimeList.Append: TFhirPractitionerRoleAvailableTime;
begin
  result := TFhirPractitionerRoleAvailableTime.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerRoleAvailableTimeList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerRoleAvailableTimeList.GetEnumerator : TFhirPractitionerRoleAvailableTimeListEnumerator;
begin
  result := TFhirPractitionerRoleAvailableTimeListEnumerator.Create(self.link);
end;

function TFhirPractitionerRoleAvailableTimeList.Clone: TFhirPractitionerRoleAvailableTimeList;
begin
  result := TFhirPractitionerRoleAvailableTimeList(inherited Clone);
end;

function TFhirPractitionerRoleAvailableTimeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerRoleAvailableTimeList.GetItemN(index: Integer): TFhirPractitionerRoleAvailableTime;
begin
  result := TFhirPractitionerRoleAvailableTime(ObjectByIndex[index]);
end;

function TFhirPractitionerRoleAvailableTimeList.ItemClass: TFslObjectClass;
begin
  result := TFhirPractitionerRoleAvailableTime;
end;
function TFhirPractitionerRoleAvailableTimeList.IndexOf(value: TFhirPractitionerRoleAvailableTime): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPractitionerRoleAvailableTimeList.Insert(index: Integer): TFhirPractitionerRoleAvailableTime;
begin
  result := TFhirPractitionerRoleAvailableTime.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerRoleAvailableTimeList.InsertItem(index: Integer; value: TFhirPractitionerRoleAvailableTime);
begin
  assert(value is TFhirPractitionerRoleAvailableTime);
  Inherited Insert(index, value);
end;

function TFhirPractitionerRoleAvailableTimeList.Item(index: Integer): TFhirPractitionerRoleAvailableTime;
begin
  result := TFhirPractitionerRoleAvailableTime(ObjectByIndex[index]);
end;

function TFhirPractitionerRoleAvailableTimeList.Link: TFhirPractitionerRoleAvailableTimeList;
begin
  result := TFhirPractitionerRoleAvailableTimeList(inherited Link);
end;

procedure TFhirPractitionerRoleAvailableTimeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerRoleAvailableTimeList.SetItemByIndex(index: Integer; value: TFhirPractitionerRoleAvailableTime);
begin
  assert(value is TFhirPractitionerRoleAvailableTime);
  FhirPractitionerRoleAvailableTimes[index] := value;
end;

procedure TFhirPractitionerRoleAvailableTimeList.SetItemN(index: Integer; value: TFhirPractitionerRoleAvailableTime);
begin
  assert(value is TFhirPractitionerRoleAvailableTime);
  ObjectByIndex[index] := value;
end;

{ TFhirPractitionerRoleNotAvailable }

constructor TFhirPractitionerRoleNotAvailable.Create;
begin
  inherited;
end;

destructor TFhirPractitionerRoleNotAvailable.Destroy;
begin
  FDescription.free;
  FDuring.free;
  inherited;
end;

procedure TFhirPractitionerRoleNotAvailable.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirPractitionerRoleNotAvailable(oSource).descriptionElement.Clone;
  during := TFhirPractitionerRoleNotAvailable(oSource).during.Clone;
end;

procedure TFhirPractitionerRoleNotAvailable.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'during') Then
     list.add(self.link, 'during', FDuring.Link);
end;

procedure TFhirPractitionerRoleNotAvailable.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'during', 'Period', false, TFhirPeriod, FDuring.Link));{2}
end;

function TFhirPractitionerRoleNotAvailable.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'during') then
  begin
    During := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPractitionerRoleNotAvailable.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPractitionerRoleNotAvailable.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.Create() {5b}
  else if (propName = 'during') then result := TFhirPeriod.Create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPractitionerRoleNotAvailable.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'during') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPractitionerRoleNotAvailable.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'during') then DuringElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPractitionerRoleNotAvailable.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'during') then DuringElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPractitionerRoleNotAvailable.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPractitionerRoleNotAvailable.fhirType : string;
begin
  result := 'notAvailable';
end;

function TFhirPractitionerRoleNotAvailable.Link : TFhirPractitionerRoleNotAvailable;
begin
  result := TFhirPractitionerRoleNotAvailable(inherited Link);
end;

function TFhirPractitionerRoleNotAvailable.Clone : TFhirPractitionerRoleNotAvailable;
begin
  result := TFhirPractitionerRoleNotAvailable(inherited Clone);
end;

function TFhirPractitionerRoleNotAvailable.equals(other : TObject) : boolean; 
var
  o : TFhirPractitionerRoleNotAvailable;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPractitionerRoleNotAvailable)) then
    result := false
  else
  begin
    o := TFhirPractitionerRoleNotAvailable(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(duringElement, o.duringElement, true);
  end;
end;

function TFhirPractitionerRoleNotAvailable.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FDuring);
end;

procedure TFhirPractitionerRoleNotAvailable.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('during');
end;

{ TFhirPractitionerRoleNotAvailable }

Procedure TFhirPractitionerRoleNotAvailable.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirPractitionerRoleNotAvailable.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirPractitionerRoleNotAvailable.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.Create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirPractitionerRoleNotAvailable.SetDuring(value : TFhirPeriod);
begin
  FDuring.free;
  FDuring := value;
end;

function TFhirPractitionerRoleNotAvailable.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FDescription.sizeInBytes(magic));
  inc(result, FDuring.sizeInBytes(magic));
end;

{ TFhirPractitionerRoleNotAvailableListEnumerator }

Constructor TFhirPractitionerRoleNotAvailableListEnumerator.Create(list : TFhirPractitionerRoleNotAvailableList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPractitionerRoleNotAvailableListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPractitionerRoleNotAvailableListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPractitionerRoleNotAvailableListEnumerator.GetCurrent : TFhirPractitionerRoleNotAvailable;
begin
  Result := FList[FIndex];
end;

function TFhirPractitionerRoleNotAvailableListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPractitionerRoleNotAvailableList }
function TFhirPractitionerRoleNotAvailableList.AddItem(value: TFhirPractitionerRoleNotAvailable): TFhirPractitionerRoleNotAvailable;
begin
  add(value);
  result := value;
end;

function TFhirPractitionerRoleNotAvailableList.Append: TFhirPractitionerRoleNotAvailable;
begin
  result := TFhirPractitionerRoleNotAvailable.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerRoleNotAvailableList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerRoleNotAvailableList.GetEnumerator : TFhirPractitionerRoleNotAvailableListEnumerator;
begin
  result := TFhirPractitionerRoleNotAvailableListEnumerator.Create(self.link);
end;

function TFhirPractitionerRoleNotAvailableList.Clone: TFhirPractitionerRoleNotAvailableList;
begin
  result := TFhirPractitionerRoleNotAvailableList(inherited Clone);
end;

function TFhirPractitionerRoleNotAvailableList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerRoleNotAvailableList.GetItemN(index: Integer): TFhirPractitionerRoleNotAvailable;
begin
  result := TFhirPractitionerRoleNotAvailable(ObjectByIndex[index]);
end;

function TFhirPractitionerRoleNotAvailableList.ItemClass: TFslObjectClass;
begin
  result := TFhirPractitionerRoleNotAvailable;
end;
function TFhirPractitionerRoleNotAvailableList.IndexOf(value: TFhirPractitionerRoleNotAvailable): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPractitionerRoleNotAvailableList.Insert(index: Integer): TFhirPractitionerRoleNotAvailable;
begin
  result := TFhirPractitionerRoleNotAvailable.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerRoleNotAvailableList.InsertItem(index: Integer; value: TFhirPractitionerRoleNotAvailable);
begin
  assert(value is TFhirPractitionerRoleNotAvailable);
  Inherited Insert(index, value);
end;

function TFhirPractitionerRoleNotAvailableList.Item(index: Integer): TFhirPractitionerRoleNotAvailable;
begin
  result := TFhirPractitionerRoleNotAvailable(ObjectByIndex[index]);
end;

function TFhirPractitionerRoleNotAvailableList.Link: TFhirPractitionerRoleNotAvailableList;
begin
  result := TFhirPractitionerRoleNotAvailableList(inherited Link);
end;

procedure TFhirPractitionerRoleNotAvailableList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerRoleNotAvailableList.SetItemByIndex(index: Integer; value: TFhirPractitionerRoleNotAvailable);
begin
  assert(value is TFhirPractitionerRoleNotAvailable);
  FhirPractitionerRoleNotAvailables[index] := value;
end;

procedure TFhirPractitionerRoleNotAvailableList.SetItemN(index: Integer; value: TFhirPractitionerRoleNotAvailable);
begin
  assert(value is TFhirPractitionerRoleNotAvailable);
  ObjectByIndex[index] := value;
end;

{ TFhirPractitionerRole }

constructor TFhirPractitionerRole.Create;
begin
  inherited;
end;

destructor TFhirPractitionerRole.Destroy;
begin
  FIdentifierList.free;
  FActive.free;
  FPeriod.free;
  FPractitioner.free;
  FOrganization.free;
  FCodeList.free;
  FSpecialtyList.free;
  FLocationList.free;
  FHealthcareServiceList.free;
  FTelecomList.free;
  FAvailableTimeList.free;
  FNotAvailableList.free;
  FAvailabilityExceptions.free;
  FEndpointList.free;
  inherited;
end;

function TFhirPractitionerRole.GetResourceType : TFhirResourceType;
begin
  result := frtPractitionerRole;
end;

procedure TFhirPractitionerRole.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPractitionerRole(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPractitionerRole(oSource).FIdentifierList);
  end;
  activeElement := TFhirPractitionerRole(oSource).activeElement.Clone;
  period := TFhirPractitionerRole(oSource).period.Clone;
  practitioner := TFhirPractitionerRole(oSource).practitioner.Clone;
  organization := TFhirPractitionerRole(oSource).organization.Clone;
  if (TFhirPractitionerRole(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirPractitionerRole(oSource).FCodeList);
  end;
  if (TFhirPractitionerRole(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirPractitionerRole(oSource).FSpecialtyList);
  end;
  if (TFhirPractitionerRole(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirReferenceList{TFhirLocation}.Create;
    FLocationList.Assign(TFhirPractitionerRole(oSource).FLocationList);
  end;
  if (TFhirPractitionerRole(oSource).FHealthcareServiceList = nil) then
  begin
    FHealthcareServiceList.free;
    FHealthcareServiceList := nil;
  end
  else
  begin
    if FHealthcareServiceList = nil then
      FHealthcareServiceList := TFhirReferenceList{TFhirHealthcareService}.Create;
    FHealthcareServiceList.Assign(TFhirPractitionerRole(oSource).FHealthcareServiceList);
  end;
  if (TFhirPractitionerRole(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirPractitionerRole(oSource).FTelecomList);
  end;
  if (TFhirPractitionerRole(oSource).FAvailableTimeList = nil) then
  begin
    FAvailableTimeList.free;
    FAvailableTimeList := nil;
  end
  else
  begin
    if FAvailableTimeList = nil then
      FAvailableTimeList := TFhirPractitionerRoleAvailableTimeList.Create;
    FAvailableTimeList.Assign(TFhirPractitionerRole(oSource).FAvailableTimeList);
  end;
  if (TFhirPractitionerRole(oSource).FNotAvailableList = nil) then
  begin
    FNotAvailableList.free;
    FNotAvailableList := nil;
  end
  else
  begin
    if FNotAvailableList = nil then
      FNotAvailableList := TFhirPractitionerRoleNotAvailableList.Create;
    FNotAvailableList.Assign(TFhirPractitionerRole(oSource).FNotAvailableList);
  end;
  availabilityExceptionsElement := TFhirPractitionerRole(oSource).availabilityExceptionsElement.Clone;
  if (TFhirPractitionerRole(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList{TFhirEndpoint}.Create;
    FEndpointList.Assign(TFhirPractitionerRole(oSource).FEndpointList);
  end;
end;

procedure TFhirPractitionerRole.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'practitioner') Then
     list.add(self.link, 'practitioner', FPractitioner.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'healthcareService') Then
    list.addAll(self, 'healthcareService', FHealthcareServiceList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'availableTime') Then
    list.addAll(self, 'availableTime', FAvailableTimeList);
  if (child_name = 'notAvailable') Then
    list.addAll(self, 'notAvailable', FNotAvailableList);
  if (child_name = 'availabilityExceptions') Then
     list.add(self.link, 'availabilityExceptions', FAvailabilityExceptions.Link);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
end;

procedure TFhirPractitionerRole.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'practitioner', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FPractitioner.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'organization', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOrganization.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'location', 'Reference(Location)', true, TFhirReference{TFhirLocation}, FLocationList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'healthcareService', 'Reference(HealthcareService)', true, TFhirReference{TFhirHealthcareService}, FHealthcareServiceList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'availableTime', '', true, TFhirPractitionerRoleAvailableTime, FAvailableTimeList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'notAvailable', '', true, TFhirPractitionerRoleNotAvailable, FNotAvailableList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'availabilityExceptions', 'string', false, TFhirString, FAvailabilityExceptions.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'endpoint', 'Reference(Endpoint)', true, TFhirReference{TFhirEndpoint}, FEndpointList.Link)){3};
end;

function TFhirPractitionerRole.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'practitioner') then
  begin
    Practitioner := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(propValue as TFhirReference{TFhirLocation}){2a};
    result := propValue;
  end
  else if (propName = 'healthcareService') then
  begin
    HealthcareServiceList.add(propValue as TFhirReference{TFhirHealthcareService}){2a};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else if (propName = 'availableTime') then
  begin
    AvailableTimeList.add(propValue as TFhirPractitionerRoleAvailableTime){2a};
    result := propValue;
  end
  else if (propName = 'notAvailable') then
  begin
    NotAvailableList.add(propValue as TFhirPractitionerRoleNotAvailable){2a};
    result := propValue;
  end
  else if (propName = 'availabilityExceptions') then
  begin
    AvailabilityExceptionsElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference{TFhirEndpoint}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirPractitionerRole.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'location') then LocationList.insertItem(index, propValue as TFhirReference{TFhirLocation}){2a}
  else if (propName = 'healthcareService') then HealthcareServiceList.insertItem(index, propValue as TFhirReference{TFhirHealthcareService}){2a}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else if (propName = 'availableTime') then AvailableTimeList.insertItem(index, propValue as TFhirPractitionerRoleAvailableTime){2a}
  else if (propName = 'notAvailable') then NotAvailableList.insertItem(index, propValue as TFhirPractitionerRoleNotAvailable){2a}
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference{TFhirEndpoint}){2a}
  else inherited;
end;

function TFhirPractitionerRole.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'active') then result := TFhirBoolean.Create() {5b}
  else if (propName = 'period') then result := TFhirPeriod.Create(){4b}
  else if (propName = 'practitioner') then result := TFhirReference{TFhirPractitioner}.Create(){4b}
  else if (propName = 'organization') then result := TFhirReference{TFhirOrganization}.Create(){4b}
  else if (propName = 'code') then result := CodeList.new(){2}
  else if (propName = 'specialty') then result := SpecialtyList.new(){2}
  else if (propName = 'location') then result := LocationList.new(){2}
  else if (propName = 'healthcareService') then result := HealthcareServiceList.new(){2}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else if (propName = 'availableTime') then result := AvailableTimeList.new(){2}
  else if (propName = 'notAvailable') then result := NotAvailableList.new(){2}
  else if (propName = 'availabilityExceptions') then result := TFhirString.Create() {5b}
  else if (propName = 'endpoint') then result := EndpointList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPractitionerRole.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'practitioner') then result := 'Reference'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'healthcareService') then result := 'Reference'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'availableTime') then result := ''
  else if (propName = 'notAvailable') then result := ''
  else if (propName = 'availabilityExceptions') then result := 'string'
  else if (propName = 'endpoint') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPractitionerRole.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'practitioner') then PractitionerElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value) {2}
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value) {2}
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value) {2}
  else if (propName = 'healthcareService') then deletePropertyValue('healthcareService', HealthcareServiceList, value) {2}
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else if (propName = 'availableTime') then deletePropertyValue('availableTime', AvailableTimeList, value) {2}
  else if (propName = 'notAvailable') then deletePropertyValue('notAvailable', NotAvailableList, value) {2}
  else if (propName = 'availabilityExceptions') then AvailabilityExceptionsElement := nil
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPractitionerRole.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'active') then ActiveElement := asBoolean(new){5b}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'practitioner') then PractitionerElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {2}
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new) {2}
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new) {2}
  else if (propName = 'healthcareService') then replacePropertyValue('healthcareService', HealthcareServiceList, existing, new) {2}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else if (propName = 'availableTime') then replacePropertyValue('availableTime', AvailableTimeList, existing, new) {2}
  else if (propName = 'notAvailable') then replacePropertyValue('notAvailable', NotAvailableList, existing, new) {2}
  else if (propName = 'availabilityExceptions') then AvailabilityExceptionsElement := asString(new){5b}
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPractitionerRole.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'code') then CodeList.move(source, destination){2a}
  else if (propName = 'specialty') then SpecialtyList.move(source, destination){2a}
  else if (propName = 'location') then LocationList.move(source, destination){2a}
  else if (propName = 'healthcareService') then HealthcareServiceList.move(source, destination){2a}
  else if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else if (propName = 'availableTime') then AvailableTimeList.move(source, destination){2a}
  else if (propName = 'notAvailable') then NotAvailableList.move(source, destination){2a}
  else if (propName = 'endpoint') then EndpointList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPractitionerRole.fhirType : string;
begin
  result := 'PractitionerRole';
end;

function TFhirPractitionerRole.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FPeriod) and isEmptyProp(FPractitioner) and isEmptyProp(FOrganization) and isEmptyProp(FcodeList) and isEmptyProp(FspecialtyList) and isEmptyProp(FlocationList) and isEmptyProp(FhealthcareServiceList) and isEmptyProp(FtelecomList) and isEmptyProp(FavailableTimeList) and isEmptyProp(FnotAvailableList) and isEmptyProp(FAvailabilityExceptions) and isEmptyProp(FendpointList);
end;

function TFhirPractitionerRole.equals(other : TObject) : boolean; 
var
  o : TFhirPractitionerRole;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPractitionerRole)) then
    result := false
  else
  begin
    o := TFhirPractitionerRole(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(practitionerElement, o.practitionerElement, true) and 
      compareDeep(organizationElement, o.organizationElement, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(specialtyList, o.specialtyList, true) and compareDeep(locationList, o.locationList, true) and 
      compareDeep(healthcareServiceList, o.healthcareServiceList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(availableTimeList, o.availableTimeList, true) and compareDeep(notAvailableList, o.notAvailableList, true) and 
      compareDeep(availabilityExceptionsElement, o.availabilityExceptionsElement, true) and 
      compareDeep(endpointList, o.endpointList, true);
  end;
end;

function TFhirPractitionerRole.Link : TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole(inherited Link);
end;

function TFhirPractitionerRole.Clone : TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole(inherited Clone);
end;

procedure TFhirPractitionerRole.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('period');
  fields.add('practitioner');
  fields.add('organization');
  fields.add('code');
  fields.add('specialty');
  fields.add('location');
  fields.add('healthcareService');
  fields.add('telecom');
  fields.add('availableTime');
  fields.add('notAvailable');
  fields.add('availabilityExceptions');
  fields.add('endpoint');
end;

{ TFhirPractitionerRole }

Function TFhirPractitionerRole.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirPractitionerRole.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirPractitionerRole.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

Function TFhirPractitionerRole.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

Procedure TFhirPractitionerRole.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.Create;
  FActive.value := value
end;

Procedure TFhirPractitionerRole.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirPractitionerRole.SetPractitioner(value : TFhirReference{TFhirPractitioner});
begin
  FPractitioner.free;
  FPractitioner := value;
end;

Procedure TFhirPractitionerRole.SetOrganization(value : TFhirReference{TFhirOrganization});
begin
  FOrganization.free;
  FOrganization := value;
end;

Function TFhirPractitionerRole.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

Function TFhirPractitionerRole.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

Function TFhirPractitionerRole.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

Function TFhirPractitionerRole.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

Function TFhirPractitionerRole.GetLocationList : TFhirReferenceList{TFhirLocation};
begin
  if FLocationList = nil then
    FLocationList := TFhirReferenceList{TFhirLocation}.Create;
  result := FLocationList;
end;

Function TFhirPractitionerRole.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

Function TFhirPractitionerRole.GetHealthcareServiceList : TFhirReferenceList{TFhirHealthcareService};
begin
  if FHealthcareServiceList = nil then
    FHealthcareServiceList := TFhirReferenceList{TFhirHealthcareService}.Create;
  result := FHealthcareServiceList;
end;

Function TFhirPractitionerRole.GetHasHealthcareServiceList : boolean;
begin
  result := (FHealthcareServiceList <> nil) and (FHealthcareServiceList.count > 0);
end;

Function TFhirPractitionerRole.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirPractitionerRole.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

Function TFhirPractitionerRole.GetAvailableTimeList : TFhirPractitionerRoleAvailableTimeList;
begin
  if FAvailableTimeList = nil then
    FAvailableTimeList := TFhirPractitionerRoleAvailableTimeList.Create;
  result := FAvailableTimeList;
end;

Function TFhirPractitionerRole.GetHasAvailableTimeList : boolean;
begin
  result := (FAvailableTimeList <> nil) and (FAvailableTimeList.count > 0);
end;

Function TFhirPractitionerRole.GetNotAvailableList : TFhirPractitionerRoleNotAvailableList;
begin
  if FNotAvailableList = nil then
    FNotAvailableList := TFhirPractitionerRoleNotAvailableList.Create;
  result := FNotAvailableList;
end;

Function TFhirPractitionerRole.GetHasNotAvailableList : boolean;
begin
  result := (FNotAvailableList <> nil) and (FNotAvailableList.count > 0);
end;

Procedure TFhirPractitionerRole.SetAvailabilityExceptions(value : TFhirString);
begin
  FAvailabilityExceptions.free;
  FAvailabilityExceptions := value;
end;

Function TFhirPractitionerRole.GetAvailabilityExceptionsST : String;
begin
  if FAvailabilityExceptions = nil then
    result := ''
  else
    result := FAvailabilityExceptions.value;
end;

Procedure TFhirPractitionerRole.SetAvailabilityExceptionsST(value : String);
begin
  if value <> '' then
  begin
    if FAvailabilityExceptions = nil then
      FAvailabilityExceptions := TFhirString.Create;
    FAvailabilityExceptions.value := value
  end
  else if FAvailabilityExceptions <> nil then
    FAvailabilityExceptions.value := '';
end;

Function TFhirPractitionerRole.GetEndpointList : TFhirReferenceList{TFhirEndpoint};
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList{TFhirEndpoint}.Create;
  result := FEndpointList;
end;

Function TFhirPractitionerRole.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

function TFhirPractitionerRole.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FidentifierList.sizeInBytes(magic));
  inc(result, FActive.sizeInBytes(magic));
  inc(result, FPeriod.sizeInBytes(magic));
  inc(result, FPractitioner.sizeInBytes(magic));
  inc(result, FOrganization.sizeInBytes(magic));
  inc(result, FcodeList.sizeInBytes(magic));
  inc(result, FspecialtyList.sizeInBytes(magic));
  inc(result, FlocationList.sizeInBytes(magic));
  inc(result, FhealthcareServiceList.sizeInBytes(magic));
  inc(result, FtelecomList.sizeInBytes(magic));
  inc(result, FavailableTimeList.sizeInBytes(magic));
  inc(result, FnotAvailableList.sizeInBytes(magic));
  inc(result, FAvailabilityExceptions.sizeInBytes(magic));
  inc(result, FendpointList.sizeInBytes(magic));
end;

{ TFhirPractitionerRoleListEnumerator }

Constructor TFhirPractitionerRoleListEnumerator.Create(list : TFhirPractitionerRoleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPractitionerRoleListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPractitionerRoleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPractitionerRoleListEnumerator.GetCurrent : TFhirPractitionerRole;
begin
  Result := FList[FIndex];
end;

function TFhirPractitionerRoleListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPractitionerRoleList }
function TFhirPractitionerRoleList.AddItem(value: TFhirPractitionerRole): TFhirPractitionerRole;
begin
  add(value);
  result := value;
end;

function TFhirPractitionerRoleList.Append: TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerRoleList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerRoleList.GetEnumerator : TFhirPractitionerRoleListEnumerator;
begin
  result := TFhirPractitionerRoleListEnumerator.Create(self.link);
end;

function TFhirPractitionerRoleList.Clone: TFhirPractitionerRoleList;
begin
  result := TFhirPractitionerRoleList(inherited Clone);
end;

function TFhirPractitionerRoleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerRoleList.GetItemN(index: Integer): TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole(ObjectByIndex[index]);
end;

function TFhirPractitionerRoleList.ItemClass: TFslObjectClass;
begin
  result := TFhirPractitionerRole;
end;
function TFhirPractitionerRoleList.IndexOf(value: TFhirPractitionerRole): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPractitionerRoleList.Insert(index: Integer): TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerRoleList.InsertItem(index: Integer; value: TFhirPractitionerRole);
begin
  assert(value is TFhirPractitionerRole);
  Inherited Insert(index, value);
end;

function TFhirPractitionerRoleList.Item(index: Integer): TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole(ObjectByIndex[index]);
end;

function TFhirPractitionerRoleList.Link: TFhirPractitionerRoleList;
begin
  result := TFhirPractitionerRoleList(inherited Link);
end;

procedure TFhirPractitionerRoleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerRoleList.SetItemByIndex(index: Integer; value: TFhirPractitionerRole);
begin
  assert(value is TFhirPractitionerRole);
  FhirPractitionerRoles[index] := value;
end;

procedure TFhirPractitionerRoleList.SetItemN(index: Integer; value: TFhirPractitionerRole);
begin
  assert(value is TFhirPractitionerRole);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PRACTITIONERROLE}

{$IFDEF FHIR_RELATEDPERSON}

{ TFhirRelatedPersonCommunication }

constructor TFhirRelatedPersonCommunication.Create;
begin
  inherited;
end;

destructor TFhirRelatedPersonCommunication.Destroy;
begin
  FLanguage.free;
  FPreferred.free;
  inherited;
end;

procedure TFhirRelatedPersonCommunication.Assign(oSource : TFslObject);
begin
  inherited;
  language := TFhirRelatedPersonCommunication(oSource).language.Clone;
  preferredElement := TFhirRelatedPersonCommunication(oSource).preferredElement.Clone;
end;

procedure TFhirRelatedPersonCommunication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'preferred') Then
     list.add(self.link, 'preferred', FPreferred.Link);
end;

procedure TFhirRelatedPersonCommunication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'preferred', 'boolean', false, TFhirBoolean, FPreferred.Link));{2}
end;

function TFhirRelatedPersonCommunication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'preferred') then
  begin
    PreferredElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRelatedPersonCommunication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRelatedPersonCommunication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'language') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'preferred') then result := TFhirBoolean.Create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRelatedPersonCommunication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'language') then result := 'CodeableConcept'
  else if (propName = 'preferred') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRelatedPersonCommunication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := nil
  else if (propName = 'preferred') then PreferredElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRelatedPersonCommunication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept{4}
  else if (propName = 'preferred') then PreferredElement := asBoolean(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRelatedPersonCommunication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRelatedPersonCommunication.fhirType : string;
begin
  result := 'communication';
end;

function TFhirRelatedPersonCommunication.Link : TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication(inherited Link);
end;

function TFhirRelatedPersonCommunication.Clone : TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication(inherited Clone);
end;

function TFhirRelatedPersonCommunication.equals(other : TObject) : boolean; 
var
  o : TFhirRelatedPersonCommunication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRelatedPersonCommunication)) then
    result := false
  else
  begin
    o := TFhirRelatedPersonCommunication(other);
    result := compareDeep(languageElement, o.languageElement, true) and compareDeep(preferredElement, o.preferredElement, true);
  end;
end;

function TFhirRelatedPersonCommunication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLanguage) and isEmptyProp(FPreferred);
end;

procedure TFhirRelatedPersonCommunication.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('language');
  fields.add('preferred');
end;

{ TFhirRelatedPersonCommunication }

Procedure TFhirRelatedPersonCommunication.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value;
end;

Procedure TFhirRelatedPersonCommunication.SetPreferred(value : TFhirBoolean);
begin
  FPreferred.free;
  FPreferred := value;
end;

Function TFhirRelatedPersonCommunication.GetPreferredST : Boolean;
begin
  if FPreferred = nil then
    result := false
  else
    result := FPreferred.value;
end;

Procedure TFhirRelatedPersonCommunication.SetPreferredST(value : Boolean);
begin
  if FPreferred = nil then
    FPreferred := TFhirBoolean.Create;
  FPreferred.value := value
end;

function TFhirRelatedPersonCommunication.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FLanguage.sizeInBytes(magic));
  inc(result, FPreferred.sizeInBytes(magic));
end;

{ TFhirRelatedPersonCommunicationListEnumerator }

Constructor TFhirRelatedPersonCommunicationListEnumerator.Create(list : TFhirRelatedPersonCommunicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRelatedPersonCommunicationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirRelatedPersonCommunicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRelatedPersonCommunicationListEnumerator.GetCurrent : TFhirRelatedPersonCommunication;
begin
  Result := FList[FIndex];
end;

function TFhirRelatedPersonCommunicationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRelatedPersonCommunicationList }
function TFhirRelatedPersonCommunicationList.AddItem(value: TFhirRelatedPersonCommunication): TFhirRelatedPersonCommunication;
begin
  add(value);
  result := value;
end;

function TFhirRelatedPersonCommunicationList.Append: TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRelatedPersonCommunicationList.ClearItems;
begin
  Clear;
end;

function TFhirRelatedPersonCommunicationList.GetEnumerator : TFhirRelatedPersonCommunicationListEnumerator;
begin
  result := TFhirRelatedPersonCommunicationListEnumerator.Create(self.link);
end;

function TFhirRelatedPersonCommunicationList.Clone: TFhirRelatedPersonCommunicationList;
begin
  result := TFhirRelatedPersonCommunicationList(inherited Clone);
end;

function TFhirRelatedPersonCommunicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRelatedPersonCommunicationList.GetItemN(index: Integer): TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication(ObjectByIndex[index]);
end;

function TFhirRelatedPersonCommunicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirRelatedPersonCommunication;
end;
function TFhirRelatedPersonCommunicationList.IndexOf(value: TFhirRelatedPersonCommunication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRelatedPersonCommunicationList.Insert(index: Integer): TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRelatedPersonCommunicationList.InsertItem(index: Integer; value: TFhirRelatedPersonCommunication);
begin
  assert(value is TFhirRelatedPersonCommunication);
  Inherited Insert(index, value);
end;

function TFhirRelatedPersonCommunicationList.Item(index: Integer): TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication(ObjectByIndex[index]);
end;

function TFhirRelatedPersonCommunicationList.Link: TFhirRelatedPersonCommunicationList;
begin
  result := TFhirRelatedPersonCommunicationList(inherited Link);
end;

procedure TFhirRelatedPersonCommunicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRelatedPersonCommunicationList.SetItemByIndex(index: Integer; value: TFhirRelatedPersonCommunication);
begin
  assert(value is TFhirRelatedPersonCommunication);
  FhirRelatedPersonCommunications[index] := value;
end;

procedure TFhirRelatedPersonCommunicationList.SetItemN(index: Integer; value: TFhirRelatedPersonCommunication);
begin
  assert(value is TFhirRelatedPersonCommunication);
  ObjectByIndex[index] := value;
end;

{ TFhirRelatedPerson }

constructor TFhirRelatedPerson.Create;
begin
  inherited;
end;

destructor TFhirRelatedPerson.Destroy;
begin
  FIdentifierList.free;
  FActive.free;
  FPatient.free;
  FRelationshipList.free;
  FNameList.free;
  FTelecomList.free;
  FGender.free;
  FBirthDate.free;
  FAddressList.free;
  FPhotoList.free;
  FPeriod.free;
  FCommunicationList.free;
  inherited;
end;

function TFhirRelatedPerson.GetResourceType : TFhirResourceType;
begin
  result := frtRelatedPerson;
end;

procedure TFhirRelatedPerson.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirRelatedPerson(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirRelatedPerson(oSource).FIdentifierList);
  end;
  activeElement := TFhirRelatedPerson(oSource).activeElement.Clone;
  patient := TFhirRelatedPerson(oSource).patient.Clone;
  if (TFhirRelatedPerson(oSource).FRelationshipList = nil) then
  begin
    FRelationshipList.free;
    FRelationshipList := nil;
  end
  else
  begin
    if FRelationshipList = nil then
      FRelationshipList := TFhirCodeableConceptList.Create;
    FRelationshipList.Assign(TFhirRelatedPerson(oSource).FRelationshipList);
  end;
  if (TFhirRelatedPerson(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirHumanNameList.Create;
    FNameList.Assign(TFhirRelatedPerson(oSource).FNameList);
  end;
  if (TFhirRelatedPerson(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirRelatedPerson(oSource).FTelecomList);
  end;
  FGender := TFhirRelatedPerson(oSource).FGender.Link;
  birthDateElement := TFhirRelatedPerson(oSource).birthDateElement.Clone;
  if (TFhirRelatedPerson(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirRelatedPerson(oSource).FAddressList);
  end;
  if (TFhirRelatedPerson(oSource).FPhotoList = nil) then
  begin
    FPhotoList.free;
    FPhotoList := nil;
  end
  else
  begin
    if FPhotoList = nil then
      FPhotoList := TFhirAttachmentList.Create;
    FPhotoList.Assign(TFhirRelatedPerson(oSource).FPhotoList);
  end;
  period := TFhirRelatedPerson(oSource).period.Clone;
  if (TFhirRelatedPerson(oSource).FCommunicationList = nil) then
  begin
    FCommunicationList.free;
    FCommunicationList := nil;
  end
  else
  begin
    if FCommunicationList = nil then
      FCommunicationList := TFhirRelatedPersonCommunicationList.Create;
    FCommunicationList.Assign(TFhirRelatedPerson(oSource).FCommunicationList);
  end;
end;

procedure TFhirRelatedPerson.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'relationship') Then
    list.addAll(self, 'relationship', FRelationshipList);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'birthDate') Then
     list.add(self.link, 'birthDate', FBirthDate.Link);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'photo') Then
    list.addAll(self, 'photo', FPhotoList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'communication') Then
    list.addAll(self, 'communication', FCommunicationList);
end;

procedure TFhirRelatedPerson.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'relationship', 'CodeableConcept', true, TFhirCodeableConcept, FRelationshipList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'name', 'HumanName', true, TFhirHumanName, FNameList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'gender', 'code', false, TFHIREnum, FGender.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'birthDate', 'date', false, TFhirDate, FBirthDate.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'photo', 'Attachment', true, TFhirAttachment, FPhotoList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'communication', '', true, TFhirRelatedPersonCommunication, FCommunicationList.Link)){3};
end;

function TFhirRelatedPerson.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    RelationshipList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirHumanName){2a};
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint){2a};
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue);
    result := propValue
  end
  else if (propName = 'birthDate') then
  begin
    BirthDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress){2a};
    result := propValue;
  end
  else if (propName = 'photo') then
  begin
    PhotoList.add(propValue as TFhirAttachment){2a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'communication') then
  begin
    CommunicationList.add(propValue as TFhirRelatedPersonCommunication){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirRelatedPerson.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'relationship') then RelationshipList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirHumanName){2a}
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint){2a}
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress){2a}
  else if (propName = 'photo') then PhotoList.insertItem(index, propValue as TFhirAttachment){2a}
  else if (propName = 'communication') then CommunicationList.insertItem(index, propValue as TFhirRelatedPersonCommunication){2a}
  else inherited;
end;

function TFhirRelatedPerson.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'active') then result := TFhirBoolean.Create() {5b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.Create(){4b}
  else if (propName = 'relationship') then result := RelationshipList.new(){2}
  else if (propName = 'name') then result := NameList.new(){2}
  else if (propName = 'telecom') then result := TelecomList.new(){2}
  else if (propName = 'birthDate') then result := TFhirDate.Create() {5b}
  else if (propName = 'address') then result := AddressList.new(){2}
  else if (propName = 'photo') then result := PhotoList.new(){2}
  else if (propName = 'period') then result := TFhirPeriod.Create(){4b}
  else if (propName = 'communication') then result := CommunicationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRelatedPerson.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'birthDate') then result := 'date'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'photo') then result := 'Attachment'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'communication') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRelatedPerson.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'relationship') then deletePropertyValue('relationship', RelationshipList, value) {2}
  else if (propName = 'name') then deletePropertyValue('name', NameList, value) {2}
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value) {2}
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'birthDate') then BirthDateElement := nil
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value) {2}
  else if (propName = 'photo') then deletePropertyValue('photo', PhotoList, value) {2}
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'communication') then deletePropertyValue('communication', CommunicationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRelatedPerson.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'active') then ActiveElement := asBoolean(new){5b}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'relationship') then replacePropertyValue('relationship', RelationshipList, existing, new) {2}
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new) {2}
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new) {2}
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new){4}
  else if (propName = 'birthDate') then BirthDateElement := asDate(new){5b}
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new) {2}
  else if (propName = 'photo') then replacePropertyValue('photo', PhotoList, existing, new) {2}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'communication') then replacePropertyValue('communication', CommunicationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRelatedPerson.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'relationship') then RelationshipList.move(source, destination){2a}
  else if (propName = 'name') then NameList.move(source, destination){2a}
  else if (propName = 'telecom') then TelecomList.move(source, destination){2a}
  else if (propName = 'address') then AddressList.move(source, destination){2a}
  else if (propName = 'photo') then PhotoList.move(source, destination){2a}
  else if (propName = 'communication') then CommunicationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRelatedPerson.fhirType : string;
begin
  result := 'RelatedPerson';
end;

function TFhirRelatedPerson.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FPatient) and isEmptyProp(FrelationshipList) and isEmptyProp(FnameList) and isEmptyProp(FtelecomList) and isEmptyProp(FGender) and isEmptyProp(FBirthDate) and isEmptyProp(FaddressList) and isEmptyProp(FphotoList) and isEmptyProp(FPeriod) and isEmptyProp(FcommunicationList);
end;

function TFhirRelatedPerson.equals(other : TObject) : boolean; 
var
  o : TFhirRelatedPerson;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRelatedPerson)) then
    result := false
  else
  begin
    o := TFhirRelatedPerson(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(relationshipList, o.relationshipList, true) and 
      compareDeep(nameList, o.nameList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(genderElement, o.genderElement, true) and compareDeep(birthDateElement, o.birthDateElement, true) and 
      compareDeep(addressList, o.addressList, true) and compareDeep(photoList, o.photoList, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(communicationList, o.communicationList, true);
  end;
end;

function TFhirRelatedPerson.Link : TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson(inherited Link);
end;

function TFhirRelatedPerson.Clone : TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson(inherited Clone);
end;

procedure TFhirRelatedPerson.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('patient');
  fields.add('relationship');
  fields.add('name');
  fields.add('telecom');
  fields.add('gender');
  fields.add('birthDate');
  fields.add('address');
  fields.add('photo');
  fields.add('period');
  fields.add('communication');
end;

{ TFhirRelatedPerson }

Function TFhirRelatedPerson.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirRelatedPerson.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirRelatedPerson.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

Function TFhirRelatedPerson.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

Procedure TFhirRelatedPerson.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.Create;
  FActive.value := value
end;

Procedure TFhirRelatedPerson.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Function TFhirRelatedPerson.GetRelationshipList : TFhirCodeableConceptList;
begin
  if FRelationshipList = nil then
    FRelationshipList := TFhirCodeableConceptList.Create;
  result := FRelationshipList;
end;

Function TFhirRelatedPerson.GetHasRelationshipList : boolean;
begin
  result := (FRelationshipList <> nil) and (FRelationshipList.count > 0);
end;

Function TFhirRelatedPerson.GetNameList : TFhirHumanNameList;
begin
  if FNameList = nil then
    FNameList := TFhirHumanNameList.Create;
  result := FNameList;
end;

Function TFhirRelatedPerson.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

Function TFhirRelatedPerson.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

Function TFhirRelatedPerson.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

Procedure TFhirRelatedPerson.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

Function TFhirRelatedPerson.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

Procedure TFhirRelatedPerson.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.Create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

Procedure TFhirRelatedPerson.SetBirthDate(value : TFhirDate);
begin
  FBirthDate.free;
  FBirthDate := value;
end;

Function TFhirRelatedPerson.GetBirthDateST : TFslDateTime;
begin
  if FBirthDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FBirthDate.value;
end;

Procedure TFhirRelatedPerson.SetBirthDateST(value : TFslDateTime);
begin
  if FBirthDate = nil then
    FBirthDate := TFhirDate.Create;
  FBirthDate.value := value
end;

Function TFhirRelatedPerson.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

Function TFhirRelatedPerson.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

Function TFhirRelatedPerson.GetPhotoList : TFhirAttachmentList;
begin
  if FPhotoList = nil then
    FPhotoList := TFhirAttachmentList.Create;
  result := FPhotoList;
end;

Function TFhirRelatedPerson.GetHasPhotoList : boolean;
begin
  result := (FPhotoList <> nil) and (FPhotoList.count > 0);
end;

Procedure TFhirRelatedPerson.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Function TFhirRelatedPerson.GetCommunicationList : TFhirRelatedPersonCommunicationList;
begin
  if FCommunicationList = nil then
    FCommunicationList := TFhirRelatedPersonCommunicationList.Create;
  result := FCommunicationList;
end;

Function TFhirRelatedPerson.GetHasCommunicationList : boolean;
begin
  result := (FCommunicationList <> nil) and (FCommunicationList.count > 0);
end;

function TFhirRelatedPerson.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FidentifierList.sizeInBytes(magic));
  inc(result, FActive.sizeInBytes(magic));
  inc(result, FPatient.sizeInBytes(magic));
  inc(result, FrelationshipList.sizeInBytes(magic));
  inc(result, FnameList.sizeInBytes(magic));
  inc(result, FtelecomList.sizeInBytes(magic));
  inc(result, FGender.sizeInBytes(magic));
  inc(result, FBirthDate.sizeInBytes(magic));
  inc(result, FaddressList.sizeInBytes(magic));
  inc(result, FphotoList.sizeInBytes(magic));
  inc(result, FPeriod.sizeInBytes(magic));
  inc(result, FcommunicationList.sizeInBytes(magic));
end;

{ TFhirRelatedPersonListEnumerator }

Constructor TFhirRelatedPersonListEnumerator.Create(list : TFhirRelatedPersonList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRelatedPersonListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirRelatedPersonListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRelatedPersonListEnumerator.GetCurrent : TFhirRelatedPerson;
begin
  Result := FList[FIndex];
end;

function TFhirRelatedPersonListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRelatedPersonList }
function TFhirRelatedPersonList.AddItem(value: TFhirRelatedPerson): TFhirRelatedPerson;
begin
  add(value);
  result := value;
end;

function TFhirRelatedPersonList.Append: TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRelatedPersonList.ClearItems;
begin
  Clear;
end;

function TFhirRelatedPersonList.GetEnumerator : TFhirRelatedPersonListEnumerator;
begin
  result := TFhirRelatedPersonListEnumerator.Create(self.link);
end;

function TFhirRelatedPersonList.Clone: TFhirRelatedPersonList;
begin
  result := TFhirRelatedPersonList(inherited Clone);
end;

function TFhirRelatedPersonList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRelatedPersonList.GetItemN(index: Integer): TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson(ObjectByIndex[index]);
end;

function TFhirRelatedPersonList.ItemClass: TFslObjectClass;
begin
  result := TFhirRelatedPerson;
end;
function TFhirRelatedPersonList.IndexOf(value: TFhirRelatedPerson): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRelatedPersonList.Insert(index: Integer): TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRelatedPersonList.InsertItem(index: Integer; value: TFhirRelatedPerson);
begin
  assert(value is TFhirRelatedPerson);
  Inherited Insert(index, value);
end;

function TFhirRelatedPersonList.Item(index: Integer): TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson(ObjectByIndex[index]);
end;

function TFhirRelatedPersonList.Link: TFhirRelatedPersonList;
begin
  result := TFhirRelatedPersonList(inherited Link);
end;

procedure TFhirRelatedPersonList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRelatedPersonList.SetItemByIndex(index: Integer; value: TFhirRelatedPerson);
begin
  assert(value is TFhirRelatedPerson);
  FhirRelatedPeople[index] := value;
end;

procedure TFhirRelatedPersonList.SetItemN(index: Integer; value: TFhirRelatedPerson);
begin
  assert(value is TFhirRelatedPerson);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RELATEDPERSON}

{$IFDEF FHIR_SCHEDULE}

{ TFhirSchedule }

constructor TFhirSchedule.Create;
begin
  inherited;
end;

destructor TFhirSchedule.Destroy;
begin
  FIdentifierList.free;
  FActive.free;
  FServiceCategoryList.free;
  FServiceTypeList.free;
  FSpecialtyList.free;
  FActorList.free;
  FPlanningHorizon.free;
  FComment.free;
  inherited;
end;

function TFhirSchedule.GetResourceType : TFhirResourceType;
begin
  result := frtSchedule;
end;

procedure TFhirSchedule.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSchedule(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSchedule(oSource).FIdentifierList);
  end;
  activeElement := TFhirSchedule(oSource).activeElement.Clone;
  if (TFhirSchedule(oSource).FServiceCategoryList = nil) then
  begin
    FServiceCategoryList.free;
    FServiceCategoryList := nil;
  end
  else
  begin
    if FServiceCategoryList = nil then
      FServiceCategoryList := TFhirCodeableConceptList.Create;
    FServiceCategoryList.Assign(TFhirSchedule(oSource).FServiceCategoryList);
  end;
  if (TFhirSchedule(oSource).FServiceTypeList = nil) then
  begin
    FServiceTypeList.free;
    FServiceTypeList := nil;
  end
  else
  begin
    if FServiceTypeList = nil then
      FServiceTypeList := TFhirCodeableConceptList.Create;
    FServiceTypeList.Assign(TFhirSchedule(oSource).FServiceTypeList);
  end;
  if (TFhirSchedule(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirSchedule(oSource).FSpecialtyList);
  end;
  if (TFhirSchedule(oSource).FActorList = nil) then
  begin
    FActorList.free;
    FActorList := nil;
  end
  else
  begin
    if FActorList = nil then
      FActorList := TFhirReferenceList{TFhirPatient}.Create;
    FActorList.Assign(TFhirSchedule(oSource).FActorList);
  end;
  planningHorizon := TFhirSchedule(oSource).planningHorizon.Clone;
  commentElement := TFhirSchedule(oSource).commentElement.Clone;
end;

procedure TFhirSchedule.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'serviceCategory') Then
    list.addAll(self, 'serviceCategory', FServiceCategoryList);
  if (child_name = 'serviceType') Then
    list.addAll(self, 'serviceType', FServiceTypeList);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'actor') Then
    list.addAll(self, 'actor', FActorList);
  if (child_name = 'planningHorizon') Then
     list.add(self.link, 'planningHorizon', FPlanningHorizon.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirSchedule.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'serviceCategory', 'CodeableConcept', true, TFhirCodeableConcept, FServiceCategoryList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'serviceType', 'CodeableConcept', true, TFhirCodeableConcept, FServiceTypeList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'actor', 'Reference(Patient)', true, TFhirReference{TFhirPatient}, FActorList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'planningHorizon', 'Period', false, TFhirPeriod, FPlanningHorizon.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
end;

function TFhirSchedule.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'serviceCategory') then
  begin
    ServiceCategoryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'serviceType') then
  begin
    ServiceTypeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    ActorList.add(propValue as TFhirReference{TFhirPatient}){2a};
    result := propValue;
  end
  else if (propName = 'planningHorizon') then
  begin
    PlanningHorizon := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSchedule.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'serviceCategory') then ServiceCategoryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'serviceType') then ServiceTypeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'actor') then ActorList.insertItem(index, propValue as TFhirReference{TFhirPatient}){2a}
  else inherited;
end;

function TFhirSchedule.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'active') then result := TFhirBoolean.Create() {5b}
  else if (propName = 'serviceCategory') then result := ServiceCategoryList.new(){2}
  else if (propName = 'serviceType') then result := ServiceTypeList.new(){2}
  else if (propName = 'specialty') then result := SpecialtyList.new(){2}
  else if (propName = 'actor') then result := ActorList.new(){2}
  else if (propName = 'planningHorizon') then result := TFhirPeriod.Create(){4b}
  else if (propName = 'comment') then result := TFhirString.Create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSchedule.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'serviceCategory') then result := 'CodeableConcept'
  else if (propName = 'serviceType') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else if (propName = 'planningHorizon') then result := 'Period'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSchedule.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'serviceCategory') then deletePropertyValue('serviceCategory', ServiceCategoryList, value) {2}
  else if (propName = 'serviceType') then deletePropertyValue('serviceType', ServiceTypeList, value) {2}
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value) {2}
  else if (propName = 'actor') then deletePropertyValue('actor', ActorList, value) {2}
  else if (propName = 'planningHorizon') then PlanningHorizonElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSchedule.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'active') then ActiveElement := asBoolean(new){5b}
  else if (propName = 'serviceCategory') then replacePropertyValue('serviceCategory', ServiceCategoryList, existing, new) {2}
  else if (propName = 'serviceType') then replacePropertyValue('serviceType', ServiceTypeList, existing, new) {2}
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new) {2}
  else if (propName = 'actor') then replacePropertyValue('actor', ActorList, existing, new) {2}
  else if (propName = 'planningHorizon') then PlanningHorizonElement := new as TFhirPeriod{4}
  else if (propName = 'comment') then CommentElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSchedule.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'serviceCategory') then ServiceCategoryList.move(source, destination){2a}
  else if (propName = 'serviceType') then ServiceTypeList.move(source, destination){2a}
  else if (propName = 'specialty') then SpecialtyList.move(source, destination){2a}
  else if (propName = 'actor') then ActorList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSchedule.fhirType : string;
begin
  result := 'Schedule';
end;

function TFhirSchedule.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FserviceCategoryList) and isEmptyProp(FserviceTypeList) and isEmptyProp(FspecialtyList) and isEmptyProp(FactorList) and isEmptyProp(FPlanningHorizon) and isEmptyProp(FComment);
end;

function TFhirSchedule.equals(other : TObject) : boolean; 
var
  o : TFhirSchedule;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSchedule)) then
    result := false
  else
  begin
    o := TFhirSchedule(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(serviceCategoryList, o.serviceCategoryList, true) and compareDeep(serviceTypeList, o.serviceTypeList, true) and 
      compareDeep(specialtyList, o.specialtyList, true) and compareDeep(actorList, o.actorList, true) and 
      compareDeep(planningHorizonElement, o.planningHorizonElement, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirSchedule.Link : TFhirSchedule;
begin
  result := TFhirSchedule(inherited Link);
end;

function TFhirSchedule.Clone : TFhirSchedule;
begin
  result := TFhirSchedule(inherited Clone);
end;

procedure TFhirSchedule.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('serviceCategory');
  fields.add('serviceType');
  fields.add('specialty');
  fields.add('actor');
  fields.add('planningHorizon');
  fields.add('comment');
end;

{ TFhirSchedule }

Function TFhirSchedule.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirSchedule.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirSchedule.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

Function TFhirSchedule.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

Procedure TFhirSchedule.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.Create;
  FActive.value := value
end;

Function TFhirSchedule.GetServiceCategoryList : TFhirCodeableConceptList;
begin
  if FServiceCategoryList = nil then
    FServiceCategoryList := TFhirCodeableConceptList.Create;
  result := FServiceCategoryList;
end;

Function TFhirSchedule.GetHasServiceCategoryList : boolean;
begin
  result := (FServiceCategoryList <> nil) and (FServiceCategoryList.count > 0);
end;

Function TFhirSchedule.GetServiceTypeList : TFhirCodeableConceptList;
begin
  if FServiceTypeList = nil then
    FServiceTypeList := TFhirCodeableConceptList.Create;
  result := FServiceTypeList;
end;

Function TFhirSchedule.GetHasServiceTypeList : boolean;
begin
  result := (FServiceTypeList <> nil) and (FServiceTypeList.count > 0);
end;

Function TFhirSchedule.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

Function TFhirSchedule.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

Function TFhirSchedule.GetActorList : TFhirReferenceList{TFhirPatient};
begin
  if FActorList = nil then
    FActorList := TFhirReferenceList{TFhirPatient}.Create;
  result := FActorList;
end;

Function TFhirSchedule.GetHasActorList : boolean;
begin
  result := (FActorList <> nil) and (FActorList.count > 0);
end;

Procedure TFhirSchedule.SetPlanningHorizon(value : TFhirPeriod);
begin
  FPlanningHorizon.free;
  FPlanningHorizon := value;
end;

Procedure TFhirSchedule.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirSchedule.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirSchedule.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.Create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

function TFhirSchedule.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FidentifierList.sizeInBytes(magic));
  inc(result, FActive.sizeInBytes(magic));
  inc(result, FserviceCategoryList.sizeInBytes(magic));
  inc(result, FserviceTypeList.sizeInBytes(magic));
  inc(result, FspecialtyList.sizeInBytes(magic));
  inc(result, FactorList.sizeInBytes(magic));
  inc(result, FPlanningHorizon.sizeInBytes(magic));
  inc(result, FComment.sizeInBytes(magic));
end;

{ TFhirScheduleListEnumerator }

Constructor TFhirScheduleListEnumerator.Create(list : TFhirScheduleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirScheduleListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirScheduleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirScheduleListEnumerator.GetCurrent : TFhirSchedule;
begin
  Result := FList[FIndex];
end;

function TFhirScheduleListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirScheduleList }
function TFhirScheduleList.AddItem(value: TFhirSchedule): TFhirSchedule;
begin
  add(value);
  result := value;
end;

function TFhirScheduleList.Append: TFhirSchedule;
begin
  result := TFhirSchedule.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirScheduleList.ClearItems;
begin
  Clear;
end;

function TFhirScheduleList.GetEnumerator : TFhirScheduleListEnumerator;
begin
  result := TFhirScheduleListEnumerator.Create(self.link);
end;

function TFhirScheduleList.Clone: TFhirScheduleList;
begin
  result := TFhirScheduleList(inherited Clone);
end;

function TFhirScheduleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirScheduleList.GetItemN(index: Integer): TFhirSchedule;
begin
  result := TFhirSchedule(ObjectByIndex[index]);
end;

function TFhirScheduleList.ItemClass: TFslObjectClass;
begin
  result := TFhirSchedule;
end;
function TFhirScheduleList.IndexOf(value: TFhirSchedule): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirScheduleList.Insert(index: Integer): TFhirSchedule;
begin
  result := TFhirSchedule.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirScheduleList.InsertItem(index: Integer; value: TFhirSchedule);
begin
  assert(value is TFhirSchedule);
  Inherited Insert(index, value);
end;

function TFhirScheduleList.Item(index: Integer): TFhirSchedule;
begin
  result := TFhirSchedule(ObjectByIndex[index]);
end;

function TFhirScheduleList.Link: TFhirScheduleList;
begin
  result := TFhirScheduleList(inherited Link);
end;

procedure TFhirScheduleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirScheduleList.SetItemByIndex(index: Integer; value: TFhirSchedule);
begin
  assert(value is TFhirSchedule);
  FhirSchedules[index] := value;
end;

procedure TFhirScheduleList.SetItemN(index: Integer; value: TFhirSchedule);
begin
  assert(value is TFhirSchedule);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SCHEDULE}

{$IFDEF FHIR_SLOT}

{ TFhirSlot }

constructor TFhirSlot.Create;
begin
  inherited;
end;

destructor TFhirSlot.Destroy;
begin
  FIdentifierList.free;
  FServiceCategoryList.free;
  FServiceTypeList.free;
  FSpecialtyList.free;
  FAppointmentType.free;
  FSchedule.free;
  FStatus.free;
  FStart.free;
  FEnd_.free;
  FOverbooked.free;
  FComment.free;
  inherited;
end;

function TFhirSlot.GetResourceType : TFhirResourceType;
begin
  result := frtSlot;
end;

procedure TFhirSlot.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSlot(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSlot(oSource).FIdentifierList);
  end;
  if (TFhirSlot(oSource).FServiceCategoryList = nil) then
  begin
    FServiceCategoryList.free;
    FServiceCategoryList := nil;
  end
  else
  begin
    if FServiceCategoryList = nil then
      FServiceCategoryList := TFhirCodeableConceptList.Create;
    FServiceCategoryList.Assign(TFhirSlot(oSource).FServiceCategoryList);
  end;
  if (TFhirSlot(oSource).FServiceTypeList = nil) then
  begin
    FServiceTypeList.free;
    FServiceTypeList := nil;
  end
  else
  begin
    if FServiceTypeList = nil then
      FServiceTypeList := TFhirCodeableConceptList.Create;
    FServiceTypeList.Assign(TFhirSlot(oSource).FServiceTypeList);
  end;
  if (TFhirSlot(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirSlot(oSource).FSpecialtyList);
  end;
  appointmentType := TFhirSlot(oSource).appointmentType.Clone;
  schedule := TFhirSlot(oSource).schedule.Clone;
  FStatus := TFhirSlot(oSource).FStatus.Link;
  startElement := TFhirSlot(oSource).startElement.Clone;
  end_Element := TFhirSlot(oSource).end_Element.Clone;
  overbookedElement := TFhirSlot(oSource).overbookedElement.Clone;
  commentElement := TFhirSlot(oSource).commentElement.Clone;
end;

procedure TFhirSlot.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'serviceCategory') Then
    list.addAll(self, 'serviceCategory', FServiceCategoryList);
  if (child_name = 'serviceType') Then
    list.addAll(self, 'serviceType', FServiceTypeList);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'appointmentType') Then
     list.add(self.link, 'appointmentType', FAppointmentType.Link);
  if (child_name = 'schedule') Then
     list.add(self.link, 'schedule', FSchedule.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'overbooked') Then
     list.add(self.link, 'overbooked', FOverbooked.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirSlot.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'serviceCategory', 'CodeableConcept', true, TFhirCodeableConcept, FServiceCategoryList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'serviceType', 'CodeableConcept', true, TFhirCodeableConcept, FServiceTypeList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link)){3};
  oList.add(TFHIRProperty.Create(self, 'appointmentType', 'CodeableConcept', false, TFhirCodeableConcept, FAppointmentType.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'schedule', 'Reference(Schedule)', false, TFhirReference{TFhirSchedule}, FSchedule.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.Create(self, 'start', 'instant', false, TFhirInstant, FStart.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'end', 'instant', false, TFhirInstant, FEnd_.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'overbooked', 'boolean', false, TFhirBoolean, FOverbooked.Link));{2}
  oList.add(TFHIRProperty.Create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
end;

function TFhirSlot.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'serviceCategory') then
  begin
    ServiceCategoryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'serviceType') then
  begin
    ServiceTypeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'appointmentType') then
  begin
    AppointmentType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'schedule') then
  begin
    Schedule := propValue as TFhirReference{TFhirSchedule}{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSlotstatusEnum, CODES_TFhirSlotstatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'start') then
  begin
    StartElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'overbooked') then
  begin
    OverbookedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSlot.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'serviceCategory') then ServiceCategoryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'serviceType') then ServiceTypeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirSlot.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'serviceCategory') then result := ServiceCategoryList.new(){2}
  else if (propName = 'serviceType') then result := ServiceTypeList.new(){2}
  else if (propName = 'specialty') then result := SpecialtyList.new(){2}
  else if (propName = 'appointmentType') then result := TFhirCodeableConcept.Create(){4b}
  else if (propName = 'schedule') then result := TFhirReference{TFhirSchedule}.Create(){4b}
  else if (propName = 'start') then result := TFhirInstant.Create() {5b}
  else if (propName = 'end') then result := TFhirInstant.Create() {5b}
  else if (propName = 'overbooked') then result := TFhirBoolean.Create() {5b}
  else if (propName = 'comment') then result := TFhirString.Create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSlot.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'serviceCategory') then result := 'CodeableConcept'
  else if (propName = 'serviceType') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'appointmentType') then result := 'CodeableConcept'
  else if (propName = 'schedule') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'start') then result := 'instant'
  else if (propName = 'end') then result := 'instant'
  else if (propName = 'overbooked') then result := 'boolean'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSlot.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'serviceCategory') then deletePropertyValue('serviceCategory', ServiceCategoryList, value) {2}
  else if (propName = 'serviceType') then deletePropertyValue('serviceType', ServiceTypeList, value) {2}
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value) {2}
  else if (propName = 'appointmentType') then AppointmentTypeElement := nil
  else if (propName = 'schedule') then ScheduleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'overbooked') then OverbookedElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSlot.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'serviceCategory') then replacePropertyValue('serviceCategory', ServiceCategoryList, existing, new) {2}
  else if (propName = 'serviceType') then replacePropertyValue('serviceType', ServiceTypeList, existing, new) {2}
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new) {2}
  else if (propName = 'appointmentType') then AppointmentTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'schedule') then ScheduleElement := new as TFhirReference{TFhirSchedule}{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSlotstatusEnum, CODES_TFhirSlotstatusEnum, new){4}
  else if (propName = 'start') then StartElement := asInstant(new){5b}
  else if (propName = 'end') then End_Element := asInstant(new){5b}
  else if (propName = 'overbooked') then OverbookedElement := asBoolean(new){5b}
  else if (propName = 'comment') then CommentElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSlot.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'serviceCategory') then ServiceCategoryList.move(source, destination){2a}
  else if (propName = 'serviceType') then ServiceTypeList.move(source, destination){2a}
  else if (propName = 'specialty') then SpecialtyList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSlot.fhirType : string;
begin
  result := 'Slot';
end;

function TFhirSlot.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FserviceCategoryList) and isEmptyProp(FserviceTypeList) and isEmptyProp(FspecialtyList) and isEmptyProp(FAppointmentType) and isEmptyProp(FSchedule) and isEmptyProp(FStatus) and isEmptyProp(FStart) and isEmptyProp(FEnd_) and isEmptyProp(FOverbooked) and isEmptyProp(FComment);
end;

function TFhirSlot.equals(other : TObject) : boolean; 
var
  o : TFhirSlot;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSlot)) then
    result := false
  else
  begin
    o := TFhirSlot(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(serviceCategoryList, o.serviceCategoryList, true) and 
      compareDeep(serviceTypeList, o.serviceTypeList, true) and compareDeep(specialtyList, o.specialtyList, true) and 
      compareDeep(appointmentTypeElement, o.appointmentTypeElement, true) and compareDeep(scheduleElement, o.scheduleElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(startElement, o.startElement, true) and 
      compareDeep(end_Element, o.end_Element, true) and compareDeep(overbookedElement, o.overbookedElement, true) and 
      compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirSlot.Link : TFhirSlot;
begin
  result := TFhirSlot(inherited Link);
end;

function TFhirSlot.Clone : TFhirSlot;
begin
  result := TFhirSlot(inherited Clone);
end;

procedure TFhirSlot.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('serviceCategory');
  fields.add('serviceType');
  fields.add('specialty');
  fields.add('appointmentType');
  fields.add('schedule');
  fields.add('status');
  fields.add('start');
  fields.add('end');
  fields.add('overbooked');
  fields.add('comment');
end;

{ TFhirSlot }

Function TFhirSlot.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirSlot.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirSlot.GetServiceCategoryList : TFhirCodeableConceptList;
begin
  if FServiceCategoryList = nil then
    FServiceCategoryList := TFhirCodeableConceptList.Create;
  result := FServiceCategoryList;
end;

Function TFhirSlot.GetHasServiceCategoryList : boolean;
begin
  result := (FServiceCategoryList <> nil) and (FServiceCategoryList.count > 0);
end;

Function TFhirSlot.GetServiceTypeList : TFhirCodeableConceptList;
begin
  if FServiceTypeList = nil then
    FServiceTypeList := TFhirCodeableConceptList.Create;
  result := FServiceTypeList;
end;

Function TFhirSlot.GetHasServiceTypeList : boolean;
begin
  result := (FServiceTypeList <> nil) and (FServiceTypeList.count > 0);
end;

Function TFhirSlot.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

Function TFhirSlot.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

Procedure TFhirSlot.SetAppointmentType(value : TFhirCodeableConcept);
begin
  FAppointmentType.free;
  FAppointmentType := value;
end;

Procedure TFhirSlot.SetSchedule(value : TFhirReference{TFhirSchedule});
begin
  FSchedule.free;
  FSchedule := value;
end;

Procedure TFhirSlot.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirSlot.GetStatusST : TFhirSlotstatusEnum;
begin
  if FStatus = nil then
    result := TFhirSlotstatusEnum(0)
  else
    result := TFhirSlotstatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSlotstatusEnum, FStatus.value));
end;

Procedure TFhirSlot.SetStatusST(value : TFhirSlotstatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.Create(SYSTEMS_TFhirSlotstatusEnum[value], CODES_TFhirSlotstatusEnum[value]);
end;

Procedure TFhirSlot.SetStart(value : TFhirInstant);
begin
  FStart.free;
  FStart := value;
end;

Function TFhirSlot.GetStartST : TFslDateTime;
begin
  if FStart = nil then
    result := TFslDateTime.makeNull
  else
    result := FStart.value;
end;

Procedure TFhirSlot.SetStartST(value : TFslDateTime);
begin
  if FStart = nil then
    FStart := TFhirInstant.Create;
  FStart.value := value
end;

Procedure TFhirSlot.SetEnd_(value : TFhirInstant);
begin
  FEnd_.free;
  FEnd_ := value;
end;

Function TFhirSlot.GetEnd_ST : TFslDateTime;
begin
  if FEnd_ = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnd_.value;
end;

Procedure TFhirSlot.SetEnd_ST(value : TFslDateTime);
begin
  if FEnd_ = nil then
    FEnd_ := TFhirInstant.Create;
  FEnd_.value := value
end;

Procedure TFhirSlot.SetOverbooked(value : TFhirBoolean);
begin
  FOverbooked.free;
  FOverbooked := value;
end;

Function TFhirSlot.GetOverbookedST : Boolean;
begin
  if FOverbooked = nil then
    result := false
  else
    result := FOverbooked.value;
end;

Procedure TFhirSlot.SetOverbookedST(value : Boolean);
begin
  if FOverbooked = nil then
    FOverbooked := TFhirBoolean.Create;
  FOverbooked.value := value
end;

Procedure TFhirSlot.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirSlot.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirSlot.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.Create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

function TFhirSlot.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FidentifierList.sizeInBytes(magic));
  inc(result, FserviceCategoryList.sizeInBytes(magic));
  inc(result, FserviceTypeList.sizeInBytes(magic));
  inc(result, FspecialtyList.sizeInBytes(magic));
  inc(result, FAppointmentType.sizeInBytes(magic));
  inc(result, FSchedule.sizeInBytes(magic));
  inc(result, FStatus.sizeInBytes(magic));
  inc(result, FStart.sizeInBytes(magic));
  inc(result, FEnd_.sizeInBytes(magic));
  inc(result, FOverbooked.sizeInBytes(magic));
  inc(result, FComment.sizeInBytes(magic));
end;

{ TFhirSlotListEnumerator }

Constructor TFhirSlotListEnumerator.Create(list : TFhirSlotList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSlotListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirSlotListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSlotListEnumerator.GetCurrent : TFhirSlot;
begin
  Result := FList[FIndex];
end;

function TFhirSlotListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSlotList }
function TFhirSlotList.AddItem(value: TFhirSlot): TFhirSlot;
begin
  add(value);
  result := value;
end;

function TFhirSlotList.Append: TFhirSlot;
begin
  result := TFhirSlot.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSlotList.ClearItems;
begin
  Clear;
end;

function TFhirSlotList.GetEnumerator : TFhirSlotListEnumerator;
begin
  result := TFhirSlotListEnumerator.Create(self.link);
end;

function TFhirSlotList.Clone: TFhirSlotList;
begin
  result := TFhirSlotList(inherited Clone);
end;

function TFhirSlotList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSlotList.GetItemN(index: Integer): TFhirSlot;
begin
  result := TFhirSlot(ObjectByIndex[index]);
end;

function TFhirSlotList.ItemClass: TFslObjectClass;
begin
  result := TFhirSlot;
end;
function TFhirSlotList.IndexOf(value: TFhirSlot): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSlotList.Insert(index: Integer): TFhirSlot;
begin
  result := TFhirSlot.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSlotList.InsertItem(index: Integer; value: TFhirSlot);
begin
  assert(value is TFhirSlot);
  Inherited Insert(index, value);
end;

function TFhirSlotList.Item(index: Integer): TFhirSlot;
begin
  result := TFhirSlot(ObjectByIndex[index]);
end;

function TFhirSlotList.Link: TFhirSlotList;
begin
  result := TFhirSlotList(inherited Link);
end;

procedure TFhirSlotList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSlotList.SetItemByIndex(index: Integer; value: TFhirSlot);
begin
  assert(value is TFhirSlot);
  FhirSlots[index] := value;
end;

procedure TFhirSlotList.SetItemN(index: Integer; value: TFhirSlot);
begin
  assert(value is TFhirSlot);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SLOT}

end.

